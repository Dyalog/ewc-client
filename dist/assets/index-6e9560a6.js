function _mergeNamespaces(n10, m3) {
  for (var i16 = 0; i16 < m3.length; i16++) {
    const e3 = m3[i16];
    if (typeof e3 !== "string" && !Array.isArray(e3)) {
      for (const k3 in e3) {
        if (k3 !== "default" && !(k3 in n10)) {
          const d8 = Object.getOwnPropertyDescriptor(e3, k3);
          if (d8) {
            Object.defineProperty(n10, k3, d8.get ? d8 : {
              enumerable: true,
              get: () => e3[k3]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n10, Symbol.toStringTag, { value: "Module" }));
}
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity)
      fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy)
      fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x3) {
  return x3 && x3.__esModule && Object.prototype.hasOwnProperty.call(x3, "default") ? x3["default"] : x3;
}
function getAugmentedNamespace(n10) {
  if (n10.__esModule)
    return n10;
  var f4 = n10.default;
  if (typeof f4 == "function") {
    var a9 = function a10() {
      if (this instanceof a10) {
        return Reflect.construct(f4, arguments, this.constructor);
      }
      return f4.apply(this, arguments);
    };
    a9.prototype = f4.prototype;
  } else
    a9 = {};
  Object.defineProperty(a9, "__esModule", { value: true });
  Object.keys(n10).forEach(function(k3) {
    var d8 = Object.getOwnPropertyDescriptor(n10, k3);
    Object.defineProperty(a9, k3, d8.get ? d8 : {
      enumerable: true,
      get: function() {
        return n10[k3];
      }
    });
  });
  return a9;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$u = Symbol.for("react.element"), n$C = Symbol.for("react.portal"), p$C = Symbol.for("react.fragment"), q$8 = Symbol.for("react.strict_mode"), r$s = Symbol.for("react.profiler"), t$s = Symbol.for("react.provider"), u$r = Symbol.for("react.context"), v$h = Symbol.for("react.forward_ref"), w$e = Symbol.for("react.suspense"), x$m = Symbol.for("react.memo"), y$d = Symbol.for("react.lazy"), z$b = Symbol.iterator;
function A$e(a9) {
  if (null === a9 || "object" !== typeof a9)
    return null;
  a9 = z$b && a9[z$b] || a9["@@iterator"];
  return "function" === typeof a9 ? a9 : null;
}
var B$9 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$h = Object.assign, D$7 = {};
function E$e(a9, b2, e3) {
  this.props = a9;
  this.context = b2;
  this.refs = D$7;
  this.updater = e3 || B$9;
}
E$e.prototype.isReactComponent = {};
E$e.prototype.setState = function(a9, b2) {
  if ("object" !== typeof a9 && "function" !== typeof a9 && null != a9)
    throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a9, b2, "setState");
};
E$e.prototype.forceUpdate = function(a9) {
  this.updater.enqueueForceUpdate(this, a9, "forceUpdate");
};
function F$5() {
}
F$5.prototype = E$e.prototype;
function G$b(a9, b2, e3) {
  this.props = a9;
  this.context = b2;
  this.refs = D$7;
  this.updater = e3 || B$9;
}
var H$6 = G$b.prototype = new F$5();
H$6.constructor = G$b;
C$h(H$6, E$e.prototype);
H$6.isPureReactComponent = true;
var I$f = Array.isArray, J$7 = Object.prototype.hasOwnProperty, K$8 = { current: null }, L$e = { key: true, ref: true, __self: true, __source: true };
function M$d(a9, b2, e3) {
  var d8, c6 = {}, k3 = null, h3 = null;
  if (null != b2)
    for (d8 in void 0 !== b2.ref && (h3 = b2.ref), void 0 !== b2.key && (k3 = "" + b2.key), b2)
      J$7.call(b2, d8) && !L$e.hasOwnProperty(d8) && (c6[d8] = b2[d8]);
  var g6 = arguments.length - 2;
  if (1 === g6)
    c6.children = e3;
  else if (1 < g6) {
    for (var f4 = Array(g6), m3 = 0; m3 < g6; m3++)
      f4[m3] = arguments[m3 + 2];
    c6.children = f4;
  }
  if (a9 && a9.defaultProps)
    for (d8 in g6 = a9.defaultProps, g6)
      void 0 === c6[d8] && (c6[d8] = g6[d8]);
  return { $$typeof: l$u, type: a9, key: k3, ref: h3, props: c6, _owner: K$8.current };
}
function N$b(a9, b2) {
  return { $$typeof: l$u, type: a9.type, key: b2, ref: a9.ref, props: a9.props, _owner: a9._owner };
}
function O$b(a9) {
  return "object" === typeof a9 && null !== a9 && a9.$$typeof === l$u;
}
function escape(a9) {
  var b2 = { "=": "=0", ":": "=2" };
  return "$" + a9.replace(/[=:]/g, function(a10) {
    return b2[a10];
  });
}
var P$e = /\/+/g;
function Q$8(a9, b2) {
  return "object" === typeof a9 && null !== a9 && null != a9.key ? escape("" + a9.key) : b2.toString(36);
}
function R$9(a9, b2, e3, d8, c6) {
  var k3 = typeof a9;
  if ("undefined" === k3 || "boolean" === k3)
    a9 = null;
  var h3 = false;
  if (null === a9)
    h3 = true;
  else
    switch (k3) {
      case "string":
      case "number":
        h3 = true;
        break;
      case "object":
        switch (a9.$$typeof) {
          case l$u:
          case n$C:
            h3 = true;
        }
    }
  if (h3)
    return h3 = a9, c6 = c6(h3), a9 = "" === d8 ? "." + Q$8(h3, 0) : d8, I$f(c6) ? (e3 = "", null != a9 && (e3 = a9.replace(P$e, "$&/") + "/"), R$9(c6, b2, e3, "", function(a10) {
      return a10;
    })) : null != c6 && (O$b(c6) && (c6 = N$b(c6, e3 + (!c6.key || h3 && h3.key === c6.key ? "" : ("" + c6.key).replace(P$e, "$&/") + "/") + a9)), b2.push(c6)), 1;
  h3 = 0;
  d8 = "" === d8 ? "." : d8 + ":";
  if (I$f(a9))
    for (var g6 = 0; g6 < a9.length; g6++) {
      k3 = a9[g6];
      var f4 = d8 + Q$8(k3, g6);
      h3 += R$9(k3, b2, e3, f4, c6);
    }
  else if (f4 = A$e(a9), "function" === typeof f4)
    for (a9 = f4.call(a9), g6 = 0; !(k3 = a9.next()).done; )
      k3 = k3.value, f4 = d8 + Q$8(k3, g6++), h3 += R$9(k3, b2, e3, f4, c6);
  else if ("object" === k3)
    throw b2 = String(a9), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a9).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
  return h3;
}
function S$d(a9, b2, e3) {
  if (null == a9)
    return a9;
  var d8 = [], c6 = 0;
  R$9(a9, d8, "", "", function(a10) {
    return b2.call(e3, a10, c6++);
  });
  return d8;
}
function T$b(a9) {
  if (-1 === a9._status) {
    var b2 = a9._result;
    b2 = b2();
    b2.then(function(b3) {
      if (0 === a9._status || -1 === a9._status)
        a9._status = 1, a9._result = b3;
    }, function(b3) {
      if (0 === a9._status || -1 === a9._status)
        a9._status = 2, a9._result = b3;
    });
    -1 === a9._status && (a9._status = 0, a9._result = b2);
  }
  if (1 === a9._status)
    return a9._result.default;
  throw a9._result;
}
var U$7 = { current: null }, V$9 = { transition: null }, W$6 = { ReactCurrentDispatcher: U$7, ReactCurrentBatchConfig: V$9, ReactCurrentOwner: K$8 };
function X$6() {
  throw Error("act(...) is not supported in production builds of React.");
}
react_production_min.Children = { map: S$d, forEach: function(a9, b2, e3) {
  S$d(a9, function() {
    b2.apply(this, arguments);
  }, e3);
}, count: function(a9) {
  var b2 = 0;
  S$d(a9, function() {
    b2++;
  });
  return b2;
}, toArray: function(a9) {
  return S$d(a9, function(a10) {
    return a10;
  }) || [];
}, only: function(a9) {
  if (!O$b(a9))
    throw Error("React.Children.only expected to receive a single React element child.");
  return a9;
} };
react_production_min.Component = E$e;
react_production_min.Fragment = p$C;
react_production_min.Profiler = r$s;
react_production_min.PureComponent = G$b;
react_production_min.StrictMode = q$8;
react_production_min.Suspense = w$e;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$6;
react_production_min.act = X$6;
react_production_min.cloneElement = function(a9, b2, e3) {
  if (null === a9 || void 0 === a9)
    throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a9 + ".");
  var d8 = C$h({}, a9.props), c6 = a9.key, k3 = a9.ref, h3 = a9._owner;
  if (null != b2) {
    void 0 !== b2.ref && (k3 = b2.ref, h3 = K$8.current);
    void 0 !== b2.key && (c6 = "" + b2.key);
    if (a9.type && a9.type.defaultProps)
      var g6 = a9.type.defaultProps;
    for (f4 in b2)
      J$7.call(b2, f4) && !L$e.hasOwnProperty(f4) && (d8[f4] = void 0 === b2[f4] && void 0 !== g6 ? g6[f4] : b2[f4]);
  }
  var f4 = arguments.length - 2;
  if (1 === f4)
    d8.children = e3;
  else if (1 < f4) {
    g6 = Array(f4);
    for (var m3 = 0; m3 < f4; m3++)
      g6[m3] = arguments[m3 + 2];
    d8.children = g6;
  }
  return { $$typeof: l$u, type: a9.type, key: c6, ref: k3, props: d8, _owner: h3 };
};
react_production_min.createContext = function(a9) {
  a9 = { $$typeof: u$r, _currentValue: a9, _currentValue2: a9, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a9.Provider = { $$typeof: t$s, _context: a9 };
  return a9.Consumer = a9;
};
react_production_min.createElement = M$d;
react_production_min.createFactory = function(a9) {
  var b2 = M$d.bind(null, a9);
  b2.type = a9;
  return b2;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a9) {
  return { $$typeof: v$h, render: a9 };
};
react_production_min.isValidElement = O$b;
react_production_min.lazy = function(a9) {
  return { $$typeof: y$d, _payload: { _status: -1, _result: a9 }, _init: T$b };
};
react_production_min.memo = function(a9, b2) {
  return { $$typeof: x$m, type: a9, compare: void 0 === b2 ? null : b2 };
};
react_production_min.startTransition = function(a9) {
  var b2 = V$9.transition;
  V$9.transition = {};
  try {
    a9();
  } finally {
    V$9.transition = b2;
  }
};
react_production_min.unstable_act = X$6;
react_production_min.useCallback = function(a9, b2) {
  return U$7.current.useCallback(a9, b2);
};
react_production_min.useContext = function(a9) {
  return U$7.current.useContext(a9);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(a9) {
  return U$7.current.useDeferredValue(a9);
};
react_production_min.useEffect = function(a9, b2) {
  return U$7.current.useEffect(a9, b2);
};
react_production_min.useId = function() {
  return U$7.current.useId();
};
react_production_min.useImperativeHandle = function(a9, b2, e3) {
  return U$7.current.useImperativeHandle(a9, b2, e3);
};
react_production_min.useInsertionEffect = function(a9, b2) {
  return U$7.current.useInsertionEffect(a9, b2);
};
react_production_min.useLayoutEffect = function(a9, b2) {
  return U$7.current.useLayoutEffect(a9, b2);
};
react_production_min.useMemo = function(a9, b2) {
  return U$7.current.useMemo(a9, b2);
};
react_production_min.useReducer = function(a9, b2, e3) {
  return U$7.current.useReducer(a9, b2, e3);
};
react_production_min.useRef = function(a9) {
  return U$7.current.useRef(a9);
};
react_production_min.useState = function(a9) {
  return U$7.current.useState(a9);
};
react_production_min.useSyncExternalStore = function(a9, b2, e3) {
  return U$7.current.useSyncExternalStore(a9, b2, e3);
};
react_production_min.useTransition = function() {
  return U$7.current.useTransition();
};
react_production_min.version = "18.3.1";
{
  react.exports = react_production_min;
}
var reactExports = react.exports;
const t$q = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
const t$r = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: t$q
}, [reactExports]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$j = reactExports, k$c = Symbol.for("react.element"), l$t = Symbol.for("react.fragment"), m$p = Object.prototype.hasOwnProperty, n$B = f$j.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$B = { key: true, ref: true, __self: true, __source: true };
function q$7(c6, a9, g6) {
  var b2, d8 = {}, e3 = null, h3 = null;
  void 0 !== g6 && (e3 = "" + g6);
  void 0 !== a9.key && (e3 = "" + a9.key);
  void 0 !== a9.ref && (h3 = a9.ref);
  for (b2 in a9)
    m$p.call(a9, b2) && !p$B.hasOwnProperty(b2) && (d8[b2] = a9[b2]);
  if (c6 && c6.defaultProps)
    for (b2 in a9 = c6.defaultProps, a9)
      void 0 === d8[b2] && (d8[b2] = a9[b2]);
  return { $$typeof: k$c, type: c6, key: e3, ref: h3, props: d8, _owner: n$B.current };
}
reactJsxRuntime_production_min.Fragment = l$t;
reactJsxRuntime_production_min.jsx = q$7;
reactJsxRuntime_production_min.jsxs = q$7;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
var jsxRuntimeExports = jsxRuntime.exports;
if (!URL.parse) {
  URL.parse = function(url) {
    try {
      return new URL(url);
    } catch (e3) {
      throw new Error("Invalid URL");
    }
  };
}
var client = {};
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  function f4(a9, b2) {
    var c6 = a9.length;
    a9.push(b2);
    a:
      for (; 0 < c6; ) {
        var d8 = c6 - 1 >>> 1, e3 = a9[d8];
        if (0 < g6(e3, b2))
          a9[d8] = b2, a9[c6] = e3, c6 = d8;
        else
          break a;
      }
  }
  function h3(a9) {
    return 0 === a9.length ? null : a9[0];
  }
  function k3(a9) {
    if (0 === a9.length)
      return null;
    var b2 = a9[0], c6 = a9.pop();
    if (c6 !== b2) {
      a9[0] = c6;
      a:
        for (var d8 = 0, e3 = a9.length, w3 = e3 >>> 1; d8 < w3; ) {
          var m3 = 2 * (d8 + 1) - 1, C2 = a9[m3], n10 = m3 + 1, x3 = a9[n10];
          if (0 > g6(C2, c6))
            n10 < e3 && 0 > g6(x3, C2) ? (a9[d8] = x3, a9[n10] = c6, d8 = n10) : (a9[d8] = C2, a9[m3] = c6, d8 = m3);
          else if (n10 < e3 && 0 > g6(x3, c6))
            a9[d8] = x3, a9[n10] = c6, d8 = n10;
          else
            break a;
        }
    }
    return b2;
  }
  function g6(a9, b2) {
    var c6 = a9.sortIndex - b2.sortIndex;
    return 0 !== c6 ? c6 : a9.id - b2.id;
  }
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l7 = performance;
    exports.unstable_now = function() {
      return l7.now();
    };
  } else {
    var p6 = Date, q2 = p6.now();
    exports.unstable_now = function() {
      return p6.now() - q2;
    };
  }
  var r12 = [], t6 = [], u5 = 1, v3 = null, y4 = 3, z3 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
  "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G2(a9) {
    for (var b2 = h3(t6); null !== b2; ) {
      if (null === b2.callback)
        k3(t6);
      else if (b2.startTime <= a9)
        k3(t6), b2.sortIndex = b2.expirationTime, f4(r12, b2);
      else
        break;
      b2 = h3(t6);
    }
  }
  function H3(a9) {
    B2 = false;
    G2(a9);
    if (!A2)
      if (null !== h3(r12))
        A2 = true, I3(J2);
      else {
        var b2 = h3(t6);
        null !== b2 && K3(H3, b2.startTime - a9);
      }
  }
  function J2(a9, b2) {
    A2 = false;
    B2 && (B2 = false, E2(L3), L3 = -1);
    z3 = true;
    var c6 = y4;
    try {
      G2(b2);
      for (v3 = h3(r12); null !== v3 && (!(v3.expirationTime > b2) || a9 && !M3()); ) {
        var d8 = v3.callback;
        if ("function" === typeof d8) {
          v3.callback = null;
          y4 = v3.priorityLevel;
          var e3 = d8(v3.expirationTime <= b2);
          b2 = exports.unstable_now();
          "function" === typeof e3 ? v3.callback = e3 : v3 === h3(r12) && k3(r12);
          G2(b2);
        } else
          k3(r12);
        v3 = h3(r12);
      }
      if (null !== v3)
        var w3 = true;
      else {
        var m3 = h3(t6);
        null !== m3 && K3(H3, m3.startTime - b2);
        w3 = false;
      }
      return w3;
    } finally {
      v3 = null, y4 = c6, z3 = false;
    }
  }
  var N3 = false, O2 = null, L3 = -1, P2 = 5, Q2 = -1;
  function M3() {
    return exports.unstable_now() - Q2 < P2 ? false : true;
  }
  function R2() {
    if (null !== O2) {
      var a9 = exports.unstable_now();
      Q2 = a9;
      var b2 = true;
      try {
        b2 = O2(true, a9);
      } finally {
        b2 ? S2() : (N3 = false, O2 = null);
      }
    } else
      N3 = false;
  }
  var S2;
  if ("function" === typeof F2)
    S2 = function() {
      F2(R2);
    };
  else if ("undefined" !== typeof MessageChannel) {
    var T3 = new MessageChannel(), U3 = T3.port2;
    T3.port1.onmessage = R2;
    S2 = function() {
      U3.postMessage(null);
    };
  } else
    S2 = function() {
      D2(R2, 0);
    };
  function I3(a9) {
    O2 = a9;
    N3 || (N3 = true, S2());
  }
  function K3(a9, b2) {
    L3 = D2(function() {
      a9(exports.unstable_now());
    }, b2);
  }
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a9) {
    a9.callback = null;
  };
  exports.unstable_continueExecution = function() {
    A2 || z3 || (A2 = true, I3(J2));
  };
  exports.unstable_forceFrameRate = function(a9) {
    0 > a9 || 125 < a9 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a9 ? Math.floor(1e3 / a9) : 5;
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return y4;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return h3(r12);
  };
  exports.unstable_next = function(a9) {
    switch (y4) {
      case 1:
      case 2:
      case 3:
        var b2 = 3;
        break;
      default:
        b2 = y4;
    }
    var c6 = y4;
    y4 = b2;
    try {
      return a9();
    } finally {
      y4 = c6;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = function() {
  };
  exports.unstable_runWithPriority = function(a9, b2) {
    switch (a9) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a9 = 3;
    }
    var c6 = y4;
    y4 = a9;
    try {
      return b2();
    } finally {
      y4 = c6;
    }
  };
  exports.unstable_scheduleCallback = function(a9, b2, c6) {
    var d8 = exports.unstable_now();
    "object" === typeof c6 && null !== c6 ? (c6 = c6.delay, c6 = "number" === typeof c6 && 0 < c6 ? d8 + c6 : d8) : c6 = d8;
    switch (a9) {
      case 1:
        var e3 = -1;
        break;
      case 2:
        e3 = 250;
        break;
      case 5:
        e3 = 1073741823;
        break;
      case 4:
        e3 = 1e4;
        break;
      default:
        e3 = 5e3;
    }
    e3 = c6 + e3;
    a9 = { id: u5++, callback: b2, priorityLevel: a9, startTime: c6, expirationTime: e3, sortIndex: -1 };
    c6 > d8 ? (a9.sortIndex = c6, f4(t6, a9), null === h3(r12) && a9 === h3(t6) && (B2 ? (E2(L3), L3 = -1) : B2 = true, K3(H3, c6 - d8))) : (a9.sortIndex = e3, f4(r12, a9), A2 || z3 || (A2 = true, I3(J2)));
    return a9;
  };
  exports.unstable_shouldYield = M3;
  exports.unstable_wrapCallback = function(a9) {
    var b2 = y4;
    return function() {
      var c6 = y4;
      y4 = b2;
      try {
        return a9.apply(this, arguments);
      } finally {
        y4 = c6;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler.exports = scheduler_production_min;
}
var schedulerExports = scheduler.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = reactExports, ca = schedulerExports;
function p$A(a9) {
  for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a9, c6 = 1; c6 < arguments.length; c6++)
    b2 += "&args[]=" + encodeURIComponent(arguments[c6]);
  return "Minified React error #" + a9 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var da = /* @__PURE__ */ new Set(), ea = {};
function fa(a9, b2) {
  ha(a9, b2);
  ha(a9 + "Capture", b2);
}
function ha(a9, b2) {
  ea[a9] = b2;
  for (a9 = 0; a9 < b2.length; a9++)
    da.add(b2[a9]);
}
var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
function oa(a9) {
  if (ja.call(ma, a9))
    return true;
  if (ja.call(la, a9))
    return false;
  if (ka.test(a9))
    return ma[a9] = true;
  la[a9] = true;
  return false;
}
function pa(a9, b2, c6, d8) {
  if (null !== c6 && 0 === c6.type)
    return false;
  switch (typeof b2) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d8)
        return false;
      if (null !== c6)
        return !c6.acceptsBooleans;
      a9 = a9.toLowerCase().slice(0, 5);
      return "data-" !== a9 && "aria-" !== a9;
    default:
      return false;
  }
}
function qa(a9, b2, c6, d8) {
  if (null === b2 || "undefined" === typeof b2 || pa(a9, b2, c6, d8))
    return true;
  if (d8)
    return false;
  if (null !== c6)
    switch (c6.type) {
      case 3:
        return !b2;
      case 4:
        return false === b2;
      case 5:
        return isNaN(b2);
      case 6:
        return isNaN(b2) || 1 > b2;
    }
  return false;
}
function v$g(a9, b2, c6, d8, e3, f4, g6) {
  this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
  this.attributeName = d8;
  this.attributeNamespace = e3;
  this.mustUseProperty = c6;
  this.propertyName = a9;
  this.type = b2;
  this.sanitizeURL = f4;
  this.removeEmptyString = g6;
}
var z$a = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a9) {
  z$a[a9] = new v$g(a9, 0, false, a9, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a9) {
  var b2 = a9[0];
  z$a[b2] = new v$g(b2, 1, false, a9[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a9) {
  z$a[a9] = new v$g(a9, 2, false, a9.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a9) {
  z$a[a9] = new v$g(a9, 2, false, a9, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a9) {
  z$a[a9] = new v$g(a9, 3, false, a9.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a9) {
  z$a[a9] = new v$g(a9, 3, true, a9, null, false, false);
});
["capture", "download"].forEach(function(a9) {
  z$a[a9] = new v$g(a9, 4, false, a9, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a9) {
  z$a[a9] = new v$g(a9, 6, false, a9, null, false, false);
});
["rowSpan", "start"].forEach(function(a9) {
  z$a[a9] = new v$g(a9, 5, false, a9.toLowerCase(), null, false, false);
});
var ra = /[\-:]([a-z])/g;
function sa(a9) {
  return a9[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a9) {
  var b2 = a9.replace(
    ra,
    sa
  );
  z$a[b2] = new v$g(b2, 1, false, a9, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a9) {
  var b2 = a9.replace(ra, sa);
  z$a[b2] = new v$g(b2, 1, false, a9, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a9) {
  var b2 = a9.replace(ra, sa);
  z$a[b2] = new v$g(b2, 1, false, a9, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a9) {
  z$a[a9] = new v$g(a9, 1, false, a9.toLowerCase(), null, false, false);
});
z$a.xlinkHref = new v$g("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a9) {
  z$a[a9] = new v$g(a9, 1, false, a9.toLowerCase(), null, true, true);
});
function ta(a9, b2, c6, d8) {
  var e3 = z$a.hasOwnProperty(b2) ? z$a[b2] : null;
  if (null !== e3 ? 0 !== e3.type : d8 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1])
    qa(b2, c6, e3, d8) && (c6 = null), d8 || null === e3 ? oa(b2) && (null === c6 ? a9.removeAttribute(b2) : a9.setAttribute(b2, "" + c6)) : e3.mustUseProperty ? a9[e3.propertyName] = null === c6 ? 3 === e3.type ? false : "" : c6 : (b2 = e3.attributeName, d8 = e3.attributeNamespace, null === c6 ? a9.removeAttribute(b2) : (e3 = e3.type, c6 = 3 === e3 || 4 === e3 && true === c6 ? "" : "" + c6, d8 ? a9.setAttributeNS(d8, b2, c6) : a9.setAttribute(b2, c6)));
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
var Ia = Symbol.for("react.offscreen");
var Ja = Symbol.iterator;
function Ka(a9) {
  if (null === a9 || "object" !== typeof a9)
    return null;
  a9 = Ja && a9[Ja] || a9["@@iterator"];
  return "function" === typeof a9 ? a9 : null;
}
var A$d = Object.assign, La;
function Ma(a9) {
  if (void 0 === La)
    try {
      throw Error();
    } catch (c6) {
      var b2 = c6.stack.trim().match(/\n( *(at )?)/);
      La = b2 && b2[1] || "";
    }
  return "\n" + La + a9;
}
var Na = false;
function Oa(a9, b2) {
  if (!a9 || Na)
    return "";
  Na = true;
  var c6 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b2)
      if (b2 = function() {
        throw Error();
      }, Object.defineProperty(b2.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b2, []);
        } catch (l7) {
          var d8 = l7;
        }
        Reflect.construct(a9, [], b2);
      } else {
        try {
          b2.call();
        } catch (l7) {
          d8 = l7;
        }
        a9.call(b2.prototype);
      }
    else {
      try {
        throw Error();
      } catch (l7) {
        d8 = l7;
      }
      a9();
    }
  } catch (l7) {
    if (l7 && d8 && "string" === typeof l7.stack) {
      for (var e3 = l7.stack.split("\n"), f4 = d8.stack.split("\n"), g6 = e3.length - 1, h3 = f4.length - 1; 1 <= g6 && 0 <= h3 && e3[g6] !== f4[h3]; )
        h3--;
      for (; 1 <= g6 && 0 <= h3; g6--, h3--)
        if (e3[g6] !== f4[h3]) {
          if (1 !== g6 || 1 !== h3) {
            do
              if (g6--, h3--, 0 > h3 || e3[g6] !== f4[h3]) {
                var k3 = "\n" + e3[g6].replace(" at new ", " at ");
                a9.displayName && k3.includes("<anonymous>") && (k3 = k3.replace("<anonymous>", a9.displayName));
                return k3;
              }
            while (1 <= g6 && 0 <= h3);
          }
          break;
        }
    }
  } finally {
    Na = false, Error.prepareStackTrace = c6;
  }
  return (a9 = a9 ? a9.displayName || a9.name : "") ? Ma(a9) : "";
}
function Pa(a9) {
  switch (a9.tag) {
    case 5:
      return Ma(a9.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a9 = Oa(a9.type, false), a9;
    case 11:
      return a9 = Oa(a9.type.render, false), a9;
    case 1:
      return a9 = Oa(a9.type, true), a9;
    default:
      return "";
  }
}
function Qa(a9) {
  if (null == a9)
    return null;
  if ("function" === typeof a9)
    return a9.displayName || a9.name || null;
  if ("string" === typeof a9)
    return a9;
  switch (a9) {
    case ya:
      return "Fragment";
    case wa:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if ("object" === typeof a9)
    switch (a9.$$typeof) {
      case Ca:
        return (a9.displayName || "Context") + ".Consumer";
      case Ba:
        return (a9._context.displayName || "Context") + ".Provider";
      case Da:
        var b2 = a9.render;
        a9 = a9.displayName;
        a9 || (a9 = b2.displayName || b2.name || "", a9 = "" !== a9 ? "ForwardRef(" + a9 + ")" : "ForwardRef");
        return a9;
      case Ga:
        return b2 = a9.displayName || null, null !== b2 ? b2 : Qa(a9.type) || "Memo";
      case Ha:
        b2 = a9._payload;
        a9 = a9._init;
        try {
          return Qa(a9(b2));
        } catch (c6) {
        }
    }
  return null;
}
function Ra(a9) {
  var b2 = a9.type;
  switch (a9.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b2.displayName || "Context") + ".Consumer";
    case 10:
      return (b2._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a9 = b2.render, a9 = a9.displayName || a9.name || "", b2.displayName || ("" !== a9 ? "ForwardRef(" + a9 + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b2;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(b2);
    case 8:
      return b2 === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b2)
        return b2.displayName || b2.name || null;
      if ("string" === typeof b2)
        return b2;
  }
  return null;
}
function Sa(a9) {
  switch (typeof a9) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a9;
    case "object":
      return a9;
    default:
      return "";
  }
}
function Ta(a9) {
  var b2 = a9.type;
  return (a9 = a9.nodeName) && "input" === a9.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
}
function Ua(a9) {
  var b2 = Ta(a9) ? "checked" : "value", c6 = Object.getOwnPropertyDescriptor(a9.constructor.prototype, b2), d8 = "" + a9[b2];
  if (!a9.hasOwnProperty(b2) && "undefined" !== typeof c6 && "function" === typeof c6.get && "function" === typeof c6.set) {
    var e3 = c6.get, f4 = c6.set;
    Object.defineProperty(a9, b2, { configurable: true, get: function() {
      return e3.call(this);
    }, set: function(a10) {
      d8 = "" + a10;
      f4.call(this, a10);
    } });
    Object.defineProperty(a9, b2, { enumerable: c6.enumerable });
    return { getValue: function() {
      return d8;
    }, setValue: function(a10) {
      d8 = "" + a10;
    }, stopTracking: function() {
      a9._valueTracker = null;
      delete a9[b2];
    } };
  }
}
function Va(a9) {
  a9._valueTracker || (a9._valueTracker = Ua(a9));
}
function Wa(a9) {
  if (!a9)
    return false;
  var b2 = a9._valueTracker;
  if (!b2)
    return true;
  var c6 = b2.getValue();
  var d8 = "";
  a9 && (d8 = Ta(a9) ? a9.checked ? "true" : "false" : a9.value);
  a9 = d8;
  return a9 !== c6 ? (b2.setValue(a9), true) : false;
}
function Xa(a9) {
  a9 = a9 || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a9)
    return null;
  try {
    return a9.activeElement || a9.body;
  } catch (b2) {
    return a9.body;
  }
}
function Ya(a9, b2) {
  var c6 = b2.checked;
  return A$d({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c6 ? c6 : a9._wrapperState.initialChecked });
}
function Za(a9, b2) {
  var c6 = null == b2.defaultValue ? "" : b2.defaultValue, d8 = null != b2.checked ? b2.checked : b2.defaultChecked;
  c6 = Sa(null != b2.value ? b2.value : c6);
  a9._wrapperState = { initialChecked: d8, initialValue: c6, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
}
function ab(a9, b2) {
  b2 = b2.checked;
  null != b2 && ta(a9, "checked", b2, false);
}
function bb(a9, b2) {
  ab(a9, b2);
  var c6 = Sa(b2.value), d8 = b2.type;
  if (null != c6)
    if ("number" === d8) {
      if (0 === c6 && "" === a9.value || a9.value != c6)
        a9.value = "" + c6;
    } else
      a9.value !== "" + c6 && (a9.value = "" + c6);
  else if ("submit" === d8 || "reset" === d8) {
    a9.removeAttribute("value");
    return;
  }
  b2.hasOwnProperty("value") ? cb(a9, b2.type, c6) : b2.hasOwnProperty("defaultValue") && cb(a9, b2.type, Sa(b2.defaultValue));
  null == b2.checked && null != b2.defaultChecked && (a9.defaultChecked = !!b2.defaultChecked);
}
function db(a9, b2, c6) {
  if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
    var d8 = b2.type;
    if (!("submit" !== d8 && "reset" !== d8 || void 0 !== b2.value && null !== b2.value))
      return;
    b2 = "" + a9._wrapperState.initialValue;
    c6 || b2 === a9.value || (a9.value = b2);
    a9.defaultValue = b2;
  }
  c6 = a9.name;
  "" !== c6 && (a9.name = "");
  a9.defaultChecked = !!a9._wrapperState.initialChecked;
  "" !== c6 && (a9.name = c6);
}
function cb(a9, b2, c6) {
  if ("number" !== b2 || Xa(a9.ownerDocument) !== a9)
    null == c6 ? a9.defaultValue = "" + a9._wrapperState.initialValue : a9.defaultValue !== "" + c6 && (a9.defaultValue = "" + c6);
}
var eb = Array.isArray;
function fb(a9, b2, c6, d8) {
  a9 = a9.options;
  if (b2) {
    b2 = {};
    for (var e3 = 0; e3 < c6.length; e3++)
      b2["$" + c6[e3]] = true;
    for (c6 = 0; c6 < a9.length; c6++)
      e3 = b2.hasOwnProperty("$" + a9[c6].value), a9[c6].selected !== e3 && (a9[c6].selected = e3), e3 && d8 && (a9[c6].defaultSelected = true);
  } else {
    c6 = "" + Sa(c6);
    b2 = null;
    for (e3 = 0; e3 < a9.length; e3++) {
      if (a9[e3].value === c6) {
        a9[e3].selected = true;
        d8 && (a9[e3].defaultSelected = true);
        return;
      }
      null !== b2 || a9[e3].disabled || (b2 = a9[e3]);
    }
    null !== b2 && (b2.selected = true);
  }
}
function gb(a9, b2) {
  if (null != b2.dangerouslySetInnerHTML)
    throw Error(p$A(91));
  return A$d({}, b2, { value: void 0, defaultValue: void 0, children: "" + a9._wrapperState.initialValue });
}
function hb(a9, b2) {
  var c6 = b2.value;
  if (null == c6) {
    c6 = b2.children;
    b2 = b2.defaultValue;
    if (null != c6) {
      if (null != b2)
        throw Error(p$A(92));
      if (eb(c6)) {
        if (1 < c6.length)
          throw Error(p$A(93));
        c6 = c6[0];
      }
      b2 = c6;
    }
    null == b2 && (b2 = "");
    c6 = b2;
  }
  a9._wrapperState = { initialValue: Sa(c6) };
}
function ib(a9, b2) {
  var c6 = Sa(b2.value), d8 = Sa(b2.defaultValue);
  null != c6 && (c6 = "" + c6, c6 !== a9.value && (a9.value = c6), null == b2.defaultValue && a9.defaultValue !== c6 && (a9.defaultValue = c6));
  null != d8 && (a9.defaultValue = "" + d8);
}
function jb(a9) {
  var b2 = a9.textContent;
  b2 === a9._wrapperState.initialValue && "" !== b2 && null !== b2 && (a9.value = b2);
}
function kb(a9) {
  switch (a9) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb(a9, b2) {
  return null == a9 || "http://www.w3.org/1999/xhtml" === a9 ? kb(b2) : "http://www.w3.org/2000/svg" === a9 && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a9;
}
var mb, nb = function(a9) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c6, d8, e3) {
    MSApp.execUnsafeLocalFunction(function() {
      return a9(b2, c6, d8, e3);
    });
  } : a9;
}(function(a9, b2) {
  if ("http://www.w3.org/2000/svg" !== a9.namespaceURI || "innerHTML" in a9)
    a9.innerHTML = b2;
  else {
    mb = mb || document.createElement("div");
    mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
    for (b2 = mb.firstChild; a9.firstChild; )
      a9.removeChild(a9.firstChild);
    for (; b2.firstChild; )
      a9.appendChild(b2.firstChild);
  }
});
function ob(a9, b2) {
  if (b2) {
    var c6 = a9.firstChild;
    if (c6 && c6 === a9.lastChild && 3 === c6.nodeType) {
      c6.nodeValue = b2;
      return;
    }
  }
  a9.textContent = b2;
}
var pb = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(a9) {
  qb.forEach(function(b2) {
    b2 = b2 + a9.charAt(0).toUpperCase() + a9.substring(1);
    pb[b2] = pb[a9];
  });
});
function rb(a9, b2, c6) {
  return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c6 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a9) && pb[a9] ? ("" + b2).trim() : b2 + "px";
}
function sb(a9, b2) {
  a9 = a9.style;
  for (var c6 in b2)
    if (b2.hasOwnProperty(c6)) {
      var d8 = 0 === c6.indexOf("--"), e3 = rb(c6, b2[c6], d8);
      "float" === c6 && (c6 = "cssFloat");
      d8 ? a9.setProperty(c6, e3) : a9[c6] = e3;
    }
}
var tb = A$d({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function ub(a9, b2) {
  if (b2) {
    if (tb[a9] && (null != b2.children || null != b2.dangerouslySetInnerHTML))
      throw Error(p$A(137, a9));
    if (null != b2.dangerouslySetInnerHTML) {
      if (null != b2.children)
        throw Error(p$A(60));
      if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML))
        throw Error(p$A(61));
    }
    if (null != b2.style && "object" !== typeof b2.style)
      throw Error(p$A(62));
  }
}
function vb(a9, b2) {
  if (-1 === a9.indexOf("-"))
    return "string" === typeof b2.is;
  switch (a9) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var wb = null;
function xb(a9) {
  a9 = a9.target || a9.srcElement || window;
  a9.correspondingUseElement && (a9 = a9.correspondingUseElement);
  return 3 === a9.nodeType ? a9.parentNode : a9;
}
var yb = null, zb = null, Ab = null;
function Bb(a9) {
  if (a9 = Cb(a9)) {
    if ("function" !== typeof yb)
      throw Error(p$A(280));
    var b2 = a9.stateNode;
    b2 && (b2 = Db(b2), yb(a9.stateNode, a9.type, b2));
  }
}
function Eb(a9) {
  zb ? Ab ? Ab.push(a9) : Ab = [a9] : zb = a9;
}
function Fb() {
  if (zb) {
    var a9 = zb, b2 = Ab;
    Ab = zb = null;
    Bb(a9);
    if (b2)
      for (a9 = 0; a9 < b2.length; a9++)
        Bb(b2[a9]);
  }
}
function Gb(a9, b2) {
  return a9(b2);
}
function Hb() {
}
var Ib = false;
function Jb(a9, b2, c6) {
  if (Ib)
    return a9(b2, c6);
  Ib = true;
  try {
    return Gb(a9, b2, c6);
  } finally {
    if (Ib = false, null !== zb || null !== Ab)
      Hb(), Fb();
  }
}
function Kb(a9, b2) {
  var c6 = a9.stateNode;
  if (null === c6)
    return null;
  var d8 = Db(c6);
  if (null === d8)
    return null;
  c6 = d8[b2];
  a:
    switch (b2) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d8 = !d8.disabled) || (a9 = a9.type, d8 = !("button" === a9 || "input" === a9 || "select" === a9 || "textarea" === a9));
        a9 = !d8;
        break a;
      default:
        a9 = false;
    }
  if (a9)
    return null;
  if (c6 && "function" !== typeof c6)
    throw Error(p$A(231, b2, typeof c6));
  return c6;
}
var Lb = false;
if (ia)
  try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", { get: function() {
      Lb = true;
    } });
    window.addEventListener("test", Mb, Mb);
    window.removeEventListener("test", Mb, Mb);
  } catch (a9) {
    Lb = false;
  }
function Nb(a9, b2, c6, d8, e3, f4, g6, h3, k3) {
  var l7 = Array.prototype.slice.call(arguments, 3);
  try {
    b2.apply(c6, l7);
  } catch (m3) {
    this.onError(m3);
  }
}
var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a9) {
  Ob = true;
  Pb = a9;
} };
function Tb(a9, b2, c6, d8, e3, f4, g6, h3, k3) {
  Ob = false;
  Pb = null;
  Nb.apply(Sb, arguments);
}
function Ub(a9, b2, c6, d8, e3, f4, g6, h3, k3) {
  Tb.apply(this, arguments);
  if (Ob) {
    if (Ob) {
      var l7 = Pb;
      Ob = false;
      Pb = null;
    } else
      throw Error(p$A(198));
    Qb || (Qb = true, Rb = l7);
  }
}
function Vb(a9) {
  var b2 = a9, c6 = a9;
  if (a9.alternate)
    for (; b2.return; )
      b2 = b2.return;
  else {
    a9 = b2;
    do
      b2 = a9, 0 !== (b2.flags & 4098) && (c6 = b2.return), a9 = b2.return;
    while (a9);
  }
  return 3 === b2.tag ? c6 : null;
}
function Wb(a9) {
  if (13 === a9.tag) {
    var b2 = a9.memoizedState;
    null === b2 && (a9 = a9.alternate, null !== a9 && (b2 = a9.memoizedState));
    if (null !== b2)
      return b2.dehydrated;
  }
  return null;
}
function Xb(a9) {
  if (Vb(a9) !== a9)
    throw Error(p$A(188));
}
function Yb(a9) {
  var b2 = a9.alternate;
  if (!b2) {
    b2 = Vb(a9);
    if (null === b2)
      throw Error(p$A(188));
    return b2 !== a9 ? null : a9;
  }
  for (var c6 = a9, d8 = b2; ; ) {
    var e3 = c6.return;
    if (null === e3)
      break;
    var f4 = e3.alternate;
    if (null === f4) {
      d8 = e3.return;
      if (null !== d8) {
        c6 = d8;
        continue;
      }
      break;
    }
    if (e3.child === f4.child) {
      for (f4 = e3.child; f4; ) {
        if (f4 === c6)
          return Xb(e3), a9;
        if (f4 === d8)
          return Xb(e3), b2;
        f4 = f4.sibling;
      }
      throw Error(p$A(188));
    }
    if (c6.return !== d8.return)
      c6 = e3, d8 = f4;
    else {
      for (var g6 = false, h3 = e3.child; h3; ) {
        if (h3 === c6) {
          g6 = true;
          c6 = e3;
          d8 = f4;
          break;
        }
        if (h3 === d8) {
          g6 = true;
          d8 = e3;
          c6 = f4;
          break;
        }
        h3 = h3.sibling;
      }
      if (!g6) {
        for (h3 = f4.child; h3; ) {
          if (h3 === c6) {
            g6 = true;
            c6 = f4;
            d8 = e3;
            break;
          }
          if (h3 === d8) {
            g6 = true;
            d8 = f4;
            c6 = e3;
            break;
          }
          h3 = h3.sibling;
        }
        if (!g6)
          throw Error(p$A(189));
      }
    }
    if (c6.alternate !== d8)
      throw Error(p$A(190));
  }
  if (3 !== c6.tag)
    throw Error(p$A(188));
  return c6.stateNode.current === c6 ? a9 : b2;
}
function Zb(a9) {
  a9 = Yb(a9);
  return null !== a9 ? $b(a9) : null;
}
function $b(a9) {
  if (5 === a9.tag || 6 === a9.tag)
    return a9;
  for (a9 = a9.child; null !== a9; ) {
    var b2 = $b(a9);
    if (null !== b2)
      return b2;
    a9 = a9.sibling;
  }
  return null;
}
var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B$8 = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
function mc(a9) {
  if (lc && "function" === typeof lc.onCommitFiberRoot)
    try {
      lc.onCommitFiberRoot(kc, a9, void 0, 128 === (a9.current.flags & 128));
    } catch (b2) {
    }
}
var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
function nc(a9) {
  a9 >>>= 0;
  return 0 === a9 ? 32 : 31 - (pc(a9) / qc | 0) | 0;
}
var rc = 64, sc = 4194304;
function tc(a9) {
  switch (a9 & -a9) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a9 & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a9 & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a9;
  }
}
function uc(a9, b2) {
  var c6 = a9.pendingLanes;
  if (0 === c6)
    return 0;
  var d8 = 0, e3 = a9.suspendedLanes, f4 = a9.pingedLanes, g6 = c6 & 268435455;
  if (0 !== g6) {
    var h3 = g6 & ~e3;
    0 !== h3 ? d8 = tc(h3) : (f4 &= g6, 0 !== f4 && (d8 = tc(f4)));
  } else
    g6 = c6 & ~e3, 0 !== g6 ? d8 = tc(g6) : 0 !== f4 && (d8 = tc(f4));
  if (0 === d8)
    return 0;
  if (0 !== b2 && b2 !== d8 && 0 === (b2 & e3) && (e3 = d8 & -d8, f4 = b2 & -b2, e3 >= f4 || 16 === e3 && 0 !== (f4 & 4194240)))
    return b2;
  0 !== (d8 & 4) && (d8 |= c6 & 16);
  b2 = a9.entangledLanes;
  if (0 !== b2)
    for (a9 = a9.entanglements, b2 &= d8; 0 < b2; )
      c6 = 31 - oc(b2), e3 = 1 << c6, d8 |= a9[c6], b2 &= ~e3;
  return d8;
}
function vc(a9, b2) {
  switch (a9) {
    case 1:
    case 2:
    case 4:
      return b2 + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b2 + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc(a9, b2) {
  for (var c6 = a9.suspendedLanes, d8 = a9.pingedLanes, e3 = a9.expirationTimes, f4 = a9.pendingLanes; 0 < f4; ) {
    var g6 = 31 - oc(f4), h3 = 1 << g6, k3 = e3[g6];
    if (-1 === k3) {
      if (0 === (h3 & c6) || 0 !== (h3 & d8))
        e3[g6] = vc(h3, b2);
    } else
      k3 <= b2 && (a9.expiredLanes |= h3);
    f4 &= ~h3;
  }
}
function xc(a9) {
  a9 = a9.pendingLanes & -1073741825;
  return 0 !== a9 ? a9 : a9 & 1073741824 ? 1073741824 : 0;
}
function yc() {
  var a9 = rc;
  rc <<= 1;
  0 === (rc & 4194240) && (rc = 64);
  return a9;
}
function zc(a9) {
  for (var b2 = [], c6 = 0; 31 > c6; c6++)
    b2.push(a9);
  return b2;
}
function Ac(a9, b2, c6) {
  a9.pendingLanes |= b2;
  536870912 !== b2 && (a9.suspendedLanes = 0, a9.pingedLanes = 0);
  a9 = a9.eventTimes;
  b2 = 31 - oc(b2);
  a9[b2] = c6;
}
function Bc(a9, b2) {
  var c6 = a9.pendingLanes & ~b2;
  a9.pendingLanes = b2;
  a9.suspendedLanes = 0;
  a9.pingedLanes = 0;
  a9.expiredLanes &= b2;
  a9.mutableReadLanes &= b2;
  a9.entangledLanes &= b2;
  b2 = a9.entanglements;
  var d8 = a9.eventTimes;
  for (a9 = a9.expirationTimes; 0 < c6; ) {
    var e3 = 31 - oc(c6), f4 = 1 << e3;
    b2[e3] = 0;
    d8[e3] = -1;
    a9[e3] = -1;
    c6 &= ~f4;
  }
}
function Cc(a9, b2) {
  var c6 = a9.entangledLanes |= b2;
  for (a9 = a9.entanglements; c6; ) {
    var d8 = 31 - oc(c6), e3 = 1 << d8;
    e3 & b2 | a9[d8] & b2 && (a9[d8] |= b2);
    c6 &= ~e3;
  }
}
var C$g = 0;
function Dc(a9) {
  a9 &= -a9;
  return 1 < a9 ? 4 < a9 ? 0 !== (a9 & 268435455) ? 16 : 536870912 : 4 : 1;
}
var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a9, b2) {
  switch (a9) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(b2.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b2.pointerId);
  }
}
function Tc(a9, b2, c6, d8, e3, f4) {
  if (null === a9 || a9.nativeEvent !== f4)
    return a9 = { blockedOn: b2, domEventName: c6, eventSystemFlags: d8, nativeEvent: f4, targetContainers: [e3] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a9;
  a9.eventSystemFlags |= d8;
  b2 = a9.targetContainers;
  null !== e3 && -1 === b2.indexOf(e3) && b2.push(e3);
  return a9;
}
function Uc(a9, b2, c6, d8, e3) {
  switch (b2) {
    case "focusin":
      return Lc = Tc(Lc, a9, b2, c6, d8, e3), true;
    case "dragenter":
      return Mc = Tc(Mc, a9, b2, c6, d8, e3), true;
    case "mouseover":
      return Nc = Tc(Nc, a9, b2, c6, d8, e3), true;
    case "pointerover":
      var f4 = e3.pointerId;
      Oc.set(f4, Tc(Oc.get(f4) || null, a9, b2, c6, d8, e3));
      return true;
    case "gotpointercapture":
      return f4 = e3.pointerId, Pc.set(f4, Tc(Pc.get(f4) || null, a9, b2, c6, d8, e3)), true;
  }
  return false;
}
function Vc(a9) {
  var b2 = Wc(a9.target);
  if (null !== b2) {
    var c6 = Vb(b2);
    if (null !== c6) {
      if (b2 = c6.tag, 13 === b2) {
        if (b2 = Wb(c6), null !== b2) {
          a9.blockedOn = b2;
          Ic(a9.priority, function() {
            Gc(c6);
          });
          return;
        }
      } else if (3 === b2 && c6.stateNode.current.memoizedState.isDehydrated) {
        a9.blockedOn = 3 === c6.tag ? c6.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a9.blockedOn = null;
}
function Xc(a9) {
  if (null !== a9.blockedOn)
    return false;
  for (var b2 = a9.targetContainers; 0 < b2.length; ) {
    var c6 = Yc(a9.domEventName, a9.eventSystemFlags, b2[0], a9.nativeEvent);
    if (null === c6) {
      c6 = a9.nativeEvent;
      var d8 = new c6.constructor(c6.type, c6);
      wb = d8;
      c6.target.dispatchEvent(d8);
      wb = null;
    } else
      return b2 = Cb(c6), null !== b2 && Fc(b2), a9.blockedOn = c6, false;
    b2.shift();
  }
  return true;
}
function Zc(a9, b2, c6) {
  Xc(a9) && c6.delete(b2);
}
function $c() {
  Jc = false;
  null !== Lc && Xc(Lc) && (Lc = null);
  null !== Mc && Xc(Mc) && (Mc = null);
  null !== Nc && Xc(Nc) && (Nc = null);
  Oc.forEach(Zc);
  Pc.forEach(Zc);
}
function ad(a9, b2) {
  a9.blockedOn === b2 && (a9.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
}
function bd(a9) {
  function b2(b3) {
    return ad(b3, a9);
  }
  if (0 < Kc.length) {
    ad(Kc[0], a9);
    for (var c6 = 1; c6 < Kc.length; c6++) {
      var d8 = Kc[c6];
      d8.blockedOn === a9 && (d8.blockedOn = null);
    }
  }
  null !== Lc && ad(Lc, a9);
  null !== Mc && ad(Mc, a9);
  null !== Nc && ad(Nc, a9);
  Oc.forEach(b2);
  Pc.forEach(b2);
  for (c6 = 0; c6 < Qc.length; c6++)
    d8 = Qc[c6], d8.blockedOn === a9 && (d8.blockedOn = null);
  for (; 0 < Qc.length && (c6 = Qc[0], null === c6.blockedOn); )
    Vc(c6), null === c6.blockedOn && Qc.shift();
}
var cd = ua.ReactCurrentBatchConfig, dd = true;
function ed(a9, b2, c6, d8) {
  var e3 = C$g, f4 = cd.transition;
  cd.transition = null;
  try {
    C$g = 1, fd(a9, b2, c6, d8);
  } finally {
    C$g = e3, cd.transition = f4;
  }
}
function gd(a9, b2, c6, d8) {
  var e3 = C$g, f4 = cd.transition;
  cd.transition = null;
  try {
    C$g = 4, fd(a9, b2, c6, d8);
  } finally {
    C$g = e3, cd.transition = f4;
  }
}
function fd(a9, b2, c6, d8) {
  if (dd) {
    var e3 = Yc(a9, b2, c6, d8);
    if (null === e3)
      hd(a9, b2, d8, id, c6), Sc(a9, d8);
    else if (Uc(e3, a9, b2, c6, d8))
      d8.stopPropagation();
    else if (Sc(a9, d8), b2 & 4 && -1 < Rc.indexOf(a9)) {
      for (; null !== e3; ) {
        var f4 = Cb(e3);
        null !== f4 && Ec(f4);
        f4 = Yc(a9, b2, c6, d8);
        null === f4 && hd(a9, b2, d8, id, c6);
        if (f4 === e3)
          break;
        e3 = f4;
      }
      null !== e3 && d8.stopPropagation();
    } else
      hd(a9, b2, d8, null, c6);
  }
}
var id = null;
function Yc(a9, b2, c6, d8) {
  id = null;
  a9 = xb(d8);
  a9 = Wc(a9);
  if (null !== a9)
    if (b2 = Vb(a9), null === b2)
      a9 = null;
    else if (c6 = b2.tag, 13 === c6) {
      a9 = Wb(b2);
      if (null !== a9)
        return a9;
      a9 = null;
    } else if (3 === c6) {
      if (b2.stateNode.current.memoizedState.isDehydrated)
        return 3 === b2.tag ? b2.stateNode.containerInfo : null;
      a9 = null;
    } else
      b2 !== a9 && (a9 = null);
  id = a9;
  return null;
}
function jd(a9) {
  switch (a9) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var kd = null, ld = null, md = null;
function nd() {
  if (md)
    return md;
  var a9, b2 = ld, c6 = b2.length, d8, e3 = "value" in kd ? kd.value : kd.textContent, f4 = e3.length;
  for (a9 = 0; a9 < c6 && b2[a9] === e3[a9]; a9++)
    ;
  var g6 = c6 - a9;
  for (d8 = 1; d8 <= g6 && b2[c6 - d8] === e3[f4 - d8]; d8++)
    ;
  return md = e3.slice(a9, 1 < d8 ? 1 - d8 : void 0);
}
function od(a9) {
  var b2 = a9.keyCode;
  "charCode" in a9 ? (a9 = a9.charCode, 0 === a9 && 13 === b2 && (a9 = 13)) : a9 = b2;
  10 === a9 && (a9 = 13);
  return 32 <= a9 || 13 === a9 ? a9 : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a9) {
  function b2(b3, d8, e3, f4, g6) {
    this._reactName = b3;
    this._targetInst = e3;
    this.type = d8;
    this.nativeEvent = f4;
    this.target = g6;
    this.currentTarget = null;
    for (var c6 in a9)
      a9.hasOwnProperty(c6) && (b3 = a9[c6], this[c6] = b3 ? b3(f4) : f4[c6]);
    this.isDefaultPrevented = (null != f4.defaultPrevented ? f4.defaultPrevented : false === f4.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  A$d(b2.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a10 = this.nativeEvent;
    a10 && (a10.preventDefault ? a10.preventDefault() : "unknown" !== typeof a10.returnValue && (a10.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a10 = this.nativeEvent;
    a10 && (a10.stopPropagation ? a10.stopPropagation() : "unknown" !== typeof a10.cancelBubble && (a10.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b2;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a9) {
  return a9.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A$d({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A$d({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a9) {
  return void 0 === a9.relatedTarget ? a9.fromElement === a9.srcElement ? a9.toElement : a9.fromElement : a9.relatedTarget;
}, movementX: function(a9) {
  if ("movementX" in a9)
    return a9.movementX;
  a9 !== yd && (yd && "mousemove" === a9.type ? (wd = a9.screenX - yd.screenX, xd = a9.screenY - yd.screenY) : xd = wd = 0, yd = a9);
  return wd;
}, movementY: function(a9) {
  return "movementY" in a9 ? a9.movementY : xd;
} }), Bd = rd(Ad), Cd = A$d({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A$d({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A$d({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A$d({}, sd, { clipboardData: function(a9) {
  return "clipboardData" in a9 ? a9.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = A$d({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a9) {
  var b2 = this.nativeEvent;
  return b2.getModifierState ? b2.getModifierState(a9) : (a9 = Od[a9]) ? !!b2[a9] : false;
}
function zd() {
  return Pd;
}
var Qd = A$d({}, ud, { key: function(a9) {
  if (a9.key) {
    var b2 = Md[a9.key] || a9.key;
    if ("Unidentified" !== b2)
      return b2;
  }
  return "keypress" === a9.type ? (a9 = od(a9), 13 === a9 ? "Enter" : String.fromCharCode(a9)) : "keydown" === a9.type || "keyup" === a9.type ? Nd[a9.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a9) {
  return "keypress" === a9.type ? od(a9) : 0;
}, keyCode: function(a9) {
  return "keydown" === a9.type || "keyup" === a9.type ? a9.keyCode : 0;
}, which: function(a9) {
  return "keypress" === a9.type ? od(a9) : "keydown" === a9.type || "keyup" === a9.type ? a9.keyCode : 0;
} }), Rd = rd(Qd), Sd = A$d({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A$d({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A$d({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A$d({}, Ad, {
  deltaX: function(a9) {
    return "deltaX" in a9 ? a9.deltaX : "wheelDeltaX" in a9 ? -a9.wheelDeltaX : 0;
  },
  deltaY: function(a9) {
    return "deltaY" in a9 ? a9.deltaY : "wheelDeltaY" in a9 ? -a9.wheelDeltaY : "wheelDelta" in a9 ? -a9.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae$3 = ia && "CompositionEvent" in window, be$2 = null;
ia && "documentMode" in document && (be$2 = document.documentMode);
var ce$4 = ia && "TextEvent" in window && !be$2, de$2 = ia && (!ae$3 || be$2 && 8 < be$2 && 11 >= be$2), ee$4 = String.fromCharCode(32), fe$2 = false;
function ge$2(a9, b2) {
  switch (a9) {
    case "keyup":
      return -1 !== $d.indexOf(b2.keyCode);
    case "keydown":
      return 229 !== b2.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he$2(a9) {
  a9 = a9.detail;
  return "object" === typeof a9 && "data" in a9 ? a9.data : null;
}
var ie$2 = false;
function je$1(a9, b2) {
  switch (a9) {
    case "compositionend":
      return he$2(b2);
    case "keypress":
      if (32 !== b2.which)
        return null;
      fe$2 = true;
      return ee$4;
    case "textInput":
      return a9 = b2.data, a9 === ee$4 && fe$2 ? null : a9;
    default:
      return null;
  }
}
function ke(a9, b2) {
  if (ie$2)
    return "compositionend" === a9 || !ae$3 && ge$2(a9, b2) ? (a9 = nd(), md = ld = kd = null, ie$2 = false, a9) : null;
  switch (a9) {
    case "paste":
      return null;
    case "keypress":
      if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
        if (b2.char && 1 < b2.char.length)
          return b2.char;
        if (b2.which)
          return String.fromCharCode(b2.which);
      }
      return null;
    case "compositionend":
      return de$2 && "ko" !== b2.locale ? null : b2.data;
    default:
      return null;
  }
}
var le$5 = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me$2(a9) {
  var b2 = a9 && a9.nodeName && a9.nodeName.toLowerCase();
  return "input" === b2 ? !!le$5[a9.type] : "textarea" === b2 ? true : false;
}
function ne$2(a9, b2, c6, d8) {
  Eb(d8);
  b2 = oe$3(b2, "onChange");
  0 < b2.length && (c6 = new td("onChange", "change", null, c6, d8), a9.push({ event: c6, listeners: b2 }));
}
var pe$3 = null, qe = null;
function re$2(a9) {
  se$2(a9, 0);
}
function te$3(a9) {
  var b2 = ue$2(a9);
  if (Wa(b2))
    return a9;
}
function ve(a9, b2) {
  if ("change" === a9)
    return b2;
}
var we = false;
if (ia) {
  var xe$1;
  if (ia) {
    var ye$1 = "oninput" in document;
    if (!ye$1) {
      var ze = document.createElement("div");
      ze.setAttribute("oninput", "return;");
      ye$1 = "function" === typeof ze.oninput;
    }
    xe$1 = ye$1;
  } else
    xe$1 = false;
  we = xe$1 && (!document.documentMode || 9 < document.documentMode);
}
function Ae$1() {
  pe$3 && (pe$3.detachEvent("onpropertychange", Be), qe = pe$3 = null);
}
function Be(a9) {
  if ("value" === a9.propertyName && te$3(qe)) {
    var b2 = [];
    ne$2(b2, qe, a9, xb(a9));
    Jb(re$2, b2);
  }
}
function Ce$2(a9, b2, c6) {
  "focusin" === a9 ? (Ae$1(), pe$3 = b2, qe = c6, pe$3.attachEvent("onpropertychange", Be)) : "focusout" === a9 && Ae$1();
}
function De$1(a9) {
  if ("selectionchange" === a9 || "keyup" === a9 || "keydown" === a9)
    return te$3(qe);
}
function Ee$4(a9, b2) {
  if ("click" === a9)
    return te$3(b2);
}
function Fe$1(a9, b2) {
  if ("input" === a9 || "change" === a9)
    return te$3(b2);
}
function Ge(a9, b2) {
  return a9 === b2 && (0 !== a9 || 1 / a9 === 1 / b2) || a9 !== a9 && b2 !== b2;
}
var He = "function" === typeof Object.is ? Object.is : Ge;
function Ie$2(a9, b2) {
  if (He(a9, b2))
    return true;
  if ("object" !== typeof a9 || null === a9 || "object" !== typeof b2 || null === b2)
    return false;
  var c6 = Object.keys(a9), d8 = Object.keys(b2);
  if (c6.length !== d8.length)
    return false;
  for (d8 = 0; d8 < c6.length; d8++) {
    var e3 = c6[d8];
    if (!ja.call(b2, e3) || !He(a9[e3], b2[e3]))
      return false;
  }
  return true;
}
function Je(a9) {
  for (; a9 && a9.firstChild; )
    a9 = a9.firstChild;
  return a9;
}
function Ke(a9, b2) {
  var c6 = Je(a9);
  a9 = 0;
  for (var d8; c6; ) {
    if (3 === c6.nodeType) {
      d8 = a9 + c6.textContent.length;
      if (a9 <= b2 && d8 >= b2)
        return { node: c6, offset: b2 - a9 };
      a9 = d8;
    }
    a: {
      for (; c6; ) {
        if (c6.nextSibling) {
          c6 = c6.nextSibling;
          break a;
        }
        c6 = c6.parentNode;
      }
      c6 = void 0;
    }
    c6 = Je(c6);
  }
}
function Le$2(a9, b2) {
  return a9 && b2 ? a9 === b2 ? true : a9 && 3 === a9.nodeType ? false : b2 && 3 === b2.nodeType ? Le$2(a9, b2.parentNode) : "contains" in a9 ? a9.contains(b2) : a9.compareDocumentPosition ? !!(a9.compareDocumentPosition(b2) & 16) : false : false;
}
function Me$1() {
  for (var a9 = window, b2 = Xa(); b2 instanceof a9.HTMLIFrameElement; ) {
    try {
      var c6 = "string" === typeof b2.contentWindow.location.href;
    } catch (d8) {
      c6 = false;
    }
    if (c6)
      a9 = b2.contentWindow;
    else
      break;
    b2 = Xa(a9.document);
  }
  return b2;
}
function Ne$1(a9) {
  var b2 = a9 && a9.nodeName && a9.nodeName.toLowerCase();
  return b2 && ("input" === b2 && ("text" === a9.type || "search" === a9.type || "tel" === a9.type || "url" === a9.type || "password" === a9.type) || "textarea" === b2 || "true" === a9.contentEditable);
}
function Oe$2(a9) {
  var b2 = Me$1(), c6 = a9.focusedElem, d8 = a9.selectionRange;
  if (b2 !== c6 && c6 && c6.ownerDocument && Le$2(c6.ownerDocument.documentElement, c6)) {
    if (null !== d8 && Ne$1(c6)) {
      if (b2 = d8.start, a9 = d8.end, void 0 === a9 && (a9 = b2), "selectionStart" in c6)
        c6.selectionStart = b2, c6.selectionEnd = Math.min(a9, c6.value.length);
      else if (a9 = (b2 = c6.ownerDocument || document) && b2.defaultView || window, a9.getSelection) {
        a9 = a9.getSelection();
        var e3 = c6.textContent.length, f4 = Math.min(d8.start, e3);
        d8 = void 0 === d8.end ? f4 : Math.min(d8.end, e3);
        !a9.extend && f4 > d8 && (e3 = d8, d8 = f4, f4 = e3);
        e3 = Ke(c6, f4);
        var g6 = Ke(
          c6,
          d8
        );
        e3 && g6 && (1 !== a9.rangeCount || a9.anchorNode !== e3.node || a9.anchorOffset !== e3.offset || a9.focusNode !== g6.node || a9.focusOffset !== g6.offset) && (b2 = b2.createRange(), b2.setStart(e3.node, e3.offset), a9.removeAllRanges(), f4 > d8 ? (a9.addRange(b2), a9.extend(g6.node, g6.offset)) : (b2.setEnd(g6.node, g6.offset), a9.addRange(b2)));
      }
    }
    b2 = [];
    for (a9 = c6; a9 = a9.parentNode; )
      1 === a9.nodeType && b2.push({ element: a9, left: a9.scrollLeft, top: a9.scrollTop });
    "function" === typeof c6.focus && c6.focus();
    for (c6 = 0; c6 < b2.length; c6++)
      a9 = b2[c6], a9.element.scrollLeft = a9.left, a9.element.scrollTop = a9.top;
  }
}
var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
function Ue(a9, b2, c6) {
  var d8 = c6.window === c6 ? c6.document : 9 === c6.nodeType ? c6 : c6.ownerDocument;
  Te || null == Qe || Qe !== Xa(d8) || (d8 = Qe, "selectionStart" in d8 && Ne$1(d8) ? d8 = { start: d8.selectionStart, end: d8.selectionEnd } : (d8 = (d8.ownerDocument && d8.ownerDocument.defaultView || window).getSelection(), d8 = { anchorNode: d8.anchorNode, anchorOffset: d8.anchorOffset, focusNode: d8.focusNode, focusOffset: d8.focusOffset }), Se && Ie$2(Se, d8) || (Se = d8, d8 = oe$3(Re, "onSelect"), 0 < d8.length && (b2 = new td("onSelect", "select", null, b2, c6), a9.push({ event: b2, listeners: d8 }), b2.target = Qe)));
}
function Ve$1(a9, b2) {
  var c6 = {};
  c6[a9.toLowerCase()] = b2.toLowerCase();
  c6["Webkit" + a9] = "webkit" + b2;
  c6["Moz" + a9] = "moz" + b2;
  return c6;
}
var We = { animationend: Ve$1("Animation", "AnimationEnd"), animationiteration: Ve$1("Animation", "AnimationIteration"), animationstart: Ve$1("Animation", "AnimationStart"), transitionend: Ve$1("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
function Ze(a9) {
  if (Xe[a9])
    return Xe[a9];
  if (!We[a9])
    return a9;
  var b2 = We[a9], c6;
  for (c6 in b2)
    if (b2.hasOwnProperty(c6) && c6 in Ye)
      return Xe[a9] = b2[c6];
  return a9;
}
var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a9, b2) {
  df.set(a9, b2);
  fa(b2, [a9]);
}
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a9, b2, c6) {
  var d8 = a9.type || "unknown-event";
  a9.currentTarget = c6;
  Ub(d8, b2, void 0, a9);
  a9.currentTarget = null;
}
function se$2(a9, b2) {
  b2 = 0 !== (b2 & 4);
  for (var c6 = 0; c6 < a9.length; c6++) {
    var d8 = a9[c6], e3 = d8.event;
    d8 = d8.listeners;
    a: {
      var f4 = void 0;
      if (b2)
        for (var g6 = d8.length - 1; 0 <= g6; g6--) {
          var h3 = d8[g6], k3 = h3.instance, l7 = h3.currentTarget;
          h3 = h3.listener;
          if (k3 !== f4 && e3.isPropagationStopped())
            break a;
          nf(e3, h3, l7);
          f4 = k3;
        }
      else
        for (g6 = 0; g6 < d8.length; g6++) {
          h3 = d8[g6];
          k3 = h3.instance;
          l7 = h3.currentTarget;
          h3 = h3.listener;
          if (k3 !== f4 && e3.isPropagationStopped())
            break a;
          nf(e3, h3, l7);
          f4 = k3;
        }
    }
  }
  if (Qb)
    throw a9 = Rb, Qb = false, Rb = null, a9;
}
function D$6(a9, b2) {
  var c6 = b2[of];
  void 0 === c6 && (c6 = b2[of] = /* @__PURE__ */ new Set());
  var d8 = a9 + "__bubble";
  c6.has(d8) || (pf(b2, a9, 2, false), c6.add(d8));
}
function qf(a9, b2, c6) {
  var d8 = 0;
  b2 && (d8 |= 4);
  pf(c6, a9, d8, b2);
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(a9) {
  if (!a9[rf]) {
    a9[rf] = true;
    da.forEach(function(b3) {
      "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a9), qf(b3, true, a9));
    });
    var b2 = 9 === a9.nodeType ? a9 : a9.ownerDocument;
    null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
  }
}
function pf(a9, b2, c6, d8) {
  switch (jd(b2)) {
    case 1:
      var e3 = ed;
      break;
    case 4:
      e3 = gd;
      break;
    default:
      e3 = fd;
  }
  c6 = e3.bind(null, b2, c6, a9);
  e3 = void 0;
  !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e3 = true);
  d8 ? void 0 !== e3 ? a9.addEventListener(b2, c6, { capture: true, passive: e3 }) : a9.addEventListener(b2, c6, true) : void 0 !== e3 ? a9.addEventListener(b2, c6, { passive: e3 }) : a9.addEventListener(b2, c6, false);
}
function hd(a9, b2, c6, d8, e3) {
  var f4 = d8;
  if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d8)
    a:
      for (; ; ) {
        if (null === d8)
          return;
        var g6 = d8.tag;
        if (3 === g6 || 4 === g6) {
          var h3 = d8.stateNode.containerInfo;
          if (h3 === e3 || 8 === h3.nodeType && h3.parentNode === e3)
            break;
          if (4 === g6)
            for (g6 = d8.return; null !== g6; ) {
              var k3 = g6.tag;
              if (3 === k3 || 4 === k3) {
                if (k3 = g6.stateNode.containerInfo, k3 === e3 || 8 === k3.nodeType && k3.parentNode === e3)
                  return;
              }
              g6 = g6.return;
            }
          for (; null !== h3; ) {
            g6 = Wc(h3);
            if (null === g6)
              return;
            k3 = g6.tag;
            if (5 === k3 || 6 === k3) {
              d8 = f4 = g6;
              continue a;
            }
            h3 = h3.parentNode;
          }
        }
        d8 = d8.return;
      }
  Jb(function() {
    var d9 = f4, e4 = xb(c6), g7 = [];
    a: {
      var h4 = df.get(a9);
      if (void 0 !== h4) {
        var k4 = td, n10 = a9;
        switch (a9) {
          case "keypress":
            if (0 === od(c6))
              break a;
          case "keydown":
          case "keyup":
            k4 = Rd;
            break;
          case "focusin":
            n10 = "focus";
            k4 = Fd;
            break;
          case "focusout":
            n10 = "blur";
            k4 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k4 = Fd;
            break;
          case "click":
            if (2 === c6.button)
              break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k4 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k4 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k4 = Vd;
            break;
          case $e:
          case af:
          case bf:
            k4 = Hd;
            break;
          case cf:
            k4 = Xd;
            break;
          case "scroll":
            k4 = vd;
            break;
          case "wheel":
            k4 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k4 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k4 = Td;
        }
        var t6 = 0 !== (b2 & 4), J2 = !t6 && "scroll" === a9, x3 = t6 ? null !== h4 ? h4 + "Capture" : null : h4;
        t6 = [];
        for (var w3 = d9, u5; null !== w3; ) {
          u5 = w3;
          var F2 = u5.stateNode;
          5 === u5.tag && null !== F2 && (u5 = F2, null !== x3 && (F2 = Kb(w3, x3), null != F2 && t6.push(tf(w3, F2, u5))));
          if (J2)
            break;
          w3 = w3.return;
        }
        0 < t6.length && (h4 = new k4(h4, n10, null, c6, e4), g7.push({ event: h4, listeners: t6 }));
      }
    }
    if (0 === (b2 & 7)) {
      a: {
        h4 = "mouseover" === a9 || "pointerover" === a9;
        k4 = "mouseout" === a9 || "pointerout" === a9;
        if (h4 && c6 !== wb && (n10 = c6.relatedTarget || c6.fromElement) && (Wc(n10) || n10[uf]))
          break a;
        if (k4 || h4) {
          h4 = e4.window === e4 ? e4 : (h4 = e4.ownerDocument) ? h4.defaultView || h4.parentWindow : window;
          if (k4) {
            if (n10 = c6.relatedTarget || c6.toElement, k4 = d9, n10 = n10 ? Wc(n10) : null, null !== n10 && (J2 = Vb(n10), n10 !== J2 || 5 !== n10.tag && 6 !== n10.tag))
              n10 = null;
          } else
            k4 = null, n10 = d9;
          if (k4 !== n10) {
            t6 = Bd;
            F2 = "onMouseLeave";
            x3 = "onMouseEnter";
            w3 = "mouse";
            if ("pointerout" === a9 || "pointerover" === a9)
              t6 = Td, F2 = "onPointerLeave", x3 = "onPointerEnter", w3 = "pointer";
            J2 = null == k4 ? h4 : ue$2(k4);
            u5 = null == n10 ? h4 : ue$2(n10);
            h4 = new t6(F2, w3 + "leave", k4, c6, e4);
            h4.target = J2;
            h4.relatedTarget = u5;
            F2 = null;
            Wc(e4) === d9 && (t6 = new t6(x3, w3 + "enter", n10, c6, e4), t6.target = u5, t6.relatedTarget = J2, F2 = t6);
            J2 = F2;
            if (k4 && n10)
              b: {
                t6 = k4;
                x3 = n10;
                w3 = 0;
                for (u5 = t6; u5; u5 = vf(u5))
                  w3++;
                u5 = 0;
                for (F2 = x3; F2; F2 = vf(F2))
                  u5++;
                for (; 0 < w3 - u5; )
                  t6 = vf(t6), w3--;
                for (; 0 < u5 - w3; )
                  x3 = vf(x3), u5--;
                for (; w3--; ) {
                  if (t6 === x3 || null !== x3 && t6 === x3.alternate)
                    break b;
                  t6 = vf(t6);
                  x3 = vf(x3);
                }
                t6 = null;
              }
            else
              t6 = null;
            null !== k4 && wf(g7, h4, k4, t6, false);
            null !== n10 && null !== J2 && wf(g7, J2, n10, t6, true);
          }
        }
      }
      a: {
        h4 = d9 ? ue$2(d9) : window;
        k4 = h4.nodeName && h4.nodeName.toLowerCase();
        if ("select" === k4 || "input" === k4 && "file" === h4.type)
          var na = ve;
        else if (me$2(h4))
          if (we)
            na = Fe$1;
          else {
            na = De$1;
            var xa = Ce$2;
          }
        else
          (k4 = h4.nodeName) && "input" === k4.toLowerCase() && ("checkbox" === h4.type || "radio" === h4.type) && (na = Ee$4);
        if (na && (na = na(a9, d9))) {
          ne$2(g7, na, c6, e4);
          break a;
        }
        xa && xa(a9, h4, d9);
        "focusout" === a9 && (xa = h4._wrapperState) && xa.controlled && "number" === h4.type && cb(h4, "number", h4.value);
      }
      xa = d9 ? ue$2(d9) : window;
      switch (a9) {
        case "focusin":
          if (me$2(xa) || "true" === xa.contentEditable)
            Qe = xa, Re = d9, Se = null;
          break;
        case "focusout":
          Se = Re = Qe = null;
          break;
        case "mousedown":
          Te = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te = false;
          Ue(g7, c6, e4);
          break;
        case "selectionchange":
          if (Pe)
            break;
        case "keydown":
        case "keyup":
          Ue(g7, c6, e4);
      }
      var $a;
      if (ae$3)
        b: {
          switch (a9) {
            case "compositionstart":
              var ba = "onCompositionStart";
              break b;
            case "compositionend":
              ba = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba = "onCompositionUpdate";
              break b;
          }
          ba = void 0;
        }
      else
        ie$2 ? ge$2(a9, c6) && (ba = "onCompositionEnd") : "keydown" === a9 && 229 === c6.keyCode && (ba = "onCompositionStart");
      ba && (de$2 && "ko" !== c6.locale && (ie$2 || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie$2 && ($a = nd()) : (kd = e4, ld = "value" in kd ? kd.value : kd.textContent, ie$2 = true)), xa = oe$3(d9, ba), 0 < xa.length && (ba = new Ld(ba, a9, null, c6, e4), g7.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he$2(c6), null !== $a && (ba.data = $a))));
      if ($a = ce$4 ? je$1(a9, c6) : ke(a9, c6))
        d9 = oe$3(d9, "onBeforeInput"), 0 < d9.length && (e4 = new Ld("onBeforeInput", "beforeinput", null, c6, e4), g7.push({ event: e4, listeners: d9 }), e4.data = $a);
    }
    se$2(g7, b2);
  });
}
function tf(a9, b2, c6) {
  return { instance: a9, listener: b2, currentTarget: c6 };
}
function oe$3(a9, b2) {
  for (var c6 = b2 + "Capture", d8 = []; null !== a9; ) {
    var e3 = a9, f4 = e3.stateNode;
    5 === e3.tag && null !== f4 && (e3 = f4, f4 = Kb(a9, c6), null != f4 && d8.unshift(tf(a9, f4, e3)), f4 = Kb(a9, b2), null != f4 && d8.push(tf(a9, f4, e3)));
    a9 = a9.return;
  }
  return d8;
}
function vf(a9) {
  if (null === a9)
    return null;
  do
    a9 = a9.return;
  while (a9 && 5 !== a9.tag);
  return a9 ? a9 : null;
}
function wf(a9, b2, c6, d8, e3) {
  for (var f4 = b2._reactName, g6 = []; null !== c6 && c6 !== d8; ) {
    var h3 = c6, k3 = h3.alternate, l7 = h3.stateNode;
    if (null !== k3 && k3 === d8)
      break;
    5 === h3.tag && null !== l7 && (h3 = l7, e3 ? (k3 = Kb(c6, f4), null != k3 && g6.unshift(tf(c6, k3, h3))) : e3 || (k3 = Kb(c6, f4), null != k3 && g6.push(tf(c6, k3, h3))));
    c6 = c6.return;
  }
  0 !== g6.length && a9.push({ event: b2, listeners: g6 });
}
var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
function zf(a9) {
  return ("string" === typeof a9 ? a9 : "" + a9).replace(xf, "\n").replace(yf, "");
}
function Af(a9, b2, c6) {
  b2 = zf(b2);
  if (zf(a9) !== b2 && c6)
    throw Error(p$A(425));
}
function Bf() {
}
var Cf = null, Df = null;
function Ef(a9, b2) {
  return "textarea" === a9 || "noscript" === a9 || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
}
var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a9) {
  return Hf.resolve(null).then(a9).catch(If);
} : Ff;
function If(a9) {
  setTimeout(function() {
    throw a9;
  });
}
function Kf(a9, b2) {
  var c6 = b2, d8 = 0;
  do {
    var e3 = c6.nextSibling;
    a9.removeChild(c6);
    if (e3 && 8 === e3.nodeType)
      if (c6 = e3.data, "/$" === c6) {
        if (0 === d8) {
          a9.removeChild(e3);
          bd(b2);
          return;
        }
        d8--;
      } else
        "$" !== c6 && "$?" !== c6 && "$!" !== c6 || d8++;
    c6 = e3;
  } while (c6);
  bd(b2);
}
function Lf(a9) {
  for (; null != a9; a9 = a9.nextSibling) {
    var b2 = a9.nodeType;
    if (1 === b2 || 3 === b2)
      break;
    if (8 === b2) {
      b2 = a9.data;
      if ("$" === b2 || "$!" === b2 || "$?" === b2)
        break;
      if ("/$" === b2)
        return null;
    }
  }
  return a9;
}
function Mf(a9) {
  a9 = a9.previousSibling;
  for (var b2 = 0; a9; ) {
    if (8 === a9.nodeType) {
      var c6 = a9.data;
      if ("$" === c6 || "$!" === c6 || "$?" === c6) {
        if (0 === b2)
          return a9;
        b2--;
      } else
        "/$" === c6 && b2++;
    }
    a9 = a9.previousSibling;
  }
  return null;
}
var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
function Wc(a9) {
  var b2 = a9[Of];
  if (b2)
    return b2;
  for (var c6 = a9.parentNode; c6; ) {
    if (b2 = c6[uf] || c6[Of]) {
      c6 = b2.alternate;
      if (null !== b2.child || null !== c6 && null !== c6.child)
        for (a9 = Mf(a9); null !== a9; ) {
          if (c6 = a9[Of])
            return c6;
          a9 = Mf(a9);
        }
      return b2;
    }
    a9 = c6;
    c6 = a9.parentNode;
  }
  return null;
}
function Cb(a9) {
  a9 = a9[Of] || a9[uf];
  return !a9 || 5 !== a9.tag && 6 !== a9.tag && 13 !== a9.tag && 3 !== a9.tag ? null : a9;
}
function ue$2(a9) {
  if (5 === a9.tag || 6 === a9.tag)
    return a9.stateNode;
  throw Error(p$A(33));
}
function Db(a9) {
  return a9[Pf] || null;
}
var Sf = [], Tf = -1;
function Uf(a9) {
  return { current: a9 };
}
function E$d(a9) {
  0 > Tf || (a9.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
function G$a(a9, b2) {
  Tf++;
  Sf[Tf] = a9.current;
  a9.current = b2;
}
var Vf = {}, H$5 = Uf(Vf), Wf = Uf(false), Xf = Vf;
function Yf(a9, b2) {
  var c6 = a9.type.contextTypes;
  if (!c6)
    return Vf;
  var d8 = a9.stateNode;
  if (d8 && d8.__reactInternalMemoizedUnmaskedChildContext === b2)
    return d8.__reactInternalMemoizedMaskedChildContext;
  var e3 = {}, f4;
  for (f4 in c6)
    e3[f4] = b2[f4];
  d8 && (a9 = a9.stateNode, a9.__reactInternalMemoizedUnmaskedChildContext = b2, a9.__reactInternalMemoizedMaskedChildContext = e3);
  return e3;
}
function Zf(a9) {
  a9 = a9.childContextTypes;
  return null !== a9 && void 0 !== a9;
}
function $f() {
  E$d(Wf);
  E$d(H$5);
}
function ag(a9, b2, c6) {
  if (H$5.current !== Vf)
    throw Error(p$A(168));
  G$a(H$5, b2);
  G$a(Wf, c6);
}
function bg(a9, b2, c6) {
  var d8 = a9.stateNode;
  b2 = b2.childContextTypes;
  if ("function" !== typeof d8.getChildContext)
    return c6;
  d8 = d8.getChildContext();
  for (var e3 in d8)
    if (!(e3 in b2))
      throw Error(p$A(108, Ra(a9) || "Unknown", e3));
  return A$d({}, c6, d8);
}
function cg(a9) {
  a9 = (a9 = a9.stateNode) && a9.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H$5.current;
  G$a(H$5, a9);
  G$a(Wf, Wf.current);
  return true;
}
function dg(a9, b2, c6) {
  var d8 = a9.stateNode;
  if (!d8)
    throw Error(p$A(169));
  c6 ? (a9 = bg(a9, b2, Xf), d8.__reactInternalMemoizedMergedChildContext = a9, E$d(Wf), E$d(H$5), G$a(H$5, a9)) : E$d(Wf);
  G$a(Wf, c6);
}
var eg = null, fg = false, gg = false;
function hg(a9) {
  null === eg ? eg = [a9] : eg.push(a9);
}
function ig(a9) {
  fg = true;
  hg(a9);
}
function jg() {
  if (!gg && null !== eg) {
    gg = true;
    var a9 = 0, b2 = C$g;
    try {
      var c6 = eg;
      for (C$g = 1; a9 < c6.length; a9++) {
        var d8 = c6[a9];
        do
          d8 = d8(true);
        while (null !== d8);
      }
      eg = null;
      fg = false;
    } catch (e3) {
      throw null !== eg && (eg = eg.slice(a9 + 1)), ac(fc, jg), e3;
    } finally {
      C$g = b2, gg = false;
    }
  }
  return null;
}
var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
function tg(a9, b2) {
  kg[lg++] = ng;
  kg[lg++] = mg;
  mg = a9;
  ng = b2;
}
function ug(a9, b2, c6) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a9;
  var d8 = rg;
  a9 = sg;
  var e3 = 32 - oc(d8) - 1;
  d8 &= ~(1 << e3);
  c6 += 1;
  var f4 = 32 - oc(b2) + e3;
  if (30 < f4) {
    var g6 = e3 - e3 % 5;
    f4 = (d8 & (1 << g6) - 1).toString(32);
    d8 >>= g6;
    e3 -= g6;
    rg = 1 << 32 - oc(b2) + e3 | c6 << e3 | d8;
    sg = f4 + a9;
  } else
    rg = 1 << f4 | c6 << e3 | d8, sg = a9;
}
function vg(a9) {
  null !== a9.return && (tg(a9, 1), ug(a9, 1, 0));
}
function wg(a9) {
  for (; a9 === mg; )
    mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a9 === qg; )
    qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
var xg = null, yg = null, I$e = false, zg = null;
function Ag(a9, b2) {
  var c6 = Bg(5, null, null, 0);
  c6.elementType = "DELETED";
  c6.stateNode = b2;
  c6.return = a9;
  b2 = a9.deletions;
  null === b2 ? (a9.deletions = [c6], a9.flags |= 16) : b2.push(c6);
}
function Cg(a9, b2) {
  switch (a9.tag) {
    case 5:
      var c6 = a9.type;
      b2 = 1 !== b2.nodeType || c6.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
      return null !== b2 ? (a9.stateNode = b2, xg = a9, yg = Lf(b2.firstChild), true) : false;
    case 6:
      return b2 = "" === a9.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a9.stateNode = b2, xg = a9, yg = null, true) : false;
    case 13:
      return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c6 = null !== qg ? { id: rg, overflow: sg } : null, a9.memoizedState = { dehydrated: b2, treeContext: c6, retryLane: 1073741824 }, c6 = Bg(18, null, null, 0), c6.stateNode = b2, c6.return = a9, a9.child = c6, xg = a9, yg = null, true) : false;
    default:
      return false;
  }
}
function Dg(a9) {
  return 0 !== (a9.mode & 1) && 0 === (a9.flags & 128);
}
function Eg(a9) {
  if (I$e) {
    var b2 = yg;
    if (b2) {
      var c6 = b2;
      if (!Cg(a9, b2)) {
        if (Dg(a9))
          throw Error(p$A(418));
        b2 = Lf(c6.nextSibling);
        var d8 = xg;
        b2 && Cg(a9, b2) ? Ag(d8, c6) : (a9.flags = a9.flags & -4097 | 2, I$e = false, xg = a9);
      }
    } else {
      if (Dg(a9))
        throw Error(p$A(418));
      a9.flags = a9.flags & -4097 | 2;
      I$e = false;
      xg = a9;
    }
  }
}
function Fg(a9) {
  for (a9 = a9.return; null !== a9 && 5 !== a9.tag && 3 !== a9.tag && 13 !== a9.tag; )
    a9 = a9.return;
  xg = a9;
}
function Gg(a9) {
  if (a9 !== xg)
    return false;
  if (!I$e)
    return Fg(a9), I$e = true, false;
  var b2;
  (b2 = 3 !== a9.tag) && !(b2 = 5 !== a9.tag) && (b2 = a9.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a9.type, a9.memoizedProps));
  if (b2 && (b2 = yg)) {
    if (Dg(a9))
      throw Hg(), Error(p$A(418));
    for (; b2; )
      Ag(a9, b2), b2 = Lf(b2.nextSibling);
  }
  Fg(a9);
  if (13 === a9.tag) {
    a9 = a9.memoizedState;
    a9 = null !== a9 ? a9.dehydrated : null;
    if (!a9)
      throw Error(p$A(317));
    a: {
      a9 = a9.nextSibling;
      for (b2 = 0; a9; ) {
        if (8 === a9.nodeType) {
          var c6 = a9.data;
          if ("/$" === c6) {
            if (0 === b2) {
              yg = Lf(a9.nextSibling);
              break a;
            }
            b2--;
          } else
            "$" !== c6 && "$!" !== c6 && "$?" !== c6 || b2++;
        }
        a9 = a9.nextSibling;
      }
      yg = null;
    }
  } else
    yg = xg ? Lf(a9.stateNode.nextSibling) : null;
  return true;
}
function Hg() {
  for (var a9 = yg; a9; )
    a9 = Lf(a9.nextSibling);
}
function Ig() {
  yg = xg = null;
  I$e = false;
}
function Jg(a9) {
  null === zg ? zg = [a9] : zg.push(a9);
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(a9, b2, c6) {
  a9 = c6.ref;
  if (null !== a9 && "function" !== typeof a9 && "object" !== typeof a9) {
    if (c6._owner) {
      c6 = c6._owner;
      if (c6) {
        if (1 !== c6.tag)
          throw Error(p$A(309));
        var d8 = c6.stateNode;
      }
      if (!d8)
        throw Error(p$A(147, a9));
      var e3 = d8, f4 = "" + a9;
      if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f4)
        return b2.ref;
      b2 = function(a10) {
        var b3 = e3.refs;
        null === a10 ? delete b3[f4] : b3[f4] = a10;
      };
      b2._stringRef = f4;
      return b2;
    }
    if ("string" !== typeof a9)
      throw Error(p$A(284));
    if (!c6._owner)
      throw Error(p$A(290, a9));
  }
  return a9;
}
function Mg(a9, b2) {
  a9 = Object.prototype.toString.call(b2);
  throw Error(p$A(31, "[object Object]" === a9 ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a9));
}
function Ng(a9) {
  var b2 = a9._init;
  return b2(a9._payload);
}
function Og(a9) {
  function b2(b3, c7) {
    if (a9) {
      var d9 = b3.deletions;
      null === d9 ? (b3.deletions = [c7], b3.flags |= 16) : d9.push(c7);
    }
  }
  function c6(c7, d9) {
    if (!a9)
      return null;
    for (; null !== d9; )
      b2(c7, d9), d9 = d9.sibling;
    return null;
  }
  function d8(a10, b3) {
    for (a10 = /* @__PURE__ */ new Map(); null !== b3; )
      null !== b3.key ? a10.set(b3.key, b3) : a10.set(b3.index, b3), b3 = b3.sibling;
    return a10;
  }
  function e3(a10, b3) {
    a10 = Pg(a10, b3);
    a10.index = 0;
    a10.sibling = null;
    return a10;
  }
  function f4(b3, c7, d9) {
    b3.index = d9;
    if (!a9)
      return b3.flags |= 1048576, c7;
    d9 = b3.alternate;
    if (null !== d9)
      return d9 = d9.index, d9 < c7 ? (b3.flags |= 2, c7) : d9;
    b3.flags |= 2;
    return c7;
  }
  function g6(b3) {
    a9 && null === b3.alternate && (b3.flags |= 2);
    return b3;
  }
  function h3(a10, b3, c7, d9) {
    if (null === b3 || 6 !== b3.tag)
      return b3 = Qg(c7, a10.mode, d9), b3.return = a10, b3;
    b3 = e3(b3, c7);
    b3.return = a10;
    return b3;
  }
  function k3(a10, b3, c7, d9) {
    var f5 = c7.type;
    if (f5 === ya)
      return m3(a10, b3, c7.props.children, d9, c7.key);
    if (null !== b3 && (b3.elementType === f5 || "object" === typeof f5 && null !== f5 && f5.$$typeof === Ha && Ng(f5) === b3.type))
      return d9 = e3(b3, c7.props), d9.ref = Lg(a10, b3, c7), d9.return = a10, d9;
    d9 = Rg(c7.type, c7.key, c7.props, null, a10.mode, d9);
    d9.ref = Lg(a10, b3, c7);
    d9.return = a10;
    return d9;
  }
  function l7(a10, b3, c7, d9) {
    if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c7.containerInfo || b3.stateNode.implementation !== c7.implementation)
      return b3 = Sg(c7, a10.mode, d9), b3.return = a10, b3;
    b3 = e3(b3, c7.children || []);
    b3.return = a10;
    return b3;
  }
  function m3(a10, b3, c7, d9, f5) {
    if (null === b3 || 7 !== b3.tag)
      return b3 = Tg(c7, a10.mode, d9, f5), b3.return = a10, b3;
    b3 = e3(b3, c7);
    b3.return = a10;
    return b3;
  }
  function q2(a10, b3, c7) {
    if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3)
      return b3 = Qg("" + b3, a10.mode, c7), b3.return = a10, b3;
    if ("object" === typeof b3 && null !== b3) {
      switch (b3.$$typeof) {
        case va:
          return c7 = Rg(b3.type, b3.key, b3.props, null, a10.mode, c7), c7.ref = Lg(a10, null, b3), c7.return = a10, c7;
        case wa:
          return b3 = Sg(b3, a10.mode, c7), b3.return = a10, b3;
        case Ha:
          var d9 = b3._init;
          return q2(a10, d9(b3._payload), c7);
      }
      if (eb(b3) || Ka(b3))
        return b3 = Tg(b3, a10.mode, c7, null), b3.return = a10, b3;
      Mg(a10, b3);
    }
    return null;
  }
  function r12(a10, b3, c7, d9) {
    var e4 = null !== b3 ? b3.key : null;
    if ("string" === typeof c7 && "" !== c7 || "number" === typeof c7)
      return null !== e4 ? null : h3(a10, b3, "" + c7, d9);
    if ("object" === typeof c7 && null !== c7) {
      switch (c7.$$typeof) {
        case va:
          return c7.key === e4 ? k3(a10, b3, c7, d9) : null;
        case wa:
          return c7.key === e4 ? l7(a10, b3, c7, d9) : null;
        case Ha:
          return e4 = c7._init, r12(
            a10,
            b3,
            e4(c7._payload),
            d9
          );
      }
      if (eb(c7) || Ka(c7))
        return null !== e4 ? null : m3(a10, b3, c7, d9, null);
      Mg(a10, c7);
    }
    return null;
  }
  function y4(a10, b3, c7, d9, e4) {
    if ("string" === typeof d9 && "" !== d9 || "number" === typeof d9)
      return a10 = a10.get(c7) || null, h3(b3, a10, "" + d9, e4);
    if ("object" === typeof d9 && null !== d9) {
      switch (d9.$$typeof) {
        case va:
          return a10 = a10.get(null === d9.key ? c7 : d9.key) || null, k3(b3, a10, d9, e4);
        case wa:
          return a10 = a10.get(null === d9.key ? c7 : d9.key) || null, l7(b3, a10, d9, e4);
        case Ha:
          var f5 = d9._init;
          return y4(a10, b3, c7, f5(d9._payload), e4);
      }
      if (eb(d9) || Ka(d9))
        return a10 = a10.get(c7) || null, m3(b3, a10, d9, e4, null);
      Mg(b3, d9);
    }
    return null;
  }
  function n10(e4, g7, h4, k4) {
    for (var l8 = null, m4 = null, u5 = g7, w3 = g7 = 0, x3 = null; null !== u5 && w3 < h4.length; w3++) {
      u5.index > w3 ? (x3 = u5, u5 = null) : x3 = u5.sibling;
      var n11 = r12(e4, u5, h4[w3], k4);
      if (null === n11) {
        null === u5 && (u5 = x3);
        break;
      }
      a9 && u5 && null === n11.alternate && b2(e4, u5);
      g7 = f4(n11, g7, w3);
      null === m4 ? l8 = n11 : m4.sibling = n11;
      m4 = n11;
      u5 = x3;
    }
    if (w3 === h4.length)
      return c6(e4, u5), I$e && tg(e4, w3), l8;
    if (null === u5) {
      for (; w3 < h4.length; w3++)
        u5 = q2(e4, h4[w3], k4), null !== u5 && (g7 = f4(u5, g7, w3), null === m4 ? l8 = u5 : m4.sibling = u5, m4 = u5);
      I$e && tg(e4, w3);
      return l8;
    }
    for (u5 = d8(e4, u5); w3 < h4.length; w3++)
      x3 = y4(u5, e4, w3, h4[w3], k4), null !== x3 && (a9 && null !== x3.alternate && u5.delete(null === x3.key ? w3 : x3.key), g7 = f4(x3, g7, w3), null === m4 ? l8 = x3 : m4.sibling = x3, m4 = x3);
    a9 && u5.forEach(function(a10) {
      return b2(e4, a10);
    });
    I$e && tg(e4, w3);
    return l8;
  }
  function t6(e4, g7, h4, k4) {
    var l8 = Ka(h4);
    if ("function" !== typeof l8)
      throw Error(p$A(150));
    h4 = l8.call(h4);
    if (null == h4)
      throw Error(p$A(151));
    for (var u5 = l8 = null, m4 = g7, w3 = g7 = 0, x3 = null, n11 = h4.next(); null !== m4 && !n11.done; w3++, n11 = h4.next()) {
      m4.index > w3 ? (x3 = m4, m4 = null) : x3 = m4.sibling;
      var t7 = r12(e4, m4, n11.value, k4);
      if (null === t7) {
        null === m4 && (m4 = x3);
        break;
      }
      a9 && m4 && null === t7.alternate && b2(e4, m4);
      g7 = f4(t7, g7, w3);
      null === u5 ? l8 = t7 : u5.sibling = t7;
      u5 = t7;
      m4 = x3;
    }
    if (n11.done)
      return c6(
        e4,
        m4
      ), I$e && tg(e4, w3), l8;
    if (null === m4) {
      for (; !n11.done; w3++, n11 = h4.next())
        n11 = q2(e4, n11.value, k4), null !== n11 && (g7 = f4(n11, g7, w3), null === u5 ? l8 = n11 : u5.sibling = n11, u5 = n11);
      I$e && tg(e4, w3);
      return l8;
    }
    for (m4 = d8(e4, m4); !n11.done; w3++, n11 = h4.next())
      n11 = y4(m4, e4, w3, n11.value, k4), null !== n11 && (a9 && null !== n11.alternate && m4.delete(null === n11.key ? w3 : n11.key), g7 = f4(n11, g7, w3), null === u5 ? l8 = n11 : u5.sibling = n11, u5 = n11);
    a9 && m4.forEach(function(a10) {
      return b2(e4, a10);
    });
    I$e && tg(e4, w3);
    return l8;
  }
  function J2(a10, d9, f5, h4) {
    "object" === typeof f5 && null !== f5 && f5.type === ya && null === f5.key && (f5 = f5.props.children);
    if ("object" === typeof f5 && null !== f5) {
      switch (f5.$$typeof) {
        case va:
          a: {
            for (var k4 = f5.key, l8 = d9; null !== l8; ) {
              if (l8.key === k4) {
                k4 = f5.type;
                if (k4 === ya) {
                  if (7 === l8.tag) {
                    c6(a10, l8.sibling);
                    d9 = e3(l8, f5.props.children);
                    d9.return = a10;
                    a10 = d9;
                    break a;
                  }
                } else if (l8.elementType === k4 || "object" === typeof k4 && null !== k4 && k4.$$typeof === Ha && Ng(k4) === l8.type) {
                  c6(a10, l8.sibling);
                  d9 = e3(l8, f5.props);
                  d9.ref = Lg(a10, l8, f5);
                  d9.return = a10;
                  a10 = d9;
                  break a;
                }
                c6(a10, l8);
                break;
              } else
                b2(a10, l8);
              l8 = l8.sibling;
            }
            f5.type === ya ? (d9 = Tg(f5.props.children, a10.mode, h4, f5.key), d9.return = a10, a10 = d9) : (h4 = Rg(f5.type, f5.key, f5.props, null, a10.mode, h4), h4.ref = Lg(a10, d9, f5), h4.return = a10, a10 = h4);
          }
          return g6(a10);
        case wa:
          a: {
            for (l8 = f5.key; null !== d9; ) {
              if (d9.key === l8)
                if (4 === d9.tag && d9.stateNode.containerInfo === f5.containerInfo && d9.stateNode.implementation === f5.implementation) {
                  c6(a10, d9.sibling);
                  d9 = e3(d9, f5.children || []);
                  d9.return = a10;
                  a10 = d9;
                  break a;
                } else {
                  c6(a10, d9);
                  break;
                }
              else
                b2(a10, d9);
              d9 = d9.sibling;
            }
            d9 = Sg(f5, a10.mode, h4);
            d9.return = a10;
            a10 = d9;
          }
          return g6(a10);
        case Ha:
          return l8 = f5._init, J2(a10, d9, l8(f5._payload), h4);
      }
      if (eb(f5))
        return n10(a10, d9, f5, h4);
      if (Ka(f5))
        return t6(a10, d9, f5, h4);
      Mg(a10, f5);
    }
    return "string" === typeof f5 && "" !== f5 || "number" === typeof f5 ? (f5 = "" + f5, null !== d9 && 6 === d9.tag ? (c6(a10, d9.sibling), d9 = e3(d9, f5), d9.return = a10, a10 = d9) : (c6(a10, d9), d9 = Qg(f5, a10.mode, h4), d9.return = a10, a10 = d9), g6(a10)) : c6(a10, d9);
  }
  return J2;
}
var Ug = Og(true), Vg = Og(false), Wg = Uf(null), Xg = null, Yg = null, Zg = null;
function $g() {
  Zg = Yg = Xg = null;
}
function ah(a9) {
  var b2 = Wg.current;
  E$d(Wg);
  a9._currentValue = b2;
}
function bh(a9, b2, c6) {
  for (; null !== a9; ) {
    var d8 = a9.alternate;
    (a9.childLanes & b2) !== b2 ? (a9.childLanes |= b2, null !== d8 && (d8.childLanes |= b2)) : null !== d8 && (d8.childLanes & b2) !== b2 && (d8.childLanes |= b2);
    if (a9 === c6)
      break;
    a9 = a9.return;
  }
}
function ch(a9, b2) {
  Xg = a9;
  Zg = Yg = null;
  a9 = a9.dependencies;
  null !== a9 && null !== a9.firstContext && (0 !== (a9.lanes & b2) && (dh = true), a9.firstContext = null);
}
function eh(a9) {
  var b2 = a9._currentValue;
  if (Zg !== a9)
    if (a9 = { context: a9, memoizedValue: b2, next: null }, null === Yg) {
      if (null === Xg)
        throw Error(p$A(308));
      Yg = a9;
      Xg.dependencies = { lanes: 0, firstContext: a9 };
    } else
      Yg = Yg.next = a9;
  return b2;
}
var fh = null;
function gh(a9) {
  null === fh ? fh = [a9] : fh.push(a9);
}
function hh(a9, b2, c6, d8) {
  var e3 = b2.interleaved;
  null === e3 ? (c6.next = c6, gh(b2)) : (c6.next = e3.next, e3.next = c6);
  b2.interleaved = c6;
  return ih(a9, d8);
}
function ih(a9, b2) {
  a9.lanes |= b2;
  var c6 = a9.alternate;
  null !== c6 && (c6.lanes |= b2);
  c6 = a9;
  for (a9 = a9.return; null !== a9; )
    a9.childLanes |= b2, c6 = a9.alternate, null !== c6 && (c6.childLanes |= b2), c6 = a9, a9 = a9.return;
  return 3 === c6.tag ? c6.stateNode : null;
}
var jh = false;
function kh(a9) {
  a9.updateQueue = { baseState: a9.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function lh(a9, b2) {
  a9 = a9.updateQueue;
  b2.updateQueue === a9 && (b2.updateQueue = { baseState: a9.baseState, firstBaseUpdate: a9.firstBaseUpdate, lastBaseUpdate: a9.lastBaseUpdate, shared: a9.shared, effects: a9.effects });
}
function mh(a9, b2) {
  return { eventTime: a9, lane: b2, tag: 0, payload: null, callback: null, next: null };
}
function nh(a9, b2, c6) {
  var d8 = a9.updateQueue;
  if (null === d8)
    return null;
  d8 = d8.shared;
  if (0 !== (K$7 & 2)) {
    var e3 = d8.pending;
    null === e3 ? b2.next = b2 : (b2.next = e3.next, e3.next = b2);
    d8.pending = b2;
    return ih(a9, c6);
  }
  e3 = d8.interleaved;
  null === e3 ? (b2.next = b2, gh(d8)) : (b2.next = e3.next, e3.next = b2);
  d8.interleaved = b2;
  return ih(a9, c6);
}
function oh(a9, b2, c6) {
  b2 = b2.updateQueue;
  if (null !== b2 && (b2 = b2.shared, 0 !== (c6 & 4194240))) {
    var d8 = b2.lanes;
    d8 &= a9.pendingLanes;
    c6 |= d8;
    b2.lanes = c6;
    Cc(a9, c6);
  }
}
function ph(a9, b2) {
  var c6 = a9.updateQueue, d8 = a9.alternate;
  if (null !== d8 && (d8 = d8.updateQueue, c6 === d8)) {
    var e3 = null, f4 = null;
    c6 = c6.firstBaseUpdate;
    if (null !== c6) {
      do {
        var g6 = { eventTime: c6.eventTime, lane: c6.lane, tag: c6.tag, payload: c6.payload, callback: c6.callback, next: null };
        null === f4 ? e3 = f4 = g6 : f4 = f4.next = g6;
        c6 = c6.next;
      } while (null !== c6);
      null === f4 ? e3 = f4 = b2 : f4 = f4.next = b2;
    } else
      e3 = f4 = b2;
    c6 = { baseState: d8.baseState, firstBaseUpdate: e3, lastBaseUpdate: f4, shared: d8.shared, effects: d8.effects };
    a9.updateQueue = c6;
    return;
  }
  a9 = c6.lastBaseUpdate;
  null === a9 ? c6.firstBaseUpdate = b2 : a9.next = b2;
  c6.lastBaseUpdate = b2;
}
function qh(a9, b2, c6, d8) {
  var e3 = a9.updateQueue;
  jh = false;
  var f4 = e3.firstBaseUpdate, g6 = e3.lastBaseUpdate, h3 = e3.shared.pending;
  if (null !== h3) {
    e3.shared.pending = null;
    var k3 = h3, l7 = k3.next;
    k3.next = null;
    null === g6 ? f4 = l7 : g6.next = l7;
    g6 = k3;
    var m3 = a9.alternate;
    null !== m3 && (m3 = m3.updateQueue, h3 = m3.lastBaseUpdate, h3 !== g6 && (null === h3 ? m3.firstBaseUpdate = l7 : h3.next = l7, m3.lastBaseUpdate = k3));
  }
  if (null !== f4) {
    var q2 = e3.baseState;
    g6 = 0;
    m3 = l7 = k3 = null;
    h3 = f4;
    do {
      var r12 = h3.lane, y4 = h3.eventTime;
      if ((d8 & r12) === r12) {
        null !== m3 && (m3 = m3.next = {
          eventTime: y4,
          lane: 0,
          tag: h3.tag,
          payload: h3.payload,
          callback: h3.callback,
          next: null
        });
        a: {
          var n10 = a9, t6 = h3;
          r12 = b2;
          y4 = c6;
          switch (t6.tag) {
            case 1:
              n10 = t6.payload;
              if ("function" === typeof n10) {
                q2 = n10.call(y4, q2, r12);
                break a;
              }
              q2 = n10;
              break a;
            case 3:
              n10.flags = n10.flags & -65537 | 128;
            case 0:
              n10 = t6.payload;
              r12 = "function" === typeof n10 ? n10.call(y4, q2, r12) : n10;
              if (null === r12 || void 0 === r12)
                break a;
              q2 = A$d({}, q2, r12);
              break a;
            case 2:
              jh = true;
          }
        }
        null !== h3.callback && 0 !== h3.lane && (a9.flags |= 64, r12 = e3.effects, null === r12 ? e3.effects = [h3] : r12.push(h3));
      } else
        y4 = { eventTime: y4, lane: r12, tag: h3.tag, payload: h3.payload, callback: h3.callback, next: null }, null === m3 ? (l7 = m3 = y4, k3 = q2) : m3 = m3.next = y4, g6 |= r12;
      h3 = h3.next;
      if (null === h3)
        if (h3 = e3.shared.pending, null === h3)
          break;
        else
          r12 = h3, h3 = r12.next, r12.next = null, e3.lastBaseUpdate = r12, e3.shared.pending = null;
    } while (1);
    null === m3 && (k3 = q2);
    e3.baseState = k3;
    e3.firstBaseUpdate = l7;
    e3.lastBaseUpdate = m3;
    b2 = e3.shared.interleaved;
    if (null !== b2) {
      e3 = b2;
      do
        g6 |= e3.lane, e3 = e3.next;
      while (e3 !== b2);
    } else
      null === f4 && (e3.shared.lanes = 0);
    rh |= g6;
    a9.lanes = g6;
    a9.memoizedState = q2;
  }
}
function sh(a9, b2, c6) {
  a9 = b2.effects;
  b2.effects = null;
  if (null !== a9)
    for (b2 = 0; b2 < a9.length; b2++) {
      var d8 = a9[b2], e3 = d8.callback;
      if (null !== e3) {
        d8.callback = null;
        d8 = c6;
        if ("function" !== typeof e3)
          throw Error(p$A(191, e3));
        e3.call(d8);
      }
    }
}
var th = {}, uh = Uf(th), vh = Uf(th), wh = Uf(th);
function xh(a9) {
  if (a9 === th)
    throw Error(p$A(174));
  return a9;
}
function yh(a9, b2) {
  G$a(wh, b2);
  G$a(vh, a9);
  G$a(uh, th);
  a9 = b2.nodeType;
  switch (a9) {
    case 9:
    case 11:
      b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
      break;
    default:
      a9 = 8 === a9 ? b2.parentNode : b2, b2 = a9.namespaceURI || null, a9 = a9.tagName, b2 = lb(b2, a9);
  }
  E$d(uh);
  G$a(uh, b2);
}
function zh() {
  E$d(uh);
  E$d(vh);
  E$d(wh);
}
function Ah(a9) {
  xh(wh.current);
  var b2 = xh(uh.current);
  var c6 = lb(b2, a9.type);
  b2 !== c6 && (G$a(vh, a9), G$a(uh, c6));
}
function Bh(a9) {
  vh.current === a9 && (E$d(uh), E$d(vh));
}
var L$d = Uf(0);
function Ch(a9) {
  for (var b2 = a9; null !== b2; ) {
    if (13 === b2.tag) {
      var c6 = b2.memoizedState;
      if (null !== c6 && (c6 = c6.dehydrated, null === c6 || "$?" === c6.data || "$!" === c6.data))
        return b2;
    } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
      if (0 !== (b2.flags & 128))
        return b2;
    } else if (null !== b2.child) {
      b2.child.return = b2;
      b2 = b2.child;
      continue;
    }
    if (b2 === a9)
      break;
    for (; null === b2.sibling; ) {
      if (null === b2.return || b2.return === a9)
        return null;
      b2 = b2.return;
    }
    b2.sibling.return = b2.return;
    b2 = b2.sibling;
  }
  return null;
}
var Dh = [];
function Eh() {
  for (var a9 = 0; a9 < Dh.length; a9++)
    Dh[a9]._workInProgressVersionPrimary = null;
  Dh.length = 0;
}
var Fh = ua.ReactCurrentDispatcher, Gh = ua.ReactCurrentBatchConfig, Hh = 0, M$c = null, N$a = null, O$a = null, Ih = false, Jh = false, Kh = 0, Lh = 0;
function P$d() {
  throw Error(p$A(321));
}
function Mh(a9, b2) {
  if (null === b2)
    return false;
  for (var c6 = 0; c6 < b2.length && c6 < a9.length; c6++)
    if (!He(a9[c6], b2[c6]))
      return false;
  return true;
}
function Nh(a9, b2, c6, d8, e3, f4) {
  Hh = f4;
  M$c = b2;
  b2.memoizedState = null;
  b2.updateQueue = null;
  b2.lanes = 0;
  Fh.current = null === a9 || null === a9.memoizedState ? Oh : Ph;
  a9 = c6(d8, e3);
  if (Jh) {
    f4 = 0;
    do {
      Jh = false;
      Kh = 0;
      if (25 <= f4)
        throw Error(p$A(301));
      f4 += 1;
      O$a = N$a = null;
      b2.updateQueue = null;
      Fh.current = Qh;
      a9 = c6(d8, e3);
    } while (Jh);
  }
  Fh.current = Rh;
  b2 = null !== N$a && null !== N$a.next;
  Hh = 0;
  O$a = N$a = M$c = null;
  Ih = false;
  if (b2)
    throw Error(p$A(300));
  return a9;
}
function Sh() {
  var a9 = 0 !== Kh;
  Kh = 0;
  return a9;
}
function Th() {
  var a9 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === O$a ? M$c.memoizedState = O$a = a9 : O$a = O$a.next = a9;
  return O$a;
}
function Uh() {
  if (null === N$a) {
    var a9 = M$c.alternate;
    a9 = null !== a9 ? a9.memoizedState : null;
  } else
    a9 = N$a.next;
  var b2 = null === O$a ? M$c.memoizedState : O$a.next;
  if (null !== b2)
    O$a = b2, N$a = a9;
  else {
    if (null === a9)
      throw Error(p$A(310));
    N$a = a9;
    a9 = { memoizedState: N$a.memoizedState, baseState: N$a.baseState, baseQueue: N$a.baseQueue, queue: N$a.queue, next: null };
    null === O$a ? M$c.memoizedState = O$a = a9 : O$a = O$a.next = a9;
  }
  return O$a;
}
function Vh(a9, b2) {
  return "function" === typeof b2 ? b2(a9) : b2;
}
function Wh(a9) {
  var b2 = Uh(), c6 = b2.queue;
  if (null === c6)
    throw Error(p$A(311));
  c6.lastRenderedReducer = a9;
  var d8 = N$a, e3 = d8.baseQueue, f4 = c6.pending;
  if (null !== f4) {
    if (null !== e3) {
      var g6 = e3.next;
      e3.next = f4.next;
      f4.next = g6;
    }
    d8.baseQueue = e3 = f4;
    c6.pending = null;
  }
  if (null !== e3) {
    f4 = e3.next;
    d8 = d8.baseState;
    var h3 = g6 = null, k3 = null, l7 = f4;
    do {
      var m3 = l7.lane;
      if ((Hh & m3) === m3)
        null !== k3 && (k3 = k3.next = { lane: 0, action: l7.action, hasEagerState: l7.hasEagerState, eagerState: l7.eagerState, next: null }), d8 = l7.hasEagerState ? l7.eagerState : a9(d8, l7.action);
      else {
        var q2 = {
          lane: m3,
          action: l7.action,
          hasEagerState: l7.hasEagerState,
          eagerState: l7.eagerState,
          next: null
        };
        null === k3 ? (h3 = k3 = q2, g6 = d8) : k3 = k3.next = q2;
        M$c.lanes |= m3;
        rh |= m3;
      }
      l7 = l7.next;
    } while (null !== l7 && l7 !== f4);
    null === k3 ? g6 = d8 : k3.next = h3;
    He(d8, b2.memoizedState) || (dh = true);
    b2.memoizedState = d8;
    b2.baseState = g6;
    b2.baseQueue = k3;
    c6.lastRenderedState = d8;
  }
  a9 = c6.interleaved;
  if (null !== a9) {
    e3 = a9;
    do
      f4 = e3.lane, M$c.lanes |= f4, rh |= f4, e3 = e3.next;
    while (e3 !== a9);
  } else
    null === e3 && (c6.lanes = 0);
  return [b2.memoizedState, c6.dispatch];
}
function Xh(a9) {
  var b2 = Uh(), c6 = b2.queue;
  if (null === c6)
    throw Error(p$A(311));
  c6.lastRenderedReducer = a9;
  var d8 = c6.dispatch, e3 = c6.pending, f4 = b2.memoizedState;
  if (null !== e3) {
    c6.pending = null;
    var g6 = e3 = e3.next;
    do
      f4 = a9(f4, g6.action), g6 = g6.next;
    while (g6 !== e3);
    He(f4, b2.memoizedState) || (dh = true);
    b2.memoizedState = f4;
    null === b2.baseQueue && (b2.baseState = f4);
    c6.lastRenderedState = f4;
  }
  return [f4, d8];
}
function Yh() {
}
function Zh(a9, b2) {
  var c6 = M$c, d8 = Uh(), e3 = b2(), f4 = !He(d8.memoizedState, e3);
  f4 && (d8.memoizedState = e3, dh = true);
  d8 = d8.queue;
  $h(ai.bind(null, c6, d8, a9), [a9]);
  if (d8.getSnapshot !== b2 || f4 || null !== O$a && O$a.memoizedState.tag & 1) {
    c6.flags |= 2048;
    bi(9, ci.bind(null, c6, d8, e3, b2), void 0, null);
    if (null === Q$7)
      throw Error(p$A(349));
    0 !== (Hh & 30) || di(c6, b2, e3);
  }
  return e3;
}
function di(a9, b2, c6) {
  a9.flags |= 16384;
  a9 = { getSnapshot: b2, value: c6 };
  b2 = M$c.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, M$c.updateQueue = b2, b2.stores = [a9]) : (c6 = b2.stores, null === c6 ? b2.stores = [a9] : c6.push(a9));
}
function ci(a9, b2, c6, d8) {
  b2.value = c6;
  b2.getSnapshot = d8;
  ei(b2) && fi(a9);
}
function ai(a9, b2, c6) {
  return c6(function() {
    ei(b2) && fi(a9);
  });
}
function ei(a9) {
  var b2 = a9.getSnapshot;
  a9 = a9.value;
  try {
    var c6 = b2();
    return !He(a9, c6);
  } catch (d8) {
    return true;
  }
}
function fi(a9) {
  var b2 = ih(a9, 1);
  null !== b2 && gi(b2, a9, 1, -1);
}
function hi(a9) {
  var b2 = Th();
  "function" === typeof a9 && (a9 = a9());
  b2.memoizedState = b2.baseState = a9;
  a9 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a9 };
  b2.queue = a9;
  a9 = a9.dispatch = ii.bind(null, M$c, a9);
  return [b2.memoizedState, a9];
}
function bi(a9, b2, c6, d8) {
  a9 = { tag: a9, create: b2, destroy: c6, deps: d8, next: null };
  b2 = M$c.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, M$c.updateQueue = b2, b2.lastEffect = a9.next = a9) : (c6 = b2.lastEffect, null === c6 ? b2.lastEffect = a9.next = a9 : (d8 = c6.next, c6.next = a9, a9.next = d8, b2.lastEffect = a9));
  return a9;
}
function ji() {
  return Uh().memoizedState;
}
function ki(a9, b2, c6, d8) {
  var e3 = Th();
  M$c.flags |= a9;
  e3.memoizedState = bi(1 | b2, c6, void 0, void 0 === d8 ? null : d8);
}
function li(a9, b2, c6, d8) {
  var e3 = Uh();
  d8 = void 0 === d8 ? null : d8;
  var f4 = void 0;
  if (null !== N$a) {
    var g6 = N$a.memoizedState;
    f4 = g6.destroy;
    if (null !== d8 && Mh(d8, g6.deps)) {
      e3.memoizedState = bi(b2, c6, f4, d8);
      return;
    }
  }
  M$c.flags |= a9;
  e3.memoizedState = bi(1 | b2, c6, f4, d8);
}
function mi(a9, b2) {
  return ki(8390656, 8, a9, b2);
}
function $h(a9, b2) {
  return li(2048, 8, a9, b2);
}
function ni(a9, b2) {
  return li(4, 2, a9, b2);
}
function oi(a9, b2) {
  return li(4, 4, a9, b2);
}
function pi(a9, b2) {
  if ("function" === typeof b2)
    return a9 = a9(), b2(a9), function() {
      b2(null);
    };
  if (null !== b2 && void 0 !== b2)
    return a9 = a9(), b2.current = a9, function() {
      b2.current = null;
    };
}
function qi(a9, b2, c6) {
  c6 = null !== c6 && void 0 !== c6 ? c6.concat([a9]) : null;
  return li(4, 4, pi.bind(null, b2, a9), c6);
}
function ri() {
}
function si(a9, b2) {
  var c6 = Uh();
  b2 = void 0 === b2 ? null : b2;
  var d8 = c6.memoizedState;
  if (null !== d8 && null !== b2 && Mh(b2, d8[1]))
    return d8[0];
  c6.memoizedState = [a9, b2];
  return a9;
}
function ti(a9, b2) {
  var c6 = Uh();
  b2 = void 0 === b2 ? null : b2;
  var d8 = c6.memoizedState;
  if (null !== d8 && null !== b2 && Mh(b2, d8[1]))
    return d8[0];
  a9 = a9();
  c6.memoizedState = [a9, b2];
  return a9;
}
function ui(a9, b2, c6) {
  if (0 === (Hh & 21))
    return a9.baseState && (a9.baseState = false, dh = true), a9.memoizedState = c6;
  He(c6, b2) || (c6 = yc(), M$c.lanes |= c6, rh |= c6, a9.baseState = true);
  return b2;
}
function vi(a9, b2) {
  var c6 = C$g;
  C$g = 0 !== c6 && 4 > c6 ? c6 : 4;
  a9(true);
  var d8 = Gh.transition;
  Gh.transition = {};
  try {
    a9(false), b2();
  } finally {
    C$g = c6, Gh.transition = d8;
  }
}
function wi() {
  return Uh().memoizedState;
}
function xi(a9, b2, c6) {
  var d8 = yi(a9);
  c6 = { lane: d8, action: c6, hasEagerState: false, eagerState: null, next: null };
  if (zi(a9))
    Ai(b2, c6);
  else if (c6 = hh(a9, b2, c6, d8), null !== c6) {
    var e3 = R$8();
    gi(c6, a9, d8, e3);
    Bi(c6, b2, d8);
  }
}
function ii(a9, b2, c6) {
  var d8 = yi(a9), e3 = { lane: d8, action: c6, hasEagerState: false, eagerState: null, next: null };
  if (zi(a9))
    Ai(b2, e3);
  else {
    var f4 = a9.alternate;
    if (0 === a9.lanes && (null === f4 || 0 === f4.lanes) && (f4 = b2.lastRenderedReducer, null !== f4))
      try {
        var g6 = b2.lastRenderedState, h3 = f4(g6, c6);
        e3.hasEagerState = true;
        e3.eagerState = h3;
        if (He(h3, g6)) {
          var k3 = b2.interleaved;
          null === k3 ? (e3.next = e3, gh(b2)) : (e3.next = k3.next, k3.next = e3);
          b2.interleaved = e3;
          return;
        }
      } catch (l7) {
      } finally {
      }
    c6 = hh(a9, b2, e3, d8);
    null !== c6 && (e3 = R$8(), gi(c6, a9, d8, e3), Bi(c6, b2, d8));
  }
}
function zi(a9) {
  var b2 = a9.alternate;
  return a9 === M$c || null !== b2 && b2 === M$c;
}
function Ai(a9, b2) {
  Jh = Ih = true;
  var c6 = a9.pending;
  null === c6 ? b2.next = b2 : (b2.next = c6.next, c6.next = b2);
  a9.pending = b2;
}
function Bi(a9, b2, c6) {
  if (0 !== (c6 & 4194240)) {
    var d8 = b2.lanes;
    d8 &= a9.pendingLanes;
    c6 |= d8;
    b2.lanes = c6;
    Cc(a9, c6);
  }
}
var Rh = { readContext: eh, useCallback: P$d, useContext: P$d, useEffect: P$d, useImperativeHandle: P$d, useInsertionEffect: P$d, useLayoutEffect: P$d, useMemo: P$d, useReducer: P$d, useRef: P$d, useState: P$d, useDebugValue: P$d, useDeferredValue: P$d, useTransition: P$d, useMutableSource: P$d, useSyncExternalStore: P$d, useId: P$d, unstable_isNewReconciler: false }, Oh = { readContext: eh, useCallback: function(a9, b2) {
  Th().memoizedState = [a9, void 0 === b2 ? null : b2];
  return a9;
}, useContext: eh, useEffect: mi, useImperativeHandle: function(a9, b2, c6) {
  c6 = null !== c6 && void 0 !== c6 ? c6.concat([a9]) : null;
  return ki(
    4194308,
    4,
    pi.bind(null, b2, a9),
    c6
  );
}, useLayoutEffect: function(a9, b2) {
  return ki(4194308, 4, a9, b2);
}, useInsertionEffect: function(a9, b2) {
  return ki(4, 2, a9, b2);
}, useMemo: function(a9, b2) {
  var c6 = Th();
  b2 = void 0 === b2 ? null : b2;
  a9 = a9();
  c6.memoizedState = [a9, b2];
  return a9;
}, useReducer: function(a9, b2, c6) {
  var d8 = Th();
  b2 = void 0 !== c6 ? c6(b2) : b2;
  d8.memoizedState = d8.baseState = b2;
  a9 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a9, lastRenderedState: b2 };
  d8.queue = a9;
  a9 = a9.dispatch = xi.bind(null, M$c, a9);
  return [d8.memoizedState, a9];
}, useRef: function(a9) {
  var b2 = Th();
  a9 = { current: a9 };
  return b2.memoizedState = a9;
}, useState: hi, useDebugValue: ri, useDeferredValue: function(a9) {
  return Th().memoizedState = a9;
}, useTransition: function() {
  var a9 = hi(false), b2 = a9[0];
  a9 = vi.bind(null, a9[1]);
  Th().memoizedState = a9;
  return [b2, a9];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a9, b2, c6) {
  var d8 = M$c, e3 = Th();
  if (I$e) {
    if (void 0 === c6)
      throw Error(p$A(407));
    c6 = c6();
  } else {
    c6 = b2();
    if (null === Q$7)
      throw Error(p$A(349));
    0 !== (Hh & 30) || di(d8, b2, c6);
  }
  e3.memoizedState = c6;
  var f4 = { value: c6, getSnapshot: b2 };
  e3.queue = f4;
  mi(ai.bind(
    null,
    d8,
    f4,
    a9
  ), [a9]);
  d8.flags |= 2048;
  bi(9, ci.bind(null, d8, f4, c6, b2), void 0, null);
  return c6;
}, useId: function() {
  var a9 = Th(), b2 = Q$7.identifierPrefix;
  if (I$e) {
    var c6 = sg;
    var d8 = rg;
    c6 = (d8 & ~(1 << 32 - oc(d8) - 1)).toString(32) + c6;
    b2 = ":" + b2 + "R" + c6;
    c6 = Kh++;
    0 < c6 && (b2 += "H" + c6.toString(32));
    b2 += ":";
  } else
    c6 = Lh++, b2 = ":" + b2 + "r" + c6.toString(32) + ":";
  return a9.memoizedState = b2;
}, unstable_isNewReconciler: false }, Ph = {
  readContext: eh,
  useCallback: si,
  useContext: eh,
  useEffect: $h,
  useImperativeHandle: qi,
  useInsertionEffect: ni,
  useLayoutEffect: oi,
  useMemo: ti,
  useReducer: Wh,
  useRef: ji,
  useState: function() {
    return Wh(Vh);
  },
  useDebugValue: ri,
  useDeferredValue: function(a9) {
    var b2 = Uh();
    return ui(b2, N$a.memoizedState, a9);
  },
  useTransition: function() {
    var a9 = Wh(Vh)[0], b2 = Uh().memoizedState;
    return [a9, b2];
  },
  useMutableSource: Yh,
  useSyncExternalStore: Zh,
  useId: wi,
  unstable_isNewReconciler: false
}, Qh = { readContext: eh, useCallback: si, useContext: eh, useEffect: $h, useImperativeHandle: qi, useInsertionEffect: ni, useLayoutEffect: oi, useMemo: ti, useReducer: Xh, useRef: ji, useState: function() {
  return Xh(Vh);
}, useDebugValue: ri, useDeferredValue: function(a9) {
  var b2 = Uh();
  return null === N$a ? b2.memoizedState = a9 : ui(b2, N$a.memoizedState, a9);
}, useTransition: function() {
  var a9 = Xh(Vh)[0], b2 = Uh().memoizedState;
  return [a9, b2];
}, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi, unstable_isNewReconciler: false };
function Ci(a9, b2) {
  if (a9 && a9.defaultProps) {
    b2 = A$d({}, b2);
    a9 = a9.defaultProps;
    for (var c6 in a9)
      void 0 === b2[c6] && (b2[c6] = a9[c6]);
    return b2;
  }
  return b2;
}
function Di(a9, b2, c6, d8) {
  b2 = a9.memoizedState;
  c6 = c6(d8, b2);
  c6 = null === c6 || void 0 === c6 ? b2 : A$d({}, b2, c6);
  a9.memoizedState = c6;
  0 === a9.lanes && (a9.updateQueue.baseState = c6);
}
var Ei = { isMounted: function(a9) {
  return (a9 = a9._reactInternals) ? Vb(a9) === a9 : false;
}, enqueueSetState: function(a9, b2, c6) {
  a9 = a9._reactInternals;
  var d8 = R$8(), e3 = yi(a9), f4 = mh(d8, e3);
  f4.payload = b2;
  void 0 !== c6 && null !== c6 && (f4.callback = c6);
  b2 = nh(a9, f4, e3);
  null !== b2 && (gi(b2, a9, e3, d8), oh(b2, a9, e3));
}, enqueueReplaceState: function(a9, b2, c6) {
  a9 = a9._reactInternals;
  var d8 = R$8(), e3 = yi(a9), f4 = mh(d8, e3);
  f4.tag = 1;
  f4.payload = b2;
  void 0 !== c6 && null !== c6 && (f4.callback = c6);
  b2 = nh(a9, f4, e3);
  null !== b2 && (gi(b2, a9, e3, d8), oh(b2, a9, e3));
}, enqueueForceUpdate: function(a9, b2) {
  a9 = a9._reactInternals;
  var c6 = R$8(), d8 = yi(a9), e3 = mh(c6, d8);
  e3.tag = 2;
  void 0 !== b2 && null !== b2 && (e3.callback = b2);
  b2 = nh(a9, e3, d8);
  null !== b2 && (gi(b2, a9, d8, c6), oh(b2, a9, d8));
} };
function Fi(a9, b2, c6, d8, e3, f4, g6) {
  a9 = a9.stateNode;
  return "function" === typeof a9.shouldComponentUpdate ? a9.shouldComponentUpdate(d8, f4, g6) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie$2(c6, d8) || !Ie$2(e3, f4) : true;
}
function Gi(a9, b2, c6) {
  var d8 = false, e3 = Vf;
  var f4 = b2.contextType;
  "object" === typeof f4 && null !== f4 ? f4 = eh(f4) : (e3 = Zf(b2) ? Xf : H$5.current, d8 = b2.contextTypes, f4 = (d8 = null !== d8 && void 0 !== d8) ? Yf(a9, e3) : Vf);
  b2 = new b2(c6, f4);
  a9.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
  b2.updater = Ei;
  a9.stateNode = b2;
  b2._reactInternals = a9;
  d8 && (a9 = a9.stateNode, a9.__reactInternalMemoizedUnmaskedChildContext = e3, a9.__reactInternalMemoizedMaskedChildContext = f4);
  return b2;
}
function Hi(a9, b2, c6, d8) {
  a9 = b2.state;
  "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c6, d8);
  "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c6, d8);
  b2.state !== a9 && Ei.enqueueReplaceState(b2, b2.state, null);
}
function Ii(a9, b2, c6, d8) {
  var e3 = a9.stateNode;
  e3.props = c6;
  e3.state = a9.memoizedState;
  e3.refs = {};
  kh(a9);
  var f4 = b2.contextType;
  "object" === typeof f4 && null !== f4 ? e3.context = eh(f4) : (f4 = Zf(b2) ? Xf : H$5.current, e3.context = Yf(a9, f4));
  e3.state = a9.memoizedState;
  f4 = b2.getDerivedStateFromProps;
  "function" === typeof f4 && (Di(a9, b2, f4, c6), e3.state = a9.memoizedState);
  "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e3.getSnapshotBeforeUpdate || "function" !== typeof e3.UNSAFE_componentWillMount && "function" !== typeof e3.componentWillMount || (b2 = e3.state, "function" === typeof e3.componentWillMount && e3.componentWillMount(), "function" === typeof e3.UNSAFE_componentWillMount && e3.UNSAFE_componentWillMount(), b2 !== e3.state && Ei.enqueueReplaceState(e3, e3.state, null), qh(a9, c6, e3, d8), e3.state = a9.memoizedState);
  "function" === typeof e3.componentDidMount && (a9.flags |= 4194308);
}
function Ji(a9, b2) {
  try {
    var c6 = "", d8 = b2;
    do
      c6 += Pa(d8), d8 = d8.return;
    while (d8);
    var e3 = c6;
  } catch (f4) {
    e3 = "\nError generating stack: " + f4.message + "\n" + f4.stack;
  }
  return { value: a9, source: b2, stack: e3, digest: null };
}
function Ki(a9, b2, c6) {
  return { value: a9, source: null, stack: null != c6 ? c6 : null, digest: null != b2 ? b2 : null };
}
function Li(a9, b2) {
  try {
    console.error(b2.value);
  } catch (c6) {
    setTimeout(function() {
      throw c6;
    });
  }
}
var Mi = "function" === typeof WeakMap ? WeakMap : Map;
function Ni(a9, b2, c6) {
  c6 = mh(-1, c6);
  c6.tag = 3;
  c6.payload = { element: null };
  var d8 = b2.value;
  c6.callback = function() {
    Oi || (Oi = true, Pi = d8);
    Li(a9, b2);
  };
  return c6;
}
function Qi(a9, b2, c6) {
  c6 = mh(-1, c6);
  c6.tag = 3;
  var d8 = a9.type.getDerivedStateFromError;
  if ("function" === typeof d8) {
    var e3 = b2.value;
    c6.payload = function() {
      return d8(e3);
    };
    c6.callback = function() {
      Li(a9, b2);
    };
  }
  var f4 = a9.stateNode;
  null !== f4 && "function" === typeof f4.componentDidCatch && (c6.callback = function() {
    Li(a9, b2);
    "function" !== typeof d8 && (null === Ri ? Ri = /* @__PURE__ */ new Set([this]) : Ri.add(this));
    var c7 = b2.stack;
    this.componentDidCatch(b2.value, { componentStack: null !== c7 ? c7 : "" });
  });
  return c6;
}
function Si(a9, b2, c6) {
  var d8 = a9.pingCache;
  if (null === d8) {
    d8 = a9.pingCache = new Mi();
    var e3 = /* @__PURE__ */ new Set();
    d8.set(b2, e3);
  } else
    e3 = d8.get(b2), void 0 === e3 && (e3 = /* @__PURE__ */ new Set(), d8.set(b2, e3));
  e3.has(c6) || (e3.add(c6), a9 = Ti.bind(null, a9, b2, c6), b2.then(a9, a9));
}
function Ui(a9) {
  do {
    var b2;
    if (b2 = 13 === a9.tag)
      b2 = a9.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
    if (b2)
      return a9;
    a9 = a9.return;
  } while (null !== a9);
  return null;
}
function Vi(a9, b2, c6, d8, e3) {
  if (0 === (a9.mode & 1))
    return a9 === b2 ? a9.flags |= 65536 : (a9.flags |= 128, c6.flags |= 131072, c6.flags &= -52805, 1 === c6.tag && (null === c6.alternate ? c6.tag = 17 : (b2 = mh(-1, 1), b2.tag = 2, nh(c6, b2, 1))), c6.lanes |= 1), a9;
  a9.flags |= 65536;
  a9.lanes = e3;
  return a9;
}
var Wi = ua.ReactCurrentOwner, dh = false;
function Xi(a9, b2, c6, d8) {
  b2.child = null === a9 ? Vg(b2, null, c6, d8) : Ug(b2, a9.child, c6, d8);
}
function Yi(a9, b2, c6, d8, e3) {
  c6 = c6.render;
  var f4 = b2.ref;
  ch(b2, e3);
  d8 = Nh(a9, b2, c6, d8, f4, e3);
  c6 = Sh();
  if (null !== a9 && !dh)
    return b2.updateQueue = a9.updateQueue, b2.flags &= -2053, a9.lanes &= ~e3, Zi(a9, b2, e3);
  I$e && c6 && vg(b2);
  b2.flags |= 1;
  Xi(a9, b2, d8, e3);
  return b2.child;
}
function $i(a9, b2, c6, d8, e3) {
  if (null === a9) {
    var f4 = c6.type;
    if ("function" === typeof f4 && !aj(f4) && void 0 === f4.defaultProps && null === c6.compare && void 0 === c6.defaultProps)
      return b2.tag = 15, b2.type = f4, bj(a9, b2, f4, d8, e3);
    a9 = Rg(c6.type, null, d8, b2, b2.mode, e3);
    a9.ref = b2.ref;
    a9.return = b2;
    return b2.child = a9;
  }
  f4 = a9.child;
  if (0 === (a9.lanes & e3)) {
    var g6 = f4.memoizedProps;
    c6 = c6.compare;
    c6 = null !== c6 ? c6 : Ie$2;
    if (c6(g6, d8) && a9.ref === b2.ref)
      return Zi(a9, b2, e3);
  }
  b2.flags |= 1;
  a9 = Pg(f4, d8);
  a9.ref = b2.ref;
  a9.return = b2;
  return b2.child = a9;
}
function bj(a9, b2, c6, d8, e3) {
  if (null !== a9) {
    var f4 = a9.memoizedProps;
    if (Ie$2(f4, d8) && a9.ref === b2.ref)
      if (dh = false, b2.pendingProps = d8 = f4, 0 !== (a9.lanes & e3))
        0 !== (a9.flags & 131072) && (dh = true);
      else
        return b2.lanes = a9.lanes, Zi(a9, b2, e3);
  }
  return cj(a9, b2, c6, d8, e3);
}
function dj(a9, b2, c6) {
  var d8 = b2.pendingProps, e3 = d8.children, f4 = null !== a9 ? a9.memoizedState : null;
  if ("hidden" === d8.mode)
    if (0 === (b2.mode & 1))
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G$a(ej, fj), fj |= c6;
    else {
      if (0 === (c6 & 1073741824))
        return a9 = null !== f4 ? f4.baseLanes | c6 : c6, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a9, cachePool: null, transitions: null }, b2.updateQueue = null, G$a(ej, fj), fj |= a9, null;
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
      d8 = null !== f4 ? f4.baseLanes : c6;
      G$a(ej, fj);
      fj |= d8;
    }
  else
    null !== f4 ? (d8 = f4.baseLanes | c6, b2.memoizedState = null) : d8 = c6, G$a(ej, fj), fj |= d8;
  Xi(a9, b2, e3, c6);
  return b2.child;
}
function gj(a9, b2) {
  var c6 = b2.ref;
  if (null === a9 && null !== c6 || null !== a9 && a9.ref !== c6)
    b2.flags |= 512, b2.flags |= 2097152;
}
function cj(a9, b2, c6, d8, e3) {
  var f4 = Zf(c6) ? Xf : H$5.current;
  f4 = Yf(b2, f4);
  ch(b2, e3);
  c6 = Nh(a9, b2, c6, d8, f4, e3);
  d8 = Sh();
  if (null !== a9 && !dh)
    return b2.updateQueue = a9.updateQueue, b2.flags &= -2053, a9.lanes &= ~e3, Zi(a9, b2, e3);
  I$e && d8 && vg(b2);
  b2.flags |= 1;
  Xi(a9, b2, c6, e3);
  return b2.child;
}
function hj(a9, b2, c6, d8, e3) {
  if (Zf(c6)) {
    var f4 = true;
    cg(b2);
  } else
    f4 = false;
  ch(b2, e3);
  if (null === b2.stateNode)
    ij(a9, b2), Gi(b2, c6, d8), Ii(b2, c6, d8, e3), d8 = true;
  else if (null === a9) {
    var g6 = b2.stateNode, h3 = b2.memoizedProps;
    g6.props = h3;
    var k3 = g6.context, l7 = c6.contextType;
    "object" === typeof l7 && null !== l7 ? l7 = eh(l7) : (l7 = Zf(c6) ? Xf : H$5.current, l7 = Yf(b2, l7));
    var m3 = c6.getDerivedStateFromProps, q2 = "function" === typeof m3 || "function" === typeof g6.getSnapshotBeforeUpdate;
    q2 || "function" !== typeof g6.UNSAFE_componentWillReceiveProps && "function" !== typeof g6.componentWillReceiveProps || (h3 !== d8 || k3 !== l7) && Hi(b2, g6, d8, l7);
    jh = false;
    var r12 = b2.memoizedState;
    g6.state = r12;
    qh(b2, d8, g6, e3);
    k3 = b2.memoizedState;
    h3 !== d8 || r12 !== k3 || Wf.current || jh ? ("function" === typeof m3 && (Di(b2, c6, m3, d8), k3 = b2.memoizedState), (h3 = jh || Fi(b2, c6, h3, d8, r12, k3, l7)) ? (q2 || "function" !== typeof g6.UNSAFE_componentWillMount && "function" !== typeof g6.componentWillMount || ("function" === typeof g6.componentWillMount && g6.componentWillMount(), "function" === typeof g6.UNSAFE_componentWillMount && g6.UNSAFE_componentWillMount()), "function" === typeof g6.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g6.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d8, b2.memoizedState = k3), g6.props = d8, g6.state = k3, g6.context = l7, d8 = h3) : ("function" === typeof g6.componentDidMount && (b2.flags |= 4194308), d8 = false);
  } else {
    g6 = b2.stateNode;
    lh(a9, b2);
    h3 = b2.memoizedProps;
    l7 = b2.type === b2.elementType ? h3 : Ci(b2.type, h3);
    g6.props = l7;
    q2 = b2.pendingProps;
    r12 = g6.context;
    k3 = c6.contextType;
    "object" === typeof k3 && null !== k3 ? k3 = eh(k3) : (k3 = Zf(c6) ? Xf : H$5.current, k3 = Yf(b2, k3));
    var y4 = c6.getDerivedStateFromProps;
    (m3 = "function" === typeof y4 || "function" === typeof g6.getSnapshotBeforeUpdate) || "function" !== typeof g6.UNSAFE_componentWillReceiveProps && "function" !== typeof g6.componentWillReceiveProps || (h3 !== q2 || r12 !== k3) && Hi(b2, g6, d8, k3);
    jh = false;
    r12 = b2.memoizedState;
    g6.state = r12;
    qh(b2, d8, g6, e3);
    var n10 = b2.memoizedState;
    h3 !== q2 || r12 !== n10 || Wf.current || jh ? ("function" === typeof y4 && (Di(b2, c6, y4, d8), n10 = b2.memoizedState), (l7 = jh || Fi(b2, c6, l7, d8, r12, n10, k3) || false) ? (m3 || "function" !== typeof g6.UNSAFE_componentWillUpdate && "function" !== typeof g6.componentWillUpdate || ("function" === typeof g6.componentWillUpdate && g6.componentWillUpdate(d8, n10, k3), "function" === typeof g6.UNSAFE_componentWillUpdate && g6.UNSAFE_componentWillUpdate(d8, n10, k3)), "function" === typeof g6.componentDidUpdate && (b2.flags |= 4), "function" === typeof g6.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g6.componentDidUpdate || h3 === a9.memoizedProps && r12 === a9.memoizedState || (b2.flags |= 4), "function" !== typeof g6.getSnapshotBeforeUpdate || h3 === a9.memoizedProps && r12 === a9.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d8, b2.memoizedState = n10), g6.props = d8, g6.state = n10, g6.context = k3, d8 = l7) : ("function" !== typeof g6.componentDidUpdate || h3 === a9.memoizedProps && r12 === a9.memoizedState || (b2.flags |= 4), "function" !== typeof g6.getSnapshotBeforeUpdate || h3 === a9.memoizedProps && r12 === a9.memoizedState || (b2.flags |= 1024), d8 = false);
  }
  return jj(a9, b2, c6, d8, f4, e3);
}
function jj(a9, b2, c6, d8, e3, f4) {
  gj(a9, b2);
  var g6 = 0 !== (b2.flags & 128);
  if (!d8 && !g6)
    return e3 && dg(b2, c6, false), Zi(a9, b2, f4);
  d8 = b2.stateNode;
  Wi.current = b2;
  var h3 = g6 && "function" !== typeof c6.getDerivedStateFromError ? null : d8.render();
  b2.flags |= 1;
  null !== a9 && g6 ? (b2.child = Ug(b2, a9.child, null, f4), b2.child = Ug(b2, null, h3, f4)) : Xi(a9, b2, h3, f4);
  b2.memoizedState = d8.state;
  e3 && dg(b2, c6, true);
  return b2.child;
}
function kj(a9) {
  var b2 = a9.stateNode;
  b2.pendingContext ? ag(a9, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a9, b2.context, false);
  yh(a9, b2.containerInfo);
}
function lj(a9, b2, c6, d8, e3) {
  Ig();
  Jg(e3);
  b2.flags |= 256;
  Xi(a9, b2, c6, d8);
  return b2.child;
}
var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
function nj(a9) {
  return { baseLanes: a9, cachePool: null, transitions: null };
}
function oj(a9, b2, c6) {
  var d8 = b2.pendingProps, e3 = L$d.current, f4 = false, g6 = 0 !== (b2.flags & 128), h3;
  (h3 = g6) || (h3 = null !== a9 && null === a9.memoizedState ? false : 0 !== (e3 & 2));
  if (h3)
    f4 = true, b2.flags &= -129;
  else if (null === a9 || null !== a9.memoizedState)
    e3 |= 1;
  G$a(L$d, e3 & 1);
  if (null === a9) {
    Eg(b2);
    a9 = b2.memoizedState;
    if (null !== a9 && (a9 = a9.dehydrated, null !== a9))
      return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a9.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
    g6 = d8.children;
    a9 = d8.fallback;
    return f4 ? (d8 = b2.mode, f4 = b2.child, g6 = { mode: "hidden", children: g6 }, 0 === (d8 & 1) && null !== f4 ? (f4.childLanes = 0, f4.pendingProps = g6) : f4 = pj(g6, d8, 0, null), a9 = Tg(a9, d8, c6, null), f4.return = b2, a9.return = b2, f4.sibling = a9, b2.child = f4, b2.child.memoizedState = nj(c6), b2.memoizedState = mj, a9) : qj(b2, g6);
  }
  e3 = a9.memoizedState;
  if (null !== e3 && (h3 = e3.dehydrated, null !== h3))
    return rj(a9, b2, g6, d8, h3, e3, c6);
  if (f4) {
    f4 = d8.fallback;
    g6 = b2.mode;
    e3 = a9.child;
    h3 = e3.sibling;
    var k3 = { mode: "hidden", children: d8.children };
    0 === (g6 & 1) && b2.child !== e3 ? (d8 = b2.child, d8.childLanes = 0, d8.pendingProps = k3, b2.deletions = null) : (d8 = Pg(e3, k3), d8.subtreeFlags = e3.subtreeFlags & 14680064);
    null !== h3 ? f4 = Pg(h3, f4) : (f4 = Tg(f4, g6, c6, null), f4.flags |= 2);
    f4.return = b2;
    d8.return = b2;
    d8.sibling = f4;
    b2.child = d8;
    d8 = f4;
    f4 = b2.child;
    g6 = a9.child.memoizedState;
    g6 = null === g6 ? nj(c6) : { baseLanes: g6.baseLanes | c6, cachePool: null, transitions: g6.transitions };
    f4.memoizedState = g6;
    f4.childLanes = a9.childLanes & ~c6;
    b2.memoizedState = mj;
    return d8;
  }
  f4 = a9.child;
  a9 = f4.sibling;
  d8 = Pg(f4, { mode: "visible", children: d8.children });
  0 === (b2.mode & 1) && (d8.lanes = c6);
  d8.return = b2;
  d8.sibling = null;
  null !== a9 && (c6 = b2.deletions, null === c6 ? (b2.deletions = [a9], b2.flags |= 16) : c6.push(a9));
  b2.child = d8;
  b2.memoizedState = null;
  return d8;
}
function qj(a9, b2) {
  b2 = pj({ mode: "visible", children: b2 }, a9.mode, 0, null);
  b2.return = a9;
  return a9.child = b2;
}
function sj(a9, b2, c6, d8) {
  null !== d8 && Jg(d8);
  Ug(b2, a9.child, null, c6);
  a9 = qj(b2, b2.pendingProps.children);
  a9.flags |= 2;
  b2.memoizedState = null;
  return a9;
}
function rj(a9, b2, c6, d8, e3, f4, g6) {
  if (c6) {
    if (b2.flags & 256)
      return b2.flags &= -257, d8 = Ki(Error(p$A(422))), sj(a9, b2, g6, d8);
    if (null !== b2.memoizedState)
      return b2.child = a9.child, b2.flags |= 128, null;
    f4 = d8.fallback;
    e3 = b2.mode;
    d8 = pj({ mode: "visible", children: d8.children }, e3, 0, null);
    f4 = Tg(f4, e3, g6, null);
    f4.flags |= 2;
    d8.return = b2;
    f4.return = b2;
    d8.sibling = f4;
    b2.child = d8;
    0 !== (b2.mode & 1) && Ug(b2, a9.child, null, g6);
    b2.child.memoizedState = nj(g6);
    b2.memoizedState = mj;
    return f4;
  }
  if (0 === (b2.mode & 1))
    return sj(a9, b2, g6, null);
  if ("$!" === e3.data) {
    d8 = e3.nextSibling && e3.nextSibling.dataset;
    if (d8)
      var h3 = d8.dgst;
    d8 = h3;
    f4 = Error(p$A(419));
    d8 = Ki(f4, d8, void 0);
    return sj(a9, b2, g6, d8);
  }
  h3 = 0 !== (g6 & a9.childLanes);
  if (dh || h3) {
    d8 = Q$7;
    if (null !== d8) {
      switch (g6 & -g6) {
        case 4:
          e3 = 2;
          break;
        case 16:
          e3 = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e3 = 32;
          break;
        case 536870912:
          e3 = 268435456;
          break;
        default:
          e3 = 0;
      }
      e3 = 0 !== (e3 & (d8.suspendedLanes | g6)) ? 0 : e3;
      0 !== e3 && e3 !== f4.retryLane && (f4.retryLane = e3, ih(a9, e3), gi(d8, a9, e3, -1));
    }
    tj();
    d8 = Ki(Error(p$A(421)));
    return sj(a9, b2, g6, d8);
  }
  if ("$?" === e3.data)
    return b2.flags |= 128, b2.child = a9.child, b2 = uj.bind(null, a9), e3._reactRetry = b2, null;
  a9 = f4.treeContext;
  yg = Lf(e3.nextSibling);
  xg = b2;
  I$e = true;
  zg = null;
  null !== a9 && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a9.id, sg = a9.overflow, qg = b2);
  b2 = qj(b2, d8.children);
  b2.flags |= 4096;
  return b2;
}
function vj(a9, b2, c6) {
  a9.lanes |= b2;
  var d8 = a9.alternate;
  null !== d8 && (d8.lanes |= b2);
  bh(a9.return, b2, c6);
}
function wj(a9, b2, c6, d8, e3) {
  var f4 = a9.memoizedState;
  null === f4 ? a9.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d8, tail: c6, tailMode: e3 } : (f4.isBackwards = b2, f4.rendering = null, f4.renderingStartTime = 0, f4.last = d8, f4.tail = c6, f4.tailMode = e3);
}
function xj(a9, b2, c6) {
  var d8 = b2.pendingProps, e3 = d8.revealOrder, f4 = d8.tail;
  Xi(a9, b2, d8.children, c6);
  d8 = L$d.current;
  if (0 !== (d8 & 2))
    d8 = d8 & 1 | 2, b2.flags |= 128;
  else {
    if (null !== a9 && 0 !== (a9.flags & 128))
      a:
        for (a9 = b2.child; null !== a9; ) {
          if (13 === a9.tag)
            null !== a9.memoizedState && vj(a9, c6, b2);
          else if (19 === a9.tag)
            vj(a9, c6, b2);
          else if (null !== a9.child) {
            a9.child.return = a9;
            a9 = a9.child;
            continue;
          }
          if (a9 === b2)
            break a;
          for (; null === a9.sibling; ) {
            if (null === a9.return || a9.return === b2)
              break a;
            a9 = a9.return;
          }
          a9.sibling.return = a9.return;
          a9 = a9.sibling;
        }
    d8 &= 1;
  }
  G$a(L$d, d8);
  if (0 === (b2.mode & 1))
    b2.memoizedState = null;
  else
    switch (e3) {
      case "forwards":
        c6 = b2.child;
        for (e3 = null; null !== c6; )
          a9 = c6.alternate, null !== a9 && null === Ch(a9) && (e3 = c6), c6 = c6.sibling;
        c6 = e3;
        null === c6 ? (e3 = b2.child, b2.child = null) : (e3 = c6.sibling, c6.sibling = null);
        wj(b2, false, e3, c6, f4);
        break;
      case "backwards":
        c6 = null;
        e3 = b2.child;
        for (b2.child = null; null !== e3; ) {
          a9 = e3.alternate;
          if (null !== a9 && null === Ch(a9)) {
            b2.child = e3;
            break;
          }
          a9 = e3.sibling;
          e3.sibling = c6;
          c6 = e3;
          e3 = a9;
        }
        wj(b2, true, c6, null, f4);
        break;
      case "together":
        wj(b2, false, null, null, void 0);
        break;
      default:
        b2.memoizedState = null;
    }
  return b2.child;
}
function ij(a9, b2) {
  0 === (b2.mode & 1) && null !== a9 && (a9.alternate = null, b2.alternate = null, b2.flags |= 2);
}
function Zi(a9, b2, c6) {
  null !== a9 && (b2.dependencies = a9.dependencies);
  rh |= b2.lanes;
  if (0 === (c6 & b2.childLanes))
    return null;
  if (null !== a9 && b2.child !== a9.child)
    throw Error(p$A(153));
  if (null !== b2.child) {
    a9 = b2.child;
    c6 = Pg(a9, a9.pendingProps);
    b2.child = c6;
    for (c6.return = b2; null !== a9.sibling; )
      a9 = a9.sibling, c6 = c6.sibling = Pg(a9, a9.pendingProps), c6.return = b2;
    c6.sibling = null;
  }
  return b2.child;
}
function yj(a9, b2, c6) {
  switch (b2.tag) {
    case 3:
      kj(b2);
      Ig();
      break;
    case 5:
      Ah(b2);
      break;
    case 1:
      Zf(b2.type) && cg(b2);
      break;
    case 4:
      yh(b2, b2.stateNode.containerInfo);
      break;
    case 10:
      var d8 = b2.type._context, e3 = b2.memoizedProps.value;
      G$a(Wg, d8._currentValue);
      d8._currentValue = e3;
      break;
    case 13:
      d8 = b2.memoizedState;
      if (null !== d8) {
        if (null !== d8.dehydrated)
          return G$a(L$d, L$d.current & 1), b2.flags |= 128, null;
        if (0 !== (c6 & b2.child.childLanes))
          return oj(a9, b2, c6);
        G$a(L$d, L$d.current & 1);
        a9 = Zi(a9, b2, c6);
        return null !== a9 ? a9.sibling : null;
      }
      G$a(L$d, L$d.current & 1);
      break;
    case 19:
      d8 = 0 !== (c6 & b2.childLanes);
      if (0 !== (a9.flags & 128)) {
        if (d8)
          return xj(a9, b2, c6);
        b2.flags |= 128;
      }
      e3 = b2.memoizedState;
      null !== e3 && (e3.rendering = null, e3.tail = null, e3.lastEffect = null);
      G$a(L$d, L$d.current);
      if (d8)
        break;
      else
        return null;
    case 22:
    case 23:
      return b2.lanes = 0, dj(a9, b2, c6);
  }
  return Zi(a9, b2, c6);
}
var zj, Aj, Bj, Cj;
zj = function(a9, b2) {
  for (var c6 = b2.child; null !== c6; ) {
    if (5 === c6.tag || 6 === c6.tag)
      a9.appendChild(c6.stateNode);
    else if (4 !== c6.tag && null !== c6.child) {
      c6.child.return = c6;
      c6 = c6.child;
      continue;
    }
    if (c6 === b2)
      break;
    for (; null === c6.sibling; ) {
      if (null === c6.return || c6.return === b2)
        return;
      c6 = c6.return;
    }
    c6.sibling.return = c6.return;
    c6 = c6.sibling;
  }
};
Aj = function() {
};
Bj = function(a9, b2, c6, d8) {
  var e3 = a9.memoizedProps;
  if (e3 !== d8) {
    a9 = b2.stateNode;
    xh(uh.current);
    var f4 = null;
    switch (c6) {
      case "input":
        e3 = Ya(a9, e3);
        d8 = Ya(a9, d8);
        f4 = [];
        break;
      case "select":
        e3 = A$d({}, e3, { value: void 0 });
        d8 = A$d({}, d8, { value: void 0 });
        f4 = [];
        break;
      case "textarea":
        e3 = gb(a9, e3);
        d8 = gb(a9, d8);
        f4 = [];
        break;
      default:
        "function" !== typeof e3.onClick && "function" === typeof d8.onClick && (a9.onclick = Bf);
    }
    ub(c6, d8);
    var g6;
    c6 = null;
    for (l7 in e3)
      if (!d8.hasOwnProperty(l7) && e3.hasOwnProperty(l7) && null != e3[l7])
        if ("style" === l7) {
          var h3 = e3[l7];
          for (g6 in h3)
            h3.hasOwnProperty(g6) && (c6 || (c6 = {}), c6[g6] = "");
        } else
          "dangerouslySetInnerHTML" !== l7 && "children" !== l7 && "suppressContentEditableWarning" !== l7 && "suppressHydrationWarning" !== l7 && "autoFocus" !== l7 && (ea.hasOwnProperty(l7) ? f4 || (f4 = []) : (f4 = f4 || []).push(l7, null));
    for (l7 in d8) {
      var k3 = d8[l7];
      h3 = null != e3 ? e3[l7] : void 0;
      if (d8.hasOwnProperty(l7) && k3 !== h3 && (null != k3 || null != h3))
        if ("style" === l7)
          if (h3) {
            for (g6 in h3)
              !h3.hasOwnProperty(g6) || k3 && k3.hasOwnProperty(g6) || (c6 || (c6 = {}), c6[g6] = "");
            for (g6 in k3)
              k3.hasOwnProperty(g6) && h3[g6] !== k3[g6] && (c6 || (c6 = {}), c6[g6] = k3[g6]);
          } else
            c6 || (f4 || (f4 = []), f4.push(
              l7,
              c6
            )), c6 = k3;
        else
          "dangerouslySetInnerHTML" === l7 ? (k3 = k3 ? k3.__html : void 0, h3 = h3 ? h3.__html : void 0, null != k3 && h3 !== k3 && (f4 = f4 || []).push(l7, k3)) : "children" === l7 ? "string" !== typeof k3 && "number" !== typeof k3 || (f4 = f4 || []).push(l7, "" + k3) : "suppressContentEditableWarning" !== l7 && "suppressHydrationWarning" !== l7 && (ea.hasOwnProperty(l7) ? (null != k3 && "onScroll" === l7 && D$6("scroll", a9), f4 || h3 === k3 || (f4 = [])) : (f4 = f4 || []).push(l7, k3));
    }
    c6 && (f4 = f4 || []).push("style", c6);
    var l7 = f4;
    if (b2.updateQueue = l7)
      b2.flags |= 4;
  }
};
Cj = function(a9, b2, c6, d8) {
  c6 !== d8 && (b2.flags |= 4);
};
function Dj(a9, b2) {
  if (!I$e)
    switch (a9.tailMode) {
      case "hidden":
        b2 = a9.tail;
        for (var c6 = null; null !== b2; )
          null !== b2.alternate && (c6 = b2), b2 = b2.sibling;
        null === c6 ? a9.tail = null : c6.sibling = null;
        break;
      case "collapsed":
        c6 = a9.tail;
        for (var d8 = null; null !== c6; )
          null !== c6.alternate && (d8 = c6), c6 = c6.sibling;
        null === d8 ? b2 || null === a9.tail ? a9.tail = null : a9.tail.sibling = null : d8.sibling = null;
    }
}
function S$c(a9) {
  var b2 = null !== a9.alternate && a9.alternate.child === a9.child, c6 = 0, d8 = 0;
  if (b2)
    for (var e3 = a9.child; null !== e3; )
      c6 |= e3.lanes | e3.childLanes, d8 |= e3.subtreeFlags & 14680064, d8 |= e3.flags & 14680064, e3.return = a9, e3 = e3.sibling;
  else
    for (e3 = a9.child; null !== e3; )
      c6 |= e3.lanes | e3.childLanes, d8 |= e3.subtreeFlags, d8 |= e3.flags, e3.return = a9, e3 = e3.sibling;
  a9.subtreeFlags |= d8;
  a9.childLanes = c6;
  return b2;
}
function Ej(a9, b2, c6) {
  var d8 = b2.pendingProps;
  wg(b2);
  switch (b2.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S$c(b2), null;
    case 1:
      return Zf(b2.type) && $f(), S$c(b2), null;
    case 3:
      d8 = b2.stateNode;
      zh();
      E$d(Wf);
      E$d(H$5);
      Eh();
      d8.pendingContext && (d8.context = d8.pendingContext, d8.pendingContext = null);
      if (null === a9 || null === a9.child)
        Gg(b2) ? b2.flags |= 4 : null === a9 || a9.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Fj(zg), zg = null));
      Aj(a9, b2);
      S$c(b2);
      return null;
    case 5:
      Bh(b2);
      var e3 = xh(wh.current);
      c6 = b2.type;
      if (null !== a9 && null != b2.stateNode)
        Bj(a9, b2, c6, d8, e3), a9.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      else {
        if (!d8) {
          if (null === b2.stateNode)
            throw Error(p$A(166));
          S$c(b2);
          return null;
        }
        a9 = xh(uh.current);
        if (Gg(b2)) {
          d8 = b2.stateNode;
          c6 = b2.type;
          var f4 = b2.memoizedProps;
          d8[Of] = b2;
          d8[Pf] = f4;
          a9 = 0 !== (b2.mode & 1);
          switch (c6) {
            case "dialog":
              D$6("cancel", d8);
              D$6("close", d8);
              break;
            case "iframe":
            case "object":
            case "embed":
              D$6("load", d8);
              break;
            case "video":
            case "audio":
              for (e3 = 0; e3 < lf.length; e3++)
                D$6(lf[e3], d8);
              break;
            case "source":
              D$6("error", d8);
              break;
            case "img":
            case "image":
            case "link":
              D$6(
                "error",
                d8
              );
              D$6("load", d8);
              break;
            case "details":
              D$6("toggle", d8);
              break;
            case "input":
              Za(d8, f4);
              D$6("invalid", d8);
              break;
            case "select":
              d8._wrapperState = { wasMultiple: !!f4.multiple };
              D$6("invalid", d8);
              break;
            case "textarea":
              hb(d8, f4), D$6("invalid", d8);
          }
          ub(c6, f4);
          e3 = null;
          for (var g6 in f4)
            if (f4.hasOwnProperty(g6)) {
              var h3 = f4[g6];
              "children" === g6 ? "string" === typeof h3 ? d8.textContent !== h3 && (true !== f4.suppressHydrationWarning && Af(d8.textContent, h3, a9), e3 = ["children", h3]) : "number" === typeof h3 && d8.textContent !== "" + h3 && (true !== f4.suppressHydrationWarning && Af(
                d8.textContent,
                h3,
                a9
              ), e3 = ["children", "" + h3]) : ea.hasOwnProperty(g6) && null != h3 && "onScroll" === g6 && D$6("scroll", d8);
            }
          switch (c6) {
            case "input":
              Va(d8);
              db(d8, f4, true);
              break;
            case "textarea":
              Va(d8);
              jb(d8);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f4.onClick && (d8.onclick = Bf);
          }
          d8 = e3;
          b2.updateQueue = d8;
          null !== d8 && (b2.flags |= 4);
        } else {
          g6 = 9 === e3.nodeType ? e3 : e3.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a9 && (a9 = kb(c6));
          "http://www.w3.org/1999/xhtml" === a9 ? "script" === c6 ? (a9 = g6.createElement("div"), a9.innerHTML = "<script><\/script>", a9 = a9.removeChild(a9.firstChild)) : "string" === typeof d8.is ? a9 = g6.createElement(c6, { is: d8.is }) : (a9 = g6.createElement(c6), "select" === c6 && (g6 = a9, d8.multiple ? g6.multiple = true : d8.size && (g6.size = d8.size))) : a9 = g6.createElementNS(a9, c6);
          a9[Of] = b2;
          a9[Pf] = d8;
          zj(a9, b2, false, false);
          b2.stateNode = a9;
          a: {
            g6 = vb(c6, d8);
            switch (c6) {
              case "dialog":
                D$6("cancel", a9);
                D$6("close", a9);
                e3 = d8;
                break;
              case "iframe":
              case "object":
              case "embed":
                D$6("load", a9);
                e3 = d8;
                break;
              case "video":
              case "audio":
                for (e3 = 0; e3 < lf.length; e3++)
                  D$6(lf[e3], a9);
                e3 = d8;
                break;
              case "source":
                D$6("error", a9);
                e3 = d8;
                break;
              case "img":
              case "image":
              case "link":
                D$6(
                  "error",
                  a9
                );
                D$6("load", a9);
                e3 = d8;
                break;
              case "details":
                D$6("toggle", a9);
                e3 = d8;
                break;
              case "input":
                Za(a9, d8);
                e3 = Ya(a9, d8);
                D$6("invalid", a9);
                break;
              case "option":
                e3 = d8;
                break;
              case "select":
                a9._wrapperState = { wasMultiple: !!d8.multiple };
                e3 = A$d({}, d8, { value: void 0 });
                D$6("invalid", a9);
                break;
              case "textarea":
                hb(a9, d8);
                e3 = gb(a9, d8);
                D$6("invalid", a9);
                break;
              default:
                e3 = d8;
            }
            ub(c6, e3);
            h3 = e3;
            for (f4 in h3)
              if (h3.hasOwnProperty(f4)) {
                var k3 = h3[f4];
                "style" === f4 ? sb(a9, k3) : "dangerouslySetInnerHTML" === f4 ? (k3 = k3 ? k3.__html : void 0, null != k3 && nb(a9, k3)) : "children" === f4 ? "string" === typeof k3 ? ("textarea" !== c6 || "" !== k3) && ob(a9, k3) : "number" === typeof k3 && ob(a9, "" + k3) : "suppressContentEditableWarning" !== f4 && "suppressHydrationWarning" !== f4 && "autoFocus" !== f4 && (ea.hasOwnProperty(f4) ? null != k3 && "onScroll" === f4 && D$6("scroll", a9) : null != k3 && ta(a9, f4, k3, g6));
              }
            switch (c6) {
              case "input":
                Va(a9);
                db(a9, d8, false);
                break;
              case "textarea":
                Va(a9);
                jb(a9);
                break;
              case "option":
                null != d8.value && a9.setAttribute("value", "" + Sa(d8.value));
                break;
              case "select":
                a9.multiple = !!d8.multiple;
                f4 = d8.value;
                null != f4 ? fb(a9, !!d8.multiple, f4, false) : null != d8.defaultValue && fb(
                  a9,
                  !!d8.multiple,
                  d8.defaultValue,
                  true
                );
                break;
              default:
                "function" === typeof e3.onClick && (a9.onclick = Bf);
            }
            switch (c6) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d8 = !!d8.autoFocus;
                break a;
              case "img":
                d8 = true;
                break a;
              default:
                d8 = false;
            }
          }
          d8 && (b2.flags |= 4);
        }
        null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      }
      S$c(b2);
      return null;
    case 6:
      if (a9 && null != b2.stateNode)
        Cj(a9, b2, a9.memoizedProps, d8);
      else {
        if ("string" !== typeof d8 && null === b2.stateNode)
          throw Error(p$A(166));
        c6 = xh(wh.current);
        xh(uh.current);
        if (Gg(b2)) {
          d8 = b2.stateNode;
          c6 = b2.memoizedProps;
          d8[Of] = b2;
          if (f4 = d8.nodeValue !== c6) {
            if (a9 = xg, null !== a9)
              switch (a9.tag) {
                case 3:
                  Af(d8.nodeValue, c6, 0 !== (a9.mode & 1));
                  break;
                case 5:
                  true !== a9.memoizedProps.suppressHydrationWarning && Af(d8.nodeValue, c6, 0 !== (a9.mode & 1));
              }
          }
          f4 && (b2.flags |= 4);
        } else
          d8 = (9 === c6.nodeType ? c6 : c6.ownerDocument).createTextNode(d8), d8[Of] = b2, b2.stateNode = d8;
      }
      S$c(b2);
      return null;
    case 13:
      E$d(L$d);
      d8 = b2.memoizedState;
      if (null === a9 || null !== a9.memoizedState && null !== a9.memoizedState.dehydrated) {
        if (I$e && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128))
          Hg(), Ig(), b2.flags |= 98560, f4 = false;
        else if (f4 = Gg(b2), null !== d8 && null !== d8.dehydrated) {
          if (null === a9) {
            if (!f4)
              throw Error(p$A(318));
            f4 = b2.memoizedState;
            f4 = null !== f4 ? f4.dehydrated : null;
            if (!f4)
              throw Error(p$A(317));
            f4[Of] = b2;
          } else
            Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
          S$c(b2);
          f4 = false;
        } else
          null !== zg && (Fj(zg), zg = null), f4 = true;
        if (!f4)
          return b2.flags & 65536 ? b2 : null;
      }
      if (0 !== (b2.flags & 128))
        return b2.lanes = c6, b2;
      d8 = null !== d8;
      d8 !== (null !== a9 && null !== a9.memoizedState) && d8 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a9 || 0 !== (L$d.current & 1) ? 0 === T$a && (T$a = 3) : tj()));
      null !== b2.updateQueue && (b2.flags |= 4);
      S$c(b2);
      return null;
    case 4:
      return zh(), Aj(a9, b2), null === a9 && sf(b2.stateNode.containerInfo), S$c(b2), null;
    case 10:
      return ah(b2.type._context), S$c(b2), null;
    case 17:
      return Zf(b2.type) && $f(), S$c(b2), null;
    case 19:
      E$d(L$d);
      f4 = b2.memoizedState;
      if (null === f4)
        return S$c(b2), null;
      d8 = 0 !== (b2.flags & 128);
      g6 = f4.rendering;
      if (null === g6)
        if (d8)
          Dj(f4, false);
        else {
          if (0 !== T$a || null !== a9 && 0 !== (a9.flags & 128))
            for (a9 = b2.child; null !== a9; ) {
              g6 = Ch(a9);
              if (null !== g6) {
                b2.flags |= 128;
                Dj(f4, false);
                d8 = g6.updateQueue;
                null !== d8 && (b2.updateQueue = d8, b2.flags |= 4);
                b2.subtreeFlags = 0;
                d8 = c6;
                for (c6 = b2.child; null !== c6; )
                  f4 = c6, a9 = d8, f4.flags &= 14680066, g6 = f4.alternate, null === g6 ? (f4.childLanes = 0, f4.lanes = a9, f4.child = null, f4.subtreeFlags = 0, f4.memoizedProps = null, f4.memoizedState = null, f4.updateQueue = null, f4.dependencies = null, f4.stateNode = null) : (f4.childLanes = g6.childLanes, f4.lanes = g6.lanes, f4.child = g6.child, f4.subtreeFlags = 0, f4.deletions = null, f4.memoizedProps = g6.memoizedProps, f4.memoizedState = g6.memoizedState, f4.updateQueue = g6.updateQueue, f4.type = g6.type, a9 = g6.dependencies, f4.dependencies = null === a9 ? null : { lanes: a9.lanes, firstContext: a9.firstContext }), c6 = c6.sibling;
                G$a(L$d, L$d.current & 1 | 2);
                return b2.child;
              }
              a9 = a9.sibling;
            }
          null !== f4.tail && B$8() > Gj && (b2.flags |= 128, d8 = true, Dj(f4, false), b2.lanes = 4194304);
        }
      else {
        if (!d8)
          if (a9 = Ch(g6), null !== a9) {
            if (b2.flags |= 128, d8 = true, c6 = a9.updateQueue, null !== c6 && (b2.updateQueue = c6, b2.flags |= 4), Dj(f4, true), null === f4.tail && "hidden" === f4.tailMode && !g6.alternate && !I$e)
              return S$c(b2), null;
          } else
            2 * B$8() - f4.renderingStartTime > Gj && 1073741824 !== c6 && (b2.flags |= 128, d8 = true, Dj(f4, false), b2.lanes = 4194304);
        f4.isBackwards ? (g6.sibling = b2.child, b2.child = g6) : (c6 = f4.last, null !== c6 ? c6.sibling = g6 : b2.child = g6, f4.last = g6);
      }
      if (null !== f4.tail)
        return b2 = f4.tail, f4.rendering = b2, f4.tail = b2.sibling, f4.renderingStartTime = B$8(), b2.sibling = null, c6 = L$d.current, G$a(L$d, d8 ? c6 & 1 | 2 : c6 & 1), b2;
      S$c(b2);
      return null;
    case 22:
    case 23:
      return Hj(), d8 = null !== b2.memoizedState, null !== a9 && null !== a9.memoizedState !== d8 && (b2.flags |= 8192), d8 && 0 !== (b2.mode & 1) ? 0 !== (fj & 1073741824) && (S$c(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S$c(b2), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p$A(156, b2.tag));
}
function Ij(a9, b2) {
  wg(b2);
  switch (b2.tag) {
    case 1:
      return Zf(b2.type) && $f(), a9 = b2.flags, a9 & 65536 ? (b2.flags = a9 & -65537 | 128, b2) : null;
    case 3:
      return zh(), E$d(Wf), E$d(H$5), Eh(), a9 = b2.flags, 0 !== (a9 & 65536) && 0 === (a9 & 128) ? (b2.flags = a9 & -65537 | 128, b2) : null;
    case 5:
      return Bh(b2), null;
    case 13:
      E$d(L$d);
      a9 = b2.memoizedState;
      if (null !== a9 && null !== a9.dehydrated) {
        if (null === b2.alternate)
          throw Error(p$A(340));
        Ig();
      }
      a9 = b2.flags;
      return a9 & 65536 ? (b2.flags = a9 & -65537 | 128, b2) : null;
    case 19:
      return E$d(L$d), null;
    case 4:
      return zh(), null;
    case 10:
      return ah(b2.type._context), null;
    case 22:
    case 23:
      return Hj(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Jj = false, U$6 = false, Kj = "function" === typeof WeakSet ? WeakSet : Set, V$8 = null;
function Lj(a9, b2) {
  var c6 = a9.ref;
  if (null !== c6)
    if ("function" === typeof c6)
      try {
        c6(null);
      } catch (d8) {
        W$5(a9, b2, d8);
      }
    else
      c6.current = null;
}
function Mj(a9, b2, c6) {
  try {
    c6();
  } catch (d8) {
    W$5(a9, b2, d8);
  }
}
var Nj = false;
function Oj(a9, b2) {
  Cf = dd;
  a9 = Me$1();
  if (Ne$1(a9)) {
    if ("selectionStart" in a9)
      var c6 = { start: a9.selectionStart, end: a9.selectionEnd };
    else
      a: {
        c6 = (c6 = a9.ownerDocument) && c6.defaultView || window;
        var d8 = c6.getSelection && c6.getSelection();
        if (d8 && 0 !== d8.rangeCount) {
          c6 = d8.anchorNode;
          var e3 = d8.anchorOffset, f4 = d8.focusNode;
          d8 = d8.focusOffset;
          try {
            c6.nodeType, f4.nodeType;
          } catch (F2) {
            c6 = null;
            break a;
          }
          var g6 = 0, h3 = -1, k3 = -1, l7 = 0, m3 = 0, q2 = a9, r12 = null;
          b:
            for (; ; ) {
              for (var y4; ; ) {
                q2 !== c6 || 0 !== e3 && 3 !== q2.nodeType || (h3 = g6 + e3);
                q2 !== f4 || 0 !== d8 && 3 !== q2.nodeType || (k3 = g6 + d8);
                3 === q2.nodeType && (g6 += q2.nodeValue.length);
                if (null === (y4 = q2.firstChild))
                  break;
                r12 = q2;
                q2 = y4;
              }
              for (; ; ) {
                if (q2 === a9)
                  break b;
                r12 === c6 && ++l7 === e3 && (h3 = g6);
                r12 === f4 && ++m3 === d8 && (k3 = g6);
                if (null !== (y4 = q2.nextSibling))
                  break;
                q2 = r12;
                r12 = q2.parentNode;
              }
              q2 = y4;
            }
          c6 = -1 === h3 || -1 === k3 ? null : { start: h3, end: k3 };
        } else
          c6 = null;
      }
    c6 = c6 || { start: 0, end: 0 };
  } else
    c6 = null;
  Df = { focusedElem: a9, selectionRange: c6 };
  dd = false;
  for (V$8 = b2; null !== V$8; )
    if (b2 = V$8, a9 = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a9)
      a9.return = b2, V$8 = a9;
    else
      for (; null !== V$8; ) {
        b2 = V$8;
        try {
          var n10 = b2.alternate;
          if (0 !== (b2.flags & 1024))
            switch (b2.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (null !== n10) {
                  var t6 = n10.memoizedProps, J2 = n10.memoizedState, x3 = b2.stateNode, w3 = x3.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t6 : Ci(b2.type, t6), J2);
                  x3.__reactInternalSnapshotBeforeUpdate = w3;
                }
                break;
              case 3:
                var u5 = b2.stateNode.containerInfo;
                1 === u5.nodeType ? u5.textContent = "" : 9 === u5.nodeType && u5.documentElement && u5.removeChild(u5.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(p$A(163));
            }
        } catch (F2) {
          W$5(b2, b2.return, F2);
        }
        a9 = b2.sibling;
        if (null !== a9) {
          a9.return = b2.return;
          V$8 = a9;
          break;
        }
        V$8 = b2.return;
      }
  n10 = Nj;
  Nj = false;
  return n10;
}
function Pj(a9, b2, c6) {
  var d8 = b2.updateQueue;
  d8 = null !== d8 ? d8.lastEffect : null;
  if (null !== d8) {
    var e3 = d8 = d8.next;
    do {
      if ((e3.tag & a9) === a9) {
        var f4 = e3.destroy;
        e3.destroy = void 0;
        void 0 !== f4 && Mj(b2, c6, f4);
      }
      e3 = e3.next;
    } while (e3 !== d8);
  }
}
function Qj(a9, b2) {
  b2 = b2.updateQueue;
  b2 = null !== b2 ? b2.lastEffect : null;
  if (null !== b2) {
    var c6 = b2 = b2.next;
    do {
      if ((c6.tag & a9) === a9) {
        var d8 = c6.create;
        c6.destroy = d8();
      }
      c6 = c6.next;
    } while (c6 !== b2);
  }
}
function Rj(a9) {
  var b2 = a9.ref;
  if (null !== b2) {
    var c6 = a9.stateNode;
    switch (a9.tag) {
      case 5:
        a9 = c6;
        break;
      default:
        a9 = c6;
    }
    "function" === typeof b2 ? b2(a9) : b2.current = a9;
  }
}
function Sj(a9) {
  var b2 = a9.alternate;
  null !== b2 && (a9.alternate = null, Sj(b2));
  a9.child = null;
  a9.deletions = null;
  a9.sibling = null;
  5 === a9.tag && (b2 = a9.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf]));
  a9.stateNode = null;
  a9.return = null;
  a9.dependencies = null;
  a9.memoizedProps = null;
  a9.memoizedState = null;
  a9.pendingProps = null;
  a9.stateNode = null;
  a9.updateQueue = null;
}
function Tj(a9) {
  return 5 === a9.tag || 3 === a9.tag || 4 === a9.tag;
}
function Uj(a9) {
  a:
    for (; ; ) {
      for (; null === a9.sibling; ) {
        if (null === a9.return || Tj(a9.return))
          return null;
        a9 = a9.return;
      }
      a9.sibling.return = a9.return;
      for (a9 = a9.sibling; 5 !== a9.tag && 6 !== a9.tag && 18 !== a9.tag; ) {
        if (a9.flags & 2)
          continue a;
        if (null === a9.child || 4 === a9.tag)
          continue a;
        else
          a9.child.return = a9, a9 = a9.child;
      }
      if (!(a9.flags & 2))
        return a9.stateNode;
    }
}
function Vj(a9, b2, c6) {
  var d8 = a9.tag;
  if (5 === d8 || 6 === d8)
    a9 = a9.stateNode, b2 ? 8 === c6.nodeType ? c6.parentNode.insertBefore(a9, b2) : c6.insertBefore(a9, b2) : (8 === c6.nodeType ? (b2 = c6.parentNode, b2.insertBefore(a9, c6)) : (b2 = c6, b2.appendChild(a9)), c6 = c6._reactRootContainer, null !== c6 && void 0 !== c6 || null !== b2.onclick || (b2.onclick = Bf));
  else if (4 !== d8 && (a9 = a9.child, null !== a9))
    for (Vj(a9, b2, c6), a9 = a9.sibling; null !== a9; )
      Vj(a9, b2, c6), a9 = a9.sibling;
}
function Wj(a9, b2, c6) {
  var d8 = a9.tag;
  if (5 === d8 || 6 === d8)
    a9 = a9.stateNode, b2 ? c6.insertBefore(a9, b2) : c6.appendChild(a9);
  else if (4 !== d8 && (a9 = a9.child, null !== a9))
    for (Wj(a9, b2, c6), a9 = a9.sibling; null !== a9; )
      Wj(a9, b2, c6), a9 = a9.sibling;
}
var X$5 = null, Xj = false;
function Yj(a9, b2, c6) {
  for (c6 = c6.child; null !== c6; )
    Zj(a9, b2, c6), c6 = c6.sibling;
}
function Zj(a9, b2, c6) {
  if (lc && "function" === typeof lc.onCommitFiberUnmount)
    try {
      lc.onCommitFiberUnmount(kc, c6);
    } catch (h3) {
    }
  switch (c6.tag) {
    case 5:
      U$6 || Lj(c6, b2);
    case 6:
      var d8 = X$5, e3 = Xj;
      X$5 = null;
      Yj(a9, b2, c6);
      X$5 = d8;
      Xj = e3;
      null !== X$5 && (Xj ? (a9 = X$5, c6 = c6.stateNode, 8 === a9.nodeType ? a9.parentNode.removeChild(c6) : a9.removeChild(c6)) : X$5.removeChild(c6.stateNode));
      break;
    case 18:
      null !== X$5 && (Xj ? (a9 = X$5, c6 = c6.stateNode, 8 === a9.nodeType ? Kf(a9.parentNode, c6) : 1 === a9.nodeType && Kf(a9, c6), bd(a9)) : Kf(X$5, c6.stateNode));
      break;
    case 4:
      d8 = X$5;
      e3 = Xj;
      X$5 = c6.stateNode.containerInfo;
      Xj = true;
      Yj(a9, b2, c6);
      X$5 = d8;
      Xj = e3;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U$6 && (d8 = c6.updateQueue, null !== d8 && (d8 = d8.lastEffect, null !== d8))) {
        e3 = d8 = d8.next;
        do {
          var f4 = e3, g6 = f4.destroy;
          f4 = f4.tag;
          void 0 !== g6 && (0 !== (f4 & 2) ? Mj(c6, b2, g6) : 0 !== (f4 & 4) && Mj(c6, b2, g6));
          e3 = e3.next;
        } while (e3 !== d8);
      }
      Yj(a9, b2, c6);
      break;
    case 1:
      if (!U$6 && (Lj(c6, b2), d8 = c6.stateNode, "function" === typeof d8.componentWillUnmount))
        try {
          d8.props = c6.memoizedProps, d8.state = c6.memoizedState, d8.componentWillUnmount();
        } catch (h3) {
          W$5(c6, b2, h3);
        }
      Yj(a9, b2, c6);
      break;
    case 21:
      Yj(a9, b2, c6);
      break;
    case 22:
      c6.mode & 1 ? (U$6 = (d8 = U$6) || null !== c6.memoizedState, Yj(a9, b2, c6), U$6 = d8) : Yj(a9, b2, c6);
      break;
    default:
      Yj(a9, b2, c6);
  }
}
function ak(a9) {
  var b2 = a9.updateQueue;
  if (null !== b2) {
    a9.updateQueue = null;
    var c6 = a9.stateNode;
    null === c6 && (c6 = a9.stateNode = new Kj());
    b2.forEach(function(b3) {
      var d8 = bk.bind(null, a9, b3);
      c6.has(b3) || (c6.add(b3), b3.then(d8, d8));
    });
  }
}
function ck(a9, b2) {
  var c6 = b2.deletions;
  if (null !== c6)
    for (var d8 = 0; d8 < c6.length; d8++) {
      var e3 = c6[d8];
      try {
        var f4 = a9, g6 = b2, h3 = g6;
        a:
          for (; null !== h3; ) {
            switch (h3.tag) {
              case 5:
                X$5 = h3.stateNode;
                Xj = false;
                break a;
              case 3:
                X$5 = h3.stateNode.containerInfo;
                Xj = true;
                break a;
              case 4:
                X$5 = h3.stateNode.containerInfo;
                Xj = true;
                break a;
            }
            h3 = h3.return;
          }
        if (null === X$5)
          throw Error(p$A(160));
        Zj(f4, g6, e3);
        X$5 = null;
        Xj = false;
        var k3 = e3.alternate;
        null !== k3 && (k3.return = null);
        e3.return = null;
      } catch (l7) {
        W$5(e3, b2, l7);
      }
    }
  if (b2.subtreeFlags & 12854)
    for (b2 = b2.child; null !== b2; )
      dk(b2, a9), b2 = b2.sibling;
}
function dk(a9, b2) {
  var c6 = a9.alternate, d8 = a9.flags;
  switch (a9.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      ck(b2, a9);
      ek(a9);
      if (d8 & 4) {
        try {
          Pj(3, a9, a9.return), Qj(3, a9);
        } catch (t6) {
          W$5(a9, a9.return, t6);
        }
        try {
          Pj(5, a9, a9.return);
        } catch (t6) {
          W$5(a9, a9.return, t6);
        }
      }
      break;
    case 1:
      ck(b2, a9);
      ek(a9);
      d8 & 512 && null !== c6 && Lj(c6, c6.return);
      break;
    case 5:
      ck(b2, a9);
      ek(a9);
      d8 & 512 && null !== c6 && Lj(c6, c6.return);
      if (a9.flags & 32) {
        var e3 = a9.stateNode;
        try {
          ob(e3, "");
        } catch (t6) {
          W$5(a9, a9.return, t6);
        }
      }
      if (d8 & 4 && (e3 = a9.stateNode, null != e3)) {
        var f4 = a9.memoizedProps, g6 = null !== c6 ? c6.memoizedProps : f4, h3 = a9.type, k3 = a9.updateQueue;
        a9.updateQueue = null;
        if (null !== k3)
          try {
            "input" === h3 && "radio" === f4.type && null != f4.name && ab(e3, f4);
            vb(h3, g6);
            var l7 = vb(h3, f4);
            for (g6 = 0; g6 < k3.length; g6 += 2) {
              var m3 = k3[g6], q2 = k3[g6 + 1];
              "style" === m3 ? sb(e3, q2) : "dangerouslySetInnerHTML" === m3 ? nb(e3, q2) : "children" === m3 ? ob(e3, q2) : ta(e3, m3, q2, l7);
            }
            switch (h3) {
              case "input":
                bb(e3, f4);
                break;
              case "textarea":
                ib(e3, f4);
                break;
              case "select":
                var r12 = e3._wrapperState.wasMultiple;
                e3._wrapperState.wasMultiple = !!f4.multiple;
                var y4 = f4.value;
                null != y4 ? fb(e3, !!f4.multiple, y4, false) : r12 !== !!f4.multiple && (null != f4.defaultValue ? fb(
                  e3,
                  !!f4.multiple,
                  f4.defaultValue,
                  true
                ) : fb(e3, !!f4.multiple, f4.multiple ? [] : "", false));
            }
            e3[Pf] = f4;
          } catch (t6) {
            W$5(a9, a9.return, t6);
          }
      }
      break;
    case 6:
      ck(b2, a9);
      ek(a9);
      if (d8 & 4) {
        if (null === a9.stateNode)
          throw Error(p$A(162));
        e3 = a9.stateNode;
        f4 = a9.memoizedProps;
        try {
          e3.nodeValue = f4;
        } catch (t6) {
          W$5(a9, a9.return, t6);
        }
      }
      break;
    case 3:
      ck(b2, a9);
      ek(a9);
      if (d8 & 4 && null !== c6 && c6.memoizedState.isDehydrated)
        try {
          bd(b2.containerInfo);
        } catch (t6) {
          W$5(a9, a9.return, t6);
        }
      break;
    case 4:
      ck(b2, a9);
      ek(a9);
      break;
    case 13:
      ck(b2, a9);
      ek(a9);
      e3 = a9.child;
      e3.flags & 8192 && (f4 = null !== e3.memoizedState, e3.stateNode.isHidden = f4, !f4 || null !== e3.alternate && null !== e3.alternate.memoizedState || (fk = B$8()));
      d8 & 4 && ak(a9);
      break;
    case 22:
      m3 = null !== c6 && null !== c6.memoizedState;
      a9.mode & 1 ? (U$6 = (l7 = U$6) || m3, ck(b2, a9), U$6 = l7) : ck(b2, a9);
      ek(a9);
      if (d8 & 8192) {
        l7 = null !== a9.memoizedState;
        if ((a9.stateNode.isHidden = l7) && !m3 && 0 !== (a9.mode & 1))
          for (V$8 = a9, m3 = a9.child; null !== m3; ) {
            for (q2 = V$8 = m3; null !== V$8; ) {
              r12 = V$8;
              y4 = r12.child;
              switch (r12.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Pj(4, r12, r12.return);
                  break;
                case 1:
                  Lj(r12, r12.return);
                  var n10 = r12.stateNode;
                  if ("function" === typeof n10.componentWillUnmount) {
                    d8 = r12;
                    c6 = r12.return;
                    try {
                      b2 = d8, n10.props = b2.memoizedProps, n10.state = b2.memoizedState, n10.componentWillUnmount();
                    } catch (t6) {
                      W$5(d8, c6, t6);
                    }
                  }
                  break;
                case 5:
                  Lj(r12, r12.return);
                  break;
                case 22:
                  if (null !== r12.memoizedState) {
                    gk(q2);
                    continue;
                  }
              }
              null !== y4 ? (y4.return = r12, V$8 = y4) : gk(q2);
            }
            m3 = m3.sibling;
          }
        a:
          for (m3 = null, q2 = a9; ; ) {
            if (5 === q2.tag) {
              if (null === m3) {
                m3 = q2;
                try {
                  e3 = q2.stateNode, l7 ? (f4 = e3.style, "function" === typeof f4.setProperty ? f4.setProperty("display", "none", "important") : f4.display = "none") : (h3 = q2.stateNode, k3 = q2.memoizedProps.style, g6 = void 0 !== k3 && null !== k3 && k3.hasOwnProperty("display") ? k3.display : null, h3.style.display = rb("display", g6));
                } catch (t6) {
                  W$5(a9, a9.return, t6);
                }
              }
            } else if (6 === q2.tag) {
              if (null === m3)
                try {
                  q2.stateNode.nodeValue = l7 ? "" : q2.memoizedProps;
                } catch (t6) {
                  W$5(a9, a9.return, t6);
                }
            } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a9) && null !== q2.child) {
              q2.child.return = q2;
              q2 = q2.child;
              continue;
            }
            if (q2 === a9)
              break a;
            for (; null === q2.sibling; ) {
              if (null === q2.return || q2.return === a9)
                break a;
              m3 === q2 && (m3 = null);
              q2 = q2.return;
            }
            m3 === q2 && (m3 = null);
            q2.sibling.return = q2.return;
            q2 = q2.sibling;
          }
      }
      break;
    case 19:
      ck(b2, a9);
      ek(a9);
      d8 & 4 && ak(a9);
      break;
    case 21:
      break;
    default:
      ck(
        b2,
        a9
      ), ek(a9);
  }
}
function ek(a9) {
  var b2 = a9.flags;
  if (b2 & 2) {
    try {
      a: {
        for (var c6 = a9.return; null !== c6; ) {
          if (Tj(c6)) {
            var d8 = c6;
            break a;
          }
          c6 = c6.return;
        }
        throw Error(p$A(160));
      }
      switch (d8.tag) {
        case 5:
          var e3 = d8.stateNode;
          d8.flags & 32 && (ob(e3, ""), d8.flags &= -33);
          var f4 = Uj(a9);
          Wj(a9, f4, e3);
          break;
        case 3:
        case 4:
          var g6 = d8.stateNode.containerInfo, h3 = Uj(a9);
          Vj(a9, h3, g6);
          break;
        default:
          throw Error(p$A(161));
      }
    } catch (k3) {
      W$5(a9, a9.return, k3);
    }
    a9.flags &= -3;
  }
  b2 & 4096 && (a9.flags &= -4097);
}
function hk(a9, b2, c6) {
  V$8 = a9;
  ik(a9);
}
function ik(a9, b2, c6) {
  for (var d8 = 0 !== (a9.mode & 1); null !== V$8; ) {
    var e3 = V$8, f4 = e3.child;
    if (22 === e3.tag && d8) {
      var g6 = null !== e3.memoizedState || Jj;
      if (!g6) {
        var h3 = e3.alternate, k3 = null !== h3 && null !== h3.memoizedState || U$6;
        h3 = Jj;
        var l7 = U$6;
        Jj = g6;
        if ((U$6 = k3) && !l7)
          for (V$8 = e3; null !== V$8; )
            g6 = V$8, k3 = g6.child, 22 === g6.tag && null !== g6.memoizedState ? jk(e3) : null !== k3 ? (k3.return = g6, V$8 = k3) : jk(e3);
        for (; null !== f4; )
          V$8 = f4, ik(f4), f4 = f4.sibling;
        V$8 = e3;
        Jj = h3;
        U$6 = l7;
      }
      kk(a9);
    } else
      0 !== (e3.subtreeFlags & 8772) && null !== f4 ? (f4.return = e3, V$8 = f4) : kk(a9);
  }
}
function kk(a9) {
  for (; null !== V$8; ) {
    var b2 = V$8;
    if (0 !== (b2.flags & 8772)) {
      var c6 = b2.alternate;
      try {
        if (0 !== (b2.flags & 8772))
          switch (b2.tag) {
            case 0:
            case 11:
            case 15:
              U$6 || Qj(5, b2);
              break;
            case 1:
              var d8 = b2.stateNode;
              if (b2.flags & 4 && !U$6)
                if (null === c6)
                  d8.componentDidMount();
                else {
                  var e3 = b2.elementType === b2.type ? c6.memoizedProps : Ci(b2.type, c6.memoizedProps);
                  d8.componentDidUpdate(e3, c6.memoizedState, d8.__reactInternalSnapshotBeforeUpdate);
                }
              var f4 = b2.updateQueue;
              null !== f4 && sh(b2, f4, d8);
              break;
            case 3:
              var g6 = b2.updateQueue;
              if (null !== g6) {
                c6 = null;
                if (null !== b2.child)
                  switch (b2.child.tag) {
                    case 5:
                      c6 = b2.child.stateNode;
                      break;
                    case 1:
                      c6 = b2.child.stateNode;
                  }
                sh(b2, g6, c6);
              }
              break;
            case 5:
              var h3 = b2.stateNode;
              if (null === c6 && b2.flags & 4) {
                c6 = h3;
                var k3 = b2.memoizedProps;
                switch (b2.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k3.autoFocus && c6.focus();
                    break;
                  case "img":
                    k3.src && (c6.src = k3.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b2.memoizedState) {
                var l7 = b2.alternate;
                if (null !== l7) {
                  var m3 = l7.memoizedState;
                  if (null !== m3) {
                    var q2 = m3.dehydrated;
                    null !== q2 && bd(q2);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p$A(163));
          }
        U$6 || b2.flags & 512 && Rj(b2);
      } catch (r12) {
        W$5(b2, b2.return, r12);
      }
    }
    if (b2 === a9) {
      V$8 = null;
      break;
    }
    c6 = b2.sibling;
    if (null !== c6) {
      c6.return = b2.return;
      V$8 = c6;
      break;
    }
    V$8 = b2.return;
  }
}
function gk(a9) {
  for (; null !== V$8; ) {
    var b2 = V$8;
    if (b2 === a9) {
      V$8 = null;
      break;
    }
    var c6 = b2.sibling;
    if (null !== c6) {
      c6.return = b2.return;
      V$8 = c6;
      break;
    }
    V$8 = b2.return;
  }
}
function jk(a9) {
  for (; null !== V$8; ) {
    var b2 = V$8;
    try {
      switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          var c6 = b2.return;
          try {
            Qj(4, b2);
          } catch (k3) {
            W$5(b2, c6, k3);
          }
          break;
        case 1:
          var d8 = b2.stateNode;
          if ("function" === typeof d8.componentDidMount) {
            var e3 = b2.return;
            try {
              d8.componentDidMount();
            } catch (k3) {
              W$5(b2, e3, k3);
            }
          }
          var f4 = b2.return;
          try {
            Rj(b2);
          } catch (k3) {
            W$5(b2, f4, k3);
          }
          break;
        case 5:
          var g6 = b2.return;
          try {
            Rj(b2);
          } catch (k3) {
            W$5(b2, g6, k3);
          }
      }
    } catch (k3) {
      W$5(b2, b2.return, k3);
    }
    if (b2 === a9) {
      V$8 = null;
      break;
    }
    var h3 = b2.sibling;
    if (null !== h3) {
      h3.return = b2.return;
      V$8 = h3;
      break;
    }
    V$8 = b2.return;
  }
}
var lk = Math.ceil, mk = ua.ReactCurrentDispatcher, nk = ua.ReactCurrentOwner, ok = ua.ReactCurrentBatchConfig, K$7 = 0, Q$7 = null, Y$8 = null, Z$5 = 0, fj = 0, ej = Uf(0), T$a = 0, pk = null, rh = 0, qk = 0, rk = 0, sk = null, tk = null, fk = 0, Gj = Infinity, uk = null, Oi = false, Pi = null, Ri = null, vk = false, wk = null, xk = 0, yk = 0, zk = null, Ak = -1, Bk = 0;
function R$8() {
  return 0 !== (K$7 & 6) ? B$8() : -1 !== Ak ? Ak : Ak = B$8();
}
function yi(a9) {
  if (0 === (a9.mode & 1))
    return 1;
  if (0 !== (K$7 & 2) && 0 !== Z$5)
    return Z$5 & -Z$5;
  if (null !== Kg.transition)
    return 0 === Bk && (Bk = yc()), Bk;
  a9 = C$g;
  if (0 !== a9)
    return a9;
  a9 = window.event;
  a9 = void 0 === a9 ? 16 : jd(a9.type);
  return a9;
}
function gi(a9, b2, c6, d8) {
  if (50 < yk)
    throw yk = 0, zk = null, Error(p$A(185));
  Ac(a9, c6, d8);
  if (0 === (K$7 & 2) || a9 !== Q$7)
    a9 === Q$7 && (0 === (K$7 & 2) && (qk |= c6), 4 === T$a && Ck(a9, Z$5)), Dk(a9, d8), 1 === c6 && 0 === K$7 && 0 === (b2.mode & 1) && (Gj = B$8() + 500, fg && jg());
}
function Dk(a9, b2) {
  var c6 = a9.callbackNode;
  wc(a9, b2);
  var d8 = uc(a9, a9 === Q$7 ? Z$5 : 0);
  if (0 === d8)
    null !== c6 && bc(c6), a9.callbackNode = null, a9.callbackPriority = 0;
  else if (b2 = d8 & -d8, a9.callbackPriority !== b2) {
    null != c6 && bc(c6);
    if (1 === b2)
      0 === a9.tag ? ig(Ek.bind(null, a9)) : hg(Ek.bind(null, a9)), Jf(function() {
        0 === (K$7 & 6) && jg();
      }), c6 = null;
    else {
      switch (Dc(d8)) {
        case 1:
          c6 = fc;
          break;
        case 4:
          c6 = gc;
          break;
        case 16:
          c6 = hc;
          break;
        case 536870912:
          c6 = jc;
          break;
        default:
          c6 = hc;
      }
      c6 = Fk(c6, Gk.bind(null, a9));
    }
    a9.callbackPriority = b2;
    a9.callbackNode = c6;
  }
}
function Gk(a9, b2) {
  Ak = -1;
  Bk = 0;
  if (0 !== (K$7 & 6))
    throw Error(p$A(327));
  var c6 = a9.callbackNode;
  if (Hk() && a9.callbackNode !== c6)
    return null;
  var d8 = uc(a9, a9 === Q$7 ? Z$5 : 0);
  if (0 === d8)
    return null;
  if (0 !== (d8 & 30) || 0 !== (d8 & a9.expiredLanes) || b2)
    b2 = Ik(a9, d8);
  else {
    b2 = d8;
    var e3 = K$7;
    K$7 |= 2;
    var f4 = Jk();
    if (Q$7 !== a9 || Z$5 !== b2)
      uk = null, Gj = B$8() + 500, Kk(a9, b2);
    do
      try {
        Lk();
        break;
      } catch (h3) {
        Mk(a9, h3);
      }
    while (1);
    $g();
    mk.current = f4;
    K$7 = e3;
    null !== Y$8 ? b2 = 0 : (Q$7 = null, Z$5 = 0, b2 = T$a);
  }
  if (0 !== b2) {
    2 === b2 && (e3 = xc(a9), 0 !== e3 && (d8 = e3, b2 = Nk(a9, e3)));
    if (1 === b2)
      throw c6 = pk, Kk(a9, 0), Ck(a9, d8), Dk(a9, B$8()), c6;
    if (6 === b2)
      Ck(a9, d8);
    else {
      e3 = a9.current.alternate;
      if (0 === (d8 & 30) && !Ok(e3) && (b2 = Ik(a9, d8), 2 === b2 && (f4 = xc(a9), 0 !== f4 && (d8 = f4, b2 = Nk(a9, f4))), 1 === b2))
        throw c6 = pk, Kk(a9, 0), Ck(a9, d8), Dk(a9, B$8()), c6;
      a9.finishedWork = e3;
      a9.finishedLanes = d8;
      switch (b2) {
        case 0:
        case 1:
          throw Error(p$A(345));
        case 2:
          Pk(a9, tk, uk);
          break;
        case 3:
          Ck(a9, d8);
          if ((d8 & 130023424) === d8 && (b2 = fk + 500 - B$8(), 10 < b2)) {
            if (0 !== uc(a9, 0))
              break;
            e3 = a9.suspendedLanes;
            if ((e3 & d8) !== d8) {
              R$8();
              a9.pingedLanes |= a9.suspendedLanes & e3;
              break;
            }
            a9.timeoutHandle = Ff(Pk.bind(null, a9, tk, uk), b2);
            break;
          }
          Pk(a9, tk, uk);
          break;
        case 4:
          Ck(a9, d8);
          if ((d8 & 4194240) === d8)
            break;
          b2 = a9.eventTimes;
          for (e3 = -1; 0 < d8; ) {
            var g6 = 31 - oc(d8);
            f4 = 1 << g6;
            g6 = b2[g6];
            g6 > e3 && (e3 = g6);
            d8 &= ~f4;
          }
          d8 = e3;
          d8 = B$8() - d8;
          d8 = (120 > d8 ? 120 : 480 > d8 ? 480 : 1080 > d8 ? 1080 : 1920 > d8 ? 1920 : 3e3 > d8 ? 3e3 : 4320 > d8 ? 4320 : 1960 * lk(d8 / 1960)) - d8;
          if (10 < d8) {
            a9.timeoutHandle = Ff(Pk.bind(null, a9, tk, uk), d8);
            break;
          }
          Pk(a9, tk, uk);
          break;
        case 5:
          Pk(a9, tk, uk);
          break;
        default:
          throw Error(p$A(329));
      }
    }
  }
  Dk(a9, B$8());
  return a9.callbackNode === c6 ? Gk.bind(null, a9) : null;
}
function Nk(a9, b2) {
  var c6 = sk;
  a9.current.memoizedState.isDehydrated && (Kk(a9, b2).flags |= 256);
  a9 = Ik(a9, b2);
  2 !== a9 && (b2 = tk, tk = c6, null !== b2 && Fj(b2));
  return a9;
}
function Fj(a9) {
  null === tk ? tk = a9 : tk.push.apply(tk, a9);
}
function Ok(a9) {
  for (var b2 = a9; ; ) {
    if (b2.flags & 16384) {
      var c6 = b2.updateQueue;
      if (null !== c6 && (c6 = c6.stores, null !== c6))
        for (var d8 = 0; d8 < c6.length; d8++) {
          var e3 = c6[d8], f4 = e3.getSnapshot;
          e3 = e3.value;
          try {
            if (!He(f4(), e3))
              return false;
          } catch (g6) {
            return false;
          }
        }
    }
    c6 = b2.child;
    if (b2.subtreeFlags & 16384 && null !== c6)
      c6.return = b2, b2 = c6;
    else {
      if (b2 === a9)
        break;
      for (; null === b2.sibling; ) {
        if (null === b2.return || b2.return === a9)
          return true;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
  }
  return true;
}
function Ck(a9, b2) {
  b2 &= ~rk;
  b2 &= ~qk;
  a9.suspendedLanes |= b2;
  a9.pingedLanes &= ~b2;
  for (a9 = a9.expirationTimes; 0 < b2; ) {
    var c6 = 31 - oc(b2), d8 = 1 << c6;
    a9[c6] = -1;
    b2 &= ~d8;
  }
}
function Ek(a9) {
  if (0 !== (K$7 & 6))
    throw Error(p$A(327));
  Hk();
  var b2 = uc(a9, 0);
  if (0 === (b2 & 1))
    return Dk(a9, B$8()), null;
  var c6 = Ik(a9, b2);
  if (0 !== a9.tag && 2 === c6) {
    var d8 = xc(a9);
    0 !== d8 && (b2 = d8, c6 = Nk(a9, d8));
  }
  if (1 === c6)
    throw c6 = pk, Kk(a9, 0), Ck(a9, b2), Dk(a9, B$8()), c6;
  if (6 === c6)
    throw Error(p$A(345));
  a9.finishedWork = a9.current.alternate;
  a9.finishedLanes = b2;
  Pk(a9, tk, uk);
  Dk(a9, B$8());
  return null;
}
function Qk(a9, b2) {
  var c6 = K$7;
  K$7 |= 1;
  try {
    return a9(b2);
  } finally {
    K$7 = c6, 0 === K$7 && (Gj = B$8() + 500, fg && jg());
  }
}
function Rk(a9) {
  null !== wk && 0 === wk.tag && 0 === (K$7 & 6) && Hk();
  var b2 = K$7;
  K$7 |= 1;
  var c6 = ok.transition, d8 = C$g;
  try {
    if (ok.transition = null, C$g = 1, a9)
      return a9();
  } finally {
    C$g = d8, ok.transition = c6, K$7 = b2, 0 === (K$7 & 6) && jg();
  }
}
function Hj() {
  fj = ej.current;
  E$d(ej);
}
function Kk(a9, b2) {
  a9.finishedWork = null;
  a9.finishedLanes = 0;
  var c6 = a9.timeoutHandle;
  -1 !== c6 && (a9.timeoutHandle = -1, Gf(c6));
  if (null !== Y$8)
    for (c6 = Y$8.return; null !== c6; ) {
      var d8 = c6;
      wg(d8);
      switch (d8.tag) {
        case 1:
          d8 = d8.type.childContextTypes;
          null !== d8 && void 0 !== d8 && $f();
          break;
        case 3:
          zh();
          E$d(Wf);
          E$d(H$5);
          Eh();
          break;
        case 5:
          Bh(d8);
          break;
        case 4:
          zh();
          break;
        case 13:
          E$d(L$d);
          break;
        case 19:
          E$d(L$d);
          break;
        case 10:
          ah(d8.type._context);
          break;
        case 22:
        case 23:
          Hj();
      }
      c6 = c6.return;
    }
  Q$7 = a9;
  Y$8 = a9 = Pg(a9.current, null);
  Z$5 = fj = b2;
  T$a = 0;
  pk = null;
  rk = qk = rh = 0;
  tk = sk = null;
  if (null !== fh) {
    for (b2 = 0; b2 < fh.length; b2++)
      if (c6 = fh[b2], d8 = c6.interleaved, null !== d8) {
        c6.interleaved = null;
        var e3 = d8.next, f4 = c6.pending;
        if (null !== f4) {
          var g6 = f4.next;
          f4.next = e3;
          d8.next = g6;
        }
        c6.pending = d8;
      }
    fh = null;
  }
  return a9;
}
function Mk(a9, b2) {
  do {
    var c6 = Y$8;
    try {
      $g();
      Fh.current = Rh;
      if (Ih) {
        for (var d8 = M$c.memoizedState; null !== d8; ) {
          var e3 = d8.queue;
          null !== e3 && (e3.pending = null);
          d8 = d8.next;
        }
        Ih = false;
      }
      Hh = 0;
      O$a = N$a = M$c = null;
      Jh = false;
      Kh = 0;
      nk.current = null;
      if (null === c6 || null === c6.return) {
        T$a = 1;
        pk = b2;
        Y$8 = null;
        break;
      }
      a: {
        var f4 = a9, g6 = c6.return, h3 = c6, k3 = b2;
        b2 = Z$5;
        h3.flags |= 32768;
        if (null !== k3 && "object" === typeof k3 && "function" === typeof k3.then) {
          var l7 = k3, m3 = h3, q2 = m3.tag;
          if (0 === (m3.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
            var r12 = m3.alternate;
            r12 ? (m3.updateQueue = r12.updateQueue, m3.memoizedState = r12.memoizedState, m3.lanes = r12.lanes) : (m3.updateQueue = null, m3.memoizedState = null);
          }
          var y4 = Ui(g6);
          if (null !== y4) {
            y4.flags &= -257;
            Vi(y4, g6, h3, f4, b2);
            y4.mode & 1 && Si(f4, l7, b2);
            b2 = y4;
            k3 = l7;
            var n10 = b2.updateQueue;
            if (null === n10) {
              var t6 = /* @__PURE__ */ new Set();
              t6.add(k3);
              b2.updateQueue = t6;
            } else
              n10.add(k3);
            break a;
          } else {
            if (0 === (b2 & 1)) {
              Si(f4, l7, b2);
              tj();
              break a;
            }
            k3 = Error(p$A(426));
          }
        } else if (I$e && h3.mode & 1) {
          var J2 = Ui(g6);
          if (null !== J2) {
            0 === (J2.flags & 65536) && (J2.flags |= 256);
            Vi(J2, g6, h3, f4, b2);
            Jg(Ji(k3, h3));
            break a;
          }
        }
        f4 = k3 = Ji(k3, h3);
        4 !== T$a && (T$a = 2);
        null === sk ? sk = [f4] : sk.push(f4);
        f4 = g6;
        do {
          switch (f4.tag) {
            case 3:
              f4.flags |= 65536;
              b2 &= -b2;
              f4.lanes |= b2;
              var x3 = Ni(f4, k3, b2);
              ph(f4, x3);
              break a;
            case 1:
              h3 = k3;
              var w3 = f4.type, u5 = f4.stateNode;
              if (0 === (f4.flags & 128) && ("function" === typeof w3.getDerivedStateFromError || null !== u5 && "function" === typeof u5.componentDidCatch && (null === Ri || !Ri.has(u5)))) {
                f4.flags |= 65536;
                b2 &= -b2;
                f4.lanes |= b2;
                var F2 = Qi(f4, h3, b2);
                ph(f4, F2);
                break a;
              }
          }
          f4 = f4.return;
        } while (null !== f4);
      }
      Sk(c6);
    } catch (na) {
      b2 = na;
      Y$8 === c6 && null !== c6 && (Y$8 = c6 = c6.return);
      continue;
    }
    break;
  } while (1);
}
function Jk() {
  var a9 = mk.current;
  mk.current = Rh;
  return null === a9 ? Rh : a9;
}
function tj() {
  if (0 === T$a || 3 === T$a || 2 === T$a)
    T$a = 4;
  null === Q$7 || 0 === (rh & 268435455) && 0 === (qk & 268435455) || Ck(Q$7, Z$5);
}
function Ik(a9, b2) {
  var c6 = K$7;
  K$7 |= 2;
  var d8 = Jk();
  if (Q$7 !== a9 || Z$5 !== b2)
    uk = null, Kk(a9, b2);
  do
    try {
      Tk();
      break;
    } catch (e3) {
      Mk(a9, e3);
    }
  while (1);
  $g();
  K$7 = c6;
  mk.current = d8;
  if (null !== Y$8)
    throw Error(p$A(261));
  Q$7 = null;
  Z$5 = 0;
  return T$a;
}
function Tk() {
  for (; null !== Y$8; )
    Uk(Y$8);
}
function Lk() {
  for (; null !== Y$8 && !cc(); )
    Uk(Y$8);
}
function Uk(a9) {
  var b2 = Vk(a9.alternate, a9, fj);
  a9.memoizedProps = a9.pendingProps;
  null === b2 ? Sk(a9) : Y$8 = b2;
  nk.current = null;
}
function Sk(a9) {
  var b2 = a9;
  do {
    var c6 = b2.alternate;
    a9 = b2.return;
    if (0 === (b2.flags & 32768)) {
      if (c6 = Ej(c6, b2, fj), null !== c6) {
        Y$8 = c6;
        return;
      }
    } else {
      c6 = Ij(c6, b2);
      if (null !== c6) {
        c6.flags &= 32767;
        Y$8 = c6;
        return;
      }
      if (null !== a9)
        a9.flags |= 32768, a9.subtreeFlags = 0, a9.deletions = null;
      else {
        T$a = 6;
        Y$8 = null;
        return;
      }
    }
    b2 = b2.sibling;
    if (null !== b2) {
      Y$8 = b2;
      return;
    }
    Y$8 = b2 = a9;
  } while (null !== b2);
  0 === T$a && (T$a = 5);
}
function Pk(a9, b2, c6) {
  var d8 = C$g, e3 = ok.transition;
  try {
    ok.transition = null, C$g = 1, Wk(a9, b2, c6, d8);
  } finally {
    ok.transition = e3, C$g = d8;
  }
  return null;
}
function Wk(a9, b2, c6, d8) {
  do
    Hk();
  while (null !== wk);
  if (0 !== (K$7 & 6))
    throw Error(p$A(327));
  c6 = a9.finishedWork;
  var e3 = a9.finishedLanes;
  if (null === c6)
    return null;
  a9.finishedWork = null;
  a9.finishedLanes = 0;
  if (c6 === a9.current)
    throw Error(p$A(177));
  a9.callbackNode = null;
  a9.callbackPriority = 0;
  var f4 = c6.lanes | c6.childLanes;
  Bc(a9, f4);
  a9 === Q$7 && (Y$8 = Q$7 = null, Z$5 = 0);
  0 === (c6.subtreeFlags & 2064) && 0 === (c6.flags & 2064) || vk || (vk = true, Fk(hc, function() {
    Hk();
    return null;
  }));
  f4 = 0 !== (c6.flags & 15990);
  if (0 !== (c6.subtreeFlags & 15990) || f4) {
    f4 = ok.transition;
    ok.transition = null;
    var g6 = C$g;
    C$g = 1;
    var h3 = K$7;
    K$7 |= 4;
    nk.current = null;
    Oj(a9, c6);
    dk(c6, a9);
    Oe$2(Df);
    dd = !!Cf;
    Df = Cf = null;
    a9.current = c6;
    hk(c6);
    dc();
    K$7 = h3;
    C$g = g6;
    ok.transition = f4;
  } else
    a9.current = c6;
  vk && (vk = false, wk = a9, xk = e3);
  f4 = a9.pendingLanes;
  0 === f4 && (Ri = null);
  mc(c6.stateNode);
  Dk(a9, B$8());
  if (null !== b2)
    for (d8 = a9.onRecoverableError, c6 = 0; c6 < b2.length; c6++)
      e3 = b2[c6], d8(e3.value, { componentStack: e3.stack, digest: e3.digest });
  if (Oi)
    throw Oi = false, a9 = Pi, Pi = null, a9;
  0 !== (xk & 1) && 0 !== a9.tag && Hk();
  f4 = a9.pendingLanes;
  0 !== (f4 & 1) ? a9 === zk ? yk++ : (yk = 0, zk = a9) : yk = 0;
  jg();
  return null;
}
function Hk() {
  if (null !== wk) {
    var a9 = Dc(xk), b2 = ok.transition, c6 = C$g;
    try {
      ok.transition = null;
      C$g = 16 > a9 ? 16 : a9;
      if (null === wk)
        var d8 = false;
      else {
        a9 = wk;
        wk = null;
        xk = 0;
        if (0 !== (K$7 & 6))
          throw Error(p$A(331));
        var e3 = K$7;
        K$7 |= 4;
        for (V$8 = a9.current; null !== V$8; ) {
          var f4 = V$8, g6 = f4.child;
          if (0 !== (V$8.flags & 16)) {
            var h3 = f4.deletions;
            if (null !== h3) {
              for (var k3 = 0; k3 < h3.length; k3++) {
                var l7 = h3[k3];
                for (V$8 = l7; null !== V$8; ) {
                  var m3 = V$8;
                  switch (m3.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Pj(8, m3, f4);
                  }
                  var q2 = m3.child;
                  if (null !== q2)
                    q2.return = m3, V$8 = q2;
                  else
                    for (; null !== V$8; ) {
                      m3 = V$8;
                      var r12 = m3.sibling, y4 = m3.return;
                      Sj(m3);
                      if (m3 === l7) {
                        V$8 = null;
                        break;
                      }
                      if (null !== r12) {
                        r12.return = y4;
                        V$8 = r12;
                        break;
                      }
                      V$8 = y4;
                    }
                }
              }
              var n10 = f4.alternate;
              if (null !== n10) {
                var t6 = n10.child;
                if (null !== t6) {
                  n10.child = null;
                  do {
                    var J2 = t6.sibling;
                    t6.sibling = null;
                    t6 = J2;
                  } while (null !== t6);
                }
              }
              V$8 = f4;
            }
          }
          if (0 !== (f4.subtreeFlags & 2064) && null !== g6)
            g6.return = f4, V$8 = g6;
          else
            b:
              for (; null !== V$8; ) {
                f4 = V$8;
                if (0 !== (f4.flags & 2048))
                  switch (f4.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Pj(9, f4, f4.return);
                  }
                var x3 = f4.sibling;
                if (null !== x3) {
                  x3.return = f4.return;
                  V$8 = x3;
                  break b;
                }
                V$8 = f4.return;
              }
        }
        var w3 = a9.current;
        for (V$8 = w3; null !== V$8; ) {
          g6 = V$8;
          var u5 = g6.child;
          if (0 !== (g6.subtreeFlags & 2064) && null !== u5)
            u5.return = g6, V$8 = u5;
          else
            b:
              for (g6 = w3; null !== V$8; ) {
                h3 = V$8;
                if (0 !== (h3.flags & 2048))
                  try {
                    switch (h3.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Qj(9, h3);
                    }
                  } catch (na) {
                    W$5(h3, h3.return, na);
                  }
                if (h3 === g6) {
                  V$8 = null;
                  break b;
                }
                var F2 = h3.sibling;
                if (null !== F2) {
                  F2.return = h3.return;
                  V$8 = F2;
                  break b;
                }
                V$8 = h3.return;
              }
        }
        K$7 = e3;
        jg();
        if (lc && "function" === typeof lc.onPostCommitFiberRoot)
          try {
            lc.onPostCommitFiberRoot(kc, a9);
          } catch (na) {
          }
        d8 = true;
      }
      return d8;
    } finally {
      C$g = c6, ok.transition = b2;
    }
  }
  return false;
}
function Xk(a9, b2, c6) {
  b2 = Ji(c6, b2);
  b2 = Ni(a9, b2, 1);
  a9 = nh(a9, b2, 1);
  b2 = R$8();
  null !== a9 && (Ac(a9, 1, b2), Dk(a9, b2));
}
function W$5(a9, b2, c6) {
  if (3 === a9.tag)
    Xk(a9, a9, c6);
  else
    for (; null !== b2; ) {
      if (3 === b2.tag) {
        Xk(b2, a9, c6);
        break;
      } else if (1 === b2.tag) {
        var d8 = b2.stateNode;
        if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d8.componentDidCatch && (null === Ri || !Ri.has(d8))) {
          a9 = Ji(c6, a9);
          a9 = Qi(b2, a9, 1);
          b2 = nh(b2, a9, 1);
          a9 = R$8();
          null !== b2 && (Ac(b2, 1, a9), Dk(b2, a9));
          break;
        }
      }
      b2 = b2.return;
    }
}
function Ti(a9, b2, c6) {
  var d8 = a9.pingCache;
  null !== d8 && d8.delete(b2);
  b2 = R$8();
  a9.pingedLanes |= a9.suspendedLanes & c6;
  Q$7 === a9 && (Z$5 & c6) === c6 && (4 === T$a || 3 === T$a && (Z$5 & 130023424) === Z$5 && 500 > B$8() - fk ? Kk(a9, 0) : rk |= c6);
  Dk(a9, b2);
}
function Yk(a9, b2) {
  0 === b2 && (0 === (a9.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
  var c6 = R$8();
  a9 = ih(a9, b2);
  null !== a9 && (Ac(a9, b2, c6), Dk(a9, c6));
}
function uj(a9) {
  var b2 = a9.memoizedState, c6 = 0;
  null !== b2 && (c6 = b2.retryLane);
  Yk(a9, c6);
}
function bk(a9, b2) {
  var c6 = 0;
  switch (a9.tag) {
    case 13:
      var d8 = a9.stateNode;
      var e3 = a9.memoizedState;
      null !== e3 && (c6 = e3.retryLane);
      break;
    case 19:
      d8 = a9.stateNode;
      break;
    default:
      throw Error(p$A(314));
  }
  null !== d8 && d8.delete(b2);
  Yk(a9, c6);
}
var Vk;
Vk = function(a9, b2, c6) {
  if (null !== a9)
    if (a9.memoizedProps !== b2.pendingProps || Wf.current)
      dh = true;
    else {
      if (0 === (a9.lanes & c6) && 0 === (b2.flags & 128))
        return dh = false, yj(a9, b2, c6);
      dh = 0 !== (a9.flags & 131072) ? true : false;
    }
  else
    dh = false, I$e && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
  b2.lanes = 0;
  switch (b2.tag) {
    case 2:
      var d8 = b2.type;
      ij(a9, b2);
      a9 = b2.pendingProps;
      var e3 = Yf(b2, H$5.current);
      ch(b2, c6);
      e3 = Nh(null, b2, d8, a9, e3, c6);
      var f4 = Sh();
      b2.flags |= 1;
      "object" === typeof e3 && null !== e3 && "function" === typeof e3.render && void 0 === e3.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d8) ? (f4 = true, cg(b2)) : f4 = false, b2.memoizedState = null !== e3.state && void 0 !== e3.state ? e3.state : null, kh(b2), e3.updater = Ei, b2.stateNode = e3, e3._reactInternals = b2, Ii(b2, d8, a9, c6), b2 = jj(null, b2, d8, true, f4, c6)) : (b2.tag = 0, I$e && f4 && vg(b2), Xi(null, b2, e3, c6), b2 = b2.child);
      return b2;
    case 16:
      d8 = b2.elementType;
      a: {
        ij(a9, b2);
        a9 = b2.pendingProps;
        e3 = d8._init;
        d8 = e3(d8._payload);
        b2.type = d8;
        e3 = b2.tag = Zk(d8);
        a9 = Ci(d8, a9);
        switch (e3) {
          case 0:
            b2 = cj(null, b2, d8, a9, c6);
            break a;
          case 1:
            b2 = hj(null, b2, d8, a9, c6);
            break a;
          case 11:
            b2 = Yi(null, b2, d8, a9, c6);
            break a;
          case 14:
            b2 = $i(null, b2, d8, Ci(d8.type, a9), c6);
            break a;
        }
        throw Error(p$A(
          306,
          d8,
          ""
        ));
      }
      return b2;
    case 0:
      return d8 = b2.type, e3 = b2.pendingProps, e3 = b2.elementType === d8 ? e3 : Ci(d8, e3), cj(a9, b2, d8, e3, c6);
    case 1:
      return d8 = b2.type, e3 = b2.pendingProps, e3 = b2.elementType === d8 ? e3 : Ci(d8, e3), hj(a9, b2, d8, e3, c6);
    case 3:
      a: {
        kj(b2);
        if (null === a9)
          throw Error(p$A(387));
        d8 = b2.pendingProps;
        f4 = b2.memoizedState;
        e3 = f4.element;
        lh(a9, b2);
        qh(b2, d8, null, c6);
        var g6 = b2.memoizedState;
        d8 = g6.element;
        if (f4.isDehydrated)
          if (f4 = { element: d8, isDehydrated: false, cache: g6.cache, pendingSuspenseBoundaries: g6.pendingSuspenseBoundaries, transitions: g6.transitions }, b2.updateQueue.baseState = f4, b2.memoizedState = f4, b2.flags & 256) {
            e3 = Ji(Error(p$A(423)), b2);
            b2 = lj(a9, b2, d8, c6, e3);
            break a;
          } else if (d8 !== e3) {
            e3 = Ji(Error(p$A(424)), b2);
            b2 = lj(a9, b2, d8, c6, e3);
            break a;
          } else
            for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I$e = true, zg = null, c6 = Vg(b2, null, d8, c6), b2.child = c6; c6; )
              c6.flags = c6.flags & -3 | 4096, c6 = c6.sibling;
        else {
          Ig();
          if (d8 === e3) {
            b2 = Zi(a9, b2, c6);
            break a;
          }
          Xi(a9, b2, d8, c6);
        }
        b2 = b2.child;
      }
      return b2;
    case 5:
      return Ah(b2), null === a9 && Eg(b2), d8 = b2.type, e3 = b2.pendingProps, f4 = null !== a9 ? a9.memoizedProps : null, g6 = e3.children, Ef(d8, e3) ? g6 = null : null !== f4 && Ef(d8, f4) && (b2.flags |= 32), gj(a9, b2), Xi(a9, b2, g6, c6), b2.child;
    case 6:
      return null === a9 && Eg(b2), null;
    case 13:
      return oj(a9, b2, c6);
    case 4:
      return yh(b2, b2.stateNode.containerInfo), d8 = b2.pendingProps, null === a9 ? b2.child = Ug(b2, null, d8, c6) : Xi(a9, b2, d8, c6), b2.child;
    case 11:
      return d8 = b2.type, e3 = b2.pendingProps, e3 = b2.elementType === d8 ? e3 : Ci(d8, e3), Yi(a9, b2, d8, e3, c6);
    case 7:
      return Xi(a9, b2, b2.pendingProps, c6), b2.child;
    case 8:
      return Xi(a9, b2, b2.pendingProps.children, c6), b2.child;
    case 12:
      return Xi(a9, b2, b2.pendingProps.children, c6), b2.child;
    case 10:
      a: {
        d8 = b2.type._context;
        e3 = b2.pendingProps;
        f4 = b2.memoizedProps;
        g6 = e3.value;
        G$a(Wg, d8._currentValue);
        d8._currentValue = g6;
        if (null !== f4)
          if (He(f4.value, g6)) {
            if (f4.children === e3.children && !Wf.current) {
              b2 = Zi(a9, b2, c6);
              break a;
            }
          } else
            for (f4 = b2.child, null !== f4 && (f4.return = b2); null !== f4; ) {
              var h3 = f4.dependencies;
              if (null !== h3) {
                g6 = f4.child;
                for (var k3 = h3.firstContext; null !== k3; ) {
                  if (k3.context === d8) {
                    if (1 === f4.tag) {
                      k3 = mh(-1, c6 & -c6);
                      k3.tag = 2;
                      var l7 = f4.updateQueue;
                      if (null !== l7) {
                        l7 = l7.shared;
                        var m3 = l7.pending;
                        null === m3 ? k3.next = k3 : (k3.next = m3.next, m3.next = k3);
                        l7.pending = k3;
                      }
                    }
                    f4.lanes |= c6;
                    k3 = f4.alternate;
                    null !== k3 && (k3.lanes |= c6);
                    bh(
                      f4.return,
                      c6,
                      b2
                    );
                    h3.lanes |= c6;
                    break;
                  }
                  k3 = k3.next;
                }
              } else if (10 === f4.tag)
                g6 = f4.type === b2.type ? null : f4.child;
              else if (18 === f4.tag) {
                g6 = f4.return;
                if (null === g6)
                  throw Error(p$A(341));
                g6.lanes |= c6;
                h3 = g6.alternate;
                null !== h3 && (h3.lanes |= c6);
                bh(g6, c6, b2);
                g6 = f4.sibling;
              } else
                g6 = f4.child;
              if (null !== g6)
                g6.return = f4;
              else
                for (g6 = f4; null !== g6; ) {
                  if (g6 === b2) {
                    g6 = null;
                    break;
                  }
                  f4 = g6.sibling;
                  if (null !== f4) {
                    f4.return = g6.return;
                    g6 = f4;
                    break;
                  }
                  g6 = g6.return;
                }
              f4 = g6;
            }
        Xi(a9, b2, e3.children, c6);
        b2 = b2.child;
      }
      return b2;
    case 9:
      return e3 = b2.type, d8 = b2.pendingProps.children, ch(b2, c6), e3 = eh(e3), d8 = d8(e3), b2.flags |= 1, Xi(a9, b2, d8, c6), b2.child;
    case 14:
      return d8 = b2.type, e3 = Ci(d8, b2.pendingProps), e3 = Ci(d8.type, e3), $i(a9, b2, d8, e3, c6);
    case 15:
      return bj(a9, b2, b2.type, b2.pendingProps, c6);
    case 17:
      return d8 = b2.type, e3 = b2.pendingProps, e3 = b2.elementType === d8 ? e3 : Ci(d8, e3), ij(a9, b2), b2.tag = 1, Zf(d8) ? (a9 = true, cg(b2)) : a9 = false, ch(b2, c6), Gi(b2, d8, e3), Ii(b2, d8, e3, c6), jj(null, b2, d8, true, a9, c6);
    case 19:
      return xj(a9, b2, c6);
    case 22:
      return dj(a9, b2, c6);
  }
  throw Error(p$A(156, b2.tag));
};
function Fk(a9, b2) {
  return ac(a9, b2);
}
function $k(a9, b2, c6, d8) {
  this.tag = a9;
  this.key = c6;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b2;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d8;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function Bg(a9, b2, c6, d8) {
  return new $k(a9, b2, c6, d8);
}
function aj(a9) {
  a9 = a9.prototype;
  return !(!a9 || !a9.isReactComponent);
}
function Zk(a9) {
  if ("function" === typeof a9)
    return aj(a9) ? 1 : 0;
  if (void 0 !== a9 && null !== a9) {
    a9 = a9.$$typeof;
    if (a9 === Da)
      return 11;
    if (a9 === Ga)
      return 14;
  }
  return 2;
}
function Pg(a9, b2) {
  var c6 = a9.alternate;
  null === c6 ? (c6 = Bg(a9.tag, b2, a9.key, a9.mode), c6.elementType = a9.elementType, c6.type = a9.type, c6.stateNode = a9.stateNode, c6.alternate = a9, a9.alternate = c6) : (c6.pendingProps = b2, c6.type = a9.type, c6.flags = 0, c6.subtreeFlags = 0, c6.deletions = null);
  c6.flags = a9.flags & 14680064;
  c6.childLanes = a9.childLanes;
  c6.lanes = a9.lanes;
  c6.child = a9.child;
  c6.memoizedProps = a9.memoizedProps;
  c6.memoizedState = a9.memoizedState;
  c6.updateQueue = a9.updateQueue;
  b2 = a9.dependencies;
  c6.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
  c6.sibling = a9.sibling;
  c6.index = a9.index;
  c6.ref = a9.ref;
  return c6;
}
function Rg(a9, b2, c6, d8, e3, f4) {
  var g6 = 2;
  d8 = a9;
  if ("function" === typeof a9)
    aj(a9) && (g6 = 1);
  else if ("string" === typeof a9)
    g6 = 5;
  else
    a:
      switch (a9) {
        case ya:
          return Tg(c6.children, e3, f4, b2);
        case za:
          g6 = 8;
          e3 |= 8;
          break;
        case Aa:
          return a9 = Bg(12, c6, b2, e3 | 2), a9.elementType = Aa, a9.lanes = f4, a9;
        case Ea:
          return a9 = Bg(13, c6, b2, e3), a9.elementType = Ea, a9.lanes = f4, a9;
        case Fa:
          return a9 = Bg(19, c6, b2, e3), a9.elementType = Fa, a9.lanes = f4, a9;
        case Ia:
          return pj(c6, e3, f4, b2);
        default:
          if ("object" === typeof a9 && null !== a9)
            switch (a9.$$typeof) {
              case Ba:
                g6 = 10;
                break a;
              case Ca:
                g6 = 9;
                break a;
              case Da:
                g6 = 11;
                break a;
              case Ga:
                g6 = 14;
                break a;
              case Ha:
                g6 = 16;
                d8 = null;
                break a;
            }
          throw Error(p$A(130, null == a9 ? a9 : typeof a9, ""));
      }
  b2 = Bg(g6, c6, b2, e3);
  b2.elementType = a9;
  b2.type = d8;
  b2.lanes = f4;
  return b2;
}
function Tg(a9, b2, c6, d8) {
  a9 = Bg(7, a9, d8, b2);
  a9.lanes = c6;
  return a9;
}
function pj(a9, b2, c6, d8) {
  a9 = Bg(22, a9, d8, b2);
  a9.elementType = Ia;
  a9.lanes = c6;
  a9.stateNode = { isHidden: false };
  return a9;
}
function Qg(a9, b2, c6) {
  a9 = Bg(6, a9, null, b2);
  a9.lanes = c6;
  return a9;
}
function Sg(a9, b2, c6) {
  b2 = Bg(4, null !== a9.children ? a9.children : [], a9.key, b2);
  b2.lanes = c6;
  b2.stateNode = { containerInfo: a9.containerInfo, pendingChildren: null, implementation: a9.implementation };
  return b2;
}
function al(a9, b2, c6, d8, e3) {
  this.tag = b2;
  this.containerInfo = a9;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc(0);
  this.expirationTimes = zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc(0);
  this.identifierPrefix = d8;
  this.onRecoverableError = e3;
  this.mutableSourceEagerHydrationData = null;
}
function bl(a9, b2, c6, d8, e3, f4, g6, h3, k3) {
  a9 = new al(a9, b2, c6, h3, k3);
  1 === b2 ? (b2 = 1, true === f4 && (b2 |= 8)) : b2 = 0;
  f4 = Bg(3, null, null, b2);
  a9.current = f4;
  f4.stateNode = a9;
  f4.memoizedState = { element: d8, isDehydrated: c6, cache: null, transitions: null, pendingSuspenseBoundaries: null };
  kh(f4);
  return a9;
}
function cl(a9, b2, c6) {
  var d8 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: wa, key: null == d8 ? null : "" + d8, children: a9, containerInfo: b2, implementation: c6 };
}
function dl(a9) {
  if (!a9)
    return Vf;
  a9 = a9._reactInternals;
  a: {
    if (Vb(a9) !== a9 || 1 !== a9.tag)
      throw Error(p$A(170));
    var b2 = a9;
    do {
      switch (b2.tag) {
        case 3:
          b2 = b2.stateNode.context;
          break a;
        case 1:
          if (Zf(b2.type)) {
            b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b2 = b2.return;
    } while (null !== b2);
    throw Error(p$A(171));
  }
  if (1 === a9.tag) {
    var c6 = a9.type;
    if (Zf(c6))
      return bg(a9, c6, b2);
  }
  return b2;
}
function el(a9, b2, c6, d8, e3, f4, g6, h3, k3) {
  a9 = bl(c6, d8, true, a9, e3, f4, g6, h3, k3);
  a9.context = dl(null);
  c6 = a9.current;
  d8 = R$8();
  e3 = yi(c6);
  f4 = mh(d8, e3);
  f4.callback = void 0 !== b2 && null !== b2 ? b2 : null;
  nh(c6, f4, e3);
  a9.current.lanes = e3;
  Ac(a9, e3, d8);
  Dk(a9, d8);
  return a9;
}
function fl(a9, b2, c6, d8) {
  var e3 = b2.current, f4 = R$8(), g6 = yi(e3);
  c6 = dl(c6);
  null === b2.context ? b2.context = c6 : b2.pendingContext = c6;
  b2 = mh(f4, g6);
  b2.payload = { element: a9 };
  d8 = void 0 === d8 ? null : d8;
  null !== d8 && (b2.callback = d8);
  a9 = nh(e3, b2, g6);
  null !== a9 && (gi(a9, e3, g6, f4), oh(a9, e3, g6));
  return g6;
}
function gl(a9) {
  a9 = a9.current;
  if (!a9.child)
    return null;
  switch (a9.child.tag) {
    case 5:
      return a9.child.stateNode;
    default:
      return a9.child.stateNode;
  }
}
function hl(a9, b2) {
  a9 = a9.memoizedState;
  if (null !== a9 && null !== a9.dehydrated) {
    var c6 = a9.retryLane;
    a9.retryLane = 0 !== c6 && c6 < b2 ? c6 : b2;
  }
}
function il(a9, b2) {
  hl(a9, b2);
  (a9 = a9.alternate) && hl(a9, b2);
}
function jl() {
  return null;
}
var kl = "function" === typeof reportError ? reportError : function(a9) {
  console.error(a9);
};
function ll(a9) {
  this._internalRoot = a9;
}
ml.prototype.render = ll.prototype.render = function(a9) {
  var b2 = this._internalRoot;
  if (null === b2)
    throw Error(p$A(409));
  fl(a9, b2, null, null);
};
ml.prototype.unmount = ll.prototype.unmount = function() {
  var a9 = this._internalRoot;
  if (null !== a9) {
    this._internalRoot = null;
    var b2 = a9.containerInfo;
    Rk(function() {
      fl(null, a9, null, null);
    });
    b2[uf] = null;
  }
};
function ml(a9) {
  this._internalRoot = a9;
}
ml.prototype.unstable_scheduleHydration = function(a9) {
  if (a9) {
    var b2 = Hc();
    a9 = { blockedOn: null, target: a9, priority: b2 };
    for (var c6 = 0; c6 < Qc.length && 0 !== b2 && b2 < Qc[c6].priority; c6++)
      ;
    Qc.splice(c6, 0, a9);
    0 === c6 && Vc(a9);
  }
};
function nl(a9) {
  return !(!a9 || 1 !== a9.nodeType && 9 !== a9.nodeType && 11 !== a9.nodeType);
}
function ol(a9) {
  return !(!a9 || 1 !== a9.nodeType && 9 !== a9.nodeType && 11 !== a9.nodeType && (8 !== a9.nodeType || " react-mount-point-unstable " !== a9.nodeValue));
}
function pl() {
}
function ql(a9, b2, c6, d8, e3) {
  if (e3) {
    if ("function" === typeof d8) {
      var f4 = d8;
      d8 = function() {
        var a10 = gl(g6);
        f4.call(a10);
      };
    }
    var g6 = el(b2, d8, a9, 0, null, false, false, "", pl);
    a9._reactRootContainer = g6;
    a9[uf] = g6.current;
    sf(8 === a9.nodeType ? a9.parentNode : a9);
    Rk();
    return g6;
  }
  for (; e3 = a9.lastChild; )
    a9.removeChild(e3);
  if ("function" === typeof d8) {
    var h3 = d8;
    d8 = function() {
      var a10 = gl(k3);
      h3.call(a10);
    };
  }
  var k3 = bl(a9, 0, false, null, null, false, false, "", pl);
  a9._reactRootContainer = k3;
  a9[uf] = k3.current;
  sf(8 === a9.nodeType ? a9.parentNode : a9);
  Rk(function() {
    fl(b2, k3, c6, d8);
  });
  return k3;
}
function rl(a9, b2, c6, d8, e3) {
  var f4 = c6._reactRootContainer;
  if (f4) {
    var g6 = f4;
    if ("function" === typeof e3) {
      var h3 = e3;
      e3 = function() {
        var a10 = gl(g6);
        h3.call(a10);
      };
    }
    fl(b2, g6, a9, e3);
  } else
    g6 = ql(c6, b2, a9, e3, d8);
  return gl(g6);
}
Ec = function(a9) {
  switch (a9.tag) {
    case 3:
      var b2 = a9.stateNode;
      if (b2.current.memoizedState.isDehydrated) {
        var c6 = tc(b2.pendingLanes);
        0 !== c6 && (Cc(b2, c6 | 1), Dk(b2, B$8()), 0 === (K$7 & 6) && (Gj = B$8() + 500, jg()));
      }
      break;
    case 13:
      Rk(function() {
        var b3 = ih(a9, 1);
        if (null !== b3) {
          var c7 = R$8();
          gi(b3, a9, 1, c7);
        }
      }), il(a9, 1);
  }
};
Fc = function(a9) {
  if (13 === a9.tag) {
    var b2 = ih(a9, 134217728);
    if (null !== b2) {
      var c6 = R$8();
      gi(b2, a9, 134217728, c6);
    }
    il(a9, 134217728);
  }
};
Gc = function(a9) {
  if (13 === a9.tag) {
    var b2 = yi(a9), c6 = ih(a9, b2);
    if (null !== c6) {
      var d8 = R$8();
      gi(c6, a9, b2, d8);
    }
    il(a9, b2);
  }
};
Hc = function() {
  return C$g;
};
Ic = function(a9, b2) {
  var c6 = C$g;
  try {
    return C$g = a9, b2();
  } finally {
    C$g = c6;
  }
};
yb = function(a9, b2, c6) {
  switch (b2) {
    case "input":
      bb(a9, c6);
      b2 = c6.name;
      if ("radio" === c6.type && null != b2) {
        for (c6 = a9; c6.parentNode; )
          c6 = c6.parentNode;
        c6 = c6.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
        for (b2 = 0; b2 < c6.length; b2++) {
          var d8 = c6[b2];
          if (d8 !== a9 && d8.form === a9.form) {
            var e3 = Db(d8);
            if (!e3)
              throw Error(p$A(90));
            Wa(d8);
            bb(d8, e3);
          }
        }
      }
      break;
    case "textarea":
      ib(a9, c6);
      break;
    case "select":
      b2 = c6.value, null != b2 && fb(a9, !!c6.multiple, b2, false);
  }
};
Gb = Qk;
Hb = Rk;
var sl = { usingClientEntryPoint: false, Events: [Cb, ue$2, Db, Eb, Fb, Qk] }, tl = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" };
var ul = { bundleType: tl.bundleType, version: tl.version, rendererPackageName: tl.rendererPackageName, rendererConfig: tl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a9) {
  a9 = Zb(a9);
  return null === a9 ? null : a9.stateNode;
}, findFiberByHostInstance: tl.findFiberByHostInstance || jl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!vl.isDisabled && vl.supportsFiber)
    try {
      kc = vl.inject(ul), lc = vl;
    } catch (a9) {
    }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
reactDom_production_min.createPortal = function(a9, b2) {
  var c6 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!nl(b2))
    throw Error(p$A(200));
  return cl(a9, b2, null, c6);
};
reactDom_production_min.createRoot = function(a9, b2) {
  if (!nl(a9))
    throw Error(p$A(299));
  var c6 = false, d8 = "", e3 = kl;
  null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c6 = true), void 0 !== b2.identifierPrefix && (d8 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e3 = b2.onRecoverableError));
  b2 = bl(a9, 1, false, null, null, c6, false, d8, e3);
  a9[uf] = b2.current;
  sf(8 === a9.nodeType ? a9.parentNode : a9);
  return new ll(b2);
};
reactDom_production_min.findDOMNode = function(a9) {
  if (null == a9)
    return null;
  if (1 === a9.nodeType)
    return a9;
  var b2 = a9._reactInternals;
  if (void 0 === b2) {
    if ("function" === typeof a9.render)
      throw Error(p$A(188));
    a9 = Object.keys(a9).join(",");
    throw Error(p$A(268, a9));
  }
  a9 = Zb(b2);
  a9 = null === a9 ? null : a9.stateNode;
  return a9;
};
reactDom_production_min.flushSync = function(a9) {
  return Rk(a9);
};
reactDom_production_min.hydrate = function(a9, b2, c6) {
  if (!ol(b2))
    throw Error(p$A(200));
  return rl(null, a9, b2, true, c6);
};
reactDom_production_min.hydrateRoot = function(a9, b2, c6) {
  if (!nl(a9))
    throw Error(p$A(405));
  var d8 = null != c6 && c6.hydratedSources || null, e3 = false, f4 = "", g6 = kl;
  null !== c6 && void 0 !== c6 && (true === c6.unstable_strictMode && (e3 = true), void 0 !== c6.identifierPrefix && (f4 = c6.identifierPrefix), void 0 !== c6.onRecoverableError && (g6 = c6.onRecoverableError));
  b2 = el(b2, null, a9, 1, null != c6 ? c6 : null, e3, false, f4, g6);
  a9[uf] = b2.current;
  sf(a9);
  if (d8)
    for (a9 = 0; a9 < d8.length; a9++)
      c6 = d8[a9], e3 = c6._getVersion, e3 = e3(c6._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c6, e3] : b2.mutableSourceEagerHydrationData.push(
        c6,
        e3
      );
  return new ml(b2);
};
reactDom_production_min.render = function(a9, b2, c6) {
  if (!ol(b2))
    throw Error(p$A(200));
  return rl(null, a9, b2, false, c6);
};
reactDom_production_min.unmountComponentAtNode = function(a9) {
  if (!ol(a9))
    throw Error(p$A(40));
  return a9._reactRootContainer ? (Rk(function() {
    rl(null, null, a9, false, function() {
      a9._reactRootContainer = null;
      a9[uf] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Qk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a9, b2, c6, d8) {
  if (!ol(c6))
    throw Error(p$A(200));
  if (null == a9 || void 0 === a9._reactInternals)
    throw Error(p$A(38));
  return rl(a9, b2, c6, false, d8);
};
reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var reactDomExports = reactDom.exports;
const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
var m$o = reactDomExports;
{
  client.createRoot = m$o.createRoot;
  client.hydrateRoot = m$o.hydrateRoot;
}
const AppDataContext = reactExports.createContext();
const getImageStyles = (decideImageStyle, ImageData, ImageSize) => {
  var _a, _b, _c, _d, _e2;
  let imageStyles = null;
  const url = getCurrentUrl();
  if (decideImageStyle == 0) {
    imageStyles = {
      backgroundImage: `url(${url}${(_a = ImageData == null ? void 0 : ImageData.Properties) == null ? void 0 : _a.File})`,
      position: "absolute",
      top: ImageSize && ImageSize.Posn && ImageSize.Posn.length ? ImageSize.Posn[0] : 0,
      left: ImageSize && ImageSize.Posn && ImageSize.Posn.length ? ImageSize.Posn[1] : 0,
      backgroundRepeat: "no-repeat",
      height: ImageSize && ImageSize.Size && ImageSize.Size.length ? ImageSize.Size[0] : "100%",
      width: ImageSize && ImageSize.Size && ImageSize.Size.length ? ImageSize.Size[1] : "100%"
    };
  }
  if (decideImageStyle == 1) {
    imageStyles = {
      backgroundImage: `url(${url}${(_b = ImageData == null ? void 0 : ImageData.Properties) == null ? void 0 : _b.File})`,
      backgroundRepeat: "repeat"
    };
  }
  if (decideImageStyle == 2) {
    imageStyles = {
      backgroundImage: `url(${url}${(_c = ImageData == null ? void 0 : ImageData.Properties) == null ? void 0 : _c.File})`,
      backgroundSize: "100% 100%",
      backgroundRepeat: "no-repeat",
      backgroundPosition: "center center",
      display: "flex",
      justifyContent: "center",
      alignItems: "center"
    };
  }
  if (decideImageStyle == 3) {
    imageStyles = {
      backgroundImage: `url(${url}${(_d = ImageData == null ? void 0 : ImageData.Properties) == null ? void 0 : _d.File})`,
      backgroundPosition: "center center",
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      backgroundRepeat: "no-repeat"
    };
  }
  if (((_e2 = ImageData == null ? void 0 : ImageData.Properties) == null ? void 0 : _e2.Type) == "Icon") {
    imageStyles = {
      ...imageStyles,
      height: "32px",
      width: "32px",
      backgroundSize: "cover"
    };
  }
  return imageStyles;
};
const renderImage = (ImageData) => {
  var _a;
  return `${getCurrentUrl()}${(_a = ImageData == null ? void 0 : ImageData.Properties) == null ? void 0 : _a.File}`;
};
const deleteFormAndSiblings = (data2) => {
  let updatedData = {};
  const keys2 = Object.keys(data2);
  keys2 == null ? void 0 : keys2.forEach((key) => {
    var _a, _b, _c, _d;
    if (((_b = (_a = data2[key]) == null ? void 0 : _a.Properties) == null ? void 0 : _b.Type) !== "Form" || !((_d = (_c = data2[key]) == null ? void 0 : _c.Properties) == null ? void 0 : _d.Type)) {
      updatedData[data2[key].ID] = data2[key];
    }
  });
  return updatedData;
};
const parseFlexStyles = (inputString) => {
  let newInputString;
  if (Array.isArray(inputString)) {
    newInputString = inputString && inputString[1];
  } else {
    newInputString = inputString;
  }
  const stylesArray = newInputString && (newInputString == null ? void 0 : newInputString.split(",").map((style2) => style2.trim()));
  const stylesObject = {};
  stylesArray == null ? void 0 : stylesArray.forEach((style2) => {
    const [property, value2] = style2 == null ? void 0 : style2.split(":").map((item) => item.trim());
    const camelCaseProperty = property == null ? void 0 : property.replace(
      /-([a-z])/g,
      (match2, letter) => letter == null ? void 0 : letter.toUpperCase()
    );
    stylesObject[camelCaseProperty] = isNaN(value2) ? value2 : parseFloat(value2);
  });
  return stylesObject;
};
const getObjectTypeById = (jsonData, targetId) => {
  var _a, _b, _c;
  const data2 = jsonData;
  function searchObject(node, idToFind) {
    if (typeof node === "object") {
      if (node.ID === idToFind) {
        return node;
      }
      for (const key in node) {
        const result2 = searchObject(node[key], idToFind);
        if (result2) {
          return result2;
        }
      }
    } else if (Array.isArray(node)) {
      for (const item of node) {
        const result2 = searchObject(item, idToFind);
        if (result2) {
          return result2;
        }
      }
    }
    return null;
  }
  let result = searchObject(data2, targetId);
  if (!result)
    return null;
  result = JSON.stringify(result, null, 2);
  result = JSON.parse(result);
  if (((_a = result == null ? void 0 : result.Properties) == null ? void 0 : _a.Type) == "Combo")
    return "select";
  if (((_b = result == null ? void 0 : result.Properties) == null ? void 0 : _b.Type) == "Edit" || ((_c = result == null ? void 0 : result.Properties) == null ? void 0 : _c.Type) == "Button")
    return "input";
  return "span";
};
const getLastTabButton = (data2) => {
  let array = Object.keys(data2).map((key) => {
    var _a;
    if (((_a = data2[key]) == null ? void 0 : _a.Properties.Type) == "TabButton") {
      return data2[key].ID;
    } else {
      return void 0;
    }
  }).filter((id2) => id2 !== void 0);
  return array.pop();
};
const locateParentByPath = (startLevel, path) => {
  const splitID = path.split(".");
  let currentLevel = startLevel;
  for (let i16 = 0; i16 < splitID.length - 1; i16++) {
    const key = splitID[i16];
    if (!currentLevel[key]) {
      currentLevel[key] = {};
    }
    currentLevel = currentLevel[key];
  }
  return currentLevel;
};
const handleMouseDown = (e3, socket, Event, ID2) => {
  const shiftState = (e3.shiftKey ? 1 : 0) + (e3.ctrlKey ? 2 : 0);
  const rect = e3.currentTarget.getBoundingClientRect();
  const x3 = Math.round(e3.clientX - rect.left);
  const y4 = Math.round(e3.clientY - rect.top);
  const button = e3.button;
  const mousedownEvent = JSON.stringify({
    Event: {
      EventName: "MouseDown",
      ID: ID2,
      Info: [y4, x3, button, shiftState]
    }
  });
  const exists = Event && Event.some((item) => item[0] === "MouseDown");
  if (!exists)
    return;
  console.log(mousedownEvent);
  socket.send(mousedownEvent);
};
const handleMouseUp = (e3, socket, Event, ID2) => {
  const shiftState = (e3.shiftKey ? 1 : 0) + (e3.ctrlKey ? 2 : 0);
  const rect = e3.currentTarget.getBoundingClientRect();
  const x3 = Math.round(e3.clientX - rect.left);
  const y4 = Math.round(e3.clientY - rect.top);
  const button = e3.button;
  const mouseUpEvent = JSON.stringify({
    Event: {
      EventName: "MouseUp",
      ID: ID2,
      Info: [y4, x3, button, shiftState]
    }
  });
  const exists = Event && Event.some((item) => item[0] === "MouseUp");
  if (!exists)
    return;
  console.log(mouseUpEvent);
  socket.send(mouseUpEvent);
};
const handleMouseDoubleClick = (e3, socket, Event, ID2) => {
  const shiftState = (e3.shiftKey ? 1 : 0) + (e3.ctrlKey ? 2 : 0);
  const rect = e3.currentTarget.getBoundingClientRect();
  const x3 = Math.round(e3.clientX - rect.left);
  const y4 = Math.round(e3.clientY - rect.top);
  const button = e3.button;
  const mouseUpEvent = JSON.stringify({
    Event: {
      EventName: "MouseDblClick",
      ID: ID2,
      Info: [y4, x3, button, shiftState]
    }
  });
  const exists = Event && Event.some((item) => item[0] === "MouseDblClick");
  if (!exists)
    return;
  console.log(mouseUpEvent);
  socket.send(mouseUpEvent);
};
const handleMouseEnter = (e3, socket, Event, ID2) => {
  const previousObjectName = e3.relatedTarget ? e3.relatedTarget.id : "";
  const mouseEnterEvent = JSON.stringify({
    Event: {
      EventName: "MouseEnter",
      ID: ID2,
      Info: [previousObjectName]
    }
  });
  const exists = Event && Event.some((item) => item[0] === "MouseEnter");
  if (!exists)
    return;
  console.log("mouseEnter", mouseEnterEvent);
  socket.send(mouseEnterEvent);
};
const handleMouseLeave = (e3, socket, Event, ID2) => {
  const newObjectName = e3.relatedTarget ? e3.relatedTarget.id : "";
  const mouseLeaveEvent = JSON.stringify({
    Event: {
      EventName: "MouseLeave",
      ID: ID2,
      Info: [newObjectName]
    }
  });
  const exists = Event && Event.some((item) => item[0] === "MouseLeave");
  if (!exists)
    return;
  console.log(mouseLeaveEvent);
  socket.send(mouseLeaveEvent);
};
const handleMouseMove = (e3, socket, Event, ID2) => {
  const shiftState = (e3.shiftKey ? 1 : 0) + (e3.ctrlKey ? 2 : 0);
  const rect = e3.currentTarget.getBoundingClientRect();
  const x3 = Math.round(e3.clientX - rect.left);
  const y4 = Math.round(e3.clientY - rect.top);
  const button = e3.buttons;
  const mouseMoveEvent = JSON.stringify({
    Event: {
      EventName: "MouseMove",
      ID: ID2,
      Info: [y4, x3, button, shiftState]
    }
  });
  const exists = Event && Event.some((item) => item[0] === "MouseMove");
  if (!exists)
    return;
  socket.send(mouseMoveEvent);
};
const handleMouseWheel = (e3, socket, Event, ID2) => {
  const shiftState = (e3.shiftKey ? 1 : 0) + (e3.ctrlKey ? 2 : 0);
  const rect = e3.currentTarget.getBoundingClientRect();
  const x3 = Math.round(e3.clientX - rect.left);
  const y4 = Math.round(e3.clientY - rect.top);
  const button = e3.buttons;
  const delta = e3.deltaY;
  const lines = e3.deltaMode === 1 ? e3.deltaY : -1;
  const wheelDelta = Math.sign(e3.deltaY);
  const mouseWheelEvent = JSON.stringify({
    Event: {
      EventName: "MouseWheel",
      ID: ID2,
      Info: [y4, x3, button, shiftState, delta, lines, wheelDelta]
    }
  });
  const exists = Event && Event.some((item) => item[0] === "MouseWheel");
  if (!exists)
    return;
  console.log(mouseWheelEvent);
  socket.send(mouseWheelEvent);
};
const handleKeyPressUtils = (e3, socket, Event, ID2) => {
  var _a, _b;
  const isAltPressed = (e3 == null ? void 0 : e3.altKey) ? 4 : 0;
  const isCtrlPressed = (e3 == null ? void 0 : e3.ctrlKey) ? 2 : 0;
  const isShiftPressed = (e3 == null ? void 0 : e3.shiftKey) ? 1 : 0;
  const charCode = (_a = e3 == null ? void 0 : e3.key) == null ? void 0 : _a.charCodeAt(0);
  let shiftState = isAltPressed + isCtrlPressed + isShiftPressed;
  const exists = Event.some((item) => item[0] === "KeyPress");
  if (!exists)
    return;
  console.log(
    JSON.stringify({
      Event: {
        EventName: "KeyPress",
        ID: ID2,
        Info: [e3.key, charCode, e3.keyCode, shiftState]
      }
    })
  );
  socket.send(
    JSON.stringify({
      Event: {
        EventName: "KeyPress",
        ID: (_b = data == null ? void 0 : data.typeObj) == null ? void 0 : _b.ID,
        Info: [e3.key, charCode, e3.keyCode, shiftState]
      }
    })
  );
};
const setStyle$1 = (Properties, position2 = "absolute", Flex = 0) => {
  if (Flex == 2) {
    return {
      display: "flex",
      flex: 1,
      height: "100vh"
    };
  }
  if (Flex == 1) {
    return {
      display: "flex"
    };
  }
  if (Flex == "fill") {
    return {
      display: "flex",
      height: "100vh",
      flexDirection: "column",
      flex: 1
    };
  }
  if (Flex === "column") {
    return {
      display: "flex",
      flexDirection: "column",
      margin: "5px"
    };
  }
  if (Flex === "row") {
    return {
      flexDirection: "row",
      justifyContent: "space-between",
      flexWrap: "wrap",
      gap: "5px",
      alignItems: "end"
    };
  }
  return {
    ...(Properties == null ? void 0 : Properties.hasOwnProperty("Posn")) ? { position: "absolute" } : { position: "relative" },
    // position: Properties?.Posn ? 'absolute' : 'relative',
    height: (Properties == null ? void 0 : Properties.Size) && (Properties == null ? void 0 : Properties.Size[0]),
    width: (Properties == null ? void 0 : Properties.Size) && (Properties == null ? void 0 : Properties.Size[1]),
    top: (Properties == null ? void 0 : Properties.Posn) && (Properties == null ? void 0 : Properties.Posn[0]),
    left: (Properties == null ? void 0 : Properties.Posn) && (Properties == null ? void 0 : Properties.Posn[1])
  };
};
const excludeKeys = (obj) => {
  const keysToExclude = ["ID", "Properties"];
  const result = {};
  for (const key in obj) {
    if (!keysToExclude.includes(key)) {
      result[key] = obj[key];
    }
  }
  return result;
};
const isEmpty = (obj) => {
  return Object.keys(obj).length === 0;
};
const extractStringUntilLastPeriod = (inputString) => {
  const lastPeriodIndex = inputString.lastIndexOf(".");
  if (lastPeriodIndex !== -1) {
    const result = inputString.slice(0, lastPeriodIndex);
    return result;
  }
  return inputString;
};
const extractStringFromLastPeriod = (inputString) => {
  const lastPeriodIndex = inputString.lastIndexOf(".");
  if (lastPeriodIndex !== -1) {
    const result = inputString.slice(1 + lastPeriodIndex);
    return result;
  }
  return inputString;
};
const generateHeader = (length) => {
  const result = [];
  const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  let current2 = "";
  while (length > 0) {
    result.push(current2);
    let carry = 1;
    for (let i16 = current2.length - 1; i16 >= 0 && carry; i16--) {
      const char = current2[i16];
      const index2 = alphabet.indexOf(char);
      if (index2 === alphabet.length - 1) {
        current2 = current2.substring(0, i16) + alphabet[0] + current2.substring(i16 + 1);
      } else {
        current2 = current2.substring(0, i16) + alphabet[index2 + 1] + current2.substring(i16 + 1);
        carry = 0;
      }
    }
    if (carry) {
      current2 = "A" + current2;
    }
    length--;
  }
  return result;
};
const getObjectById = (jsonData, targetId) => {
  const data2 = jsonData;
  function searchObject(node, idToFind) {
    if (typeof node === "object") {
      if (node.ID === idToFind) {
        return node;
      }
      for (const key in node) {
        const result2 = searchObject(node[key], idToFind);
        if (result2) {
          return result2;
        }
      }
    } else if (Array.isArray(node)) {
      for (const item of node) {
        const result2 = searchObject(item, idToFind);
        if (result2) {
          return result2;
        }
      }
    }
    return null;
  }
  const result = searchObject(data2, targetId);
  return result ? JSON.stringify(result, null, 2) : null;
};
const generateAsteriskString = (length) => {
  if (length <= 0) {
    return "*";
  }
  let asteriskString = "";
  for (let i16 = 0; i16 < length; i16++) {
    asteriskString += "*";
  }
  return asteriskString;
};
const getStringafterPeriod = (ID2) => {
  const parts = ID2 == null ? void 0 : ID2.split(".");
  if ((parts == null ? void 0 : parts.length) > 1) {
    return parts[1];
  } else {
    return ID2;
  }
};
const calculateSumFromString = (inputString) => {
  const numbers = inputString[0].split("-").map(Number);
  if (numbers.length === 2) {
    const sum2 = numbers[0] + numbers[1];
    return sum2;
  } else {
    return null;
  }
};
const findParentIndex = (depthArray, parentNumber) => {
  let parentCount = 0;
  let parentIndex = -1;
  for (let i16 = 0; i16 < depthArray.length; i16++) {
    if (depthArray[i16] === 0) {
      parentCount++;
      if (parentCount === parentNumber) {
        parentIndex = i16;
        break;
      }
    }
  }
  return parentIndex;
};
const rgbColor = (rgbArray) => {
  try {
    if (!Array.isArray(rgbArray) || rgbArray.length !== 3 && !(Array.isArray(rgbArray[0]) && rgbArray[0].length === 3)) {
      return null;
    }
    if (Array.isArray(rgbArray[0]) && rgbArray[0].length === 3) {
      rgbArray = rgbArray[0];
    }
    const [r12, g6, b2] = rgbArray;
    if ([r12, g6, b2].some((color) => color < 0 || color > 255)) {
      return null;
    }
    return `rgb(${r12}, ${g6}, ${b2})`;
  } catch (error2) {
    console.log("rgb error", error2);
    return null;
  }
};
const calculateDateAfterDays = (days) => {
  var startDate = new Date(1900, 0, 1);
  var targetDate = new Date((startDate == null ? void 0 : startDate.getTime()) + days * 24 * 60 * 60 * 1e3);
  var formattedDate = targetDate == null ? void 0 : targetDate.toISOString().split("T")[0];
  return formattedDate;
};
const calculateDaysFromDate = (inputDate) => {
  const [year, month, day] = inputDate.split("-");
  const inputDateObj = new Date(year, month - 1, day);
  const startDate = new Date(1900, 0, 1, 0, 0, 0, 0);
  const timeDifference = inputDateObj.getTime() - startDate.getTime();
  const daysDifference = timeDifference / (24 * 60 * 60 * 1e3);
  return Math.round(daysDifference);
};
const checkSupportedProperties = (supportedProperties, array) => {
  const notSupportedProperties = array.filter(
    (item) => !supportedProperties.includes(item)
  );
  if (notSupportedProperties.length > 0) {
    const result = {
      NotSupported: notSupportedProperties
    };
    return result;
  } else {
    return null;
  }
};
const findFormParentID = (data2) => {
  const formParentID = Object.keys(data2).find((key) => {
    const item = data2[key];
    return item && item.Properties && item.Properties.Type === "Form";
  });
  return formParentID;
};
const createListViewObjects = (images, codes, descriptions, imagesIndexes) => {
  const result = codes.map((code, index2) => ({
    index: index2 + 1,
    title: code,
    description: descriptions && descriptions[index2][0],
    image: images && images[imagesIndexes[index2] - 1] || ""
  }));
  return result;
};
const getCurrentUrl = () => {
  const currentUrl = window.location.origin;
  const path = window.location.pathname !== "/" ? window.location.pathname : "";
  return currentUrl + path;
};
const MenuBar = ({ data: data2 }) => {
  const updatedData = excludeKeys(data2);
  const { Visible, CSS } = data2 == null ? void 0 : data2.Properties;
  const customStyles = parseFlexStyles(CSS);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      style: {
        display: Visible == 0 ? "none" : "flex",
        ...customStyles
      },
      children: Object.keys(updatedData).map((key) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectComponent, { data: updatedData[key] });
      })
    }
  );
};
const Dropdown$1 = "";
const useAppData = () => {
  const { socketData, dataRef, socket, handleData, focusedElement, reRender, proceed, setProceed, proceedEventArray, setProceedEventArray, colors, fontScale } = reactExports.useContext(AppDataContext);
  const findDesiredData = (ID2) => {
    const findData = socketData == null ? void 0 : socketData.find((obj) => obj.ID == ID2);
    return findData;
  };
  const findAggregatedPropertiesData = (ID2) => {
    const findAllData = socketData.filter((obj) => obj.ID === ID2);
    const reqObj = {
      ID: ID2,
      Properties: {}
    };
    findAllData.forEach((element) => {
      reqObj.Properties = {
        ...reqObj.Properties,
        ...element.Properties
      };
    });
    return reqObj;
  };
  const getObjType = (ID2) => {
    var _a;
    const findData = socketData == null ? void 0 : socketData.find((obj) => obj.ID == ID2);
    return (_a = findData == null ? void 0 : findData.Properties) == null ? void 0 : _a.Type;
  };
  return {
    socketData,
    findDesiredData,
    getObjType,
    dataRef,
    socket,
    handleData,
    focusedElement,
    reRender,
    proceed,
    setProceed,
    proceedEventArray,
    setProceedEventArray,
    colors,
    findAggregatedPropertiesData,
    fontScale
  };
};
const useResizeObserver = (parent) => {
  const [dimensions, setDimensions] = reactExports.useState({
    width: parent == null ? void 0 : parent.clientWidth,
    height: parent == null ? void 0 : parent.clientHeight
  });
  reactExports.useEffect(() => {
    if (!parent) {
      return;
    }
    const resizeObserver2 = new ResizeObserver((entries) => {
      const { offsetWidth, offsetHeight } = entries[0].target;
      setDimensions({
        width: offsetWidth,
        height: offsetHeight
      });
    });
    resizeObserver2.observe(parent);
    return function cleanup2() {
      resizeObserver2.disconnect();
    };
  }, [parent]);
  return dimensions;
};
const useWindowDimensions = () => {
  const { socket } = useAppData();
  const [viewport, setViewport] = reactExports.useState({
    width: window.innerWidth,
    height: window.innerHeight
  });
  const resizeTimeoutRef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    const handleResize = () => {
      const newViewport = {
        width: window.innerWidth,
        height: window.innerHeight
      };
      let zoom = Math.round(window.devicePixelRatio * 100);
      setViewport(newViewport);
      if (resizeTimeoutRef.current) {
        clearTimeout(resizeTimeoutRef.current);
      }
      resizeTimeoutRef.current = setTimeout(() => {
        let event = JSON.stringify({
          DeviceCapabilities: {
            ViewPort: [newViewport.height, newViewport.width],
            ScreenSize: [window.screen.height, window.screen.width],
            DPR: zoom / 100,
            PPI: 200
          }
        });
        console.log({ event });
        socket.send(event);
      }, 1e3);
    };
    window.addEventListener("resize", handleResize);
    return () => {
      window.removeEventListener("resize", handleResize);
      if (resizeTimeoutRef.current) {
        clearTimeout(resizeTimeoutRef.current);
      }
    };
  }, []);
  return viewport;
};
const Dropdown = ({ title: title2, data: data2 }) => {
  const { socket } = useAppData();
  reactExports.useEffect(() => {
    const handleShortcut = (event) => {
      Object.keys(data2).forEach((key) => {
        var _a, _b, _c, _d;
        const itemCaption = (_b = (_a = data2[key]) == null ? void 0 : _a.Properties) == null ? void 0 : _b.Caption;
        const shortcutKey = (itemCaption == null ? void 0 : itemCaption.includes("&")) ? itemCaption.charAt(itemCaption.indexOf("&") + 1).toLowerCase() : null;
        if (shortcutKey && event.altKey && event.key.toLowerCase() === shortcutKey) {
          handleSelectEvent((_c = data2[key]) == null ? void 0 : _c.ID, (_d = data2[key]) == null ? void 0 : _d.Properties);
        }
      });
    };
    document.addEventListener("keydown", handleShortcut);
    return () => document.removeEventListener("keydown", handleShortcut);
  }, [data2]);
  const handleSelectEvent = (id2, Properties) => {
    const { Event } = Properties;
    const selectEvent = JSON.stringify({
      Event: {
        EventName: "Select",
        ID: id2
      }
    });
    const exists = Event && Event.some((item) => item[0] === "Select");
    if (!exists)
      return;
    console.log(selectEvent);
    socket.send(selectEvent);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: "12px", marginLeft: "7px", cursor: "pointer" }, className: "menu-item", children: [
    title2,
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "dropdown", children: Object.keys(data2).map((key) => {
      var _a, _b, _c, _d, _e2;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          id: (_a = data2[key]) == null ? void 0 : _a.ID,
          className: "dropdown-item",
          onClick: () => {
            var _a2, _b2;
            return handleSelectEvent((_a2 = data2[key]) == null ? void 0 : _a2.ID, (_b2 = data2[key]) == null ? void 0 : _b2.Properties);
          },
          children: (_d = (_c = (_b = data2[key]) == null ? void 0 : _b.Properties) == null ? void 0 : _c.Caption) == null ? void 0 : _d.replace("&", "")
        },
        (_e2 = data2[key]) == null ? void 0 : _e2.ID
      );
    }) })
  ] });
};
const Menu$1 = "";
const Menu = ({ data: data2 }) => {
  var _a, _b, _c, _d;
  const updatedData = excludeKeys(data2);
  const empty2 = isEmpty(updatedData);
  if (empty2) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        style: {
          fontSize: "12px",
          marginLeft: "7px",
          cursor: "pointer",
          display: "inline-block"
        },
        className: "menu-item",
        children: (_b = (_a = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _a.Caption) == null ? void 0 : _b.replace("&", "")
      }
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Dropdown,
    {
      data: updatedData,
      title: (
        // data?.Properties?.Caption?.includes('&')
        //   ? data?.Properties?.Caption?.substring(1)
        //   : data?.Properties?.Caption
        (_d = (_c = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _c.Caption) == null ? void 0 : _d.replace("&", "")
      )
    }
  );
};
var byteToHex = [];
for (var i$w = 0; i$w < 256; ++i$w) {
  byteToHex.push((i$w + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset2 = 0) {
  return (byteToHex[arr[offset2 + 0]] + byteToHex[arr[offset2 + 1]] + byteToHex[arr[offset2 + 2]] + byteToHex[arr[offset2 + 3]] + "-" + byteToHex[arr[offset2 + 4]] + byteToHex[arr[offset2 + 5]] + "-" + byteToHex[arr[offset2 + 6]] + byteToHex[arr[offset2 + 7]] + "-" + byteToHex[arr[offset2 + 8]] + byteToHex[arr[offset2 + 9]] + "-" + byteToHex[arr[offset2 + 10]] + byteToHex[arr[offset2 + 11]] + byteToHex[arr[offset2 + 12]] + byteToHex[arr[offset2 + 13]] + byteToHex[arr[offset2 + 14]] + byteToHex[arr[offset2 + 15]]).toLowerCase();
}
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const native = {
  randomUUID
};
function v4(options2, buf, offset2) {
  if (native.randomUUID && !buf && !options2) {
    return native.randomUUID();
  }
  options2 = options2 || {};
  var rnds = options2.random || (options2.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset2 = offset2 || 0;
    for (var i16 = 0; i16 < 16; ++i16) {
      buf[offset2 + i16] = rnds[i16];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
function __rest$1(s10, e3) {
  var t6 = {};
  for (var p6 in s10) {
    if (Object.prototype.hasOwnProperty.call(s10, p6) && e3.indexOf(p6) < 0) {
      t6[p6] = s10[p6];
    }
  }
  if (s10 != null && typeof Object.getOwnPropertySymbols === "function") {
    for (var i16 = 0, p6 = Object.getOwnPropertySymbols(s10); i16 < p6.length; i16++) {
      if (e3.indexOf(p6[i16]) < 0 && Object.prototype.propertyIsEnumerable.call(s10, p6[i16])) {
        t6[p6[i16]] = s10[p6[i16]];
      }
    }
  }
  return t6;
}
var SourceType;
(function(SourceType2) {
  SourceType2["event"] = "event";
  SourceType2["props"] = "prop";
})(SourceType || (SourceType = {}));
function noop$4() {
}
function memoizeOnce(cb2) {
  var lastArgs;
  var lastValue = void 0;
  return function() {
    var args = [], len = arguments.length;
    while (len--)
      args[len] = arguments[len];
    if (lastArgs && args.length === lastArgs.length && args.every(function(value2, index2) {
      return value2 === lastArgs[index2];
    })) {
      return lastValue;
    }
    lastArgs = args;
    lastValue = cb2.apply(void 0, args);
    return lastValue;
  };
}
function charIsNumber(char) {
  return !!(char || "").match(/\d/);
}
function isNil(val) {
  return val === null || val === void 0;
}
function isNanValue(val) {
  return typeof val === "number" && isNaN(val);
}
function isNotValidValue(val) {
  return isNil(val) || isNanValue(val) || typeof val === "number" && !isFinite(val);
}
function escapeRegExp(str) {
  return str.replace(/[-[\]/{}()*+?.\\^$|]/g, "\\$&");
}
function getThousandsGroupRegex(thousandsGroupStyle) {
  switch (thousandsGroupStyle) {
    case "lakh":
      return /(\d+?)(?=(\d\d)+(\d)(?!\d))(\.\d+)?/g;
    case "wan":
      return /(\d)(?=(\d{4})+(?!\d))/g;
    case "thousand":
    default:
      return /(\d)(?=(\d{3})+(?!\d))/g;
  }
}
function applyThousandSeparator(str, thousandSeparator, thousandsGroupStyle) {
  var thousandsGroupRegex = getThousandsGroupRegex(thousandsGroupStyle);
  var index2 = str.search(/[1-9]/);
  index2 = index2 === -1 ? str.length : index2;
  return str.substring(0, index2) + str.substring(index2, str.length).replace(thousandsGroupRegex, "$1" + thousandSeparator);
}
function usePersistentCallback(cb2) {
  var callbackRef = reactExports.useRef(cb2);
  callbackRef.current = cb2;
  var persistentCbRef = reactExports.useRef(function() {
    var args = [], len = arguments.length;
    while (len--)
      args[len] = arguments[len];
    return callbackRef.current.apply(callbackRef, args);
  });
  return persistentCbRef.current;
}
function splitDecimal(numStr, allowNegative) {
  if (allowNegative === void 0)
    allowNegative = true;
  var hasNegation = numStr[0] === "-";
  var addNegation = hasNegation && allowNegative;
  numStr = numStr.replace("-", "");
  var parts = numStr.split(".");
  var beforeDecimal = parts[0];
  var afterDecimal = parts[1] || "";
  return {
    beforeDecimal,
    afterDecimal,
    hasNegation,
    addNegation
  };
}
function fixLeadingZero(numStr) {
  if (!numStr) {
    return numStr;
  }
  var isNegative = numStr[0] === "-";
  if (isNegative) {
    numStr = numStr.substring(1, numStr.length);
  }
  var parts = numStr.split(".");
  var beforeDecimal = parts[0].replace(/^0+/, "") || "0";
  var afterDecimal = parts[1] || "";
  return (isNegative ? "-" : "") + beforeDecimal + (afterDecimal ? "." + afterDecimal : "");
}
function limitToScale(numStr, scale, fixedDecimalScale) {
  var str = "";
  var filler = fixedDecimalScale ? "0" : "";
  for (var i16 = 0; i16 <= scale - 1; i16++) {
    str += numStr[i16] || filler;
  }
  return str;
}
function repeat(str, count) {
  return Array(count + 1).join(str);
}
function toNumericString(num) {
  var _num = num + "";
  var sign = _num[0] === "-" ? "-" : "";
  if (sign) {
    _num = _num.substring(1);
  }
  var ref2 = _num.split(/[eE]/g);
  var coefficient = ref2[0];
  var exponent = ref2[1];
  exponent = Number(exponent);
  if (!exponent) {
    return sign + coefficient;
  }
  coefficient = coefficient.replace(".", "");
  var decimalIndex = 1 + exponent;
  var coffiecientLn = coefficient.length;
  if (decimalIndex < 0) {
    coefficient = "0." + repeat("0", Math.abs(decimalIndex)) + coefficient;
  } else if (decimalIndex >= coffiecientLn) {
    coefficient = coefficient + repeat("0", decimalIndex - coffiecientLn);
  } else {
    coefficient = (coefficient.substring(0, decimalIndex) || "0") + "." + coefficient.substring(decimalIndex);
  }
  return sign + coefficient;
}
function roundToPrecision(numStr, scale, fixedDecimalScale) {
  if (["", "-"].indexOf(numStr) !== -1) {
    return numStr;
  }
  var shouldHaveDecimalSeparator = (numStr.indexOf(".") !== -1 || fixedDecimalScale) && scale;
  var ref2 = splitDecimal(numStr);
  var beforeDecimal = ref2.beforeDecimal;
  var afterDecimal = ref2.afterDecimal;
  var hasNegation = ref2.hasNegation;
  var floatValue = parseFloat("0." + (afterDecimal || "0"));
  var floatValueStr = afterDecimal.length <= scale ? "0." + afterDecimal : floatValue.toFixed(scale);
  var roundedDecimalParts = floatValueStr.split(".");
  var intPart = beforeDecimal;
  if (beforeDecimal && Number(roundedDecimalParts[0])) {
    intPart = beforeDecimal.split("").reverse().reduce(function(roundedStr, current2, idx) {
      if (roundedStr.length > idx) {
        return (Number(roundedStr[0]) + Number(current2)).toString() + roundedStr.substring(1, roundedStr.length);
      }
      return current2 + roundedStr;
    }, roundedDecimalParts[0]);
  }
  var decimalPart = limitToScale(roundedDecimalParts[1] || "", scale, fixedDecimalScale);
  var negation = hasNegation ? "-" : "";
  var decimalSeparator = shouldHaveDecimalSeparator ? "." : "";
  return "" + negation + intPart + decimalSeparator + decimalPart;
}
function setCaretPosition(el2, caretPos) {
  el2.value = el2.value;
  if (el2 !== null) {
    if (el2.createTextRange) {
      var range = el2.createTextRange();
      range.move("character", caretPos);
      range.select();
      return true;
    }
    if (el2.selectionStart || el2.selectionStart === 0) {
      el2.focus();
      el2.setSelectionRange(caretPos, caretPos);
      return true;
    }
    el2.focus();
    return false;
  }
}
var findChangeRange = memoizeOnce(function(prevValue, newValue) {
  var i16 = 0, j2 = 0;
  var prevLength = prevValue.length;
  var newLength = newValue.length;
  while (prevValue[i16] === newValue[i16] && i16 < prevLength) {
    i16++;
  }
  while (prevValue[prevLength - 1 - j2] === newValue[newLength - 1 - j2] && newLength - j2 > i16 && prevLength - j2 > i16) {
    j2++;
  }
  return {
    from: { start: i16, end: prevLength - j2 },
    to: { start: i16, end: newLength - j2 }
  };
});
var findChangedRangeFromCaretPositions = function(lastCaretPositions, currentCaretPosition) {
  var startPosition = Math.min(lastCaretPositions.selectionStart, currentCaretPosition);
  return {
    from: { start: startPosition, end: lastCaretPositions.selectionEnd },
    to: { start: startPosition, end: currentCaretPosition }
  };
};
function clamp(num, min2, max2) {
  return Math.min(Math.max(num, min2), max2);
}
function geInputCaretPosition(el2) {
  return Math.max(el2.selectionStart, el2.selectionEnd);
}
function addInputMode() {
  return typeof navigator !== "undefined" && !(navigator.platform && /iPhone|iPod/.test(navigator.platform));
}
function getDefaultChangeMeta(value2) {
  return {
    from: {
      start: 0,
      end: 0
    },
    to: {
      start: 0,
      end: value2.length
    },
    lastValue: ""
  };
}
function defaultIsCharacterSame(ref2) {
  var currentValue = ref2.currentValue;
  var formattedValue = ref2.formattedValue;
  var currentValueIndex = ref2.currentValueIndex;
  var formattedValueIndex = ref2.formattedValueIndex;
  return currentValue[currentValueIndex] === formattedValue[formattedValueIndex];
}
function getCaretPosition(newFormattedValue, lastFormattedValue, curValue, curCaretPos, boundary, isValidInputCharacter, isCharacterSame) {
  if (isCharacterSame === void 0)
    isCharacterSame = defaultIsCharacterSame;
  var firstAllowedPosition = boundary.findIndex(function(b2) {
    return b2;
  });
  var prefixFormat = newFormattedValue.slice(0, firstAllowedPosition);
  if (!lastFormattedValue && !curValue.startsWith(prefixFormat)) {
    lastFormattedValue = prefixFormat;
    curValue = prefixFormat + curValue;
    curCaretPos = curCaretPos + prefixFormat.length;
  }
  var curValLn = curValue.length;
  var formattedValueLn = newFormattedValue.length;
  var addedIndexMap = {};
  var indexMap = new Array(curValLn);
  for (var i16 = 0; i16 < curValLn; i16++) {
    indexMap[i16] = -1;
    for (var j2 = 0, jLn = formattedValueLn; j2 < jLn; j2++) {
      var isCharSame = isCharacterSame({
        currentValue: curValue,
        lastValue: lastFormattedValue,
        formattedValue: newFormattedValue,
        currentValueIndex: i16,
        formattedValueIndex: j2
      });
      if (isCharSame && addedIndexMap[j2] !== true) {
        indexMap[i16] = j2;
        addedIndexMap[j2] = true;
        break;
      }
    }
  }
  var pos = curCaretPos;
  while (pos < curValLn && (indexMap[pos] === -1 || !isValidInputCharacter(curValue[pos]))) {
    pos++;
  }
  var endIndex = pos === curValLn || indexMap[pos] === -1 ? formattedValueLn : indexMap[pos];
  pos = curCaretPos - 1;
  while (pos > 0 && indexMap[pos] === -1) {
    pos--;
  }
  var startIndex = pos === -1 || indexMap[pos] === -1 ? 0 : indexMap[pos] + 1;
  if (startIndex > endIndex) {
    return endIndex;
  }
  return curCaretPos - startIndex < endIndex - curCaretPos ? startIndex : endIndex;
}
function getCaretPosInBoundary(value2, caretPos, boundary, direction) {
  var valLn = value2.length;
  caretPos = clamp(caretPos, 0, valLn);
  if (direction === "left") {
    while (caretPos >= 0 && !boundary[caretPos]) {
      caretPos--;
    }
    if (caretPos === -1) {
      caretPos = boundary.indexOf(true);
    }
  } else {
    while (caretPos <= valLn && !boundary[caretPos]) {
      caretPos++;
    }
    if (caretPos > valLn) {
      caretPos = boundary.lastIndexOf(true);
    }
  }
  if (caretPos === -1) {
    caretPos = valLn;
  }
  return caretPos;
}
function caretUnknownFormatBoundary(formattedValue) {
  var boundaryAry = Array.from({ length: formattedValue.length + 1 }).map(function() {
    return true;
  });
  for (var i16 = 0, ln = boundaryAry.length; i16 < ln; i16++) {
    boundaryAry[i16] = Boolean(charIsNumber(formattedValue[i16]) || charIsNumber(formattedValue[i16 - 1]));
  }
  return boundaryAry;
}
function useInternalValues(value2, defaultValue, valueIsNumericString, format2, removeFormatting2, onValueChange) {
  if (onValueChange === void 0)
    onValueChange = noop$4;
  var getValues = usePersistentCallback(function(value3, valueIsNumericString2) {
    var formattedValue, numAsString;
    if (isNotValidValue(value3)) {
      numAsString = "";
      formattedValue = "";
    } else if (typeof value3 === "number" || valueIsNumericString2) {
      numAsString = typeof value3 === "number" ? toNumericString(value3) : value3;
      formattedValue = format2(numAsString);
    } else {
      numAsString = removeFormatting2(value3, void 0);
      formattedValue = format2(numAsString);
    }
    return { formattedValue, numAsString };
  });
  var ref2 = reactExports.useState(function() {
    return getValues(isNil(value2) ? defaultValue : value2, valueIsNumericString);
  });
  var values6 = ref2[0];
  var setValues = ref2[1];
  var _onValueChange = function(newValues2, sourceInfo) {
    if (newValues2.formattedValue !== values6.formattedValue) {
      setValues({
        formattedValue: newValues2.formattedValue,
        numAsString: newValues2.value
      });
    }
    onValueChange(newValues2, sourceInfo);
  };
  var _value = value2;
  var _valueIsNumericString = valueIsNumericString;
  if (isNil(value2)) {
    _value = values6.numAsString;
    _valueIsNumericString = true;
  }
  var newValues = getValues(_value, _valueIsNumericString);
  reactExports.useMemo(function() {
    setValues(newValues);
  }, [newValues.formattedValue]);
  return [values6, _onValueChange];
}
function defaultRemoveFormatting(value2) {
  return value2.replace(/[^0-9]/g, "");
}
function defaultFormat(value2) {
  return value2;
}
function NumberFormatBase(props) {
  var type = props.type;
  if (type === void 0)
    type = "text";
  var displayType = props.displayType;
  if (displayType === void 0)
    displayType = "input";
  var customInput = props.customInput;
  var renderText = props.renderText;
  var getInputRef = props.getInputRef;
  var format2 = props.format;
  if (format2 === void 0)
    format2 = defaultFormat;
  var removeFormatting2 = props.removeFormatting;
  if (removeFormatting2 === void 0)
    removeFormatting2 = defaultRemoveFormatting;
  var defaultValue = props.defaultValue;
  var valueIsNumericString = props.valueIsNumericString;
  var onValueChange = props.onValueChange;
  var isAllowed = props.isAllowed;
  var onChange = props.onChange;
  if (onChange === void 0)
    onChange = noop$4;
  var onKeyDown = props.onKeyDown;
  if (onKeyDown === void 0)
    onKeyDown = noop$4;
  var onMouseUp = props.onMouseUp;
  if (onMouseUp === void 0)
    onMouseUp = noop$4;
  var onFocus = props.onFocus;
  if (onFocus === void 0)
    onFocus = noop$4;
  var onBlur = props.onBlur;
  if (onBlur === void 0)
    onBlur = noop$4;
  var propValue = props.value;
  var getCaretBoundary2 = props.getCaretBoundary;
  if (getCaretBoundary2 === void 0)
    getCaretBoundary2 = caretUnknownFormatBoundary;
  var isValidInputCharacter = props.isValidInputCharacter;
  if (isValidInputCharacter === void 0)
    isValidInputCharacter = charIsNumber;
  var isCharacterSame = props.isCharacterSame;
  var otherProps = __rest$1(props, ["type", "displayType", "customInput", "renderText", "getInputRef", "format", "removeFormatting", "defaultValue", "valueIsNumericString", "onValueChange", "isAllowed", "onChange", "onKeyDown", "onMouseUp", "onFocus", "onBlur", "value", "getCaretBoundary", "isValidInputCharacter", "isCharacterSame"]);
  var ref2 = useInternalValues(propValue, defaultValue, Boolean(valueIsNumericString), format2, removeFormatting2, onValueChange);
  var ref_0 = ref2[0];
  var formattedValue = ref_0.formattedValue;
  var numAsString = ref_0.numAsString;
  var onFormattedValueChange = ref2[1];
  var caretPositionBeforeChange = reactExports.useRef();
  var lastUpdatedValue = reactExports.useRef({ formattedValue, numAsString });
  var _onValueChange = function(values6, source) {
    lastUpdatedValue.current = { formattedValue: values6.formattedValue, numAsString: values6.value };
    onFormattedValueChange(values6, source);
  };
  var ref$1 = reactExports.useState(false);
  var mounted = ref$1[0];
  var setMounted = ref$1[1];
  var focusedElm = reactExports.useRef(null);
  var timeout = reactExports.useRef({
    setCaretTimeout: null,
    focusTimeout: null
  });
  reactExports.useEffect(function() {
    setMounted(true);
    return function() {
      clearTimeout(timeout.current.setCaretTimeout);
      clearTimeout(timeout.current.focusTimeout);
    };
  }, []);
  var _format = format2;
  var getValueObject = function(formattedValue2, numAsString2) {
    var floatValue = parseFloat(numAsString2);
    return {
      formattedValue: formattedValue2,
      value: numAsString2,
      floatValue: isNaN(floatValue) ? void 0 : floatValue
    };
  };
  var setPatchedCaretPosition = function(el2, caretPos, currentValue) {
    if (el2.selectionStart === 0 && el2.selectionEnd === el2.value.length) {
      return;
    }
    setCaretPosition(el2, caretPos);
    timeout.current.setCaretTimeout = setTimeout(function() {
      if (el2.value === currentValue && el2.selectionStart !== caretPos) {
        setCaretPosition(el2, caretPos);
      }
    }, 0);
  };
  var correctCaretPosition = function(value2, caretPos, direction) {
    return getCaretPosInBoundary(value2, caretPos, getCaretBoundary2(value2), direction);
  };
  var getNewCaretPosition = function(inputValue, newFormattedValue, caretPos) {
    var caretBoundary = getCaretBoundary2(newFormattedValue);
    var updatedCaretPos = getCaretPosition(newFormattedValue, formattedValue, inputValue, caretPos, caretBoundary, isValidInputCharacter, isCharacterSame);
    updatedCaretPos = getCaretPosInBoundary(newFormattedValue, updatedCaretPos, caretBoundary);
    return updatedCaretPos;
  };
  var updateValueAndCaretPosition = function(params) {
    var newFormattedValue = params.formattedValue;
    if (newFormattedValue === void 0)
      newFormattedValue = "";
    var input = params.input;
    var source = params.source;
    var event = params.event;
    var numAsString2 = params.numAsString;
    var caretPos;
    if (input) {
      var inputValue = params.inputValue || input.value;
      var currentCaretPosition2 = geInputCaretPosition(input);
      input.value = newFormattedValue;
      caretPos = getNewCaretPosition(inputValue, newFormattedValue, currentCaretPosition2);
      if (caretPos !== void 0) {
        setPatchedCaretPosition(input, caretPos, newFormattedValue);
      }
    }
    if (newFormattedValue !== formattedValue) {
      _onValueChange(getValueObject(newFormattedValue, numAsString2), { event, source });
    }
  };
  reactExports.useEffect(function() {
    var ref3 = lastUpdatedValue.current;
    var lastFormattedValue = ref3.formattedValue;
    var lastNumAsString = ref3.numAsString;
    if (formattedValue !== lastFormattedValue || numAsString !== lastNumAsString) {
      _onValueChange(getValueObject(formattedValue, numAsString), {
        event: void 0,
        source: SourceType.props
      });
    }
  }, [formattedValue, numAsString]);
  var currentCaretPosition = focusedElm.current ? geInputCaretPosition(focusedElm.current) : void 0;
  var useIsomorphicLayoutEffect2 = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
  useIsomorphicLayoutEffect2(function() {
    var input = focusedElm.current;
    if (formattedValue !== lastUpdatedValue.current.formattedValue && input) {
      var caretPos = getNewCaretPosition(lastUpdatedValue.current.formattedValue, formattedValue, currentCaretPosition);
      input.value = formattedValue;
      setPatchedCaretPosition(input, caretPos, formattedValue);
    }
  }, [formattedValue]);
  var formatInputValue = function(inputValue, event, source) {
    var input = event.target;
    var changeRange = caretPositionBeforeChange.current ? findChangedRangeFromCaretPositions(caretPositionBeforeChange.current, input.selectionEnd) : findChangeRange(formattedValue, inputValue);
    var changeMeta = Object.assign(Object.assign({}, changeRange), { lastValue: formattedValue });
    var _numAsString = removeFormatting2(inputValue, changeMeta);
    var _formattedValue = _format(_numAsString);
    _numAsString = removeFormatting2(_formattedValue, void 0);
    if (isAllowed && !isAllowed(getValueObject(_formattedValue, _numAsString))) {
      var input$1 = event.target;
      var currentCaretPosition2 = geInputCaretPosition(input$1);
      var caretPos = getNewCaretPosition(inputValue, formattedValue, currentCaretPosition2);
      input$1.value = formattedValue;
      setPatchedCaretPosition(input$1, caretPos, formattedValue);
      return false;
    }
    updateValueAndCaretPosition({
      formattedValue: _formattedValue,
      numAsString: _numAsString,
      inputValue,
      event,
      source,
      input: event.target
    });
    return true;
  };
  var setCaretPositionInfoBeforeChange = function(el2, endOffset) {
    if (endOffset === void 0)
      endOffset = 0;
    var selectionStart = el2.selectionStart;
    var selectionEnd = el2.selectionEnd;
    caretPositionBeforeChange.current = { selectionStart, selectionEnd: selectionEnd + endOffset };
  };
  var _onChange = function(e3) {
    var el2 = e3.target;
    var inputValue = el2.value;
    var changed = formatInputValue(inputValue, e3, SourceType.event);
    if (changed) {
      onChange(e3);
    }
    caretPositionBeforeChange.current = void 0;
  };
  var _onKeyDown = function(e3) {
    var el2 = e3.target;
    var key = e3.key;
    var selectionStart = el2.selectionStart;
    var selectionEnd = el2.selectionEnd;
    var value2 = el2.value;
    if (value2 === void 0)
      value2 = "";
    var expectedCaretPosition;
    if (key === "ArrowLeft" || key === "Backspace") {
      expectedCaretPosition = Math.max(selectionStart - 1, 0);
    } else if (key === "ArrowRight") {
      expectedCaretPosition = Math.min(selectionStart + 1, value2.length);
    } else if (key === "Delete") {
      expectedCaretPosition = selectionStart;
    }
    var endOffset = 0;
    if (key === "Delete" && selectionStart === selectionEnd) {
      endOffset = 1;
    }
    var isArrowKey = key === "ArrowLeft" || key === "ArrowRight";
    if (expectedCaretPosition === void 0 || selectionStart !== selectionEnd && !isArrowKey) {
      onKeyDown(e3);
      setCaretPositionInfoBeforeChange(el2, endOffset);
      return;
    }
    var newCaretPosition = expectedCaretPosition;
    if (isArrowKey) {
      var direction = key === "ArrowLeft" ? "left" : "right";
      newCaretPosition = correctCaretPosition(value2, expectedCaretPosition, direction);
      if (newCaretPosition !== expectedCaretPosition) {
        e3.preventDefault();
      }
    } else if (key === "Delete" && !isValidInputCharacter(value2[expectedCaretPosition])) {
      newCaretPosition = correctCaretPosition(value2, expectedCaretPosition, "right");
    } else if (key === "Backspace" && !isValidInputCharacter(value2[expectedCaretPosition])) {
      newCaretPosition = correctCaretPosition(value2, expectedCaretPosition, "left");
    }
    if (newCaretPosition !== expectedCaretPosition) {
      setPatchedCaretPosition(el2, newCaretPosition, value2);
    }
    onKeyDown(e3);
    setCaretPositionInfoBeforeChange(el2, endOffset);
  };
  var _onMouseUp = function(e3) {
    var el2 = e3.target;
    var correctCaretPositionIfRequired = function() {
      var selectionStart = el2.selectionStart;
      var selectionEnd = el2.selectionEnd;
      var value2 = el2.value;
      if (value2 === void 0)
        value2 = "";
      if (selectionStart === selectionEnd) {
        var caretPosition = correctCaretPosition(value2, selectionStart);
        if (caretPosition !== selectionStart) {
          setPatchedCaretPosition(el2, caretPosition, value2);
        }
      }
    };
    correctCaretPositionIfRequired();
    requestAnimationFrame(function() {
      correctCaretPositionIfRequired();
    });
    onMouseUp(e3);
    setCaretPositionInfoBeforeChange(el2);
  };
  var _onFocus = function(e3) {
    if (e3.persist) {
      e3.persist();
    }
    var el2 = e3.target;
    var currentTarget = e3.currentTarget;
    focusedElm.current = el2;
    timeout.current.focusTimeout = setTimeout(function() {
      var selectionStart = el2.selectionStart;
      var selectionEnd = el2.selectionEnd;
      var value2 = el2.value;
      if (value2 === void 0)
        value2 = "";
      var caretPosition = correctCaretPosition(value2, selectionStart);
      if (caretPosition !== selectionStart && !(selectionStart === 0 && selectionEnd === value2.length)) {
        setPatchedCaretPosition(el2, caretPosition, value2);
      }
      onFocus(Object.assign(Object.assign({}, e3), { currentTarget }));
    }, 0);
  };
  var _onBlur = function(e3) {
    focusedElm.current = null;
    clearTimeout(timeout.current.focusTimeout);
    clearTimeout(timeout.current.setCaretTimeout);
    onBlur(e3);
  };
  var inputMode = mounted && addInputMode() ? "numeric" : void 0;
  var inputProps = Object.assign({ inputMode }, otherProps, {
    type,
    value: formattedValue,
    onChange: _onChange,
    onKeyDown: _onKeyDown,
    onMouseUp: _onMouseUp,
    onFocus: _onFocus,
    onBlur: _onBlur
  });
  if (displayType === "text") {
    return renderText ? t$q.createElement(t$q.Fragment, null, renderText(formattedValue, otherProps) || null) : t$q.createElement("span", Object.assign({}, otherProps, { ref: getInputRef }), formattedValue);
  } else if (customInput) {
    var CustomInput = customInput;
    return t$q.createElement(CustomInput, Object.assign({}, inputProps, { ref: getInputRef }));
  }
  return t$q.createElement("input", Object.assign({}, inputProps, { ref: getInputRef }));
}
function format$1(numStr, props) {
  var decimalScale = props.decimalScale;
  var fixedDecimalScale = props.fixedDecimalScale;
  var prefix = props.prefix;
  if (prefix === void 0)
    prefix = "";
  var suffix = props.suffix;
  if (suffix === void 0)
    suffix = "";
  var allowNegative = props.allowNegative;
  var thousandsGroupStyle = props.thousandsGroupStyle;
  if (thousandsGroupStyle === void 0)
    thousandsGroupStyle = "thousand";
  if (numStr === "" || numStr === "-") {
    return numStr;
  }
  var ref2 = getSeparators(props);
  var thousandSeparator = ref2.thousandSeparator;
  var decimalSeparator = ref2.decimalSeparator;
  var hasDecimalSeparator = decimalScale !== 0 && numStr.indexOf(".") !== -1 || decimalScale && fixedDecimalScale;
  var ref$1 = splitDecimal(numStr, allowNegative);
  var beforeDecimal = ref$1.beforeDecimal;
  var afterDecimal = ref$1.afterDecimal;
  var addNegation = ref$1.addNegation;
  if (decimalScale !== void 0) {
    afterDecimal = limitToScale(afterDecimal, decimalScale, !!fixedDecimalScale);
  }
  if (thousandSeparator) {
    beforeDecimal = applyThousandSeparator(beforeDecimal, thousandSeparator, thousandsGroupStyle);
  }
  if (prefix) {
    beforeDecimal = prefix + beforeDecimal;
  }
  if (suffix) {
    afterDecimal = afterDecimal + suffix;
  }
  if (addNegation) {
    beforeDecimal = "-" + beforeDecimal;
  }
  numStr = beforeDecimal + (hasDecimalSeparator && decimalSeparator || "") + afterDecimal;
  return numStr;
}
function getSeparators(props) {
  var decimalSeparator = props.decimalSeparator;
  if (decimalSeparator === void 0)
    decimalSeparator = ".";
  var thousandSeparator = props.thousandSeparator;
  var allowedDecimalSeparators = props.allowedDecimalSeparators;
  if (thousandSeparator === true) {
    thousandSeparator = ",";
  }
  if (!allowedDecimalSeparators) {
    allowedDecimalSeparators = [decimalSeparator, "."];
  }
  return {
    decimalSeparator,
    thousandSeparator,
    allowedDecimalSeparators
  };
}
function handleNegation(value2, allowNegative) {
  if (value2 === void 0)
    value2 = "";
  var negationRegex = new RegExp("(-)");
  var doubleNegationRegex = new RegExp("(-)(.)*(-)");
  var hasNegation = negationRegex.test(value2);
  var removeNegation = doubleNegationRegex.test(value2);
  value2 = value2.replace(/-/g, "");
  if (hasNegation && !removeNegation && allowNegative) {
    value2 = "-" + value2;
  }
  return value2;
}
function getNumberRegex(decimalSeparator, global2) {
  return new RegExp("(^-)|[0-9]|" + escapeRegExp(decimalSeparator), global2 ? "g" : void 0);
}
function isNumericString(val, prefix, suffix) {
  if (val === "") {
    return true;
  }
  return !(prefix === null || prefix === void 0 ? void 0 : prefix.match(/\d/)) && !(suffix === null || suffix === void 0 ? void 0 : suffix.match(/\d/)) && typeof val === "string" && !isNaN(Number(val));
}
function removeFormatting(value2, changeMeta, props) {
  var assign;
  if (changeMeta === void 0)
    changeMeta = getDefaultChangeMeta(value2);
  var allowNegative = props.allowNegative;
  var prefix = props.prefix;
  if (prefix === void 0)
    prefix = "";
  var suffix = props.suffix;
  if (suffix === void 0)
    suffix = "";
  var decimalScale = props.decimalScale;
  var from = changeMeta.from;
  var to = changeMeta.to;
  var start = to.start;
  var end = to.end;
  var ref2 = getSeparators(props);
  var allowedDecimalSeparators = ref2.allowedDecimalSeparators;
  var decimalSeparator = ref2.decimalSeparator;
  var isBeforeDecimalSeparator = value2[end] === decimalSeparator;
  if (charIsNumber(value2) && (value2 === prefix || value2 === suffix) && changeMeta.lastValue === "") {
    return value2;
  }
  if (end - start === 1 && allowedDecimalSeparators.indexOf(value2[start]) !== -1) {
    var separator = decimalScale === 0 ? "" : decimalSeparator;
    value2 = value2.substring(0, start) + separator + value2.substring(start + 1, value2.length);
  }
  var stripNegation = function(value3, start2, end2) {
    var hasNegation2 = false;
    var hasDoubleNegation = false;
    if (prefix.startsWith("-")) {
      hasNegation2 = false;
    } else if (value3.startsWith("--")) {
      hasNegation2 = false;
      hasDoubleNegation = true;
    } else if (suffix.startsWith("-") && value3.length === suffix.length) {
      hasNegation2 = false;
    } else if (value3[0] === "-") {
      hasNegation2 = true;
    }
    var charsToRemove = hasNegation2 ? 1 : 0;
    if (hasDoubleNegation) {
      charsToRemove = 2;
    }
    if (charsToRemove) {
      value3 = value3.substring(charsToRemove);
      start2 -= charsToRemove;
      end2 -= charsToRemove;
    }
    return { value: value3, start: start2, end: end2, hasNegation: hasNegation2 };
  };
  var toMetadata = stripNegation(value2, start, end);
  var hasNegation = toMetadata.hasNegation;
  assign = toMetadata, value2 = assign.value, start = assign.start, end = assign.end;
  var ref$1 = stripNegation(changeMeta.lastValue, from.start, from.end);
  var fromStart = ref$1.start;
  var fromEnd = ref$1.end;
  var lastValue = ref$1.value;
  var updatedSuffixPart = value2.substring(start, end);
  if (value2.length && lastValue.length && (fromStart > lastValue.length - suffix.length || fromEnd < prefix.length) && !(updatedSuffixPart && suffix.startsWith(updatedSuffixPart))) {
    value2 = lastValue;
  }
  var startIndex = 0;
  if (value2.startsWith(prefix)) {
    startIndex += prefix.length;
  } else if (start < prefix.length) {
    startIndex = start;
  }
  value2 = value2.substring(startIndex);
  end -= startIndex;
  var endIndex = value2.length;
  var suffixStartIndex = value2.length - suffix.length;
  if (value2.endsWith(suffix)) {
    endIndex = suffixStartIndex;
  } else if (end > suffixStartIndex) {
    endIndex = end;
  } else if (end > value2.length - suffix.length) {
    endIndex = end;
  }
  value2 = value2.substring(0, endIndex);
  value2 = handleNegation(hasNegation ? "-" + value2 : value2, allowNegative);
  value2 = (value2.match(getNumberRegex(decimalSeparator, true)) || []).join("");
  var firstIndex = value2.indexOf(decimalSeparator);
  value2 = value2.replace(new RegExp(escapeRegExp(decimalSeparator), "g"), function(match2, index2) {
    return index2 === firstIndex ? "." : "";
  });
  var ref$2 = splitDecimal(value2, allowNegative);
  var beforeDecimal = ref$2.beforeDecimal;
  var afterDecimal = ref$2.afterDecimal;
  var addNegation = ref$2.addNegation;
  if (to.end - to.start < from.end - from.start && beforeDecimal === "" && isBeforeDecimalSeparator && !parseFloat(afterDecimal)) {
    value2 = addNegation ? "-" : "";
  }
  return value2;
}
function getCaretBoundary(formattedValue, props) {
  var prefix = props.prefix;
  if (prefix === void 0)
    prefix = "";
  var suffix = props.suffix;
  if (suffix === void 0)
    suffix = "";
  var boundaryAry = Array.from({ length: formattedValue.length + 1 }).map(function() {
    return true;
  });
  var hasNegation = formattedValue[0] === "-";
  boundaryAry.fill(false, 0, prefix.length + (hasNegation ? 1 : 0));
  var valLn = formattedValue.length;
  boundaryAry.fill(false, valLn - suffix.length + 1, valLn + 1);
  return boundaryAry;
}
function validateAndUpdateProps(props) {
  var ref2 = getSeparators(props);
  var thousandSeparator = ref2.thousandSeparator;
  var decimalSeparator = ref2.decimalSeparator;
  var prefix = props.prefix;
  if (prefix === void 0)
    prefix = "";
  var allowNegative = props.allowNegative;
  if (allowNegative === void 0)
    allowNegative = true;
  if (thousandSeparator === decimalSeparator) {
    throw new Error("\n        Decimal separator can't be same as thousand separator.\n        thousandSeparator: " + thousandSeparator + ' (thousandSeparator = {true} is same as thousandSeparator = ",")\n        decimalSeparator: ' + decimalSeparator + " (default value for decimalSeparator is .)\n     ");
  }
  if (prefix.startsWith("-") && allowNegative) {
    console.error("\n      Prefix can't start with '-' when allowNegative is true.\n      prefix: " + prefix + "\n      allowNegative: " + allowNegative + "\n    ");
    allowNegative = false;
  }
  return Object.assign(Object.assign({}, props), { allowNegative });
}
function useNumericFormat(props) {
  props = validateAndUpdateProps(props);
  props.decimalSeparator;
  props.allowedDecimalSeparators;
  props.thousandsGroupStyle;
  var suffix = props.suffix;
  var allowNegative = props.allowNegative;
  var allowLeadingZeros = props.allowLeadingZeros;
  var onKeyDown = props.onKeyDown;
  if (onKeyDown === void 0)
    onKeyDown = noop$4;
  var onBlur = props.onBlur;
  if (onBlur === void 0)
    onBlur = noop$4;
  var thousandSeparator = props.thousandSeparator;
  var decimalScale = props.decimalScale;
  var fixedDecimalScale = props.fixedDecimalScale;
  var prefix = props.prefix;
  if (prefix === void 0)
    prefix = "";
  var defaultValue = props.defaultValue;
  var value2 = props.value;
  var valueIsNumericString = props.valueIsNumericString;
  var onValueChange = props.onValueChange;
  var restProps = __rest$1(props, ["decimalSeparator", "allowedDecimalSeparators", "thousandsGroupStyle", "suffix", "allowNegative", "allowLeadingZeros", "onKeyDown", "onBlur", "thousandSeparator", "decimalScale", "fixedDecimalScale", "prefix", "defaultValue", "value", "valueIsNumericString", "onValueChange"]);
  var ref2 = getSeparators(props);
  var decimalSeparator = ref2.decimalSeparator;
  var allowedDecimalSeparators = ref2.allowedDecimalSeparators;
  var _format = function(numStr) {
    return format$1(numStr, props);
  };
  var _removeFormatting = function(inputValue, changeMeta) {
    return removeFormatting(inputValue, changeMeta, props);
  };
  var _value = isNil(value2) ? defaultValue : value2;
  var _valueIsNumericString = valueIsNumericString !== null && valueIsNumericString !== void 0 ? valueIsNumericString : isNumericString(_value, prefix, suffix);
  if (!isNil(value2)) {
    _valueIsNumericString = _valueIsNumericString || typeof value2 === "number";
  } else if (!isNil(defaultValue)) {
    _valueIsNumericString = _valueIsNumericString || typeof defaultValue === "number";
  }
  var roundIncomingValueToPrecision = function(value3) {
    if (isNotValidValue(value3)) {
      return value3;
    }
    if (typeof value3 === "number") {
      value3 = toNumericString(value3);
    }
    if (_valueIsNumericString && typeof decimalScale === "number") {
      return roundToPrecision(value3, decimalScale, Boolean(fixedDecimalScale));
    }
    return value3;
  };
  var ref$1 = useInternalValues(roundIncomingValueToPrecision(value2), roundIncomingValueToPrecision(defaultValue), Boolean(_valueIsNumericString), _format, _removeFormatting, onValueChange);
  var ref$1_0 = ref$1[0];
  var numAsString = ref$1_0.numAsString;
  var formattedValue = ref$1_0.formattedValue;
  var _onValueChange = ref$1[1];
  var _onKeyDown = function(e3) {
    var el2 = e3.target;
    var key = e3.key;
    var selectionStart = el2.selectionStart;
    var selectionEnd = el2.selectionEnd;
    var value3 = el2.value;
    if (value3 === void 0)
      value3 = "";
    if ((key === "Backspace" || key === "Delete") && selectionEnd < prefix.length) {
      e3.preventDefault();
      return;
    }
    if (selectionStart !== selectionEnd) {
      onKeyDown(e3);
      return;
    }
    if (key === "Backspace" && value3[0] === "-" && selectionStart === prefix.length + 1 && allowNegative) {
      setCaretPosition(el2, 1);
    }
    if (decimalScale && fixedDecimalScale) {
      if (key === "Backspace" && value3[selectionStart - 1] === decimalSeparator) {
        setCaretPosition(el2, selectionStart - 1);
        e3.preventDefault();
      } else if (key === "Delete" && value3[selectionStart] === decimalSeparator) {
        e3.preventDefault();
      }
    }
    if ((allowedDecimalSeparators === null || allowedDecimalSeparators === void 0 ? void 0 : allowedDecimalSeparators.includes(key)) && value3[selectionStart] === decimalSeparator) {
      setCaretPosition(el2, selectionStart + 1);
    }
    var _thousandSeparator = thousandSeparator === true ? "," : thousandSeparator;
    if (key === "Backspace" && value3[selectionStart - 1] === _thousandSeparator) {
      setCaretPosition(el2, selectionStart - 1);
    }
    if (key === "Delete" && value3[selectionStart] === _thousandSeparator) {
      setCaretPosition(el2, selectionStart + 1);
    }
    onKeyDown(e3);
  };
  var _onBlur = function(e3) {
    var _value2 = numAsString;
    if (!_value2.match(/\d/g)) {
      _value2 = "";
    }
    if (!allowLeadingZeros) {
      _value2 = fixLeadingZero(_value2);
    }
    if (fixedDecimalScale && decimalScale) {
      _value2 = roundToPrecision(_value2, decimalScale, fixedDecimalScale);
    }
    if (_value2 !== numAsString) {
      var formattedValue2 = format$1(_value2, props);
      _onValueChange({
        formattedValue: formattedValue2,
        value: _value2,
        floatValue: parseFloat(_value2)
      }, {
        event: e3,
        source: SourceType.event
      });
    }
    onBlur(e3);
  };
  var isValidInputCharacter = function(inputChar) {
    if (inputChar === decimalSeparator) {
      return true;
    }
    return charIsNumber(inputChar);
  };
  var isCharacterSame = function(ref3) {
    var currentValue = ref3.currentValue;
    var lastValue = ref3.lastValue;
    var formattedValue2 = ref3.formattedValue;
    var currentValueIndex = ref3.currentValueIndex;
    var formattedValueIndex = ref3.formattedValueIndex;
    var curChar = currentValue[currentValueIndex];
    var newChar = formattedValue2[formattedValueIndex];
    var typedRange = findChangeRange(lastValue, currentValue);
    var to = typedRange.to;
    var getDecimalSeparatorIndex = function(value3) {
      return _removeFormatting(value3).indexOf(".") + prefix.length;
    };
    if (value2 === 0 && fixedDecimalScale && decimalScale && getDecimalSeparatorIndex(currentValue) < currentValueIndex && getDecimalSeparatorIndex(formattedValue2) > formattedValueIndex) {
      return false;
    }
    if (currentValueIndex >= to.start && currentValueIndex < to.end && allowedDecimalSeparators && allowedDecimalSeparators.includes(curChar) && newChar === decimalSeparator) {
      return true;
    }
    return curChar === newChar;
  };
  return Object.assign(Object.assign({}, restProps), {
    value: formattedValue,
    valueIsNumericString: false,
    isValidInputCharacter,
    isCharacterSame,
    onValueChange: _onValueChange,
    format: _format,
    removeFormatting: _removeFormatting,
    getCaretBoundary: function(formattedValue2) {
      return getCaretBoundary(formattedValue2, props);
    },
    onKeyDown: _onKeyDown,
    onBlur: _onBlur
  });
}
function NumericFormat(props) {
  var numericFormatProps = useNumericFormat(props);
  return t$q.createElement(NumberFormatBase, Object.assign({}, numericFormatProps));
}
var dayjs_min = { exports: {} };
(function(module, exports) {
  !function(t6, e3) {
    module.exports = e3();
  }(commonjsGlobal, function() {
    var t6 = 1e3, e3 = 6e4, n10 = 36e5, r12 = "millisecond", i16 = "second", s10 = "minute", u5 = "hour", a9 = "day", o9 = "week", c6 = "month", f4 = "quarter", h3 = "year", d8 = "date", l7 = "Invalid Date", $2 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y4 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M3 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t7) {
      var e4 = ["th", "st", "nd", "rd"], n11 = t7 % 100;
      return "[" + t7 + (e4[(n11 - 20) % 10] || e4[n11] || e4[0]) + "]";
    } }, m3 = function(t7, e4, n11) {
      var r13 = String(t7);
      return !r13 || r13.length >= e4 ? t7 : "" + Array(e4 + 1 - r13.length).join(n11) + t7;
    }, v3 = { s: m3, z: function(t7) {
      var e4 = -t7.utcOffset(), n11 = Math.abs(e4), r13 = Math.floor(n11 / 60), i17 = n11 % 60;
      return (e4 <= 0 ? "+" : "-") + m3(r13, 2, "0") + ":" + m3(i17, 2, "0");
    }, m: function t7(e4, n11) {
      if (e4.date() < n11.date())
        return -t7(n11, e4);
      var r13 = 12 * (n11.year() - e4.year()) + (n11.month() - e4.month()), i17 = e4.clone().add(r13, c6), s11 = n11 - i17 < 0, u6 = e4.clone().add(r13 + (s11 ? -1 : 1), c6);
      return +(-(r13 + (n11 - i17) / (s11 ? i17 - u6 : u6 - i17)) || 0);
    }, a: function(t7) {
      return t7 < 0 ? Math.ceil(t7) || 0 : Math.floor(t7);
    }, p: function(t7) {
      return { M: c6, y: h3, w: o9, d: a9, D: d8, h: u5, m: s10, s: i16, ms: r12, Q: f4 }[t7] || String(t7 || "").toLowerCase().replace(/s$/, "");
    }, u: function(t7) {
      return void 0 === t7;
    } }, g6 = "en", D2 = {};
    D2[g6] = M3;
    var p6 = "$isDayjsObject", S2 = function(t7) {
      return t7 instanceof _2 || !(!t7 || !t7[p6]);
    }, w3 = function t7(e4, n11, r13) {
      var i17;
      if (!e4)
        return g6;
      if ("string" == typeof e4) {
        var s11 = e4.toLowerCase();
        D2[s11] && (i17 = s11), n11 && (D2[s11] = n11, i17 = s11);
        var u6 = e4.split("-");
        if (!i17 && u6.length > 1)
          return t7(u6[0]);
      } else {
        var a10 = e4.name;
        D2[a10] = e4, i17 = a10;
      }
      return !r13 && i17 && (g6 = i17), i17 || !r13 && g6;
    }, O2 = function(t7, e4) {
      if (S2(t7))
        return t7.clone();
      var n11 = "object" == typeof e4 ? e4 : {};
      return n11.date = t7, n11.args = arguments, new _2(n11);
    }, b2 = v3;
    b2.l = w3, b2.i = S2, b2.w = function(t7, e4) {
      return O2(t7, { locale: e4.$L, utc: e4.$u, x: e4.$x, $offset: e4.$offset });
    };
    var _2 = function() {
      function M4(t7) {
        this.$L = w3(t7.locale, null, true), this.parse(t7), this.$x = this.$x || t7.x || {}, this[p6] = true;
      }
      var m4 = M4.prototype;
      return m4.parse = function(t7) {
        this.$d = function(t8) {
          var e4 = t8.date, n11 = t8.utc;
          if (null === e4)
            return /* @__PURE__ */ new Date(NaN);
          if (b2.u(e4))
            return /* @__PURE__ */ new Date();
          if (e4 instanceof Date)
            return new Date(e4);
          if ("string" == typeof e4 && !/Z$/i.test(e4)) {
            var r13 = e4.match($2);
            if (r13) {
              var i17 = r13[2] - 1 || 0, s11 = (r13[7] || "0").substring(0, 3);
              return n11 ? new Date(Date.UTC(r13[1], i17, r13[3] || 1, r13[4] || 0, r13[5] || 0, r13[6] || 0, s11)) : new Date(r13[1], i17, r13[3] || 1, r13[4] || 0, r13[5] || 0, r13[6] || 0, s11);
            }
          }
          return new Date(e4);
        }(t7), this.init();
      }, m4.init = function() {
        var t7 = this.$d;
        this.$y = t7.getFullYear(), this.$M = t7.getMonth(), this.$D = t7.getDate(), this.$W = t7.getDay(), this.$H = t7.getHours(), this.$m = t7.getMinutes(), this.$s = t7.getSeconds(), this.$ms = t7.getMilliseconds();
      }, m4.$utils = function() {
        return b2;
      }, m4.isValid = function() {
        return !(this.$d.toString() === l7);
      }, m4.isSame = function(t7, e4) {
        var n11 = O2(t7);
        return this.startOf(e4) <= n11 && n11 <= this.endOf(e4);
      }, m4.isAfter = function(t7, e4) {
        return O2(t7) < this.startOf(e4);
      }, m4.isBefore = function(t7, e4) {
        return this.endOf(e4) < O2(t7);
      }, m4.$g = function(t7, e4, n11) {
        return b2.u(t7) ? this[e4] : this.set(n11, t7);
      }, m4.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, m4.valueOf = function() {
        return this.$d.getTime();
      }, m4.startOf = function(t7, e4) {
        var n11 = this, r13 = !!b2.u(e4) || e4, f5 = b2.p(t7), l8 = function(t8, e5) {
          var i17 = b2.w(n11.$u ? Date.UTC(n11.$y, e5, t8) : new Date(n11.$y, e5, t8), n11);
          return r13 ? i17 : i17.endOf(a9);
        }, $3 = function(t8, e5) {
          return b2.w(n11.toDate()[t8].apply(n11.toDate("s"), (r13 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e5)), n11);
        }, y5 = this.$W, M5 = this.$M, m5 = this.$D, v5 = "set" + (this.$u ? "UTC" : "");
        switch (f5) {
          case h3:
            return r13 ? l8(1, 0) : l8(31, 11);
          case c6:
            return r13 ? l8(1, M5) : l8(0, M5 + 1);
          case o9:
            var g7 = this.$locale().weekStart || 0, D3 = (y5 < g7 ? y5 + 7 : y5) - g7;
            return l8(r13 ? m5 - D3 : m5 + (6 - D3), M5);
          case a9:
          case d8:
            return $3(v5 + "Hours", 0);
          case u5:
            return $3(v5 + "Minutes", 1);
          case s10:
            return $3(v5 + "Seconds", 2);
          case i16:
            return $3(v5 + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, m4.endOf = function(t7) {
        return this.startOf(t7, false);
      }, m4.$set = function(t7, e4) {
        var n11, o10 = b2.p(t7), f5 = "set" + (this.$u ? "UTC" : ""), l8 = (n11 = {}, n11[a9] = f5 + "Date", n11[d8] = f5 + "Date", n11[c6] = f5 + "Month", n11[h3] = f5 + "FullYear", n11[u5] = f5 + "Hours", n11[s10] = f5 + "Minutes", n11[i16] = f5 + "Seconds", n11[r12] = f5 + "Milliseconds", n11)[o10], $3 = o10 === a9 ? this.$D + (e4 - this.$W) : e4;
        if (o10 === c6 || o10 === h3) {
          var y5 = this.clone().set(d8, 1);
          y5.$d[l8]($3), y5.init(), this.$d = y5.set(d8, Math.min(this.$D, y5.daysInMonth())).$d;
        } else
          l8 && this.$d[l8]($3);
        return this.init(), this;
      }, m4.set = function(t7, e4) {
        return this.clone().$set(t7, e4);
      }, m4.get = function(t7) {
        return this[b2.p(t7)]();
      }, m4.add = function(r13, f5) {
        var d9, l8 = this;
        r13 = Number(r13);
        var $3 = b2.p(f5), y5 = function(t7) {
          var e4 = O2(l8);
          return b2.w(e4.date(e4.date() + Math.round(t7 * r13)), l8);
        };
        if ($3 === c6)
          return this.set(c6, this.$M + r13);
        if ($3 === h3)
          return this.set(h3, this.$y + r13);
        if ($3 === a9)
          return y5(1);
        if ($3 === o9)
          return y5(7);
        var M5 = (d9 = {}, d9[s10] = e3, d9[u5] = n10, d9[i16] = t6, d9)[$3] || 1, m5 = this.$d.getTime() + r13 * M5;
        return b2.w(m5, this);
      }, m4.subtract = function(t7, e4) {
        return this.add(-1 * t7, e4);
      }, m4.format = function(t7) {
        var e4 = this, n11 = this.$locale();
        if (!this.isValid())
          return n11.invalidDate || l7;
        var r13 = t7 || "YYYY-MM-DDTHH:mm:ssZ", i17 = b2.z(this), s11 = this.$H, u6 = this.$m, a10 = this.$M, o10 = n11.weekdays, c7 = n11.months, f5 = n11.meridiem, h4 = function(t8, n12, i18, s12) {
          return t8 && (t8[n12] || t8(e4, r13)) || i18[n12].slice(0, s12);
        }, d9 = function(t8) {
          return b2.s(s11 % 12 || 12, t8, "0");
        }, $3 = f5 || function(t8, e5, n12) {
          var r14 = t8 < 12 ? "AM" : "PM";
          return n12 ? r14.toLowerCase() : r14;
        };
        return r13.replace(y4, function(t8, r14) {
          return r14 || function(t9) {
            switch (t9) {
              case "YY":
                return String(e4.$y).slice(-2);
              case "YYYY":
                return b2.s(e4.$y, 4, "0");
              case "M":
                return a10 + 1;
              case "MM":
                return b2.s(a10 + 1, 2, "0");
              case "MMM":
                return h4(n11.monthsShort, a10, c7, 3);
              case "MMMM":
                return h4(c7, a10);
              case "D":
                return e4.$D;
              case "DD":
                return b2.s(e4.$D, 2, "0");
              case "d":
                return String(e4.$W);
              case "dd":
                return h4(n11.weekdaysMin, e4.$W, o10, 2);
              case "ddd":
                return h4(n11.weekdaysShort, e4.$W, o10, 3);
              case "dddd":
                return o10[e4.$W];
              case "H":
                return String(s11);
              case "HH":
                return b2.s(s11, 2, "0");
              case "h":
                return d9(1);
              case "hh":
                return d9(2);
              case "a":
                return $3(s11, u6, true);
              case "A":
                return $3(s11, u6, false);
              case "m":
                return String(u6);
              case "mm":
                return b2.s(u6, 2, "0");
              case "s":
                return String(e4.$s);
              case "ss":
                return b2.s(e4.$s, 2, "0");
              case "SSS":
                return b2.s(e4.$ms, 3, "0");
              case "Z":
                return i17;
            }
            return null;
          }(t8) || i17.replace(":", "");
        });
      }, m4.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, m4.diff = function(r13, d9, l8) {
        var $3, y5 = this, M5 = b2.p(d9), m5 = O2(r13), v5 = (m5.utcOffset() - this.utcOffset()) * e3, g7 = this - m5, D3 = function() {
          return b2.m(y5, m5);
        };
        switch (M5) {
          case h3:
            $3 = D3() / 12;
            break;
          case c6:
            $3 = D3();
            break;
          case f4:
            $3 = D3() / 3;
            break;
          case o9:
            $3 = (g7 - v5) / 6048e5;
            break;
          case a9:
            $3 = (g7 - v5) / 864e5;
            break;
          case u5:
            $3 = g7 / n10;
            break;
          case s10:
            $3 = g7 / e3;
            break;
          case i16:
            $3 = g7 / t6;
            break;
          default:
            $3 = g7;
        }
        return l8 ? $3 : b2.a($3);
      }, m4.daysInMonth = function() {
        return this.endOf(c6).$D;
      }, m4.$locale = function() {
        return D2[this.$L];
      }, m4.locale = function(t7, e4) {
        if (!t7)
          return this.$L;
        var n11 = this.clone(), r13 = w3(t7, e4, true);
        return r13 && (n11.$L = r13), n11;
      }, m4.clone = function() {
        return b2.w(this.$d, this);
      }, m4.toDate = function() {
        return new Date(this.valueOf());
      }, m4.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, m4.toISOString = function() {
        return this.$d.toISOString();
      }, m4.toString = function() {
        return this.$d.toUTCString();
      }, M4;
    }(), k3 = _2.prototype;
    return O2.prototype = k3, [["$ms", r12], ["$s", i16], ["$m", s10], ["$H", u5], ["$W", a9], ["$M", c6], ["$y", h3], ["$D", d8]].forEach(function(t7) {
      k3[t7[1]] = function(e4) {
        return this.$g(e4, t7[0], t7[1]);
      };
    }), O2.extend = function(t7, e4) {
      return t7.$i || (t7(e4, _2, O2), t7.$i = true), O2;
    }, O2.locale = w3, O2.isDayjs = S2, O2.unix = function(t7) {
      return O2(1e3 * t7);
    }, O2.en = D2[g6], O2.Ls = D2, O2.p = {}, O2;
  });
})(dayjs_min);
var dayjs_minExports = dayjs_min.exports;
const dayjs = /* @__PURE__ */ getDefaultExportFromCjs(dayjs_minExports);
const GridEdit = ({ data: data2 }) => {
  var _a;
  const inputRef = reactExports.useRef(null);
  const dateRef = reactExports.useRef(null);
  const divRef = reactExports.useRef(null);
  const [isEditable, setIsEditable] = reactExports.useState(false);
  const [selected, setSelected] = reactExports.useState(false);
  const [dateFormattedValue, setDateFormattedValue] = reactExports.useState(data2 == null ? void 0 : data2.value);
  const { FieldType, Decimal, SelText, Event } = (_a = data2 == null ? void 0 : data2.typeObj) == null ? void 0 : _a.Properties;
  const { dataRef, findDesiredData, handleData, socket, socketData } = useAppData();
  const dateFormat = JSON.parse(getObjectById(dataRef.current, "Locale"));
  const { ShortDate, Thousand, Decimal: decimalSeparator } = dateFormat == null ? void 0 : dateFormat.Properties;
  const [inputValue, setInputValue] = reactExports.useState(
    FieldType == "Date" ? dayjs(calculateDateAfterDays(data2 == null ? void 0 : data2.value)).format(ShortDate && ShortDate) : data2 == null ? void 0 : data2.value
  );
  const [selectedDate, setSelectedDate] = reactExports.useState(
    FieldType == "Date" ? dayjs(calculateDateAfterDays(data2 == null ? void 0 : data2.value)) : /* @__PURE__ */ new Date()
  );
  const findFirstNonSpaceIndex = (content) => {
    const trimmedContent = content.trimStart();
    const firstNonSpaceIndex = content.indexOf(trimmedContent[0]);
    return firstNonSpaceIndex;
  };
  reactExports.useEffect(() => {
    if (!isEditable && divRef.current && SelText && SelText.length === 2 && (data2 == null ? void 0 : data2.focused)) {
      const [start, end] = SelText;
      const textNode = divRef.current.firstChild;
      console.log({ textNode });
      const actualTextNode = (textNode == null ? void 0 : textNode.nodeType) ? textNode : textNode == null ? void 0 : textNode.textNode;
      if ((actualTextNode == null ? void 0 : actualTextNode.nodeType) === Node.TEXT_NODE) {
        const range = document.createRange();
        const selection = window.getSelection();
        const adjustedEnd = Math.min(end - 1, actualTextNode.length);
        const parent = actualTextNode.parentNode;
        parent.textContent.trim();
        console.log("use effect", { content: data2 == null ? void 0 : data2.formattedValue });
        if (data2 == null ? void 0 : data2.formattedValue) {
          console.log("content", { index: findFirstNonSpaceIndex(data2 == null ? void 0 : data2.formattedValue) });
          const reqIndex = findFirstNonSpaceIndex(data2 == null ? void 0 : data2.formattedValue);
          range.setStart(actualTextNode, Math.min(start - 1 + reqIndex, actualTextNode.length));
          range.setEnd(actualTextNode, Math.min(end - 1 + reqIndex, actualTextNode.length));
        } else {
          range.setStart(actualTextNode, Math.min(start - 1, actualTextNode.length));
          range.setEnd(actualTextNode, adjustedEnd);
        }
        selection.removeAllRanges();
        selection.addRange(range);
      }
    }
  }, [SelText, isEditable, data2.focused]);
  const handleSelect = (event) => {
    var _a2, _b, _c, _d;
    console.log("select");
    console.log({ event });
    const input = event.target;
    const start = input.selectionStart + 1;
    const end = input.selectionEnd + 1;
    const selectedText = input.value.substring(start, end);
    console.log({ data: data2, input, start, end });
    setSelected(!!selectedText);
    console.log("select", !!selectedText);
    if (!!selectedText) {
      localStorage.setItem((_a2 = data2 == null ? void 0 : data2.typeObj) == null ? void 0 : _a2.ID, JSON.stringify({ Event: { Info: [start, end] } }));
      handleData(
        {
          ID: (_b = data2 == null ? void 0 : data2.typeObj) == null ? void 0 : _b.ID,
          Properties: {
            SelText: [start, end]
          }
        },
        "WS"
      );
    } else {
      localStorage.setItem((_c = data2 == null ? void 0 : data2.typeObj) == null ? void 0 : _c.ID, JSON.stringify({ Event: { Info: [1, 1] } }));
      handleData(
        {
          ID: (_d = data2 == null ? void 0 : data2.typeObj) == null ? void 0 : _d.ID,
          Properties: {
            SelText: [1, 1]
          }
        },
        "WS"
      );
    }
  };
  const triggerCellChangedEvent = () => {
    const values6 = data2 == null ? void 0 : data2.gridValues;
    values6[(data2 == null ? void 0 : data2.row) - 1][data2 == null ? void 0 : data2.column] = FieldType == "Date" ? dateFormattedValue : inputValue;
    const cellChangedEvent = JSON.stringify({
      Event: {
        EventName: "CellChanged",
        ID: data2 == null ? void 0 : data2.gridId,
        Row: data2 == null ? void 0 : data2.row,
        Col: (data2 == null ? void 0 : data2.column) + 1,
        Value: FieldType == "Date" ? dateFormattedValue : inputValue
      }
    });
    const updatedGridValues = JSON.stringify({
      Event: {
        EventName: "CellChanged",
        Values: values6,
        CurCell: [data2 == null ? void 0 : data2.row, (data2 == null ? void 0 : data2.column) + 1]
      }
    });
    const formatCellEvent = JSON.stringify({
      FormatCell: {
        Cell: [data2 == null ? void 0 : data2.row, (data2 == null ? void 0 : data2.column) + 1],
        ID: data2 == null ? void 0 : data2.gridId,
        Value: FieldType == "Date" ? dateFormattedValue : inputValue
      }
    });
    localStorage.setItem(data2 == null ? void 0 : data2.gridId, updatedGridValues);
    const exists = (data2 == null ? void 0 : data2.gridEvent) && (data2 == null ? void 0 : data2.gridEvent.some((item) => item[0] === "CellChanged"));
    if (!exists)
      return;
    console.log(cellChangedEvent);
    socket.send(cellChangedEvent);
    localStorage.setItem(
      "isChanged",
      JSON.stringify({
        isChange: true,
        value: FieldType == "Date" ? dateFormattedValue : inputValue
      })
    );
    if (!(data2 == null ? void 0 : data2.formatString))
      return;
    console.log(formatCellEvent);
    socket.send(formatCellEvent);
  };
  reactExports.useEffect(() => {
    var _a2;
    if (data2.focused) {
      (_a2 = inputRef == null ? void 0 : inputRef.current) == null ? void 0 : _a2.focus();
    }
  }, [data2.focused]);
  reactExports.useEffect(() => {
    var _a2, _b;
    console.log("select useEffect", { selected });
    if (selected) {
      return;
    }
    console.log("select useEffect 2", { selected });
    localStorage.setItem((_a2 = data2 == null ? void 0 : data2.typeObj) == null ? void 0 : _a2.ID, JSON.stringify({ Event: { Info: [1, 1] } }));
    handleData(
      {
        ID: (_b = data2 == null ? void 0 : data2.typeObj) == null ? void 0 : _b.ID,
        Properties: {
          SelText: [1, 1]
        }
      },
      "WS"
    );
    return () => {
      console.log("select unmount");
    };
  }, [data2.focused]);
  const handleEditEvents = () => {
    if (FieldType == "Date") {
      if ((data2 == null ? void 0 : data2.value) == dateFormattedValue)
        return;
      triggerCellChangedEvent();
    } else {
      if ((data2 == null ? void 0 : data2.value) == inputValue)
        return;
      triggerCellChangedEvent();
    }
  };
  const handleKeyPress = (e3) => {
    var _a2, _b, _c, _d, _e2, _f;
    const isAltPressed = (e3 == null ? void 0 : e3.altKey) ? 4 : 0;
    const isCtrlPressed = (e3 == null ? void 0 : e3.ctrlKey) ? 2 : 0;
    const isShiftPressed = (e3 == null ? void 0 : e3.shiftKey) ? 1 : 0;
    const charCode = (_a2 = e3 == null ? void 0 : e3.key) == null ? void 0 : _a2.charCodeAt(0);
    let shiftState = isAltPressed + isCtrlPressed + isShiftPressed;
    const exists = (_d = (_c = (_b = data2 == null ? void 0 : data2.typeObj) == null ? void 0 : _b.Properties) == null ? void 0 : _c.Event) == null ? void 0 : _d.some((item) => item[0] === "KeyPress");
    if (!exists)
      return;
    console.log(
      JSON.stringify({
        Event: {
          EventName: "KeyPress",
          ID: (_e2 = data2 == null ? void 0 : data2.typeObj) == null ? void 0 : _e2.ID,
          Info: [e3.key, charCode, e3.keyCode, shiftState]
        }
      })
    );
    socket.send(
      JSON.stringify({
        Event: {
          EventName: "KeyPress",
          ID: (_f = data2 == null ? void 0 : data2.typeObj) == null ? void 0 : _f.ID,
          Info: [e3.key, charCode, e3.keyCode, shiftState]
        }
      })
    );
  };
  if (FieldType == "Date") {
    const handleDateChange = (event) => {
      setSelectedDate(event.target.value);
      const selectedDate2 = dayjs(event.target.value).format(ShortDate);
      console.log("date picker", { input: event.target.value, ShortDate, selectedDate: selectedDate2 });
      let value2 = calculateDaysFromDate(event.target.value) + 1;
      setInputValue(selectedDate2);
      setDateFormattedValue(value2);
    };
    const handleInputChange = (event) => {
      setInputValue(event.target.value);
    };
    const handleDatePickerClick = () => {
      inputRef.current.showPicker();
    };
    const handleInputBlur = () => {
      const [day, month, year] = inputValue.split("-");
      const formattedDate = `${year}-${month}-${day}`;
      const newDate = new Date(formattedDate);
      const parsedDate = dayjs(newDate, ShortDate, true);
      if (parsedDate.isValid()) {
        const formattedDate2 = parsedDate.format("YYYY-MM-DD");
        setSelectedDate(formattedDate2);
        const value2 = calculateDaysFromDate(formattedDate2) + 1;
        setDateFormattedValue(value2);
      } else {
        console.warn("Invalid date entered");
      }
      setIsEditable(false);
      handleEditEvents();
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: !isEditable ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        onDoubleClick: (e3) => {
          setIsEditable(true);
        },
        style: { backgroundColor: data2 == null ? void 0 : data2.backgroundColor, outline: 0, paddingLeft: "5px", paddingRight: "5px" },
        children: !(data2 == null ? void 0 : data2.formattedValue) ? inputValue : data2 == null ? void 0 : data2.formattedValue
      }
    ) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            ref: dateRef,
            id: `${data2 == null ? void 0 : data2.gridId}`,
            style: {
              border: 0,
              outline: 0,
              width: "100%",
              height: "100%",
              paddingLeft: "5px",
              paddingRight: "5px"
            },
            value: inputValue,
            onChange: handleInputChange,
            type: "text",
            onClick: (e3) => {
            },
            onBlur: handleInputBlur,
            onKeyDown: (e3) => {
              e3.stopPropagation();
            }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: handleDatePickerClick,
            style: {
              border: "none",
              background: "transparent",
              cursor: "pointer",
              padding: 0
            },
            children: ""
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          id: `${data2 == null ? void 0 : data2.gridId}`,
          type: "date",
          value: dayjs(new Date(selectedDate)).format("YYYY-MM-DD"),
          ref: inputRef,
          onChange: handleDateChange,
          style: {
            display: "none"
          }
        }
      )
    ] }) });
  }
  console.log("gridEdit", Event, data2);
  if (FieldType == "LongNumeric" || FieldType == "Numeric") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: !isEditable ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        ref: divRef,
        onDoubleClick: (e3) => {
          setIsEditable(true);
        },
        style: {
          backgroundColor: data2 == null ? void 0 : data2.backgroundColor,
          outline: 0,
          textAlign: "right",
          paddingRight: "5px"
        },
        children: !(data2 == null ? void 0 : data2.formattedValue) ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          NumericFormat,
          {
            className: "currency",
            allowLeadingZeros: true,
            id: `${data2 == null ? void 0 : data2.gridId}`,
            style: {
              width: "100%",
              border: 0,
              outline: 0,
              backgroundColor: data2 == null ? void 0 : data2.backgroundColor,
              textAlign: "right"
              // paddingRight: '5px',
              // paddingLeft: '5px'
            },
            readOnly: true,
            decimalScale: Decimal,
            value: data2 == null ? void 0 : data2.value,
            decimalSeparator,
            thousandSeparator: Thousand
          }
        ) : data2 == null ? void 0 : data2.formattedValue
      }
    ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
      NumericFormat,
      {
        className: "currency",
        allowLeadingZeros: true,
        getInputRef: inputRef,
        id: `${data2 == null ? void 0 : data2.gridId}`,
        style: {
          width: "100%",
          border: 0,
          outline: 0,
          backgroundColor: data2 == null ? void 0 : data2.backgroundColor,
          textAlign: "right",
          paddingRight: "5px",
          paddingLeft: "5px"
        },
        onValueChange: (value2) => {
          if (!value2.value)
            return setInputValue(0);
          setInputValue(parseFloat(value2 == null ? void 0 : value2.value));
        },
        decimalScale: Decimal,
        value: inputValue,
        onSelect: handleSelect,
        decimalSeparator,
        thousandSeparator: Thousand,
        onBlur: (e3) => {
          setIsEditable(false);
          handleEditEvents();
        },
        onKeyDown: (e3) => {
          e3.stopPropagation();
          handleKeyPress(e3);
        },
        onMouseDown: (e3) => {
          var _a2;
          handleMouseDown(e3, socket, Event, (_a2 = data2 == null ? void 0 : data2.typeObj) == null ? void 0 : _a2.ID);
        },
        onMouseUp: (e3) => {
          var _a2;
          handleMouseUp(e3, socket, Event, (_a2 = data2 == null ? void 0 : data2.typeObj) == null ? void 0 : _a2.ID);
        },
        onMouseEnter: (e3) => {
          var _a2;
          handleMouseEnter(e3, socket, Event, (_a2 = data2 == null ? void 0 : data2.typeObj) == null ? void 0 : _a2.ID);
        },
        onMouseMove: (e3) => {
          var _a2;
          handleMouseMove(e3, socket, Event, (_a2 = data2 == null ? void 0 : data2.typeObj) == null ? void 0 : _a2.ID);
        },
        onMouseLeave: (e3) => {
          var _a2;
          handleMouseLeave(e3, socket, Event, (_a2 = data2 == null ? void 0 : data2.typeObj) == null ? void 0 : _a2.ID);
        },
        onWheel: (e3) => {
          var _a2;
          handleMouseWheel(e3, socket, Event, (_a2 = data2 == null ? void 0 : data2.typeObj) == null ? void 0 : _a2.ID);
        },
        onDoubleClick: (e3) => {
          var _a2;
          handleMouseDoubleClick(e3, socket, Event, (_a2 = data2 == null ? void 0 : data2.typeObj) == null ? void 0 : _a2.ID);
        }
      }
    ) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: !isEditable ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      ref: divRef,
      onDoubleClick: (e3) => {
        setIsEditable(true);
      },
      autoFocus: true,
      onKeyDown: (e3) => console.log({ e: e3 }),
      style: {
        display: "flex",
        align: data2 == null ? void 0 : data2.align,
        backgroundColor: data2 == null ? void 0 : data2.backgroundColor,
        outline: 0,
        height: "100%",
        width: "100%",
        paddingLeft: "5px",
        paddingRight: "5px"
      },
      children: !(data2 == null ? void 0 : data2.formattedValue) ? data2 == null ? void 0 : data2.value : data2 == null ? void 0 : data2.formattedValue
    }
  ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
    "input",
    {
      type: "text",
      id: `${data2 == null ? void 0 : data2.gridId}`,
      ref: inputRef,
      style: {
        outline: 0,
        border: 0,
        width: "100%",
        height: "100%",
        display: "flex",
        backgroundColor: data2 == null ? void 0 : data2.backgroundColor,
        align: data2 == null ? void 0 : data2.align,
        paddingLeft: "5px",
        paddingRight: "5px"
      },
      onSelect: handleSelect,
      onDoubleClick: (e3) => {
        var _a2;
        handleMouseDoubleClick(e3, socket, Event, (_a2 = data2 == null ? void 0 : data2.typeObj) == null ? void 0 : _a2.ID);
        e3.stopPropagation();
      },
      value: inputValue,
      onKeyDown: (e3) => {
        e3.stopPropagation();
        handleKeyPress(e3);
      },
      onChange: (e3) => {
        e3.stopPropagation();
        setInputValue(e3.target.value);
      },
      onBlur: (e3) => {
        setIsEditable(false);
        handleEditEvents();
      },
      autoFocus: true,
      onMouseDown: (e3) => {
        var _a2;
        handleMouseDown(e3, socket, Event, (_a2 = data2 == null ? void 0 : data2.typeObj) == null ? void 0 : _a2.ID);
      },
      onMouseUp: (e3) => {
        var _a2;
        handleMouseUp(e3, socket, Event, (_a2 = data2 == null ? void 0 : data2.typeObj) == null ? void 0 : _a2.ID);
      },
      onMouseEnter: (e3) => {
        var _a2;
        handleMouseEnter(e3, socket, Event, (_a2 = data2 == null ? void 0 : data2.typeObj) == null ? void 0 : _a2.ID);
      },
      onMouseMove: (e3) => {
        var _a2;
        handleMouseMove(e3, socket, Event, (_a2 = data2 == null ? void 0 : data2.typeObj) == null ? void 0 : _a2.ID);
      },
      onMouseLeave: (e3) => {
        var _a2;
        handleMouseLeave(e3, socket, Event, (_a2 = data2 == null ? void 0 : data2.typeObj) == null ? void 0 : _a2.ID);
      },
      onWheel: (e3) => {
        var _a2;
        handleMouseWheel(e3, socket, Event, (_a2 = data2 == null ? void 0 : data2.typeObj) == null ? void 0 : _a2.ID);
      }
    }
  ) });
};
const GridSelect = ({ data: data2 }) => {
  var _a, _b;
  const selectRef = reactExports.useRef(null);
  const { Items } = (_a = data2 == null ? void 0 : data2.typeObj) == null ? void 0 : _a.Properties;
  const [comboInput, setComboInput] = reactExports.useState(data2 == null ? void 0 : data2.value);
  const { findDesiredData, socket, handleData } = useAppData();
  reactExports.useEffect(() => {
    if (data2.focused) {
      selectRef.current.focus();
    }
  }, [data2.focused]);
  const handleCellChangeEvent = (value2) => {
    var _a2;
    const gridEvent = findDesiredData(data2 == null ? void 0 : data2.gridId);
    const values6 = data2 == null ? void 0 : data2.gridValues;
    values6[(data2 == null ? void 0 : data2.row) - 1][data2 == null ? void 0 : data2.column] = value2;
    handleData(
      {
        ID: data2 == null ? void 0 : data2.gridId,
        Properties: {
          ...gridEvent.Properties,
          Values: values6,
          CurCell: [data2 == null ? void 0 : data2.row, (data2 == null ? void 0 : data2.column) + 1]
        }
      },
      "WS"
    );
    const triggerEvent = JSON.stringify({
      Event: {
        EventName: "CellChanged",
        ID: data2 == null ? void 0 : data2.gridId,
        Row: data2 == null ? void 0 : data2.row,
        Col: (data2 == null ? void 0 : data2.column) + 1,
        Value: value2
      }
    });
    const updatedGridValues = JSON.stringify({
      Event: {
        EventName: "CellChanged",
        Values: values6,
        CurCell: [data2 == null ? void 0 : data2.row, (data2 == null ? void 0 : data2.column) + 1]
      }
    });
    localStorage.setItem(data2 == null ? void 0 : data2.gridId, updatedGridValues);
    const exists = (_a2 = data2 == null ? void 0 : data2.gridEvent) == null ? void 0 : _a2.some((item) => item[0] === "CellChanged");
    if (!exists)
      return;
    console.log(triggerEvent);
    socket.send(triggerEvent);
    localStorage.setItem(
      "isChanged",
      JSON.stringify({
        isChange: true,
        value: value2
      })
    );
  };
  const handleSelItemsEvent = (value2) => {
    Items.indexOf(value2);
    handleCellChangeEvent(value2);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "select",
    {
      onKeyDown: (e3) => e3.preventDefault(),
      onClick: (e3) => console.log("click"),
      ref: selectRef,
      value: comboInput,
      style: { border: 0, outline: 0, width: "100%", height: "100%" },
      id: `${(_b = data2 == null ? void 0 : data2.typeObj) == null ? void 0 : _b.ID}`,
      onChange: (e3) => {
        setComboInput(e3.target.value);
        handleSelItemsEvent(e3.target.value);
      },
      children: Items && Items.map((item, i16) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: item, children: item }))
    }
  );
};
const GridButton = ({ data: data2 }) => {
  var _a, _b;
  console.log("GridButton", data2);
  const buttonRef = reactExports.useRef(null);
  const { handleData, socket, findDesiredData } = useAppData();
  const [checkInput, setCheckInput] = reactExports.useState(data2 == null ? void 0 : data2.value);
  const [showInput, setShowInput] = reactExports.useState(data2 == null ? void 0 : data2.showInput);
  const [isFocused, setisFocused] = reactExports.useState(false);
  reactExports.useEffect(() => {
    var _a2;
    if (data2.focused) {
      (_a2 = buttonRef == null ? void 0 : buttonRef.current) == null ? void 0 : _a2.focus();
    }
  }, [data2.focused, showInput]);
  const { Event } = (_a = data2 == null ? void 0 : data2.typeObj) == null ? void 0 : _a.Properties;
  const handleCellChangedEvent = (value2) => {
    const gridEvent = findDesiredData(data2 == null ? void 0 : data2.gridId);
    const values6 = data2 == null ? void 0 : data2.gridValues;
    values6[(data2 == null ? void 0 : data2.row) - 1][data2 == null ? void 0 : data2.column] = value2 ? 1 : 0;
    handleData(
      {
        ID: data2 == null ? void 0 : data2.gridId,
        Properties: {
          ...gridEvent.Properties,
          Values: values6,
          CurCell: [data2 == null ? void 0 : data2.row, (data2 == null ? void 0 : data2.column) + 1]
        }
      },
      "WS"
    );
    const triggerEvent = JSON.stringify({
      Event: {
        EventName: "CellChanged",
        ID: data2 == null ? void 0 : data2.gridId,
        Row: data2 == null ? void 0 : data2.row,
        Col: (data2 == null ? void 0 : data2.column) + 1,
        Value: value2 ? 1 : 0
      }
    });
    const updatedGridValues = JSON.stringify({
      Event: {
        EventName: "CellChanged",
        Values: values6,
        CurCell: [data2 == null ? void 0 : data2.row, (data2 == null ? void 0 : data2.column) + 1]
      }
    });
    const formatCellEvent = JSON.stringify({
      FormatCell: {
        Cell: [data2 == null ? void 0 : data2.row, (data2 == null ? void 0 : data2.column) + 1],
        ID: data2 == null ? void 0 : data2.gridId,
        Value: value2 ? 1 : 0
      }
    });
    localStorage.setItem(data2 == null ? void 0 : data2.gridId, updatedGridValues);
    console.log(triggerEvent);
    const exists = (data2 == null ? void 0 : data2.gridEvent) && (data2 == null ? void 0 : data2.gridEvent.some((item) => item[0] === "CellChanged"));
    if (!exists)
      return;
    if (data2.formatString) {
      socket.send(formatCellEvent);
      console.log(formatCellEvent);
    }
    socket.send(triggerEvent);
    localStorage.setItem(
      "isChanged",
      JSON.stringify({ isChange: true, value: value2 ? 1 : 0 })
    );
  };
  const handleCheckBoxEvent = (value2) => {
    handleCellChangedEvent(value2);
  };
  const fontProperties = (data2 == null ? void 0 : data2.cellFont) && ((_b = data2 == null ? void 0 : data2.cellFont) == null ? void 0 : _b.Properties);
  let fontStyles = {
    fontFamily: fontProperties == null ? void 0 : fontProperties.PName,
    fontSize: !(fontProperties == null ? void 0 : fontProperties.Size) ? "12px" : "12px",
    // fontSize: !fontProperties?.Size ? '11px' : '12px',
    textDecoration: !(fontProperties == null ? void 0 : fontProperties.Underline) ? "none" : (fontProperties == null ? void 0 : fontProperties.Underline) == 1 ? "underline" : "none",
    fontStyle: !(fontProperties == null ? void 0 : fontProperties.Italic) ? "none" : (fontProperties == null ? void 0 : fontProperties.Italic) == 1 ? "italic" : "none",
    fontWeight: !(fontProperties == null ? void 0 : fontProperties.Weight) ? 0 : fontProperties == null ? void 0 : fontProperties.Weight
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: !showInput ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      id: `${data2 == null ? void 0 : data2.gridId}`,
      onDoubleClick: (e3) => {
        setShowInput(true);
        setisFocused(true);
      },
      ref: buttonRef,
      tabIndex: "1",
      style: {
        backgroundColor: data2 == null ? void 0 : data2.backgroundColor,
        ...fontStyles,
        outline: 0,
        paddingRight: "5px"
      },
      children: !(data2 == null ? void 0 : data2.formattedValue) ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          ref: buttonRef,
          id: `${data2 == null ? void 0 : data2.gridId}`,
          type: "checkbox",
          checked: checkInput,
          onChange: (e3) => {
            setCheckInput(e3.target.checked);
            handleCheckBoxEvent(e3.target.checked);
          },
          style: {
            backgroundColor: data2 == null ? void 0 : data2.backgroundColor,
            outline: 0,
            marginTop: "3.5px",
            marginLeft: "5px"
          }
        }
      ) : data2 == null ? void 0 : data2.formattedValue
    }
  ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
    "input",
    {
      ref: buttonRef,
      id: `${data2 == null ? void 0 : data2.gridId}`,
      type: "checkbox",
      checked: checkInput,
      onChange: (e3) => {
        setCheckInput(e3.target.checked);
        handleCheckBoxEvent(e3.target.checked);
      },
      onBlur: () => setShowInput(false),
      style: {
        backgroundColor: data2 == null ? void 0 : data2.backgroundColor,
        outline: 0,
        marginTop: "3.5px",
        marginLeft: "5px"
      },
      onDoubleClick: (e3) => {
        var _a2;
        handleMouseDoubleClick(e3, socket, Event, (_a2 = data2 == null ? void 0 : data2.typeObj) == null ? void 0 : _a2.ID);
      },
      onMouseDown: (e3) => {
        var _a2;
        handleMouseDown(e3, socket, Event, (_a2 = data2 == null ? void 0 : data2.typeObj) == null ? void 0 : _a2.ID);
      },
      onMouseUp: (e3) => {
        var _a2;
        handleMouseUp(e3, socket, Event, (_a2 = data2 == null ? void 0 : data2.typeObj) == null ? void 0 : _a2.ID);
      },
      onMouseEnter: (e3) => {
        var _a2;
        handleMouseEnter(e3, socket, Event, (_a2 = data2 == null ? void 0 : data2.typeObj) == null ? void 0 : _a2.ID);
      },
      onMouseMove: (e3) => {
        var _a2;
        handleMouseMove(e3, socket, Event, (_a2 = data2 == null ? void 0 : data2.typeObj) == null ? void 0 : _a2.ID);
      },
      onMouseLeave: (e3) => {
        var _a2;
        handleMouseLeave(e3, socket, Event, (_a2 = data2 == null ? void 0 : data2.typeObj) == null ? void 0 : _a2.ID);
      },
      onWheel: (e3) => {
        var _a2;
        handleMouseWheel(e3, socket, Event, (_a2 = data2 == null ? void 0 : data2.typeObj) == null ? void 0 : _a2.ID);
      }
    }
  ) });
};
const GridCell = ({ data: data2, keyPress }) => {
  var _a, _b;
  const cellRef = reactExports.useRef(null);
  const [isEditable, setisEditable] = reactExports.useState(false);
  reactExports.useEffect(() => {
    var _a2;
    if (data2.focused) {
      (_a2 = cellRef == null ? void 0 : cellRef.current) == null ? void 0 : _a2.focus();
    }
  }, [data2.focused]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: !isEditable ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      style: {
        backgroundColor: data2 == null ? void 0 : data2.backgroundColor,
        outline: 0,
        // ...fontStyles,
        textAlign: (_b = (_a = data2 == null ? void 0 : data2.typeObj) == null ? void 0 : _a.Properties) == null ? void 0 : _b.Justify,
        paddingRight: "5px"
      },
      onDoubleClick: (e3) => setisEditable(true),
      children: !(data2 == null ? void 0 : data2.formattedValue) ? data2.value : data2 == null ? void 0 : data2.formattedValue
    }
  ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      style: {
        outline: 0,
        display: "flex",
        alignItems: "center",
        justifyContent: data2 == null ? void 0 : data2.align,
        paddingLeft: "5px",
        paddingRight: "5px",
        height: "100%",
        width: "100%",
        textAlign: data2 == null ? void 0 : data2.align,
        backgroundColor: data2 == null ? void 0 : data2.backgroundColor
      },
      onBlur: () => setisEditable(false),
      ref: cellRef,
      id: `${data2 == null ? void 0 : data2.row}-${data2 == null ? void 0 : data2.column}`,
      tabIndex: "0",
      children: data2 == null ? void 0 : data2.value
    }
  ) });
};
var lodash = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
lodash.exports;
(function(module, exports) {
  (function() {
    var undefined$1;
    var VERSION = "4.17.21";
    var LARGE_ARRAY_SIZE = 200;
    var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_MEMOIZE_SIZE = 500;
    var PLACEHOLDER2 = "__lodash_placeholder__";
    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
    var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
    var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    var wrapFlags = [
      ["ary", WRAP_ARY_FLAG],
      ["bind", WRAP_BIND_FLAG],
      ["bindKey", WRAP_BIND_KEY_FLAG],
      ["curry", WRAP_CURRY_FLAG],
      ["curryRight", WRAP_CURRY_RIGHT_FLAG],
      ["flip", WRAP_FLIP_FLAG],
      ["partial", WRAP_PARTIAL_FLAG],
      ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
      ["rearg", WRAP_REARG_FLAG]
    ];
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
    var reTrimStart = /^\s+/;
    var reWhitespace = /\s/;
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
    var reEscapeChar = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "[']", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ];
    var templateCounter = -1;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var deburredLetters = {
      // Latin-1 Supplement block.
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "C",
      "": "c",
      "": "D",
      "": "d",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "N",
      "": "n",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "Y",
      "": "y",
      "": "y",
      "": "Ae",
      "": "ae",
      "": "Th",
      "": "th",
      "": "ss",
      // Latin Extended-A block.
      "": "A",
      "": "A",
      "": "A",
      "": "a",
      "": "a",
      "": "a",
      "": "C",
      "": "C",
      "": "C",
      "": "C",
      "": "c",
      "": "c",
      "": "c",
      "": "c",
      "": "D",
      "": "D",
      "": "d",
      "": "d",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "G",
      "": "G",
      "": "G",
      "": "G",
      "": "g",
      "": "g",
      "": "g",
      "": "g",
      "": "H",
      "": "H",
      "": "h",
      "": "h",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "J",
      "": "j",
      "": "K",
      "": "k",
      "": "k",
      "": "L",
      "": "L",
      "": "L",
      "": "L",
      "": "L",
      "": "l",
      "": "l",
      "": "l",
      "": "l",
      "": "l",
      "": "N",
      "": "N",
      "": "N",
      "": "N",
      "": "n",
      "": "n",
      "": "n",
      "": "n",
      "": "O",
      "": "O",
      "": "O",
      "": "o",
      "": "o",
      "": "o",
      "": "R",
      "": "R",
      "": "R",
      "": "r",
      "": "r",
      "": "r",
      "": "S",
      "": "S",
      "": "S",
      "": "S",
      "": "s",
      "": "s",
      "": "s",
      "": "s",
      "": "T",
      "": "T",
      "": "T",
      "": "t",
      "": "t",
      "": "t",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "W",
      "": "w",
      "": "Y",
      "": "y",
      "": "Y",
      "": "Z",
      "": "Z",
      "": "Z",
      "": "z",
      "": "z",
      "": "z",
      "": "IJ",
      "": "ij",
      "": "Oe",
      "": "oe",
      "": "'n",
      "": "s"
    };
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    };
    var stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    var freeParseFloat = parseFloat, freeParseInt = parseInt;
    var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e3) {
      }
    }();
    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        var value2 = array[index2];
        setter(accumulator, value2, iteratee(value2), array);
      }
      return accumulator;
    }
    function arrayEach(array, iteratee) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (iteratee(array[index2], index2, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEachRight(array, iteratee) {
      var length = array == null ? 0 : array.length;
      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEvery(array, predicate) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (!predicate(array[index2], index2, array)) {
          return false;
        }
      }
      return true;
    }
    function arrayFilter(array, predicate) {
      var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index2 < length) {
        var value2 = array[index2];
        if (predicate(value2, index2, array)) {
          result[resIndex++] = value2;
        }
      }
      return result;
    }
    function arrayIncludes(array, value2) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value2, 0) > -1;
    }
    function arrayIncludesWith(array, value2, comparator) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (comparator(value2, array[index2])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap(array, iteratee) {
      var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index2 < length) {
        result[index2] = iteratee(array[index2], index2, array);
      }
      return result;
    }
    function arrayPush(array, values6) {
      var index2 = -1, length = values6.length, offset2 = array.length;
      while (++index2 < length) {
        array[offset2 + index2] = values6[index2];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index2 = -1, length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[++index2];
      }
      while (++index2 < length) {
        accumulator = iteratee(accumulator, array[index2], index2, array);
      }
      return accumulator;
    }
    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
      var length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }
    function arraySome(array, predicate) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (predicate(array[index2], index2, array)) {
          return true;
        }
      }
      return false;
    }
    var asciiSize = baseProperty("length");
    function asciiToArray(string) {
      return string.split("");
    }
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    function baseFindKey(collection, predicate, eachFunc) {
      var result;
      eachFunc(collection, function(value2, key, collection2) {
        if (predicate(value2, key, collection2)) {
          result = key;
          return false;
        }
      });
      return result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index2-- : ++index2 < length) {
        if (predicate(array[index2], index2, array)) {
          return index2;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value2, fromIndex) {
      return value2 === value2 ? strictIndexOf(array, value2, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    function baseIndexOfWith(array, value2, fromIndex, comparator) {
      var index2 = fromIndex - 1, length = array.length;
      while (++index2 < length) {
        if (comparator(array[index2], value2)) {
          return index2;
        }
      }
      return -1;
    }
    function baseIsNaN(value2) {
      return value2 !== value2;
    }
    function baseMean(array, iteratee) {
      var length = array == null ? 0 : array.length;
      return length ? baseSum(array, iteratee) / length : NAN;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined$1 : object[key];
      };
    }
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? undefined$1 : object[key];
      };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value2, index2, collection2) {
        accumulator = initAccum ? (initAccum = false, value2) : iteratee(accumulator, value2, index2, collection2);
      });
      return accumulator;
    }
    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }
    function baseSum(array, iteratee) {
      var result, index2 = -1, length = array.length;
      while (++index2 < length) {
        var current2 = iteratee(array[index2]);
        if (current2 !== undefined$1) {
          result = result === undefined$1 ? current2 : result + current2;
        }
      }
      return result;
    }
    function baseTimes(n10, iteratee) {
      var index2 = -1, result = Array(n10);
      while (++index2 < n10) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    function baseToPairs(object, props) {
      return arrayMap(props, function(key) {
        return [key, object[key]];
      });
    }
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    function baseUnary(func) {
      return function(value2) {
        return func(value2);
      };
    }
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    function cacheHas(cache2, key) {
      return cache2.has(key);
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      var index2 = -1, length = strSymbols.length;
      while (++index2 < length && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
      }
      return index2;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      var index2 = strSymbols.length;
      while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
      }
      return index2;
    }
    function countHolders(array, placeholder) {
      var length = array.length, result = 0;
      while (length--) {
        if (array[length] === placeholder) {
          ++result;
        }
      }
      return result;
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    function getValue(object, key) {
      return object == null ? undefined$1 : object[key];
    }
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    function iteratorToArray(iterator) {
      var data2, result = [];
      while (!(data2 = iterator.next()).done) {
        result.push(data2.value);
      }
      return result;
    }
    function mapToArray(map3) {
      var index2 = -1, result = Array(map3.size);
      map3.forEach(function(value2, key) {
        result[++index2] = [key, value2];
      });
      return result;
    }
    function overArg(func, transform2) {
      return function(arg) {
        return func(transform2(arg));
      };
    }
    function replaceHolders(array, placeholder) {
      var index2 = -1, length = array.length, resIndex = 0, result = [];
      while (++index2 < length) {
        var value2 = array[index2];
        if (value2 === placeholder || value2 === PLACEHOLDER2) {
          array[index2] = PLACEHOLDER2;
          result[resIndex++] = index2;
        }
      }
      return result;
    }
    function setToArray(set4) {
      var index2 = -1, result = Array(set4.size);
      set4.forEach(function(value2) {
        result[++index2] = value2;
      });
      return result;
    }
    function setToPairs(set4) {
      var index2 = -1, result = Array(set4.size);
      set4.forEach(function(value2) {
        result[++index2] = [value2, value2];
      });
      return result;
    }
    function strictIndexOf(array, value2, fromIndex) {
      var index2 = fromIndex - 1, length = array.length;
      while (++index2 < length) {
        if (array[index2] === value2) {
          return index2;
        }
      }
      return -1;
    }
    function strictLastIndexOf(array, value2, fromIndex) {
      var index2 = fromIndex + 1;
      while (index2--) {
        if (array[index2] === value2) {
          return index2;
        }
      }
      return index2;
    }
    function stringSize(string) {
      return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
    }
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    function trimmedEndIndex(string) {
      var index2 = string.length;
      while (index2-- && reWhitespace.test(string.charAt(index2))) {
      }
      return index2;
    }
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    function unicodeSize(string) {
      var result = reUnicode.lastIndex = 0;
      while (reUnicode.test(string)) {
        ++result;
      }
      return result;
    }
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    var runInContext = function runInContext2(context2) {
      context2 = context2 == null ? root : _2.defaults(root.Object(), context2, _2.pick(root, contextProps));
      var Array2 = context2.Array, Date2 = context2.Date, Error2 = context2.Error, Function2 = context2.Function, Math2 = context2.Math, Object2 = context2.Object, RegExp2 = context2.RegExp, String2 = context2.String, TypeError2 = context2.TypeError;
      var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
      var coreJsData = context2["__core-js_shared__"];
      var funcToString = funcProto.toString;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      var idCounter = 0;
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      var nativeObjectToString = objectProto.toString;
      var objectCtorString = funcToString.call(Object2);
      var oldDash = root._;
      var reIsNative = RegExp2(
        "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      var Buffer = moduleExports ? context2.Buffer : undefined$1, Symbol2 = context2.Symbol, Uint8Array2 = context2.Uint8Array, allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined$1, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice2 = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined$1, symIterator = Symbol2 ? Symbol2.iterator : undefined$1, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined$1;
      var defineProperty = function() {
        try {
          var func = getNative(Object2, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e3) {
        }
      }();
      var ctxClearTimeout = context2.clearTimeout !== root.clearTimeout && context2.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context2.setTimeout !== root.setTimeout && context2.setTimeout;
      var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined$1, nativeIsFinite = context2.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context2.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
      var DataView = getNative(context2, "DataView"), Map2 = getNative(context2, "Map"), Promise2 = getNative(context2, "Promise"), Set2 = getNative(context2, "Set"), WeakMap2 = getNative(context2, "WeakMap"), nativeCreate = getNative(Object2, "create");
      var metaMap = WeakMap2 && new WeakMap2();
      var realNames = {};
      var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
      var symbolProto = Symbol2 ? Symbol2.prototype : undefined$1, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1, symbolToString = symbolProto ? symbolProto.toString : undefined$1;
      function lodash2(value2) {
        if (isObjectLike(value2) && !isArray2(value2) && !(value2 instanceof LazyWrapper)) {
          if (value2 instanceof LodashWrapper) {
            return value2;
          }
          if (hasOwnProperty2.call(value2, "__wrapped__")) {
            return wrapperClone(value2);
          }
        }
        return new LodashWrapper(value2);
      }
      var baseCreate = function() {
        function object() {
        }
        return function(proto) {
          if (!isObject2(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object.prototype = proto;
          var result2 = new object();
          object.prototype = undefined$1;
          return result2;
        };
      }();
      function baseLodash() {
      }
      function LodashWrapper(value2, chainAll) {
        this.__wrapped__ = value2;
        this.__actions__ = [];
        this.__chain__ = !!chainAll;
        this.__index__ = 0;
        this.__values__ = undefined$1;
      }
      lodash2.templateSettings = {
        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        "escape": reEscape,
        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        "evaluate": reEvaluate,
        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        "interpolate": reInterpolate,
        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        "variable": "",
        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        "imports": {
          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          "_": lodash2
        }
      };
      lodash2.prototype = baseLodash.prototype;
      lodash2.prototype.constructor = lodash2;
      LodashWrapper.prototype = baseCreate(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;
      function LazyWrapper(value2) {
        this.__wrapped__ = value2;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = MAX_ARRAY_LENGTH;
        this.__views__ = [];
      }
      function lazyClone() {
        var result2 = new LazyWrapper(this.__wrapped__);
        result2.__actions__ = copyArray(this.__actions__);
        result2.__dir__ = this.__dir__;
        result2.__filtered__ = this.__filtered__;
        result2.__iteratees__ = copyArray(this.__iteratees__);
        result2.__takeCount__ = this.__takeCount__;
        result2.__views__ = copyArray(this.__views__);
        return result2;
      }
      function lazyReverse() {
        if (this.__filtered__) {
          var result2 = new LazyWrapper(this);
          result2.__dir__ = -1;
          result2.__filtered__ = true;
        } else {
          result2 = this.clone();
          result2.__dir__ *= -1;
        }
        return result2;
      }
      function lazyValue() {
        var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index2 = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length && takeCount == length) {
          return baseWrapperValue(array, this.__actions__);
        }
        var result2 = [];
        outer:
          while (length-- && resIndex < takeCount) {
            index2 += dir;
            var iterIndex = -1, value2 = array[index2];
            while (++iterIndex < iterLength) {
              var data2 = iteratees[iterIndex], iteratee2 = data2.iteratee, type = data2.type, computed = iteratee2(value2);
              if (type == LAZY_MAP_FLAG) {
                value2 = computed;
              } else if (!computed) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result2[resIndex++] = value2;
          }
        return result2;
      }
      LazyWrapper.prototype = baseCreate(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;
      function Hash(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result2 = this.has(key) && delete this.__data__[key];
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function hashGet(key) {
        var data2 = this.__data__;
        if (nativeCreate) {
          var result2 = data2[key];
          return result2 === HASH_UNDEFINED ? undefined$1 : result2;
        }
        return hasOwnProperty2.call(data2, key) ? data2[key] : undefined$1;
      }
      function hashHas(key) {
        var data2 = this.__data__;
        return nativeCreate ? data2[key] !== undefined$1 : hasOwnProperty2.call(data2, key);
      }
      function hashSet(key, value2) {
        var data2 = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data2[key] = nativeCreate && value2 === undefined$1 ? HASH_UNDEFINED : value2;
        return this;
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function listCacheDelete(key) {
        var data2 = this.__data__, index2 = assocIndexOf(data2, key);
        if (index2 < 0) {
          return false;
        }
        var lastIndex = data2.length - 1;
        if (index2 == lastIndex) {
          data2.pop();
        } else {
          splice2.call(data2, index2, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data2 = this.__data__, index2 = assocIndexOf(data2, key);
        return index2 < 0 ? undefined$1 : data2[index2][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value2) {
        var data2 = this.__data__, index2 = assocIndexOf(data2, key);
        if (index2 < 0) {
          ++this.size;
          data2.push([key, value2]);
        } else {
          data2[index2][1] = value2;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map2 || ListCache)(),
          "string": new Hash()
        };
      }
      function mapCacheDelete(key) {
        var result2 = getMapData(this, key)["delete"](key);
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value2) {
        var data2 = getMapData(this, key), size2 = data2.size;
        data2.set(key, value2);
        this.size += data2.size == size2 ? 0 : 1;
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function SetCache(values7) {
        var index2 = -1, length = values7 == null ? 0 : values7.length;
        this.__data__ = new MapCache();
        while (++index2 < length) {
          this.add(values7[index2]);
        }
      }
      function setCacheAdd(value2) {
        this.__data__.set(value2, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value2) {
        return this.__data__.has(value2);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack(entries) {
        var data2 = this.__data__ = new ListCache(entries);
        this.size = data2.size;
      }
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      function stackDelete(key) {
        var data2 = this.__data__, result2 = data2["delete"](key);
        this.size = data2.size;
        return result2;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      function stackSet(key, value2) {
        var data2 = this.__data__;
        if (data2 instanceof ListCache) {
          var pairs = data2.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value2]);
            this.size = ++data2.size;
            return this;
          }
          data2 = this.__data__ = new MapCache(pairs);
        }
        data2.set(key, value2);
        this.size = data2.size;
        return this;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function arrayLikeKeys(value2, inherited) {
        var isArr = isArray2(value2), isArg = !isArr && isArguments(value2), isBuff = !isArr && !isArg && isBuffer(value2), isType = !isArr && !isArg && !isBuff && isTypedArray(value2), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value2.length, String2) : [], length = result2.length;
        for (var key in value2) {
          if ((inherited || hasOwnProperty2.call(value2, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
          isIndex(key, length)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function arraySample(array) {
        var length = array.length;
        return length ? array[baseRandom(0, length - 1)] : undefined$1;
      }
      function arraySampleSize(array, n10) {
        return shuffleSelf(copyArray(array), baseClamp(n10, 0, array.length));
      }
      function arrayShuffle(array) {
        return shuffleSelf(copyArray(array));
      }
      function assignMergeValue(object, key, value2) {
        if (value2 !== undefined$1 && !eq(object[key], value2) || value2 === undefined$1 && !(key in object)) {
          baseAssignValue(object, key, value2);
        }
      }
      function assignValue(object, key, value2) {
        var objValue = object[key];
        if (!(hasOwnProperty2.call(object, key) && eq(objValue, value2)) || value2 === undefined$1 && !(key in object)) {
          baseAssignValue(object, key, value2);
        }
      }
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      function baseAggregator(collection, setter, iteratee2, accumulator) {
        baseEach(collection, function(value2, key, collection2) {
          setter(accumulator, value2, iteratee2(value2), collection2);
        });
        return accumulator;
      }
      function baseAssign(object, source) {
        return object && copyObject(source, keys2(source), object);
      }
      function baseAssignIn(object, source) {
        return object && copyObject(source, keysIn(source), object);
      }
      function baseAssignValue(object, key, value2) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object, key, {
            "configurable": true,
            "enumerable": true,
            "value": value2,
            "writable": true
          });
        } else {
          object[key] = value2;
        }
      }
      function baseAt(object, paths) {
        var index2 = -1, length = paths.length, result2 = Array2(length), skip = object == null;
        while (++index2 < length) {
          result2[index2] = skip ? undefined$1 : get3(object, paths[index2]);
        }
        return result2;
      }
      function baseClamp(number, lower, upper) {
        if (number === number) {
          if (upper !== undefined$1) {
            number = number <= upper ? number : upper;
          }
          if (lower !== undefined$1) {
            number = number >= lower ? number : lower;
          }
        }
        return number;
      }
      function baseClone(value2, bitmask, customizer, key, object, stack) {
        var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result2 = object ? customizer(value2, key, object, stack) : customizer(value2);
        }
        if (result2 !== undefined$1) {
          return result2;
        }
        if (!isObject2(value2)) {
          return value2;
        }
        var isArr = isArray2(value2);
        if (isArr) {
          result2 = initCloneArray(value2);
          if (!isDeep) {
            return copyArray(value2, result2);
          }
        } else {
          var tag = getTag(value2), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer(value2)) {
            return cloneBuffer(value2, isDeep);
          }
          if (tag == objectTag || tag == argsTag || isFunc && !object) {
            result2 = isFlat || isFunc ? {} : initCloneObject(value2);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value2, baseAssignIn(result2, value2)) : copySymbols(value2, baseAssign(result2, value2));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object ? value2 : {};
            }
            result2 = initCloneByTag(value2, tag, isDeep);
          }
        }
        stack || (stack = new Stack());
        var stacked = stack.get(value2);
        if (stacked) {
          return stacked;
        }
        stack.set(value2, result2);
        if (isSet(value2)) {
          value2.forEach(function(subValue) {
            result2.add(baseClone(subValue, bitmask, customizer, subValue, value2, stack));
          });
        } else if (isMap(value2)) {
          value2.forEach(function(subValue, key2) {
            result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value2, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys2;
        var props = isArr ? undefined$1 : keysFunc(value2);
        arrayEach(props || value2, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value2[key2];
          }
          assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value2, stack));
        });
        return result2;
      }
      function baseConforms(source) {
        var props = keys2(source);
        return function(object) {
          return baseConformsTo(object, source, props);
        };
      }
      function baseConformsTo(object, source, props) {
        var length = props.length;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (length--) {
          var key = props[length], predicate = source[key], value2 = object[key];
          if (value2 === undefined$1 && !(key in object) || !predicate(value2)) {
            return false;
          }
        }
        return true;
      }
      function baseDelay(func, wait, args) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return setTimeout2(function() {
          func.apply(undefined$1, args);
        }, wait);
      }
      function baseDifference(array, values7, iteratee2, comparator) {
        var index2 = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values7.length;
        if (!length) {
          return result2;
        }
        if (iteratee2) {
          values7 = arrayMap(values7, baseUnary(iteratee2));
        }
        if (comparator) {
          includes2 = arrayIncludesWith;
          isCommon = false;
        } else if (values7.length >= LARGE_ARRAY_SIZE) {
          includes2 = cacheHas;
          isCommon = false;
          values7 = new SetCache(values7);
        }
        outer:
          while (++index2 < length) {
            var value2 = array[index2], computed = iteratee2 == null ? value2 : iteratee2(value2);
            value2 = comparator || value2 !== 0 ? value2 : 0;
            if (isCommon && computed === computed) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values7[valuesIndex] === computed) {
                  continue outer;
                }
              }
              result2.push(value2);
            } else if (!includes2(values7, computed, comparator)) {
              result2.push(value2);
            }
          }
        return result2;
      }
      var baseEach = createBaseEach(baseForOwn);
      var baseEachRight = createBaseEach(baseForOwnRight, true);
      function baseEvery(collection, predicate) {
        var result2 = true;
        baseEach(collection, function(value2, index2, collection2) {
          result2 = !!predicate(value2, index2, collection2);
          return result2;
        });
        return result2;
      }
      function baseExtremum(array, iteratee2, comparator) {
        var index2 = -1, length = array.length;
        while (++index2 < length) {
          var value2 = array[index2], current2 = iteratee2(value2);
          if (current2 != null && (computed === undefined$1 ? current2 === current2 && !isSymbol(current2) : comparator(current2, computed))) {
            var computed = current2, result2 = value2;
          }
        }
        return result2;
      }
      function baseFill(array, value2, start, end) {
        var length = array.length;
        start = toInteger(start);
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end === undefined$1 || end > length ? length : toInteger(end);
        if (end < 0) {
          end += length;
        }
        end = start > end ? 0 : toLength(end);
        while (start < end) {
          array[start++] = value2;
        }
        return array;
      }
      function baseFilter(collection, predicate) {
        var result2 = [];
        baseEach(collection, function(value2, index2, collection2) {
          if (predicate(value2, index2, collection2)) {
            result2.push(value2);
          }
        });
        return result2;
      }
      function baseFlatten(array, depth, predicate, isStrict, result2) {
        var index2 = -1, length = array.length;
        predicate || (predicate = isFlattenable);
        result2 || (result2 = []);
        while (++index2 < length) {
          var value2 = array[index2];
          if (depth > 0 && predicate(value2)) {
            if (depth > 1) {
              baseFlatten(value2, depth - 1, predicate, isStrict, result2);
            } else {
              arrayPush(result2, value2);
            }
          } else if (!isStrict) {
            result2[result2.length] = value2;
          }
        }
        return result2;
      }
      var baseFor = createBaseFor();
      var baseForRight = createBaseFor(true);
      function baseForOwn(object, iteratee2) {
        return object && baseFor(object, iteratee2, keys2);
      }
      function baseForOwnRight(object, iteratee2) {
        return object && baseForRight(object, iteratee2, keys2);
      }
      function baseFunctions(object, props) {
        return arrayFilter(props, function(key) {
          return isFunction2(object[key]);
        });
      }
      function baseGet(object, path) {
        path = castPath(path, object);
        var index2 = 0, length = path.length;
        while (object != null && index2 < length) {
          object = object[toKey(path[index2++])];
        }
        return index2 && index2 == length ? object : undefined$1;
      }
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result2 = keysFunc(object);
        return isArray2(object) ? result2 : arrayPush(result2, symbolsFunc(object));
      }
      function baseGetTag(value2) {
        if (value2 == null) {
          return value2 === undefined$1 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object2(value2) ? getRawTag(value2) : objectToString(value2);
      }
      function baseGt(value2, other) {
        return value2 > other;
      }
      function baseHas(object, key) {
        return object != null && hasOwnProperty2.call(object, key);
      }
      function baseHasIn(object, key) {
        return object != null && key in Object2(object);
      }
      function baseInRange(number, start, end) {
        return number >= nativeMin(start, end) && number < nativeMax(start, end);
      }
      function baseIntersection(arrays, iteratee2, comparator) {
        var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
        while (othIndex--) {
          var array = arrays[othIndex];
          if (othIndex && iteratee2) {
            array = arrayMap(array, baseUnary(iteratee2));
          }
          maxLength = nativeMin(array.length, maxLength);
          caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined$1;
        }
        array = arrays[0];
        var index2 = -1, seen = caches[0];
        outer:
          while (++index2 < length && result2.length < maxLength) {
            var value2 = array[index2], computed = iteratee2 ? iteratee2(value2) : value2;
            value2 = comparator || value2 !== 0 ? value2 : 0;
            if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache2 = caches[othIndex];
                if (!(cache2 ? cacheHas(cache2, computed) : includes2(arrays[othIndex], computed, comparator))) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(computed);
              }
              result2.push(value2);
            }
          }
        return result2;
      }
      function baseInverter(object, setter, iteratee2, accumulator) {
        baseForOwn(object, function(value2, key, object2) {
          setter(accumulator, iteratee2(value2), key, object2);
        });
        return accumulator;
      }
      function baseInvoke(object, path, args) {
        path = castPath(path, object);
        object = parent(object, path);
        var func = object == null ? object : object[toKey(last2(path))];
        return func == null ? undefined$1 : apply(func, object, args);
      }
      function baseIsArguments(value2) {
        return isObjectLike(value2) && baseGetTag(value2) == argsTag;
      }
      function baseIsArrayBuffer(value2) {
        return isObjectLike(value2) && baseGetTag(value2) == arrayBufferTag;
      }
      function baseIsDate(value2) {
        return isObjectLike(value2) && baseGetTag(value2) == dateTag;
      }
      function baseIsEqual(value2, other, bitmask, customizer, stack) {
        if (value2 === other) {
          return true;
        }
        if (value2 == null || other == null || !isObjectLike(value2) && !isObjectLike(other)) {
          return value2 !== value2 && other !== other;
        }
        return baseIsEqualDeep(value2, other, bitmask, customizer, baseIsEqual, stack);
      }
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack());
          return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack());
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
      }
      function baseIsMap(value2) {
        return isObjectLike(value2) && getTag(value2) == mapTag;
      }
      function baseIsMatch(object, source, matchData, customizer) {
        var index2 = matchData.length, length = index2, noCustomizer = !customizer;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (index2--) {
          var data2 = matchData[index2];
          if (noCustomizer && data2[2] ? data2[1] !== object[data2[0]] : !(data2[0] in object)) {
            return false;
          }
        }
        while (++index2 < length) {
          data2 = matchData[index2];
          var key = data2[0], objValue = object[key], srcValue = data2[1];
          if (noCustomizer && data2[2]) {
            if (objValue === undefined$1 && !(key in object)) {
              return false;
            }
          } else {
            var stack = new Stack();
            if (customizer) {
              var result2 = customizer(objValue, srcValue, key, object, source, stack);
            }
            if (!(result2 === undefined$1 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
              return false;
            }
          }
        }
        return true;
      }
      function baseIsNative(value2) {
        if (!isObject2(value2) || isMasked(value2)) {
          return false;
        }
        var pattern = isFunction2(value2) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value2));
      }
      function baseIsRegExp(value2) {
        return isObjectLike(value2) && baseGetTag(value2) == regexpTag;
      }
      function baseIsSet(value2) {
        return isObjectLike(value2) && getTag(value2) == setTag;
      }
      function baseIsTypedArray(value2) {
        return isObjectLike(value2) && isLength(value2.length) && !!typedArrayTags[baseGetTag(value2)];
      }
      function baseIteratee(value2) {
        if (typeof value2 == "function") {
          return value2;
        }
        if (value2 == null) {
          return identity;
        }
        if (typeof value2 == "object") {
          return isArray2(value2) ? baseMatchesProperty(value2[0], value2[1]) : baseMatches(value2);
        }
        return property(value2);
      }
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result2 = [];
        for (var key in Object2(object)) {
          if (hasOwnProperty2.call(object, key) && key != "constructor") {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseKeysIn(object) {
        if (!isObject2(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result2 = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseLt(value2, other) {
        return value2 < other;
      }
      function baseMap(collection, iteratee2) {
        var index2 = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value2, key, collection2) {
          result2[++index2] = iteratee2(value2, key, collection2);
        });
        return result2;
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object) {
          var objValue = get3(object, path);
          return objValue === undefined$1 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseMerge(object, source, srcIndex, customizer, stack) {
        if (object === source) {
          return;
        }
        baseFor(source, function(srcValue, key) {
          stack || (stack = new Stack());
          if (isObject2(srcValue)) {
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined$1;
            if (newValue === undefined$1) {
              newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
          }
        }, keysIn);
      }
      function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined$1;
        var isCommon = newValue === undefined$1;
        if (isCommon) {
          var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray2(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject2(objValue) || isFunction2(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object, key, newValue);
      }
      function baseNth(array, n10) {
        var length = array.length;
        if (!length) {
          return;
        }
        n10 += n10 < 0 ? length : 0;
        return isIndex(n10, length) ? array[n10] : undefined$1;
      }
      function baseOrderBy(collection, iteratees, orders) {
        if (iteratees.length) {
          iteratees = arrayMap(iteratees, function(iteratee2) {
            if (isArray2(iteratee2)) {
              return function(value2) {
                return baseGet(value2, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
              };
            }
            return iteratee2;
          });
        } else {
          iteratees = [identity];
        }
        var index2 = -1;
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        var result2 = baseMap(collection, function(value2, key, collection2) {
          var criteria = arrayMap(iteratees, function(iteratee2) {
            return iteratee2(value2);
          });
          return { "criteria": criteria, "index": ++index2, "value": value2 };
        });
        return baseSortBy(result2, function(object, other) {
          return compareMultiple(object, other, orders);
        });
      }
      function basePick(object, paths) {
        return basePickBy(object, paths, function(value2, path) {
          return hasIn(object, path);
        });
      }
      function basePickBy(object, paths, predicate) {
        var index2 = -1, length = paths.length, result2 = {};
        while (++index2 < length) {
          var path = paths[index2], value2 = baseGet(object, path);
          if (predicate(value2, path)) {
            baseSet(result2, castPath(path, object), value2);
          }
        }
        return result2;
      }
      function basePropertyDeep(path) {
        return function(object) {
          return baseGet(object, path);
        };
      }
      function basePullAll(array, values7, iteratee2, comparator) {
        var indexOf3 = comparator ? baseIndexOfWith : baseIndexOf, index2 = -1, length = values7.length, seen = array;
        if (array === values7) {
          values7 = copyArray(values7);
        }
        if (iteratee2) {
          seen = arrayMap(array, baseUnary(iteratee2));
        }
        while (++index2 < length) {
          var fromIndex = 0, value2 = values7[index2], computed = iteratee2 ? iteratee2(value2) : value2;
          while ((fromIndex = indexOf3(seen, computed, fromIndex, comparator)) > -1) {
            if (seen !== array) {
              splice2.call(seen, fromIndex, 1);
            }
            splice2.call(array, fromIndex, 1);
          }
        }
        return array;
      }
      function basePullAt(array, indexes) {
        var length = array ? indexes.length : 0, lastIndex = length - 1;
        while (length--) {
          var index2 = indexes[length];
          if (length == lastIndex || index2 !== previous) {
            var previous = index2;
            if (isIndex(index2)) {
              splice2.call(array, index2, 1);
            } else {
              baseUnset(array, index2);
            }
          }
        }
        return array;
      }
      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
      }
      function baseRange(start, end, step, fromRight) {
        var index2 = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
        while (length--) {
          result2[fromRight ? length : ++index2] = start;
          start += step;
        }
        return result2;
      }
      function baseRepeat(string, n10) {
        var result2 = "";
        if (!string || n10 < 1 || n10 > MAX_SAFE_INTEGER) {
          return result2;
        }
        do {
          if (n10 % 2) {
            result2 += string;
          }
          n10 = nativeFloor(n10 / 2);
          if (n10) {
            string += string;
          }
        } while (n10);
        return result2;
      }
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity), func + "");
      }
      function baseSample(collection) {
        return arraySample(values6(collection));
      }
      function baseSampleSize(collection, n10) {
        var array = values6(collection);
        return shuffleSelf(array, baseClamp(n10, 0, array.length));
      }
      function baseSet(object, path, value2, customizer) {
        if (!isObject2(object)) {
          return object;
        }
        path = castPath(path, object);
        var index2 = -1, length = path.length, lastIndex = length - 1, nested = object;
        while (nested != null && ++index2 < length) {
          var key = toKey(path[index2]), newValue = value2;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object;
          }
          if (index2 != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
            if (newValue === undefined$1) {
              newValue = isObject2(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object;
      }
      var baseSetData = !metaMap ? identity : function(func, data2) {
        metaMap.set(func, data2);
        return func;
      };
      var baseSetToString = !defineProperty ? identity : function(func, string) {
        return defineProperty(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant(string),
          "writable": true
        });
      };
      function baseShuffle(collection) {
        return shuffleSelf(values6(collection));
      }
      function baseSlice(array, start, end) {
        var index2 = -1, length = array.length;
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : end - start >>> 0;
        start >>>= 0;
        var result2 = Array2(length);
        while (++index2 < length) {
          result2[index2] = array[index2 + start];
        }
        return result2;
      }
      function baseSome(collection, predicate) {
        var result2;
        baseEach(collection, function(value2, index2, collection2) {
          result2 = predicate(value2, index2, collection2);
          return !result2;
        });
        return !!result2;
      }
      function baseSortedIndex(array, value2, retHighest) {
        var low = 0, high = array == null ? low : array.length;
        if (typeof value2 == "number" && value2 === value2 && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid = low + high >>> 1, computed = array[mid];
            if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value2 : computed < value2)) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return high;
        }
        return baseSortedIndexBy(array, value2, identity, retHighest);
      }
      function baseSortedIndexBy(array, value2, iteratee2, retHighest) {
        var low = 0, high = array == null ? 0 : array.length;
        if (high === 0) {
          return 0;
        }
        value2 = iteratee2(value2);
        var valIsNaN = value2 !== value2, valIsNull = value2 === null, valIsSymbol = isSymbol(value2), valIsUndefined = value2 === undefined$1;
        while (low < high) {
          var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined$1, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
          if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = retHighest ? computed <= value2 : computed < value2;
          }
          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return nativeMin(high, MAX_ARRAY_INDEX);
      }
      function baseSortedUniq(array, iteratee2) {
        var index2 = -1, length = array.length, resIndex = 0, result2 = [];
        while (++index2 < length) {
          var value2 = array[index2], computed = iteratee2 ? iteratee2(value2) : value2;
          if (!index2 || !eq(computed, seen)) {
            var seen = computed;
            result2[resIndex++] = value2 === 0 ? 0 : value2;
          }
        }
        return result2;
      }
      function baseToNumber(value2) {
        if (typeof value2 == "number") {
          return value2;
        }
        if (isSymbol(value2)) {
          return NAN;
        }
        return +value2;
      }
      function baseToString(value2) {
        if (typeof value2 == "string") {
          return value2;
        }
        if (isArray2(value2)) {
          return arrayMap(value2, baseToString) + "";
        }
        if (isSymbol(value2)) {
          return symbolToString ? symbolToString.call(value2) : "";
        }
        var result2 = value2 + "";
        return result2 == "0" && 1 / value2 == -INFINITY ? "-0" : result2;
      }
      function baseUniq(array, iteratee2, comparator) {
        var index2 = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
        if (comparator) {
          isCommon = false;
          includes2 = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE) {
          var set5 = iteratee2 ? null : createSet(array);
          if (set5) {
            return setToArray(set5);
          }
          isCommon = false;
          includes2 = cacheHas;
          seen = new SetCache();
        } else {
          seen = iteratee2 ? [] : result2;
        }
        outer:
          while (++index2 < length) {
            var value2 = array[index2], computed = iteratee2 ? iteratee2(value2) : value2;
            value2 = comparator || value2 !== 0 ? value2 : 0;
            if (isCommon && computed === computed) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee2) {
                seen.push(computed);
              }
              result2.push(value2);
            } else if (!includes2(seen, computed, comparator)) {
              if (seen !== result2) {
                seen.push(computed);
              }
              result2.push(value2);
            }
          }
        return result2;
      }
      function baseUnset(object, path) {
        path = castPath(path, object);
        object = parent(object, path);
        return object == null || delete object[toKey(last2(path))];
      }
      function baseUpdate(object, path, updater, customizer) {
        return baseSet(object, path, updater(baseGet(object, path)), customizer);
      }
      function baseWhile(array, predicate, isDrop, fromRight) {
        var length = array.length, index2 = fromRight ? length : -1;
        while ((fromRight ? index2-- : ++index2 < length) && predicate(array[index2], index2, array)) {
        }
        return isDrop ? baseSlice(array, fromRight ? 0 : index2, fromRight ? index2 + 1 : length) : baseSlice(array, fromRight ? index2 + 1 : 0, fromRight ? length : index2);
      }
      function baseWrapperValue(value2, actions) {
        var result2 = value2;
        if (result2 instanceof LazyWrapper) {
          result2 = result2.value();
        }
        return arrayReduce(actions, function(result3, action) {
          return action.func.apply(action.thisArg, arrayPush([result3], action.args));
        }, result2);
      }
      function baseXor(arrays, iteratee2, comparator) {
        var length = arrays.length;
        if (length < 2) {
          return length ? baseUniq(arrays[0]) : [];
        }
        var index2 = -1, result2 = Array2(length);
        while (++index2 < length) {
          var array = arrays[index2], othIndex = -1;
          while (++othIndex < length) {
            if (othIndex != index2) {
              result2[index2] = baseDifference(result2[index2] || array, arrays[othIndex], iteratee2, comparator);
            }
          }
        }
        return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
      }
      function baseZipObject(props, values7, assignFunc) {
        var index2 = -1, length = props.length, valsLength = values7.length, result2 = {};
        while (++index2 < length) {
          var value2 = index2 < valsLength ? values7[index2] : undefined$1;
          assignFunc(result2, props[index2], value2);
        }
        return result2;
      }
      function castArrayLikeObject(value2) {
        return isArrayLikeObject(value2) ? value2 : [];
      }
      function castFunction(value2) {
        return typeof value2 == "function" ? value2 : identity;
      }
      function castPath(value2, object) {
        if (isArray2(value2)) {
          return value2;
        }
        return isKey(value2, object) ? [value2] : stringToPath(toString2(value2));
      }
      var castRest = baseRest;
      function castSlice(array, start, end) {
        var length = array.length;
        end = end === undefined$1 ? length : end;
        return !start && end >= length ? array : baseSlice(array, start, end);
      }
      var clearTimeout2 = ctxClearTimeout || function(id2) {
        return root.clearTimeout(id2);
      };
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result2);
        return result2;
      }
      function cloneArrayBuffer(arrayBuffer) {
        var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
        return result2;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      function cloneRegExp(regexp) {
        var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result2.lastIndex = regexp.lastIndex;
        return result2;
      }
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      function compareAscending(value2, other) {
        if (value2 !== other) {
          var valIsDefined = value2 !== undefined$1, valIsNull = value2 === null, valIsReflexive = value2 === value2, valIsSymbol = isSymbol(value2);
          var othIsDefined = other !== undefined$1, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value2 > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value2 < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      function compareMultiple(object, other, orders) {
        var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
        while (++index2 < length) {
          var result2 = compareAscending(objCriteria[index2], othCriteria[index2]);
          if (result2) {
            if (index2 >= ordersLength) {
              return result2;
            }
            var order = orders[index2];
            return result2 * (order == "desc" ? -1 : 1);
          }
        }
        return object.index - other.index;
      }
      function composeArgs(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
        while (++leftIndex < leftLength) {
          result2[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[holders[argsIndex]] = args[argsIndex];
          }
        }
        while (rangeLength--) {
          result2[leftIndex++] = args[argsIndex++];
        }
        return result2;
      }
      function composeArgsRight(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
        while (++argsIndex < rangeLength) {
          result2[argsIndex] = args[argsIndex];
        }
        var offset2 = argsIndex;
        while (++rightIndex < rightLength) {
          result2[offset2 + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[offset2 + holders[holdersIndex]] = args[argsIndex++];
          }
        }
        return result2;
      }
      function copyArray(source, array) {
        var index2 = -1, length = source.length;
        array || (array = Array2(length));
        while (++index2 < length) {
          array[index2] = source[index2];
        }
        return array;
      }
      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index2 = -1, length = props.length;
        while (++index2 < length) {
          var key = props[index2];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined$1;
          if (newValue === undefined$1) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }
        return object;
      }
      function copySymbols(source, object) {
        return copyObject(source, getSymbols(source), object);
      }
      function copySymbolsIn(source, object) {
        return copyObject(source, getSymbolsIn(source), object);
      }
      function createAggregator(setter, initializer) {
        return function(collection, iteratee2) {
          var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
        };
      }
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined$1, guard = length > 2 ? sources[2] : undefined$1;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined$1;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined$1 : customizer;
            length = 1;
          }
          object = Object2(object);
          while (++index2 < length) {
            var source = sources[index2];
            if (source) {
              assigner(object, source, index2, customizer);
            }
          }
          return object;
        });
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee2) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee2);
          }
          var length = collection.length, index2 = fromRight ? length : -1, iterable = Object2(collection);
          while (fromRight ? index2-- : ++index2 < length) {
            if (iteratee2(iterable[index2], index2, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      function createBaseFor(fromRight) {
        return function(object, iteratee2, keysFunc) {
          var index2 = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index2];
            if (iteratee2(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      function createBind(func, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper2() {
          var fn = this && this !== root && this instanceof wrapper2 ? Ctor : func;
          return fn.apply(isBind ? thisArg : this, arguments);
        }
        return wrapper2;
      }
      function createCaseFirst(methodName) {
        return function(string) {
          string = toString2(string);
          var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined$1;
          var chr = strSymbols ? strSymbols[0] : string.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function(string) {
          return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
        };
      }
      function createCtor(Ctor) {
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return new Ctor();
            case 1:
              return new Ctor(args[0]);
            case 2:
              return new Ctor(args[0], args[1]);
            case 3:
              return new Ctor(args[0], args[1], args[2]);
            case 4:
              return new Ctor(args[0], args[1], args[2], args[3]);
            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
          return isObject2(result2) ? result2 : thisBinding;
        };
      }
      function createCurry(func, bitmask, arity) {
        var Ctor = createCtor(func);
        function wrapper2() {
          var length = arguments.length, args = Array2(length), index2 = length, placeholder = getHolder(wrapper2);
          while (index2--) {
            args[index2] = arguments[index2];
          }
          var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
          length -= holders.length;
          if (length < arity) {
            return createRecurry(
              func,
              bitmask,
              createHybrid,
              wrapper2.placeholder,
              undefined$1,
              args,
              holders,
              undefined$1,
              undefined$1,
              arity - length
            );
          }
          var fn = this && this !== root && this instanceof wrapper2 ? Ctor : func;
          return apply(fn, this, args);
        }
        return wrapper2;
      }
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object2(collection);
          if (!isArrayLike(collection)) {
            var iteratee2 = getIteratee(predicate, 3);
            collection = keys2(collection);
            predicate = function(key) {
              return iteratee2(iterable[key], key, iterable);
            };
          }
          var index2 = findIndexFunc(collection, predicate, fromIndex);
          return index2 > -1 ? iterable[iteratee2 ? collection[index2] : index2] : undefined$1;
        };
      }
      function createFlow(fromRight) {
        return flatRest(function(funcs) {
          var length = funcs.length, index2 = length, prereq = LodashWrapper.prototype.thru;
          if (fromRight) {
            funcs.reverse();
          }
          while (index2--) {
            var func = funcs[index2];
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (prereq && !wrapper2 && getFuncName(func) == "wrapper") {
              var wrapper2 = new LodashWrapper([], true);
            }
          }
          index2 = wrapper2 ? index2 : length;
          while (++index2 < length) {
            func = funcs[index2];
            var funcName = getFuncName(func), data2 = funcName == "wrapper" ? getData2(func) : undefined$1;
            if (data2 && isLaziable(data2[0]) && data2[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data2[4].length && data2[9] == 1) {
              wrapper2 = wrapper2[getFuncName(data2[0])].apply(wrapper2, data2[3]);
            } else {
              wrapper2 = func.length == 1 && isLaziable(func) ? wrapper2[funcName]() : wrapper2.thru(func);
            }
          }
          return function() {
            var args = arguments, value2 = args[0];
            if (wrapper2 && args.length == 1 && isArray2(value2)) {
              return wrapper2.plant(value2).value();
            }
            var index3 = 0, result2 = length ? funcs[index3].apply(this, args) : value2;
            while (++index3 < length) {
              result2 = funcs[index3].call(this, result2);
            }
            return result2;
          };
        });
      }
      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$1 : createCtor(func);
        function wrapper2() {
          var length = arguments.length, args = Array2(length), index2 = length;
          while (index2--) {
            args[index2] = arguments[index2];
          }
          if (isCurried) {
            var placeholder = getHolder(wrapper2), holdersCount = countHolders(args, placeholder);
          }
          if (partials) {
            args = composeArgs(args, partials, holders, isCurried);
          }
          if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
          }
          length -= holdersCount;
          if (isCurried && length < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(
              func,
              bitmask,
              createHybrid,
              wrapper2.placeholder,
              thisArg,
              args,
              newHolders,
              argPos,
              ary2,
              arity - length
            );
          }
          var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
          length = args.length;
          if (argPos) {
            args = reorder(args, argPos);
          } else if (isFlip && length > 1) {
            args.reverse();
          }
          if (isAry && ary2 < length) {
            args.length = ary2;
          }
          if (this && this !== root && this instanceof wrapper2) {
            fn = Ctor || createCtor(fn);
          }
          return fn.apply(thisBinding, args);
        }
        return wrapper2;
      }
      function createInverter(setter, toIteratee) {
        return function(object, iteratee2) {
          return baseInverter(object, setter, toIteratee(iteratee2), {});
        };
      }
      function createMathOperation(operator, defaultValue) {
        return function(value2, other) {
          var result2;
          if (value2 === undefined$1 && other === undefined$1) {
            return defaultValue;
          }
          if (value2 !== undefined$1) {
            result2 = value2;
          }
          if (other !== undefined$1) {
            if (result2 === undefined$1) {
              return other;
            }
            if (typeof value2 == "string" || typeof other == "string") {
              value2 = baseToString(value2);
              other = baseToString(other);
            } else {
              value2 = baseToNumber(value2);
              other = baseToNumber(other);
            }
            result2 = operator(value2, other);
          }
          return result2;
        };
      }
      function createOver(arrayFunc) {
        return flatRest(function(iteratees) {
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          return baseRest(function(args) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee2) {
              return apply(iteratee2, thisArg, args);
            });
          });
        });
      }
      function createPadding(length, chars) {
        chars = chars === undefined$1 ? " " : baseToString(chars);
        var charsLength = chars.length;
        if (charsLength < 2) {
          return charsLength ? baseRepeat(chars, length) : chars;
        }
        var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
        return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
      }
      function createPartial(func, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper2() {
          var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper2 ? Ctor : func;
          while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
          }
          while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
          }
          return apply(fn, isBind ? thisArg : this, args);
        }
        return wrapper2;
      }
      function createRange(fromRight) {
        return function(start, end, step) {
          if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
            end = step = undefined$1;
          }
          start = toFinite(start);
          if (end === undefined$1) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          step = step === undefined$1 ? start < end ? 1 : -1 : toFinite(step);
          return baseRange(start, end, step, fromRight);
        };
      }
      function createRelationalOperation(operator) {
        return function(value2, other) {
          if (!(typeof value2 == "string" && typeof other == "string")) {
            value2 = toNumber(value2);
            other = toNumber(other);
          }
          return operator(value2, other);
        };
      }
      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$1, newHoldersRight = isCurry ? undefined$1 : holders, newPartials = isCurry ? partials : undefined$1, newPartialsRight = isCurry ? undefined$1 : partials;
        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
        if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
          bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
        }
        var newData = [
          func,
          bitmask,
          thisArg,
          newPartials,
          newHolders,
          newPartialsRight,
          newHoldersRight,
          argPos,
          ary2,
          arity
        ];
        var result2 = wrapFunc.apply(undefined$1, newData);
        if (isLaziable(func)) {
          setData(result2, newData);
        }
        result2.placeholder = placeholder;
        return setWrapToString(result2, func, bitmask);
      }
      function createRound(methodName) {
        var func = Math2[methodName];
        return function(number, precision) {
          number = toNumber(number);
          precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
          if (precision && nativeIsFinite(number)) {
            var pair = (toString2(number) + "e").split("e"), value2 = func(pair[0] + "e" + (+pair[1] + precision));
            pair = (toString2(value2) + "e").split("e");
            return +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func(number);
        };
      }
      var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop3 : function(values7) {
        return new Set2(values7);
      };
      function createToPairs(keysFunc) {
        return function(object) {
          var tag = getTag(object);
          if (tag == mapTag) {
            return mapToArray(object);
          }
          if (tag == setTag) {
            return setToPairs(object);
          }
          return baseToPairs(object, keysFunc(object));
        };
      }
      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
        if (!isBindKey && typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var length = partials ? partials.length : 0;
        if (!length) {
          bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
          partials = holders = undefined$1;
        }
        ary2 = ary2 === undefined$1 ? ary2 : nativeMax(toInteger(ary2), 0);
        arity = arity === undefined$1 ? arity : toInteger(arity);
        length -= holders ? holders.length : 0;
        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = undefined$1;
        }
        var data2 = isBindKey ? undefined$1 : getData2(func);
        var newData = [
          func,
          bitmask,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary2,
          arity
        ];
        if (data2) {
          mergeData(newData, data2);
        }
        func = newData[0];
        bitmask = newData[1];
        thisArg = newData[2];
        partials = newData[3];
        holders = newData[4];
        arity = newData[9] = newData[9] === undefined$1 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
        if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
          bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
        }
        if (!bitmask || bitmask == WRAP_BIND_FLAG) {
          var result2 = createBind(func, bitmask, thisArg);
        } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
          result2 = createCurry(func, bitmask, arity);
        } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
          result2 = createPartial(func, bitmask, thisArg, partials);
        } else {
          result2 = createHybrid.apply(undefined$1, newData);
        }
        var setter = data2 ? baseSetData : setData;
        return setWrapToString(setter(result2, newData), func, bitmask);
      }
      function customDefaultsAssignIn(objValue, srcValue, key, object) {
        if (objValue === undefined$1 || eq(objValue, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
          return srcValue;
        }
        return objValue;
      }
      function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
        if (isObject2(objValue) && isObject2(srcValue)) {
          stack.set(srcValue, objValue);
          baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
          stack["delete"](srcValue);
        }
        return objValue;
      }
      function customOmitClone(value2) {
        return isPlainObject2(value2) ? undefined$1 : value2;
      }
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index2 = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$1;
        stack.set(array, other);
        stack.set(other, array);
        while (++index2 < arrLength) {
          var arrValue = array[index2], othValue = other[index2];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
          }
          if (compared !== undefined$1) {
            if (compared) {
              continue;
            }
            result2 = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result2 = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result2 = false;
            break;
          }
        }
        stack["delete"](array);
        stack["delete"](other);
        return result2;
      }
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert2 = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert2 || (convert2 = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object, other);
            var result2 = equalArrays(convert2(object), convert2(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object);
            return result2;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index2 = objLength;
        while (index2--) {
          var key = objProps[index2];
          if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result2 = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index2 < objLength) {
          key = objProps[index2];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
          }
          if (!(compared === undefined$1 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result2 = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result2 && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result2 = false;
          }
        }
        stack["delete"](object);
        stack["delete"](other);
        return result2;
      }
      function flatRest(func) {
        return setToString(overRest(func, undefined$1, flatten2), func + "");
      }
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys2, getSymbols);
      }
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn);
      }
      var getData2 = !metaMap ? noop3 : function(func) {
        return metaMap.get(func);
      };
      function getFuncName(func) {
        var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty2.call(realNames, result2) ? array.length : 0;
        while (length--) {
          var data2 = array[length], otherFunc = data2.func;
          if (otherFunc == null || otherFunc == func) {
            return data2.name;
          }
        }
        return result2;
      }
      function getHolder(func) {
        var object = hasOwnProperty2.call(lodash2, "placeholder") ? lodash2 : func;
        return object.placeholder;
      }
      function getIteratee() {
        var result2 = lodash2.iteratee || iteratee;
        result2 = result2 === iteratee ? baseIteratee : result2;
        return arguments.length ? result2(arguments[0], arguments[1]) : result2;
      }
      function getMapData(map4, key) {
        var data2 = map4.__data__;
        return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
      }
      function getMatchData(object) {
        var result2 = keys2(object), length = result2.length;
        while (length--) {
          var key = result2[length], value2 = object[key];
          result2[length] = [key, value2, isStrictComparable(value2)];
        }
        return result2;
      }
      function getNative(object, key) {
        var value2 = getValue(object, key);
        return baseIsNative(value2) ? value2 : undefined$1;
      }
      function getRawTag(value2) {
        var isOwn = hasOwnProperty2.call(value2, symToStringTag), tag = value2[symToStringTag];
        try {
          value2[symToStringTag] = undefined$1;
          var unmasked = true;
        } catch (e3) {
        }
        var result2 = nativeObjectToString.call(value2);
        if (unmasked) {
          if (isOwn) {
            value2[symToStringTag] = tag;
          } else {
            delete value2[symToStringTag];
          }
        }
        return result2;
      }
      var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object2(object);
        return arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
        var result2 = [];
        while (object) {
          arrayPush(result2, getSymbols(object));
          object = getPrototype(object);
        }
        return result2;
      };
      var getTag = baseGetTag;
      if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
        getTag = function(value2) {
          var result2 = baseGetTag(value2), Ctor = result2 == objectTag ? value2.constructor : undefined$1, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result2;
        };
      }
      function getView(start, end, transforms) {
        var index2 = -1, length = transforms.length;
        while (++index2 < length) {
          var data2 = transforms[index2], size2 = data2.size;
          switch (data2.type) {
            case "drop":
              start += size2;
              break;
            case "dropRight":
              end -= size2;
              break;
            case "take":
              end = nativeMin(end, start + size2);
              break;
            case "takeRight":
              start = nativeMax(start, end - size2);
              break;
          }
        }
        return { "start": start, "end": end };
      }
      function getWrapDetails(source) {
        var match2 = source.match(reWrapDetails);
        return match2 ? match2[1].split(reSplitDetails) : [];
      }
      function hasPath(object, path, hasFunc) {
        path = castPath(path, object);
        var index2 = -1, length = path.length, result2 = false;
        while (++index2 < length) {
          var key = toKey(path[index2]);
          if (!(result2 = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result2 || ++index2 != length) {
          return result2;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray2(object) || isArguments(object));
      }
      function initCloneArray(array) {
        var length = array.length, result2 = new array.constructor(length);
        if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
          result2.index = array.index;
          result2.input = array.input;
        }
        return result2;
      }
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }
      function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object);
          case boolTag:
          case dateTag:
            return new Ctor(+object);
          case dataViewTag:
            return cloneDataView(object, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object, isDeep);
          case mapTag:
            return new Ctor();
          case numberTag:
          case stringTag:
            return new Ctor(object);
          case regexpTag:
            return cloneRegExp(object);
          case setTag:
            return new Ctor();
          case symbolTag:
            return cloneSymbol(object);
        }
      }
      function insertWrapDetails(source, details) {
        var length = details.length;
        if (!length) {
          return source;
        }
        var lastIndex = length - 1;
        details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
        details = details.join(length > 2 ? ", " : " ");
        return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
      }
      function isFlattenable(value2) {
        return isArray2(value2) || isArguments(value2) || !!(spreadableSymbol && value2 && value2[spreadableSymbol]);
      }
      function isIndex(value2, length) {
        var type = typeof value2;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value2)) && (value2 > -1 && value2 % 1 == 0 && value2 < length);
      }
      function isIterateeCall(value2, index2, object) {
        if (!isObject2(object)) {
          return false;
        }
        var type = typeof index2;
        if (type == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
          return eq(object[index2], value2);
        }
        return false;
      }
      function isKey(value2, object) {
        if (isArray2(value2)) {
          return false;
        }
        var type = typeof value2;
        if (type == "number" || type == "symbol" || type == "boolean" || value2 == null || isSymbol(value2)) {
          return true;
        }
        return reIsPlainProp.test(value2) || !reIsDeepProp.test(value2) || object != null && value2 in Object2(object);
      }
      function isKeyable(value2) {
        var type = typeof value2;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value2 !== "__proto__" : value2 === null;
      }
      function isLaziable(func) {
        var funcName = getFuncName(func), other = lodash2[funcName];
        if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
          return false;
        }
        if (func === other) {
          return true;
        }
        var data2 = getData2(other);
        return !!data2 && func === data2[0];
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var isMaskable = coreJsData ? isFunction2 : stubFalse;
      function isPrototype(value2) {
        var Ctor = value2 && value2.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value2 === proto;
      }
      function isStrictComparable(value2) {
        return value2 === value2 && !isObject2(value2);
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== undefined$1 || key in Object2(object));
        };
      }
      function memoizeCapped(func) {
        var result2 = memoize2(func, function(key) {
          if (cache2.size === MAX_MEMOIZE_SIZE) {
            cache2.clear();
          }
          return key;
        });
        var cache2 = result2.cache;
        return result2;
      }
      function mergeData(data2, source) {
        var bitmask = data2[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
        var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data2[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
        if (!(isCommon || isCombo)) {
          return data2;
        }
        if (srcBitmask & WRAP_BIND_FLAG) {
          data2[2] = source[2];
          newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
        }
        var value2 = source[3];
        if (value2) {
          var partials = data2[3];
          data2[3] = partials ? composeArgs(partials, value2, source[4]) : value2;
          data2[4] = partials ? replaceHolders(data2[3], PLACEHOLDER2) : source[4];
        }
        value2 = source[5];
        if (value2) {
          partials = data2[5];
          data2[5] = partials ? composeArgsRight(partials, value2, source[6]) : value2;
          data2[6] = partials ? replaceHolders(data2[5], PLACEHOLDER2) : source[6];
        }
        value2 = source[7];
        if (value2) {
          data2[7] = value2;
        }
        if (srcBitmask & WRAP_ARY_FLAG) {
          data2[8] = data2[8] == null ? source[8] : nativeMin(data2[8], source[8]);
        }
        if (data2[9] == null) {
          data2[9] = source[9];
        }
        data2[0] = source[0];
        data2[1] = newBitmask;
        return data2;
      }
      function nativeKeysIn(object) {
        var result2 = [];
        if (object != null) {
          for (var key in Object2(object)) {
            result2.push(key);
          }
        }
        return result2;
      }
      function objectToString(value2) {
        return nativeObjectToString.call(value2);
      }
      function overRest(func, start, transform3) {
        start = nativeMax(start === undefined$1 ? func.length - 1 : start, 0);
        return function() {
          var args = arguments, index2 = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
          while (++index2 < length) {
            array[index2] = args[start + index2];
          }
          index2 = -1;
          var otherArgs = Array2(start + 1);
          while (++index2 < start) {
            otherArgs[index2] = args[index2];
          }
          otherArgs[start] = transform3(array);
          return apply(func, this, otherArgs);
        };
      }
      function parent(object, path) {
        return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
      }
      function reorder(array, indexes) {
        var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
        while (length--) {
          var index2 = indexes[length];
          array[length] = isIndex(index2, arrLength) ? oldArray[index2] : undefined$1;
        }
        return array;
      }
      function safeGet(object, key) {
        if (key === "constructor" && typeof object[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object[key];
      }
      var setData = shortOut(baseSetData);
      var setTimeout2 = ctxSetTimeout || function(func, wait) {
        return root.setTimeout(func, wait);
      };
      var setToString = shortOut(baseSetToString);
      function setWrapToString(wrapper2, reference, bitmask) {
        var source = reference + "";
        return setToString(wrapper2, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
      }
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(undefined$1, arguments);
        };
      }
      function shuffleSelf(array, size2) {
        var index2 = -1, length = array.length, lastIndex = length - 1;
        size2 = size2 === undefined$1 ? length : size2;
        while (++index2 < size2) {
          var rand = baseRandom(index2, lastIndex), value2 = array[rand];
          array[rand] = array[index2];
          array[index2] = value2;
        }
        array.length = size2;
        return array;
      }
      var stringToPath = memoizeCapped(function(string) {
        var result2 = [];
        if (string.charCodeAt(0) === 46) {
          result2.push("");
        }
        string.replace(rePropName, function(match2, number, quote, subString) {
          result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match2);
        });
        return result2;
      });
      function toKey(value2) {
        if (typeof value2 == "string" || isSymbol(value2)) {
          return value2;
        }
        var result2 = value2 + "";
        return result2 == "0" && 1 / value2 == -INFINITY ? "-0" : result2;
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e3) {
          }
          try {
            return func + "";
          } catch (e3) {
          }
        }
        return "";
      }
      function updateWrapDetails(details, bitmask) {
        arrayEach(wrapFlags, function(pair) {
          var value2 = "_." + pair[0];
          if (bitmask & pair[1] && !arrayIncludes(details, value2)) {
            details.push(value2);
          }
        });
        return details.sort();
      }
      function wrapperClone(wrapper2) {
        if (wrapper2 instanceof LazyWrapper) {
          return wrapper2.clone();
        }
        var result2 = new LodashWrapper(wrapper2.__wrapped__, wrapper2.__chain__);
        result2.__actions__ = copyArray(wrapper2.__actions__);
        result2.__index__ = wrapper2.__index__;
        result2.__values__ = wrapper2.__values__;
        return result2;
      }
      function chunk(array, size2, guard) {
        if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined$1) {
          size2 = 1;
        } else {
          size2 = nativeMax(toInteger(size2), 0);
        }
        var length = array == null ? 0 : array.length;
        if (!length || size2 < 1) {
          return [];
        }
        var index2 = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
        while (index2 < length) {
          result2[resIndex++] = baseSlice(array, index2, index2 += size2);
        }
        return result2;
      }
      function compact(array) {
        var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
        while (++index2 < length) {
          var value2 = array[index2];
          if (value2) {
            result2[resIndex++] = value2;
          }
        }
        return result2;
      }
      function concat() {
        var length = arguments.length;
        if (!length) {
          return [];
        }
        var args = Array2(length - 1), array = arguments[0], index2 = length;
        while (index2--) {
          args[index2 - 1] = arguments[index2];
        }
        return arrayPush(isArray2(array) ? copyArray(array) : [array], baseFlatten(args, 1));
      }
      var difference = baseRest(function(array, values7) {
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values7, 1, isArrayLikeObject, true)) : [];
      });
      var differenceBy = baseRest(function(array, values7) {
        var iteratee2 = last2(values7);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values7, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
      });
      var differenceWith = baseRest(function(array, values7) {
        var comparator = last2(values7);
        if (isArrayLikeObject(comparator)) {
          comparator = undefined$1;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values7, 1, isArrayLikeObject, true), undefined$1, comparator) : [];
      });
      function drop(array, n10, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n10 = guard || n10 === undefined$1 ? 1 : toInteger(n10);
        return baseSlice(array, n10 < 0 ? 0 : n10, length);
      }
      function dropRight(array, n10, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n10 = guard || n10 === undefined$1 ? 1 : toInteger(n10);
        n10 = length - n10;
        return baseSlice(array, 0, n10 < 0 ? 0 : n10);
      }
      function dropRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
      }
      function dropWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
      }
      function fill(array, value2, start, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (start && typeof start != "number" && isIterateeCall(array, value2, start)) {
          start = 0;
          end = length;
        }
        return baseFill(array, value2, start, end);
      }
      function findIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index2 < 0) {
          index2 = nativeMax(length + index2, 0);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index2);
      }
      function findLastIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = length - 1;
        if (fromIndex !== undefined$1) {
          index2 = toInteger(fromIndex);
          index2 = fromIndex < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index2, true);
      }
      function flatten2(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, 1) : [];
      }
      function flattenDeep(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, INFINITY) : [];
      }
      function flattenDepth(array, depth) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        depth = depth === undefined$1 ? 1 : toInteger(depth);
        return baseFlatten(array, depth);
      }
      function fromPairs(pairs) {
        var index2 = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
        while (++index2 < length) {
          var pair = pairs[index2];
          result2[pair[0]] = pair[1];
        }
        return result2;
      }
      function head(array) {
        return array && array.length ? array[0] : undefined$1;
      }
      function indexOf2(array, value2, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index2 < 0) {
          index2 = nativeMax(length + index2, 0);
        }
        return baseIndexOf(array, value2, index2);
      }
      function initial2(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 0, -1) : [];
      }
      var intersection2 = baseRest(function(arrays) {
        var mapped = arrayMap(arrays, castArrayLikeObject);
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
      });
      var intersectionBy = baseRest(function(arrays) {
        var iteratee2 = last2(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        if (iteratee2 === last2(mapped)) {
          iteratee2 = undefined$1;
        } else {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
      });
      var intersectionWith = baseRest(function(arrays) {
        var comparator = last2(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        if (comparator) {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$1, comparator) : [];
      });
      function join(array, separator) {
        return array == null ? "" : nativeJoin.call(array, separator);
      }
      function last2(array) {
        var length = array == null ? 0 : array.length;
        return length ? array[length - 1] : undefined$1;
      }
      function lastIndexOf(array, value2, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = length;
        if (fromIndex !== undefined$1) {
          index2 = toInteger(fromIndex);
          index2 = index2 < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
        }
        return value2 === value2 ? strictLastIndexOf(array, value2, index2) : baseFindIndex(array, baseIsNaN, index2, true);
      }
      function nth(array, n10) {
        return array && array.length ? baseNth(array, toInteger(n10)) : undefined$1;
      }
      var pull = baseRest(pullAll);
      function pullAll(array, values7) {
        return array && array.length && values7 && values7.length ? basePullAll(array, values7) : array;
      }
      function pullAllBy(array, values7, iteratee2) {
        return array && array.length && values7 && values7.length ? basePullAll(array, values7, getIteratee(iteratee2, 2)) : array;
      }
      function pullAllWith(array, values7, comparator) {
        return array && array.length && values7 && values7.length ? basePullAll(array, values7, undefined$1, comparator) : array;
      }
      var pullAt = flatRest(function(array, indexes) {
        var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
        basePullAt(array, arrayMap(indexes, function(index2) {
          return isIndex(index2, length) ? +index2 : index2;
        }).sort(compareAscending));
        return result2;
      });
      function remove(array, predicate) {
        var result2 = [];
        if (!(array && array.length)) {
          return result2;
        }
        var index2 = -1, indexes = [], length = array.length;
        predicate = getIteratee(predicate, 3);
        while (++index2 < length) {
          var value2 = array[index2];
          if (predicate(value2, index2, array)) {
            result2.push(value2);
            indexes.push(index2);
          }
        }
        basePullAt(array, indexes);
        return result2;
      }
      function reverse(array) {
        return array == null ? array : nativeReverse.call(array);
      }
      function slice3(array, start, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
          start = 0;
          end = length;
        } else {
          start = start == null ? 0 : toInteger(start);
          end = end === undefined$1 ? length : toInteger(end);
        }
        return baseSlice(array, start, end);
      }
      function sortedIndex(array, value2) {
        return baseSortedIndex(array, value2);
      }
      function sortedIndexBy(array, value2, iteratee2) {
        return baseSortedIndexBy(array, value2, getIteratee(iteratee2, 2));
      }
      function sortedIndexOf(array, value2) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index2 = baseSortedIndex(array, value2);
          if (index2 < length && eq(array[index2], value2)) {
            return index2;
          }
        }
        return -1;
      }
      function sortedLastIndex(array, value2) {
        return baseSortedIndex(array, value2, true);
      }
      function sortedLastIndexBy(array, value2, iteratee2) {
        return baseSortedIndexBy(array, value2, getIteratee(iteratee2, 2), true);
      }
      function sortedLastIndexOf(array, value2) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index2 = baseSortedIndex(array, value2, true) - 1;
          if (eq(array[index2], value2)) {
            return index2;
          }
        }
        return -1;
      }
      function sortedUniq(array) {
        return array && array.length ? baseSortedUniq(array) : [];
      }
      function sortedUniqBy(array, iteratee2) {
        return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function tail(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 1, length) : [];
      }
      function take2(array, n10, guard) {
        if (!(array && array.length)) {
          return [];
        }
        n10 = guard || n10 === undefined$1 ? 1 : toInteger(n10);
        return baseSlice(array, 0, n10 < 0 ? 0 : n10);
      }
      function takeRight(array, n10, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n10 = guard || n10 === undefined$1 ? 1 : toInteger(n10);
        n10 = length - n10;
        return baseSlice(array, n10 < 0 ? 0 : n10, length);
      }
      function takeRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
      }
      function takeWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
      }
      var union = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
      });
      var unionBy = baseRest(function(arrays) {
        var iteratee2 = last2(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
      });
      var unionWith = baseRest(function(arrays) {
        var comparator = last2(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator);
      });
      function uniq(array) {
        return array && array.length ? baseUniq(array) : [];
      }
      function uniqBy(array, iteratee2) {
        return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function uniqWith(array, comparator) {
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return array && array.length ? baseUniq(array, undefined$1, comparator) : [];
      }
      function unzip(array) {
        if (!(array && array.length)) {
          return [];
        }
        var length = 0;
        array = arrayFilter(array, function(group2) {
          if (isArrayLikeObject(group2)) {
            length = nativeMax(group2.length, length);
            return true;
          }
        });
        return baseTimes(length, function(index2) {
          return arrayMap(array, baseProperty(index2));
        });
      }
      function unzipWith(array, iteratee2) {
        if (!(array && array.length)) {
          return [];
        }
        var result2 = unzip(array);
        if (iteratee2 == null) {
          return result2;
        }
        return arrayMap(result2, function(group2) {
          return apply(iteratee2, undefined$1, group2);
        });
      }
      var without = baseRest(function(array, values7) {
        return isArrayLikeObject(array) ? baseDifference(array, values7) : [];
      });
      var xor = baseRest(function(arrays) {
        return baseXor(arrayFilter(arrays, isArrayLikeObject));
      });
      var xorBy = baseRest(function(arrays) {
        var iteratee2 = last2(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
      });
      var xorWith = baseRest(function(arrays) {
        var comparator = last2(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
      });
      var zip = baseRest(unzip);
      function zipObject(props, values7) {
        return baseZipObject(props || [], values7 || [], assignValue);
      }
      function zipObjectDeep(props, values7) {
        return baseZipObject(props || [], values7 || [], baseSet);
      }
      var zipWith = baseRest(function(arrays) {
        var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined$1;
        iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$1;
        return unzipWith(arrays, iteratee2);
      });
      function chain(value2) {
        var result2 = lodash2(value2);
        result2.__chain__ = true;
        return result2;
      }
      function tap(value2, interceptor) {
        interceptor(value2);
        return value2;
      }
      function thru(value2, interceptor) {
        return interceptor(value2);
      }
      var wrapperAt = flatRest(function(paths) {
        var length = paths.length, start = length ? paths[0] : 0, value2 = this.__wrapped__, interceptor = function(object) {
          return baseAt(object, paths);
        };
        if (length > 1 || this.__actions__.length || !(value2 instanceof LazyWrapper) || !isIndex(start)) {
          return this.thru(interceptor);
        }
        value2 = value2.slice(start, +start + (length ? 1 : 0));
        value2.__actions__.push({
          "func": thru,
          "args": [interceptor],
          "thisArg": undefined$1
        });
        return new LodashWrapper(value2, this.__chain__).thru(function(array) {
          if (length && !array.length) {
            array.push(undefined$1);
          }
          return array;
        });
      });
      function wrapperChain() {
        return chain(this);
      }
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      function wrapperNext() {
        if (this.__values__ === undefined$1) {
          this.__values__ = toArray2(this.value());
        }
        var done = this.__index__ >= this.__values__.length, value2 = done ? undefined$1 : this.__values__[this.__index__++];
        return { "done": done, "value": value2 };
      }
      function wrapperToIterator() {
        return this;
      }
      function wrapperPlant(value2) {
        var result2, parent2 = this;
        while (parent2 instanceof baseLodash) {
          var clone4 = wrapperClone(parent2);
          clone4.__index__ = 0;
          clone4.__values__ = undefined$1;
          if (result2) {
            previous.__wrapped__ = clone4;
          } else {
            result2 = clone4;
          }
          var previous = clone4;
          parent2 = parent2.__wrapped__;
        }
        previous.__wrapped__ = value2;
        return result2;
      }
      function wrapperReverse() {
        var value2 = this.__wrapped__;
        if (value2 instanceof LazyWrapper) {
          var wrapped = value2;
          if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
          }
          wrapped = wrapped.reverse();
          wrapped.__actions__.push({
            "func": thru,
            "args": [reverse],
            "thisArg": undefined$1
          });
          return new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse);
      }
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      var countBy = createAggregator(function(result2, value2, key) {
        if (hasOwnProperty2.call(result2, key)) {
          ++result2[key];
        } else {
          baseAssignValue(result2, key, 1);
        }
      });
      function every(collection, predicate, guard) {
        var func = isArray2(collection) ? arrayEvery : baseEvery;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      function filter(collection, predicate) {
        var func = isArray2(collection) ? arrayFilter : baseFilter;
        return func(collection, getIteratee(predicate, 3));
      }
      var find2 = createFind(findIndex);
      var findLast = createFind(findLastIndex);
      function flatMap(collection, iteratee2) {
        return baseFlatten(map3(collection, iteratee2), 1);
      }
      function flatMapDeep(collection, iteratee2) {
        return baseFlatten(map3(collection, iteratee2), INFINITY);
      }
      function flatMapDepth(collection, iteratee2, depth) {
        depth = depth === undefined$1 ? 1 : toInteger(depth);
        return baseFlatten(map3(collection, iteratee2), depth);
      }
      function forEach2(collection, iteratee2) {
        var func = isArray2(collection) ? arrayEach : baseEach;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function forEachRight(collection, iteratee2) {
        var func = isArray2(collection) ? arrayEachRight : baseEachRight;
        return func(collection, getIteratee(iteratee2, 3));
      }
      var groupBy = createAggregator(function(result2, value2, key) {
        if (hasOwnProperty2.call(result2, key)) {
          result2[key].push(value2);
        } else {
          baseAssignValue(result2, key, [value2]);
        }
      });
      function includes(collection, value2, fromIndex, guard) {
        collection = isArrayLike(collection) ? collection : values6(collection);
        fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
        var length = collection.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax(length + fromIndex, 0);
        }
        return isString2(collection) ? fromIndex <= length && collection.indexOf(value2, fromIndex) > -1 : !!length && baseIndexOf(collection, value2, fromIndex) > -1;
      }
      var invokeMap = baseRest(function(collection, path, args) {
        var index2 = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value2) {
          result2[++index2] = isFunc ? apply(path, value2, args) : baseInvoke(value2, path, args);
        });
        return result2;
      });
      var keyBy = createAggregator(function(result2, value2, key) {
        baseAssignValue(result2, key, value2);
      });
      function map3(collection, iteratee2) {
        var func = isArray2(collection) ? arrayMap : baseMap;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function orderBy2(collection, iteratees, orders, guard) {
        if (collection == null) {
          return [];
        }
        if (!isArray2(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders = guard ? undefined$1 : orders;
        if (!isArray2(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseOrderBy(collection, iteratees, orders);
      }
      var partition = createAggregator(function(result2, value2, key) {
        result2[key ? 0 : 1].push(value2);
      }, function() {
        return [[], []];
      });
      function reduce(collection, iteratee2, accumulator) {
        var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
      }
      function reduceRight(collection, iteratee2, accumulator) {
        var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
      }
      function reject(collection, predicate) {
        var func = isArray2(collection) ? arrayFilter : baseFilter;
        return func(collection, negate(getIteratee(predicate, 3)));
      }
      function sample(collection) {
        var func = isArray2(collection) ? arraySample : baseSample;
        return func(collection);
      }
      function sampleSize(collection, n10, guard) {
        if (guard ? isIterateeCall(collection, n10, guard) : n10 === undefined$1) {
          n10 = 1;
        } else {
          n10 = toInteger(n10);
        }
        var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
        return func(collection, n10);
      }
      function shuffle(collection) {
        var func = isArray2(collection) ? arrayShuffle : baseShuffle;
        return func(collection);
      }
      function size(collection) {
        if (collection == null) {
          return 0;
        }
        if (isArrayLike(collection)) {
          return isString2(collection) ? stringSize(collection) : collection.length;
        }
        var tag = getTag(collection);
        if (tag == mapTag || tag == setTag) {
          return collection.size;
        }
        return baseKeys(collection).length;
      }
      function some(collection, predicate, guard) {
        var func = isArray2(collection) ? arraySome : baseSome;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      var sortBy = baseRest(function(collection, iteratees) {
        if (collection == null) {
          return [];
        }
        var length = iteratees.length;
        if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      });
      var now2 = ctxNow || function() {
        return root.Date.now();
      };
      function after(n10, func) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n10 = toInteger(n10);
        return function() {
          if (--n10 < 1) {
            return func.apply(this, arguments);
          }
        };
      }
      function ary(func, n10, guard) {
        n10 = guard ? undefined$1 : n10;
        n10 = func && n10 == null ? func.length : n10;
        return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n10);
      }
      function before(n10, func) {
        var result2;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n10 = toInteger(n10);
        return function() {
          if (--n10 > 0) {
            result2 = func.apply(this, arguments);
          }
          if (n10 <= 1) {
            func = undefined$1;
          }
          return result2;
        };
      }
      var bind = baseRest(function(func, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(func, bitmask, thisArg, partials, holders);
      });
      var bindKey = baseRest(function(object, key, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(key, bitmask, object, partials, holders);
      });
      function curry(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result2.placeholder = curry.placeholder;
        return result2;
      }
      function curryRight(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result2.placeholder = curryRight.placeholder;
        return result2;
      }
      function debounce(func, wait, options2) {
        var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject2(options2)) {
          leading = !!options2.leading;
          maxing = "maxWait" in options2;
          maxWait = maxing ? nativeMax(toNumber(options2.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options2 ? !!options2.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = undefined$1;
          lastInvokeTime = time;
          result2 = func.apply(thisArg, args);
          return result2;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout2(timerExpired, wait);
          return leading ? invokeFunc(time) : result2;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === undefined$1 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now2();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout2(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = undefined$1;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined$1;
          return result2;
        }
        function cancel() {
          if (timerId !== undefined$1) {
            clearTimeout2(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined$1;
        }
        function flush() {
          return timerId === undefined$1 ? result2 : trailingEdge(now2());
        }
        function debounced() {
          var time = now2(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === undefined$1) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout2(timerId);
              timerId = setTimeout2(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined$1) {
            timerId = setTimeout2(timerExpired, wait);
          }
          return result2;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      var defer = baseRest(function(func, args) {
        return baseDelay(func, 1, args);
      });
      var delay = baseRest(function(func, wait, args) {
        return baseDelay(func, toNumber(wait) || 0, args);
      });
      function flip2(func) {
        return createWrap(func, WRAP_FLIP_FLAG);
      }
      function memoize2(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
          if (cache2.has(key)) {
            return cache2.get(key);
          }
          var result2 = func.apply(this, args);
          memoized.cache = cache2.set(key, result2) || cache2;
          return result2;
        };
        memoized.cache = new (memoize2.Cache || MapCache)();
        return memoized;
      }
      memoize2.Cache = MapCache;
      function negate(predicate) {
        if (typeof predicate != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args[0]);
            case 2:
              return !predicate.call(this, args[0], args[1]);
            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      function once(func) {
        return before(2, func);
      }
      var overArgs = castRest(function(func, transforms) {
        transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
        var funcsLength = transforms.length;
        return baseRest(function(args) {
          var index2 = -1, length = nativeMin(args.length, funcsLength);
          while (++index2 < length) {
            args[index2] = transforms[index2].call(this, args[index2]);
          }
          return apply(func, this, args);
        });
      });
      var partial = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partial));
        return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
      });
      var partialRight = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
      });
      var rearg = flatRest(function(func, indexes) {
        return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
      });
      function rest(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start === undefined$1 ? start : toInteger(start);
        return baseRest(func, start);
      }
      function spread(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start == null ? 0 : nativeMax(toInteger(start), 0);
        return baseRest(function(args) {
          var array = args[start], otherArgs = castSlice(args, 0, start);
          if (array) {
            arrayPush(otherArgs, array);
          }
          return apply(func, this, otherArgs);
        });
      }
      function throttle2(func, wait, options2) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        if (isObject2(options2)) {
          leading = "leading" in options2 ? !!options2.leading : leading;
          trailing = "trailing" in options2 ? !!options2.trailing : trailing;
        }
        return debounce(func, wait, {
          "leading": leading,
          "maxWait": wait,
          "trailing": trailing
        });
      }
      function unary(func) {
        return ary(func, 1);
      }
      function wrap(value2, wrapper2) {
        return partial(castFunction(wrapper2), value2);
      }
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value2 = arguments[0];
        return isArray2(value2) ? value2 : [value2];
      }
      function clone3(value2) {
        return baseClone(value2, CLONE_SYMBOLS_FLAG);
      }
      function cloneWith(value2, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseClone(value2, CLONE_SYMBOLS_FLAG, customizer);
      }
      function cloneDeep(value2) {
        return baseClone(value2, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      function cloneDeepWith(value2, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseClone(value2, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
      }
      function conformsTo(object, source) {
        return source == null || baseConformsTo(object, source, keys2(source));
      }
      function eq(value2, other) {
        return value2 === other || value2 !== value2 && other !== other;
      }
      var gt = createRelationalOperation(baseGt);
      var gte = createRelationalOperation(function(value2, other) {
        return value2 >= other;
      });
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value2) {
        return isObjectLike(value2) && hasOwnProperty2.call(value2, "callee") && !propertyIsEnumerable.call(value2, "callee");
      };
      var isArray2 = Array2.isArray;
      var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
      function isArrayLike(value2) {
        return value2 != null && isLength(value2.length) && !isFunction2(value2);
      }
      function isArrayLikeObject(value2) {
        return isObjectLike(value2) && isArrayLike(value2);
      }
      function isBoolean(value2) {
        return value2 === true || value2 === false || isObjectLike(value2) && baseGetTag(value2) == boolTag;
      }
      var isBuffer = nativeIsBuffer || stubFalse;
      var isDate2 = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
      function isElement(value2) {
        return isObjectLike(value2) && value2.nodeType === 1 && !isPlainObject2(value2);
      }
      function isEmpty2(value2) {
        if (value2 == null) {
          return true;
        }
        if (isArrayLike(value2) && (isArray2(value2) || typeof value2 == "string" || typeof value2.splice == "function" || isBuffer(value2) || isTypedArray(value2) || isArguments(value2))) {
          return !value2.length;
        }
        var tag = getTag(value2);
        if (tag == mapTag || tag == setTag) {
          return !value2.size;
        }
        if (isPrototype(value2)) {
          return !baseKeys(value2).length;
        }
        for (var key in value2) {
          if (hasOwnProperty2.call(value2, key)) {
            return false;
          }
        }
        return true;
      }
      function isEqual2(value2, other) {
        return baseIsEqual(value2, other);
      }
      function isEqualWith(value2, other, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        var result2 = customizer ? customizer(value2, other) : undefined$1;
        return result2 === undefined$1 ? baseIsEqual(value2, other, undefined$1, customizer) : !!result2;
      }
      function isError(value2) {
        if (!isObjectLike(value2)) {
          return false;
        }
        var tag = baseGetTag(value2);
        return tag == errorTag || tag == domExcTag || typeof value2.message == "string" && typeof value2.name == "string" && !isPlainObject2(value2);
      }
      function isFinite2(value2) {
        return typeof value2 == "number" && nativeIsFinite(value2);
      }
      function isFunction2(value2) {
        if (!isObject2(value2)) {
          return false;
        }
        var tag = baseGetTag(value2);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      function isInteger(value2) {
        return typeof value2 == "number" && value2 == toInteger(value2);
      }
      function isLength(value2) {
        return typeof value2 == "number" && value2 > -1 && value2 % 1 == 0 && value2 <= MAX_SAFE_INTEGER;
      }
      function isObject2(value2) {
        var type = typeof value2;
        return value2 != null && (type == "object" || type == "function");
      }
      function isObjectLike(value2) {
        return value2 != null && typeof value2 == "object";
      }
      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      function isMatch(object, source) {
        return object === source || baseIsMatch(object, source, getMatchData(source));
      }
      function isMatchWith(object, source, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseIsMatch(object, source, getMatchData(source), customizer);
      }
      function isNaN2(value2) {
        return isNumber2(value2) && value2 != +value2;
      }
      function isNative(value2) {
        if (isMaskable(value2)) {
          throw new Error2(CORE_ERROR_TEXT);
        }
        return baseIsNative(value2);
      }
      function isNull(value2) {
        return value2 === null;
      }
      function isNil2(value2) {
        return value2 == null;
      }
      function isNumber2(value2) {
        return typeof value2 == "number" || isObjectLike(value2) && baseGetTag(value2) == numberTag;
      }
      function isPlainObject2(value2) {
        if (!isObjectLike(value2) || baseGetTag(value2) != objectTag) {
          return false;
        }
        var proto = getPrototype(value2);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
      function isSafeInteger(value2) {
        return isInteger(value2) && value2 >= -MAX_SAFE_INTEGER && value2 <= MAX_SAFE_INTEGER;
      }
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      function isString2(value2) {
        return typeof value2 == "string" || !isArray2(value2) && isObjectLike(value2) && baseGetTag(value2) == stringTag;
      }
      function isSymbol(value2) {
        return typeof value2 == "symbol" || isObjectLike(value2) && baseGetTag(value2) == symbolTag;
      }
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function isUndefined(value2) {
        return value2 === undefined$1;
      }
      function isWeakMap(value2) {
        return isObjectLike(value2) && getTag(value2) == weakMapTag;
      }
      function isWeakSet(value2) {
        return isObjectLike(value2) && baseGetTag(value2) == weakSetTag;
      }
      var lt = createRelationalOperation(baseLt);
      var lte = createRelationalOperation(function(value2, other) {
        return value2 <= other;
      });
      function toArray2(value2) {
        if (!value2) {
          return [];
        }
        if (isArrayLike(value2)) {
          return isString2(value2) ? stringToArray(value2) : copyArray(value2);
        }
        if (symIterator && value2[symIterator]) {
          return iteratorToArray(value2[symIterator]());
        }
        var tag = getTag(value2), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values6;
        return func(value2);
      }
      function toFinite(value2) {
        if (!value2) {
          return value2 === 0 ? value2 : 0;
        }
        value2 = toNumber(value2);
        if (value2 === INFINITY || value2 === -INFINITY) {
          var sign = value2 < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value2 === value2 ? value2 : 0;
      }
      function toInteger(value2) {
        var result2 = toFinite(value2), remainder = result2 % 1;
        return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
      }
      function toLength(value2) {
        return value2 ? baseClamp(toInteger(value2), 0, MAX_ARRAY_LENGTH) : 0;
      }
      function toNumber(value2) {
        if (typeof value2 == "number") {
          return value2;
        }
        if (isSymbol(value2)) {
          return NAN;
        }
        if (isObject2(value2)) {
          var other = typeof value2.valueOf == "function" ? value2.valueOf() : value2;
          value2 = isObject2(other) ? other + "" : other;
        }
        if (typeof value2 != "string") {
          return value2 === 0 ? value2 : +value2;
        }
        value2 = baseTrim(value2);
        var isBinary = reIsBinary.test(value2);
        return isBinary || reIsOctal.test(value2) ? freeParseInt(value2.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value2) ? NAN : +value2;
      }
      function toPlainObject(value2) {
        return copyObject(value2, keysIn(value2));
      }
      function toSafeInteger(value2) {
        return value2 ? baseClamp(toInteger(value2), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value2 === 0 ? value2 : 0;
      }
      function toString2(value2) {
        return value2 == null ? "" : baseToString(value2);
      }
      var assign = createAssigner(function(object, source) {
        if (isPrototype(source) || isArrayLike(source)) {
          copyObject(source, keys2(source), object);
          return;
        }
        for (var key in source) {
          if (hasOwnProperty2.call(source, key)) {
            assignValue(object, key, source[key]);
          }
        }
      });
      var assignIn = createAssigner(function(object, source) {
        copyObject(source, keysIn(source), object);
      });
      var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keysIn(source), object, customizer);
      });
      var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keys2(source), object, customizer);
      });
      var at = flatRest(baseAt);
      function create2(prototype, properties) {
        var result2 = baseCreate(prototype);
        return properties == null ? result2 : baseAssign(result2, properties);
      }
      var defaults = baseRest(function(object, sources) {
        object = Object2(object);
        var index2 = -1;
        var length = sources.length;
        var guard = length > 2 ? sources[2] : undefined$1;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          length = 1;
        }
        while (++index2 < length) {
          var source = sources[index2];
          var props = keysIn(source);
          var propsIndex = -1;
          var propsLength = props.length;
          while (++propsIndex < propsLength) {
            var key = props[propsIndex];
            var value2 = object[key];
            if (value2 === undefined$1 || eq(value2, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
              object[key] = source[key];
            }
          }
        }
        return object;
      });
      var defaultsDeep = baseRest(function(args) {
        args.push(undefined$1, customDefaultsMerge);
        return apply(mergeWith, undefined$1, args);
      });
      function findKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
      }
      function findLastKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
      }
      function forIn(object, iteratee2) {
        return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forInRight(object, iteratee2) {
        return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forOwn(object, iteratee2) {
        return object && baseForOwn(object, getIteratee(iteratee2, 3));
      }
      function forOwnRight(object, iteratee2) {
        return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
      }
      function functions(object) {
        return object == null ? [] : baseFunctions(object, keys2(object));
      }
      function functionsIn(object) {
        return object == null ? [] : baseFunctions(object, keysIn(object));
      }
      function get3(object, path, defaultValue) {
        var result2 = object == null ? undefined$1 : baseGet(object, path);
        return result2 === undefined$1 ? defaultValue : result2;
      }
      function has3(object, path) {
        return object != null && hasPath(object, path, baseHas);
      }
      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
      }
      var invert = createInverter(function(result2, value2, key) {
        if (value2 != null && typeof value2.toString != "function") {
          value2 = nativeObjectToString.call(value2);
        }
        result2[value2] = key;
      }, constant(identity));
      var invertBy = createInverter(function(result2, value2, key) {
        if (value2 != null && typeof value2.toString != "function") {
          value2 = nativeObjectToString.call(value2);
        }
        if (hasOwnProperty2.call(result2, value2)) {
          result2[value2].push(key);
        } else {
          result2[value2] = [key];
        }
      }, getIteratee);
      var invoke = baseRest(baseInvoke);
      function keys2(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      function mapKeys(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value2, key, object2) {
          baseAssignValue(result2, iteratee2(value2, key, object2), value2);
        });
        return result2;
      }
      function mapValues(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value2, key, object2) {
          baseAssignValue(result2, key, iteratee2(value2, key, object2));
        });
        return result2;
      }
      var merge = createAssigner(function(object, source, srcIndex) {
        baseMerge(object, source, srcIndex);
      });
      var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
        baseMerge(object, source, srcIndex, customizer);
      });
      var omit2 = flatRest(function(object, paths) {
        var result2 = {};
        if (object == null) {
          return result2;
        }
        var isDeep = false;
        paths = arrayMap(paths, function(path) {
          path = castPath(path, object);
          isDeep || (isDeep = path.length > 1);
          return path;
        });
        copyObject(object, getAllKeysIn(object), result2);
        if (isDeep) {
          result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
        }
        var length = paths.length;
        while (length--) {
          baseUnset(result2, paths[length]);
        }
        return result2;
      });
      function omitBy(object, predicate) {
        return pickBy(object, negate(getIteratee(predicate)));
      }
      var pick = flatRest(function(object, paths) {
        return object == null ? {} : basePick(object, paths);
      });
      function pickBy(object, predicate) {
        if (object == null) {
          return {};
        }
        var props = arrayMap(getAllKeysIn(object), function(prop) {
          return [prop];
        });
        predicate = getIteratee(predicate);
        return basePickBy(object, props, function(value2, path) {
          return predicate(value2, path[0]);
        });
      }
      function result(object, path, defaultValue) {
        path = castPath(path, object);
        var index2 = -1, length = path.length;
        if (!length) {
          length = 1;
          object = undefined$1;
        }
        while (++index2 < length) {
          var value2 = object == null ? undefined$1 : object[toKey(path[index2])];
          if (value2 === undefined$1) {
            index2 = length;
            value2 = defaultValue;
          }
          object = isFunction2(value2) ? value2.call(object) : value2;
        }
        return object;
      }
      function set4(object, path, value2) {
        return object == null ? object : baseSet(object, path, value2);
      }
      function setWith(object, path, value2, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return object == null ? object : baseSet(object, path, value2, customizer);
      }
      var toPairs = createToPairs(keys2);
      var toPairsIn = createToPairs(keysIn);
      function transform2(object, iteratee2, accumulator) {
        var isArr = isArray2(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
        iteratee2 = getIteratee(iteratee2, 4);
        if (accumulator == null) {
          var Ctor = object && object.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor() : [];
          } else if (isObject2(object)) {
            accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object)) : {};
          } else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach : baseForOwn)(object, function(value2, index2, object2) {
          return iteratee2(accumulator, value2, index2, object2);
        });
        return accumulator;
      }
      function unset(object, path) {
        return object == null ? true : baseUnset(object, path);
      }
      function update(object, path, updater) {
        return object == null ? object : baseUpdate(object, path, castFunction(updater));
      }
      function updateWith(object, path, updater, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
      }
      function values6(object) {
        return object == null ? [] : baseValues(object, keys2(object));
      }
      function valuesIn(object) {
        return object == null ? [] : baseValues(object, keysIn(object));
      }
      function clamp2(number, lower, upper) {
        if (upper === undefined$1) {
          upper = lower;
          lower = undefined$1;
        }
        if (upper !== undefined$1) {
          upper = toNumber(upper);
          upper = upper === upper ? upper : 0;
        }
        if (lower !== undefined$1) {
          lower = toNumber(lower);
          lower = lower === lower ? lower : 0;
        }
        return baseClamp(toNumber(number), lower, upper);
      }
      function inRange(number, start, end) {
        start = toFinite(start);
        if (end === undefined$1) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        number = toNumber(number);
        return baseInRange(number, start, end);
      }
      function random(lower, upper, floating) {
        if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
          upper = floating = undefined$1;
        }
        if (floating === undefined$1) {
          if (typeof upper == "boolean") {
            floating = upper;
            upper = undefined$1;
          } else if (typeof lower == "boolean") {
            floating = lower;
            lower = undefined$1;
          }
        }
        if (lower === undefined$1 && upper === undefined$1) {
          lower = 0;
          upper = 1;
        } else {
          lower = toFinite(lower);
          if (upper === undefined$1) {
            upper = lower;
            lower = 0;
          } else {
            upper = toFinite(upper);
          }
        }
        if (lower > upper) {
          var temp = lower;
          lower = upper;
          upper = temp;
        }
        if (floating || lower % 1 || upper % 1) {
          var rand = nativeRandom();
          return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
        }
        return baseRandom(lower, upper);
      }
      var camelCase = createCompounder(function(result2, word, index2) {
        word = word.toLowerCase();
        return result2 + (index2 ? capitalize(word) : word);
      });
      function capitalize(string) {
        return upperFirst(toString2(string).toLowerCase());
      }
      function deburr(string) {
        string = toString2(string);
        return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      function endsWith(string, target, position2) {
        string = toString2(string);
        target = baseToString(target);
        var length = string.length;
        position2 = position2 === undefined$1 ? length : baseClamp(toInteger(position2), 0, length);
        var end = position2;
        position2 -= target.length;
        return position2 >= 0 && string.slice(position2, end) == target;
      }
      function escape2(string) {
        string = toString2(string);
        return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
      }
      function escapeRegExp2(string) {
        string = toString2(string);
        return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
      }
      var kebabCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? "-" : "") + word.toLowerCase();
      });
      var lowerCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + word.toLowerCase();
      });
      var lowerFirst = createCaseFirst("toLowerCase");
      function pad2(string, length, chars) {
        string = toString2(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        if (!length || strLength >= length) {
          return string;
        }
        var mid = (length - strLength) / 2;
        return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
      }
      function padEnd(string, length, chars) {
        string = toString2(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
      }
      function padStart(string, length, chars) {
        string = toString2(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
      }
      function parseInt2(string, radix, guard) {
        if (guard || radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        return nativeParseInt(toString2(string).replace(reTrimStart, ""), radix || 0);
      }
      function repeat2(string, n10, guard) {
        if (guard ? isIterateeCall(string, n10, guard) : n10 === undefined$1) {
          n10 = 1;
        } else {
          n10 = toInteger(n10);
        }
        return baseRepeat(toString2(string), n10);
      }
      function replace2() {
        var args = arguments, string = toString2(args[0]);
        return args.length < 3 ? string : string.replace(args[1], args[2]);
      }
      var snakeCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? "_" : "") + word.toLowerCase();
      });
      function split(string, separator, limit) {
        if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
          separator = limit = undefined$1;
        }
        limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
        if (!limit) {
          return [];
        }
        string = toString2(string);
        if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
          separator = baseToString(separator);
          if (!separator && hasUnicode(string)) {
            return castSlice(stringToArray(string), 0, limit);
          }
        }
        return string.split(separator, limit);
      }
      var startCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + upperFirst(word);
      });
      function startsWith(string, target, position2) {
        string = toString2(string);
        position2 = position2 == null ? 0 : baseClamp(toInteger(position2), 0, string.length);
        target = baseToString(target);
        return string.slice(position2, position2 + target.length) == target;
      }
      function template(string, options2, guard) {
        var settings = lodash2.templateSettings;
        if (guard && isIterateeCall(string, options2, guard)) {
          options2 = undefined$1;
        }
        string = toString2(string);
        options2 = assignInWith({}, options2, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options2.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys2(imports), importsValues = baseValues(imports, importsKeys);
        var isEscaping, isEvaluating, index2 = 0, interpolate = options2.interpolate || reNoMatch, source = "__p += '";
        var reDelimiters = RegExp2(
          (options2.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options2.evaluate || reNoMatch).source + "|$",
          "g"
        );
        var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options2, "sourceURL") ? (options2.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
        string.replace(reDelimiters, function(match2, escapeValue, interpolateValue2, esTemplateValue, evaluateValue, offset2) {
          interpolateValue2 || (interpolateValue2 = esTemplateValue);
          source += string.slice(index2, offset2).replace(reUnescapedString, escapeStringChar);
          if (escapeValue) {
            isEscaping = true;
            source += "' +\n__e(" + escapeValue + ") +\n'";
          }
          if (evaluateValue) {
            isEvaluating = true;
            source += "';\n" + evaluateValue + ";\n__p += '";
          }
          if (interpolateValue2) {
            source += "' +\n((__t = (" + interpolateValue2 + ")) == null ? '' : __t) +\n'";
          }
          index2 = offset2 + match2.length;
          return match2;
        });
        source += "';\n";
        var variable = hasOwnProperty2.call(options2, "variable") && options2.variable;
        if (!variable) {
          source = "with (obj) {\n" + source + "\n}\n";
        } else if (reForbiddenIdentifierChars.test(variable)) {
          throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
        }
        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
        source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
        var result2 = attempt(function() {
          return Function2(importsKeys, sourceURL + "return " + source).apply(undefined$1, importsValues);
        });
        result2.source = source;
        if (isError(result2)) {
          throw result2;
        }
        return result2;
      }
      function toLower(value2) {
        return toString2(value2).toLowerCase();
      }
      function toUpper(value2) {
        return toString2(value2).toUpperCase();
      }
      function trim(string, chars, guard) {
        string = toString2(string);
        if (string && (guard || chars === undefined$1)) {
          return baseTrim(string);
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start, end).join("");
      }
      function trimEnd(string, chars, guard) {
        string = toString2(string);
        if (string && (guard || chars === undefined$1)) {
          return string.slice(0, trimmedEndIndex(string) + 1);
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
        return castSlice(strSymbols, 0, end).join("");
      }
      function trimStart(string, chars, guard) {
        string = toString2(string);
        if (string && (guard || chars === undefined$1)) {
          return string.replace(reTrimStart, "");
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
        return castSlice(strSymbols, start).join("");
      }
      function truncate(string, options2) {
        var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
        if (isObject2(options2)) {
          var separator = "separator" in options2 ? options2.separator : separator;
          length = "length" in options2 ? toInteger(options2.length) : length;
          omission = "omission" in options2 ? baseToString(options2.omission) : omission;
        }
        string = toString2(string);
        var strLength = string.length;
        if (hasUnicode(string)) {
          var strSymbols = stringToArray(string);
          strLength = strSymbols.length;
        }
        if (length >= strLength) {
          return string;
        }
        var end = length - stringSize(omission);
        if (end < 1) {
          return omission;
        }
        var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
        if (separator === undefined$1) {
          return result2 + omission;
        }
        if (strSymbols) {
          end += result2.length - end;
        }
        if (isRegExp(separator)) {
          if (string.slice(end).search(separator)) {
            var match2, substring = result2;
            if (!separator.global) {
              separator = RegExp2(separator.source, toString2(reFlags.exec(separator)) + "g");
            }
            separator.lastIndex = 0;
            while (match2 = separator.exec(substring)) {
              var newEnd = match2.index;
            }
            result2 = result2.slice(0, newEnd === undefined$1 ? end : newEnd);
          }
        } else if (string.indexOf(baseToString(separator), end) != end) {
          var index2 = result2.lastIndexOf(separator);
          if (index2 > -1) {
            result2 = result2.slice(0, index2);
          }
        }
        return result2 + omission;
      }
      function unescape(string) {
        string = toString2(string);
        return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
      }
      var upperCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + word.toUpperCase();
      });
      var upperFirst = createCaseFirst("toUpperCase");
      function words(string, pattern, guard) {
        string = toString2(string);
        pattern = guard ? undefined$1 : pattern;
        if (pattern === undefined$1) {
          return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
        }
        return string.match(pattern) || [];
      }
      var attempt = baseRest(function(func, args) {
        try {
          return apply(func, undefined$1, args);
        } catch (e3) {
          return isError(e3) ? e3 : new Error2(e3);
        }
      });
      var bindAll = flatRest(function(object, methodNames) {
        arrayEach(methodNames, function(key) {
          key = toKey(key);
          baseAssignValue(object, key, bind(object[key], object));
        });
        return object;
      });
      function cond(pairs) {
        var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
        pairs = !length ? [] : arrayMap(pairs, function(pair) {
          if (typeof pair[1] != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return [toIteratee(pair[0]), pair[1]];
        });
        return baseRest(function(args) {
          var index2 = -1;
          while (++index2 < length) {
            var pair = pairs[index2];
            if (apply(pair[0], this, args)) {
              return apply(pair[1], this, args);
            }
          }
        });
      }
      function conforms(source) {
        return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
      }
      function constant(value2) {
        return function() {
          return value2;
        };
      }
      function defaultTo(value2, defaultValue) {
        return value2 == null || value2 !== value2 ? defaultValue : value2;
      }
      var flow = createFlow();
      var flowRight = createFlow(true);
      function identity(value2) {
        return value2;
      }
      function iteratee(func) {
        return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
      }
      function matches(source) {
        return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
      }
      function matchesProperty(path, srcValue) {
        return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
      }
      var method = baseRest(function(path, args) {
        return function(object) {
          return baseInvoke(object, path, args);
        };
      });
      var methodOf = baseRest(function(object, args) {
        return function(path) {
          return baseInvoke(object, path, args);
        };
      });
      function mixin(object, source, options2) {
        var props = keys2(source), methodNames = baseFunctions(source, props);
        if (options2 == null && !(isObject2(source) && (methodNames.length || !props.length))) {
          options2 = source;
          source = object;
          object = this;
          methodNames = baseFunctions(source, keys2(source));
        }
        var chain2 = !(isObject2(options2) && "chain" in options2) || !!options2.chain, isFunc = isFunction2(object);
        arrayEach(methodNames, function(methodName) {
          var func = source[methodName];
          object[methodName] = func;
          if (isFunc) {
            object.prototype[methodName] = function() {
              var chainAll = this.__chain__;
              if (chain2 || chainAll) {
                var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                actions.push({ "func": func, "args": arguments, "thisArg": object });
                result2.__chain__ = chainAll;
                return result2;
              }
              return func.apply(object, arrayPush([this.value()], arguments));
            };
          }
        });
        return object;
      }
      function noConflict() {
        if (root._ === this) {
          root._ = oldDash;
        }
        return this;
      }
      function noop3() {
      }
      function nthArg(n10) {
        n10 = toInteger(n10);
        return baseRest(function(args) {
          return baseNth(args, n10);
        });
      }
      var over = createOver(arrayMap);
      var overEvery = createOver(arrayEvery);
      var overSome = createOver(arraySome);
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      function propertyOf(object) {
        return function(path) {
          return object == null ? undefined$1 : baseGet(object, path);
        };
      }
      var range = createRange();
      var rangeRight = createRange(true);
      function stubArray() {
        return [];
      }
      function stubFalse() {
        return false;
      }
      function stubObject() {
        return {};
      }
      function stubString() {
        return "";
      }
      function stubTrue() {
        return true;
      }
      function times(n10, iteratee2) {
        n10 = toInteger(n10);
        if (n10 < 1 || n10 > MAX_SAFE_INTEGER) {
          return [];
        }
        var index2 = MAX_ARRAY_LENGTH, length = nativeMin(n10, MAX_ARRAY_LENGTH);
        iteratee2 = getIteratee(iteratee2);
        n10 -= MAX_ARRAY_LENGTH;
        var result2 = baseTimes(length, iteratee2);
        while (++index2 < n10) {
          iteratee2(index2);
        }
        return result2;
      }
      function toPath(value2) {
        if (isArray2(value2)) {
          return arrayMap(value2, toKey);
        }
        return isSymbol(value2) ? [value2] : copyArray(stringToPath(toString2(value2)));
      }
      function uniqueId(prefix) {
        var id2 = ++idCounter;
        return toString2(prefix) + id2;
      }
      var add3 = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0);
      var ceil2 = createRound("ceil");
      var divide = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1);
      var floor2 = createRound("floor");
      function max2(array) {
        return array && array.length ? baseExtremum(array, identity, baseGt) : undefined$1;
      }
      function maxBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined$1;
      }
      function mean(array) {
        return baseMean(array, identity);
      }
      function meanBy(array, iteratee2) {
        return baseMean(array, getIteratee(iteratee2, 2));
      }
      function min2(array) {
        return array && array.length ? baseExtremum(array, identity, baseLt) : undefined$1;
      }
      function minBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined$1;
      }
      var multiply2 = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1);
      var round2 = createRound("round");
      var subtract = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum2(array) {
        return array && array.length ? baseSum(array, identity) : 0;
      }
      function sumBy(array, iteratee2) {
        return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
      }
      lodash2.after = after;
      lodash2.ary = ary;
      lodash2.assign = assign;
      lodash2.assignIn = assignIn;
      lodash2.assignInWith = assignInWith;
      lodash2.assignWith = assignWith;
      lodash2.at = at;
      lodash2.before = before;
      lodash2.bind = bind;
      lodash2.bindAll = bindAll;
      lodash2.bindKey = bindKey;
      lodash2.castArray = castArray;
      lodash2.chain = chain;
      lodash2.chunk = chunk;
      lodash2.compact = compact;
      lodash2.concat = concat;
      lodash2.cond = cond;
      lodash2.conforms = conforms;
      lodash2.constant = constant;
      lodash2.countBy = countBy;
      lodash2.create = create2;
      lodash2.curry = curry;
      lodash2.curryRight = curryRight;
      lodash2.debounce = debounce;
      lodash2.defaults = defaults;
      lodash2.defaultsDeep = defaultsDeep;
      lodash2.defer = defer;
      lodash2.delay = delay;
      lodash2.difference = difference;
      lodash2.differenceBy = differenceBy;
      lodash2.differenceWith = differenceWith;
      lodash2.drop = drop;
      lodash2.dropRight = dropRight;
      lodash2.dropRightWhile = dropRightWhile;
      lodash2.dropWhile = dropWhile;
      lodash2.fill = fill;
      lodash2.filter = filter;
      lodash2.flatMap = flatMap;
      lodash2.flatMapDeep = flatMapDeep;
      lodash2.flatMapDepth = flatMapDepth;
      lodash2.flatten = flatten2;
      lodash2.flattenDeep = flattenDeep;
      lodash2.flattenDepth = flattenDepth;
      lodash2.flip = flip2;
      lodash2.flow = flow;
      lodash2.flowRight = flowRight;
      lodash2.fromPairs = fromPairs;
      lodash2.functions = functions;
      lodash2.functionsIn = functionsIn;
      lodash2.groupBy = groupBy;
      lodash2.initial = initial2;
      lodash2.intersection = intersection2;
      lodash2.intersectionBy = intersectionBy;
      lodash2.intersectionWith = intersectionWith;
      lodash2.invert = invert;
      lodash2.invertBy = invertBy;
      lodash2.invokeMap = invokeMap;
      lodash2.iteratee = iteratee;
      lodash2.keyBy = keyBy;
      lodash2.keys = keys2;
      lodash2.keysIn = keysIn;
      lodash2.map = map3;
      lodash2.mapKeys = mapKeys;
      lodash2.mapValues = mapValues;
      lodash2.matches = matches;
      lodash2.matchesProperty = matchesProperty;
      lodash2.memoize = memoize2;
      lodash2.merge = merge;
      lodash2.mergeWith = mergeWith;
      lodash2.method = method;
      lodash2.methodOf = methodOf;
      lodash2.mixin = mixin;
      lodash2.negate = negate;
      lodash2.nthArg = nthArg;
      lodash2.omit = omit2;
      lodash2.omitBy = omitBy;
      lodash2.once = once;
      lodash2.orderBy = orderBy2;
      lodash2.over = over;
      lodash2.overArgs = overArgs;
      lodash2.overEvery = overEvery;
      lodash2.overSome = overSome;
      lodash2.partial = partial;
      lodash2.partialRight = partialRight;
      lodash2.partition = partition;
      lodash2.pick = pick;
      lodash2.pickBy = pickBy;
      lodash2.property = property;
      lodash2.propertyOf = propertyOf;
      lodash2.pull = pull;
      lodash2.pullAll = pullAll;
      lodash2.pullAllBy = pullAllBy;
      lodash2.pullAllWith = pullAllWith;
      lodash2.pullAt = pullAt;
      lodash2.range = range;
      lodash2.rangeRight = rangeRight;
      lodash2.rearg = rearg;
      lodash2.reject = reject;
      lodash2.remove = remove;
      lodash2.rest = rest;
      lodash2.reverse = reverse;
      lodash2.sampleSize = sampleSize;
      lodash2.set = set4;
      lodash2.setWith = setWith;
      lodash2.shuffle = shuffle;
      lodash2.slice = slice3;
      lodash2.sortBy = sortBy;
      lodash2.sortedUniq = sortedUniq;
      lodash2.sortedUniqBy = sortedUniqBy;
      lodash2.split = split;
      lodash2.spread = spread;
      lodash2.tail = tail;
      lodash2.take = take2;
      lodash2.takeRight = takeRight;
      lodash2.takeRightWhile = takeRightWhile;
      lodash2.takeWhile = takeWhile;
      lodash2.tap = tap;
      lodash2.throttle = throttle2;
      lodash2.thru = thru;
      lodash2.toArray = toArray2;
      lodash2.toPairs = toPairs;
      lodash2.toPairsIn = toPairsIn;
      lodash2.toPath = toPath;
      lodash2.toPlainObject = toPlainObject;
      lodash2.transform = transform2;
      lodash2.unary = unary;
      lodash2.union = union;
      lodash2.unionBy = unionBy;
      lodash2.unionWith = unionWith;
      lodash2.uniq = uniq;
      lodash2.uniqBy = uniqBy;
      lodash2.uniqWith = uniqWith;
      lodash2.unset = unset;
      lodash2.unzip = unzip;
      lodash2.unzipWith = unzipWith;
      lodash2.update = update;
      lodash2.updateWith = updateWith;
      lodash2.values = values6;
      lodash2.valuesIn = valuesIn;
      lodash2.without = without;
      lodash2.words = words;
      lodash2.wrap = wrap;
      lodash2.xor = xor;
      lodash2.xorBy = xorBy;
      lodash2.xorWith = xorWith;
      lodash2.zip = zip;
      lodash2.zipObject = zipObject;
      lodash2.zipObjectDeep = zipObjectDeep;
      lodash2.zipWith = zipWith;
      lodash2.entries = toPairs;
      lodash2.entriesIn = toPairsIn;
      lodash2.extend = assignIn;
      lodash2.extendWith = assignInWith;
      mixin(lodash2, lodash2);
      lodash2.add = add3;
      lodash2.attempt = attempt;
      lodash2.camelCase = camelCase;
      lodash2.capitalize = capitalize;
      lodash2.ceil = ceil2;
      lodash2.clamp = clamp2;
      lodash2.clone = clone3;
      lodash2.cloneDeep = cloneDeep;
      lodash2.cloneDeepWith = cloneDeepWith;
      lodash2.cloneWith = cloneWith;
      lodash2.conformsTo = conformsTo;
      lodash2.deburr = deburr;
      lodash2.defaultTo = defaultTo;
      lodash2.divide = divide;
      lodash2.endsWith = endsWith;
      lodash2.eq = eq;
      lodash2.escape = escape2;
      lodash2.escapeRegExp = escapeRegExp2;
      lodash2.every = every;
      lodash2.find = find2;
      lodash2.findIndex = findIndex;
      lodash2.findKey = findKey;
      lodash2.findLast = findLast;
      lodash2.findLastIndex = findLastIndex;
      lodash2.findLastKey = findLastKey;
      lodash2.floor = floor2;
      lodash2.forEach = forEach2;
      lodash2.forEachRight = forEachRight;
      lodash2.forIn = forIn;
      lodash2.forInRight = forInRight;
      lodash2.forOwn = forOwn;
      lodash2.forOwnRight = forOwnRight;
      lodash2.get = get3;
      lodash2.gt = gt;
      lodash2.gte = gte;
      lodash2.has = has3;
      lodash2.hasIn = hasIn;
      lodash2.head = head;
      lodash2.identity = identity;
      lodash2.includes = includes;
      lodash2.indexOf = indexOf2;
      lodash2.inRange = inRange;
      lodash2.invoke = invoke;
      lodash2.isArguments = isArguments;
      lodash2.isArray = isArray2;
      lodash2.isArrayBuffer = isArrayBuffer;
      lodash2.isArrayLike = isArrayLike;
      lodash2.isArrayLikeObject = isArrayLikeObject;
      lodash2.isBoolean = isBoolean;
      lodash2.isBuffer = isBuffer;
      lodash2.isDate = isDate2;
      lodash2.isElement = isElement;
      lodash2.isEmpty = isEmpty2;
      lodash2.isEqual = isEqual2;
      lodash2.isEqualWith = isEqualWith;
      lodash2.isError = isError;
      lodash2.isFinite = isFinite2;
      lodash2.isFunction = isFunction2;
      lodash2.isInteger = isInteger;
      lodash2.isLength = isLength;
      lodash2.isMap = isMap;
      lodash2.isMatch = isMatch;
      lodash2.isMatchWith = isMatchWith;
      lodash2.isNaN = isNaN2;
      lodash2.isNative = isNative;
      lodash2.isNil = isNil2;
      lodash2.isNull = isNull;
      lodash2.isNumber = isNumber2;
      lodash2.isObject = isObject2;
      lodash2.isObjectLike = isObjectLike;
      lodash2.isPlainObject = isPlainObject2;
      lodash2.isRegExp = isRegExp;
      lodash2.isSafeInteger = isSafeInteger;
      lodash2.isSet = isSet;
      lodash2.isString = isString2;
      lodash2.isSymbol = isSymbol;
      lodash2.isTypedArray = isTypedArray;
      lodash2.isUndefined = isUndefined;
      lodash2.isWeakMap = isWeakMap;
      lodash2.isWeakSet = isWeakSet;
      lodash2.join = join;
      lodash2.kebabCase = kebabCase;
      lodash2.last = last2;
      lodash2.lastIndexOf = lastIndexOf;
      lodash2.lowerCase = lowerCase;
      lodash2.lowerFirst = lowerFirst;
      lodash2.lt = lt;
      lodash2.lte = lte;
      lodash2.max = max2;
      lodash2.maxBy = maxBy;
      lodash2.mean = mean;
      lodash2.meanBy = meanBy;
      lodash2.min = min2;
      lodash2.minBy = minBy;
      lodash2.stubArray = stubArray;
      lodash2.stubFalse = stubFalse;
      lodash2.stubObject = stubObject;
      lodash2.stubString = stubString;
      lodash2.stubTrue = stubTrue;
      lodash2.multiply = multiply2;
      lodash2.nth = nth;
      lodash2.noConflict = noConflict;
      lodash2.noop = noop3;
      lodash2.now = now2;
      lodash2.pad = pad2;
      lodash2.padEnd = padEnd;
      lodash2.padStart = padStart;
      lodash2.parseInt = parseInt2;
      lodash2.random = random;
      lodash2.reduce = reduce;
      lodash2.reduceRight = reduceRight;
      lodash2.repeat = repeat2;
      lodash2.replace = replace2;
      lodash2.result = result;
      lodash2.round = round2;
      lodash2.runInContext = runInContext2;
      lodash2.sample = sample;
      lodash2.size = size;
      lodash2.snakeCase = snakeCase;
      lodash2.some = some;
      lodash2.sortedIndex = sortedIndex;
      lodash2.sortedIndexBy = sortedIndexBy;
      lodash2.sortedIndexOf = sortedIndexOf;
      lodash2.sortedLastIndex = sortedLastIndex;
      lodash2.sortedLastIndexBy = sortedLastIndexBy;
      lodash2.sortedLastIndexOf = sortedLastIndexOf;
      lodash2.startCase = startCase;
      lodash2.startsWith = startsWith;
      lodash2.subtract = subtract;
      lodash2.sum = sum2;
      lodash2.sumBy = sumBy;
      lodash2.template = template;
      lodash2.times = times;
      lodash2.toFinite = toFinite;
      lodash2.toInteger = toInteger;
      lodash2.toLength = toLength;
      lodash2.toLower = toLower;
      lodash2.toNumber = toNumber;
      lodash2.toSafeInteger = toSafeInteger;
      lodash2.toString = toString2;
      lodash2.toUpper = toUpper;
      lodash2.trim = trim;
      lodash2.trimEnd = trimEnd;
      lodash2.trimStart = trimStart;
      lodash2.truncate = truncate;
      lodash2.unescape = unescape;
      lodash2.uniqueId = uniqueId;
      lodash2.upperCase = upperCase;
      lodash2.upperFirst = upperFirst;
      lodash2.each = forEach2;
      lodash2.eachRight = forEachRight;
      lodash2.first = head;
      mixin(lodash2, function() {
        var source = {};
        baseForOwn(lodash2, function(func, methodName) {
          if (!hasOwnProperty2.call(lodash2.prototype, methodName)) {
            source[methodName] = func;
          }
        });
        return source;
      }(), { "chain": false });
      lodash2.VERSION = VERSION;
      arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
        lodash2[methodName].placeholder = lodash2;
      });
      arrayEach(["drop", "take"], function(methodName, index2) {
        LazyWrapper.prototype[methodName] = function(n10) {
          n10 = n10 === undefined$1 ? 1 : nativeMax(toInteger(n10), 0);
          var result2 = this.__filtered__ && !index2 ? new LazyWrapper(this) : this.clone();
          if (result2.__filtered__) {
            result2.__takeCount__ = nativeMin(n10, result2.__takeCount__);
          } else {
            result2.__views__.push({
              "size": nativeMin(n10, MAX_ARRAY_LENGTH),
              "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
            });
          }
          return result2;
        };
        LazyWrapper.prototype[methodName + "Right"] = function(n10) {
          return this.reverse()[methodName](n10).reverse();
        };
      });
      arrayEach(["filter", "map", "takeWhile"], function(methodName, index2) {
        var type = index2 + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function(iteratee2) {
          var result2 = this.clone();
          result2.__iteratees__.push({
            "iteratee": getIteratee(iteratee2, 3),
            "type": type
          });
          result2.__filtered__ = result2.__filtered__ || isFilter;
          return result2;
        };
      });
      arrayEach(["head", "last"], function(methodName, index2) {
        var takeName = "take" + (index2 ? "Right" : "");
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      });
      arrayEach(["initial", "tail"], function(methodName, index2) {
        var dropName = "drop" + (index2 ? "" : "Right");
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      });
      LazyWrapper.prototype.compact = function() {
        return this.filter(identity);
      };
      LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      };
      LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      };
      LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
        if (typeof path == "function") {
          return new LazyWrapper(this);
        }
        return this.map(function(value2) {
          return baseInvoke(value2, path, args);
        });
      });
      LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate(getIteratee(predicate)));
      };
      LazyWrapper.prototype.slice = function(start, end) {
        start = toInteger(start);
        var result2 = this;
        if (result2.__filtered__ && (start > 0 || end < 0)) {
          return new LazyWrapper(result2);
        }
        if (start < 0) {
          result2 = result2.takeRight(-start);
        } else if (start) {
          result2 = result2.drop(start);
        }
        if (end !== undefined$1) {
          end = toInteger(end);
          result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
        }
        return result2;
      };
      LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      };
      LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH);
      };
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        if (!lodashFunc) {
          return;
        }
        lodash2.prototype[methodName] = function() {
          var value2 = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value2 instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value2);
          var interceptor = function(value3) {
            var result3 = lodashFunc.apply(lodash2, arrayPush([value3], args));
            return isTaker && chainAll ? result3[0] : result3;
          };
          if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
            isLazy = useLazy = false;
          }
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy) {
            value2 = onlyLazy ? value2 : new LazyWrapper(this);
            var result2 = func.apply(value2, args);
            result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined$1 });
            return new LodashWrapper(result2, chainAll);
          }
          if (isUnwrapped && onlyLazy) {
            return func.apply(this, args);
          }
          result2 = this.thru(interceptor);
          return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
        };
      });
      arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
        var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash2.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value2 = this.value();
            return func.apply(isArray2(value2) ? value2 : [], args);
          }
          return this[chainName](function(value3) {
            return func.apply(isArray2(value3) ? value3 : [], args);
          });
        };
      });
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var lodashFunc = lodash2[methodName];
        if (lodashFunc) {
          var key = lodashFunc.name + "";
          if (!hasOwnProperty2.call(realNames, key)) {
            realNames[key] = [];
          }
          realNames[key].push({ "name": methodName, "func": lodashFunc });
        }
      });
      realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
        "name": "wrapper",
        "func": undefined$1
      }];
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;
      lodash2.prototype.at = wrapperAt;
      lodash2.prototype.chain = wrapperChain;
      lodash2.prototype.commit = wrapperCommit;
      lodash2.prototype.next = wrapperNext;
      lodash2.prototype.plant = wrapperPlant;
      lodash2.prototype.reverse = wrapperReverse;
      lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue;
      lodash2.prototype.first = lodash2.prototype.head;
      if (symIterator) {
        lodash2.prototype[symIterator] = wrapperToIterator;
      }
      return lodash2;
    };
    var _2 = runInContext();
    if (freeModule) {
      (freeModule.exports = _2)._ = _2;
      freeExports._ = _2;
    } else {
      root._ = _2;
    }
  }).call(commonjsGlobal);
})(lodash, lodash.exports);
var lodashExports = lodash.exports;
const Header = ({ data: data2 }) => {
  if (lodashExports.isArray(data2 == null ? void 0 : data2.value)) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        style: {
          backgroundColor: data2 == null ? void 0 : data2.backgroundColor,
          color: data2 == null ? void 0 : data2.color,
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          flexDirection: "column",
          height: "100%"
        },
        children: data2 == null ? void 0 : data2.value.map((th2) => {
          if (th2 == "")
            return /* @__PURE__ */ jsxRuntimeExports.jsx("br", {});
          return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { lineHeight: "96%" }, children: th2 });
        })
      }
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { backgroundColor: data2 == null ? void 0 : data2.backgroundColor, color: data2 == null ? void 0 : data2.color }, children: data2 == null ? void 0 : data2.value });
};
const GridLabel = ({ data: data2 }) => {
  var _a, _b, _c, _d, _e2, _f;
  const labelRef = reactExports.useRef();
  const { socket } = useAppData();
  const [isEditable, setisEditable] = reactExports.useState(false);
  reactExports.useEffect(() => {
    var _a2;
    if (data2.focused) {
      (_a2 = labelRef == null ? void 0 : labelRef.current) == null ? void 0 : _a2.focus();
    }
  }, [data2.focused]);
  reactExports.useEffect(() => {
  }, [isEditable]);
  const { Event } = (_a = data2 == null ? void 0 : data2.typeObj) == null ? void 0 : _a.Properties;
  const fontProperties = (data2 == null ? void 0 : data2.cellFont) && ((_b = data2 == null ? void 0 : data2.cellFont) == null ? void 0 : _b.Properties);
  const handleBlur = () => {
    setisEditable(false);
  };
  const handleDoubleClick = () => {
    setisEditable(true);
  };
  let fontStyles = {
    fontFamily: fontProperties == null ? void 0 : fontProperties.PName,
    fontSize: !(fontProperties == null ? void 0 : fontProperties.Size) ? "12px" : "12px",
    // fontSize: !fontProperties?.Size ? '11px' : '12px',
    textDecoration: !(fontProperties == null ? void 0 : fontProperties.Underline) ? "none" : (fontProperties == null ? void 0 : fontProperties.Underline) == 1 ? "underline" : "none",
    fontStyle: !(fontProperties == null ? void 0 : fontProperties.Italic) ? "none" : (fontProperties == null ? void 0 : fontProperties.Italic) == 1 ? "italic" : "none",
    fontWeight: !(fontProperties == null ? void 0 : fontProperties.Weight) ? 0 : fontProperties == null ? void 0 : fontProperties.Weight
  };
  const handleKeyPress = (e3) => {
    var _a2, _b2, _c2, _d2;
    const isAltPressed = (e3 == null ? void 0 : e3.altKey) ? 4 : 0;
    const isCtrlPressed = (e3 == null ? void 0 : e3.ctrlKey) ? 2 : 0;
    const isShiftPressed = (e3 == null ? void 0 : e3.shiftKey) ? 1 : 0;
    const charCode = (_a2 = e3 == null ? void 0 : e3.key) == null ? void 0 : _a2.charCodeAt(0);
    let shiftState = isAltPressed + isCtrlPressed + isShiftPressed;
    const exists = (_d2 = (_c2 = (_b2 = data2 == null ? void 0 : data2.typeObj) == null ? void 0 : _b2.Properties) == null ? void 0 : _c2.Event) == null ? void 0 : _d2.some((item) => item[0] === "KeyPress");
    if (!exists)
      return;
    console.log(
      JSON.stringify({
        Event: {
          EventName: "KeyPress",
          ID: data2 == null ? void 0 : data2.ID,
          Info: [e3.key, charCode, e3.keyCode, shiftState]
        }
      })
    );
    socket.send(
      JSON.stringify({
        Event: {
          EventName: "KeyPress",
          ID: data2 == null ? void 0 : data2.ID,
          Info: [e3.key, charCode, e3.keyCode, shiftState]
        }
      })
    );
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: !isEditable ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      ref: labelRef,
      style: {
        backgroundColor: data2 == null ? void 0 : data2.backgroundColor,
        outline: 0,
        ...fontStyles,
        textAlign: (_d = (_c = data2 == null ? void 0 : data2.typeObj) == null ? void 0 : _c.Properties) == null ? void 0 : _d.Justify,
        paddingRight: "5px"
      },
      onKeyDown: (e3) => {
        e3.stopPropagation();
        handleKeyPress(e3);
      },
      onDoubleClick: handleDoubleClick,
      onBlur: handleBlur,
      id: data2.gridId,
      children: data2 == null ? void 0 : data2.formattedValue
    }
  ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      style: {
        backgroundColor: data2 == null ? void 0 : data2.backgroundColor,
        outline: 0,
        ...fontStyles,
        textAlign: (_f = (_e2 = data2 == null ? void 0 : data2.typeObj) == null ? void 0 : _e2.Properties) == null ? void 0 : _f.Justify,
        paddingRight: "5px"
      },
      onKeyDown: (e3) => {
        e3.stopPropagation();
        handleKeyPress(e3);
      },
      onBlur: handleBlur,
      ref: labelRef,
      onMouseDown: (e3) => {
        var _a2;
        handleMouseDown(e3, socket, Event, (_a2 = data2 == null ? void 0 : data2.typeObj) == null ? void 0 : _a2.ID);
      },
      onMouseUp: (e3) => {
        var _a2;
        handleMouseUp(e3, socket, Event, (_a2 = data2 == null ? void 0 : data2.typeObj) == null ? void 0 : _a2.ID);
      },
      onMouseEnter: (e3) => {
        var _a2;
        handleMouseEnter(e3, socket, Event, (_a2 = data2 == null ? void 0 : data2.typeObj) == null ? void 0 : _a2.ID);
      },
      onMouseMove: (e3) => {
        var _a2;
        handleMouseMove(e3, socket, Event, (_a2 = data2 == null ? void 0 : data2.typeObj) == null ? void 0 : _a2.ID);
      },
      onMouseLeave: (e3) => {
        var _a2;
        handleMouseLeave(e3, socket, Event, (_a2 = data2 == null ? void 0 : data2.typeObj) == null ? void 0 : _a2.ID);
      },
      onWheel: (e3) => {
        var _a2;
        handleMouseWheel(e3, socket, Event, (_a2 = data2 == null ? void 0 : data2.typeObj) == null ? void 0 : _a2.ID);
      },
      onDoubleClick: (e3) => {
        var _a2;
        handleMouseDoubleClick(e3, socket, Event, (_a2 = data2 == null ? void 0 : data2.typeObj) == null ? void 0 : _a2.ID);
      },
      children: (data2 == null ? void 0 : data2.focused) ? data2 == null ? void 0 : data2.value : data2 == null ? void 0 : data2.formattedValue
    }
  ) });
};
const Component = ({ data: data2 }) => {
  if ((data2 == null ? void 0 : data2.type) == "Edit")
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GridEdit, { data: data2 });
  else if ((data2 == null ? void 0 : data2.type) == "Button")
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GridButton, { data: data2 });
  else if ((data2 == null ? void 0 : data2.type) == "cell" || "rowTitle")
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GridCell, { data: data2 });
  else if ((data2 == null ? void 0 : data2.type) == "header")
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { data: data2 });
  else if ((data2 == null ? void 0 : data2.type) == "Combo")
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GridSelect, { data: data2 });
  else if ((data2 == null ? void 0 : data2.type) == "Label")
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GridLabel, { data: data2 });
};
const Grid = ({ data: data2 }) => {
  const gridId = data2 == null ? void 0 : data2.ID;
  const {
    findDesiredData,
    socket,
    proceed,
    setProceed,
    proceedEventArray,
    setProceedEventArray,
    findAggregatedPropertiesData,
    handleData
  } = useAppData();
  const [eventId, setEventId] = reactExports.useState(null);
  const dimensions = useResizeObserver(
    document.getElementById(extractStringUntilLastPeriod(data2 == null ? void 0 : data2.ID))
  );
  const gridRef = reactExports.useRef(null);
  const {
    Size: Size2,
    Values,
    Input,
    ColTitles,
    RowTitles,
    CellWidths,
    CellHeights,
    Visible,
    CurCell,
    CellTypes,
    ShowInput,
    FormattedValues,
    BCol,
    CellFonts,
    ColTitleBCol,
    ColTitleFCol,
    TitleHeight,
    TitleWidth,
    FormatString,
    VScroll = 0,
    HScroll = 0,
    Attach,
    Event,
    CSS
  } = data2 == null ? void 0 : data2.Properties;
  const [height, setHeight] = reactExports.useState(Size2[0]);
  const [width, setWidth] = reactExports.useState(Size2[1]);
  const [rows, setRows] = reactExports.useState(0);
  const [columns, setColumns] = reactExports.useState(0);
  const [selectedRow, setSelectedRow] = reactExports.useState(
    !CurCell ? (ColTitles == null ? void 0 : ColTitles.length) > 0 ? 1 : 0 : CurCell[0]
  );
  const [selectedColumn, setSelectedColumn] = reactExports.useState(
    !CurCell ? TitleWidth === 0 ? 1 : 0 : CurCell[1]
  );
  reactExports.useEffect(() => {
    if (CurCell) {
      let defaultRow = !CurCell ? (RowTitles == null ? void 0 : RowTitles.length) > 0 ? 1 : 0 : CurCell[0];
      let defaultCol = !CurCell ? TitleWidth === 0 ? 1 : 0 : CurCell[1];
      setSelectedRow((prev) => prev !== CurCell[0] ? defaultRow : prev);
      setSelectedColumn((prev) => prev !== CurCell[1] ? defaultCol : prev);
      localStorage.setItem(
        data2 == null ? void 0 : data2.ID,
        JSON.stringify({
          Event: {
            CurCell: [defaultRow, defaultCol]
          }
        })
      );
    }
  }, [CurCell]);
  reactExports.useEffect(() => {
    if (localStorage.getItem(data2.ID)) {
      const { Event: Event2 } = JSON.parse(localStorage.getItem(data2.ID));
      if (Event2.CurCell) {
        handleData(
          {
            ID: data2 == null ? void 0 : data2.ID,
            Properties: {
              CurCell: [Event2.CurCell[0], Event2.CurCell[1]]
            }
          },
          "WS"
        );
      }
    }
  }, [localStorage.getItem(data2.ID)]);
  const style2 = setStyle$1(data2 == null ? void 0 : data2.Properties);
  reactExports.useEffect(() => {
    if (!Attach)
      return;
    setWidth((dimensions == null ? void 0 : dimensions.width) - 73);
    setHeight((dimensions == null ? void 0 : dimensions.height) - 73);
  }, [dimensions]);
  reactExports.useEffect(() => {
    var _a;
    if (!ColTitles)
      setColumns(((_a = Values[0]) == null ? void 0 : _a.length) + 1);
    else
      setColumns(ColTitles == null ? void 0 : ColTitles.length);
    if (Values)
      setRows((Values == null ? void 0 : Values.length) + 1);
  }, [data2]);
  const handleCellMove = (row, column, mouseClick) => {
    if (column > columns || column <= 0)
      return;
    const isKeyboard = !mouseClick ? 1 : 0;
    const cellChanged = JSON.parse(localStorage.getItem("isChanged"));
    const cellMoveEvent = JSON.stringify({
      Event: {
        ID: data2 == null ? void 0 : data2.ID,
        EventName: "CellMove",
        EventId: eventId,
        Info: [
          row,
          column,
          isKeyboard,
          0,
          mouseClick,
          cellChanged && cellChanged.isChange ? 1 : 0,
          cellChanged && cellChanged ? cellChanged.value : ""
        ]
      }
    });
    const exists = Event && (Event == null ? void 0 : Event.some((item) => item[0] === "CellMove"));
    if (!exists)
      return;
    socket.send(cellMoveEvent);
    localStorage.setItem(
      "isChanged",
      JSON.stringify({
        isChange: false,
        value: ""
      })
    );
  };
  const waitForProceed = (localStorageBool) => {
    return new Promise((resolve) => {
      const checkProceed = () => {
        if (localStorageBool || proceed !== null) {
          if (localStorageBool || proceedEventArray[eventId] === 1) {
            resolve();
            setProceed(false);
            setProceedEventArray((prev) => ({ ...prev, [eventId]: 0 }));
          } else {
            return;
          }
        }
      };
      checkProceed();
    });
  };
  const handleKeyDown = (event) => {
    var _a;
    const isAltPressed = event.altKey ? 4 : 0;
    const isCtrlPressed = event.ctrlKey ? 2 : 0;
    const isShiftPressed = event.shiftKey ? 1 : 0;
    const charCode = event.key.charCodeAt(0);
    const eventId2 = v4();
    setEventId(eventId2);
    let shiftState = isAltPressed + isCtrlPressed + isShiftPressed;
    const parentExists = Event && (Event == null ? void 0 : Event.some((item) => item[0].toLowerCase() === "keypress"));
    let keys2 = Object.keys(data2);
    let childKey;
    const checkArray = keys2.reduce((prev, current2) => {
      var _a2, _b, _c, _d, _e2, _f;
      if ((_c = (_b = (_a2 = data2[current2]) == null ? void 0 : _a2.Properties) == null ? void 0 : _b.Event) == null ? void 0 : _c.some(
        (item) => item[0].toLowerCase() === "keypress"
      ))
        childKey = current2;
      return [
        ...prev,
        (_f = (_e2 = (_d = data2[current2]) == null ? void 0 : _d.Properties) == null ? void 0 : _e2.Event) == null ? void 0 : _f.some(
          (item) => item[0].toLowerCase() === "keypress"
        )
      ];
    }, []);
    const childExists = checkArray.some((item) => item === true);
    const parentKeyPressEvent = JSON.stringify({
      Event: {
        EventName: "KeyPress",
        ID: data2 == null ? void 0 : data2.ID,
        EventID: eventId2,
        Info: [event.key, charCode, event.keyCode, shiftState]
      }
    });
    const keyPressEvent = JSON.stringify({
      Event: {
        EventName: "KeyPress",
        ID: (_a = data2[childKey]) == null ? void 0 : _a.ID,
        EventID: eventId2,
        Info: [event.key, charCode, event.keyCode, shiftState]
      }
    });
    if (parentExists && !!!childExists) {
      socket.send(parentKeyPressEvent);
    }
    if (childExists) {
      socket.send(keyPressEvent);
    }
    const isNavigationKeys = [
      "ArrowRight",
      "ArrowLeft",
      "ArrowUp",
      "ArrowDown"
    ].some((key) => event.key === key);
    if (isNavigationKeys) {
      gridRef.current.focus();
    }
    let localStoragValue = JSON.parse(localStorage.getItem(data2 == null ? void 0 : data2.ID));
    const updatePosition = async () => {
      var _a2, _b, _c, _d, _e2, _f, _g;
      if (event.key === "ArrowRight") {
        if (childExists || parentExists)
          await waitForProceed(localStorage.getItem(eventId2));
        const updatedColumn = Math.min(selectedColumn + 1, !ColTitles ? columns - 1 : columns);
        setSelectedColumn(updatedColumn);
        if (selectedColumn === updatedColumn)
          return;
        if (!localStoragValue) {
          console.log(
            "writing local storage",
            JSON.stringify({
              Event: {
                CurCell: [
                  selectedRow,
                  updatedColumn
                ]
              }
            })
          );
          localStorage.setItem(
            data2 == null ? void 0 : data2.ID,
            JSON.stringify({
              Event: {
                CurCell: [
                  selectedRow,
                  updatedColumn
                ]
              }
            })
          );
        } else {
          console.log(
            JSON.stringify({
              Event: {
                CurCell: [
                  selectedRow,
                  updatedColumn
                ],
                Values: (_a2 = localStoragValue == null ? void 0 : localStoragValue.Event) == null ? void 0 : _a2.Values
              }
            })
          );
          localStorage.setItem(
            data2 == null ? void 0 : data2.ID,
            JSON.stringify({
              Event: {
                CurCell: [
                  selectedRow,
                  updatedColumn
                ],
                Values: (_b = localStoragValue == null ? void 0 : localStoragValue.Event) == null ? void 0 : _b.Values
              }
            })
          );
        }
        handleCellMove(
          selectedRow,
          updatedColumn,
          0
        );
      } else if (event.key === "ArrowLeft") {
        if (childExists || parentExists)
          await waitForProceed(localStorage.getItem(eventId2));
        const updatedColumn = Math.max(selectedColumn - 1, 1);
        setSelectedColumn(updatedColumn);
        if (selectedColumn === updatedColumn)
          return;
        if (!localStoragValue) {
          localStorage.setItem(
            data2 == null ? void 0 : data2.ID,
            JSON.stringify({
              Event: {
                CurCell: [
                  selectedRow,
                  updatedColumn
                ]
              }
            })
          );
        } else {
          localStorage.setItem(
            data2 == null ? void 0 : data2.ID,
            JSON.stringify({
              Event: {
                CurCell: [
                  selectedRow,
                  updatedColumn
                ],
                Values: (_c = localStoragValue == null ? void 0 : localStoragValue.Event) == null ? void 0 : _c.Values
              }
            })
          );
        }
        handleCellMove(
          selectedRow,
          updatedColumn,
          0
        );
      } else if (event.key === "ArrowUp") {
        if (childExists || parentExists)
          await waitForProceed(localStorage.getItem(eventId2));
        const updatedRow = Math.max(selectedRow - 1, 1);
        setSelectedRow(updatedRow);
        if (selectedRow === updatedRow)
          return;
        if (!localStoragValue) {
          localStorage.setItem(
            data2 == null ? void 0 : data2.ID,
            JSON.stringify({
              Event: {
                CurCell: [
                  updatedRow,
                  selectedColumn
                ]
              }
            })
          );
        } else {
          localStorage.setItem(
            data2 == null ? void 0 : data2.ID,
            JSON.stringify({
              Event: {
                CurCell: [
                  updatedRow,
                  selectedColumn
                ],
                Values: (_d = localStoragValue == null ? void 0 : localStoragValue.Event) == null ? void 0 : _d.Values
              }
            })
          );
        }
        handleCellMove(
          updatedRow,
          selectedColumn,
          0
        );
      } else if (event.key === "ArrowDown") {
        if (childExists || parentExists)
          await waitForProceed(localStorage.getItem(eventId2));
        const updatedRow = Math.min(selectedRow + 1, rows - 1);
        setSelectedRow(updatedRow);
        if (selectedRow == rows - 1)
          return;
        if (!localStoragValue) {
          localStorage.setItem(
            data2 == null ? void 0 : data2.ID,
            JSON.stringify({
              Event: {
                CurCell: [
                  updatedRow,
                  selectedColumn
                ]
              }
            })
          );
        } else {
          localStorage.setItem(
            data2 == null ? void 0 : data2.ID,
            JSON.stringify({
              Event: {
                CurCell: [
                  updatedRow,
                  selectedColumn
                ],
                Values: (_e2 = localStoragValue == null ? void 0 : localStoragValue.Event) == null ? void 0 : _e2.Values
              }
            })
          );
        }
        if (selectedRow === updatedRow)
          return;
        handleCellMove(
          updatedRow,
          selectedColumn,
          0
        );
      } else if (event.key === "PageDown") {
        if (childExists || parentExists)
          await waitForProceed(localStorage.getItem(eventId2));
        const demoRow = Math.min(selectedRow + 9, rows - 1);
        setSelectedRow(demoRow);
        if (!localStoragValue) {
          if (selectedRow == rows - 1)
            return;
          localStorage.setItem(
            data2 == null ? void 0 : data2.ID,
            JSON.stringify({
              Event: {
                CurCell: [
                  demoRow,
                  selectedColumn
                ]
              }
            })
          );
        } else {
          if (selectedRow == rows - 1)
            return;
          localStorage.setItem(
            data2 == null ? void 0 : data2.ID,
            JSON.stringify({
              Event: {
                CurCell: [
                  demoRow,
                  selectedColumn
                ],
                Values: (_f = localStoragValue == null ? void 0 : localStoragValue.Event) == null ? void 0 : _f.Values
              }
            })
          );
        }
        handleCellMove(
          demoRow,
          selectedColumn,
          0
        );
      } else if (event.key === "PageUp") {
        if (childExists || parentExists)
          await waitForProceed(localStorage.getItem(eventId2));
        const updatedRow = Math.max(selectedRow - 9, 1);
        setSelectedRow(updatedRow);
        if (!localStoragValue) {
          if (selectedRow == updatedRow)
            return;
          localStorage.setItem(
            data2 == null ? void 0 : data2.ID,
            JSON.stringify({
              Event: {
                CurCell: [
                  updatedRow,
                  selectedColumn
                ]
              }
            })
          );
        } else {
          if (selectedRow == updatedRow)
            return;
          localStorage.setItem(
            data2 == null ? void 0 : data2.ID,
            JSON.stringify({
              Event: {
                CurCell: [
                  updatedRow,
                  selectedColumn
                ],
                Values: (_g = localStoragValue == null ? void 0 : localStoragValue.Event) == null ? void 0 : _g.Values
              }
            })
          );
        }
        handleCellMove(
          updatedRow,
          selectedColumn,
          0
        );
      }
    };
    updatePosition();
  };
  const modifyGridData = () => {
    var _a, _b, _c;
    let data22 = [];
    if (ColTitles) {
      let header = [];
      let emptyobj = {
        value: "",
        type: "header",
        width: !TitleWidth ? 100 : TitleWidth,
        height: !TitleHeight ? 20 : TitleHeight
      };
      TitleWidth === 0 ? null : header.push(emptyobj);
      for (let i16 = 0; i16 < (ColTitles == null ? void 0 : ColTitles.length); i16++) {
        let obj = {
          value: ColTitles[i16],
          type: "header",
          backgroundColor: rgbColor(ColTitleBCol),
          color: rgbColor(ColTitleFCol),
          width: !CellWidths ? 100 : Array.isArray(CellWidths) ? CellWidths[i16] : CellWidths,
          height: !TitleHeight ? 20 : TitleHeight
        };
        header.push(obj);
      }
      data22.push(header);
    } else if (!ColTitles) {
      let headerArray = generateHeader(columns).map((alphabet) => {
        return {
          value: alphabet,
          type: "header",
          width: !TitleWidth ? 100 : TitleWidth,
          height: !TitleHeight ? 20 : TitleHeight
        };
      });
      data22.push(headerArray);
    }
    if (!Input) {
      for (let i16 = 0; i16 < (Values == null ? void 0 : Values.length); i16++) {
        let cellType = CellTypes && CellTypes[i16][0];
        const backgroundColor = BCol && BCol[cellType - 1];
        let body = [];
        let obj = {
          type: "rowTitle",
          value: RowTitles ? RowTitles[i16] : i16 + 1,
          width: RowTitles ? !TitleWidth ? 100 : TitleWidth : 100,
          height: !CellHeights ? 20 : Array.isArray(CellHeights) ? CellHeights[i16] : CellHeights,
          align: "end",
          backgroundColor: rgbColor(backgroundColor)
        };
        TitleWidth == void 0 ? body.push(obj) : TitleWidth == 0 ? null : body.push(obj);
        for (let j2 = 0; j2 <= columns; j2++) {
          if (Values[i16][j2] === void 0)
            continue;
          let obj2 = {
            type: "cell",
            value: Values[i16][j2],
            width: !CellWidths ? 100 : Array.isArray(CellWidths) ? CellWidths[j2] : CellWidths,
            height: !CellHeights ? 20 : Array.isArray(CellHeights) ? CellHeights[j2] : CellHeights,
            align: !isNaN(Values[i16][j2]) ? "end" : "start",
            paddingLeft: !isNaN(parseInt(Values[i16][j2])) ? "0px" : "5px"
          };
          body.push(obj2);
        }
        data22.push(body);
      }
    } else if (Input) {
      for (let i16 = 0; i16 < (Values == null ? void 0 : Values.length); i16++) {
        let body = [];
        let cellType = CellTypes && CellTypes[i16][0];
        const backgroundColor = BCol && BCol[cellType - 1];
        let obj = {
          type: "rowTitle",
          value: RowTitles ? RowTitles[i16] : i16 + 1,
          width: !TitleWidth ? 100 : TitleWidth,
          height: !CellHeights ? 20 : Array.isArray(CellHeights) ? CellHeights[i16] : CellHeights,
          align: "end",
          backgroundColor: rgbColor(backgroundColor)
        };
        TitleWidth == void 0 ? body.push(obj) : TitleWidth == 0 ? null : body.push(obj);
        for (let j2 = 0; j2 < columns; j2++) {
          let cellType2 = CellTypes && CellTypes[i16][j2];
          const type = findAggregatedPropertiesData(
            (Input == null ? void 0 : Input.length) > 1 ? Input && Input[cellType2 - 1] : Input[0]
          );
          const event = ((_a = data22 == null ? void 0 : data22.Properties) == null ? void 0 : _a.Event) && ((_b = data22 == null ? void 0 : data22.Properties) == null ? void 0 : _b.Event);
          const backgroundColor2 = BCol && BCol[cellType2 - 1];
          const cellFont = findDesiredData(
            CellFonts && CellFonts[cellType2 - 1]
          );
          let obj2 = {
            type: !type ? "cell" : (_c = type == null ? void 0 : type.Properties) == null ? void 0 : _c.Type,
            value: Values[i16][j2],
            event,
            backgroundColor: rgbColor(backgroundColor2),
            cellFont,
            typeObj: type,
            formattedValue: FormattedValues && FormattedValues[i16][j2],
            formatString: FormatString && FormatString[cellType2 - 1],
            width: !CellWidths ? 100 : Array.isArray(CellWidths) ? CellWidths[j2] : CellWidths,
            height: !CellHeights ? 20 : Array.isArray(CellHeights) ? CellHeights[i16] : CellHeights
          };
          body.push(obj2);
        }
        data22.push(body);
      }
    }
    return data22;
  };
  const handleCellClick = (row, column) => {
    var _a;
    setSelectedColumn(column);
    setSelectedRow(row);
    if (row == selectedRow && column == selectedColumn)
      return;
    let localStoragValue = JSON.parse(localStorage.getItem(data2 == null ? void 0 : data2.ID));
    if (!localStoragValue)
      localStorage.setItem(
        data2 == null ? void 0 : data2.ID,
        JSON.stringify({
          Event: {
            CurCell: [row, column]
          }
        })
      );
    else {
      localStorage.setItem(
        data2 == null ? void 0 : data2.ID,
        JSON.stringify({
          Event: {
            CurCell: [row, column],
            Values: (_a = localStoragValue == null ? void 0 : localStoragValue.Event) == null ? void 0 : _a.Values
          }
        })
      );
    }
    handleCellMove(row, column, 1);
  };
  const gridData = modifyGridData();
  const customStyles = parseFlexStyles(CSS);
  console.log("260", rows);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      tabIndex: 0,
      ref: gridRef,
      onKeyDown: handleKeyDown,
      onMouseDown: (e3) => {
        handleMouseDown(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseUp: (e3) => {
        handleMouseUp(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseEnter: (e3) => {
        handleMouseEnter(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseMove: (e3) => {
        handleMouseMove(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseLeave: (e3) => {
        handleMouseLeave(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onWheel: (e3) => {
        handleMouseWheel(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onDoubleClick: (e3) => {
        var _a;
        handleMouseDoubleClick(e3, socket, Event, (_a = data2 == null ? void 0 : data2.typeObj) == null ? void 0 : _a.ID);
      },
      id: data2 == null ? void 0 : data2.ID,
      style: {
        ...style2,
        height,
        width,
        border: "1px solid black",
        overflow: !ColTitles ? "auto" : "hidden",
        background: "white",
        display: Visible == 0 ? "none" : "block",
        overflowX: HScroll == -3 ? "scroll" : HScroll == -1 || HScroll == -2 ? "auto" : "auto",
        overflowY: VScroll == -3 ? "scroll" : VScroll == -1 || HScroll == -2 ? "auto" : "auto",
        ...customStyles
      },
      children: gridData == null ? void 0 : gridData.map((row, rowi) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex" }, id: `row-${rowi}-cell`, children: row.map((data22, columni) => {
          const isFocused = selectedRow === rowi && selectedColumn === (TitleWidth === 0 ? columni + 1 : columni);
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              onClick: () => {
                if (data22.type === "rowTitle" || data22.type === "header")
                  return;
                handleCellClick(rowi, TitleWidth === 0 ? columni + 1 : columni);
              },
              id: `${gridId}`,
              style: {
                borderRight: isFocused ? "1px solid blue" : "1px solid  #EFEFEF",
                borderBottom: isFocused ? "1px solid blue" : "1px solid  #EFEFEF",
                fontSize: "12px",
                minHeight: `${data22 == null ? void 0 : data22.height}px`,
                maxHeight: `${data22 == null ? void 0 : data22.height}px`,
                minWidth: `${data22 == null ? void 0 : data22.width}px`,
                maxWidth: `${data22 == null ? void 0 : data22.width}px`,
                minheight: `${data22 == null ? void 0 : data22.height}px`,
                maxheight: `${data22 == null ? void 0 : data22.height}px`,
                backgroundColor: selectedRow === rowi && data22.type == "rowTitle" || selectedColumn === (TitleWidth === 0 ? columni + 1 : columni) && data22.type == "header" ? "lightblue" : rgbColor(data22 == null ? void 0 : data22.backgroundColor),
                textAlign: data22.type == "header" ? "center" : data22 == null ? void 0 : data22.align,
                overflow: "hidden",
                lineHeight: `${data22 == null ? void 0 : data22.height}px`,
                paddingLeft: data22 == null ? void 0 : data22.paddingLeft
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Component,
                {
                  data: {
                    ...data22,
                    row: rowi,
                    column: TitleWidth === 0 ? columni + 1 : columni,
                    gridValues: Values,
                    gridEvent: Event,
                    showInput: ShowInput,
                    gridId,
                    focused: isFocused,
                    backgroundColor: data22 == null ? void 0 : data22.backgroundColor
                  }
                },
                data22 == null ? void 0 : data22.type
              )
            }
          );
        }) });
      })
    }
  ) });
};
const Edit = ({
  data: data2,
  value: value2,
  event = "",
  row = "",
  column = "",
  location = "",
  values: values6 = [],
  T: T3 = ""
}) => {
  const {
    socket,
    dataRef,
    findDesiredData,
    handleData,
    addChangeEvent,
    fontScale
  } = useAppData();
  const dateFormat = JSON.parse(getObjectById(dataRef.current, "Locale"));
  const {
    ShortDate,
    Thousand,
    Decimal: decimalSeparator
  } = dateFormat == null ? void 0 : dateFormat.Properties;
  let styles = { ...setStyle$1(data2 == null ? void 0 : data2.Properties) };
  const [inputType, setInputType] = reactExports.useState("text");
  const [inputValue, setInputValue] = reactExports.useState("");
  const [emitValue, setEmitValue] = reactExports.useState("");
  const [initialValue, setInitialValue] = reactExports.useState("");
  const [prevFocused, setprevFocused] = reactExports.useState("");
  reactExports.useRef();
  const {
    FieldType,
    MaxLength,
    FCol,
    Decimal,
    Visible,
    Event,
    FontObj,
    Size: Size2,
    EdgeStyle,
    Border = 0,
    CSS
  } = data2 == null ? void 0 : data2.Properties;
  const hasTextProperty = data2 == null ? void 0 : data2.Properties.hasOwnProperty("Text");
  const hasValueProperty = data2 == null ? void 0 : data2.Properties.hasOwnProperty("Value");
  const isPassword = data2 == null ? void 0 : data2.Properties.hasOwnProperty("Password");
  const inputRef = reactExports.useRef(null);
  const font2 = findDesiredData(FontObj && FontObj);
  const fontProperties = font2 && (font2 == null ? void 0 : font2.Properties);
  const customStyles = parseFlexStyles(CSS);
  const decideInputValue = reactExports.useCallback(() => {
    var _a, _b, _c, _d, _e2, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t;
    if (location === "inGrid") {
      if (FieldType === "Date") {
        setEmitValue(value2);
        setInitialValue(value2);
        const date = calculateDateAfterDays(value2);
        return setInputValue(dayjs(date).format(ShortDate));
      }
      if (FieldType === "LongNumeric") {
        setEmitValue(value2);
        setInitialValue(value2);
        return setInputValue(value2);
      }
      setEmitValue(value2);
      setInitialValue(value2);
      return setInputValue(value2);
    }
    if (!((_b = (_a = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _a.FieldType) == null ? void 0 : _b.includes("Numeric"))) {
      if (isPassword) {
        setInitialValue(generateAsteriskString((_d = (_c = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _c.Text) == null ? void 0 : _d.length));
        setEmitValue((_e2 = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _e2.Text);
        return setInputValue(
          generateAsteriskString((_g = (_f = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _f.Text) == null ? void 0 : _g.length)
        );
      } else {
        setEmitValue((_h = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _h.Text);
        setInitialValue((_i = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _i.Text);
        return setInputValue((_j = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _j.Text);
      }
    }
    if ((_l = (_k = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _k.FieldType) == null ? void 0 : _l.includes("Numeric")) {
      if (isPassword) {
        setInitialValue(
          generateAsteriskString((_n = (_m = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _m.Value) == null ? void 0 : _n.length)
        );
        setEmitValue((_o = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _o.Value);
        return setInputValue(
          generateAsteriskString((_q = (_p = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _p.Value) == null ? void 0 : _q.length)
        );
      } else {
        setInitialValue((_r = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _r.Value);
        setEmitValue((_s = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _s.Value);
        return setInputValue((_t = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _t.Value);
      }
    }
  }, [
    location,
    FieldType,
    value2,
    ShortDate,
    hasTextProperty,
    isPassword,
    data2,
    hasValueProperty
  ]);
  const handleInputClick = () => {
    if (inputRef.current) {
      inputRef.current.select();
    }
  };
  const decideInputType = reactExports.useCallback(() => {
    if (FieldType === "Numeric") {
      setInputType("number");
    } else if (FieldType === "Date") {
      setInputType("date");
    } else if (isPassword) {
      setInputType("password");
    }
  }, [FieldType, isPassword]);
  reactExports.useEffect(() => {
    decideInputType();
  }, [decideInputType]);
  reactExports.useEffect(() => {
    decideInputValue();
  }, [decideInputValue]);
  if (location == "inGrid") {
    styles = {
      ...styles,
      border: "none",
      color: FCol ? rgbColor(FCol) : "black"
    };
  } else {
    styles = {
      ...styles,
      borderTop: 0,
      borderLeft: 0,
      borderRight: 0,
      borderBottom: "1px solid black",
      color: FCol ? rgbColor(FCol) : "black"
    };
  }
  const triggerCellMoveEvent = (row2, column2, mouseClick, value22) => {
    const isKeyboard = !mouseClick ? 1 : 0;
    const Event2 = JSON.stringify({
      Event: {
        ID: extractStringUntilLastPeriod(data2 == null ? void 0 : data2.ID),
        EventName: "CellMove",
        Info: [row2, column2, isKeyboard, 0, mouseClick, value22]
      }
    });
    const exists = event && event.some((item) => item[0] === "CellMove");
    if (!exists)
      return;
    console.log(Event2);
    socket.send(Event2);
  };
  const handleCellMove = () => {
    if (location !== "inGrid")
      return;
    const parent = inputRef.current.parentElement;
    const grandParent = parent.parentElement;
    const superParent = grandParent.parentElement;
    const nextSibling = superParent.nextSibling;
    triggerCellMoveEvent(parseInt(row) + 1, parseInt(column), 0, emitValue);
    const element = nextSibling == null ? void 0 : nextSibling.querySelectorAll("input");
    if (!element)
      return;
    element && element.forEach((inputElement) => {
      if (inputElement.id === (data2 == null ? void 0 : data2.ID)) {
        inputElement.select();
      }
    });
  };
  const handleRightArrow = () => {
    var _a, _b;
    if (location !== "inGrid")
      return;
    const parent = inputRef.current.parentElement;
    const grandParent = parent.parentElement;
    const nextSibling = grandParent.nextSibling;
    const querySelector = getObjectTypeById(dataRef.current, nextSibling == null ? void 0 : nextSibling.id);
    let element = nextSibling == null ? void 0 : nextSibling.querySelectorAll(querySelector);
    if ((element == null ? void 0 : element.length) == 0)
      element = nextSibling == null ? void 0 : nextSibling.querySelectorAll("span");
    triggerCellMoveEvent(parseInt(row), parseInt(column) + 1, 0, emitValue);
    element && ((_a = element[0]) == null ? void 0 : _a.focus());
    element && ((_b = element[0]) == null ? void 0 : _b.select());
  };
  const handleLeftArrow = () => {
    var _a;
    if (location !== "inGrid")
      return;
    const parent = inputRef.current.parentElement;
    const grandParent = parent.parentElement;
    const nextSibling = grandParent.previousSibling;
    const querySelector = getObjectTypeById(dataRef.current, nextSibling == null ? void 0 : nextSibling.id);
    const element = nextSibling == null ? void 0 : nextSibling.querySelectorAll(querySelector);
    triggerCellMoveEvent(parseInt(row), parseInt(column) + 1, 0, emitValue);
    if (!element)
      return;
    if (querySelector == "select")
      return element && element[0].focus();
    return element && ((_a = element[0]) == null ? void 0 : _a.select());
  };
  const handleUpArrow = () => {
    if (location !== "inGrid")
      return;
    const parent = inputRef.current.parentElement;
    const grandParent = parent.parentElement;
    const superParent = grandParent.parentElement;
    const nextSibling = superParent.previousSibling;
    triggerCellMoveEvent(parseInt(row) - 1, parseInt(column), 0, emitValue);
    const element = nextSibling == null ? void 0 : nextSibling.querySelectorAll("input");
    if (!element)
      return;
    element && element.forEach((inputElement) => {
      if (inputElement.id === (data2 == null ? void 0 : data2.ID)) {
        inputElement.select();
      }
    });
  };
  const handleKeyPress = (e3) => {
    if (e3.key == "ArrowRight")
      handleRightArrow();
    else if (e3.key == "ArrowLeft")
      handleLeftArrow();
    else if (e3.key == "ArrowDown")
      handleCellMove();
    else if (e3.key == "Enter")
      handleCellMove();
    else if (e3.key == "ArrowUp")
      handleUpArrow();
    const exists = Event && Event.some((item) => item[0] === "KeyPress");
    if (!exists)
      return;
    const isAltPressed = e3.altKey ? 4 : 0;
    const isCtrlPressed = e3.ctrlKey ? 2 : 0;
    const isShiftPressed = e3.shiftKey ? 1 : 0;
    const charCode = e3.key.charCodeAt(0);
    let shiftState = isAltPressed + isCtrlPressed + isShiftPressed;
    console.log(
      JSON.stringify({
        Event: {
          EventName: "KeyPress",
          ID: data2 == null ? void 0 : data2.ID,
          Info: [e3.key, charCode, e3.keyCode, shiftState]
        }
      })
    );
    socket.send(
      JSON.stringify({
        Event: {
          EventName: "KeyPress",
          ID: data2 == null ? void 0 : data2.ID,
          Info: [e3.key, charCode, e3.keyCode, shiftState]
        }
      })
    );
  };
  const triggerChangeEvent = () => {
    var _a, _b;
    localStorage.getItem("current-focus");
    const event2 = JSON.stringify({
      Event: {
        EventName: "Change",
        ID: data2 == null ? void 0 : data2.ID,
        Info: FieldType && FieldType == "LongNumeric" || FieldType == "Numeric" ? parseInt(emitValue) : emitValue
      }
    });
    handleData(
      {
        ID: data2 == null ? void 0 : data2.ID,
        Properties: {
          ...FieldType === "LongNumeric" || FieldType === "Numeric" ? { Value: parseInt(emitValue) } : { Text: emitValue }
        }
      },
      "WS"
    );
    localStorage.setItem(data2 == null ? void 0 : data2.ID, event2);
    localStorage.setItem(
      "shouldChangeEvent",
      data2.Properties.hasOwnProperty("Event")
    );
    const prevFocusedID = JSON.parse(localStorage.getItem(prevFocused));
    if (!!data2.Properties.hasOwnProperty("Event")) {
      const event1 = JSON.stringify({
        Event: {
          EventName: "Change",
          ID: prevFocused,
          Info: [data2 == null ? void 0 : data2.ID]
        }
      });
      const originalValue = ((_a = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _a.Text) || ((_b = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _b.Value) || "";
      console.log(
        "value focused",
        { value: value2, emitValue, originalValue },
        prevFocusedID,
        prevFocusedID.Event.EventName !== "Select",
        originalValue !== emitValue
      );
      if (prevFocused && prevFocusedID.Event.EventName !== "Select" && originalValue !== emitValue && prevFocused !== data2.ID) {
        console.log(
          "focused",
          prevFocusedID,
          prevFocusedID.Event.EventName !== "Select",
          originalValue !== emitValue
        );
        socket.send(event1);
      }
    }
    const exists = Event && Event.some((item) => item[0] === "Change");
    if (!exists)
      return;
    const event3 = JSON.stringify({
      Event: {
        EventName: "Change",
        ID: data2 == null ? void 0 : data2.ID,
        Info: []
      }
    });
    localStorage.setItem("change-event", event3);
  };
  const triggerCellChangedEvent = () => {
    const gridEvent = findDesiredData(extractStringUntilLastPeriod(data2 == null ? void 0 : data2.ID));
    values6[parseInt(row) - 1][parseInt(column) - 1] = emitValue;
    handleData(
      {
        ID: extractStringUntilLastPeriod(data2 == null ? void 0 : data2.ID),
        Properties: {
          ...gridEvent.Properties,
          Values: values6,
          CurCell: [parseInt(row), parseInt(column)]
        }
      },
      "WS"
    );
    const cellChangedEvent = JSON.stringify({
      Event: {
        EventName: "CellChanged",
        ID: extractStringUntilLastPeriod(data2 == null ? void 0 : data2.ID),
        Row: parseInt(row),
        Col: parseInt(column),
        Value: emitValue
      }
    });
    const updatedGridValues = JSON.stringify({
      Event: {
        EventName: "CellChanged",
        Values: values6,
        CurCell: [row, column]
      }
    });
    const formatCellEvent = JSON.stringify({
      FormatCell: {
        Cell: [row, column],
        ID: extractStringUntilLastPeriod(data2 == null ? void 0 : data2.ID),
        Value: emitValue
      }
    });
    localStorage.setItem(
      extractStringUntilLastPeriod(data2 == null ? void 0 : data2.ID),
      updatedGridValues
    );
    const exists = event && event.some((item) => item[0] === "CellChanged");
    if (!exists)
      return;
    console.log(cellChangedEvent);
    socket.send(cellChangedEvent);
    if (!formatString)
      return;
    console.log(formatCellEvent);
    socket.send(formatCellEvent);
  };
  const handleEditEvents = () => {
    if (location == "inGrid") {
      if (value2 != emitValue) {
        triggerChangeEvent();
        triggerCellChangedEvent();
      }
    } else {
      triggerChangeEvent();
    }
  };
  const handleGotFocus = () => {
    const previousFocusedId = localStorage.getItem("current-focus");
    setprevFocused(previousFocusedId);
    const gotFocusEvent = JSON.stringify({
      Event: {
        EventName: "GotFocus",
        ID: data2 == null ? void 0 : data2.ID,
        Info: !previousFocusedId ? [""] : [previousFocusedId]
      }
    });
    localStorage.setItem("current-focus", data2 == null ? void 0 : data2.ID);
    const exists = Event && Event.some((item) => item[0] === "GotFocus");
    if (!exists || previousFocusedId == (data2 == null ? void 0 : data2.ID))
      return;
    console.log(gotFocusEvent);
    socket.send(gotFocusEvent);
  };
  styles = {
    ...styles,
    fontFamily: fontProperties == null ? void 0 : fontProperties.PName,
    fontSize: (fontProperties == null ? void 0 : fontProperties.Size) ? `${fontProperties.Size * fontScale}px` : `${12 * fontScale}px`,
    // fontSize: fontProperties?.Size ? `${fontProperties.Size * fontScale}px` : `${11 * fontScale}px`,
    textDecoration: !(fontProperties == null ? void 0 : fontProperties.Underline) ? "none" : (fontProperties == null ? void 0 : fontProperties.Underline) == 1 ? "underline" : "none",
    fontStyle: !(fontProperties == null ? void 0 : fontProperties.Italic) ? "none" : (fontProperties == null ? void 0 : fontProperties.Italic) == 1 ? "italic" : "none",
    fontWeight: !(fontProperties == null ? void 0 : fontProperties.Weight) ? 0 : fontProperties == null ? void 0 : fontProperties.Weight
  };
  if (inputType == "date") {
    const handleTextClick = () => {
      inputRef.current.select();
      inputRef.current.showPicker();
    };
    const handleDateChange = (event2) => {
      const selectedDate = dayjs(event2.target.value).format(ShortDate);
      let value22 = calculateDaysFromDate(event2.target.value) + 1;
      setInputValue(selectedDate);
      setEmitValue(value22);
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          id: data2 == null ? void 0 : data2.ID,
          style: {
            ...styles,
            borderRadius: "2px",
            fontSize: "12px",
            zIndex: 1,
            display: Visible == 0 ? "none" : "block",
            paddingLeft: "5px",
            ...customStyles
          },
          value: inputValue,
          type: "text",
          readOnly: true,
          onClick: handleTextClick,
          onBlur: () => {
            handleEditEvents();
          },
          onKeyDown: (e3) => handleKeyPress(e3),
          onMouseDown: (e3) => {
            handleMouseDown(e3, socket, Event, data2 == null ? void 0 : data2.ID);
          },
          onMouseUp: (e3) => {
            handleMouseUp(e3, socket, Event, data2 == null ? void 0 : data2.ID);
          },
          onMouseEnter: (e3) => {
            handleMouseEnter(e3, socket, Event, data2 == null ? void 0 : data2.ID);
          },
          onMouseMove: (e3) => {
            handleMouseMove(e3, socket, Event, data2 == null ? void 0 : data2.ID);
          },
          onMouseLeave: (e3) => {
            handleMouseLeave(e3, socket, Event, data2 == null ? void 0 : data2.ID);
          },
          onWheel: (e3) => {
            handleMouseWheel(e3, socket, Event, data2 == null ? void 0 : data2.ID);
          },
          onDoubleClick: (e3) => {
            handleMouseDoubleClick(e3, socket, Event, data2 == null ? void 0 : data2.ID);
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          id: data2 == null ? void 0 : data2.ID,
          type: "date",
          ref: inputRef,
          onChange: handleDateChange,
          style: {
            ...styles,
            position: "absolute",
            zIndex: 1,
            display: "none"
          }
        }
      )
    ] });
  }
  if (FieldType == "LongNumeric" || FieldType == "Numeric") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      NumericFormat,
      {
        className: "currency",
        allowLeadingZeros: true,
        getInputRef: inputRef,
        onClick: handleInputClick,
        id: data2 == null ? void 0 : data2.ID,
        style: {
          ...styles,
          width: !Size2 ? "100%" : Size2[1],
          zIndex: 1,
          display: Visible == 0 ? "none" : "block",
          border: Border && Border == "1" || EdgeStyle && EdgeStyle == "Ridge" ? "1px solid #6A6A6A" : "none",
          textAlign: "right",
          verticalAlign: "text-top",
          paddingBottom: "6px",
          paddingRight: "2px",
          ...customStyles
        },
        onValueChange: (value22) => {
          setInputValue(value22.value);
          setEmitValue(value22.value);
        },
        decimalScale: Decimal,
        value: inputValue,
        decimalSeparator,
        thousandSeparator: Thousand,
        onBlur: () => handleEditEvents(),
        onKeyDown: (e3) => handleKeyPress(e3),
        onFocus: handleGotFocus,
        onMouseDown: (e3) => {
          handleMouseDown(e3, socket, Event, data2 == null ? void 0 : data2.ID);
        },
        onMouseUp: (e3) => {
          handleMouseUp(e3, socket, Event, data2 == null ? void 0 : data2.ID);
        },
        onMouseEnter: (e3) => {
          handleMouseEnter(e3, socket, Event, data2 == null ? void 0 : data2.ID);
        },
        onMouseMove: (e3) => {
          handleMouseMove(e3, socket, Event, data2 == null ? void 0 : data2.ID);
        },
        onMouseLeave: (e3) => {
          handleMouseLeave(e3, socket, Event, data2 == null ? void 0 : data2.ID);
        },
        onWheel: (e3) => {
          handleMouseWheel(e3, socket, Event, data2 == null ? void 0 : data2.ID);
        },
        onDoubleClick: (e3) => {
          handleMouseDoubleClick(e3, socket, Event, data2 == null ? void 0 : data2.ID);
        }
      }
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "input",
    {
      id: data2.ID,
      ref: inputRef,
      value: inputValue,
      onClick: handleInputClick,
      type: inputType,
      onChange: (e3) => {
        if (FieldType == "Char") {
          setEmitValue(e3.target.value);
          setInputValue(e3.target.value);
        }
        if (!FieldType) {
          setEmitValue(e3.target.value);
          setInputValue(e3.target.value);
        }
      },
      onBlur: () => {
        handleEditEvents();
      },
      onKeyDown: (e3) => handleKeyPress(e3),
      style: {
        ...styles,
        width: !Size2 ? "100%" : Size2[1],
        borderRadius: "2px",
        zIndex: 1,
        display: Visible == 0 ? "none" : "block",
        paddingLeft: "5px",
        border: Border && Border == "1" || EdgeStyle && EdgeStyle == "Ridge" ? "1px solid #6A6A6A" : "none",
        ...customStyles
      },
      maxLength: MaxLength,
      onFocus: handleGotFocus,
      onMouseDown: (e3) => {
        handleMouseDown(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseUp: (e3) => {
        handleMouseUp(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseEnter: (e3) => {
        handleMouseEnter(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseMove: (e3) => {
        handleMouseMove(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseLeave: (e3) => {
        handleMouseLeave(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onWheel: (e3) => {
        handleMouseWheel(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onDoubleClick: (e3) => {
        handleMouseDoubleClick(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      }
    }
  );
};
const Button = ({
  data: data2,
  inputValue,
  event = "",
  row = "",
  column = "",
  location = "",
  values: values6 = []
}) => {
  var _a, _b, _c, _d, _e2, _f, _g, _h, _i, _j, _k;
  const parentSize = JSON.parse(
    localStorage.getItem(extractStringUntilLastPeriod(data2 == null ? void 0 : data2.ID))
  );
  const styles = setStyle$1(data2 == null ? void 0 : data2.Properties);
  const { socket, findDesiredData, dataRef, handleData, reRender } = useAppData();
  const { Picture, State, Visible, Event, Caption, Align, Posn, Size: Size2, CSS } = data2 == null ? void 0 : data2.Properties;
  console.log("data Button", data2);
  const customStyles = parseFlexStyles(CSS);
  const inputRef = reactExports.useRef();
  const dimensions = useResizeObserver(
    document.getElementById(extractStringUntilLastPeriod(data2 == null ? void 0 : data2.ID))
  );
  const [checkInput, setCheckInput] = reactExports.useState();
  const [radioValue, setRadioValue] = reactExports.useState(State ? State : 0);
  const hasCaption = data2.Properties.hasOwnProperty("Caption");
  const isCheckBox = ((_a = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _a.Style) && ((_b = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _b.Style) == "Check";
  const isRadio = ((_c = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _c.Style) && ((_d = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _d.Style) == "Radio";
  const ImageData = findDesiredData(Picture && Picture[0]);
  const buttonEvent = data2.Properties.Event && ((_e2 = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _e2.Event[0]);
  const imageStyles = getImageStyles(Picture && Picture[1], ImageData);
  const [position2, setPosition] = reactExports.useState({
    top: Posn && Posn[0],
    left: Posn && Posn[1]
  });
  const [parentOldDimensions, setParentOldDimensions] = reactExports.useState(
    parentSize == null ? void 0 : parentSize.Size
  );
  const decideInput = () => {
    if (location == "inGrid") {
      return setCheckInput(inputValue);
    }
    setCheckInput(State && State);
  };
  reactExports.useEffect(() => {
    decideInput();
    setPosition({ top: Posn && Posn[0], left: Posn && Posn[1] });
  }, [data2]);
  const shortcutKey = (Caption == null ? void 0 : Caption.includes("&")) ? Caption == null ? void 0 : Caption.charAt(Caption.indexOf("&") + 1).toLowerCase() : null;
  reactExports.useEffect(() => {
    const handleShortcut = (event2) => {
      if (shortcutKey && event2.altKey && event2.key.toLowerCase() === shortcutKey) {
        handleButtonClick();
      }
    };
    document.addEventListener("keydown", handleShortcut);
    return () => document.removeEventListener("keydown", handleShortcut);
  }, [shortcutKey]);
  const handleButtonClick = () => {
    console.log("Button clicked:", data2 == null ? void 0 : data2.ID);
    if (buttonEvent) {
      socket.send(
        JSON.stringify({
          Event: {
            EventName: buttonEvent[0],
            ID: data2 == null ? void 0 : data2.ID
          }
        })
      );
    }
  };
  reactExports.useEffect(() => {
    var _a2;
    if (!position2)
      return;
    if (!parentOldDimensions)
      return;
    let calculateLeft = position2 && position2.left && parentOldDimensions && parentOldDimensions[1] ? position2.left / parentOldDimensions[1] * dimensions.width : 0;
    calculateLeft = Math.max(0, Math.min(calculateLeft, dimensions.width));
    let calculateTop = position2 && position2.top && parentOldDimensions && parentOldDimensions[0] ? position2.top / parentOldDimensions[0] * dimensions.height : 0;
    calculateTop = Math.max(0, Math.min(calculateTop, dimensions.height));
    setPosition({
      top: Math.round(calculateTop),
      left: Math.round(calculateLeft)
    });
    setParentOldDimensions([dimensions == null ? void 0 : dimensions.height, dimensions == null ? void 0 : dimensions.width]);
    handleData(
      {
        ID: data2 == null ? void 0 : data2.ID,
        Properties: {
          ...((_a2 = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _a2.hasOwnProperty("Posn")) ? { Posn: [Math.round(calculateTop), Math.round(calculateLeft)] } : {}
        }
      },
      "WS"
    );
    if (!localStorage.getItem(data2 == null ? void 0 : data2.ID)) {
      const event2 = JSON.stringify({
        Event: {
          EventName: "Select",
          ID: data2 == null ? void 0 : data2.ID,
          Value: 0,
          Posn: [Math.round(calculateTop), Math.round(calculateLeft)],
          Size: [Size2 && Size2[0], Size2 && Size2[1]]
        }
      });
      localStorage.setItem(data2 == null ? void 0 : data2.ID, event2);
    } else {
      const { Event: Event2 } = JSON.parse(localStorage.getItem(data2 == null ? void 0 : data2.ID));
      const { Value } = Event2;
      const event2 = JSON.stringify({
        Event: {
          EventName: "Select",
          ID: data2 == null ? void 0 : data2.ID,
          Value,
          Posn: [Math.round(calculateTop), Math.round(calculateLeft)],
          Size: [Size2 && Size2[0], Size2 && Size2[1]]
        }
      });
      localStorage.setItem(data2 == null ? void 0 : data2.ID, event2);
    }
    setParentOldDimensions([dimensions == null ? void 0 : dimensions.height, dimensions == null ? void 0 : dimensions.width]);
    reRender();
  }, [dimensions]);
  const handleCellChangedEvent = (value2) => {
    const gridEvent = findDesiredData(extractStringUntilLastPeriod(data2 == null ? void 0 : data2.ID));
    values6[parseInt(row) - 1][parseInt(column) - 1] = value2 ? 1 : 0, handleData(
      {
        ID: extractStringUntilLastPeriod(data2 == null ? void 0 : data2.ID),
        Properties: {
          ...gridEvent.Properties,
          Values: values6,
          CurCell: [row, column]
        }
      },
      "WS"
    );
    const triggerEvent = JSON.stringify({
      Event: {
        EventName: "CellChanged",
        ID: extractStringUntilLastPeriod(data2 == null ? void 0 : data2.ID),
        Row: parseInt(row),
        Col: parseInt(column),
        Value: value2 ? 1 : 0
      }
    });
    const updatedGridValues = JSON.stringify({
      Event: {
        EventName: "CellChanged",
        Values: values6,
        CurCell: [row, column]
      }
    });
    const formatCellEvent = JSON.stringify({
      FormatCell: {
        Cell: [row, column],
        ID: extractStringUntilLastPeriod(data2 == null ? void 0 : data2.ID),
        Value: value2 ? 1 : 0
      }
    });
    localStorage.setItem(
      extractStringUntilLastPeriod(data2 == null ? void 0 : data2.ID),
      updatedGridValues
    );
    const exists = event && event.some((item) => item[0] === "CellChanged");
    if (!exists)
      return;
    console.log(triggerEvent);
    console.log(formatCellEvent);
    socket.send(formatCellEvent);
    socket.send(triggerEvent);
  };
  const handleSelectEvent = (value2) => {
    const triggerEvent = JSON.stringify({
      Event: {
        EventName: "Select",
        ID: data2 == null ? void 0 : data2.ID,
        Value: value2 ? 1 : 0,
        Posn: [position2 == null ? void 0 : position2.top, position2 == null ? void 0 : position2.left],
        Size: [Size2 && Size2[0], Size2 && Size2[1]]
      }
    });
    localStorage.setItem(data2 == null ? void 0 : data2.ID, triggerEvent);
    const exists = Event && Event.some((item) => item[0] === "Select");
    if (!exists)
      return;
    console.log(triggerEvent);
    const event2 = JSON.stringify({
      Event: {
        EventName: "Select",
        ID: data2 == null ? void 0 : data2.ID
      }
    });
    socket.send(event2);
  };
  const handleCheckBoxEvent = (value2) => {
    if (location == "inGrid") {
      handleSelectEvent(value2);
      handleCellChangedEvent(value2);
    } else {
      handleSelectEvent(value2);
    }
  };
  const triggerCellMoveEvent = (row2, column2, mouseClick) => {
    console.log("265 button");
    const isKeyboard = !mouseClick ? 1 : 0;
    const Event2 = JSON.stringify({
      Event: {
        ID: extractStringUntilLastPeriod(data2 == null ? void 0 : data2.ID),
        EventName: "CellMove",
        Info: [row2, column2, isKeyboard, 0, mouseClick, checkInput ? 1 : 0]
      }
    });
    const exists = event && event.some((item) => item[0] === "CellMove");
    if (!exists)
      return;
    console.log(Event2);
    socket.send(Event2);
  };
  const handleCellMove = () => {
    if (location !== "inGrid")
      return;
    const parent = inputRef.current.parentElement;
    const grandParent = parent.parentElement;
    const superParent = grandParent.parentElement;
    const nextSibling = superParent.nextSibling;
    triggerCellMoveEvent(row + 1, column, 0);
    const element = nextSibling == null ? void 0 : nextSibling.querySelectorAll("input");
    element && element.forEach((inputElement) => {
      if (inputElement.id === (data2 == null ? void 0 : data2.ID)) {
        inputElement.focus();
      }
    });
  };
  const handleRightArrow = () => {
    if (location !== "inGrid")
      return;
    const parent = inputRef.current.parentElement;
    const grandParent = parent.parentElement;
    const nextSibling = grandParent.nextSibling;
    const querySelector = getObjectTypeById(dataRef.current, nextSibling == null ? void 0 : nextSibling.id);
    triggerCellMoveEvent(row, column + 1, 0);
    const element = nextSibling == null ? void 0 : nextSibling.querySelectorAll(querySelector);
    if (querySelector == "select")
      return element && element[0].focus();
    return element && element[0].select();
  };
  const handleLeftArrow = () => {
    var _a2, _b2;
    if (location !== "inGrid")
      return;
    console.log(inputRef);
    const parent = inputRef.current.parentElement;
    const grandParent = parent.parentElement;
    const nextSibling = grandParent.previousSibling;
    const querySelector = getObjectTypeById(dataRef.current, nextSibling == null ? void 0 : nextSibling.id);
    triggerCellMoveEvent(row, column - 1, 0);
    const element = nextSibling == null ? void 0 : nextSibling.querySelectorAll(querySelector);
    element && ((_a2 = element[0]) == null ? void 0 : _a2.focus());
    return element && ((_b2 = element[0]) == null ? void 0 : _b2.select());
  };
  const handleUpArrow = () => {
    if (location !== "inGrid")
      return;
    const parent = inputRef.current.parentElement;
    const grandParent = parent.parentElement;
    const superParent = grandParent.parentElement;
    const nextSibling = superParent.previousSibling;
    triggerCellMoveEvent(row - 1, column, 0);
    const element = nextSibling == null ? void 0 : nextSibling.querySelectorAll("input");
    element && element.forEach((inputElement) => {
      if (inputElement.id === (data2 == null ? void 0 : data2.ID)) {
        inputElement.focus();
      }
    });
  };
  const handleKeyPress = (e3) => {
    handleKeyPressUtils(e3, socket, Event, data2 == null ? void 0 : data2.ID);
    if (e3.key == "Enter")
      handleCellMove();
    else if (e3.key == "ArrowRight")
      handleRightArrow();
    else if (e3.key == "ArrowLeft")
      handleLeftArrow();
    else if (e3.key == "ArrowDown")
      handleCellMove();
    else if (e3.key == "ArrowUp")
      handleUpArrow();
  };
  const handleGotFocus = () => {
    const previousFocusedId = localStorage.getItem("current-focus");
    const gotFocusEvent = JSON.stringify({
      Event: {
        EventName: "GotFocus",
        ID: data2 == null ? void 0 : data2.ID,
        Info: !previousFocusedId ? [""] : [previousFocusedId]
      }
    });
    localStorage.setItem("current-focus", data2 == null ? void 0 : data2.ID);
    const exists = Event && Event.some((item) => item[0] === "GotFocus");
    if (!exists || previousFocusedId == (data2 == null ? void 0 : data2.ID))
      return;
    console.log(gotFocusEvent);
    socket.send(gotFocusEvent);
  };
  if (isCheckBox) {
    let checkBoxPosition = null;
    if (Align && Align == "Left") {
      checkBoxPosition = { position: "absolute", right: 0, top: 3 };
    } else if (!Align || Align == "Right") {
      checkBoxPosition = { position: "absolute", left: 0, top: 3 };
    }
    if (location == "inGrid") {
      checkBoxPosition = { ...checkBoxPosition, marginLeft: "5px" };
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        onKeyDown: (e3) => handleKeyPress(e3),
        style: {
          ...styles,
          zIndex: 1,
          display: Visible == 0 ? "none" : "block"
        },
        children: [
          Align && Align == "Left" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              style: { fontSize: "12px", position: "absolute", top: 0, left: 0 },
              children: Caption
            }
          ) : null,
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              onFocus: handleGotFocus,
              ref: inputRef,
              onKeyDown: (e3) => handleKeyPress(e3),
              id: data2 == null ? void 0 : data2.ID,
              type: "checkbox",
              style: checkBoxPosition,
              checked: checkInput,
              onChange: (e3) => {
                setCheckInput(e3.target.checked);
                handleCheckBoxEvent(e3.target.checked);
              }
            }
          ),
          !Align || Align == "Right" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              style: {
                fontSize: "12px",
                position: "absolute",
                top: 0,
                left: 16,
                ...customStyles
              },
              children: Caption
            }
          ) : null
        ]
      }
    );
  }
  if (isRadio) {
    const handleRadioSelectEvent = (value2) => {
      const emitEvent = JSON.stringify({
        Event: {
          EventName: "Select",
          ID: data2 == null ? void 0 : data2.ID,
          Value: value2
        }
      });
      const exists = Event && Event.some((item) => item[0] === "Select");
      if (!exists)
        return;
      const event2 = JSON.stringify({
        Event: {
          EventName: "Select",
          ID: data2 == null ? void 0 : data2.ID
        }
      });
      console.log(emitEvent);
      socket.send(event2);
    };
    const handleRadioButton = (id2, value2) => {
      const parentElement = document.getElementById(
        extractStringUntilLastPeriod(data2 == null ? void 0 : data2.ID)
      );
      var radioInputs = parentElement.getElementsByTagName("input");
      for (var i16 = 0; i16 < radioInputs.length; i16++) {
        if (radioInputs[i16].type !== "radio") {
          continue;
        }
        var radioId = radioInputs[i16].id;
        const button2 = JSON.parse(getObjectById(dataRef.current, radioId));
        handleData(
          {
            ID: button2.ID,
            Properties: {
              ...button2 == null ? void 0 : button2.Properties,
              State: 0
            }
          },
          "WS"
        );
      }
      const button = JSON.parse(getObjectById(dataRef.current, data2.ID));
      handleData(
        {
          ID: data2.ID,
          Properties: {
            ...button == null ? void 0 : button.Properties,
            State: 1
          }
        },
        "WS"
      );
      handleRadioSelectEvent(value2);
    };
    reactExports.useEffect(() => {
      setRadioValue(State);
    }, [data2]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          ...styles,
          zIndex: 1,
          display: Visible == 0 ? "none" : "block",
          ...customStyles
        },
        children: [
          Align && Align == "Left" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              style: {
                fontSize: "12px",
                position: "absolute",
                top: 2,
                left: 0,
                ...customStyles
              },
              children: Caption
            }
          ) : null,
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              onFocus: handleGotFocus,
              name: extractStringUntilLastPeriod(data2 == null ? void 0 : data2.ID),
              id: data2 == null ? void 0 : data2.ID,
              checked: radioValue,
              type: "radio",
              value: Caption,
              onChange: (e3) => {
                handleRadioButton(data2 == null ? void 0 : data2.ID, e3.target.checked);
              }
            }
          ),
          !Align || Align == "Right" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              style: {
                fontSize: "12px",
                position: "absolute",
                top: 2,
                left: 16,
                ...customStyles
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("label", { for: data2 == null ? void 0 : data2.ID, children: Caption })
            }
          ) : null
        ]
      }
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      id: data2 == null ? void 0 : data2.ID,
      onMouseDown: (e3) => {
        handleMouseDown(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseUp: (e3) => {
        handleMouseUp(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseEnter: (e3) => {
        handleMouseEnter(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseMove: (e3) => {
        handleMouseMove(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseLeave: (e3) => {
        handleMouseLeave(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onWheel: (e3) => {
        handleMouseWheel(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onDoubleClick: (e3) => {
        handleMouseDoubleClick(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onClick: () => {
        console.log(
          JSON.stringify({
            Event: {
              EventName: buttonEvent[0],
              ID: data2 == null ? void 0 : data2.ID
            }
          })
        );
        if (localStorage.getItem("current-focus") && localStorage.getItem("shouldChangeEvent") === "true") {
          console.log(
            JSON.stringify({
              Event: {
                EventName: "Change",
                ID: localStorage.getItem("current-focus"),
                Info: [data2 == null ? void 0 : data2.ID]
              }
            })
          );
          socket.send(
            JSON.stringify({
              Event: {
                EventName: "Change",
                ID: localStorage.getItem("current-focus"),
                Info: [data2 == null ? void 0 : data2.ID]
              }
            })
          );
        }
        socket.send(
          JSON.stringify({
            Event: {
              EventName: buttonEvent[0],
              ID: data2 == null ? void 0 : data2.ID
            }
          })
        );
        handleGotFocus();
      },
      style: {
        ...styles,
        border: "1px solid black",
        textAlign: "center",
        alignItems: "center",
        justifyContent: "center",
        background: "white",
        borderRadius: "4px",
        borderColor: "#ccc",
        fontSize: "12px",
        // fontSize: '11px',
        cursor: "pointer",
        zIndex: 1,
        display: Visible == 0 ? "none" : "flex",
        ...((_f = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _f.hasOwnProperty("Posn")) ? { top: position2 == null ? void 0 : position2.top } : {},
        ...((_g = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _g.hasOwnProperty("Posn")) ? { left: position2 == null ? void 0 : position2.left } : {},
        ...customStyles
      },
      children: [
        ImageData ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { ...imageStyles, width: "100%", height: "100%" } }) : null,
        hasCaption ? ((_i = (_h = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _h.Caption) == null ? void 0 : _i.includes("&")) ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          "span",
          {
            dangerouslySetInnerHTML: {
              __html: (_j = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _j.Caption.replace(/&(\w)/, "<u>$1</u>")
            }
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: (_k = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _k.Caption }) : null
      ]
    }
  );
};
const Combo = ({ data: data2, value: value2, event = "", row = "", column = "", location = "", values: values6 = [] }) => {
  const parentSize = JSON.parse(localStorage.getItem(extractStringUntilLastPeriod(data2 == null ? void 0 : data2.ID)));
  const { CSS } = data2.Properties;
  const customStyles = parseFlexStyles(CSS);
  const inputRef = reactExports.useRef();
  const { socket, handleData, findDesiredData, reRender, dataRef } = useAppData();
  const styles = setStyle$1(data2 == null ? void 0 : data2.Properties);
  const { Items, SelItems, Event, Visible, Posn, Size: Size2 } = data2 == null ? void 0 : data2.Properties;
  const dimensions = useResizeObserver(
    document.getElementById(extractStringUntilLastPeriod(data2 == null ? void 0 : data2.ID))
  );
  const [comboInput, setComboInput] = reactExports.useState("+");
  const [position2, setPosition] = reactExports.useState({ top: Posn && Posn[0], left: Posn && Posn[1] });
  const [parentOldDimensions, setParentOldDimensions] = reactExports.useState(parentSize == null ? void 0 : parentSize.Size);
  reactExports.useEffect(() => {
    const index2 = SelItems == null ? void 0 : SelItems.findIndex((element) => element == 1);
    setComboInput(Items[index2]);
    const triggerEvent = JSON.stringify({
      Event: {
        EventName: "Select",
        ID: data2 == null ? void 0 : data2.ID,
        Info: index2 + 1,
        Text: Items && Items[index2],
        Posn: [position2 == null ? void 0 : position2.top, position2 == null ? void 0 : position2.left],
        Size: [Size2 && Size2[0], Size2 && Size2[1]]
      }
    });
    localStorage.setItem(data2 == null ? void 0 : data2.ID, triggerEvent);
  }, [data2]);
  const handleCellChangeEvent = (value22) => {
    const gridEvent = findDesiredData(extractStringUntilLastPeriod(data2 == null ? void 0 : data2.ID));
    values6[parseInt(row) - 1][parseInt(column) - 1] = value22;
    handleData(
      {
        ID: extractStringUntilLastPeriod(data2 == null ? void 0 : data2.ID),
        Properties: {
          ...gridEvent.Properties,
          Values: values6,
          CurCell: [row, column]
        }
      },
      "WS"
    );
    const triggerEvent = JSON.stringify({
      Event: {
        EventName: "CellChanged",
        ID: extractStringUntilLastPeriod(data2 == null ? void 0 : data2.ID),
        Row: parseInt(row),
        Col: parseInt(column),
        Value: value22
      }
    });
    const updatedGridValues = JSON.stringify({
      Event: {
        EventName: "CellChanged",
        Values: values6,
        CurCell: [row, column]
      }
    });
    localStorage.setItem(extractStringUntilLastPeriod(data2 == null ? void 0 : data2.ID), updatedGridValues);
    const exists = event && event.some((item) => item[0] === "CellChanged");
    if (!exists)
      return;
    console.log(triggerEvent);
    socket.send(triggerEvent);
  };
  const handleSelectEvent = (value22) => {
    const NewSelItems = new Array(Items.length).fill(0);
    handleData(
      {
        ID: data2 == null ? void 0 : data2.ID,
        Properties: {
          ...data2 == null ? void 0 : data2.Properties,
          SelItems: NewSelItems,
          Text: Items && Items[value22]
        }
      },
      "WS"
    );
    const triggerEvent = JSON.stringify({
      Event: {
        EventName: "Select",
        ID: data2 == null ? void 0 : data2.ID,
        Info: parseInt(value22 + 1),
        Text: Items && Items[value22],
        SelItems: NewSelItems,
        Posn: [position2 == null ? void 0 : position2.top, position2 == null ? void 0 : position2.left],
        Size: [Size2 && Size2[0], Size2 && Size2[1]]
      }
    });
    const event2 = JSON.stringify({
      Event: {
        EventName: "Select",
        ID: data2 == null ? void 0 : data2.ID
      }
    });
    localStorage.setItem(data2 == null ? void 0 : data2.ID, triggerEvent);
    const exists = Event && Event.some((item) => item[0] === "Select");
    if (!exists)
      return;
    console.log(triggerEvent);
    socket.send(event2);
  };
  const handleSelItemsEvent = (value22) => {
    const index2 = Items.indexOf(value22);
    if (location == "inGrid") {
      handleSelectEvent(index2);
      handleCellChangeEvent(value22);
    } else {
      handleSelectEvent(index2);
    }
  };
  reactExports.useEffect(() => {
    if (!position2)
      return;
    if (!parentOldDimensions)
      return;
    let calculateLeft = position2 && position2.left && parentOldDimensions && parentOldDimensions[1] ? position2.left / parentOldDimensions[1] * dimensions.width : 0;
    calculateLeft = Math.max(0, Math.min(calculateLeft, dimensions.width));
    let calculateTop = position2 && position2.top && parentOldDimensions && parentOldDimensions[0] ? position2.top / parentOldDimensions[0] * dimensions.height : 0;
    calculateTop = Math.max(0, Math.min(calculateTop, dimensions.height));
    setPosition({ top: calculateTop, left: calculateLeft });
    handleData(
      {
        ID: data2 == null ? void 0 : data2.ID,
        Properties: {
          Posn: [calculateTop, calculateLeft]
        }
      },
      "WS"
    );
    setParentOldDimensions([dimensions == null ? void 0 : dimensions.height, dimensions == null ? void 0 : dimensions.width]);
    reRender();
  }, [dimensions]);
  const triggerCellMoveEvent = (row2, column2, mouseClick, value22) => {
    console.log("265 combo");
    const isKeyboard = !mouseClick ? 1 : 0;
    const Event2 = JSON.stringify({
      Event: {
        ID: extractStringUntilLastPeriod(data2 == null ? void 0 : data2.ID),
        EventName: "CellMove",
        Info: [row2, column2, isKeyboard, 0, mouseClick, value22]
      }
    });
    const exists = event && event.some((item) => item[0] === "CellMove");
    if (!exists)
      return;
    console.log(Event2);
    socket.send(Event2);
  };
  const handleRightArrow = (value22) => {
    if (location !== "inGrid")
      return;
    console.log(inputRef);
    const parent = inputRef.current.parentElement;
    const grandParent = parent.parentElement;
    const nextSibling = grandParent.nextSibling;
    const querySelector = getObjectTypeById(dataRef.current, nextSibling == null ? void 0 : nextSibling.id);
    triggerCellMoveEvent(row, column + 1, 0, value22);
    const element = nextSibling == null ? void 0 : nextSibling.querySelectorAll(querySelector);
    console.log({ element });
    if (querySelector == "select")
      return element && element[0].focus();
    return element && element[0].select();
  };
  const handleLeftArrow = (value22) => {
    if (location !== "inGrid")
      return;
    console.log(inputRef);
    const parent = inputRef.current.parentElement;
    const grandParent = parent.parentElement;
    const nextSibling = grandParent.previousSibling;
    const querySelector = getObjectTypeById(dataRef.current, nextSibling == null ? void 0 : nextSibling.id);
    triggerCellMoveEvent(row, column - 1, 0, value22);
    const element = nextSibling == null ? void 0 : nextSibling.querySelectorAll(querySelector);
    if (querySelector == "select")
      return element && element[0].focus();
    return element && element[0].select();
  };
  const handleUpArrow = (value22) => {
    if (location !== "inGrid")
      return;
    const parent = inputRef.current.parentElement;
    const grandParent = parent.parentElement;
    const superParent = grandParent.parentElement;
    const nextSibling = superParent.previousSibling;
    const element = nextSibling == null ? void 0 : nextSibling.querySelectorAll("select");
    triggerCellMoveEvent(row - 1, column, 0, value22);
    element && element.forEach((inputElement) => {
      if (inputElement.id === (data2 == null ? void 0 : data2.ID)) {
        inputElement.focus();
      }
    });
  };
  const handleCellMove = (value22) => {
    if (location !== "inGrid")
      return;
    const parent = inputRef.current.parentElement;
    const grandParent = parent.parentElement;
    const superParent = grandParent.parentElement;
    const nextSibling = superParent.nextSibling;
    triggerCellMoveEvent(row + 1, column, 0, value22);
    const element = nextSibling == null ? void 0 : nextSibling.querySelectorAll("select");
    element && element.forEach((inputElement) => {
      if (inputElement.id === (data2 == null ? void 0 : data2.ID)) {
        inputElement.focus();
      }
    });
  };
  const handleKeyPress = (e3) => {
    e3.stopPropagation();
    e3.preventDefault();
    handleKeyPressUtils(e3, socket, Event, data2 == null ? void 0 : data2.ID);
    if (e3.key == "ArrowRight")
      handleRightArrow(e3.target.value);
    else if (e3.key == "ArrowLeft")
      handleLeftArrow(e3.target.value);
    else if (e3.key == "ArrowDown")
      handleCellMove(e3.target.value);
    else if (e3.key == "ArrowUp")
      handleUpArrow(e3.target.value);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      style: {
        ...styles,
        borderColor: "#ccc",
        display: Visible == 0 ? "none" : "block",
        top: position2 == null ? void 0 : position2.top,
        left: position2 == null ? void 0 : position2.left
      },
      onMouseDown: (e3) => {
        e3.stopPropagation();
        handleMouseDown(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseUp: (e3) => {
        e3.stopPropagation();
        handleMouseUp(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseEnter: (e3) => {
        e3.stopPropagation();
        handleMouseEnter(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseMove: (e3) => {
        e3.stopPropagation();
        handleMouseMove(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseLeave: (e3) => {
        e3.stopPropagation();
        handleMouseLeave(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onWheel: (e3) => {
        handleMouseWheel(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onDoubleClick: (e3) => {
        e3.stopPropagation();
        handleMouseDoubleClick(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "select",
        {
          ref: inputRef,
          onKeyDown: (e3) => handleKeyPress(e3),
          id: data2 == null ? void 0 : data2.ID,
          value: value2 ? value2 : comboInput,
          style: {
            width: "100%",
            border: 0,
            fontSize: "12px",
            height: location === "inGrid" ? null : "100%",
            zIndex: 1,
            ...customStyles
          },
          onChange: (e3) => {
            e3.stopPropagation();
            setComboInput(e3.target.value);
            handleSelItemsEvent(e3.target.value);
          },
          children: Items && Items.map((item, i16) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: item, children: item }, i16))
        }
      )
    }
  );
};
const font = "";
const Label$1 = ({ data: data2, gridValue }) => {
  var _a, _b, _c, _d, _e2;
  let styles = setStyle$1(data2 == null ? void 0 : data2.Properties);
  const { findDesiredData, fontScale, socket } = useAppData();
  const haveColor = data2 == null ? void 0 : data2.Properties.hasOwnProperty("FCol");
  const haveFontProperty = data2 == null ? void 0 : data2.Properties.hasOwnProperty("Font");
  const { Visible, FontObj, Caption, Size: Size2, BCol, Event, CSS } = data2 == null ? void 0 : data2.Properties;
  console.log("data Label", data2);
  const customStyles = parseFlexStyles(CSS);
  if (haveColor) {
    styles = {
      ...styles,
      color: `rgb(${(_a = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _a.FCol[0]},${(_b = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _b.FCol[1]},${(_c = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _c.FCol[2]})`
    };
  }
  if (haveFontProperty) {
    styles = {
      ...styles,
      fontFamily: (_d = data2.Properties) == null ? void 0 : _d.Font[0],
      fontSize: (_e2 = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _e2.Font[1]
    };
  } else {
    const font2 = findDesiredData(FontObj && FontObj);
    const fontProperties = font2 && (font2 == null ? void 0 : font2.Properties);
    styles = {
      ...styles,
      fontFamily: fontProperties == null ? void 0 : fontProperties.PName,
      fontSize: (fontProperties == null ? void 0 : fontProperties.Size) ? `${fontProperties.Size * fontScale}px` : `${12 * fontScale}px`,
      // fontSize: fontProperties?.Size ? `${fontProperties.Size * fontScale}px` : `${11 * fontScale}px`,
      textDecoration: !(fontProperties == null ? void 0 : fontProperties.Underline) ? "none" : (fontProperties == null ? void 0 : fontProperties.Underline) == 1 ? "underline" : "none",
      fontStyle: !(fontProperties == null ? void 0 : fontProperties.Italic) ? "none" : (fontProperties == null ? void 0 : fontProperties.Italic) == 1 ? "italic" : "none",
      fontWeight: !(fontProperties == null ? void 0 : fontProperties.Weight) ? 0 : fontProperties == null ? void 0 : fontProperties.Weight,
      background: BCol && rgbColor(BCol)
      // paddingLeft: '10px',
      // paddingRight: '10px'
    };
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      id: data2 == null ? void 0 : data2.ID,
      style: { ...styles, display: Visible == 0 ? "none" : "block", ...customStyles },
      onMouseDown: (e3) => {
        handleMouseDown(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseUp: (e3) => {
        handleMouseUp(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseEnter: (e3) => {
        handleMouseEnter(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseMove: (e3) => {
        handleMouseMove(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseLeave: (e3) => {
        handleMouseLeave(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      children: !Caption ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        "span",
        {
          style: {
            display: "flex",
            justifyContent: typeof gridValue == "string" ? "start" : "end",
            fontSize: "12px",
            marginLeft: "5px"
          },
          children: gridValue
        }
      ) : Caption
    }
  );
};
function _extends$4() {
  _extends$4 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i16 = 1; i16 < arguments.length; i16++) {
      var source = arguments[i16];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$4.apply(this, arguments);
}
function _typeof$6(o9) {
  "@babel/helpers - typeof";
  return _typeof$6 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o10) {
    return typeof o10;
  } : function(o10) {
    return o10 && "function" == typeof Symbol && o10.constructor === Symbol && o10 !== Symbol.prototype ? "symbol" : typeof o10;
  }, _typeof$6(o9);
}
function _toPrimitive(input, hint) {
  if (_typeof$6(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof$6(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof$6(key) === "symbol" ? key : String(key);
}
function _defineProperty$2(obj, key, value2) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value2;
  }
  return obj;
}
function ownKeys(e3, r12) {
  var t6 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o9 = Object.getOwnPropertySymbols(e3);
    r12 && (o9 = o9.filter(function(r13) {
      return Object.getOwnPropertyDescriptor(e3, r13).enumerable;
    })), t6.push.apply(t6, o9);
  }
  return t6;
}
function _objectSpread2(e3) {
  for (var r12 = 1; r12 < arguments.length; r12++) {
    var t6 = null != arguments[r12] ? arguments[r12] : {};
    r12 % 2 ? ownKeys(Object(t6), true).forEach(function(r13) {
      _defineProperty$2(e3, r13, t6[r13]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t6)) : ownKeys(Object(t6)).forEach(function(r13) {
      Object.defineProperty(e3, r13, Object.getOwnPropertyDescriptor(t6, r13));
    });
  }
  return e3;
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i16 = 0, arr2 = new Array(len); i16 < len; i16++)
    arr2[i16] = arr[i16];
  return arr2;
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _unsupportedIterableToArray(o9, minLen) {
  if (!o9)
    return;
  if (typeof o9 === "string")
    return _arrayLikeToArray(o9, minLen);
  var n10 = Object.prototype.toString.call(o9).slice(8, -1);
  if (n10 === "Object" && o9.constructor)
    n10 = o9.constructor.name;
  if (n10 === "Map" || n10 === "Set")
    return Array.from(o9);
  if (n10 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n10))
    return _arrayLikeToArray(o9, minLen);
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _classCallCheck$5(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$4(target, props) {
  for (var i16 = 0; i16 < props.length; i16++) {
    var descriptor = props[i16];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass$5(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$4(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$4(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _assertThisInitialized$4(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _setPrototypeOf$4(o9, p6) {
  _setPrototypeOf$4 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o10, p7) {
    o10.__proto__ = p7;
    return o10;
  };
  return _setPrototypeOf$4(o9, p6);
}
function _inherits$5(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf$4(subClass, superClass);
}
function _getPrototypeOf$4(o9) {
  _getPrototypeOf$4 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o10) {
    return o10.__proto__ || Object.getPrototypeOf(o10);
  };
  return _getPrototypeOf$4(o9);
}
function _isNativeReflectConstruct$4() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _possibleConstructorReturn$5(self2, call2) {
  if (call2 && (_typeof$6(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$4(self2);
}
function _createSuper$4(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$4();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$4(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$4(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$5(this, result);
  };
}
var classnames = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(module) {
  (function() {
    var hasOwn = {}.hasOwnProperty;
    function classNames2() {
      var classes = [];
      for (var i16 = 0; i16 < arguments.length; i16++) {
        var arg = arguments[i16];
        if (!arg)
          continue;
        var argType = typeof arg;
        if (argType === "string" || argType === "number") {
          classes.push(arg);
        } else if (Array.isArray(arg)) {
          if (arg.length) {
            var inner = classNames2.apply(null, arg);
            if (inner) {
              classes.push(inner);
            }
          }
        } else if (argType === "object") {
          if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
            classes.push(arg.toString());
            continue;
          }
          for (var key in arg) {
            if (hasOwn.call(arg, key) && arg[key]) {
              classes.push(key);
            }
          }
        }
      }
      return classes.join(" ");
    }
    if (module.exports) {
      classNames2.default = classNames2;
      module.exports = classNames2;
    } else {
      window.classNames = classNames2;
    }
  })();
})(classnames);
var classnamesExports = classnames.exports;
const classNames = /* @__PURE__ */ getDefaultExportFromCjs(classnamesExports);
var KeyCode = {
  /**
   * MAC_ENTER
   */
  MAC_ENTER: 3,
  /**
   * BACKSPACE
   */
  BACKSPACE: 8,
  /**
   * TAB
   */
  TAB: 9,
  /**
   * NUMLOCK on FF/Safari Mac
   */
  NUM_CENTER: 12,
  // NUMLOCK on FF/Safari Mac
  /**
   * ENTER
   */
  ENTER: 13,
  /**
   * SHIFT
   */
  SHIFT: 16,
  /**
   * CTRL
   */
  CTRL: 17,
  /**
   * ALT
   */
  ALT: 18,
  /**
   * PAUSE
   */
  PAUSE: 19,
  /**
   * CAPS_LOCK
   */
  CAPS_LOCK: 20,
  /**
   * ESC
   */
  ESC: 27,
  /**
   * SPACE
   */
  SPACE: 32,
  /**
   * PAGE_UP
   */
  PAGE_UP: 33,
  // also NUM_NORTH_EAST
  /**
   * PAGE_DOWN
   */
  PAGE_DOWN: 34,
  // also NUM_SOUTH_EAST
  /**
   * END
   */
  END: 35,
  // also NUM_SOUTH_WEST
  /**
   * HOME
   */
  HOME: 36,
  // also NUM_NORTH_WEST
  /**
   * LEFT
   */
  LEFT: 37,
  // also NUM_WEST
  /**
   * UP
   */
  UP: 38,
  // also NUM_NORTH
  /**
   * RIGHT
   */
  RIGHT: 39,
  // also NUM_EAST
  /**
   * DOWN
   */
  DOWN: 40,
  // also NUM_SOUTH
  /**
   * PRINT_SCREEN
   */
  PRINT_SCREEN: 44,
  /**
   * INSERT
   */
  INSERT: 45,
  // also NUM_INSERT
  /**
   * DELETE
   */
  DELETE: 46,
  // also NUM_DELETE
  /**
   * ZERO
   */
  ZERO: 48,
  /**
   * ONE
   */
  ONE: 49,
  /**
   * TWO
   */
  TWO: 50,
  /**
   * THREE
   */
  THREE: 51,
  /**
   * FOUR
   */
  FOUR: 52,
  /**
   * FIVE
   */
  FIVE: 53,
  /**
   * SIX
   */
  SIX: 54,
  /**
   * SEVEN
   */
  SEVEN: 55,
  /**
   * EIGHT
   */
  EIGHT: 56,
  /**
   * NINE
   */
  NINE: 57,
  /**
   * QUESTION_MARK
   */
  QUESTION_MARK: 63,
  // needs localization
  /**
   * A
   */
  A: 65,
  /**
   * B
   */
  B: 66,
  /**
   * C
   */
  C: 67,
  /**
   * D
   */
  D: 68,
  /**
   * E
   */
  E: 69,
  /**
   * F
   */
  F: 70,
  /**
   * G
   */
  G: 71,
  /**
   * H
   */
  H: 72,
  /**
   * I
   */
  I: 73,
  /**
   * J
   */
  J: 74,
  /**
   * K
   */
  K: 75,
  /**
   * L
   */
  L: 76,
  /**
   * M
   */
  M: 77,
  /**
   * N
   */
  N: 78,
  /**
   * O
   */
  O: 79,
  /**
   * P
   */
  P: 80,
  /**
   * Q
   */
  Q: 81,
  /**
   * R
   */
  R: 82,
  /**
   * S
   */
  S: 83,
  /**
   * T
   */
  T: 84,
  /**
   * U
   */
  U: 85,
  /**
   * V
   */
  V: 86,
  /**
   * W
   */
  W: 87,
  /**
   * X
   */
  X: 88,
  /**
   * Y
   */
  Y: 89,
  /**
   * Z
   */
  Z: 90,
  /**
   * META
   */
  META: 91,
  // WIN_KEY_LEFT
  /**
   * WIN_KEY_RIGHT
   */
  WIN_KEY_RIGHT: 92,
  /**
   * CONTEXT_MENU
   */
  CONTEXT_MENU: 93,
  /**
   * NUM_ZERO
   */
  NUM_ZERO: 96,
  /**
   * NUM_ONE
   */
  NUM_ONE: 97,
  /**
   * NUM_TWO
   */
  NUM_TWO: 98,
  /**
   * NUM_THREE
   */
  NUM_THREE: 99,
  /**
   * NUM_FOUR
   */
  NUM_FOUR: 100,
  /**
   * NUM_FIVE
   */
  NUM_FIVE: 101,
  /**
   * NUM_SIX
   */
  NUM_SIX: 102,
  /**
   * NUM_SEVEN
   */
  NUM_SEVEN: 103,
  /**
   * NUM_EIGHT
   */
  NUM_EIGHT: 104,
  /**
   * NUM_NINE
   */
  NUM_NINE: 105,
  /**
   * NUM_MULTIPLY
   */
  NUM_MULTIPLY: 106,
  /**
   * NUM_PLUS
   */
  NUM_PLUS: 107,
  /**
   * NUM_MINUS
   */
  NUM_MINUS: 109,
  /**
   * NUM_PERIOD
   */
  NUM_PERIOD: 110,
  /**
   * NUM_DIVISION
   */
  NUM_DIVISION: 111,
  /**
   * F1
   */
  F1: 112,
  /**
   * F2
   */
  F2: 113,
  /**
   * F3
   */
  F3: 114,
  /**
   * F4
   */
  F4: 115,
  /**
   * F5
   */
  F5: 116,
  /**
   * F6
   */
  F6: 117,
  /**
   * F7
   */
  F7: 118,
  /**
   * F8
   */
  F8: 119,
  /**
   * F9
   */
  F9: 120,
  /**
   * F10
   */
  F10: 121,
  /**
   * F11
   */
  F11: 122,
  /**
   * F12
   */
  F12: 123,
  /**
   * NUMLOCK
   */
  NUMLOCK: 144,
  /**
   * SEMICOLON
   */
  SEMICOLON: 186,
  // needs localization
  /**
   * DASH
   */
  DASH: 189,
  // needs localization
  /**
   * EQUALS
   */
  EQUALS: 187,
  // needs localization
  /**
   * COMMA
   */
  COMMA: 188,
  // needs localization
  /**
   * PERIOD
   */
  PERIOD: 190,
  // needs localization
  /**
   * SLASH
   */
  SLASH: 191,
  // needs localization
  /**
   * APOSTROPHE
   */
  APOSTROPHE: 192,
  // needs localization
  /**
   * SINGLE_QUOTE
   */
  SINGLE_QUOTE: 222,
  // needs localization
  /**
   * OPEN_SQUARE_BRACKET
   */
  OPEN_SQUARE_BRACKET: 219,
  // needs localization
  /**
   * BACKSLASH
   */
  BACKSLASH: 220,
  // needs localization
  /**
   * CLOSE_SQUARE_BRACKET
   */
  CLOSE_SQUARE_BRACKET: 221,
  // needs localization
  /**
   * WIN_KEY
   */
  WIN_KEY: 224,
  /**
   * MAC_FF_META
   */
  MAC_FF_META: 224,
  // Firefox (Gecko) fires this for the meta key instead of 91
  /**
   * WIN_IME
   */
  WIN_IME: 229,
  // ======================== Function ========================
  /**
   * whether text and modified key is entered at the same time.
   */
  isTextModifyingKeyEvent: function isTextModifyingKeyEvent(e3) {
    var keyCode = e3.keyCode;
    if (e3.altKey && !e3.ctrlKey || e3.metaKey || // Function keys don't generate text
    keyCode >= KeyCode.F1 && keyCode <= KeyCode.F12) {
      return false;
    }
    switch (keyCode) {
      case KeyCode.ALT:
      case KeyCode.CAPS_LOCK:
      case KeyCode.CONTEXT_MENU:
      case KeyCode.CTRL:
      case KeyCode.DOWN:
      case KeyCode.END:
      case KeyCode.ESC:
      case KeyCode.HOME:
      case KeyCode.INSERT:
      case KeyCode.LEFT:
      case KeyCode.MAC_FF_META:
      case KeyCode.META:
      case KeyCode.NUMLOCK:
      case KeyCode.NUM_CENTER:
      case KeyCode.PAGE_DOWN:
      case KeyCode.PAGE_UP:
      case KeyCode.PAUSE:
      case KeyCode.PRINT_SCREEN:
      case KeyCode.RIGHT:
      case KeyCode.SHIFT:
      case KeyCode.UP:
      case KeyCode.WIN_KEY:
      case KeyCode.WIN_KEY_RIGHT:
        return false;
      default:
        return true;
    }
  },
  /**
   * whether character is entered.
   */
  isCharacterKey: function isCharacterKey(keyCode) {
    if (keyCode >= KeyCode.ZERO && keyCode <= KeyCode.NINE) {
      return true;
    }
    if (keyCode >= KeyCode.NUM_ZERO && keyCode <= KeyCode.NUM_MULTIPLY) {
      return true;
    }
    if (keyCode >= KeyCode.A && keyCode <= KeyCode.Z) {
      return true;
    }
    if (window.navigator.userAgent.indexOf("WebKit") !== -1 && keyCode === 0) {
      return true;
    }
    switch (keyCode) {
      case KeyCode.SPACE:
      case KeyCode.QUESTION_MARK:
      case KeyCode.NUM_PLUS:
      case KeyCode.NUM_MINUS:
      case KeyCode.NUM_PERIOD:
      case KeyCode.NUM_DIVISION:
      case KeyCode.SEMICOLON:
      case KeyCode.DASH:
      case KeyCode.EQUALS:
      case KeyCode.COMMA:
      case KeyCode.PERIOD:
      case KeyCode.SLASH:
      case KeyCode.APOSTROPHE:
      case KeyCode.SINGLE_QUOTE:
      case KeyCode.OPEN_SQUARE_BRACKET:
      case KeyCode.BACKSLASH:
      case KeyCode.CLOSE_SQUARE_BRACKET:
        return true;
      default:
        return false;
    }
  }
};
var attributes = "accept acceptCharset accessKey action allowFullScreen allowTransparency\n    alt async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge\n    charSet checked classID className colSpan cols content contentEditable contextMenu\n    controls coords crossOrigin data dateTime default defer dir disabled download draggable\n    encType form formAction formEncType formMethod formNoValidate formTarget frameBorder\n    headers height hidden high href hrefLang htmlFor httpEquiv icon id inputMode integrity\n    is keyParams keyType kind label lang list loop low manifest marginHeight marginWidth max maxLength media\n    mediaGroup method min minLength multiple muted name noValidate nonce open\n    optimum pattern placeholder poster preload radioGroup readOnly rel required\n    reversed role rowSpan rows sandbox scope scoped scrolling seamless selected\n    shape size sizes span spellCheck src srcDoc srcLang srcSet start step style\n    summary tabIndex target title type useMap value width wmode wrap";
var eventsName = "onCopy onCut onPaste onCompositionEnd onCompositionStart onCompositionUpdate onKeyDown\n    onKeyPress onKeyUp onFocus onBlur onChange onInput onSubmit onClick onContextMenu onDoubleClick\n    onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onMouseDown\n    onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp onSelect onTouchCancel\n    onTouchEnd onTouchMove onTouchStart onScroll onWheel onAbort onCanPlay onCanPlayThrough\n    onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata\n    onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting onLoad onError";
var propList = "".concat(attributes, " ").concat(eventsName).split(/[\s\n]+/);
var ariaPrefix = "aria-";
var dataPrefix = "data-";
function match(key, prefix) {
  return key.indexOf(prefix) === 0;
}
function pickAttrs(props) {
  var ariaOnly = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var mergedConfig;
  if (ariaOnly === false) {
    mergedConfig = {
      aria: true,
      data: true,
      attr: true
    };
  } else if (ariaOnly === true) {
    mergedConfig = {
      aria: true
    };
  } else {
    mergedConfig = _objectSpread2({}, ariaOnly);
  }
  var attrs = {};
  Object.keys(props).forEach(function(key) {
    if (
      // Aria
      mergedConfig.aria && (key === "role" || match(key, ariaPrefix)) || // Data
      mergedConfig.data && match(key, dataPrefix) || // Attr
      mergedConfig.attr && propList.includes(key)
    ) {
      attrs[key] = props[key];
    }
  });
  return attrs;
}
var warned$1 = {};
var preMessage = function preMessage2(fn) {
};
function warning(valid, message) {
}
function note(valid, message) {
}
function resetWarned() {
  warned$1 = {};
}
function call(method, valid, message) {
  if (!valid && !warned$1[message]) {
    method(false, message);
    warned$1[message] = true;
  }
}
function warningOnce(valid, message) {
  call(warning, valid, message);
}
function noteOnce(valid, message) {
  call(note, valid, message);
}
warningOnce.preMessage = preMessage;
warningOnce.resetWarned = resetWarned;
warningOnce.noteOnce = noteOnce;
var TreeContext = /* @__PURE__ */ reactExports.createContext(null);
function DropIndicator(_ref) {
  var dropPosition = _ref.dropPosition, dropLevelOffset = _ref.dropLevelOffset, indent = _ref.indent;
  var style2 = {
    pointerEvents: "none",
    position: "absolute",
    right: 0,
    backgroundColor: "red",
    height: 2
  };
  switch (dropPosition) {
    case -1:
      style2.top = 0;
      style2.left = -dropLevelOffset * indent;
      break;
    case 1:
      style2.bottom = 0;
      style2.left = -dropLevelOffset * indent;
      break;
    case 0:
      style2.bottom = 0;
      style2.left = indent;
      break;
  }
  return /* @__PURE__ */ reactExports.createElement("div", {
    style: style2
  });
}
function _objectDestructuringEmpty(obj) {
  if (obj == null)
    throw new TypeError("Cannot destructure " + obj);
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _iterableToArrayLimit(r12, l7) {
  var t6 = null == r12 ? null : "undefined" != typeof Symbol && r12[Symbol.iterator] || r12["@@iterator"];
  if (null != t6) {
    var e3, n10, i16, u5, a9 = [], f4 = true, o9 = false;
    try {
      if (i16 = (t6 = t6.call(r12)).next, 0 === l7) {
        if (Object(t6) !== t6)
          return;
        f4 = false;
      } else
        for (; !(f4 = (e3 = i16.call(t6)).done) && (a9.push(e3.value), a9.length !== l7); f4 = true)
          ;
    } catch (r13) {
      o9 = true, n10 = r13;
    } finally {
      try {
        if (!f4 && null != t6["return"] && (u5 = t6["return"](), Object(u5) !== u5))
          return;
      } finally {
        if (o9)
          throw n10;
      }
    }
    return a9;
  }
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _slicedToArray(arr, i16) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i16) || _unsupportedIterableToArray(arr, i16) || _nonIterableRest();
}
function _objectWithoutPropertiesLoose$2(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i16;
  for (i16 = 0; i16 < sourceKeys.length; i16++) {
    key = sourceKeys[i16];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties$3(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$2(source, excluded);
  var key, i16;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i16 = 0; i16 < sourceSymbolKeys.length; i16++) {
      key = sourceSymbolKeys[i16];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function canUseDom() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
var useInternalLayoutEffect = canUseDom() ? reactExports.useLayoutEffect : reactExports.useEffect;
var useLayoutEffect = function useLayoutEffect2(callback, deps) {
  var firstMountRef = reactExports.useRef(true);
  useInternalLayoutEffect(function() {
    return callback(firstMountRef.current);
  }, deps);
  useInternalLayoutEffect(function() {
    firstMountRef.current = false;
    return function() {
      firstMountRef.current = true;
    };
  }, []);
};
var reactIs = { exports: {} };
var reactIs_production_min = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b$d = Symbol.for("react.element"), c$q = Symbol.for("react.portal"), d$u = Symbol.for("react.fragment"), e$D = Symbol.for("react.strict_mode"), f$i = Symbol.for("react.profiler"), g$k = Symbol.for("react.provider"), h$f = Symbol.for("react.context"), k$b = Symbol.for("react.server_context"), l$s = Symbol.for("react.forward_ref"), m$n = Symbol.for("react.suspense"), n$A = Symbol.for("react.suspense_list"), p$z = Symbol.for("react.memo"), q$6 = Symbol.for("react.lazy"), t$p = Symbol.for("react.offscreen"), u$q;
u$q = Symbol.for("react.module.reference");
function v$f(a9) {
  if ("object" === typeof a9 && null !== a9) {
    var r12 = a9.$$typeof;
    switch (r12) {
      case b$d:
        switch (a9 = a9.type, a9) {
          case d$u:
          case f$i:
          case e$D:
          case m$n:
          case n$A:
            return a9;
          default:
            switch (a9 = a9 && a9.$$typeof, a9) {
              case k$b:
              case h$f:
              case l$s:
              case q$6:
              case p$z:
              case g$k:
                return a9;
              default:
                return r12;
            }
        }
      case c$q:
        return r12;
    }
  }
}
reactIs_production_min.ContextConsumer = h$f;
reactIs_production_min.ContextProvider = g$k;
reactIs_production_min.Element = b$d;
reactIs_production_min.ForwardRef = l$s;
reactIs_production_min.Fragment = d$u;
reactIs_production_min.Lazy = q$6;
reactIs_production_min.Memo = p$z;
reactIs_production_min.Portal = c$q;
reactIs_production_min.Profiler = f$i;
reactIs_production_min.StrictMode = e$D;
reactIs_production_min.Suspense = m$n;
reactIs_production_min.SuspenseList = n$A;
reactIs_production_min.isAsyncMode = function() {
  return false;
};
reactIs_production_min.isConcurrentMode = function() {
  return false;
};
reactIs_production_min.isContextConsumer = function(a9) {
  return v$f(a9) === h$f;
};
reactIs_production_min.isContextProvider = function(a9) {
  return v$f(a9) === g$k;
};
reactIs_production_min.isElement = function(a9) {
  return "object" === typeof a9 && null !== a9 && a9.$$typeof === b$d;
};
reactIs_production_min.isForwardRef = function(a9) {
  return v$f(a9) === l$s;
};
reactIs_production_min.isFragment = function(a9) {
  return v$f(a9) === d$u;
};
reactIs_production_min.isLazy = function(a9) {
  return v$f(a9) === q$6;
};
reactIs_production_min.isMemo = function(a9) {
  return v$f(a9) === p$z;
};
reactIs_production_min.isPortal = function(a9) {
  return v$f(a9) === c$q;
};
reactIs_production_min.isProfiler = function(a9) {
  return v$f(a9) === f$i;
};
reactIs_production_min.isStrictMode = function(a9) {
  return v$f(a9) === e$D;
};
reactIs_production_min.isSuspense = function(a9) {
  return v$f(a9) === m$n;
};
reactIs_production_min.isSuspenseList = function(a9) {
  return v$f(a9) === n$A;
};
reactIs_production_min.isValidElementType = function(a9) {
  return "string" === typeof a9 || "function" === typeof a9 || a9 === d$u || a9 === f$i || a9 === e$D || a9 === m$n || a9 === n$A || a9 === t$p || "object" === typeof a9 && null !== a9 && (a9.$$typeof === q$6 || a9.$$typeof === p$z || a9.$$typeof === g$k || a9.$$typeof === h$f || a9.$$typeof === l$s || a9.$$typeof === u$q || void 0 !== a9.getModuleId) ? true : false;
};
reactIs_production_min.typeOf = v$f;
{
  reactIs.exports = reactIs_production_min;
}
var reactIsExports = reactIs.exports;
function toArray(children) {
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var ret = [];
  t$q.Children.forEach(children, function(child) {
    if ((child === void 0 || child === null) && !option.keepEmpty) {
      return;
    }
    if (Array.isArray(child)) {
      ret = ret.concat(toArray(child));
    } else if (reactIsExports.isFragment(child) && child.props) {
      ret = ret.concat(toArray(child.props.children, option));
    } else {
      ret.push(child);
    }
  });
  return ret;
}
function fillRef(ref2, node) {
  if (typeof ref2 === "function") {
    ref2(node);
  } else if (_typeof$6(ref2) === "object" && ref2 && "current" in ref2) {
    ref2.current = node;
  }
}
function composeRef() {
  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
    refs[_key] = arguments[_key];
  }
  var refList = refs.filter(function(ref2) {
    return ref2;
  });
  if (refList.length <= 1) {
    return refList[0];
  }
  return function(node) {
    refs.forEach(function(ref2) {
      fillRef(ref2, node);
    });
  };
}
function supportRef(nodeOrComponent) {
  var _type$prototype, _nodeOrComponent$prot;
  var type = reactIsExports.isMemo(nodeOrComponent) ? nodeOrComponent.type.type : nodeOrComponent.type;
  if (typeof type === "function" && !((_type$prototype = type.prototype) !== null && _type$prototype !== void 0 && _type$prototype.render)) {
    return false;
  }
  if (typeof nodeOrComponent === "function" && !((_nodeOrComponent$prot = nodeOrComponent.prototype) !== null && _nodeOrComponent$prot !== void 0 && _nodeOrComponent$prot.render)) {
    return false;
  }
  return true;
}
function isDOM(node) {
  return node instanceof HTMLElement || node instanceof SVGElement;
}
function findDOMNode(node) {
  if (isDOM(node)) {
    return node;
  }
  if (node instanceof t$q.Component) {
    return ReactDOM.findDOMNode(node);
  }
  return null;
}
var MapShim = function() {
  if (typeof Map !== "undefined") {
    return Map;
  }
  function getIndex(arr, key) {
    var result = -1;
    arr.some(function(entry, index2) {
      if (entry[0] === key) {
        result = index2;
        return true;
      }
      return false;
    });
    return result;
  }
  return (
    /** @class */
    function() {
      function class_1() {
        this.__entries__ = [];
      }
      Object.defineProperty(class_1.prototype, "size", {
        /**
         * @returns {boolean}
         */
        get: function() {
          return this.__entries__.length;
        },
        enumerable: true,
        configurable: true
      });
      class_1.prototype.get = function(key) {
        var index2 = getIndex(this.__entries__, key);
        var entry = this.__entries__[index2];
        return entry && entry[1];
      };
      class_1.prototype.set = function(key, value2) {
        var index2 = getIndex(this.__entries__, key);
        if (~index2) {
          this.__entries__[index2][1] = value2;
        } else {
          this.__entries__.push([key, value2]);
        }
      };
      class_1.prototype.delete = function(key) {
        var entries = this.__entries__;
        var index2 = getIndex(entries, key);
        if (~index2) {
          entries.splice(index2, 1);
        }
      };
      class_1.prototype.has = function(key) {
        return !!~getIndex(this.__entries__, key);
      };
      class_1.prototype.clear = function() {
        this.__entries__.splice(0);
      };
      class_1.prototype.forEach = function(callback, ctx) {
        if (ctx === void 0) {
          ctx = null;
        }
        for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
          var entry = _a[_i];
          callback.call(ctx, entry[1], entry[0]);
        }
      };
      return class_1;
    }()
  );
}();
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
var global$1 = function() {
  if (typeof global !== "undefined" && global.Math === Math) {
    return global;
  }
  if (typeof self !== "undefined" && self.Math === Math) {
    return self;
  }
  if (typeof window !== "undefined" && window.Math === Math) {
    return window;
  }
  return Function("return this")();
}();
var requestAnimationFrame$1 = function() {
  if (typeof requestAnimationFrame === "function") {
    return requestAnimationFrame.bind(global$1);
  }
  return function(callback) {
    return setTimeout(function() {
      return callback(Date.now());
    }, 1e3 / 60);
  };
}();
var trailingTimeout = 2;
function throttle$1(callback, delay) {
  var leadingCall = false, trailingCall = false, lastCallTime = 0;
  function resolvePending() {
    if (leadingCall) {
      leadingCall = false;
      callback();
    }
    if (trailingCall) {
      proxy2();
    }
  }
  function timeoutCallback() {
    requestAnimationFrame$1(resolvePending);
  }
  function proxy2() {
    var timeStamp = Date.now();
    if (leadingCall) {
      if (timeStamp - lastCallTime < trailingTimeout) {
        return;
      }
      trailingCall = true;
    } else {
      leadingCall = true;
      trailingCall = false;
      setTimeout(timeoutCallback, delay);
    }
    lastCallTime = timeStamp;
  }
  return proxy2;
}
var REFRESH_DELAY = 20;
var transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
var mutationObserverSupported = typeof MutationObserver !== "undefined";
var ResizeObserverController = (
  /** @class */
  function() {
    function ResizeObserverController2() {
      this.connected_ = false;
      this.mutationEventsAdded_ = false;
      this.mutationsObserver_ = null;
      this.observers_ = [];
      this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
      this.refresh = throttle$1(this.refresh.bind(this), REFRESH_DELAY);
    }
    ResizeObserverController2.prototype.addObserver = function(observer) {
      if (!~this.observers_.indexOf(observer)) {
        this.observers_.push(observer);
      }
      if (!this.connected_) {
        this.connect_();
      }
    };
    ResizeObserverController2.prototype.removeObserver = function(observer) {
      var observers2 = this.observers_;
      var index2 = observers2.indexOf(observer);
      if (~index2) {
        observers2.splice(index2, 1);
      }
      if (!observers2.length && this.connected_) {
        this.disconnect_();
      }
    };
    ResizeObserverController2.prototype.refresh = function() {
      var changesDetected = this.updateObservers_();
      if (changesDetected) {
        this.refresh();
      }
    };
    ResizeObserverController2.prototype.updateObservers_ = function() {
      var activeObservers = this.observers_.filter(function(observer) {
        return observer.gatherActive(), observer.hasActive();
      });
      activeObservers.forEach(function(observer) {
        return observer.broadcastActive();
      });
      return activeObservers.length > 0;
    };
    ResizeObserverController2.prototype.connect_ = function() {
      if (!isBrowser || this.connected_) {
        return;
      }
      document.addEventListener("transitionend", this.onTransitionEnd_);
      window.addEventListener("resize", this.refresh);
      if (mutationObserverSupported) {
        this.mutationsObserver_ = new MutationObserver(this.refresh);
        this.mutationsObserver_.observe(document, {
          attributes: true,
          childList: true,
          characterData: true,
          subtree: true
        });
      } else {
        document.addEventListener("DOMSubtreeModified", this.refresh);
        this.mutationEventsAdded_ = true;
      }
      this.connected_ = true;
    };
    ResizeObserverController2.prototype.disconnect_ = function() {
      if (!isBrowser || !this.connected_) {
        return;
      }
      document.removeEventListener("transitionend", this.onTransitionEnd_);
      window.removeEventListener("resize", this.refresh);
      if (this.mutationsObserver_) {
        this.mutationsObserver_.disconnect();
      }
      if (this.mutationEventsAdded_) {
        document.removeEventListener("DOMSubtreeModified", this.refresh);
      }
      this.mutationsObserver_ = null;
      this.mutationEventsAdded_ = false;
      this.connected_ = false;
    };
    ResizeObserverController2.prototype.onTransitionEnd_ = function(_a) {
      var _b = _a.propertyName, propertyName = _b === void 0 ? "" : _b;
      var isReflowProperty = transitionKeys.some(function(key) {
        return !!~propertyName.indexOf(key);
      });
      if (isReflowProperty) {
        this.refresh();
      }
    };
    ResizeObserverController2.getInstance = function() {
      if (!this.instance_) {
        this.instance_ = new ResizeObserverController2();
      }
      return this.instance_;
    };
    ResizeObserverController2.instance_ = null;
    return ResizeObserverController2;
  }()
);
var defineConfigurable = function(target, props) {
  for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
    var key = _a[_i];
    Object.defineProperty(target, key, {
      value: props[key],
      enumerable: false,
      writable: false,
      configurable: true
    });
  }
  return target;
};
var getWindowOf = function(target) {
  var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
  return ownerGlobal || global$1;
};
var emptyRect = createRectInit(0, 0, 0, 0);
function toFloat(value2) {
  return parseFloat(value2) || 0;
}
function getBordersSize(styles) {
  var positions = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    positions[_i - 1] = arguments[_i];
  }
  return positions.reduce(function(size, position2) {
    var value2 = styles["border-" + position2 + "-width"];
    return size + toFloat(value2);
  }, 0);
}
function getPaddings(styles) {
  var positions = ["top", "right", "bottom", "left"];
  var paddings = {};
  for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
    var position2 = positions_1[_i];
    var value2 = styles["padding-" + position2];
    paddings[position2] = toFloat(value2);
  }
  return paddings;
}
function getSVGContentRect(target) {
  var bbox = target.getBBox();
  return createRectInit(0, 0, bbox.width, bbox.height);
}
function getHTMLElementContentRect(target) {
  var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
  if (!clientWidth && !clientHeight) {
    return emptyRect;
  }
  var styles = getWindowOf(target).getComputedStyle(target);
  var paddings = getPaddings(styles);
  var horizPad = paddings.left + paddings.right;
  var vertPad = paddings.top + paddings.bottom;
  var width = toFloat(styles.width), height = toFloat(styles.height);
  if (styles.boxSizing === "border-box") {
    if (Math.round(width + horizPad) !== clientWidth) {
      width -= getBordersSize(styles, "left", "right") + horizPad;
    }
    if (Math.round(height + vertPad) !== clientHeight) {
      height -= getBordersSize(styles, "top", "bottom") + vertPad;
    }
  }
  if (!isDocumentElement(target)) {
    var vertScrollbar = Math.round(width + horizPad) - clientWidth;
    var horizScrollbar = Math.round(height + vertPad) - clientHeight;
    if (Math.abs(vertScrollbar) !== 1) {
      width -= vertScrollbar;
    }
    if (Math.abs(horizScrollbar) !== 1) {
      height -= horizScrollbar;
    }
  }
  return createRectInit(paddings.left, paddings.top, width, height);
}
var isSVGGraphicsElement = function() {
  if (typeof SVGGraphicsElement !== "undefined") {
    return function(target) {
      return target instanceof getWindowOf(target).SVGGraphicsElement;
    };
  }
  return function(target) {
    return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === "function";
  };
}();
function isDocumentElement(target) {
  return target === getWindowOf(target).document.documentElement;
}
function getContentRect(target) {
  if (!isBrowser) {
    return emptyRect;
  }
  if (isSVGGraphicsElement(target)) {
    return getSVGContentRect(target);
  }
  return getHTMLElementContentRect(target);
}
function createReadOnlyRect(_a) {
  var x3 = _a.x, y4 = _a.y, width = _a.width, height = _a.height;
  var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
  var rect = Object.create(Constr.prototype);
  defineConfigurable(rect, {
    x: x3,
    y: y4,
    width,
    height,
    top: y4,
    right: x3 + width,
    bottom: height + y4,
    left: x3
  });
  return rect;
}
function createRectInit(x3, y4, width, height) {
  return { x: x3, y: y4, width, height };
}
var ResizeObservation = (
  /** @class */
  function() {
    function ResizeObservation2(target) {
      this.broadcastWidth = 0;
      this.broadcastHeight = 0;
      this.contentRect_ = createRectInit(0, 0, 0, 0);
      this.target = target;
    }
    ResizeObservation2.prototype.isActive = function() {
      var rect = getContentRect(this.target);
      this.contentRect_ = rect;
      return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
    };
    ResizeObservation2.prototype.broadcastRect = function() {
      var rect = this.contentRect_;
      this.broadcastWidth = rect.width;
      this.broadcastHeight = rect.height;
      return rect;
    };
    return ResizeObservation2;
  }()
);
var ResizeObserverEntry = (
  /** @class */
  function() {
    function ResizeObserverEntry2(target, rectInit) {
      var contentRect = createReadOnlyRect(rectInit);
      defineConfigurable(this, { target, contentRect });
    }
    return ResizeObserverEntry2;
  }()
);
var ResizeObserverSPI = (
  /** @class */
  function() {
    function ResizeObserverSPI2(callback, controller, callbackCtx) {
      this.activeObservations_ = [];
      this.observations_ = new MapShim();
      if (typeof callback !== "function") {
        throw new TypeError("The callback provided as parameter 1 is not a function.");
      }
      this.callback_ = callback;
      this.controller_ = controller;
      this.callbackCtx_ = callbackCtx;
    }
    ResizeObserverSPI2.prototype.observe = function(target) {
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      if (typeof Element === "undefined" || !(Element instanceof Object)) {
        return;
      }
      if (!(target instanceof getWindowOf(target).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
      }
      var observations = this.observations_;
      if (observations.has(target)) {
        return;
      }
      observations.set(target, new ResizeObservation(target));
      this.controller_.addObserver(this);
      this.controller_.refresh();
    };
    ResizeObserverSPI2.prototype.unobserve = function(target) {
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      if (typeof Element === "undefined" || !(Element instanceof Object)) {
        return;
      }
      if (!(target instanceof getWindowOf(target).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
      }
      var observations = this.observations_;
      if (!observations.has(target)) {
        return;
      }
      observations.delete(target);
      if (!observations.size) {
        this.controller_.removeObserver(this);
      }
    };
    ResizeObserverSPI2.prototype.disconnect = function() {
      this.clearActive();
      this.observations_.clear();
      this.controller_.removeObserver(this);
    };
    ResizeObserverSPI2.prototype.gatherActive = function() {
      var _this = this;
      this.clearActive();
      this.observations_.forEach(function(observation) {
        if (observation.isActive()) {
          _this.activeObservations_.push(observation);
        }
      });
    };
    ResizeObserverSPI2.prototype.broadcastActive = function() {
      if (!this.hasActive()) {
        return;
      }
      var ctx = this.callbackCtx_;
      var entries = this.activeObservations_.map(function(observation) {
        return new ResizeObserverEntry(observation.target, observation.broadcastRect());
      });
      this.callback_.call(ctx, entries, ctx);
      this.clearActive();
    };
    ResizeObserverSPI2.prototype.clearActive = function() {
      this.activeObservations_.splice(0);
    };
    ResizeObserverSPI2.prototype.hasActive = function() {
      return this.activeObservations_.length > 0;
    };
    return ResizeObserverSPI2;
  }()
);
var observers = typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim();
var ResizeObserver$2 = (
  /** @class */
  function() {
    function ResizeObserver2(callback) {
      if (!(this instanceof ResizeObserver2)) {
        throw new TypeError("Cannot call a class as a function.");
      }
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      var controller = ResizeObserverController.getInstance();
      var observer = new ResizeObserverSPI(callback, controller, this);
      observers.set(this, observer);
    }
    return ResizeObserver2;
  }()
);
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(method) {
  ResizeObserver$2.prototype[method] = function() {
    var _a;
    return (_a = observers.get(this))[method].apply(_a, arguments);
  };
});
var index$1 = function() {
  if (typeof global$1.ResizeObserver !== "undefined") {
    return global$1.ResizeObserver;
  }
  return ResizeObserver$2;
}();
var elementListeners = /* @__PURE__ */ new Map();
function onResize(entities) {
  entities.forEach(function(entity) {
    var _elementListeners$get;
    var target = entity.target;
    (_elementListeners$get = elementListeners.get(target)) === null || _elementListeners$get === void 0 ? void 0 : _elementListeners$get.forEach(function(listener) {
      return listener(target);
    });
  });
}
var resizeObserver = new index$1(onResize);
function observe(element, callback) {
  if (!elementListeners.has(element)) {
    elementListeners.set(element, /* @__PURE__ */ new Set());
    resizeObserver.observe(element);
  }
  elementListeners.get(element).add(callback);
}
function unobserve(element, callback) {
  if (elementListeners.has(element)) {
    elementListeners.get(element).delete(callback);
    if (!elementListeners.get(element).size) {
      resizeObserver.unobserve(element);
      elementListeners.delete(element);
    }
  }
}
var DomWrapper$1 = /* @__PURE__ */ function(_React$Component) {
  _inherits$5(DomWrapper2, _React$Component);
  var _super = _createSuper$4(DomWrapper2);
  function DomWrapper2() {
    _classCallCheck$5(this, DomWrapper2);
    return _super.apply(this, arguments);
  }
  _createClass$5(DomWrapper2, [{
    key: "render",
    value: function render() {
      return this.props.children;
    }
  }]);
  return DomWrapper2;
}(reactExports.Component);
var CollectionContext = /* @__PURE__ */ reactExports.createContext(null);
function Collection(_ref) {
  var children = _ref.children, onBatchResize = _ref.onBatchResize;
  var resizeIdRef = reactExports.useRef(0);
  var resizeInfosRef = reactExports.useRef([]);
  var onCollectionResize = reactExports.useContext(CollectionContext);
  var onResize2 = reactExports.useCallback(function(size, element, data2) {
    resizeIdRef.current += 1;
    var currentId = resizeIdRef.current;
    resizeInfosRef.current.push({
      size,
      element,
      data: data2
    });
    Promise.resolve().then(function() {
      if (currentId === resizeIdRef.current) {
        onBatchResize === null || onBatchResize === void 0 ? void 0 : onBatchResize(resizeInfosRef.current);
        resizeInfosRef.current = [];
      }
    });
    onCollectionResize === null || onCollectionResize === void 0 ? void 0 : onCollectionResize(size, element, data2);
  }, [onBatchResize, onCollectionResize]);
  return /* @__PURE__ */ reactExports.createElement(CollectionContext.Provider, {
    value: onResize2
  }, children);
}
function SingleObserver(props, ref2) {
  var children = props.children, disabled = props.disabled;
  var elementRef = reactExports.useRef(null);
  var wrapperRef = reactExports.useRef(null);
  var onCollectionResize = reactExports.useContext(CollectionContext);
  var isRenderProps = typeof children === "function";
  var mergedChildren = isRenderProps ? children(elementRef) : children;
  var sizeRef = reactExports.useRef({
    width: -1,
    height: -1,
    offsetWidth: -1,
    offsetHeight: -1
  });
  var canRef = !isRenderProps && /* @__PURE__ */ reactExports.isValidElement(mergedChildren) && supportRef(mergedChildren);
  var originRef = canRef ? mergedChildren.ref : null;
  var mergedRef = reactExports.useMemo(function() {
    return composeRef(originRef, elementRef);
  }, [originRef, elementRef]);
  var getDom = function getDom2() {
    return findDOMNode(elementRef.current) || findDOMNode(wrapperRef.current);
  };
  reactExports.useImperativeHandle(ref2, function() {
    return getDom();
  });
  var propsRef = reactExports.useRef(props);
  propsRef.current = props;
  var onInternalResize = reactExports.useCallback(function(target) {
    var _propsRef$current = propsRef.current, onResize2 = _propsRef$current.onResize, data2 = _propsRef$current.data;
    var _target$getBoundingCl = target.getBoundingClientRect(), width = _target$getBoundingCl.width, height = _target$getBoundingCl.height;
    var offsetWidth = target.offsetWidth, offsetHeight = target.offsetHeight;
    var fixedWidth = Math.floor(width);
    var fixedHeight = Math.floor(height);
    if (sizeRef.current.width !== fixedWidth || sizeRef.current.height !== fixedHeight || sizeRef.current.offsetWidth !== offsetWidth || sizeRef.current.offsetHeight !== offsetHeight) {
      var size = {
        width: fixedWidth,
        height: fixedHeight,
        offsetWidth,
        offsetHeight
      };
      sizeRef.current = size;
      var mergedOffsetWidth = offsetWidth === Math.round(width) ? width : offsetWidth;
      var mergedOffsetHeight = offsetHeight === Math.round(height) ? height : offsetHeight;
      var sizeInfo = _objectSpread2(_objectSpread2({}, size), {}, {
        offsetWidth: mergedOffsetWidth,
        offsetHeight: mergedOffsetHeight
      });
      onCollectionResize === null || onCollectionResize === void 0 ? void 0 : onCollectionResize(sizeInfo, target, data2);
      if (onResize2) {
        Promise.resolve().then(function() {
          onResize2(sizeInfo, target);
        });
      }
    }
  }, []);
  reactExports.useEffect(function() {
    var currentElement = getDom();
    if (currentElement && !disabled) {
      observe(currentElement, onInternalResize);
    }
    return function() {
      return unobserve(currentElement, onInternalResize);
    };
  }, [elementRef.current, disabled]);
  return /* @__PURE__ */ reactExports.createElement(DomWrapper$1, {
    ref: wrapperRef
  }, canRef ? /* @__PURE__ */ reactExports.cloneElement(mergedChildren, {
    ref: mergedRef
  }) : mergedChildren);
}
var RefSingleObserver = /* @__PURE__ */ reactExports.forwardRef(SingleObserver);
var INTERNAL_PREFIX_KEY = "rc-observer-key";
function ResizeObserver$1(props, ref2) {
  var children = props.children;
  var childNodes = typeof children === "function" ? [children] : toArray(children);
  return childNodes.map(function(child, index2) {
    var key = (child === null || child === void 0 ? void 0 : child.key) || "".concat(INTERNAL_PREFIX_KEY, "-").concat(index2);
    return /* @__PURE__ */ reactExports.createElement(RefSingleObserver, _extends$4({}, props, {
      key,
      ref: index2 === 0 ? ref2 : void 0
    }), child);
  });
}
var RefResizeObserver = /* @__PURE__ */ reactExports.forwardRef(ResizeObserver$1);
RefResizeObserver.Collection = Collection;
var Filler = /* @__PURE__ */ reactExports.forwardRef(function(_ref, ref2) {
  var height = _ref.height, offsetY = _ref.offsetY, offsetX = _ref.offsetX, children = _ref.children, prefixCls = _ref.prefixCls, onInnerResize = _ref.onInnerResize, innerProps = _ref.innerProps, rtl = _ref.rtl, extra = _ref.extra;
  var outerStyle = {};
  var innerStyle = {
    display: "flex",
    flexDirection: "column"
  };
  if (offsetY !== void 0) {
    var _objectSpread2$1;
    outerStyle = {
      height,
      position: "relative",
      overflow: "hidden"
    };
    innerStyle = _objectSpread2(_objectSpread2({}, innerStyle), {}, (_objectSpread2$1 = {
      transform: "translateY(".concat(offsetY, "px)")
    }, _defineProperty$2(_objectSpread2$1, rtl ? "marginRight" : "marginLeft", -offsetX), _defineProperty$2(_objectSpread2$1, "position", "absolute"), _defineProperty$2(_objectSpread2$1, "left", 0), _defineProperty$2(_objectSpread2$1, "right", 0), _defineProperty$2(_objectSpread2$1, "top", 0), _objectSpread2$1));
  }
  return /* @__PURE__ */ reactExports.createElement("div", {
    style: outerStyle
  }, /* @__PURE__ */ reactExports.createElement(RefResizeObserver, {
    onResize: function onResize2(_ref2) {
      var offsetHeight = _ref2.offsetHeight;
      if (offsetHeight && onInnerResize) {
        onInnerResize();
      }
    }
  }, /* @__PURE__ */ reactExports.createElement("div", _extends$4({
    style: innerStyle,
    className: classNames(_defineProperty$2({}, "".concat(prefixCls, "-holder-inner"), prefixCls)),
    ref: ref2
  }, innerProps), children, extra)));
});
Filler.displayName = "Filler";
var raf = function raf2(callback) {
  return +setTimeout(callback, 16);
};
var caf = function caf2(num) {
  return clearTimeout(num);
};
if (typeof window !== "undefined" && "requestAnimationFrame" in window) {
  raf = function raf3(callback) {
    return window.requestAnimationFrame(callback);
  };
  caf = function caf3(handle) {
    return window.cancelAnimationFrame(handle);
  };
}
var rafUUID = 0;
var rafIds = /* @__PURE__ */ new Map();
function cleanup(id2) {
  rafIds.delete(id2);
}
var wrapperRaf = function wrapperRaf2(callback) {
  var times = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  rafUUID += 1;
  var id2 = rafUUID;
  function callRef(leftTimes) {
    if (leftTimes === 0) {
      cleanup(id2);
      callback();
    } else {
      var realId = raf(function() {
        callRef(leftTimes - 1);
      });
      rafIds.set(id2, realId);
    }
  }
  callRef(times);
  return id2;
};
wrapperRaf.cancel = function(id2) {
  var realId = rafIds.get(id2);
  cleanup(realId);
  return caf(realId);
};
function getPageXY(e3, horizontal) {
  var obj = "touches" in e3 ? e3.touches[0] : e3;
  return obj[horizontal ? "pageX" : "pageY"];
}
var ScrollBar$3 = /* @__PURE__ */ reactExports.forwardRef(function(props, ref2) {
  var _classNames;
  var prefixCls = props.prefixCls, rtl = props.rtl, scrollOffset = props.scrollOffset, scrollRange = props.scrollRange, onStartMove = props.onStartMove, onStopMove = props.onStopMove, onScroll = props.onScroll, horizontal = props.horizontal, spinSize = props.spinSize, containerSize = props.containerSize, style2 = props.style, propsThumbStyle = props.thumbStyle;
  var _React$useState = reactExports.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), dragging = _React$useState2[0], setDragging = _React$useState2[1];
  var _React$useState3 = reactExports.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), pageXY = _React$useState4[0], setPageXY = _React$useState4[1];
  var _React$useState5 = reactExports.useState(null), _React$useState6 = _slicedToArray(_React$useState5, 2), startTop = _React$useState6[0], setStartTop = _React$useState6[1];
  var isLTR = !rtl;
  var scrollbarRef = reactExports.useRef();
  var thumbRef = reactExports.useRef();
  var _React$useState7 = reactExports.useState(false), _React$useState8 = _slicedToArray(_React$useState7, 2), visible = _React$useState8[0], setVisible = _React$useState8[1];
  var visibleTimeoutRef = reactExports.useRef();
  var delayHidden = function delayHidden2() {
    clearTimeout(visibleTimeoutRef.current);
    setVisible(true);
    visibleTimeoutRef.current = setTimeout(function() {
      setVisible(false);
    }, 3e3);
  };
  var enableScrollRange = scrollRange - containerSize || 0;
  var enableOffsetRange = containerSize - spinSize || 0;
  var canScroll = enableScrollRange > 0;
  var top = reactExports.useMemo(function() {
    if (scrollOffset === 0 || enableScrollRange === 0) {
      return 0;
    }
    var ptg = scrollOffset / enableScrollRange;
    return ptg * enableOffsetRange;
  }, [scrollOffset, enableScrollRange, enableOffsetRange]);
  var onContainerMouseDown = function onContainerMouseDown2(e3) {
    e3.stopPropagation();
    e3.preventDefault();
  };
  var stateRef = reactExports.useRef({
    top,
    dragging,
    pageY: pageXY,
    startTop
  });
  stateRef.current = {
    top,
    dragging,
    pageY: pageXY,
    startTop
  };
  var onThumbMouseDown = function onThumbMouseDown2(e3) {
    setDragging(true);
    setPageXY(getPageXY(e3, horizontal));
    setStartTop(stateRef.current.top);
    onStartMove();
    e3.stopPropagation();
    e3.preventDefault();
  };
  reactExports.useEffect(function() {
    var onScrollbarTouchStart = function onScrollbarTouchStart2(e3) {
      e3.preventDefault();
    };
    var scrollbarEle = scrollbarRef.current;
    var thumbEle = thumbRef.current;
    scrollbarEle.addEventListener("touchstart", onScrollbarTouchStart);
    thumbEle.addEventListener("touchstart", onThumbMouseDown);
    return function() {
      scrollbarEle.removeEventListener("touchstart", onScrollbarTouchStart);
      thumbEle.removeEventListener("touchstart", onThumbMouseDown);
    };
  }, []);
  var enableScrollRangeRef = reactExports.useRef();
  enableScrollRangeRef.current = enableScrollRange;
  var enableOffsetRangeRef = reactExports.useRef();
  enableOffsetRangeRef.current = enableOffsetRange;
  reactExports.useEffect(function() {
    if (dragging) {
      var moveRafId;
      var onMouseMove = function onMouseMove2(e3) {
        var _stateRef$current = stateRef.current, stateDragging = _stateRef$current.dragging, statePageY = _stateRef$current.pageY, stateStartTop = _stateRef$current.startTop;
        wrapperRaf.cancel(moveRafId);
        if (stateDragging) {
          var offset2 = getPageXY(e3, horizontal) - statePageY;
          var newTop = stateStartTop;
          if (!isLTR && horizontal) {
            newTop -= offset2;
          } else {
            newTop += offset2;
          }
          var tmpEnableScrollRange = enableScrollRangeRef.current;
          var tmpEnableOffsetRange = enableOffsetRangeRef.current;
          var ptg = tmpEnableOffsetRange ? newTop / tmpEnableOffsetRange : 0;
          var newScrollTop = Math.ceil(ptg * tmpEnableScrollRange);
          newScrollTop = Math.max(newScrollTop, 0);
          newScrollTop = Math.min(newScrollTop, tmpEnableScrollRange);
          moveRafId = wrapperRaf(function() {
            onScroll(newScrollTop, horizontal);
          });
        }
      };
      var onMouseUp = function onMouseUp2() {
        setDragging(false);
        onStopMove();
      };
      window.addEventListener("mousemove", onMouseMove);
      window.addEventListener("touchmove", onMouseMove);
      window.addEventListener("mouseup", onMouseUp);
      window.addEventListener("touchend", onMouseUp);
      return function() {
        window.removeEventListener("mousemove", onMouseMove);
        window.removeEventListener("touchmove", onMouseMove);
        window.removeEventListener("mouseup", onMouseUp);
        window.removeEventListener("touchend", onMouseUp);
        wrapperRaf.cancel(moveRafId);
      };
    }
  }, [dragging]);
  reactExports.useEffect(function() {
    delayHidden();
  }, [scrollOffset]);
  reactExports.useImperativeHandle(ref2, function() {
    return {
      delayHidden
    };
  });
  var scrollbarPrefixCls = "".concat(prefixCls, "-scrollbar");
  var containerStyle = {
    position: "absolute",
    visibility: visible && canScroll ? null : "hidden"
  };
  var thumbStyle = {
    position: "absolute",
    background: "rgba(0, 0, 0, 0.5)",
    borderRadius: 99,
    cursor: "pointer",
    userSelect: "none"
  };
  if (horizontal) {
    containerStyle.height = 8;
    containerStyle.left = 0;
    containerStyle.right = 0;
    containerStyle.bottom = 0;
    thumbStyle.height = "100%";
    thumbStyle.width = spinSize;
    if (isLTR) {
      thumbStyle.left = top;
    } else {
      thumbStyle.right = top;
    }
  } else {
    containerStyle.width = 8;
    containerStyle.top = 0;
    containerStyle.bottom = 0;
    if (isLTR) {
      containerStyle.right = 0;
    } else {
      containerStyle.left = 0;
    }
    thumbStyle.width = "100%";
    thumbStyle.height = spinSize;
    thumbStyle.top = top;
  }
  return /* @__PURE__ */ reactExports.createElement("div", {
    ref: scrollbarRef,
    className: classNames(scrollbarPrefixCls, (_classNames = {}, _defineProperty$2(_classNames, "".concat(scrollbarPrefixCls, "-horizontal"), horizontal), _defineProperty$2(_classNames, "".concat(scrollbarPrefixCls, "-vertical"), !horizontal), _defineProperty$2(_classNames, "".concat(scrollbarPrefixCls, "-visible"), visible), _classNames)),
    style: _objectSpread2(_objectSpread2({}, containerStyle), style2),
    onMouseDown: onContainerMouseDown,
    onMouseMove: delayHidden
  }, /* @__PURE__ */ reactExports.createElement("div", {
    ref: thumbRef,
    className: classNames("".concat(scrollbarPrefixCls, "-thumb"), _defineProperty$2({}, "".concat(scrollbarPrefixCls, "-thumb-moving"), dragging)),
    style: _objectSpread2(_objectSpread2({}, thumbStyle), propsThumbStyle),
    onMouseDown: onThumbMouseDown
  }));
});
function Item(_ref) {
  var children = _ref.children, setRef = _ref.setRef;
  var refFunc = reactExports.useCallback(function(node) {
    setRef(node);
  }, []);
  return /* @__PURE__ */ reactExports.cloneElement(children, {
    ref: refFunc
  });
}
function useChildren(list, startIndex, endIndex, scrollWidth, setNodeRef, renderFunc, _ref) {
  var getKey2 = _ref.getKey;
  return list.slice(startIndex, endIndex + 1).map(function(item, index2) {
    var eleIndex = startIndex + index2;
    var node = renderFunc(item, eleIndex, {
      style: {
        width: scrollWidth
      }
    });
    var key = getKey2(item);
    return /* @__PURE__ */ reactExports.createElement(Item, {
      key,
      setRef: function setRef(ele) {
        return setNodeRef(item, ele);
      }
    }, node);
  });
}
var CacheMap = /* @__PURE__ */ function() {
  function CacheMap2() {
    _classCallCheck$5(this, CacheMap2);
    this.maps = void 0;
    this.id = 0;
    this.maps = /* @__PURE__ */ Object.create(null);
  }
  _createClass$5(CacheMap2, [{
    key: "set",
    value: function set4(key, value2) {
      this.maps[key] = value2;
      this.id += 1;
    }
  }, {
    key: "get",
    value: function get3(key) {
      return this.maps[key];
    }
  }]);
  return CacheMap2;
}();
function useHeights(getKey2, onItemAdd, onItemRemove) {
  var _React$useState = reactExports.useState(0), _React$useState2 = _slicedToArray(_React$useState, 2), updatedMark = _React$useState2[0], setUpdatedMark = _React$useState2[1];
  var instanceRef = reactExports.useRef(/* @__PURE__ */ new Map());
  var heightsRef = reactExports.useRef(new CacheMap());
  var collectRafRef = reactExports.useRef();
  function cancelRaf() {
    wrapperRaf.cancel(collectRafRef.current);
  }
  function collectHeight() {
    var sync = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    cancelRaf();
    var doCollect = function doCollect2() {
      instanceRef.current.forEach(function(element, key) {
        if (element && element.offsetParent) {
          var htmlElement = findDOMNode(element);
          var offsetHeight = htmlElement.offsetHeight;
          if (heightsRef.current.get(key) !== offsetHeight) {
            heightsRef.current.set(key, htmlElement.offsetHeight);
          }
        }
      });
      setUpdatedMark(function(c6) {
        return c6 + 1;
      });
    };
    if (sync) {
      doCollect();
    } else {
      collectRafRef.current = wrapperRaf(doCollect);
    }
  }
  function setInstanceRef(item, instance2) {
    var key = getKey2(item);
    var origin = instanceRef.current.get(key);
    if (instance2) {
      instanceRef.current.set(key, instance2);
      collectHeight();
    } else {
      instanceRef.current.delete(key);
    }
    if (!origin !== !instance2) {
      if (instance2) {
        onItemAdd === null || onItemAdd === void 0 ? void 0 : onItemAdd(item);
      } else {
        onItemRemove === null || onItemRemove === void 0 ? void 0 : onItemRemove(item);
      }
    }
  }
  reactExports.useEffect(function() {
    return cancelRaf;
  }, []);
  return [setInstanceRef, collectHeight, heightsRef.current, updatedMark];
}
function useEvent(callback) {
  var fnRef = reactExports.useRef();
  fnRef.current = callback;
  var memoFn = reactExports.useCallback(function() {
    var _fnRef$current;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return (_fnRef$current = fnRef.current) === null || _fnRef$current === void 0 ? void 0 : _fnRef$current.call.apply(_fnRef$current, [fnRef].concat(args));
  }, []);
  return memoFn;
}
function useSafeState(defaultValue) {
  var destroyRef = reactExports.useRef(false);
  var _React$useState = reactExports.useState(defaultValue), _React$useState2 = _slicedToArray(_React$useState, 2), value2 = _React$useState2[0], setValue2 = _React$useState2[1];
  reactExports.useEffect(function() {
    destroyRef.current = false;
    return function() {
      destroyRef.current = true;
    };
  }, []);
  function safeSetState(updater, ignoreDestroy) {
    if (ignoreDestroy && destroyRef.current) {
      return;
    }
    setValue2(updater);
  }
  return [value2, safeSetState];
}
var MAX_TIMES = 10;
function useScrollTo(containerRef, data2, heights, itemHeight, getKey2, collectHeight, syncScrollTop, triggerFlash) {
  var scrollRef = reactExports.useRef();
  var _React$useState = reactExports.useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), syncState = _React$useState2[0], setSyncState = _React$useState2[1];
  useLayoutEffect(function() {
    if (syncState && syncState.times < MAX_TIMES) {
      if (!containerRef.current) {
        setSyncState(function(ori) {
          return _objectSpread2({}, ori);
        });
        return;
      }
      collectHeight();
      var targetAlign = syncState.targetAlign, originAlign = syncState.originAlign, index2 = syncState.index, offset2 = syncState.offset;
      var height = containerRef.current.clientHeight;
      var needCollectHeight = false;
      var newTargetAlign = targetAlign;
      var targetTop = null;
      if (height) {
        var mergedAlign = targetAlign || originAlign;
        var stackTop = 0;
        var itemTop = 0;
        var itemBottom = 0;
        var maxLen = Math.min(data2.length - 1, index2);
        for (var i16 = 0; i16 <= maxLen; i16 += 1) {
          var key = getKey2(data2[i16]);
          itemTop = stackTop;
          var cacheHeight = heights.get(key);
          itemBottom = itemTop + (cacheHeight === void 0 ? itemHeight : cacheHeight);
          stackTop = itemBottom;
        }
        var leftHeight = mergedAlign === "top" ? offset2 : height - offset2;
        for (var _i = maxLen; _i >= 0; _i -= 1) {
          var _key = getKey2(data2[_i]);
          var _cacheHeight = heights.get(_key);
          if (_cacheHeight === void 0) {
            needCollectHeight = true;
            break;
          }
          leftHeight -= _cacheHeight;
          if (leftHeight <= 0) {
            break;
          }
        }
        switch (mergedAlign) {
          case "top":
            targetTop = itemTop - offset2;
            break;
          case "bottom":
            targetTop = itemBottom - height + offset2;
            break;
          default: {
            var scrollTop = containerRef.current.scrollTop;
            var scrollBottom = scrollTop + height;
            if (itemTop < scrollTop) {
              newTargetAlign = "top";
            } else if (itemBottom > scrollBottom) {
              newTargetAlign = "bottom";
            }
          }
        }
        if (targetTop !== null) {
          syncScrollTop(targetTop);
        }
        if (targetTop !== syncState.lastTop) {
          needCollectHeight = true;
        }
      }
      if (needCollectHeight) {
        setSyncState(function(ori) {
          return _objectSpread2(_objectSpread2({}, ori), {}, {
            times: ori.times + 1,
            targetAlign: newTargetAlign,
            lastTop: targetTop
          });
        });
      }
    }
  }, [syncState, containerRef.current]);
  return function(arg) {
    if (arg === null || arg === void 0) {
      triggerFlash();
      return;
    }
    wrapperRaf.cancel(scrollRef.current);
    if (typeof arg === "number") {
      syncScrollTop(arg);
    } else if (arg && _typeof$6(arg) === "object") {
      var index2;
      var align2 = arg.align;
      if ("index" in arg) {
        index2 = arg.index;
      } else {
        index2 = data2.findIndex(function(item) {
          return getKey2(item) === arg.key;
        });
      }
      var _arg$offset = arg.offset, offset2 = _arg$offset === void 0 ? 0 : _arg$offset;
      setSyncState({
        times: 0,
        index: index2,
        offset: offset2,
        originAlign: align2
      });
    }
  };
}
function findListDiffIndex(originList, targetList, getKey2) {
  var originLen = originList.length;
  var targetLen = targetList.length;
  var shortList;
  var longList;
  if (originLen === 0 && targetLen === 0) {
    return null;
  }
  if (originLen < targetLen) {
    shortList = originList;
    longList = targetList;
  } else {
    shortList = targetList;
    longList = originList;
  }
  var notExistKey = {
    __EMPTY_ITEM__: true
  };
  function getItemKey(item) {
    if (item !== void 0) {
      return getKey2(item);
    }
    return notExistKey;
  }
  var diffIndex = null;
  var multiple = Math.abs(originLen - targetLen) !== 1;
  for (var i16 = 0; i16 < longList.length; i16 += 1) {
    var shortKey = getItemKey(shortList[i16]);
    var longKey = getItemKey(longList[i16]);
    if (shortKey !== longKey) {
      diffIndex = i16;
      multiple = multiple || shortKey !== getItemKey(longList[i16 + 1]);
      break;
    }
  }
  return diffIndex === null ? null : {
    index: diffIndex,
    multiple
  };
}
function useDiffItem(data2, getKey2, onDiff) {
  var _React$useState = reactExports.useState(data2), _React$useState2 = _slicedToArray(_React$useState, 2), prevData = _React$useState2[0], setPrevData = _React$useState2[1];
  var _React$useState3 = reactExports.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), diffItem = _React$useState4[0], setDiffItem = _React$useState4[1];
  reactExports.useEffect(function() {
    var diff = findListDiffIndex(prevData || [], data2 || [], getKey2);
    if ((diff === null || diff === void 0 ? void 0 : diff.index) !== void 0) {
      onDiff === null || onDiff === void 0 ? void 0 : onDiff(diff.index);
      setDiffItem(data2[diff.index]);
    }
    setPrevData(data2);
  }, [data2]);
  return [diffItem];
}
var isFF = (typeof navigator === "undefined" ? "undefined" : _typeof$6(navigator)) === "object" && /Firefox/i.test(navigator.userAgent);
const useOriginScroll = function(isScrollAtTop, isScrollAtBottom) {
  var lockRef = reactExports.useRef(false);
  var lockTimeoutRef = reactExports.useRef(null);
  function lockScroll() {
    clearTimeout(lockTimeoutRef.current);
    lockRef.current = true;
    lockTimeoutRef.current = setTimeout(function() {
      lockRef.current = false;
    }, 50);
  }
  var scrollPingRef = reactExports.useRef({
    top: isScrollAtTop,
    bottom: isScrollAtBottom
  });
  scrollPingRef.current.top = isScrollAtTop;
  scrollPingRef.current.bottom = isScrollAtBottom;
  return function(deltaY) {
    var smoothOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var originScroll = (
      // Pass origin wheel when on the top
      deltaY < 0 && scrollPingRef.current.top || // Pass origin wheel when on the bottom
      deltaY > 0 && scrollPingRef.current.bottom
    );
    if (smoothOffset && originScroll) {
      clearTimeout(lockTimeoutRef.current);
      lockRef.current = false;
    } else if (!originScroll || lockRef.current) {
      lockScroll();
    }
    return !lockRef.current && originScroll;
  };
};
function useFrameWheel(inVirtual, isScrollAtTop, isScrollAtBottom, horizontalScroll, onWheelDelta) {
  var offsetRef = reactExports.useRef(0);
  var nextFrameRef = reactExports.useRef(null);
  var wheelValueRef = reactExports.useRef(null);
  var isMouseScrollRef = reactExports.useRef(false);
  var originScroll = useOriginScroll(isScrollAtTop, isScrollAtBottom);
  function onWheelY(event, deltaY) {
    wrapperRaf.cancel(nextFrameRef.current);
    offsetRef.current += deltaY;
    wheelValueRef.current = deltaY;
    if (originScroll(deltaY))
      return;
    if (!isFF) {
      event.preventDefault();
    }
    nextFrameRef.current = wrapperRaf(function() {
      var patchMultiple = isMouseScrollRef.current ? 10 : 1;
      onWheelDelta(offsetRef.current * patchMultiple);
      offsetRef.current = 0;
    });
  }
  function onWheelX(event, deltaX) {
    onWheelDelta(deltaX, true);
    if (!isFF) {
      event.preventDefault();
    }
  }
  var wheelDirectionRef = reactExports.useRef(null);
  var wheelDirectionCleanRef = reactExports.useRef(null);
  function onWheel(event) {
    if (!inVirtual)
      return;
    wrapperRaf.cancel(wheelDirectionCleanRef.current);
    wheelDirectionCleanRef.current = wrapperRaf(function() {
      wheelDirectionRef.current = null;
    }, 2);
    var deltaX = event.deltaX, deltaY = event.deltaY, shiftKey = event.shiftKey;
    var mergedDeltaX = deltaX;
    var mergedDeltaY = deltaY;
    if (wheelDirectionRef.current === "sx" || !wheelDirectionRef.current && (shiftKey || false) && deltaY && !deltaX) {
      mergedDeltaX = deltaY;
      mergedDeltaY = 0;
      wheelDirectionRef.current = "sx";
    }
    var absX = Math.abs(mergedDeltaX);
    var absY = Math.abs(mergedDeltaY);
    if (wheelDirectionRef.current === null) {
      wheelDirectionRef.current = horizontalScroll && absX > absY ? "x" : "y";
    }
    if (wheelDirectionRef.current === "y") {
      onWheelY(event, mergedDeltaY);
    } else {
      onWheelX(event, mergedDeltaX);
    }
  }
  function onFireFoxScroll(event) {
    if (!inVirtual)
      return;
    isMouseScrollRef.current = event.detail === wheelValueRef.current;
  }
  return [onWheel, onFireFoxScroll];
}
var SMOOTH_PTG = 14 / 15;
function useMobileTouchMove(inVirtual, listRef, callback) {
  var touchedRef = reactExports.useRef(false);
  var touchYRef = reactExports.useRef(0);
  var elementRef = reactExports.useRef(null);
  var intervalRef = reactExports.useRef(null);
  var cleanUpEvents;
  var onTouchMove = function onTouchMove2(e3) {
    if (touchedRef.current) {
      var currentY = Math.ceil(e3.touches[0].pageY);
      var offsetY = touchYRef.current - currentY;
      touchYRef.current = currentY;
      if (callback(offsetY)) {
        e3.preventDefault();
      }
      clearInterval(intervalRef.current);
      intervalRef.current = setInterval(function() {
        offsetY *= SMOOTH_PTG;
        if (!callback(offsetY, true) || Math.abs(offsetY) <= 0.1) {
          clearInterval(intervalRef.current);
        }
      }, 16);
    }
  };
  var onTouchEnd = function onTouchEnd2() {
    touchedRef.current = false;
    cleanUpEvents();
  };
  var onTouchStart = function onTouchStart2(e3) {
    cleanUpEvents();
    if (e3.touches.length === 1 && !touchedRef.current) {
      touchedRef.current = true;
      touchYRef.current = Math.ceil(e3.touches[0].pageY);
      elementRef.current = e3.target;
      elementRef.current.addEventListener("touchmove", onTouchMove);
      elementRef.current.addEventListener("touchend", onTouchEnd);
    }
  };
  cleanUpEvents = function cleanUpEvents2() {
    if (elementRef.current) {
      elementRef.current.removeEventListener("touchmove", onTouchMove);
      elementRef.current.removeEventListener("touchend", onTouchEnd);
    }
  };
  useLayoutEffect(function() {
    if (inVirtual) {
      listRef.current.addEventListener("touchstart", onTouchStart);
    }
    return function() {
      var _listRef$current;
      (_listRef$current = listRef.current) === null || _listRef$current === void 0 ? void 0 : _listRef$current.removeEventListener("touchstart", onTouchStart);
      cleanUpEvents();
      clearInterval(intervalRef.current);
    };
  }, [inVirtual]);
}
var MIN_SIZE = 20;
function getSpinSize() {
  var containerSize = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
  var scrollRange = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var baseSize = containerSize / scrollRange * 100;
  if (isNaN(baseSize)) {
    baseSize = 0;
  }
  baseSize = Math.max(baseSize, MIN_SIZE);
  baseSize = Math.min(baseSize, containerSize / 2);
  return Math.floor(baseSize);
}
function useGetSize(mergedData, getKey2, heights, itemHeight) {
  var _React$useMemo = reactExports.useMemo(function() {
    return [/* @__PURE__ */ new Map(), []];
  }, [mergedData, heights.id, itemHeight]), _React$useMemo2 = _slicedToArray(_React$useMemo, 2), key2Index = _React$useMemo2[0], bottomList = _React$useMemo2[1];
  var getSize = function getSize2(startKey) {
    var endKey = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : startKey;
    var startIndex = key2Index.get(startKey);
    var endIndex = key2Index.get(endKey);
    if (startIndex === void 0 || endIndex === void 0) {
      var dataLen = mergedData.length;
      for (var i16 = bottomList.length; i16 < dataLen; i16 += 1) {
        var _heights$get;
        var item = mergedData[i16];
        var key = getKey2(item);
        key2Index.set(key, i16);
        var cacheHeight = (_heights$get = heights.get(key)) !== null && _heights$get !== void 0 ? _heights$get : itemHeight;
        bottomList[i16] = (bottomList[i16 - 1] || 0) + cacheHeight;
        if (key === startKey) {
          startIndex = i16;
        }
        if (key === endKey) {
          endIndex = i16;
        }
        if (startIndex !== void 0 && endIndex !== void 0) {
          break;
        }
      }
    }
    return {
      top: bottomList[startIndex - 1] || 0,
      bottom: bottomList[endIndex]
    };
  };
  return getSize;
}
var _excluded$7 = ["prefixCls", "className", "height", "itemHeight", "fullHeight", "style", "data", "children", "itemKey", "virtual", "direction", "scrollWidth", "component", "onScroll", "onVirtualScroll", "onVisibleChange", "innerProps", "extraRender", "styles"];
var EMPTY_DATA = [];
var ScrollStyle = {
  overflowY: "auto",
  overflowAnchor: "none"
};
function RawList(props, ref2) {
  var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-virtual-list" : _props$prefixCls, className = props.className, height = props.height, itemHeight = props.itemHeight, _props$fullHeight = props.fullHeight, fullHeight = _props$fullHeight === void 0 ? true : _props$fullHeight, style2 = props.style, data2 = props.data, children = props.children, itemKey2 = props.itemKey, virtual = props.virtual, direction = props.direction, scrollWidth = props.scrollWidth, _props$component = props.component, Component2 = _props$component === void 0 ? "div" : _props$component, onScroll = props.onScroll, onVirtualScroll = props.onVirtualScroll, onVisibleChange = props.onVisibleChange, innerProps = props.innerProps, extraRender = props.extraRender, styles = props.styles, restProps = _objectWithoutProperties$3(props, _excluded$7);
  var useVirtual = !!(virtual !== false && height && itemHeight);
  var inVirtual = useVirtual && data2 && (itemHeight * data2.length > height || !!scrollWidth);
  var isRTL = direction === "rtl";
  var mergedClassName = classNames(prefixCls, _defineProperty$2({}, "".concat(prefixCls, "-rtl"), isRTL), className);
  var mergedData = data2 || EMPTY_DATA;
  var componentRef = reactExports.useRef();
  var fillerInnerRef = reactExports.useRef();
  var _useState = reactExports.useState(0), _useState2 = _slicedToArray(_useState, 2), offsetTop = _useState2[0], setOffsetTop = _useState2[1];
  var _useState3 = reactExports.useState(0), _useState4 = _slicedToArray(_useState3, 2), offsetLeft = _useState4[0], setOffsetLeft = _useState4[1];
  var _useState5 = reactExports.useState(false), _useState6 = _slicedToArray(_useState5, 2), scrollMoving = _useState6[0], setScrollMoving = _useState6[1];
  var onScrollbarStartMove = function onScrollbarStartMove2() {
    setScrollMoving(true);
  };
  var onScrollbarStopMove = function onScrollbarStopMove2() {
    setScrollMoving(false);
  };
  var getKey2 = reactExports.useCallback(function(item) {
    if (typeof itemKey2 === "function") {
      return itemKey2(item);
    }
    return item === null || item === void 0 ? void 0 : item[itemKey2];
  }, [itemKey2]);
  var sharedConfig = {
    getKey: getKey2
  };
  function syncScrollTop(newTop) {
    setOffsetTop(function(origin) {
      var value2;
      if (typeof newTop === "function") {
        value2 = newTop(origin);
      } else {
        value2 = newTop;
      }
      var alignedTop = keepInRange(value2);
      componentRef.current.scrollTop = alignedTop;
      return alignedTop;
    });
  }
  var rangeRef = reactExports.useRef({
    start: 0,
    end: mergedData.length
  });
  var diffItemRef = reactExports.useRef();
  var _useDiffItem = useDiffItem(mergedData, getKey2), _useDiffItem2 = _slicedToArray(_useDiffItem, 1), diffItem = _useDiffItem2[0];
  diffItemRef.current = diffItem;
  var _useHeights = useHeights(getKey2, null, null), _useHeights2 = _slicedToArray(_useHeights, 4), setInstanceRef = _useHeights2[0], collectHeight = _useHeights2[1], heights = _useHeights2[2], heightUpdatedMark = _useHeights2[3];
  var _React$useMemo = reactExports.useMemo(function() {
    if (!useVirtual) {
      return {
        scrollHeight: void 0,
        start: 0,
        end: mergedData.length - 1,
        offset: void 0
      };
    }
    if (!inVirtual) {
      var _fillerInnerRef$curre;
      return {
        scrollHeight: ((_fillerInnerRef$curre = fillerInnerRef.current) === null || _fillerInnerRef$curre === void 0 ? void 0 : _fillerInnerRef$curre.offsetHeight) || 0,
        start: 0,
        end: mergedData.length - 1,
        offset: void 0
      };
    }
    var itemTop = 0;
    var startIndex;
    var startOffset;
    var endIndex;
    var dataLen = mergedData.length;
    for (var i16 = 0; i16 < dataLen; i16 += 1) {
      var item = mergedData[i16];
      var key = getKey2(item);
      var cacheHeight = heights.get(key);
      var currentItemBottom = itemTop + (cacheHeight === void 0 ? itemHeight : cacheHeight);
      if (currentItemBottom >= offsetTop && startIndex === void 0) {
        startIndex = i16;
        startOffset = itemTop;
      }
      if (currentItemBottom > offsetTop + height && endIndex === void 0) {
        endIndex = i16;
      }
      itemTop = currentItemBottom;
    }
    if (startIndex === void 0) {
      startIndex = 0;
      startOffset = 0;
      endIndex = Math.ceil(height / itemHeight);
    }
    if (endIndex === void 0) {
      endIndex = mergedData.length - 1;
    }
    endIndex = Math.min(endIndex + 1, mergedData.length - 1);
    return {
      scrollHeight: itemTop,
      start: startIndex,
      end: endIndex,
      offset: startOffset
    };
  }, [inVirtual, useVirtual, offsetTop, mergedData, heightUpdatedMark, height]), scrollHeight = _React$useMemo.scrollHeight, start = _React$useMemo.start, end = _React$useMemo.end, fillerOffset = _React$useMemo.offset;
  rangeRef.current.start = start;
  rangeRef.current.end = end;
  var _React$useState = reactExports.useState({
    width: 0,
    height
  }), _React$useState2 = _slicedToArray(_React$useState, 2), size = _React$useState2[0], setSize = _React$useState2[1];
  var onHolderResize = function onHolderResize2(sizeInfo) {
    setSize({
      width: sizeInfo.width || sizeInfo.offsetWidth,
      height: sizeInfo.height || sizeInfo.offsetHeight
    });
  };
  var verticalScrollBarRef = reactExports.useRef();
  var horizontalScrollBarRef = reactExports.useRef();
  var horizontalScrollBarSpinSize = reactExports.useMemo(function() {
    return getSpinSize(size.width, scrollWidth);
  }, [size.width, scrollWidth]);
  var verticalScrollBarSpinSize = reactExports.useMemo(function() {
    return getSpinSize(size.height, scrollHeight);
  }, [size.height, scrollHeight]);
  var maxScrollHeight = scrollHeight - height;
  var maxScrollHeightRef = reactExports.useRef(maxScrollHeight);
  maxScrollHeightRef.current = maxScrollHeight;
  function keepInRange(newScrollTop) {
    var newTop = newScrollTop;
    if (!Number.isNaN(maxScrollHeightRef.current)) {
      newTop = Math.min(newTop, maxScrollHeightRef.current);
    }
    newTop = Math.max(newTop, 0);
    return newTop;
  }
  var isScrollAtTop = offsetTop <= 0;
  var isScrollAtBottom = offsetTop >= maxScrollHeight;
  var originScroll = useOriginScroll(isScrollAtTop, isScrollAtBottom);
  var getVirtualScrollInfo = function getVirtualScrollInfo2() {
    return {
      x: isRTL ? -offsetLeft : offsetLeft,
      y: offsetTop
    };
  };
  var lastVirtualScrollInfoRef = reactExports.useRef(getVirtualScrollInfo());
  var triggerScroll = useEvent(function() {
    if (onVirtualScroll) {
      var nextInfo = getVirtualScrollInfo();
      if (lastVirtualScrollInfoRef.current.x !== nextInfo.x || lastVirtualScrollInfoRef.current.y !== nextInfo.y) {
        onVirtualScroll(nextInfo);
        lastVirtualScrollInfoRef.current = nextInfo;
      }
    }
  });
  function onScrollBar(newScrollOffset, horizontal) {
    var newOffset = newScrollOffset;
    if (horizontal) {
      reactDomExports.flushSync(function() {
        setOffsetLeft(newOffset);
      });
      triggerScroll();
    } else {
      syncScrollTop(newOffset);
    }
  }
  function onFallbackScroll(e3) {
    var newScrollTop = e3.currentTarget.scrollTop;
    if (newScrollTop !== offsetTop) {
      syncScrollTop(newScrollTop);
    }
    onScroll === null || onScroll === void 0 ? void 0 : onScroll(e3);
    triggerScroll();
  }
  var keepInHorizontalRange = function keepInHorizontalRange2(nextOffsetLeft) {
    var tmpOffsetLeft = nextOffsetLeft;
    var max2 = scrollWidth - size.width;
    tmpOffsetLeft = Math.max(tmpOffsetLeft, 0);
    tmpOffsetLeft = Math.min(tmpOffsetLeft, max2);
    return tmpOffsetLeft;
  };
  var onWheelDelta = useEvent(function(offsetXY, fromHorizontal) {
    if (fromHorizontal) {
      reactDomExports.flushSync(function() {
        setOffsetLeft(function(left) {
          var nextOffsetLeft = left + (isRTL ? -offsetXY : offsetXY);
          return keepInHorizontalRange(nextOffsetLeft);
        });
      });
      triggerScroll();
    } else {
      syncScrollTop(function(top) {
        var newTop = top + offsetXY;
        return newTop;
      });
    }
  });
  var _useFrameWheel = useFrameWheel(useVirtual, isScrollAtTop, isScrollAtBottom, !!scrollWidth, onWheelDelta), _useFrameWheel2 = _slicedToArray(_useFrameWheel, 2), onRawWheel = _useFrameWheel2[0], onFireFoxScroll = _useFrameWheel2[1];
  useMobileTouchMove(useVirtual, componentRef, function(deltaY, smoothOffset) {
    if (originScroll(deltaY, smoothOffset)) {
      return false;
    }
    onRawWheel({
      preventDefault: function preventDefault2() {
      },
      deltaY
    });
    return true;
  });
  useLayoutEffect(function() {
    function onMozMousePixelScroll(e3) {
      if (useVirtual) {
        e3.preventDefault();
      }
    }
    var componentEle = componentRef.current;
    componentEle.addEventListener("wheel", onRawWheel);
    componentEle.addEventListener("DOMMouseScroll", onFireFoxScroll);
    componentEle.addEventListener("MozMousePixelScroll", onMozMousePixelScroll);
    return function() {
      componentEle.removeEventListener("wheel", onRawWheel);
      componentEle.removeEventListener("DOMMouseScroll", onFireFoxScroll);
      componentEle.removeEventListener("MozMousePixelScroll", onMozMousePixelScroll);
    };
  }, [useVirtual]);
  useLayoutEffect(function() {
    if (scrollWidth) {
      setOffsetLeft(function(left) {
        return keepInHorizontalRange(left);
      });
    }
  }, [size.width, scrollWidth]);
  var delayHideScrollBar = function delayHideScrollBar2() {
    var _verticalScrollBarRef, _horizontalScrollBarR;
    (_verticalScrollBarRef = verticalScrollBarRef.current) === null || _verticalScrollBarRef === void 0 ? void 0 : _verticalScrollBarRef.delayHidden();
    (_horizontalScrollBarR = horizontalScrollBarRef.current) === null || _horizontalScrollBarR === void 0 ? void 0 : _horizontalScrollBarR.delayHidden();
  };
  var _scrollTo = useScrollTo(componentRef, mergedData, heights, itemHeight, getKey2, function() {
    return collectHeight(true);
  }, syncScrollTop, delayHideScrollBar);
  reactExports.useImperativeHandle(ref2, function() {
    return {
      getScrollInfo: getVirtualScrollInfo,
      scrollTo: function scrollTo(config2) {
        function isPosScroll(arg) {
          return arg && _typeof$6(arg) === "object" && ("left" in arg || "top" in arg);
        }
        if (isPosScroll(config2)) {
          if (config2.left !== void 0) {
            setOffsetLeft(keepInHorizontalRange(config2.left));
          }
          _scrollTo(config2.top);
        } else {
          _scrollTo(config2);
        }
      }
    };
  });
  useLayoutEffect(function() {
    if (onVisibleChange) {
      var renderList = mergedData.slice(start, end + 1);
      onVisibleChange(renderList, mergedData);
    }
  }, [start, end, mergedData]);
  var getSize = useGetSize(mergedData, getKey2, heights, itemHeight);
  var extraContent = extraRender === null || extraRender === void 0 ? void 0 : extraRender({
    start,
    end,
    virtual: inVirtual,
    offsetX: offsetLeft,
    offsetY: fillerOffset,
    rtl: isRTL,
    getSize
  });
  var listChildren = useChildren(mergedData, start, end, scrollWidth, setInstanceRef, children, sharedConfig);
  var componentStyle = null;
  if (height) {
    componentStyle = _objectSpread2(_defineProperty$2({}, fullHeight ? "height" : "maxHeight", height), ScrollStyle);
    if (useVirtual) {
      componentStyle.overflowY = "hidden";
      if (scrollWidth) {
        componentStyle.overflowX = "hidden";
      }
      if (scrollMoving) {
        componentStyle.pointerEvents = "none";
      }
    }
  }
  var containerProps = {};
  if (isRTL) {
    containerProps.dir = "rtl";
  }
  return /* @__PURE__ */ reactExports.createElement("div", _extends$4({
    style: _objectSpread2(_objectSpread2({}, style2), {}, {
      position: "relative"
    }),
    className: mergedClassName
  }, containerProps, restProps), /* @__PURE__ */ reactExports.createElement(RefResizeObserver, {
    onResize: onHolderResize
  }, /* @__PURE__ */ reactExports.createElement(Component2, {
    className: "".concat(prefixCls, "-holder"),
    style: componentStyle,
    ref: componentRef,
    onScroll: onFallbackScroll,
    onMouseEnter: delayHideScrollBar
  }, /* @__PURE__ */ reactExports.createElement(Filler, {
    prefixCls,
    height: scrollHeight,
    offsetX: offsetLeft,
    offsetY: fillerOffset,
    scrollWidth,
    onInnerResize: collectHeight,
    ref: fillerInnerRef,
    innerProps,
    rtl: isRTL,
    extra: extraContent
  }, listChildren))), inVirtual && scrollHeight > height && /* @__PURE__ */ reactExports.createElement(ScrollBar$3, {
    ref: verticalScrollBarRef,
    prefixCls,
    scrollOffset: offsetTop,
    scrollRange: scrollHeight,
    rtl: isRTL,
    onScroll: onScrollBar,
    onStartMove: onScrollbarStartMove,
    onStopMove: onScrollbarStopMove,
    spinSize: verticalScrollBarSpinSize,
    containerSize: size.height,
    style: styles === null || styles === void 0 ? void 0 : styles.verticalScrollBar,
    thumbStyle: styles === null || styles === void 0 ? void 0 : styles.verticalScrollBarThumb
  }), inVirtual && scrollWidth && /* @__PURE__ */ reactExports.createElement(ScrollBar$3, {
    ref: horizontalScrollBarRef,
    prefixCls,
    scrollOffset: offsetLeft,
    scrollRange: scrollWidth,
    rtl: isRTL,
    onScroll: onScrollBar,
    onStartMove: onScrollbarStartMove,
    onStopMove: onScrollbarStopMove,
    spinSize: horizontalScrollBarSpinSize,
    containerSize: size.width,
    horizontal: true,
    style: styles === null || styles === void 0 ? void 0 : styles.horizontalScrollBar,
    thumbStyle: styles === null || styles === void 0 ? void 0 : styles.horizontalScrollBarThumb
  }));
}
var List$1 = /* @__PURE__ */ reactExports.forwardRef(RawList);
List$1.displayName = "List";
var Context = /* @__PURE__ */ reactExports.createContext({});
var DomWrapper = /* @__PURE__ */ function(_React$Component) {
  _inherits$5(DomWrapper2, _React$Component);
  var _super = _createSuper$4(DomWrapper2);
  function DomWrapper2() {
    _classCallCheck$5(this, DomWrapper2);
    return _super.apply(this, arguments);
  }
  _createClass$5(DomWrapper2, [{
    key: "render",
    value: function render() {
      return this.props.children;
    }
  }]);
  return DomWrapper2;
}(reactExports.Component);
var STATUS_NONE = "none";
var STATUS_APPEAR = "appear";
var STATUS_ENTER = "enter";
var STATUS_LEAVE = "leave";
var STEP_NONE = "none";
var STEP_PREPARE = "prepare";
var STEP_START = "start";
var STEP_ACTIVE = "active";
var STEP_ACTIVATED = "end";
var STEP_PREPARED = "prepared";
function makePrefixMap(styleProp, eventName) {
  var prefixes = {};
  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
  prefixes["Webkit".concat(styleProp)] = "webkit".concat(eventName);
  prefixes["Moz".concat(styleProp)] = "moz".concat(eventName);
  prefixes["ms".concat(styleProp)] = "MS".concat(eventName);
  prefixes["O".concat(styleProp)] = "o".concat(eventName.toLowerCase());
  return prefixes;
}
function getVendorPrefixes(domSupport, win) {
  var prefixes = {
    animationend: makePrefixMap("Animation", "AnimationEnd"),
    transitionend: makePrefixMap("Transition", "TransitionEnd")
  };
  if (domSupport) {
    if (!("AnimationEvent" in win)) {
      delete prefixes.animationend.animation;
    }
    if (!("TransitionEvent" in win)) {
      delete prefixes.transitionend.transition;
    }
  }
  return prefixes;
}
var vendorPrefixes = getVendorPrefixes(canUseDom(), typeof window !== "undefined" ? window : {});
var style = {};
if (canUseDom()) {
  var _document$createEleme = document.createElement("div");
  style = _document$createEleme.style;
}
var prefixedEventNames = {};
function getVendorPrefixedEventName(eventName) {
  if (prefixedEventNames[eventName]) {
    return prefixedEventNames[eventName];
  }
  var prefixMap = vendorPrefixes[eventName];
  if (prefixMap) {
    var stylePropList = Object.keys(prefixMap);
    var len = stylePropList.length;
    for (var i16 = 0; i16 < len; i16 += 1) {
      var styleProp = stylePropList[i16];
      if (Object.prototype.hasOwnProperty.call(prefixMap, styleProp) && styleProp in style) {
        prefixedEventNames[eventName] = prefixMap[styleProp];
        return prefixedEventNames[eventName];
      }
    }
  }
  return "";
}
var internalAnimationEndName = getVendorPrefixedEventName("animationend");
var internalTransitionEndName = getVendorPrefixedEventName("transitionend");
var supportTransition = !!(internalAnimationEndName && internalTransitionEndName);
var animationEndName = internalAnimationEndName || "animationend";
var transitionEndName = internalTransitionEndName || "transitionend";
function getTransitionName(transitionName, transitionType) {
  if (!transitionName)
    return null;
  if (_typeof$6(transitionName) === "object") {
    var type = transitionType.replace(/-\w/g, function(match2) {
      return match2[1].toUpperCase();
    });
    return transitionName[type];
  }
  return "".concat(transitionName, "-").concat(transitionType);
}
const useDomMotionEvents = function(callback) {
  var cacheElementRef = reactExports.useRef();
  var callbackRef = reactExports.useRef(callback);
  callbackRef.current = callback;
  var onInternalMotionEnd = reactExports.useCallback(function(event) {
    callbackRef.current(event);
  }, []);
  function removeMotionEvents(element) {
    if (element) {
      element.removeEventListener(transitionEndName, onInternalMotionEnd);
      element.removeEventListener(animationEndName, onInternalMotionEnd);
    }
  }
  function patchMotionEvents(element) {
    if (cacheElementRef.current && cacheElementRef.current !== element) {
      removeMotionEvents(cacheElementRef.current);
    }
    if (element && element !== cacheElementRef.current) {
      element.addEventListener(transitionEndName, onInternalMotionEnd);
      element.addEventListener(animationEndName, onInternalMotionEnd);
      cacheElementRef.current = element;
    }
  }
  reactExports.useEffect(function() {
    return function() {
      removeMotionEvents(cacheElementRef.current);
    };
  }, []);
  return [patchMotionEvents, removeMotionEvents];
};
var useIsomorphicLayoutEffect = canUseDom() ? reactExports.useLayoutEffect : reactExports.useEffect;
const useNextFrame = function() {
  var nextFrameRef = reactExports.useRef(null);
  function cancelNextFrame() {
    wrapperRaf.cancel(nextFrameRef.current);
  }
  function nextFrame(callback) {
    var delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
    cancelNextFrame();
    var nextFrameId = wrapperRaf(function() {
      if (delay <= 1) {
        callback({
          isCanceled: function isCanceled() {
            return nextFrameId !== nextFrameRef.current;
          }
        });
      } else {
        nextFrame(callback, delay - 1);
      }
    });
    nextFrameRef.current = nextFrameId;
  }
  reactExports.useEffect(function() {
    return function() {
      cancelNextFrame();
    };
  }, []);
  return [nextFrame, cancelNextFrame];
};
var FULL_STEP_QUEUE = [STEP_PREPARE, STEP_START, STEP_ACTIVE, STEP_ACTIVATED];
var SIMPLE_STEP_QUEUE = [STEP_PREPARE, STEP_PREPARED];
var SkipStep = false;
var DoStep = true;
function isActive(step) {
  return step === STEP_ACTIVE || step === STEP_ACTIVATED;
}
const useStepQueue = function(status, prepareOnly, callback) {
  var _useState = useSafeState(STEP_NONE), _useState2 = _slicedToArray(_useState, 2), step = _useState2[0], setStep = _useState2[1];
  var _useNextFrame = useNextFrame(), _useNextFrame2 = _slicedToArray(_useNextFrame, 2), nextFrame = _useNextFrame2[0], cancelNextFrame = _useNextFrame2[1];
  function startQueue() {
    setStep(STEP_PREPARE, true);
  }
  var STEP_QUEUE = prepareOnly ? SIMPLE_STEP_QUEUE : FULL_STEP_QUEUE;
  useIsomorphicLayoutEffect(function() {
    if (step !== STEP_NONE && step !== STEP_ACTIVATED) {
      var index2 = STEP_QUEUE.indexOf(step);
      var nextStep = STEP_QUEUE[index2 + 1];
      var result = callback(step);
      if (result === SkipStep) {
        setStep(nextStep, true);
      } else if (nextStep) {
        nextFrame(function(info) {
          function doNext() {
            if (info.isCanceled())
              return;
            setStep(nextStep, true);
          }
          if (result === true) {
            doNext();
          } else {
            Promise.resolve(result).then(doNext);
          }
        });
      }
    }
  }, [status, step]);
  reactExports.useEffect(function() {
    return function() {
      cancelNextFrame();
    };
  }, []);
  return [startQueue, step];
};
function useStatus(supportMotion, visible, getElement, _ref) {
  var _ref$motionEnter = _ref.motionEnter, motionEnter = _ref$motionEnter === void 0 ? true : _ref$motionEnter, _ref$motionAppear = _ref.motionAppear, motionAppear = _ref$motionAppear === void 0 ? true : _ref$motionAppear, _ref$motionLeave = _ref.motionLeave, motionLeave = _ref$motionLeave === void 0 ? true : _ref$motionLeave, motionDeadline = _ref.motionDeadline, motionLeaveImmediately = _ref.motionLeaveImmediately, onAppearPrepare = _ref.onAppearPrepare, onEnterPrepare = _ref.onEnterPrepare, onLeavePrepare = _ref.onLeavePrepare, onAppearStart = _ref.onAppearStart, onEnterStart = _ref.onEnterStart, onLeaveStart = _ref.onLeaveStart, onAppearActive = _ref.onAppearActive, onEnterActive = _ref.onEnterActive, onLeaveActive = _ref.onLeaveActive, onAppearEnd = _ref.onAppearEnd, onEnterEnd = _ref.onEnterEnd, onLeaveEnd = _ref.onLeaveEnd, onVisibleChanged = _ref.onVisibleChanged;
  var _useState = useSafeState(), _useState2 = _slicedToArray(_useState, 2), asyncVisible = _useState2[0], setAsyncVisible = _useState2[1];
  var _useState3 = useSafeState(STATUS_NONE), _useState4 = _slicedToArray(_useState3, 2), status = _useState4[0], setStatus = _useState4[1];
  var _useState5 = useSafeState(null), _useState6 = _slicedToArray(_useState5, 2), style2 = _useState6[0], setStyle2 = _useState6[1];
  var mountedRef = reactExports.useRef(false);
  var deadlineRef = reactExports.useRef(null);
  function getDomElement() {
    return getElement();
  }
  var activeRef = reactExports.useRef(false);
  function updateMotionEndStatus() {
    setStatus(STATUS_NONE, true);
    setStyle2(null, true);
  }
  function onInternalMotionEnd(event) {
    var element = getDomElement();
    if (event && !event.deadline && event.target !== element) {
      return;
    }
    var currentActive = activeRef.current;
    var canEnd;
    if (status === STATUS_APPEAR && currentActive) {
      canEnd = onAppearEnd === null || onAppearEnd === void 0 ? void 0 : onAppearEnd(element, event);
    } else if (status === STATUS_ENTER && currentActive) {
      canEnd = onEnterEnd === null || onEnterEnd === void 0 ? void 0 : onEnterEnd(element, event);
    } else if (status === STATUS_LEAVE && currentActive) {
      canEnd = onLeaveEnd === null || onLeaveEnd === void 0 ? void 0 : onLeaveEnd(element, event);
    }
    if (status !== STATUS_NONE && currentActive && canEnd !== false) {
      updateMotionEndStatus();
    }
  }
  var _useDomMotionEvents = useDomMotionEvents(onInternalMotionEnd), _useDomMotionEvents2 = _slicedToArray(_useDomMotionEvents, 1), patchMotionEvents = _useDomMotionEvents2[0];
  var getEventHandlers = function getEventHandlers2(targetStatus) {
    var _ref2, _ref3, _ref4;
    switch (targetStatus) {
      case STATUS_APPEAR:
        return _ref2 = {}, _defineProperty$2(_ref2, STEP_PREPARE, onAppearPrepare), _defineProperty$2(_ref2, STEP_START, onAppearStart), _defineProperty$2(_ref2, STEP_ACTIVE, onAppearActive), _ref2;
      case STATUS_ENTER:
        return _ref3 = {}, _defineProperty$2(_ref3, STEP_PREPARE, onEnterPrepare), _defineProperty$2(_ref3, STEP_START, onEnterStart), _defineProperty$2(_ref3, STEP_ACTIVE, onEnterActive), _ref3;
      case STATUS_LEAVE:
        return _ref4 = {}, _defineProperty$2(_ref4, STEP_PREPARE, onLeavePrepare), _defineProperty$2(_ref4, STEP_START, onLeaveStart), _defineProperty$2(_ref4, STEP_ACTIVE, onLeaveActive), _ref4;
      default:
        return {};
    }
  };
  var eventHandlers = reactExports.useMemo(function() {
    return getEventHandlers(status);
  }, [status]);
  var _useStepQueue = useStepQueue(status, !supportMotion, function(newStep) {
    if (newStep === STEP_PREPARE) {
      var onPrepare = eventHandlers[STEP_PREPARE];
      if (!onPrepare) {
        return SkipStep;
      }
      return onPrepare(getDomElement());
    }
    if (step in eventHandlers) {
      var _eventHandlers$step;
      setStyle2(((_eventHandlers$step = eventHandlers[step]) === null || _eventHandlers$step === void 0 ? void 0 : _eventHandlers$step.call(eventHandlers, getDomElement(), null)) || null);
    }
    if (step === STEP_ACTIVE) {
      patchMotionEvents(getDomElement());
      if (motionDeadline > 0) {
        clearTimeout(deadlineRef.current);
        deadlineRef.current = setTimeout(function() {
          onInternalMotionEnd({
            deadline: true
          });
        }, motionDeadline);
      }
    }
    if (step === STEP_PREPARED) {
      updateMotionEndStatus();
    }
    return DoStep;
  }), _useStepQueue2 = _slicedToArray(_useStepQueue, 2), startStep = _useStepQueue2[0], step = _useStepQueue2[1];
  var active = isActive(step);
  activeRef.current = active;
  useIsomorphicLayoutEffect(function() {
    setAsyncVisible(visible);
    var isMounted = mountedRef.current;
    mountedRef.current = true;
    var nextStatus;
    if (!isMounted && visible && motionAppear) {
      nextStatus = STATUS_APPEAR;
    }
    if (isMounted && visible && motionEnter) {
      nextStatus = STATUS_ENTER;
    }
    if (isMounted && !visible && motionLeave || !isMounted && motionLeaveImmediately && !visible && motionLeave) {
      nextStatus = STATUS_LEAVE;
    }
    var nextEventHandlers = getEventHandlers(nextStatus);
    if (nextStatus && (supportMotion || nextEventHandlers[STEP_PREPARE])) {
      setStatus(nextStatus);
      startStep();
    } else {
      setStatus(STATUS_NONE);
    }
  }, [visible]);
  reactExports.useEffect(function() {
    if (
      // Cancel appear
      status === STATUS_APPEAR && !motionAppear || // Cancel enter
      status === STATUS_ENTER && !motionEnter || // Cancel leave
      status === STATUS_LEAVE && !motionLeave
    ) {
      setStatus(STATUS_NONE);
    }
  }, [motionAppear, motionEnter, motionLeave]);
  reactExports.useEffect(function() {
    return function() {
      mountedRef.current = false;
      clearTimeout(deadlineRef.current);
    };
  }, []);
  var firstMountChangeRef = reactExports.useRef(false);
  reactExports.useEffect(function() {
    if (asyncVisible) {
      firstMountChangeRef.current = true;
    }
    if (asyncVisible !== void 0 && status === STATUS_NONE) {
      if (firstMountChangeRef.current || asyncVisible) {
        onVisibleChanged === null || onVisibleChanged === void 0 ? void 0 : onVisibleChanged(asyncVisible);
      }
      firstMountChangeRef.current = true;
    }
  }, [asyncVisible, status]);
  var mergedStyle = style2;
  if (eventHandlers[STEP_PREPARE] && step === STEP_START) {
    mergedStyle = _objectSpread2({
      transition: "none"
    }, mergedStyle);
  }
  return [status, step, mergedStyle, asyncVisible !== null && asyncVisible !== void 0 ? asyncVisible : visible];
}
function genCSSMotion(config2) {
  var transitionSupport = config2;
  if (_typeof$6(config2) === "object") {
    transitionSupport = config2.transitionSupport;
  }
  function isSupportTransition(props, contextMotion) {
    return !!(props.motionName && transitionSupport && contextMotion !== false);
  }
  var CSSMotion2 = /* @__PURE__ */ reactExports.forwardRef(function(props, ref2) {
    var _props$visible = props.visible, visible = _props$visible === void 0 ? true : _props$visible, _props$removeOnLeave = props.removeOnLeave, removeOnLeave = _props$removeOnLeave === void 0 ? true : _props$removeOnLeave, forceRender = props.forceRender, children = props.children, motionName = props.motionName, leavedClassName = props.leavedClassName, eventProps = props.eventProps;
    var _React$useContext = reactExports.useContext(Context), contextMotion = _React$useContext.motion;
    var supportMotion = isSupportTransition(props, contextMotion);
    var nodeRef = reactExports.useRef();
    var wrapperNodeRef = reactExports.useRef();
    function getDomElement() {
      try {
        return nodeRef.current instanceof HTMLElement ? nodeRef.current : findDOMNode(wrapperNodeRef.current);
      } catch (e3) {
        return null;
      }
    }
    var _useStatus = useStatus(supportMotion, visible, getDomElement, props), _useStatus2 = _slicedToArray(_useStatus, 4), status = _useStatus2[0], statusStep = _useStatus2[1], statusStyle = _useStatus2[2], mergedVisible = _useStatus2[3];
    var renderedRef = reactExports.useRef(mergedVisible);
    if (mergedVisible) {
      renderedRef.current = true;
    }
    var setNodeRef = reactExports.useCallback(function(node) {
      nodeRef.current = node;
      fillRef(ref2, node);
    }, [ref2]);
    var motionChildren;
    var mergedProps = _objectSpread2(_objectSpread2({}, eventProps), {}, {
      visible
    });
    if (!children) {
      motionChildren = null;
    } else if (status === STATUS_NONE) {
      if (mergedVisible) {
        motionChildren = children(_objectSpread2({}, mergedProps), setNodeRef);
      } else if (!removeOnLeave && renderedRef.current && leavedClassName) {
        motionChildren = children(_objectSpread2(_objectSpread2({}, mergedProps), {}, {
          className: leavedClassName
        }), setNodeRef);
      } else if (forceRender || !removeOnLeave && !leavedClassName) {
        motionChildren = children(_objectSpread2(_objectSpread2({}, mergedProps), {}, {
          style: {
            display: "none"
          }
        }), setNodeRef);
      } else {
        motionChildren = null;
      }
    } else {
      var _classNames;
      var statusSuffix;
      if (statusStep === STEP_PREPARE) {
        statusSuffix = "prepare";
      } else if (isActive(statusStep)) {
        statusSuffix = "active";
      } else if (statusStep === STEP_START) {
        statusSuffix = "start";
      }
      var motionCls = getTransitionName(motionName, "".concat(status, "-").concat(statusSuffix));
      motionChildren = children(_objectSpread2(_objectSpread2({}, mergedProps), {}, {
        className: classNames(getTransitionName(motionName, status), (_classNames = {}, _defineProperty$2(_classNames, motionCls, motionCls && statusSuffix), _defineProperty$2(_classNames, motionName, typeof motionName === "string"), _classNames)),
        style: statusStyle
      }), setNodeRef);
    }
    if (/* @__PURE__ */ reactExports.isValidElement(motionChildren) && supportRef(motionChildren)) {
      var _ref = motionChildren, originNodeRef = _ref.ref;
      if (!originNodeRef) {
        motionChildren = /* @__PURE__ */ reactExports.cloneElement(motionChildren, {
          ref: setNodeRef
        });
      }
    }
    return /* @__PURE__ */ reactExports.createElement(DomWrapper, {
      ref: wrapperNodeRef
    }, motionChildren);
  });
  CSSMotion2.displayName = "CSSMotion";
  return CSSMotion2;
}
const CSSMotion = genCSSMotion(supportTransition);
var STATUS_ADD = "add";
var STATUS_KEEP = "keep";
var STATUS_REMOVE = "remove";
var STATUS_REMOVED = "removed";
function wrapKeyToObject(key) {
  var keyObj;
  if (key && _typeof$6(key) === "object" && "key" in key) {
    keyObj = key;
  } else {
    keyObj = {
      key
    };
  }
  return _objectSpread2(_objectSpread2({}, keyObj), {}, {
    key: String(keyObj.key)
  });
}
function parseKeys() {
  var keys2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  return keys2.map(wrapKeyToObject);
}
function diffKeys() {
  var prevKeys = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  var currentKeys = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var list = [];
  var currentIndex = 0;
  var currentLen = currentKeys.length;
  var prevKeyObjects = parseKeys(prevKeys);
  var currentKeyObjects = parseKeys(currentKeys);
  prevKeyObjects.forEach(function(keyObj) {
    var hit = false;
    for (var i16 = currentIndex; i16 < currentLen; i16 += 1) {
      var currentKeyObj = currentKeyObjects[i16];
      if (currentKeyObj.key === keyObj.key) {
        if (currentIndex < i16) {
          list = list.concat(currentKeyObjects.slice(currentIndex, i16).map(function(obj) {
            return _objectSpread2(_objectSpread2({}, obj), {}, {
              status: STATUS_ADD
            });
          }));
          currentIndex = i16;
        }
        list.push(_objectSpread2(_objectSpread2({}, currentKeyObj), {}, {
          status: STATUS_KEEP
        }));
        currentIndex += 1;
        hit = true;
        break;
      }
    }
    if (!hit) {
      list.push(_objectSpread2(_objectSpread2({}, keyObj), {}, {
        status: STATUS_REMOVE
      }));
    }
  });
  if (currentIndex < currentLen) {
    list = list.concat(currentKeyObjects.slice(currentIndex).map(function(obj) {
      return _objectSpread2(_objectSpread2({}, obj), {}, {
        status: STATUS_ADD
      });
    }));
  }
  var keys2 = {};
  list.forEach(function(_ref) {
    var key = _ref.key;
    keys2[key] = (keys2[key] || 0) + 1;
  });
  var duplicatedKeys = Object.keys(keys2).filter(function(key) {
    return keys2[key] > 1;
  });
  duplicatedKeys.forEach(function(matchKey) {
    list = list.filter(function(_ref2) {
      var key = _ref2.key, status = _ref2.status;
      return key !== matchKey || status !== STATUS_REMOVE;
    });
    list.forEach(function(node) {
      if (node.key === matchKey) {
        node.status = STATUS_KEEP;
      }
    });
  });
  return list;
}
var _excluded$6 = ["component", "children", "onVisibleChanged", "onAllRemoved"], _excluded2 = ["status"];
var MOTION_PROP_NAMES = ["eventProps", "visible", "children", "motionName", "motionAppear", "motionEnter", "motionLeave", "motionLeaveImmediately", "motionDeadline", "removeOnLeave", "leavedClassName", "onAppearPrepare", "onAppearStart", "onAppearActive", "onAppearEnd", "onEnterStart", "onEnterActive", "onEnterEnd", "onLeaveStart", "onLeaveActive", "onLeaveEnd"];
function genCSSMotionList(transitionSupport) {
  var CSSMotion$1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : CSSMotion;
  var CSSMotionList = /* @__PURE__ */ function(_React$Component) {
    _inherits$5(CSSMotionList2, _React$Component);
    var _super = _createSuper$4(CSSMotionList2);
    function CSSMotionList2() {
      var _this;
      _classCallCheck$5(this, CSSMotionList2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty$2(_assertThisInitialized$4(_this), "state", {
        keyEntities: []
      });
      _defineProperty$2(_assertThisInitialized$4(_this), "removeKey", function(removeKey) {
        var keyEntities = _this.state.keyEntities;
        var nextKeyEntities = keyEntities.map(function(entity) {
          if (entity.key !== removeKey)
            return entity;
          return _objectSpread2(_objectSpread2({}, entity), {}, {
            status: STATUS_REMOVED
          });
        });
        _this.setState({
          keyEntities: nextKeyEntities
        });
        return nextKeyEntities.filter(function(_ref) {
          var status = _ref.status;
          return status !== STATUS_REMOVED;
        }).length;
      });
      return _this;
    }
    _createClass$5(CSSMotionList2, [{
      key: "render",
      value: function render() {
        var _this2 = this;
        var keyEntities = this.state.keyEntities;
        var _this$props = this.props, component = _this$props.component, children = _this$props.children, _onVisibleChanged = _this$props.onVisibleChanged, onAllRemoved = _this$props.onAllRemoved, restProps = _objectWithoutProperties$3(_this$props, _excluded$6);
        var Component2 = component || reactExports.Fragment;
        var motionProps = {};
        MOTION_PROP_NAMES.forEach(function(prop) {
          motionProps[prop] = restProps[prop];
          delete restProps[prop];
        });
        delete restProps.keys;
        return /* @__PURE__ */ reactExports.createElement(Component2, restProps, keyEntities.map(function(_ref2, index2) {
          var status = _ref2.status, eventProps = _objectWithoutProperties$3(_ref2, _excluded2);
          var visible = status === STATUS_ADD || status === STATUS_KEEP;
          return /* @__PURE__ */ reactExports.createElement(CSSMotion$1, _extends$4({}, motionProps, {
            key: eventProps.key,
            visible,
            eventProps,
            onVisibleChanged: function onVisibleChanged(changedVisible) {
              _onVisibleChanged === null || _onVisibleChanged === void 0 ? void 0 : _onVisibleChanged(changedVisible, {
                key: eventProps.key
              });
              if (!changedVisible) {
                var restKeysCount = _this2.removeKey(eventProps.key);
                if (restKeysCount === 0 && onAllRemoved) {
                  onAllRemoved();
                }
              }
            }
          }), function(props, ref2) {
            return children(_objectSpread2(_objectSpread2({}, props), {}, {
              index: index2
            }), ref2);
          });
        }));
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref3, _ref4) {
        var keys2 = _ref3.keys;
        var keyEntities = _ref4.keyEntities;
        var parsedKeyObjects = parseKeys(keys2);
        var mixedKeyEntities = diffKeys(keyEntities, parsedKeyObjects);
        return {
          keyEntities: mixedKeyEntities.filter(function(entity) {
            var prevEntity = keyEntities.find(function(_ref5) {
              var key = _ref5.key;
              return entity.key === key;
            });
            if (prevEntity && prevEntity.status === STATUS_REMOVED && entity.status === STATUS_REMOVE) {
              return false;
            }
            return true;
          })
        };
      }
    }]);
    return CSSMotionList2;
  }(reactExports.Component);
  _defineProperty$2(CSSMotionList, "defaultProps", {
    component: "div"
  });
  return CSSMotionList;
}
genCSSMotionList(supportTransition);
var Indent = function Indent2(_ref) {
  var prefixCls = _ref.prefixCls, level = _ref.level, isStart = _ref.isStart, isEnd = _ref.isEnd;
  var baseClassName = "".concat(prefixCls, "-indent-unit");
  var list = [];
  for (var i16 = 0; i16 < level; i16 += 1) {
    list.push(/* @__PURE__ */ reactExports.createElement("span", {
      key: i16,
      className: classNames(baseClassName, _defineProperty$2(_defineProperty$2({}, "".concat(baseClassName, "-start"), isStart[i16]), "".concat(baseClassName, "-end"), isEnd[i16]))
    }));
  }
  return /* @__PURE__ */ reactExports.createElement("span", {
    "aria-hidden": "true",
    className: "".concat(prefixCls, "-indent")
  }, list);
};
const Indent$1 = /* @__PURE__ */ reactExports.memo(Indent);
function getEntity(keyEntities, key) {
  return keyEntities[key];
}
function omit(obj, fields) {
  var clone3 = _objectSpread2({}, obj);
  if (Array.isArray(fields)) {
    fields.forEach(function(key) {
      delete clone3[key];
    });
  }
  return clone3;
}
var _excluded$5 = ["children"];
function getPosition(level, index2) {
  return "".concat(level, "-").concat(index2);
}
function isTreeNode(node) {
  return node && node.type && node.type.isTreeNode;
}
function getKey(key, pos) {
  if (key !== null && key !== void 0) {
    return key;
  }
  return pos;
}
function fillFieldNames(fieldNames) {
  var _ref = fieldNames || {}, title2 = _ref.title, _title = _ref._title, key = _ref.key, children = _ref.children;
  var mergedTitle = title2 || "title";
  return {
    title: mergedTitle,
    _title: _title || [mergedTitle],
    key: key || "key",
    children: children || "children"
  };
}
function convertTreeToData(rootNodes) {
  function dig(node) {
    var treeNodes = toArray(node);
    return treeNodes.map(function(treeNode) {
      if (!isTreeNode(treeNode)) {
        warningOnce(!treeNode, "Tree/TreeNode can only accept TreeNode as children.");
        return null;
      }
      var key = treeNode.key;
      var _treeNode$props = treeNode.props, children = _treeNode$props.children, rest = _objectWithoutProperties$3(_treeNode$props, _excluded$5);
      var dataNode = _objectSpread2({
        key
      }, rest);
      var parsedChildren = dig(children);
      if (parsedChildren.length) {
        dataNode.children = parsedChildren;
      }
      return dataNode;
    }).filter(function(dataNode) {
      return dataNode;
    });
  }
  return dig(rootNodes);
}
function flattenTreeData(treeNodeList, expandedKeys, fieldNames) {
  var _fillFieldNames = fillFieldNames(fieldNames), fieldTitles = _fillFieldNames._title, fieldKey = _fillFieldNames.key, fieldChildren = _fillFieldNames.children;
  var expandedKeySet = new Set(expandedKeys === true ? [] : expandedKeys);
  var flattenList = [];
  function dig(list) {
    var parent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    return list.map(function(treeNode, index2) {
      var pos = getPosition(parent ? parent.pos : "0", index2);
      var mergedKey = getKey(treeNode[fieldKey], pos);
      var mergedTitle;
      for (var i16 = 0; i16 < fieldTitles.length; i16 += 1) {
        var fieldTitle = fieldTitles[i16];
        if (treeNode[fieldTitle] !== void 0) {
          mergedTitle = treeNode[fieldTitle];
          break;
        }
      }
      var flattenNode = Object.assign(omit(treeNode, [].concat(_toConsumableArray(fieldTitles), [fieldKey, fieldChildren])), {
        title: mergedTitle,
        key: mergedKey,
        parent,
        pos,
        children: null,
        data: treeNode,
        isStart: [].concat(_toConsumableArray(parent ? parent.isStart : []), [index2 === 0]),
        isEnd: [].concat(_toConsumableArray(parent ? parent.isEnd : []), [index2 === list.length - 1])
      });
      flattenList.push(flattenNode);
      if (expandedKeys === true || expandedKeySet.has(mergedKey)) {
        flattenNode.children = dig(treeNode[fieldChildren] || [], flattenNode);
      } else {
        flattenNode.children = [];
      }
      return flattenNode;
    });
  }
  dig(treeNodeList);
  return flattenList;
}
function traverseDataNodes(dataNodes, callback, config2) {
  var mergedConfig = {};
  if (_typeof$6(config2) === "object") {
    mergedConfig = config2;
  } else {
    mergedConfig = {
      externalGetKey: config2
    };
  }
  mergedConfig = mergedConfig || {};
  var _mergedConfig = mergedConfig, childrenPropName = _mergedConfig.childrenPropName, externalGetKey = _mergedConfig.externalGetKey, fieldNames = _mergedConfig.fieldNames;
  var _fillFieldNames2 = fillFieldNames(fieldNames), fieldKey = _fillFieldNames2.key, fieldChildren = _fillFieldNames2.children;
  var mergeChildrenPropName = childrenPropName || fieldChildren;
  var syntheticGetKey;
  if (externalGetKey) {
    if (typeof externalGetKey === "string") {
      syntheticGetKey = function syntheticGetKey2(node) {
        return node[externalGetKey];
      };
    } else if (typeof externalGetKey === "function") {
      syntheticGetKey = function syntheticGetKey2(node) {
        return externalGetKey(node);
      };
    }
  } else {
    syntheticGetKey = function syntheticGetKey2(node, pos) {
      return getKey(node[fieldKey], pos);
    };
  }
  function processNode(node, index2, parent, pathNodes) {
    var children = node ? node[mergeChildrenPropName] : dataNodes;
    var pos = node ? getPosition(parent.pos, index2) : "0";
    var connectNodes = node ? [].concat(_toConsumableArray(pathNodes), [node]) : [];
    if (node) {
      var key = syntheticGetKey(node, pos);
      var _data = {
        node,
        index: index2,
        pos,
        key,
        parentPos: parent.node ? parent.pos : null,
        level: parent.level + 1,
        nodes: connectNodes
      };
      callback(_data);
    }
    if (children) {
      children.forEach(function(subNode, subIndex) {
        processNode(subNode, subIndex, {
          node,
          pos,
          level: parent ? parent.level + 1 : -1
        }, connectNodes);
      });
    }
  }
  processNode(null);
}
function convertDataToEntities(dataNodes) {
  var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, initWrapper = _ref2.initWrapper, processEntity = _ref2.processEntity, onProcessFinished = _ref2.onProcessFinished, externalGetKey = _ref2.externalGetKey, childrenPropName = _ref2.childrenPropName, fieldNames = _ref2.fieldNames;
  var legacyExternalGetKey = arguments.length > 2 ? arguments[2] : void 0;
  var mergedExternalGetKey = externalGetKey || legacyExternalGetKey;
  var posEntities = {};
  var keyEntities = {};
  var wrapper2 = {
    posEntities,
    keyEntities
  };
  if (initWrapper) {
    wrapper2 = initWrapper(wrapper2) || wrapper2;
  }
  traverseDataNodes(dataNodes, function(item) {
    var node = item.node, index2 = item.index, pos = item.pos, key = item.key, parentPos = item.parentPos, level = item.level, nodes = item.nodes;
    var entity = {
      node,
      nodes,
      index: index2,
      key,
      pos,
      level
    };
    var mergedKey = getKey(key, pos);
    posEntities[pos] = entity;
    keyEntities[mergedKey] = entity;
    entity.parent = posEntities[parentPos];
    if (entity.parent) {
      entity.parent.children = entity.parent.children || [];
      entity.parent.children.push(entity);
    }
    if (processEntity) {
      processEntity(entity, wrapper2);
    }
  }, {
    externalGetKey: mergedExternalGetKey,
    childrenPropName,
    fieldNames
  });
  if (onProcessFinished) {
    onProcessFinished(wrapper2);
  }
  return wrapper2;
}
function getTreeNodeProps(key, _ref3) {
  var expandedKeys = _ref3.expandedKeys, selectedKeys = _ref3.selectedKeys, loadedKeys = _ref3.loadedKeys, loadingKeys = _ref3.loadingKeys, checkedKeys = _ref3.checkedKeys, halfCheckedKeys = _ref3.halfCheckedKeys, dragOverNodeKey = _ref3.dragOverNodeKey, dropPosition = _ref3.dropPosition, keyEntities = _ref3.keyEntities;
  var entity = getEntity(keyEntities, key);
  var treeNodeProps = {
    eventKey: key,
    expanded: expandedKeys.indexOf(key) !== -1,
    selected: selectedKeys.indexOf(key) !== -1,
    loaded: loadedKeys.indexOf(key) !== -1,
    loading: loadingKeys.indexOf(key) !== -1,
    checked: checkedKeys.indexOf(key) !== -1,
    halfChecked: halfCheckedKeys.indexOf(key) !== -1,
    pos: String(entity ? entity.pos : ""),
    // [Legacy] Drag props
    // Since the interaction of drag is changed, the semantic of the props are
    // not accuracy, I think it should be finally removed
    dragOver: dragOverNodeKey === key && dropPosition === 0,
    dragOverGapTop: dragOverNodeKey === key && dropPosition === -1,
    dragOverGapBottom: dragOverNodeKey === key && dropPosition === 1
  };
  return treeNodeProps;
}
function convertNodePropsToEventData(props) {
  var data2 = props.data, expanded = props.expanded, selected = props.selected, checked = props.checked, loaded = props.loaded, loading = props.loading, halfChecked = props.halfChecked, dragOver = props.dragOver, dragOverGapTop = props.dragOverGapTop, dragOverGapBottom = props.dragOverGapBottom, pos = props.pos, active = props.active, eventKey = props.eventKey;
  var eventData = _objectSpread2(_objectSpread2({}, data2), {}, {
    expanded,
    selected,
    checked,
    loaded,
    loading,
    halfChecked,
    dragOver,
    dragOverGapTop,
    dragOverGapBottom,
    pos,
    active,
    key: eventKey
  });
  if (!("props" in eventData)) {
    Object.defineProperty(eventData, "props", {
      get: function get3() {
        warningOnce(false, "Second param return from event is node data instead of TreeNode instance. Please read value directly instead of reading from `props`.");
        return props;
      }
    });
  }
  return eventData;
}
var _excluded$4 = ["eventKey", "className", "style", "dragOver", "dragOverGapTop", "dragOverGapBottom", "isLeaf", "isStart", "isEnd", "expanded", "selected", "checked", "halfChecked", "loading", "domRef", "active", "data", "onMouseMove", "selectable"];
var ICON_OPEN = "open";
var ICON_CLOSE = "close";
var defaultTitle = "---";
var InternalTreeNode = /* @__PURE__ */ function(_React$Component) {
  _inherits$5(InternalTreeNode2, _React$Component);
  var _super = _createSuper$4(InternalTreeNode2);
  function InternalTreeNode2() {
    var _this;
    _classCallCheck$5(this, InternalTreeNode2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$2(_assertThisInitialized$4(_this), "state", {
      dragNodeHighlight: false
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "selectHandle", void 0);
    _defineProperty$2(_assertThisInitialized$4(_this), "cacheIndent", void 0);
    _defineProperty$2(_assertThisInitialized$4(_this), "onSelectorClick", function(e3) {
      var onNodeClick = _this.props.context.onNodeClick;
      onNodeClick(e3, convertNodePropsToEventData(_this.props));
      if (_this.isSelectable()) {
        _this.onSelect(e3);
      } else {
        _this.onCheck(e3);
      }
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "onSelectorDoubleClick", function(e3) {
      var onNodeDoubleClick = _this.props.context.onNodeDoubleClick;
      onNodeDoubleClick(e3, convertNodePropsToEventData(_this.props));
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "onSelect", function(e3) {
      if (_this.isDisabled())
        return;
      var onNodeSelect = _this.props.context.onNodeSelect;
      onNodeSelect(e3, convertNodePropsToEventData(_this.props));
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "onCheck", function(e3) {
      if (_this.isDisabled())
        return;
      var _this$props = _this.props, disableCheckbox = _this$props.disableCheckbox, checked = _this$props.checked;
      var onNodeCheck = _this.props.context.onNodeCheck;
      if (!_this.isCheckable() || disableCheckbox)
        return;
      var targetChecked = !checked;
      onNodeCheck(e3, convertNodePropsToEventData(_this.props), targetChecked);
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "onMouseEnter", function(e3) {
      var onNodeMouseEnter = _this.props.context.onNodeMouseEnter;
      onNodeMouseEnter(e3, convertNodePropsToEventData(_this.props));
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "onMouseLeave", function(e3) {
      var onNodeMouseLeave = _this.props.context.onNodeMouseLeave;
      onNodeMouseLeave(e3, convertNodePropsToEventData(_this.props));
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "onContextMenu", function(e3) {
      var onNodeContextMenu = _this.props.context.onNodeContextMenu;
      onNodeContextMenu(e3, convertNodePropsToEventData(_this.props));
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "onDragStart", function(e3) {
      var onNodeDragStart = _this.props.context.onNodeDragStart;
      e3.stopPropagation();
      _this.setState({
        dragNodeHighlight: true
      });
      onNodeDragStart(e3, _assertThisInitialized$4(_this));
      try {
        e3.dataTransfer.setData("text/plain", "");
      } catch (error2) {
      }
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "onDragEnter", function(e3) {
      var onNodeDragEnter = _this.props.context.onNodeDragEnter;
      e3.preventDefault();
      e3.stopPropagation();
      onNodeDragEnter(e3, _assertThisInitialized$4(_this));
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "onDragOver", function(e3) {
      var onNodeDragOver = _this.props.context.onNodeDragOver;
      e3.preventDefault();
      e3.stopPropagation();
      onNodeDragOver(e3, _assertThisInitialized$4(_this));
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "onDragLeave", function(e3) {
      var onNodeDragLeave = _this.props.context.onNodeDragLeave;
      e3.stopPropagation();
      onNodeDragLeave(e3, _assertThisInitialized$4(_this));
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "onDragEnd", function(e3) {
      var onNodeDragEnd = _this.props.context.onNodeDragEnd;
      e3.stopPropagation();
      _this.setState({
        dragNodeHighlight: false
      });
      onNodeDragEnd(e3, _assertThisInitialized$4(_this));
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "onDrop", function(e3) {
      var onNodeDrop = _this.props.context.onNodeDrop;
      e3.preventDefault();
      e3.stopPropagation();
      _this.setState({
        dragNodeHighlight: false
      });
      onNodeDrop(e3, _assertThisInitialized$4(_this));
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "onExpand", function(e3) {
      var _this$props2 = _this.props, loading = _this$props2.loading, onNodeExpand = _this$props2.context.onNodeExpand;
      if (loading)
        return;
      onNodeExpand(e3, convertNodePropsToEventData(_this.props));
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "setSelectHandle", function(node) {
      _this.selectHandle = node;
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "getNodeState", function() {
      var expanded = _this.props.expanded;
      if (_this.isLeaf()) {
        return null;
      }
      return expanded ? ICON_OPEN : ICON_CLOSE;
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "hasChildren", function() {
      var eventKey = _this.props.eventKey;
      var keyEntities = _this.props.context.keyEntities;
      var _ref = getEntity(keyEntities, eventKey) || {}, children = _ref.children;
      return !!(children || []).length;
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "isLeaf", function() {
      var _this$props3 = _this.props, isLeaf = _this$props3.isLeaf, loaded = _this$props3.loaded;
      var loadData = _this.props.context.loadData;
      var hasChildren = _this.hasChildren();
      if (isLeaf === false) {
        return false;
      }
      return isLeaf || !loadData && !hasChildren || loadData && loaded && !hasChildren;
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "isDisabled", function() {
      var disabled = _this.props.disabled;
      var treeDisabled = _this.props.context.disabled;
      return !!(treeDisabled || disabled);
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "isCheckable", function() {
      var checkable = _this.props.checkable;
      var treeCheckable = _this.props.context.checkable;
      if (!treeCheckable || checkable === false)
        return false;
      return treeCheckable;
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "syncLoadData", function(props) {
      var expanded = props.expanded, loading = props.loading, loaded = props.loaded;
      var _this$props$context = _this.props.context, loadData = _this$props$context.loadData, onNodeLoad = _this$props$context.onNodeLoad;
      if (loading) {
        return;
      }
      if (loadData && expanded && !_this.isLeaf() && !loaded) {
        onNodeLoad(convertNodePropsToEventData(_this.props));
      }
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "isDraggable", function() {
      var _this$props4 = _this.props, data2 = _this$props4.data, draggable = _this$props4.context.draggable;
      return !!(draggable && (!draggable.nodeDraggable || draggable.nodeDraggable(data2)));
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "renderDragHandler", function() {
      var _this$props$context2 = _this.props.context, draggable = _this$props$context2.draggable, prefixCls = _this$props$context2.prefixCls;
      return draggable !== null && draggable !== void 0 && draggable.icon ? /* @__PURE__ */ reactExports.createElement("span", {
        className: "".concat(prefixCls, "-draggable-icon")
      }, draggable.icon) : null;
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "renderSwitcherIconDom", function(isLeaf) {
      var switcherIconFromProps = _this.props.switcherIcon;
      var switcherIconFromCtx = _this.props.context.switcherIcon;
      var switcherIcon = switcherIconFromProps || switcherIconFromCtx;
      if (typeof switcherIcon === "function") {
        return switcherIcon(_objectSpread2(_objectSpread2({}, _this.props), {}, {
          isLeaf
        }));
      }
      return switcherIcon;
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "renderSwitcher", function() {
      var expanded = _this.props.expanded;
      var prefixCls = _this.props.context.prefixCls;
      if (_this.isLeaf()) {
        var _switcherIconDom = _this.renderSwitcherIconDom(true);
        return _switcherIconDom !== false ? /* @__PURE__ */ reactExports.createElement("span", {
          className: classNames("".concat(prefixCls, "-switcher"), "".concat(prefixCls, "-switcher-noop"))
        }, _switcherIconDom) : null;
      }
      var switcherCls = classNames("".concat(prefixCls, "-switcher"), "".concat(prefixCls, "-switcher_").concat(expanded ? ICON_OPEN : ICON_CLOSE));
      var switcherIconDom = _this.renderSwitcherIconDom(false);
      return switcherIconDom !== false ? /* @__PURE__ */ reactExports.createElement("span", {
        onClick: _this.onExpand,
        className: switcherCls
      }, switcherIconDom) : null;
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "renderCheckbox", function() {
      var _this$props5 = _this.props, checked = _this$props5.checked, halfChecked = _this$props5.halfChecked, disableCheckbox = _this$props5.disableCheckbox;
      var prefixCls = _this.props.context.prefixCls;
      var disabled = _this.isDisabled();
      var checkable = _this.isCheckable();
      if (!checkable)
        return null;
      var $custom = typeof checkable !== "boolean" ? checkable : null;
      return /* @__PURE__ */ reactExports.createElement("span", {
        className: classNames("".concat(prefixCls, "-checkbox"), checked && "".concat(prefixCls, "-checkbox-checked"), !checked && halfChecked && "".concat(prefixCls, "-checkbox-indeterminate"), (disabled || disableCheckbox) && "".concat(prefixCls, "-checkbox-disabled")),
        onClick: _this.onCheck
      }, $custom);
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "renderIcon", function() {
      var loading = _this.props.loading;
      var prefixCls = _this.props.context.prefixCls;
      return /* @__PURE__ */ reactExports.createElement("span", {
        className: classNames("".concat(prefixCls, "-iconEle"), "".concat(prefixCls, "-icon__").concat(_this.getNodeState() || "docu"), loading && "".concat(prefixCls, "-icon_loading"))
      });
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "renderSelector", function() {
      var dragNodeHighlight = _this.state.dragNodeHighlight;
      var _this$props6 = _this.props, _this$props6$title = _this$props6.title, title2 = _this$props6$title === void 0 ? defaultTitle : _this$props6$title, selected = _this$props6.selected, icon = _this$props6.icon, loading = _this$props6.loading, data2 = _this$props6.data;
      var _this$props$context3 = _this.props.context, prefixCls = _this$props$context3.prefixCls, showIcon = _this$props$context3.showIcon, treeIcon = _this$props$context3.icon, loadData = _this$props$context3.loadData, titleRender = _this$props$context3.titleRender;
      var disabled = _this.isDisabled();
      var wrapClass = "".concat(prefixCls, "-node-content-wrapper");
      var $icon;
      if (showIcon) {
        var currentIcon = icon || treeIcon;
        $icon = currentIcon ? /* @__PURE__ */ reactExports.createElement("span", {
          className: classNames("".concat(prefixCls, "-iconEle"), "".concat(prefixCls, "-icon__customize"))
        }, typeof currentIcon === "function" ? currentIcon(_this.props) : currentIcon) : _this.renderIcon();
      } else if (loadData && loading) {
        $icon = _this.renderIcon();
      }
      var titleNode;
      if (typeof title2 === "function") {
        titleNode = title2(data2);
      } else if (titleRender) {
        titleNode = titleRender(data2);
      } else {
        titleNode = title2;
      }
      var $title = /* @__PURE__ */ reactExports.createElement("span", {
        className: "".concat(prefixCls, "-title")
      }, titleNode);
      return /* @__PURE__ */ reactExports.createElement("span", {
        ref: _this.setSelectHandle,
        title: typeof title2 === "string" ? title2 : "",
        className: classNames("".concat(wrapClass), "".concat(wrapClass, "-").concat(_this.getNodeState() || "normal"), !disabled && (selected || dragNodeHighlight) && "".concat(prefixCls, "-node-selected")),
        onMouseEnter: _this.onMouseEnter,
        onMouseLeave: _this.onMouseLeave,
        onContextMenu: _this.onContextMenu,
        onClick: _this.onSelectorClick,
        onDoubleClick: _this.onSelectorDoubleClick
      }, $icon, $title, _this.renderDropIndicator());
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "renderDropIndicator", function() {
      var _this$props7 = _this.props, disabled = _this$props7.disabled, eventKey = _this$props7.eventKey;
      var _this$props$context4 = _this.props.context, draggable = _this$props$context4.draggable, dropLevelOffset = _this$props$context4.dropLevelOffset, dropPosition = _this$props$context4.dropPosition, prefixCls = _this$props$context4.prefixCls, indent = _this$props$context4.indent, dropIndicatorRender = _this$props$context4.dropIndicatorRender, dragOverNodeKey = _this$props$context4.dragOverNodeKey, direction = _this$props$context4.direction;
      var rootDraggable = !!draggable;
      var showIndicator = !disabled && rootDraggable && dragOverNodeKey === eventKey;
      var mergedIndent = indent !== null && indent !== void 0 ? indent : _this.cacheIndent;
      _this.cacheIndent = indent;
      return showIndicator ? dropIndicatorRender({
        dropPosition,
        dropLevelOffset,
        indent: mergedIndent,
        prefixCls,
        direction
      }) : null;
    });
    return _this;
  }
  _createClass$5(InternalTreeNode2, [{
    key: "componentDidMount",
    value: (
      // Isomorphic needn't load data in server side
      function componentDidMount() {
        this.syncLoadData(this.props);
      }
    )
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.syncLoadData(this.props);
    }
  }, {
    key: "isSelectable",
    value: function isSelectable() {
      var selectable = this.props.selectable;
      var treeSelectable = this.props.context.selectable;
      if (typeof selectable === "boolean") {
        return selectable;
      }
      return treeSelectable;
    }
  }, {
    key: "render",
    value: (
      // =========================== Render ===========================
      function render() {
        var _classNames;
        var _this$props8 = this.props, eventKey = _this$props8.eventKey, className = _this$props8.className, style2 = _this$props8.style, dragOver = _this$props8.dragOver, dragOverGapTop = _this$props8.dragOverGapTop, dragOverGapBottom = _this$props8.dragOverGapBottom, isLeaf = _this$props8.isLeaf, isStart = _this$props8.isStart, isEnd = _this$props8.isEnd, expanded = _this$props8.expanded, selected = _this$props8.selected, checked = _this$props8.checked, halfChecked = _this$props8.halfChecked, loading = _this$props8.loading, domRef = _this$props8.domRef, active = _this$props8.active;
        _this$props8.data;
        var onMouseMove = _this$props8.onMouseMove, selectable = _this$props8.selectable, otherProps = _objectWithoutProperties$3(_this$props8, _excluded$4);
        var _this$props$context5 = this.props.context, prefixCls = _this$props$context5.prefixCls, filterTreeNode = _this$props$context5.filterTreeNode, keyEntities = _this$props$context5.keyEntities, dropContainerKey = _this$props$context5.dropContainerKey, dropTargetKey = _this$props$context5.dropTargetKey, draggingNodeKey = _this$props$context5.draggingNodeKey;
        var disabled = this.isDisabled();
        var dataOrAriaAttributeProps = pickAttrs(otherProps, {
          aria: true,
          data: true
        });
        var _ref2 = getEntity(keyEntities, eventKey) || {}, level = _ref2.level;
        var isEndNode = isEnd[isEnd.length - 1];
        var mergedDraggable = this.isDraggable();
        var draggableWithoutDisabled = !disabled && mergedDraggable;
        var dragging = draggingNodeKey === eventKey;
        var ariaSelected = selectable !== void 0 ? {
          "aria-selected": !!selectable
        } : void 0;
        return /* @__PURE__ */ reactExports.createElement("div", _extends$4({
          ref: domRef,
          className: classNames(className, "".concat(prefixCls, "-treenode"), (_classNames = {}, _defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_classNames, "".concat(prefixCls, "-treenode-disabled"), disabled), "".concat(prefixCls, "-treenode-switcher-").concat(expanded ? "open" : "close"), !isLeaf), "".concat(prefixCls, "-treenode-checkbox-checked"), checked), "".concat(prefixCls, "-treenode-checkbox-indeterminate"), halfChecked), "".concat(prefixCls, "-treenode-selected"), selected), "".concat(prefixCls, "-treenode-loading"), loading), "".concat(prefixCls, "-treenode-active"), active), "".concat(prefixCls, "-treenode-leaf-last"), isEndNode), "".concat(prefixCls, "-treenode-draggable"), mergedDraggable), "dragging", dragging), _defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_classNames, "drop-target", dropTargetKey === eventKey), "drop-container", dropContainerKey === eventKey), "drag-over", !disabled && dragOver), "drag-over-gap-top", !disabled && dragOverGapTop), "drag-over-gap-bottom", !disabled && dragOverGapBottom), "filter-node", filterTreeNode && filterTreeNode(convertNodePropsToEventData(this.props))))),
          style: style2,
          draggable: draggableWithoutDisabled,
          "aria-grabbed": dragging,
          onDragStart: draggableWithoutDisabled ? this.onDragStart : void 0,
          onDragEnter: mergedDraggable ? this.onDragEnter : void 0,
          onDragOver: mergedDraggable ? this.onDragOver : void 0,
          onDragLeave: mergedDraggable ? this.onDragLeave : void 0,
          onDrop: mergedDraggable ? this.onDrop : void 0,
          onDragEnd: mergedDraggable ? this.onDragEnd : void 0,
          onMouseMove
        }, ariaSelected, dataOrAriaAttributeProps), /* @__PURE__ */ reactExports.createElement(Indent$1, {
          prefixCls,
          level,
          isStart,
          isEnd
        }), this.renderDragHandler(), this.renderSwitcher(), this.renderCheckbox(), this.renderSelector());
      }
    )
  }]);
  return InternalTreeNode2;
}(reactExports.Component);
var ContextTreeNode = function ContextTreeNode2(props) {
  return /* @__PURE__ */ reactExports.createElement(TreeContext.Consumer, null, function(context2) {
    return /* @__PURE__ */ reactExports.createElement(InternalTreeNode, _extends$4({}, props, {
      context: context2
    }));
  });
};
ContextTreeNode.displayName = "TreeNode";
ContextTreeNode.isTreeNode = 1;
function useUnmount(triggerStart, triggerEnd) {
  var _React$useState = reactExports.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), firstMount = _React$useState2[0], setFirstMount = _React$useState2[1];
  useLayoutEffect(function() {
    if (firstMount) {
      triggerStart();
      return function() {
        triggerEnd();
      };
    }
  }, [firstMount]);
  useLayoutEffect(function() {
    setFirstMount(true);
    return function() {
      setFirstMount(false);
    };
  }, []);
}
var _excluded$3 = ["className", "style", "motion", "motionNodes", "motionType", "onMotionStart", "onMotionEnd", "active", "treeNodeRequiredProps"];
var MotionTreeNode = function MotionTreeNode2(_ref, ref2) {
  var className = _ref.className, style2 = _ref.style, motion = _ref.motion, motionNodes = _ref.motionNodes, motionType = _ref.motionType, onOriginMotionStart = _ref.onMotionStart, onOriginMotionEnd = _ref.onMotionEnd, active = _ref.active, treeNodeRequiredProps = _ref.treeNodeRequiredProps, props = _objectWithoutProperties$3(_ref, _excluded$3);
  var _React$useState = reactExports.useState(true), _React$useState2 = _slicedToArray(_React$useState, 2), visible = _React$useState2[0], setVisible = _React$useState2[1];
  var _React$useContext = reactExports.useContext(TreeContext), prefixCls = _React$useContext.prefixCls;
  var targetVisible = motionNodes && motionType !== "hide";
  useLayoutEffect(function() {
    if (motionNodes) {
      if (targetVisible !== visible) {
        setVisible(targetVisible);
      }
    }
  }, [motionNodes]);
  var triggerMotionStart = function triggerMotionStart2() {
    if (motionNodes) {
      onOriginMotionStart();
    }
  };
  var triggerMotionEndRef = reactExports.useRef(false);
  var triggerMotionEnd = function triggerMotionEnd2() {
    if (motionNodes && !triggerMotionEndRef.current) {
      triggerMotionEndRef.current = true;
      onOriginMotionEnd();
    }
  };
  useUnmount(triggerMotionStart, triggerMotionEnd);
  var onVisibleChanged = function onVisibleChanged2(nextVisible) {
    if (targetVisible === nextVisible) {
      triggerMotionEnd();
    }
  };
  if (motionNodes) {
    return /* @__PURE__ */ reactExports.createElement(CSSMotion, _extends$4({
      ref: ref2,
      visible
    }, motion, {
      motionAppear: motionType === "show",
      onVisibleChanged
    }), function(_ref2, motionRef) {
      var motionClassName = _ref2.className, motionStyle = _ref2.style;
      return /* @__PURE__ */ reactExports.createElement("div", {
        ref: motionRef,
        className: classNames("".concat(prefixCls, "-treenode-motion"), motionClassName),
        style: motionStyle
      }, motionNodes.map(function(treeNode) {
        var restProps = Object.assign({}, (_objectDestructuringEmpty(treeNode.data), treeNode.data)), title2 = treeNode.title, key = treeNode.key, isStart = treeNode.isStart, isEnd = treeNode.isEnd;
        delete restProps.children;
        var treeNodeProps = getTreeNodeProps(key, treeNodeRequiredProps);
        return /* @__PURE__ */ reactExports.createElement(ContextTreeNode, _extends$4({}, restProps, treeNodeProps, {
          title: title2,
          active,
          data: treeNode.data,
          key,
          isStart,
          isEnd
        }));
      }));
    });
  }
  return /* @__PURE__ */ reactExports.createElement(ContextTreeNode, _extends$4({
    domRef: ref2,
    className,
    style: style2
  }, props, {
    active
  }));
};
MotionTreeNode.displayName = "MotionTreeNode";
var RefMotionTreeNode = /* @__PURE__ */ reactExports.forwardRef(MotionTreeNode);
function findExpandedKeys() {
  var prev = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  var next = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var prevLen = prev.length;
  var nextLen = next.length;
  if (Math.abs(prevLen - nextLen) !== 1) {
    return {
      add: false,
      key: null
    };
  }
  function find2(shorter, longer) {
    var cache2 = /* @__PURE__ */ new Map();
    shorter.forEach(function(key) {
      cache2.set(key, true);
    });
    var keys2 = longer.filter(function(key) {
      return !cache2.has(key);
    });
    return keys2.length === 1 ? keys2[0] : null;
  }
  if (prevLen < nextLen) {
    return {
      add: true,
      key: find2(prev, next)
    };
  }
  return {
    add: false,
    key: find2(next, prev)
  };
}
function getExpandRange(shorter, longer, key) {
  var shorterStartIndex = shorter.findIndex(function(data2) {
    return data2.key === key;
  });
  var shorterEndNode = shorter[shorterStartIndex + 1];
  var longerStartIndex = longer.findIndex(function(data2) {
    return data2.key === key;
  });
  if (shorterEndNode) {
    var longerEndIndex = longer.findIndex(function(data2) {
      return data2.key === shorterEndNode.key;
    });
    return longer.slice(longerStartIndex + 1, longerEndIndex);
  }
  return longer.slice(longerStartIndex + 1);
}
var _excluded$2 = ["prefixCls", "data", "selectable", "checkable", "expandedKeys", "selectedKeys", "checkedKeys", "loadedKeys", "loadingKeys", "halfCheckedKeys", "keyEntities", "disabled", "dragging", "dragOverNodeKey", "dropPosition", "motion", "height", "itemHeight", "virtual", "focusable", "activeItem", "focused", "tabIndex", "onKeyDown", "onFocus", "onBlur", "onActiveChange", "onListChangeStart", "onListChangeEnd"];
var HIDDEN_STYLE = {
  width: 0,
  height: 0,
  display: "flex",
  overflow: "hidden",
  opacity: 0,
  border: 0,
  padding: 0,
  margin: 0
};
var noop$3 = function noop() {
};
var MOTION_KEY = "RC_TREE_MOTION_".concat(Math.random());
var MotionNode = {
  key: MOTION_KEY
};
var MotionEntity = {
  key: MOTION_KEY,
  level: 0,
  index: 0,
  pos: "0",
  node: MotionNode,
  nodes: [MotionNode]
};
var MotionFlattenData = {
  parent: null,
  children: [],
  pos: MotionEntity.pos,
  data: MotionNode,
  title: null,
  key: MOTION_KEY,
  /** Hold empty list here since we do not use it */
  isStart: [],
  isEnd: []
};
function getMinimumRangeTransitionRange(list, virtual, height, itemHeight) {
  if (virtual === false || !height) {
    return list;
  }
  return list.slice(0, Math.ceil(height / itemHeight) + 1);
}
function itemKey(item) {
  var key = item.key, pos = item.pos;
  return getKey(key, pos);
}
function getAccessibilityPath(item) {
  var path = String(item.data.key);
  var current2 = item;
  while (current2.parent) {
    current2 = current2.parent;
    path = "".concat(current2.data.key, " > ").concat(path);
  }
  return path;
}
var NodeList = /* @__PURE__ */ reactExports.forwardRef(function(props, ref2) {
  var prefixCls = props.prefixCls, data2 = props.data;
  props.selectable;
  props.checkable;
  var expandedKeys = props.expandedKeys, selectedKeys = props.selectedKeys, checkedKeys = props.checkedKeys, loadedKeys = props.loadedKeys, loadingKeys = props.loadingKeys, halfCheckedKeys = props.halfCheckedKeys, keyEntities = props.keyEntities, disabled = props.disabled, dragging = props.dragging, dragOverNodeKey = props.dragOverNodeKey, dropPosition = props.dropPosition, motion = props.motion, height = props.height, itemHeight = props.itemHeight, virtual = props.virtual, focusable = props.focusable, activeItem = props.activeItem, focused = props.focused, tabIndex = props.tabIndex, onKeyDown = props.onKeyDown, onFocus = props.onFocus, onBlur = props.onBlur, onActiveChange = props.onActiveChange, onListChangeStart = props.onListChangeStart, onListChangeEnd = props.onListChangeEnd, domProps = _objectWithoutProperties$3(props, _excluded$2);
  var listRef = reactExports.useRef(null);
  var indentMeasurerRef = reactExports.useRef(null);
  reactExports.useImperativeHandle(ref2, function() {
    return {
      scrollTo: function scrollTo(scroll) {
        listRef.current.scrollTo(scroll);
      },
      getIndentWidth: function getIndentWidth() {
        return indentMeasurerRef.current.offsetWidth;
      }
    };
  });
  var _React$useState = reactExports.useState(expandedKeys), _React$useState2 = _slicedToArray(_React$useState, 2), prevExpandedKeys = _React$useState2[0], setPrevExpandedKeys = _React$useState2[1];
  var _React$useState3 = reactExports.useState(data2), _React$useState4 = _slicedToArray(_React$useState3, 2), prevData = _React$useState4[0], setPrevData = _React$useState4[1];
  var _React$useState5 = reactExports.useState(data2), _React$useState6 = _slicedToArray(_React$useState5, 2), transitionData = _React$useState6[0], setTransitionData = _React$useState6[1];
  var _React$useState7 = reactExports.useState([]), _React$useState8 = _slicedToArray(_React$useState7, 2), transitionRange = _React$useState8[0], setTransitionRange = _React$useState8[1];
  var _React$useState9 = reactExports.useState(null), _React$useState10 = _slicedToArray(_React$useState9, 2), motionType = _React$useState10[0], setMotionType = _React$useState10[1];
  var dataRef = reactExports.useRef(data2);
  dataRef.current = data2;
  function onMotionEnd() {
    var latestData = dataRef.current;
    setPrevData(latestData);
    setTransitionData(latestData);
    setTransitionRange([]);
    setMotionType(null);
    onListChangeEnd();
  }
  useLayoutEffect(function() {
    setPrevExpandedKeys(expandedKeys);
    var diffExpanded = findExpandedKeys(prevExpandedKeys, expandedKeys);
    if (diffExpanded.key !== null) {
      if (diffExpanded.add) {
        var keyIndex = prevData.findIndex(function(_ref) {
          var key = _ref.key;
          return key === diffExpanded.key;
        });
        var rangeNodes = getMinimumRangeTransitionRange(getExpandRange(prevData, data2, diffExpanded.key), virtual, height, itemHeight);
        var newTransitionData = prevData.slice();
        newTransitionData.splice(keyIndex + 1, 0, MotionFlattenData);
        setTransitionData(newTransitionData);
        setTransitionRange(rangeNodes);
        setMotionType("show");
      } else {
        var _keyIndex = data2.findIndex(function(_ref2) {
          var key = _ref2.key;
          return key === diffExpanded.key;
        });
        var _rangeNodes = getMinimumRangeTransitionRange(getExpandRange(data2, prevData, diffExpanded.key), virtual, height, itemHeight);
        var _newTransitionData = data2.slice();
        _newTransitionData.splice(_keyIndex + 1, 0, MotionFlattenData);
        setTransitionData(_newTransitionData);
        setTransitionRange(_rangeNodes);
        setMotionType("hide");
      }
    } else if (prevData !== data2) {
      setPrevData(data2);
      setTransitionData(data2);
    }
  }, [expandedKeys, data2]);
  reactExports.useEffect(function() {
    if (!dragging) {
      onMotionEnd();
    }
  }, [dragging]);
  var mergedData = motion ? transitionData : data2;
  var treeNodeRequiredProps = {
    expandedKeys,
    selectedKeys,
    loadedKeys,
    loadingKeys,
    checkedKeys,
    halfCheckedKeys,
    dragOverNodeKey,
    dropPosition,
    keyEntities
  };
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, focused && activeItem && /* @__PURE__ */ reactExports.createElement("span", {
    style: HIDDEN_STYLE,
    "aria-live": "assertive"
  }, getAccessibilityPath(activeItem)), /* @__PURE__ */ reactExports.createElement("div", null, /* @__PURE__ */ reactExports.createElement("input", {
    style: HIDDEN_STYLE,
    disabled: focusable === false || disabled,
    tabIndex: focusable !== false ? tabIndex : null,
    onKeyDown,
    onFocus,
    onBlur,
    value: "",
    onChange: noop$3,
    "aria-label": "for screen reader"
  })), /* @__PURE__ */ reactExports.createElement("div", {
    className: "".concat(prefixCls, "-treenode"),
    "aria-hidden": true,
    style: {
      position: "absolute",
      pointerEvents: "none",
      visibility: "hidden",
      height: 0,
      overflow: "hidden",
      border: 0,
      padding: 0
    }
  }, /* @__PURE__ */ reactExports.createElement("div", {
    className: "".concat(prefixCls, "-indent")
  }, /* @__PURE__ */ reactExports.createElement("div", {
    ref: indentMeasurerRef,
    className: "".concat(prefixCls, "-indent-unit")
  }))), /* @__PURE__ */ reactExports.createElement(List$1, _extends$4({}, domProps, {
    data: mergedData,
    itemKey,
    height,
    fullHeight: false,
    virtual,
    itemHeight,
    prefixCls: "".concat(prefixCls, "-list"),
    ref: listRef,
    onVisibleChange: function onVisibleChange(originList, fullList) {
      var originSet = new Set(originList);
      var restList = fullList.filter(function(item) {
        return !originSet.has(item);
      });
      if (restList.some(function(item) {
        return itemKey(item) === MOTION_KEY;
      })) {
        onMotionEnd();
      }
    }
  }), function(treeNode) {
    var pos = treeNode.pos, restProps = Object.assign({}, (_objectDestructuringEmpty(treeNode.data), treeNode.data)), title2 = treeNode.title, key = treeNode.key, isStart = treeNode.isStart, isEnd = treeNode.isEnd;
    var mergedKey = getKey(key, pos);
    delete restProps.key;
    delete restProps.children;
    var treeNodeProps = getTreeNodeProps(mergedKey, treeNodeRequiredProps);
    return /* @__PURE__ */ reactExports.createElement(RefMotionTreeNode, _extends$4({}, restProps, treeNodeProps, {
      title: title2,
      active: !!activeItem && key === activeItem.key,
      pos,
      data: treeNode.data,
      isStart,
      isEnd,
      motion,
      motionNodes: key === MOTION_KEY ? transitionRange : null,
      motionType,
      onMotionStart: onListChangeStart,
      onMotionEnd,
      treeNodeRequiredProps,
      onMouseMove: function onMouseMove() {
        onActiveChange(null);
      }
    }));
  }));
});
NodeList.displayName = "NodeList";
function arrDel(list, value2) {
  if (!list)
    return [];
  var clone3 = list.slice();
  var index2 = clone3.indexOf(value2);
  if (index2 >= 0) {
    clone3.splice(index2, 1);
  }
  return clone3;
}
function arrAdd(list, value2) {
  var clone3 = (list || []).slice();
  if (clone3.indexOf(value2) === -1) {
    clone3.push(value2);
  }
  return clone3;
}
function posToArr(pos) {
  return pos.split("-");
}
function getDragChildrenKeys(dragNodeKey, keyEntities) {
  var dragChildrenKeys = [];
  var entity = getEntity(keyEntities, dragNodeKey);
  function dig() {
    var list = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    list.forEach(function(_ref) {
      var key = _ref.key, children = _ref.children;
      dragChildrenKeys.push(key);
      dig(children);
    });
  }
  dig(entity.children);
  return dragChildrenKeys;
}
function isLastChild(treeNodeEntity) {
  if (treeNodeEntity.parent) {
    var posArr = posToArr(treeNodeEntity.pos);
    return Number(posArr[posArr.length - 1]) === treeNodeEntity.parent.children.length - 1;
  }
  return false;
}
function isFirstChild(treeNodeEntity) {
  var posArr = posToArr(treeNodeEntity.pos);
  return Number(posArr[posArr.length - 1]) === 0;
}
function calcDropPosition(event, dragNode, targetNode, indent, startMousePosition, allowDrop2, flattenedNodes, keyEntities, expandKeys, direction) {
  var _abstractDropNodeEnti;
  var clientX = event.clientX, clientY = event.clientY;
  var _getBoundingClientRec = event.target.getBoundingClientRect(), top = _getBoundingClientRec.top, height = _getBoundingClientRec.height;
  var horizontalMouseOffset = (direction === "rtl" ? -1 : 1) * (((startMousePosition === null || startMousePosition === void 0 ? void 0 : startMousePosition.x) || 0) - clientX);
  var rawDropLevelOffset = (horizontalMouseOffset - 12) / indent;
  var filteredExpandKeys = expandKeys.filter(function(key) {
    var _keyEntities$key;
    return (_keyEntities$key = keyEntities[key]) === null || _keyEntities$key === void 0 || (_keyEntities$key = _keyEntities$key.children) === null || _keyEntities$key === void 0 ? void 0 : _keyEntities$key.length;
  });
  var abstractDropNodeEntity = getEntity(keyEntities, targetNode.props.eventKey);
  if (clientY < top + height / 2) {
    var nodeIndex = flattenedNodes.findIndex(function(flattenedNode) {
      return flattenedNode.key === abstractDropNodeEntity.key;
    });
    var prevNodeIndex = nodeIndex <= 0 ? 0 : nodeIndex - 1;
    var prevNodeKey = flattenedNodes[prevNodeIndex].key;
    abstractDropNodeEntity = getEntity(keyEntities, prevNodeKey);
  }
  var initialAbstractDropNodeKey = abstractDropNodeEntity.key;
  var abstractDragOverEntity = abstractDropNodeEntity;
  var dragOverNodeKey = abstractDropNodeEntity.key;
  var dropPosition = 0;
  var dropLevelOffset = 0;
  if (!filteredExpandKeys.includes(initialAbstractDropNodeKey)) {
    for (var i16 = 0; i16 < rawDropLevelOffset; i16 += 1) {
      if (isLastChild(abstractDropNodeEntity)) {
        abstractDropNodeEntity = abstractDropNodeEntity.parent;
        dropLevelOffset += 1;
      } else {
        break;
      }
    }
  }
  var abstractDragDataNode = dragNode.props.data;
  var abstractDropDataNode = abstractDropNodeEntity.node;
  var dropAllowed = true;
  if (isFirstChild(abstractDropNodeEntity) && abstractDropNodeEntity.level === 0 && clientY < top + height / 2 && allowDrop2({
    dragNode: abstractDragDataNode,
    dropNode: abstractDropDataNode,
    dropPosition: -1
  }) && abstractDropNodeEntity.key === targetNode.props.eventKey) {
    dropPosition = -1;
  } else if ((abstractDragOverEntity.children || []).length && filteredExpandKeys.includes(dragOverNodeKey)) {
    if (allowDrop2({
      dragNode: abstractDragDataNode,
      dropNode: abstractDropDataNode,
      dropPosition: 0
    })) {
      dropPosition = 0;
    } else {
      dropAllowed = false;
    }
  } else if (dropLevelOffset === 0) {
    if (rawDropLevelOffset > -1.5) {
      if (allowDrop2({
        dragNode: abstractDragDataNode,
        dropNode: abstractDropDataNode,
        dropPosition: 1
      })) {
        dropPosition = 1;
      } else {
        dropAllowed = false;
      }
    } else {
      if (allowDrop2({
        dragNode: abstractDragDataNode,
        dropNode: abstractDropDataNode,
        dropPosition: 0
      })) {
        dropPosition = 0;
      } else if (allowDrop2({
        dragNode: abstractDragDataNode,
        dropNode: abstractDropDataNode,
        dropPosition: 1
      })) {
        dropPosition = 1;
      } else {
        dropAllowed = false;
      }
    }
  } else {
    if (allowDrop2({
      dragNode: abstractDragDataNode,
      dropNode: abstractDropDataNode,
      dropPosition: 1
    })) {
      dropPosition = 1;
    } else {
      dropAllowed = false;
    }
  }
  return {
    dropPosition,
    dropLevelOffset,
    dropTargetKey: abstractDropNodeEntity.key,
    dropTargetPos: abstractDropNodeEntity.pos,
    dragOverNodeKey,
    dropContainerKey: dropPosition === 0 ? null : ((_abstractDropNodeEnti = abstractDropNodeEntity.parent) === null || _abstractDropNodeEnti === void 0 ? void 0 : _abstractDropNodeEnti.key) || null,
    dropAllowed
  };
}
function calcSelectedKeys(selectedKeys, props) {
  if (!selectedKeys)
    return void 0;
  var multiple = props.multiple;
  if (multiple) {
    return selectedKeys.slice();
  }
  if (selectedKeys.length) {
    return [selectedKeys[0]];
  }
  return selectedKeys;
}
function parseCheckedKeys(keys2) {
  if (!keys2) {
    return null;
  }
  var keyProps;
  if (Array.isArray(keys2)) {
    keyProps = {
      checkedKeys: keys2,
      halfCheckedKeys: void 0
    };
  } else if (_typeof$6(keys2) === "object") {
    keyProps = {
      checkedKeys: keys2.checked || void 0,
      halfCheckedKeys: keys2.halfChecked || void 0
    };
  } else {
    warningOnce(false, "`checkedKeys` is not an array or an object");
    return null;
  }
  return keyProps;
}
function conductExpandParent(keyList, keyEntities) {
  var expandedKeys = /* @__PURE__ */ new Set();
  function conductUp(key) {
    if (expandedKeys.has(key))
      return;
    var entity = getEntity(keyEntities, key);
    if (!entity)
      return;
    expandedKeys.add(key);
    var parent = entity.parent, node = entity.node;
    if (node.disabled)
      return;
    if (parent) {
      conductUp(parent.key);
    }
  }
  (keyList || []).forEach(function(key) {
    conductUp(key);
  });
  return _toConsumableArray(expandedKeys);
}
function removeFromCheckedKeys(halfCheckedKeys, checkedKeys) {
  var filteredKeys = /* @__PURE__ */ new Set();
  halfCheckedKeys.forEach(function(key) {
    if (!checkedKeys.has(key)) {
      filteredKeys.add(key);
    }
  });
  return filteredKeys;
}
function isCheckDisabled(node) {
  var _ref = node || {}, disabled = _ref.disabled, disableCheckbox = _ref.disableCheckbox, checkable = _ref.checkable;
  return !!(disabled || disableCheckbox) || checkable === false;
}
function fillConductCheck(keys2, levelEntities, maxLevel, syntheticGetCheckDisabled) {
  var checkedKeys = new Set(keys2);
  var halfCheckedKeys = /* @__PURE__ */ new Set();
  for (var level = 0; level <= maxLevel; level += 1) {
    var entities = levelEntities.get(level) || /* @__PURE__ */ new Set();
    entities.forEach(function(entity) {
      var key = entity.key, node = entity.node, _entity$children = entity.children, children = _entity$children === void 0 ? [] : _entity$children;
      if (checkedKeys.has(key) && !syntheticGetCheckDisabled(node)) {
        children.filter(function(childEntity) {
          return !syntheticGetCheckDisabled(childEntity.node);
        }).forEach(function(childEntity) {
          checkedKeys.add(childEntity.key);
        });
      }
    });
  }
  var visitedKeys = /* @__PURE__ */ new Set();
  for (var _level = maxLevel; _level >= 0; _level -= 1) {
    var _entities = levelEntities.get(_level) || /* @__PURE__ */ new Set();
    _entities.forEach(function(entity) {
      var parent = entity.parent, node = entity.node;
      if (syntheticGetCheckDisabled(node) || !entity.parent || visitedKeys.has(entity.parent.key)) {
        return;
      }
      if (syntheticGetCheckDisabled(entity.parent.node)) {
        visitedKeys.add(parent.key);
        return;
      }
      var allChecked = true;
      var partialChecked = false;
      (parent.children || []).filter(function(childEntity) {
        return !syntheticGetCheckDisabled(childEntity.node);
      }).forEach(function(_ref2) {
        var key = _ref2.key;
        var checked = checkedKeys.has(key);
        if (allChecked && !checked) {
          allChecked = false;
        }
        if (!partialChecked && (checked || halfCheckedKeys.has(key))) {
          partialChecked = true;
        }
      });
      if (allChecked) {
        checkedKeys.add(parent.key);
      }
      if (partialChecked) {
        halfCheckedKeys.add(parent.key);
      }
      visitedKeys.add(parent.key);
    });
  }
  return {
    checkedKeys: Array.from(checkedKeys),
    halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))
  };
}
function cleanConductCheck(keys2, halfKeys, levelEntities, maxLevel, syntheticGetCheckDisabled) {
  var checkedKeys = new Set(keys2);
  var halfCheckedKeys = new Set(halfKeys);
  for (var level = 0; level <= maxLevel; level += 1) {
    var entities = levelEntities.get(level) || /* @__PURE__ */ new Set();
    entities.forEach(function(entity) {
      var key = entity.key, node = entity.node, _entity$children2 = entity.children, children = _entity$children2 === void 0 ? [] : _entity$children2;
      if (!checkedKeys.has(key) && !halfCheckedKeys.has(key) && !syntheticGetCheckDisabled(node)) {
        children.filter(function(childEntity) {
          return !syntheticGetCheckDisabled(childEntity.node);
        }).forEach(function(childEntity) {
          checkedKeys.delete(childEntity.key);
        });
      }
    });
  }
  halfCheckedKeys = /* @__PURE__ */ new Set();
  var visitedKeys = /* @__PURE__ */ new Set();
  for (var _level2 = maxLevel; _level2 >= 0; _level2 -= 1) {
    var _entities2 = levelEntities.get(_level2) || /* @__PURE__ */ new Set();
    _entities2.forEach(function(entity) {
      var parent = entity.parent, node = entity.node;
      if (syntheticGetCheckDisabled(node) || !entity.parent || visitedKeys.has(entity.parent.key)) {
        return;
      }
      if (syntheticGetCheckDisabled(entity.parent.node)) {
        visitedKeys.add(parent.key);
        return;
      }
      var allChecked = true;
      var partialChecked = false;
      (parent.children || []).filter(function(childEntity) {
        return !syntheticGetCheckDisabled(childEntity.node);
      }).forEach(function(_ref3) {
        var key = _ref3.key;
        var checked = checkedKeys.has(key);
        if (allChecked && !checked) {
          allChecked = false;
        }
        if (!partialChecked && (checked || halfCheckedKeys.has(key))) {
          partialChecked = true;
        }
      });
      if (!allChecked) {
        checkedKeys.delete(parent.key);
      }
      if (partialChecked) {
        halfCheckedKeys.add(parent.key);
      }
      visitedKeys.add(parent.key);
    });
  }
  return {
    checkedKeys: Array.from(checkedKeys),
    halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))
  };
}
function conductCheck(keyList, checked, keyEntities, getCheckDisabled) {
  var warningMissKeys = [];
  var syntheticGetCheckDisabled;
  if (getCheckDisabled) {
    syntheticGetCheckDisabled = getCheckDisabled;
  } else {
    syntheticGetCheckDisabled = isCheckDisabled;
  }
  var keys2 = new Set(keyList.filter(function(key) {
    var hasEntity = !!getEntity(keyEntities, key);
    if (!hasEntity) {
      warningMissKeys.push(key);
    }
    return hasEntity;
  }));
  var levelEntities = /* @__PURE__ */ new Map();
  var maxLevel = 0;
  Object.keys(keyEntities).forEach(function(key) {
    var entity = keyEntities[key];
    var level = entity.level;
    var levelSet = levelEntities.get(level);
    if (!levelSet) {
      levelSet = /* @__PURE__ */ new Set();
      levelEntities.set(level, levelSet);
    }
    levelSet.add(entity);
    maxLevel = Math.max(maxLevel, level);
  });
  warningOnce(!warningMissKeys.length, "Tree missing follow keys: ".concat(warningMissKeys.slice(0, 100).map(function(key) {
    return "'".concat(key, "'");
  }).join(", ")));
  var result;
  if (checked === true) {
    result = fillConductCheck(keys2, levelEntities, maxLevel, syntheticGetCheckDisabled);
  } else {
    result = cleanConductCheck(keys2, checked.halfCheckedKeys, levelEntities, maxLevel, syntheticGetCheckDisabled);
  }
  return result;
}
var MAX_RETRY_TIMES = 10;
var Tree = /* @__PURE__ */ function(_React$Component) {
  _inherits$5(Tree2, _React$Component);
  var _super = _createSuper$4(Tree2);
  function Tree2() {
    var _this;
    _classCallCheck$5(this, Tree2);
    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
      _args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(_args));
    _defineProperty$2(_assertThisInitialized$4(_this), "destroyed", false);
    _defineProperty$2(_assertThisInitialized$4(_this), "delayedDragEnterLogic", void 0);
    _defineProperty$2(_assertThisInitialized$4(_this), "loadingRetryTimes", {});
    _defineProperty$2(_assertThisInitialized$4(_this), "state", {
      keyEntities: {},
      indent: null,
      selectedKeys: [],
      checkedKeys: [],
      halfCheckedKeys: [],
      loadedKeys: [],
      loadingKeys: [],
      expandedKeys: [],
      draggingNodeKey: null,
      dragChildrenKeys: [],
      // dropTargetKey is the key of abstract-drop-node
      // the abstract-drop-node is the real drop node when drag and drop
      // not the DOM drag over node
      dropTargetKey: null,
      dropPosition: null,
      // the drop position of abstract-drop-node, inside 0, top -1, bottom 1
      dropContainerKey: null,
      // the container key of abstract-drop-node if dropPosition is -1 or 1
      dropLevelOffset: null,
      // the drop level offset of abstract-drag-over-node
      dropTargetPos: null,
      // the pos of abstract-drop-node
      dropAllowed: true,
      // if drop to abstract-drop-node is allowed
      // the abstract-drag-over-node
      // if mouse is on the bottom of top dom node or no the top of the bottom dom node
      // abstract-drag-over-node is the top node
      dragOverNodeKey: null,
      treeData: [],
      flattenNodes: [],
      focused: false,
      activeKey: null,
      listChanging: false,
      prevProps: null,
      fieldNames: fillFieldNames()
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "dragStartMousePosition", null);
    _defineProperty$2(_assertThisInitialized$4(_this), "dragNode", void 0);
    _defineProperty$2(_assertThisInitialized$4(_this), "currentMouseOverDroppableNodeKey", null);
    _defineProperty$2(_assertThisInitialized$4(_this), "listRef", /* @__PURE__ */ reactExports.createRef());
    _defineProperty$2(_assertThisInitialized$4(_this), "onNodeDragStart", function(event, node) {
      var _this$state = _this.state, expandedKeys = _this$state.expandedKeys, keyEntities = _this$state.keyEntities;
      var onDragStart = _this.props.onDragStart;
      var eventKey = node.props.eventKey;
      _this.dragNode = node;
      _this.dragStartMousePosition = {
        x: event.clientX,
        y: event.clientY
      };
      var newExpandedKeys = arrDel(expandedKeys, eventKey);
      _this.setState({
        draggingNodeKey: eventKey,
        dragChildrenKeys: getDragChildrenKeys(eventKey, keyEntities),
        indent: _this.listRef.current.getIndentWidth()
      });
      _this.setExpandedKeys(newExpandedKeys);
      window.addEventListener("dragend", _this.onWindowDragEnd);
      onDragStart === null || onDragStart === void 0 || onDragStart({
        event,
        node: convertNodePropsToEventData(node.props)
      });
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "onNodeDragEnter", function(event, node) {
      var _this$state2 = _this.state, expandedKeys = _this$state2.expandedKeys, keyEntities = _this$state2.keyEntities, dragChildrenKeys = _this$state2.dragChildrenKeys, flattenNodes = _this$state2.flattenNodes, indent = _this$state2.indent;
      var _this$props = _this.props, onDragEnter = _this$props.onDragEnter, onExpand = _this$props.onExpand, allowDrop2 = _this$props.allowDrop, direction = _this$props.direction;
      var _node$props = node.props, pos = _node$props.pos, eventKey = _node$props.eventKey;
      var _assertThisInitialize = _assertThisInitialized$4(_this), dragNode = _assertThisInitialize.dragNode;
      if (_this.currentMouseOverDroppableNodeKey !== eventKey) {
        _this.currentMouseOverDroppableNodeKey = eventKey;
      }
      if (!dragNode) {
        _this.resetDragState();
        return;
      }
      var _calcDropPosition = calcDropPosition(event, dragNode, node, indent, _this.dragStartMousePosition, allowDrop2, flattenNodes, keyEntities, expandedKeys, direction), dropPosition = _calcDropPosition.dropPosition, dropLevelOffset = _calcDropPosition.dropLevelOffset, dropTargetKey = _calcDropPosition.dropTargetKey, dropContainerKey = _calcDropPosition.dropContainerKey, dropTargetPos = _calcDropPosition.dropTargetPos, dropAllowed = _calcDropPosition.dropAllowed, dragOverNodeKey = _calcDropPosition.dragOverNodeKey;
      if (
        // don't allow drop inside its children
        dragChildrenKeys.indexOf(dropTargetKey) !== -1 || // don't allow drop when drop is not allowed caculated by calcDropPosition
        !dropAllowed
      ) {
        _this.resetDragState();
        return;
      }
      if (!_this.delayedDragEnterLogic) {
        _this.delayedDragEnterLogic = {};
      }
      Object.keys(_this.delayedDragEnterLogic).forEach(function(key) {
        clearTimeout(_this.delayedDragEnterLogic[key]);
      });
      if (dragNode.props.eventKey !== node.props.eventKey) {
        event.persist();
        _this.delayedDragEnterLogic[pos] = window.setTimeout(function() {
          if (_this.state.draggingNodeKey === null)
            return;
          var newExpandedKeys = _toConsumableArray(expandedKeys);
          var entity = getEntity(keyEntities, node.props.eventKey);
          if (entity && (entity.children || []).length) {
            newExpandedKeys = arrAdd(expandedKeys, node.props.eventKey);
          }
          if (!("expandedKeys" in _this.props)) {
            _this.setExpandedKeys(newExpandedKeys);
          }
          onExpand === null || onExpand === void 0 || onExpand(newExpandedKeys, {
            node: convertNodePropsToEventData(node.props),
            expanded: true,
            nativeEvent: event.nativeEvent
          });
        }, 800);
      }
      if (dragNode.props.eventKey === dropTargetKey && dropLevelOffset === 0) {
        _this.resetDragState();
        return;
      }
      _this.setState({
        dragOverNodeKey,
        dropPosition,
        dropLevelOffset,
        dropTargetKey,
        dropContainerKey,
        dropTargetPos,
        dropAllowed
      });
      onDragEnter === null || onDragEnter === void 0 || onDragEnter({
        event,
        node: convertNodePropsToEventData(node.props),
        expandedKeys
      });
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "onNodeDragOver", function(event, node) {
      var _this$state3 = _this.state, dragChildrenKeys = _this$state3.dragChildrenKeys, flattenNodes = _this$state3.flattenNodes, keyEntities = _this$state3.keyEntities, expandedKeys = _this$state3.expandedKeys, indent = _this$state3.indent;
      var _this$props2 = _this.props, onDragOver = _this$props2.onDragOver, allowDrop2 = _this$props2.allowDrop, direction = _this$props2.direction;
      var _assertThisInitialize2 = _assertThisInitialized$4(_this), dragNode = _assertThisInitialize2.dragNode;
      if (!dragNode) {
        return;
      }
      var _calcDropPosition2 = calcDropPosition(event, dragNode, node, indent, _this.dragStartMousePosition, allowDrop2, flattenNodes, keyEntities, expandedKeys, direction), dropPosition = _calcDropPosition2.dropPosition, dropLevelOffset = _calcDropPosition2.dropLevelOffset, dropTargetKey = _calcDropPosition2.dropTargetKey, dropContainerKey = _calcDropPosition2.dropContainerKey, dropAllowed = _calcDropPosition2.dropAllowed, dropTargetPos = _calcDropPosition2.dropTargetPos, dragOverNodeKey = _calcDropPosition2.dragOverNodeKey;
      if (dragChildrenKeys.indexOf(dropTargetKey) !== -1 || !dropAllowed) {
        return;
      }
      if (dragNode.props.eventKey === dropTargetKey && dropLevelOffset === 0) {
        if (!(_this.state.dropPosition === null && _this.state.dropLevelOffset === null && _this.state.dropTargetKey === null && _this.state.dropContainerKey === null && _this.state.dropTargetPos === null && _this.state.dropAllowed === false && _this.state.dragOverNodeKey === null)) {
          _this.resetDragState();
        }
      } else if (!(dropPosition === _this.state.dropPosition && dropLevelOffset === _this.state.dropLevelOffset && dropTargetKey === _this.state.dropTargetKey && dropContainerKey === _this.state.dropContainerKey && dropTargetPos === _this.state.dropTargetPos && dropAllowed === _this.state.dropAllowed && dragOverNodeKey === _this.state.dragOverNodeKey)) {
        _this.setState({
          dropPosition,
          dropLevelOffset,
          dropTargetKey,
          dropContainerKey,
          dropTargetPos,
          dropAllowed,
          dragOverNodeKey
        });
      }
      onDragOver === null || onDragOver === void 0 || onDragOver({
        event,
        node: convertNodePropsToEventData(node.props)
      });
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "onNodeDragLeave", function(event, node) {
      if (_this.currentMouseOverDroppableNodeKey === node.props.eventKey && !event.currentTarget.contains(event.relatedTarget)) {
        _this.resetDragState();
        _this.currentMouseOverDroppableNodeKey = null;
      }
      var onDragLeave = _this.props.onDragLeave;
      onDragLeave === null || onDragLeave === void 0 || onDragLeave({
        event,
        node: convertNodePropsToEventData(node.props)
      });
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "onWindowDragEnd", function(event) {
      _this.onNodeDragEnd(event, null, true);
      window.removeEventListener("dragend", _this.onWindowDragEnd);
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "onNodeDragEnd", function(event, node) {
      var onDragEnd = _this.props.onDragEnd;
      _this.setState({
        dragOverNodeKey: null
      });
      _this.cleanDragState();
      onDragEnd === null || onDragEnd === void 0 || onDragEnd({
        event,
        node: convertNodePropsToEventData(node.props)
      });
      _this.dragNode = null;
      window.removeEventListener("dragend", _this.onWindowDragEnd);
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "onNodeDrop", function(event, node) {
      var _this$getActiveItem;
      var outsideTree = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var _this$state4 = _this.state, dragChildrenKeys = _this$state4.dragChildrenKeys, dropPosition = _this$state4.dropPosition, dropTargetKey = _this$state4.dropTargetKey, dropTargetPos = _this$state4.dropTargetPos, dropAllowed = _this$state4.dropAllowed;
      if (!dropAllowed)
        return;
      var onDrop = _this.props.onDrop;
      _this.setState({
        dragOverNodeKey: null
      });
      _this.cleanDragState();
      if (dropTargetKey === null)
        return;
      var abstractDropNodeProps = _objectSpread2(_objectSpread2({}, getTreeNodeProps(dropTargetKey, _this.getTreeNodeRequiredProps())), {}, {
        active: ((_this$getActiveItem = _this.getActiveItem()) === null || _this$getActiveItem === void 0 ? void 0 : _this$getActiveItem.key) === dropTargetKey,
        data: getEntity(_this.state.keyEntities, dropTargetKey).node
      });
      var dropToChild = dragChildrenKeys.indexOf(dropTargetKey) !== -1;
      warningOnce(!dropToChild, "Can not drop to dragNode's children node. This is a bug of rc-tree. Please report an issue.");
      var posArr = posToArr(dropTargetPos);
      var dropResult = {
        event,
        node: convertNodePropsToEventData(abstractDropNodeProps),
        dragNode: _this.dragNode ? convertNodePropsToEventData(_this.dragNode.props) : null,
        dragNodesKeys: [_this.dragNode.props.eventKey].concat(dragChildrenKeys),
        dropToGap: dropPosition !== 0,
        dropPosition: dropPosition + Number(posArr[posArr.length - 1])
      };
      if (!outsideTree) {
        onDrop === null || onDrop === void 0 || onDrop(dropResult);
      }
      _this.dragNode = null;
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "cleanDragState", function() {
      var draggingNodeKey = _this.state.draggingNodeKey;
      if (draggingNodeKey !== null) {
        _this.setState({
          draggingNodeKey: null,
          dropPosition: null,
          dropContainerKey: null,
          dropTargetKey: null,
          dropLevelOffset: null,
          dropAllowed: true,
          dragOverNodeKey: null
        });
      }
      _this.dragStartMousePosition = null;
      _this.currentMouseOverDroppableNodeKey = null;
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "triggerExpandActionExpand", function(e3, treeNode) {
      var _this$state5 = _this.state, expandedKeys = _this$state5.expandedKeys, flattenNodes = _this$state5.flattenNodes;
      var expanded = treeNode.expanded, key = treeNode.key, isLeaf = treeNode.isLeaf;
      if (isLeaf || e3.shiftKey || e3.metaKey || e3.ctrlKey) {
        return;
      }
      var node = flattenNodes.filter(function(nodeItem) {
        return nodeItem.key === key;
      })[0];
      var eventNode = convertNodePropsToEventData(_objectSpread2(_objectSpread2({}, getTreeNodeProps(key, _this.getTreeNodeRequiredProps())), {}, {
        data: node.data
      }));
      _this.setExpandedKeys(expanded ? arrDel(expandedKeys, key) : arrAdd(expandedKeys, key));
      _this.onNodeExpand(e3, eventNode);
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "onNodeClick", function(e3, treeNode) {
      var _this$props3 = _this.props, onClick = _this$props3.onClick, expandAction = _this$props3.expandAction;
      if (expandAction === "click") {
        _this.triggerExpandActionExpand(e3, treeNode);
      }
      onClick === null || onClick === void 0 || onClick(e3, treeNode);
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "onNodeDoubleClick", function(e3, treeNode) {
      var _this$props4 = _this.props, onDoubleClick = _this$props4.onDoubleClick, expandAction = _this$props4.expandAction;
      if (expandAction === "doubleClick") {
        _this.triggerExpandActionExpand(e3, treeNode);
      }
      onDoubleClick === null || onDoubleClick === void 0 || onDoubleClick(e3, treeNode);
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "onNodeSelect", function(e3, treeNode) {
      var selectedKeys = _this.state.selectedKeys;
      var _this$state6 = _this.state, keyEntities = _this$state6.keyEntities, fieldNames = _this$state6.fieldNames;
      var _this$props5 = _this.props, onSelect = _this$props5.onSelect, multiple = _this$props5.multiple;
      var selected = treeNode.selected;
      var key = treeNode[fieldNames.key];
      var targetSelected = !selected;
      if (!targetSelected) {
        selectedKeys = arrDel(selectedKeys, key);
      } else if (!multiple) {
        selectedKeys = [key];
      } else {
        selectedKeys = arrAdd(selectedKeys, key);
      }
      var selectedNodes = selectedKeys.map(function(selectedKey) {
        var entity = getEntity(keyEntities, selectedKey);
        if (!entity)
          return null;
        return entity.node;
      }).filter(function(node) {
        return node;
      });
      _this.setUncontrolledState({
        selectedKeys
      });
      onSelect === null || onSelect === void 0 || onSelect(selectedKeys, {
        event: "select",
        selected: targetSelected,
        node: treeNode,
        selectedNodes,
        nativeEvent: e3.nativeEvent
      });
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "onNodeCheck", function(e3, treeNode, checked) {
      var _this$state7 = _this.state, keyEntities = _this$state7.keyEntities, oriCheckedKeys = _this$state7.checkedKeys, oriHalfCheckedKeys = _this$state7.halfCheckedKeys;
      var _this$props6 = _this.props, checkStrictly = _this$props6.checkStrictly, onCheck = _this$props6.onCheck;
      var key = treeNode.key;
      var checkedObj;
      var eventObj = {
        event: "check",
        node: treeNode,
        checked,
        nativeEvent: e3.nativeEvent
      };
      if (checkStrictly) {
        var checkedKeys = checked ? arrAdd(oriCheckedKeys, key) : arrDel(oriCheckedKeys, key);
        var halfCheckedKeys = arrDel(oriHalfCheckedKeys, key);
        checkedObj = {
          checked: checkedKeys,
          halfChecked: halfCheckedKeys
        };
        eventObj.checkedNodes = checkedKeys.map(function(checkedKey) {
          return getEntity(keyEntities, checkedKey);
        }).filter(function(entity) {
          return entity;
        }).map(function(entity) {
          return entity.node;
        });
        _this.setUncontrolledState({
          checkedKeys
        });
      } else {
        var _conductCheck = conductCheck([].concat(_toConsumableArray(oriCheckedKeys), [key]), true, keyEntities), _checkedKeys = _conductCheck.checkedKeys, _halfCheckedKeys = _conductCheck.halfCheckedKeys;
        if (!checked) {
          var keySet = new Set(_checkedKeys);
          keySet.delete(key);
          var _conductCheck2 = conductCheck(Array.from(keySet), {
            checked: false,
            halfCheckedKeys: _halfCheckedKeys
          }, keyEntities);
          _checkedKeys = _conductCheck2.checkedKeys;
          _halfCheckedKeys = _conductCheck2.halfCheckedKeys;
        }
        checkedObj = _checkedKeys;
        eventObj.checkedNodes = [];
        eventObj.checkedNodesPositions = [];
        eventObj.halfCheckedKeys = _halfCheckedKeys;
        _checkedKeys.forEach(function(checkedKey) {
          var entity = getEntity(keyEntities, checkedKey);
          if (!entity)
            return;
          var node = entity.node, pos = entity.pos;
          eventObj.checkedNodes.push(node);
          eventObj.checkedNodesPositions.push({
            node,
            pos
          });
        });
        _this.setUncontrolledState({
          checkedKeys: _checkedKeys
        }, false, {
          halfCheckedKeys: _halfCheckedKeys
        });
      }
      onCheck === null || onCheck === void 0 || onCheck(checkedObj, eventObj);
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "onNodeLoad", function(treeNode) {
      var _entity$children;
      var key = treeNode.key;
      var keyEntities = _this.state.keyEntities;
      var entity = getEntity(keyEntities, key);
      if (entity !== null && entity !== void 0 && (_entity$children = entity.children) !== null && _entity$children !== void 0 && _entity$children.length) {
        return;
      }
      var loadPromise = new Promise(function(resolve, reject) {
        _this.setState(function(_ref) {
          var _ref$loadedKeys = _ref.loadedKeys, loadedKeys = _ref$loadedKeys === void 0 ? [] : _ref$loadedKeys, _ref$loadingKeys = _ref.loadingKeys, loadingKeys = _ref$loadingKeys === void 0 ? [] : _ref$loadingKeys;
          var _this$props7 = _this.props, loadData = _this$props7.loadData, onLoad = _this$props7.onLoad;
          if (!loadData || loadedKeys.indexOf(key) !== -1 || loadingKeys.indexOf(key) !== -1) {
            return null;
          }
          var promise = loadData(treeNode);
          promise.then(function() {
            var currentLoadedKeys = _this.state.loadedKeys;
            var newLoadedKeys = arrAdd(currentLoadedKeys, key);
            onLoad === null || onLoad === void 0 || onLoad(newLoadedKeys, {
              event: "load",
              node: treeNode
            });
            _this.setUncontrolledState({
              loadedKeys: newLoadedKeys
            });
            _this.setState(function(prevState) {
              return {
                loadingKeys: arrDel(prevState.loadingKeys, key)
              };
            });
            resolve();
          }).catch(function(e3) {
            _this.setState(function(prevState) {
              return {
                loadingKeys: arrDel(prevState.loadingKeys, key)
              };
            });
            _this.loadingRetryTimes[key] = (_this.loadingRetryTimes[key] || 0) + 1;
            if (_this.loadingRetryTimes[key] >= MAX_RETRY_TIMES) {
              var currentLoadedKeys = _this.state.loadedKeys;
              warningOnce(false, "Retry for `loadData` many times but still failed. No more retry.");
              _this.setUncontrolledState({
                loadedKeys: arrAdd(currentLoadedKeys, key)
              });
              resolve();
            }
            reject(e3);
          });
          return {
            loadingKeys: arrAdd(loadingKeys, key)
          };
        });
      });
      loadPromise.catch(function() {
      });
      return loadPromise;
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "onNodeMouseEnter", function(event, node) {
      var onMouseEnter = _this.props.onMouseEnter;
      onMouseEnter === null || onMouseEnter === void 0 || onMouseEnter({
        event,
        node
      });
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "onNodeMouseLeave", function(event, node) {
      var onMouseLeave = _this.props.onMouseLeave;
      onMouseLeave === null || onMouseLeave === void 0 || onMouseLeave({
        event,
        node
      });
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "onNodeContextMenu", function(event, node) {
      var onRightClick = _this.props.onRightClick;
      if (onRightClick) {
        event.preventDefault();
        onRightClick({
          event,
          node
        });
      }
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "onFocus", function() {
      var onFocus = _this.props.onFocus;
      _this.setState({
        focused: true
      });
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      onFocus === null || onFocus === void 0 || onFocus.apply(void 0, args);
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "onBlur", function() {
      var onBlur = _this.props.onBlur;
      _this.setState({
        focused: false
      });
      _this.onActiveChange(null);
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      onBlur === null || onBlur === void 0 || onBlur.apply(void 0, args);
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "getTreeNodeRequiredProps", function() {
      var _this$state8 = _this.state, expandedKeys = _this$state8.expandedKeys, selectedKeys = _this$state8.selectedKeys, loadedKeys = _this$state8.loadedKeys, loadingKeys = _this$state8.loadingKeys, checkedKeys = _this$state8.checkedKeys, halfCheckedKeys = _this$state8.halfCheckedKeys, dragOverNodeKey = _this$state8.dragOverNodeKey, dropPosition = _this$state8.dropPosition, keyEntities = _this$state8.keyEntities;
      return {
        expandedKeys: expandedKeys || [],
        selectedKeys: selectedKeys || [],
        loadedKeys: loadedKeys || [],
        loadingKeys: loadingKeys || [],
        checkedKeys: checkedKeys || [],
        halfCheckedKeys: halfCheckedKeys || [],
        dragOverNodeKey,
        dropPosition,
        keyEntities
      };
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "setExpandedKeys", function(expandedKeys) {
      var _this$state9 = _this.state, treeData = _this$state9.treeData, fieldNames = _this$state9.fieldNames;
      var flattenNodes = flattenTreeData(treeData, expandedKeys, fieldNames);
      _this.setUncontrolledState({
        expandedKeys,
        flattenNodes
      }, true);
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "onNodeExpand", function(e3, treeNode) {
      var expandedKeys = _this.state.expandedKeys;
      var _this$state10 = _this.state, listChanging = _this$state10.listChanging, fieldNames = _this$state10.fieldNames;
      var _this$props8 = _this.props, onExpand = _this$props8.onExpand, loadData = _this$props8.loadData;
      var expanded = treeNode.expanded;
      var key = treeNode[fieldNames.key];
      if (listChanging) {
        return;
      }
      var index2 = expandedKeys.indexOf(key);
      var targetExpanded = !expanded;
      warningOnce(expanded && index2 !== -1 || !expanded && index2 === -1, "Expand state not sync with index check");
      if (targetExpanded) {
        expandedKeys = arrAdd(expandedKeys, key);
      } else {
        expandedKeys = arrDel(expandedKeys, key);
      }
      _this.setExpandedKeys(expandedKeys);
      onExpand === null || onExpand === void 0 || onExpand(expandedKeys, {
        node: treeNode,
        expanded: targetExpanded,
        nativeEvent: e3.nativeEvent
      });
      if (targetExpanded && loadData) {
        var loadPromise = _this.onNodeLoad(treeNode);
        if (loadPromise) {
          loadPromise.then(function() {
            var newFlattenTreeData = flattenTreeData(_this.state.treeData, expandedKeys, fieldNames);
            _this.setUncontrolledState({
              flattenNodes: newFlattenTreeData
            });
          }).catch(function() {
            var currentExpandedKeys = _this.state.expandedKeys;
            var expandedKeysToRestore = arrDel(currentExpandedKeys, key);
            _this.setExpandedKeys(expandedKeysToRestore);
          });
        }
      }
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "onListChangeStart", function() {
      _this.setUncontrolledState({
        listChanging: true
      });
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "onListChangeEnd", function() {
      setTimeout(function() {
        _this.setUncontrolledState({
          listChanging: false
        });
      });
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "onActiveChange", function(newActiveKey) {
      var activeKey = _this.state.activeKey;
      var _this$props9 = _this.props, onActiveChange = _this$props9.onActiveChange, _this$props9$itemScro = _this$props9.itemScrollOffset, itemScrollOffset = _this$props9$itemScro === void 0 ? 0 : _this$props9$itemScro;
      if (activeKey === newActiveKey) {
        return;
      }
      _this.setState({
        activeKey: newActiveKey
      });
      if (newActiveKey !== null) {
        _this.scrollTo({
          key: newActiveKey,
          offset: itemScrollOffset
        });
      }
      onActiveChange === null || onActiveChange === void 0 || onActiveChange(newActiveKey);
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "getActiveItem", function() {
      var _this$state11 = _this.state, activeKey = _this$state11.activeKey, flattenNodes = _this$state11.flattenNodes;
      if (activeKey === null) {
        return null;
      }
      return flattenNodes.find(function(_ref2) {
        var key = _ref2.key;
        return key === activeKey;
      }) || null;
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "offsetActiveKey", function(offset2) {
      var _this$state12 = _this.state, flattenNodes = _this$state12.flattenNodes, activeKey = _this$state12.activeKey;
      var index2 = flattenNodes.findIndex(function(_ref3) {
        var key = _ref3.key;
        return key === activeKey;
      });
      if (index2 === -1 && offset2 < 0) {
        index2 = flattenNodes.length;
      }
      index2 = (index2 + offset2 + flattenNodes.length) % flattenNodes.length;
      var item = flattenNodes[index2];
      if (item) {
        var _key4 = item.key;
        _this.onActiveChange(_key4);
      } else {
        _this.onActiveChange(null);
      }
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "onKeyDown", function(event) {
      var _this$state13 = _this.state, activeKey = _this$state13.activeKey, expandedKeys = _this$state13.expandedKeys, checkedKeys = _this$state13.checkedKeys, fieldNames = _this$state13.fieldNames;
      var _this$props10 = _this.props, onKeyDown = _this$props10.onKeyDown, checkable = _this$props10.checkable, selectable = _this$props10.selectable;
      switch (event.which) {
        case KeyCode.UP: {
          _this.offsetActiveKey(-1);
          event.preventDefault();
          break;
        }
        case KeyCode.DOWN: {
          _this.offsetActiveKey(1);
          event.preventDefault();
          break;
        }
      }
      var activeItem = _this.getActiveItem();
      if (activeItem && activeItem.data) {
        var treeNodeRequiredProps = _this.getTreeNodeRequiredProps();
        var expandable = activeItem.data.isLeaf === false || !!(activeItem.data[fieldNames.children] || []).length;
        var eventNode = convertNodePropsToEventData(_objectSpread2(_objectSpread2({}, getTreeNodeProps(activeKey, treeNodeRequiredProps)), {}, {
          data: activeItem.data,
          active: true
        }));
        switch (event.which) {
          case KeyCode.LEFT: {
            if (expandable && expandedKeys.includes(activeKey)) {
              _this.onNodeExpand({}, eventNode);
            } else if (activeItem.parent) {
              _this.onActiveChange(activeItem.parent.key);
            }
            event.preventDefault();
            break;
          }
          case KeyCode.RIGHT: {
            if (expandable && !expandedKeys.includes(activeKey)) {
              _this.onNodeExpand({}, eventNode);
            } else if (activeItem.children && activeItem.children.length) {
              _this.onActiveChange(activeItem.children[0].key);
            }
            event.preventDefault();
            break;
          }
          case KeyCode.ENTER:
          case KeyCode.SPACE: {
            if (checkable && !eventNode.disabled && eventNode.checkable !== false && !eventNode.disableCheckbox) {
              _this.onNodeCheck({}, eventNode, !checkedKeys.includes(activeKey));
            } else if (!checkable && selectable && !eventNode.disabled && eventNode.selectable !== false) {
              _this.onNodeSelect({}, eventNode);
            }
            break;
          }
        }
      }
      onKeyDown === null || onKeyDown === void 0 || onKeyDown(event);
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "setUncontrolledState", function(state) {
      var atomic = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var forceState = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (!_this.destroyed) {
        var needSync = false;
        var allPassed = true;
        var newState = {};
        Object.keys(state).forEach(function(name2) {
          if (name2 in _this.props) {
            allPassed = false;
            return;
          }
          needSync = true;
          newState[name2] = state[name2];
        });
        if (needSync && (!atomic || allPassed)) {
          _this.setState(_objectSpread2(_objectSpread2({}, newState), forceState));
        }
      }
    });
    _defineProperty$2(_assertThisInitialized$4(_this), "scrollTo", function(scroll) {
      _this.listRef.current.scrollTo(scroll);
    });
    return _this;
  }
  _createClass$5(Tree2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.destroyed = false;
      this.onUpdated();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.onUpdated();
    }
  }, {
    key: "onUpdated",
    value: function onUpdated() {
      var _this$props11 = this.props, activeKey = _this$props11.activeKey, _this$props11$itemScr = _this$props11.itemScrollOffset, itemScrollOffset = _this$props11$itemScr === void 0 ? 0 : _this$props11$itemScr;
      if (activeKey !== void 0 && activeKey !== this.state.activeKey) {
        this.setState({
          activeKey
        });
        if (activeKey !== null) {
          this.scrollTo({
            key: activeKey,
            offset: itemScrollOffset
          });
        }
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      window.removeEventListener("dragend", this.onWindowDragEnd);
      this.destroyed = true;
    }
  }, {
    key: "resetDragState",
    value: function resetDragState() {
      this.setState({
        dragOverNodeKey: null,
        dropPosition: null,
        dropLevelOffset: null,
        dropTargetKey: null,
        dropContainerKey: null,
        dropTargetPos: null,
        dropAllowed: false
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this$state14 = this.state, focused = _this$state14.focused, flattenNodes = _this$state14.flattenNodes, keyEntities = _this$state14.keyEntities, draggingNodeKey = _this$state14.draggingNodeKey, activeKey = _this$state14.activeKey, dropLevelOffset = _this$state14.dropLevelOffset, dropContainerKey = _this$state14.dropContainerKey, dropTargetKey = _this$state14.dropTargetKey, dropPosition = _this$state14.dropPosition, dragOverNodeKey = _this$state14.dragOverNodeKey, indent = _this$state14.indent;
      var _this$props12 = this.props, prefixCls = _this$props12.prefixCls, className = _this$props12.className, style2 = _this$props12.style, showLine = _this$props12.showLine, focusable = _this$props12.focusable, _this$props12$tabInde = _this$props12.tabIndex, tabIndex = _this$props12$tabInde === void 0 ? 0 : _this$props12$tabInde, selectable = _this$props12.selectable, showIcon = _this$props12.showIcon, icon = _this$props12.icon, switcherIcon = _this$props12.switcherIcon, draggable = _this$props12.draggable, checkable = _this$props12.checkable, checkStrictly = _this$props12.checkStrictly, disabled = _this$props12.disabled, motion = _this$props12.motion, loadData = _this$props12.loadData, filterTreeNode = _this$props12.filterTreeNode, height = _this$props12.height, itemHeight = _this$props12.itemHeight, virtual = _this$props12.virtual, titleRender = _this$props12.titleRender, dropIndicatorRender = _this$props12.dropIndicatorRender, onContextMenu = _this$props12.onContextMenu, onScroll = _this$props12.onScroll, direction = _this$props12.direction, rootClassName = _this$props12.rootClassName, rootStyle = _this$props12.rootStyle;
      var domProps = pickAttrs(this.props, {
        aria: true,
        data: true
      });
      var draggableConfig;
      if (draggable) {
        if (_typeof$6(draggable) === "object") {
          draggableConfig = draggable;
        } else if (typeof draggable === "function") {
          draggableConfig = {
            nodeDraggable: draggable
          };
        } else {
          draggableConfig = {};
        }
      }
      return /* @__PURE__ */ reactExports.createElement(TreeContext.Provider, {
        value: {
          prefixCls,
          selectable,
          showIcon,
          icon,
          switcherIcon,
          draggable: draggableConfig,
          draggingNodeKey,
          checkable,
          checkStrictly,
          disabled,
          keyEntities,
          dropLevelOffset,
          dropContainerKey,
          dropTargetKey,
          dropPosition,
          dragOverNodeKey,
          indent,
          direction,
          dropIndicatorRender,
          loadData,
          filterTreeNode,
          titleRender,
          onNodeClick: this.onNodeClick,
          onNodeDoubleClick: this.onNodeDoubleClick,
          onNodeExpand: this.onNodeExpand,
          onNodeSelect: this.onNodeSelect,
          onNodeCheck: this.onNodeCheck,
          onNodeLoad: this.onNodeLoad,
          onNodeMouseEnter: this.onNodeMouseEnter,
          onNodeMouseLeave: this.onNodeMouseLeave,
          onNodeContextMenu: this.onNodeContextMenu,
          onNodeDragStart: this.onNodeDragStart,
          onNodeDragEnter: this.onNodeDragEnter,
          onNodeDragOver: this.onNodeDragOver,
          onNodeDragLeave: this.onNodeDragLeave,
          onNodeDragEnd: this.onNodeDragEnd,
          onNodeDrop: this.onNodeDrop
        }
      }, /* @__PURE__ */ reactExports.createElement("div", {
        role: "tree",
        className: classNames(prefixCls, className, rootClassName, _defineProperty$2(_defineProperty$2(_defineProperty$2({}, "".concat(prefixCls, "-show-line"), showLine), "".concat(prefixCls, "-focused"), focused), "".concat(prefixCls, "-active-focused"), activeKey !== null)),
        style: rootStyle
      }, /* @__PURE__ */ reactExports.createElement(NodeList, _extends$4({
        ref: this.listRef,
        prefixCls,
        style: style2,
        data: flattenNodes,
        disabled,
        selectable,
        checkable: !!checkable,
        motion,
        dragging: draggingNodeKey !== null,
        height,
        itemHeight,
        virtual,
        focusable,
        focused,
        tabIndex,
        activeItem: this.getActiveItem(),
        onFocus: this.onFocus,
        onBlur: this.onBlur,
        onKeyDown: this.onKeyDown,
        onActiveChange: this.onActiveChange,
        onListChangeStart: this.onListChangeStart,
        onListChangeEnd: this.onListChangeEnd,
        onContextMenu,
        onScroll
      }, this.getTreeNodeRequiredProps(), domProps))));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, prevState) {
      var prevProps = prevState.prevProps;
      var newState = {
        prevProps: props
      };
      function needSync(name2) {
        return !prevProps && name2 in props || prevProps && prevProps[name2] !== props[name2];
      }
      var treeData;
      var fieldNames = prevState.fieldNames;
      if (needSync("fieldNames")) {
        fieldNames = fillFieldNames(props.fieldNames);
        newState.fieldNames = fieldNames;
      }
      if (needSync("treeData")) {
        treeData = props.treeData;
      } else if (needSync("children")) {
        warningOnce(false, "`children` of Tree is deprecated. Please use `treeData` instead.");
        treeData = convertTreeToData(props.children);
      }
      if (treeData) {
        newState.treeData = treeData;
        var entitiesMap = convertDataToEntities(treeData, {
          fieldNames
        });
        newState.keyEntities = _objectSpread2(_defineProperty$2({}, MOTION_KEY, MotionEntity), entitiesMap.keyEntities);
      }
      var keyEntities = newState.keyEntities || prevState.keyEntities;
      if (needSync("expandedKeys") || prevProps && needSync("autoExpandParent")) {
        newState.expandedKeys = props.autoExpandParent || !prevProps && props.defaultExpandParent ? conductExpandParent(props.expandedKeys, keyEntities) : props.expandedKeys;
      } else if (!prevProps && props.defaultExpandAll) {
        var cloneKeyEntities = _objectSpread2({}, keyEntities);
        delete cloneKeyEntities[MOTION_KEY];
        newState.expandedKeys = Object.keys(cloneKeyEntities).map(function(key) {
          return cloneKeyEntities[key].key;
        });
      } else if (!prevProps && props.defaultExpandedKeys) {
        newState.expandedKeys = props.autoExpandParent || props.defaultExpandParent ? conductExpandParent(props.defaultExpandedKeys, keyEntities) : props.defaultExpandedKeys;
      }
      if (!newState.expandedKeys) {
        delete newState.expandedKeys;
      }
      if (treeData || newState.expandedKeys) {
        var flattenNodes = flattenTreeData(treeData || prevState.treeData, newState.expandedKeys || prevState.expandedKeys, fieldNames);
        newState.flattenNodes = flattenNodes;
      }
      if (props.selectable) {
        if (needSync("selectedKeys")) {
          newState.selectedKeys = calcSelectedKeys(props.selectedKeys, props);
        } else if (!prevProps && props.defaultSelectedKeys) {
          newState.selectedKeys = calcSelectedKeys(props.defaultSelectedKeys, props);
        }
      }
      if (props.checkable) {
        var checkedKeyEntity;
        if (needSync("checkedKeys")) {
          checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {};
        } else if (!prevProps && props.defaultCheckedKeys) {
          checkedKeyEntity = parseCheckedKeys(props.defaultCheckedKeys) || {};
        } else if (treeData) {
          checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {
            checkedKeys: prevState.checkedKeys,
            halfCheckedKeys: prevState.halfCheckedKeys
          };
        }
        if (checkedKeyEntity) {
          var _checkedKeyEntity = checkedKeyEntity, _checkedKeyEntity$che = _checkedKeyEntity.checkedKeys, checkedKeys = _checkedKeyEntity$che === void 0 ? [] : _checkedKeyEntity$che, _checkedKeyEntity$hal = _checkedKeyEntity.halfCheckedKeys, halfCheckedKeys = _checkedKeyEntity$hal === void 0 ? [] : _checkedKeyEntity$hal;
          if (!props.checkStrictly) {
            var conductKeys = conductCheck(checkedKeys, true, keyEntities);
            checkedKeys = conductKeys.checkedKeys;
            halfCheckedKeys = conductKeys.halfCheckedKeys;
          }
          newState.checkedKeys = checkedKeys;
          newState.halfCheckedKeys = halfCheckedKeys;
        }
      }
      if (needSync("loadedKeys")) {
        newState.loadedKeys = props.loadedKeys;
      }
      return newState;
    }
  }]);
  return Tree2;
}(reactExports.Component);
_defineProperty$2(Tree, "defaultProps", {
  prefixCls: "rc-tree",
  showLine: false,
  showIcon: true,
  selectable: true,
  multiple: false,
  checkable: false,
  disabled: false,
  checkStrictly: false,
  draggable: false,
  defaultExpandParent: true,
  autoExpandParent: false,
  defaultExpandAll: false,
  defaultExpandedKeys: [],
  defaultCheckedKeys: [],
  defaultSelectedKeys: [],
  dropIndicatorRender: DropIndicator,
  allowDrop: function allowDrop() {
    return true;
  },
  expandAction: false
});
_defineProperty$2(Tree, "TreeNode", ContextTreeNode);
const index = "";
const TreeView = "";
const Treeview = ({ data: data2 }) => {
  const { Depth, Items, ImageListObj, ImageIndex, Visible, Event, CSS } = data2 == null ? void 0 : data2.Properties;
  const customStyles = parseFlexStyles(CSS);
  const [nodeData, setNodeData] = reactExports.useState([]);
  const { dataRef, socket, findDesiredData } = useAppData();
  const styles = setStyle$1(data2 == null ? void 0 : data2.Properties);
  const treeData = [];
  let childIndex = 0;
  const ID2 = getStringafterPeriod(ImageListObj);
  const ImageList = JSON.parse(getObjectById(dataRef.current, ID2));
  const eventEmit = (treeState, info) => {
    const { node } = info;
    if (treeState.length > nodeData.length) {
      treeState.filter((item) => !nodeData.includes(item));
      const expandEvent = JSON.stringify({
        Event: {
          EventName: "Expanding",
          ID: data2 == null ? void 0 : data2.ID,
          Info: node == null ? void 0 : node.id
        }
      });
      const exists = Event && Event.some(
        (item) => {
          var _a;
          return item[0] === "Expanding" && ((_a = node == null ? void 0 : node.children) == null ? void 0 : _a.length) > 0;
        }
      );
      if (!exists)
        return;
      console.log(expandEvent);
      socket.send(expandEvent);
    } else if (treeState.length < nodeData.length) {
      const missingPart = nodeData.filter((item) => !treeState.includes(item));
      findParentIndex(
        Depth,
        1 + calculateSumFromString(missingPart)
      );
      const retractEvent = JSON.stringify({
        Event: {
          EventName: "Retracting",
          ID: data2 == null ? void 0 : data2.ID,
          Info: node == null ? void 0 : node.id
        }
      });
      const exists = Event && Event.some((item) => item[0] === "Retracting");
      if (!exists)
        return;
      console.log(retractEvent);
      socket.send(retractEvent);
    } else {
      console.log("Equal");
    }
    setNodeData(treeState);
  };
  const createNode = (title2, index2) => {
    var _a;
    if (!index2)
      return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { onKeyDown: (e3) => console.log({ e: e3 }), children: title2 });
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "img",
        {
          src: `${getCurrentUrl()}${(_a = ImageList == null ? void 0 : ImageList.Properties) == null ? void 0 : _a.Files[index2 - 1]}`
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: title2 })
    ] });
  };
  for (let i16 = 0; i16 < Depth.length; i16++) {
    const depthValue = Depth[i16];
    const title2 = createNode(Items[i16], ImageIndex && ImageIndex[i16]);
    if (depthValue === 0) {
      childIndex++;
      treeData.push({
        id: childIndex,
        title: title2,
        children: []
      });
    } else if (depthValue >= 1) {
      childIndex++;
      const newNode = {
        id: childIndex,
        title: title2
      };
      let parent = treeData[treeData.length - 1];
      for (let j2 = 1; j2 < depthValue; j2++) {
        parent = parent.children[parent.children.length - 1];
      }
      if (!parent.children) {
        parent.children = [];
      }
      parent.children.push(newNode);
    }
  }
  const handleItemDownEvent = (index2, shiftState) => {
    const event = JSON.stringify({
      Event: {
        EventName: "ItemDown",
        ID: data2 == null ? void 0 : data2.ID,
        Info: [index2, 1, shiftState, 4]
      }
    });
    const SelItems = new Array(childIndex).fill(0);
    SelItems[index2 - 1] = 1;
    const storedFocusedIndex = JSON.stringify({
      Event: {
        SelItems
      }
    });
    localStorage.setItem(data2 == null ? void 0 : data2.ID, storedFocusedIndex);
    const exists = Event && Event.some((item) => item[0] === "ItemDown");
    if (!exists)
      return;
    console.log(event);
    socket.send(event);
  };
  const handleSelect = (_2, info) => {
    var _a;
    const { selectedNodes, nativeEvent } = info;
    const isAltPressed = nativeEvent.altKey ? 4 : 0;
    const isCtrlPressed = nativeEvent.ctrlKey ? 2 : 0;
    const isShiftPressed = nativeEvent.shiftKey ? 1 : 0;
    nativeEvent.button;
    let shiftState = isAltPressed + isCtrlPressed + isShiftPressed;
    if (selectedNodes.length == 0)
      return;
    handleItemDownEvent((_a = selectedNodes[0]) == null ? void 0 : _a.id, shiftState);
  };
  const handleDoubleClickEvent = (index2, shiftState) => {
    const event = JSON.stringify({
      Event: {
        EventName: "ItemDblClick",
        ID: data2 == null ? void 0 : data2.ID,
        Info: [index2, 1, shiftState, 4]
      }
    });
    const SelItems = new Array(childIndex).fill(0);
    SelItems[index2 - 1] = 1;
    const storedFocusedIndex = JSON.stringify({
      Event: {
        SelItems
      }
    });
    localStorage.setItem(data2 == null ? void 0 : data2.ID, storedFocusedIndex);
    const exists = Event && Event.some((item) => item[0] === "ItemDblClick");
    if (!exists)
      return;
    console.log(event);
    socket.send(event);
  };
  const handleDoubleClick = (_2, info) => {
    const { nativeEvent } = info;
    const isAltPressed = (nativeEvent == null ? void 0 : nativeEvent.altKey) ? 4 : 0;
    const isCtrlPressed = (nativeEvent == null ? void 0 : nativeEvent.ctrlKey) ? 2 : 0;
    const isShiftPressed = (nativeEvent == null ? void 0 : nativeEvent.shiftKey) ? 1 : 0;
    nativeEvent == null ? void 0 : nativeEvent.button;
    let shiftState = isAltPressed + isCtrlPressed + isShiftPressed;
    handleDoubleClickEvent(info.id, shiftState);
  };
  reactExports.useEffect(() => {
    localStorage.setItem(
      data2.ID,
      JSON.stringify({
        Event: {
          SelItems: new Array(Items.length).fill(0)
        }
      })
    );
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      id: data2 == null ? void 0 : data2.ID,
      style: {
        ...styles,
        border: "1px solid black",
        background: "white",
        paddingLeft: "2px",
        paddingTop: "3px",
        display: Visible == 0 ? "none" : "block",
        overflowY: "scroll",
        ...customStyles
      },
      onMouseDown: (e3) => {
        handleMouseDown(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseUp: (e3) => {
        handleMouseUp(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseEnter: (e3) => {
        handleMouseEnter(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseMove: (e3) => {
        handleMouseMove(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseLeave: (e3) => {
        handleMouseLeave(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onWheel: (e3) => {
        handleMouseWheel(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onDoubleClick: (e3) => {
        handleMouseDoubleClick(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Tree,
        {
          onDoubleClick: handleDoubleClick,
          onSelect: handleSelect,
          onKeyDown: (e3) => handleKeyPressUtils(e3, socket, Event, data2 == null ? void 0 : data2.ID),
          onExpand: eventEmit,
          expandAction: "click",
          treeData,
          showIcon: false,
          showLine: true,
          style: { fontSize: "12px", lineHeight: "15px", margin: 0, padding: 0 }
        }
      )
    }
  );
};
const List = ({ data: data2 }) => {
  const { socket } = useAppData();
  const styles = setStyle$1(data2 == null ? void 0 : data2.Properties);
  const { Items, SelItems, Visible, Size: Size2, Event, CSS } = data2 == null ? void 0 : data2.Properties;
  const customStyles = parseFlexStyles(CSS);
  const ref2 = reactExports.useRef();
  const [selectedItem, _2] = reactExports.useState(1);
  const [items, setItems] = reactExports.useState(SelItems);
  const dimensions = useResizeObserver(
    document.getElementById(extractStringUntilLastPeriod(data2 == null ? void 0 : data2.ID))
  );
  const [width, setWidth] = reactExports.useState(Size2[1]);
  reactExports.useEffect(() => {
    setWidth((dimensions == null ? void 0 : dimensions.width) - 50);
  }, [dimensions]);
  const selectedStyles = {
    background: "#1264FF",
    color: "white",
    cursor: "pointer"
  };
  const handleClick = (index2) => {
    const length = SelItems.length;
    let updatedArray = Array(length).fill(0);
    updatedArray[index2] = 1;
    localStorage.setItem(
      data2 == null ? void 0 : data2.ID,
      JSON.stringify({
        Event: {
          ID: data2 == null ? void 0 : data2.ID,
          SelItems: updatedArray
        }
      })
    );
    setItems(updatedArray);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      ref: ref2,
      style: {
        ...styles,
        width,
        border: "1px solid black",
        display: Visible == 0 ? "none" : "block"
      },
      onMouseDown: (e3) => {
        handleMouseDown(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseUp: (e3) => {
        handleMouseUp(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseEnter: (e3) => {
        handleMouseEnter(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseMove: (e3) => {
        handleMouseMove(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseLeave: (e3) => {
        handleMouseLeave(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onWheel: (e3) => {
        handleMouseWheel(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onDoubleClick: (e3) => {
        handleMouseDoubleClick(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onKeyDown: (e3) => {
        handleKeyPressUtils(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      children: Items && Items.map(
        (item, index2) => selectedItem == items[index2] ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            style: {
              ...selectedStyles,
              fontSize: "12px",
              height: "14px",
              display: "flex",
              alignItems: "center",
              padding: "1px",
              ...customStyles
            },
            children: item
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            onClick: () => handleClick(index2),
            style: {
              cursor: "pointer",
              fontSize: "12px",
              height: "14px",
              padding: "1px",
              display: "flex",
              alignItems: "center",
              ...customStyles
            },
            children: item
          }
        )
      )
    }
  );
};
const VerticalSplitter = ({ data: data2 }) => {
  const { Size: SubformSize } = JSON.parse(
    localStorage.getItem(extractStringUntilLastPeriod(data2 == null ? void 0 : data2.ID))
  );
  const { Posn, SplitObj1, SplitObj2, Event, CSS } = data2 == null ? void 0 : data2.Properties;
  const customStyles = parseFlexStyles(CSS);
  const [position2, setPosition] = reactExports.useState({ left: Posn && Posn[1] });
  const [isResizing, setResizing] = reactExports.useState(false);
  const { handleData, reRender, socket } = useAppData();
  const dimensions = useResizeObserver(
    document.getElementById(extractStringUntilLastPeriod(data2 == null ? void 0 : data2.ID))
  );
  const [oldFormValues, setoldFormValues] = reactExports.useState(SubformSize && SubformSize);
  reactExports.useEffect(() => {
    if (!position2)
      return;
    if (!oldFormValues)
      return;
    let calculateLeft = position2 && position2.left && oldFormValues && oldFormValues[1] ? position2.left / oldFormValues[1] * dimensions.width : 0;
    calculateLeft = Math.max(0, Math.min(calculateLeft, dimensions.width - 3));
    setPosition({ left: calculateLeft });
    const rightWidth = dimensions.width - (calculateLeft + 3);
    handleData(
      {
        ID: SplitObj1,
        Properties: {
          Posn: [0, 0],
          Size: [dimensions.height, Math.round(calculateLeft)],
          BCol: [255, 255, 255]
        }
      },
      "WS"
    );
    handleData(
      {
        ID: SplitObj2,
        Properties: {
          Posn: [0, Math.round(calculateLeft + 3)],
          Size: [dimensions == null ? void 0 : dimensions.height, Math.round(rightWidth)],
          BCol: [255, 255, 255]
        }
      },
      "WS"
    );
    localStorage.setItem(
      data2 == null ? void 0 : data2.ID,
      JSON.stringify({
        Event: {
          EventName: emitEvent && emitEvent[0],
          ID: data2.ID,
          Info: [0, Math.round(calculateLeft)],
          Size: [formHeight, 3]
        }
      })
    );
    setoldFormValues([dimensions == null ? void 0 : dimensions.height, dimensions == null ? void 0 : dimensions.width]);
    reRender();
  }, [dimensions]);
  let formWidth = dimensions.width;
  let formHeight = dimensions.height;
  const emitEvent = Event && Event[0];
  let verticalStyles = {
    width: "3px",
    height: "100%",
    backgroundColor: "#F0F0F0",
    cursor: "col-resize",
    position: "absolute",
    top: Posn && Posn[0],
    left: position2 == null ? void 0 : position2.left,
    ...customStyles
  };
  reactExports.useEffect(() => {
    const handleMouseMove2 = (e3) => {
      if (isResizing) {
        const formPositions = JSON.parse(localStorage.getItem("formPositions"));
        let newLeft = e3.clientX - formPositions[1];
        newLeft = Math.max(0, Math.min(newLeft, formWidth - 3));
        const rightWidth = formWidth - (newLeft + 3);
        localStorage.setItem(
          SplitObj1,
          JSON.stringify({ Posn: [0, 0], Size: [formHeight, newLeft] })
        );
        localStorage.setItem(
          SplitObj2,
          JSON.stringify({ Posn: [0, newLeft + 3], Size: [formHeight, rightWidth] })
        );
        handleData(
          {
            ID: SplitObj1,
            Properties: {
              Posn: [0, 0],
              Size: [formHeight, newLeft],
              BCol: [255, 255, 255]
            }
          },
          "WS"
        );
        handleData(
          {
            ID: SplitObj2,
            Properties: {
              Posn: [0, newLeft + 3],
              Size: [formHeight, rightWidth],
              BCol: [255, 255, 255]
            }
          },
          "WS"
        );
        localStorage.setItem(
          data2 == null ? void 0 : data2.ID,
          JSON.stringify({
            Event: {
              EventName: emitEvent && emitEvent[0],
              ID: data2.ID,
              Info: [0, newLeft],
              Size: [formHeight, 3]
            }
          })
        );
        setPosition({ left: newLeft });
        reRender();
      }
    };
    const handleMouseUp2 = () => {
      if (isResizing) {
        setResizing(false);
        const { Event: customEvent } = JSON.parse(localStorage.getItem(data2 == null ? void 0 : data2.ID));
        const { Size: Size2, ...event } = customEvent;
        const exists = Event && (Event == null ? void 0 : Event.some((item) => item[0] === "EndSplit"));
        if (!exists)
          return;
        console.log(JSON.stringify({ Event: { ...event } }));
        socket.send(JSON.stringify({ Event: { ...event } }));
      }
    };
    document.addEventListener("mousemove", handleMouseMove2);
    document.addEventListener("mouseup", handleMouseUp2);
    return () => {
      document.removeEventListener("mousemove", handleMouseMove2);
      document.removeEventListener("mouseup", handleMouseUp2);
    };
  }, [isResizing]);
  const handleMouseDown2 = (e3) => {
    e3.preventDefault();
    setResizing(true);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      id: data2 == null ? void 0 : data2.ID,
      onClick: (e3) => e3.preventDefault(),
      onMouseDown: handleMouseDown2,
      style: verticalStyles
    }
  );
};
const HorizontalSplitter = ({ data: data2 }) => {
  const { Size: SubformSize, Posn: SubFormPosn } = JSON.parse(
    localStorage.getItem(extractStringUntilLastPeriod(data2 == null ? void 0 : data2.ID))
  );
  const { Posn, SplitObj1, SplitObj2, Event, Size: Size2, CSS } = data2 == null ? void 0 : data2.Properties;
  const customStyles = parseFlexStyles(CSS);
  const [position2, setPosition] = reactExports.useState({ top: Posn && Posn[0] });
  const [isResizing, setResizing] = reactExports.useState(false);
  const { handleData, reRender, socket } = useAppData();
  const dimensions = useResizeObserver(
    document.getElementById(extractStringUntilLastPeriod(data2 == null ? void 0 : data2.ID))
  );
  const [oldFormValues, setoldFormValues] = reactExports.useState(SubformSize && SubformSize);
  const [oldHeight, setOldHeight] = reactExports.useState(Size2 && Size2[0]);
  reactExports.useEffect(() => {
    if (!position2)
      return;
    if (!oldFormValues)
      return;
    if (oldHeight == dimensions.height) {
      const obj1 = JSON.parse(localStorage.getItem(SplitObj1));
      const obj2 = JSON.parse(localStorage.getItem(SplitObj2));
      if (!obj1 && !obj2)
        return;
      const { Size: Size1, Posn: Posn1 } = obj1;
      const { Size: Size22, Posn: Posn2 } = obj2;
      localStorage.setItem(
        SplitObj1,
        JSON.stringify({
          Size: [Math.round(Size1 && Size1[0]), dimensions.width],
          Posn: Posn1
        })
      );
      localStorage.setItem(
        SplitObj2,
        JSON.stringify({
          Size: [Math.round(Size22 && Size22[0]), dimensions.width],
          Posn: Posn2
        })
      );
      handleData(
        {
          ID: SplitObj1,
          Properties: {
            Posn: Posn1,
            Size: [Math.round(Size1 && Size1[0]), dimensions.width]
          }
        },
        "WS"
      );
      handleData(
        {
          ID: SplitObj2,
          Properties: {
            Posn: Posn2,
            Size: [Math.round(Size22 && Size22[0]), dimensions.width]
          }
        },
        "WS"
      );
    } else {
      let calculateTop = position2 && position2.top && oldFormValues && oldFormValues[0] ? position2.top / oldFormValues[0] * dimensions.height : 0;
      calculateTop = Math.max(0, Math.min(calculateTop, dimensions.height - 3));
      setPosition({ top: Math.round(calculateTop) });
      handleData(
        {
          ID: SplitObj1,
          Properties: {
            Posn: [0, 0],
            Size: [Math.round(calculateTop), dimensions.width]
          }
        },
        "WS"
      );
      handleData(
        {
          ID: SplitObj2,
          Properties: {
            Posn: [Math.round(calculateTop + 3), 0],
            Size: [Math.round((dimensions == null ? void 0 : dimensions.height) - (calculateTop + 3)), dimensions.width]
          }
        },
        "WS"
      );
    }
    setOldHeight(dimensions.height);
    setoldFormValues([dimensions == null ? void 0 : dimensions.height, dimensions == null ? void 0 : dimensions.width]);
    reRender();
  }, [dimensions]);
  let formHeight = dimensions.height;
  const emitEvent = Event && Event[0];
  reactExports.useEffect(() => {
    const handleMouseMove2 = (e3) => {
      if (isResizing) {
        const formPositions = JSON.parse(localStorage.getItem("formPositions"));
        let newTop = e3.clientY - formPositions[1];
        const parentSize = JSON.parse(
          localStorage.getItem(extractStringUntilLastPeriod(data2 == null ? void 0 : data2.ID))
        );
        const { Size: Size22 } = parentSize;
        newTop = Math.max(0, Math.min(newTop, formHeight));
        handleData(
          {
            ID: SplitObj1,
            Properties: {
              Posn: [0, 0],
              Size: [newTop, Size22[1]]
            }
          },
          "WS"
        );
        handleData(
          {
            ID: SplitObj2,
            Properties: {
              Posn: [newTop + 3, 0],
              Size: [formHeight - (newTop + 3), Size22[1]]
            }
          },
          "WS"
        );
        localStorage.setItem(
          data2 == null ? void 0 : data2.ID,
          JSON.stringify({
            Event: {
              EventName: emitEvent && emitEvent[0],
              ID: data2.ID,
              Info: [newTop, 0],
              Size: [3, formHeight]
            }
          })
        );
        setPosition({ top: newTop });
        reRender();
      }
    };
    const handleMouseUp2 = () => {
      if (isResizing) {
        setResizing(false);
        const { Event: customEvent } = JSON.parse(localStorage.getItem(data2 == null ? void 0 : data2.ID));
        const { Size: Size22, ...event } = customEvent;
        const exists = Event && (Event == null ? void 0 : Event.some((item) => item[0] === "EndSplit"));
        if (!exists)
          return;
        console.log(JSON.stringify({ Event: { ...event } }));
        socket.send(JSON.stringify({ Event: { ...event } }));
      }
    };
    document.addEventListener("mousemove", handleMouseMove2);
    document.addEventListener("mouseup", handleMouseUp2);
    return () => {
      document.removeEventListener("mousemove", handleMouseMove2);
      document.removeEventListener("mouseup", handleMouseUp2);
    };
  }, [isResizing]);
  const handleMouseDown2 = (e3) => {
    e3.preventDefault();
    setResizing(true);
  };
  let horizontalStyles = {
    width: "100%",
    height: "3px",
    backgroundColor: "#F0F0F0",
    cursor: "row-resize",
    position: "absolute",
    top: position2 == null ? void 0 : position2.top,
    left: 0,
    ...customStyles
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { id: data2 == null ? void 0 : data2.ID, style: horizontalStyles, onMouseDown: (e3) => handleMouseDown2(e3) });
};
const Splitter = ({ data: data2 }) => {
  const { Style, Posn, SplitObj1, SplitObj2, Event } = data2 == null ? void 0 : data2.Properties;
  const { handleData } = useAppData();
  let formWidth = 800;
  let formHeight = 800;
  const emitEvent = Event && Event[0];
  const initializeSplitterDimensions = () => {
    if (Style && Style == "Horz") {
      const localStorageKeys = Object.keys(localStorage);
      localStorageKeys.forEach((key) => {
        const IDs = key.split(".");
        if (IDs.length == 2 && IDs.includes("RIGHT")) {
          const rightPaneDimensions = JSON.parse(localStorage.getItem(key));
          const { Size: Size2 } = rightPaneDimensions;
          localStorage.setItem(
            data2 == null ? void 0 : data2.ID,
            JSON.stringify({
              Event: {
                EventName: emitEvent && emitEvent[0],
                ID: data2.ID,
                Info: Posn,
                Size: [3, Size2[1]]
              }
            })
          );
          localStorage.setItem(
            SplitObj1,
            JSON.stringify({ Size: [Posn[0], Size2[1]], Posn: [0, 0] })
          );
          handleData(
            {
              ID: SplitObj1,
              Properties: {
                Posn: [0, 0],
                Size: [Posn[0], Size2[1]],
                BCol: [255, 255, 255]
              }
            },
            "WS"
          );
          localStorage.setItem(
            SplitObj2,
            JSON.stringify({
              Size: [formHeight - (Posn[0] + 3), Size2[1]],
              Posn: [Posn[0] + 3, 0]
            })
          );
          handleData(
            {
              ID: SplitObj2,
              Properties: {
                Posn: [Posn[0] + 3, 0],
                Size: [formHeight - (Posn[0] + 3), Size2[1]],
                BCol: [255, 255, 255]
              }
            },
            "WS"
          );
        }
      });
    } else {
      localStorage.setItem(
        data2 == null ? void 0 : data2.ID,
        JSON.stringify({
          Event: {
            EventName: emitEvent && emitEvent[0],
            ID: data2.ID,
            Info: Posn,
            Size: [formHeight, 3]
          }
        })
      );
      localStorage.setItem(
        SplitObj1,
        JSON.stringify({ Size: [formHeight, Posn[1]], Posn: [0, Posn[1]] })
      );
      localStorage.setItem(
        SplitObj2,
        JSON.stringify({
          Size: [formHeight, formWidth - (Posn[1] + 3)],
          Posn: [0, Posn[1] + 3]
        })
      );
      handleData(
        {
          ID: SplitObj1,
          Properties: {
            BCol: [255, 255, 255]
          }
        },
        "WS"
      );
      handleData(
        {
          ID: SplitObj2,
          Properties: {
            BCol: [255, 255, 255]
          }
        },
        "WS"
      );
    }
  };
  reactExports.useEffect(() => {
    initializeSplitterDimensions();
  }, []);
  if (Style && Style == "Horz") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(HorizontalSplitter, { data: data2 });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(VerticalSplitter, { data: data2 });
};
const Group$a = ({ data: data2 }) => {
  var _a, _b;
  const {
    Visible,
    Picture,
    Border = 1,
    Size: Size2,
    Flex = 0,
    CSS,
    Event
  } = data2 == null ? void 0 : data2.Properties;
  const { findDesiredData, socket } = useAppData();
  const dimensions = useResizeObserver(
    document.getElementById(extractStringUntilLastPeriod(data2 == null ? void 0 : data2.ID))
  );
  const [width, setWidth] = reactExports.useState(Size2[1]);
  const [height, setHeight] = reactExports.useState(Size2[0]);
  reactExports.useEffect(() => {
    if (!Size2.length) {
      setWidth((dimensions == null ? void 0 : dimensions.width) - 47);
      setHeight((dimensions == null ? void 0 : dimensions.height) - 47);
    }
  }, [dimensions]);
  const ImageData = findDesiredData(Picture && Picture[0]);
  const imageStyles = getImageStyles(Picture && Picture[1], ImageData);
  const flexStyles = parseFlexStyles(CSS);
  const updatedData = excludeKeys(data2);
  const styles = setStyle$1(data2 == null ? void 0 : data2.Properties, "absolute", Flex);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      style: {
        ...styles,
        width,
        height,
        border: Border == 0 ? "none" : "1px solid #E9E9E9",
        display: Visible == 0 ? "none" : "block",
        ...imageStyles,
        ...flexStyles
      },
      id: data2 == null ? void 0 : data2.ID,
      onMouseDown: (e3) => {
        handleMouseDown(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseUp: (e3) => {
        handleMouseUp(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseEnter: (e3) => {
        handleMouseEnter(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseMove: (e3) => {
        handleMouseMove(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseLeave: (e3) => {
        handleMouseLeave(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onWheel: (e3) => {
        handleMouseWheel(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onDoubleClick: (e3) => {
        handleMouseDoubleClick(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onKeyDown: (e3) => {
        handleKeyPressUtils(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      children: [
        ((_a = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _a.Caption) != "" && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "span",
          {
            style: {
              fontSize: "12px",
              // fontSize: '10px',
              position: "relative",
              bottom: 14,
              left: 10,
              background: "#F1F1F1 "
            },
            children: (_b = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _b.Caption
          }
        ),
        Object.keys(updatedData).map((key) => /* @__PURE__ */ jsxRuntimeExports.jsx(SelectComponent, { data: updatedData[key] }))
      ]
    }
  );
};
var DefaultContext = {
  color: void 0,
  size: void 0,
  className: void 0,
  style: void 0,
  attr: void 0
};
var IconContext = t$q.createContext && t$q.createContext(DefaultContext);
var __assign = globalThis && globalThis.__assign || function() {
  __assign = Object.assign || function(t6) {
    for (var s10, i16 = 1, n10 = arguments.length; i16 < n10; i16++) {
      s10 = arguments[i16];
      for (var p6 in s10)
        if (Object.prototype.hasOwnProperty.call(s10, p6))
          t6[p6] = s10[p6];
    }
    return t6;
  };
  return __assign.apply(this, arguments);
};
var __rest = globalThis && globalThis.__rest || function(s10, e3) {
  var t6 = {};
  for (var p6 in s10)
    if (Object.prototype.hasOwnProperty.call(s10, p6) && e3.indexOf(p6) < 0)
      t6[p6] = s10[p6];
  if (s10 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i16 = 0, p6 = Object.getOwnPropertySymbols(s10); i16 < p6.length; i16++) {
      if (e3.indexOf(p6[i16]) < 0 && Object.prototype.propertyIsEnumerable.call(s10, p6[i16]))
        t6[p6[i16]] = s10[p6[i16]];
    }
  return t6;
};
function Tree2Element(tree) {
  return tree && tree.map(function(node, i16) {
    return t$q.createElement(node.tag, __assign({
      key: i16
    }, node.attr), Tree2Element(node.child));
  });
}
function GenIcon(data2) {
  return function(props) {
    return t$q.createElement(IconBase, __assign({
      attr: __assign({}, data2.attr)
    }, props), Tree2Element(data2.child));
  };
}
function IconBase(props) {
  var elem = function(conf) {
    var attr = props.attr, size = props.size, title2 = props.title, svgProps = __rest(props, ["attr", "size", "title"]);
    var computedSize = size || conf.size || "1em";
    var className;
    if (conf.className)
      className = conf.className;
    if (props.className)
      className = (className ? className + " " : "") + props.className;
    return t$q.createElement("svg", __assign({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, conf.attr, attr, svgProps, {
      className,
      style: __assign(__assign({
        color: props.color || conf.color
      }, conf.style), props.style),
      height: computedSize,
      width: computedSize,
      xmlns: "http://www.w3.org/2000/svg"
    }), title2 && t$q.createElement("title", null, title2), props.children);
  };
  return IconContext !== void 0 ? t$q.createElement(IconContext.Consumer, null, function(conf) {
    return elem(conf);
  }) : elem(DefaultContext);
}
const ScrollBar$2 = "";
const ScrollBar$1 = ({ data: data2 }) => {
  const {
    Align,
    Type,
    Thumb,
    Range,
    Event,
    Visible,
    Size: Size2,
    Posn,
    VScroll,
    HScroll,
    Attach,
    CSS
  } = data2 == null ? void 0 : data2.Properties;
  const customStyles = parseFlexStyles(CSS);
  const isHorizontal = Type === "Scroll" && (Align === "Bottom" || HScroll === -1);
  const [scaledValue, setScaledValue] = reactExports.useState(Thumb || 1);
  const parentSize = JSON.parse(localStorage.getItem("formDimension"));
  const [showButtons, setShowButtons] = reactExports.useState(false);
  const emitEvent = Event && Event[0];
  const { socket, handleData } = useAppData();
  const trackRef = reactExports.useRef(null);
  const thumbRef = reactExports.useRef(null);
  const maxValue = Range;
  const trackHeight = !Size2 ? parentSize && parentSize[0] : Size2 && Size2[0];
  const trackWidth = !Size2 ? parentSize && parentSize[1] : Size2 && Size2[1];
  const handleTrackMouseEnter = (e22) => {
    setShowButtons(true);
    handleMouseEnter(e22, socket, Event, data2 == null ? void 0 : data2.ID);
  };
  const handleTrackMouseLeave = (e22) => {
    setShowButtons(false);
    handleMouseLeave(e22, socket, Event, data2 == null ? void 0 : data2.ID);
  };
  const handleThumbDrag = (event) => {
    event.preventDefault();
    event.stopPropagation();
    const startPosition = isHorizontal ? event.clientX : event.clientY;
    const thumbStyleProp = isHorizontal ? "left" : "top";
    const initialThumbPosition = thumbRef.current ? parseFloat(thumbRef.current.style[thumbStyleProp]) || 0 : 0;
    let newThumbPosition = initialThumbPosition;
    const maxThumbPosition = isHorizontal ? trackWidth - 50 : trackHeight - 100;
    const handleMouseMoveEvent = (moveEvent) => {
      const currentPosition = isHorizontal ? moveEvent.clientX : moveEvent.clientY;
      const delta = currentPosition - startPosition;
      newThumbPosition = initialThumbPosition + delta;
      newThumbPosition = Math.max(
        0,
        Math.min(maxThumbPosition, newThumbPosition)
      );
      const newScaledValue = newThumbPosition / maxThumbPosition * maxValue;
      if (thumbRef.current) {
        thumbRef.current.style[thumbStyleProp] = `${newThumbPosition}px`;
      }
      requestAnimationFrame(() => {
        setScaledValue(newScaledValue);
      });
    };
    const handleMouseUpEvent = () => {
      window.removeEventListener("mousemove", handleMouseMoveEvent);
      window.removeEventListener("mouseup", handleMouseUpEvent);
      const finalScaledValue = newThumbPosition / maxThumbPosition * maxValue;
      const roundedScaledValue = Math.round(finalScaledValue) || 1;
      handleData(
        { ID: data2 == null ? void 0 : data2.ID, Properties: { Thumb: roundedScaledValue } },
        "WS"
      );
      const scrollEvent = JSON.stringify({
        Event: {
          EventName: "Scroll",
          ID: data2 == null ? void 0 : data2.ID,
          Info: [0, roundedScaledValue]
        }
      });
      console.log("Final Scroll Event:", scrollEvent);
      localStorage.setItem(data2.ID, scrollEvent);
      const exists = Event && Event.some((item) => item[0] === "Scroll");
      if (exists) {
        socket.send(scrollEvent);
      }
    };
    window.addEventListener("mousemove", handleMouseMoveEvent);
    window.addEventListener("mouseup", handleMouseUpEvent);
  };
  const handleTrackClick = (event) => {
    if (thumbRef.current && (event.target === thumbRef.current || thumbRef.current.contains(event.target))) {
      return;
    }
    if (thumbRef.current && trackRef.current) {
      const trackRect = trackRef.current.getBoundingClientRect();
      const clickPosition = isHorizontal ? event.clientX - trackRect.left : event.clientY - trackRect.top;
      const maxThumbPosition = isHorizontal ? trackWidth - 50 : trackHeight - 100;
      const newThumbPosition = Math.max(
        0,
        Math.min(maxThumbPosition, clickPosition - 20)
        // Adjust for thumb size
      );
      const newScaledValue = newThumbPosition / maxThumbPosition * maxValue;
      if (newScaledValue >= 1 && newScaledValue <= maxValue) {
        setScaledValue(newScaledValue);
        if (thumbRef.current) {
          thumbRef.current.style[isHorizontal ? "left" : "top"] = `${newThumbPosition}px`;
        }
        const scrollEvent = JSON.stringify({
          Event: {
            EventName: emitEvent && emitEvent[0],
            ID: data2 == null ? void 0 : data2.ID,
            Info: [
              Math.round(scaledValue) < Math.round(newScaledValue) ? 2 : -2,
              Math.round(newScaledValue)
            ]
          }
        });
        console.log("Event", scrollEvent);
        localStorage.setItem(data2.ID, scrollEvent);
        handleData(
          {
            ID: data2 == null ? void 0 : data2.ID,
            Properties: { Thumb: Math.round(newScaledValue) || 1 }
          },
          "WS"
        );
        const exists = Event && Event.some((item) => item[0] === "Scroll");
        if (exists) {
          socket.send(scrollEvent);
        }
      }
    }
  };
  const defaultPosn = Posn || [0, 0];
  const defaultSize = Size2 || [parentSize[0], parentSize[1]];
  const calculateAttachStyle = () => {
    let attachStyle2 = {};
    if (Attach) {
      const [topAttach, leftAttach, bottomAttach, rightAttach] = Attach;
      if (topAttach === "Top" || topAttach === "Bottom") {
        attachStyle2.top = `${defaultPosn[0]}px`;
      }
      if (leftAttach === "Left" || leftAttach === "Right") {
        attachStyle2.left = `${defaultPosn[1]}px`;
      }
      if (bottomAttach === "Bottom" || bottomAttach === "Top") {
        attachStyle2.bottom = `${defaultPosn[0]}px`;
      }
      if (rightAttach === "Right" || rightAttach === "Left") {
        attachStyle2.right = `${defaultPosn[1]}px`;
      }
    }
    return attachStyle2;
  };
  const attachStyle = calculateAttachStyle();
  const trackStyle = {
    width: isHorizontal ? `${trackWidth}px` : defaultSize[1] + "px",
    height: isHorizontal ? defaultSize[0] + "px" : `${trackHeight}px`,
    position: "relative"
  };
  const thumbPosition = scaledValue / maxValue * (isHorizontal ? trackWidth - 50 : trackHeight - 100);
  const thumbStyle = {
    width: isHorizontal ? "40px" : defaultSize[1] - 6 + "px",
    height: isHorizontal ? defaultSize[0] - 6 + "px" : "40px",
    backgroundColor: "#9E9E9E",
    position: "absolute",
    left: isHorizontal ? `${thumbPosition}px` : "2px",
    top: isHorizontal ? "2px" : `${thumbPosition}px`,
    cursor: "pointer",
    borderRadius: "5px"
  };
  const verticalPosition = {
    position: "absolute",
    top: VScroll === -1 && defaultPosn[0] !== void 0 ? defaultPosn[0] : 0,
    ...VScroll === -1 ? {
      left: VScroll === -1 && defaultPosn[1] !== void 0 ? defaultPosn[1] : 0
    } : { right: 0 },
    display: Visible == 0 ? "none" : "block",
    ...attachStyle,
    ...customStyles
  };
  const horizontalPosition = {
    position: "absolute",
    ...HScroll === -1 ? {
      top: HScroll === -1 && defaultPosn[0] !== void 0 ? defaultPosn[0] : 0
    } : { bottom: 0 },
    left: HScroll === -1 && defaultPosn[1] !== void 0 ? defaultPosn[1] : 0,
    width: defaultSize[1] + "px",
    height: defaultSize[0],
    display: Visible == 0 ? "none" : "block",
    ...attachStyle,
    ...customStyles
  };
  reactExports.useEffect(() => {
    setScaledValue((prevValue) => Math.min(Thumb, maxValue));
  }, [Thumb]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      id: data2 == null ? void 0 : data2.ID,
      onMouseEnter: handleTrackMouseEnter,
      onMouseLeave: handleTrackMouseLeave,
      onWheel: (e22) => {
        handleMouseWheel(e22, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      style: isHorizontal ? horizontalPosition : verticalPosition,
      onMouseDown: (e22) => {
        handleMouseDown(e22, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseUp: (e22) => {
        handleMouseUp(e22, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseMove: (e22) => {
        handleMouseMove(e22, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onDoubleClick: (e22) => {
        handleMouseDoubleClick(e22, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: `scroll-bar ${isHorizontal ? "horizontal" : "vertical"}`,
          style: { ...trackStyle },
          onMouseDown: handleTrackClick,
          ref: trackRef,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: "thumb",
              style: { ...thumbStyle },
              ref: thumbRef,
              onMouseDown: handleThumbDrag,
              onKeyDown: () => {
                handleKeyPressUtils(e, socket, Event, data2 == null ? void 0 : data2.ID);
              }
            }
          )
        }
      ) })
    }
  );
};
const SubForm = ({ data: data2 }) => {
  const { findDesiredData, socket } = useAppData();
  const {
    Size: Size2,
    Posn,
    Picture,
    Visible,
    BCol,
    FlexDirection,
    JustifyContent,
    Display,
    Flex = 0,
    CSS,
    Event
  } = data2 == null ? void 0 : data2.Properties;
  const observedDiv = reactExports.useRef(null);
  const styles = setStyle$1(data2 == null ? void 0 : data2.Properties, "absolute", Flex);
  const flexStyles = parseFlexStyles(CSS);
  const updatedData = excludeKeys(data2);
  const ImageData = findDesiredData(Picture && Picture[0]);
  const imageStyles = getImageStyles(
    Picture && Picture[1],
    ImageData,
    data2 == null ? void 0 : data2.Properties
  );
  let updatedStyles = { ...styles, ...imageStyles, ...flexStyles };
  console.log("App Subform", {
    styles,
    data: data2,
    updatedStyles,
    flexStyles,
    Size: Size2,
    Posn
  });
  reactExports.useEffect(() => {
    let existingData;
    if (data2.ID === "F1.SCALE") {
      setTimeout(() => {
        var _a, _b, _c, _d, _e2;
        existingData = JSON.parse(localStorage.getItem(data2.ID));
        if (existingData && ((_a = existingData.Event) == null ? void 0 : _a.ID) === data2.ID) {
          existingData.Event = {
            ...existingData.Event,
            Size: ((_b = data2.Properties) == null ? void 0 : _b.Size) || ((_c = existingData.Event) == null ? void 0 : _c.Size),
            Posn: ((_d = data2.Properties) == null ? void 0 : _d.Posn) || ((_e2 = existingData.Event) == null ? void 0 : _e2.Posn)
          };
        }
      }, 500);
    } else if (data2.ID === "F1.BX") {
      localStorage.setItem(
        data2.ID,
        JSON.stringify({
          Size: Size2 || [600, 400],
          // Default size if none provided
          Posn: Posn || [50, 50]
          // Default position if none provided
        })
      );
    } else {
      localStorage.setItem(
        data2.ID,
        JSON.stringify({
          Size: Size2 && Size2,
          Posn: Posn && Posn
        })
      );
    }
  }, [data2]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      id: data2.ID,
      style: {
        display: Visible == 0 ? "none" : (data2 == null ? void 0 : data2.Properties.hasOwnProperty("Flex")) ? "flex" : "block",
        background: BCol && rgbColor(BCol),
        ...updatedStyles
        // height: Size && Size[0],
        // width: Size && Size[1],
        // top: Posn && Posn[0],
        // left: Posn && Posn[1],
        // position: 'absolute',
      },
      ref: observedDiv,
      onMouseDown: (e3) => {
        handleMouseDown(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseUp: (e3) => {
        handleMouseUp(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseEnter: (e3) => {
        handleMouseEnter(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseMove: (e3) => {
        handleMouseMove(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseLeave: (e3) => {
        handleMouseLeave(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onWheel: (e3) => {
        handleMouseWheel(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onDoubleClick: (e3) => {
        handleMouseDoubleClick(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onKeyDown: (e3) => {
        handleKeyPressUtils(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      children: Object.keys(updatedData).map((key) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectComponent, { data: updatedData[key] });
      })
    }
  );
};
const TabButton = ({ data: data2, handleTabClick, activeTab, bgColor, fontColor, activebgColor }) => {
  const { socket } = useAppData();
  const { Caption, Event, CSS } = data2 == null ? void 0 : data2.Properties;
  const emitEvent = Event && Event[0];
  const customStyles = parseFlexStyles(CSS);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      id: data2.ID,
      onMouseDown: (e3) => {
        handleMouseDown(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseUp: (e3) => {
        handleMouseUp(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseEnter: (e3) => {
        handleMouseEnter(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseMove: (e3) => {
        handleMouseMove(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseLeave: (e3) => {
        handleMouseLeave(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onWheel: (e3) => {
        handleMouseWheel(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onDoubleClick: (e3) => {
        handleMouseDoubleClick(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      style: {
        border: "1px solid #DFDFDF",
        fontSize: "12px",
        // fontSize: '11px',
        paddingTop: "2px",
        paddingBottom: "2px",
        paddingLeft: "4px",
        paddingRight: "4px",
        cursor: "pointer",
        borderRadius: "2px",
        background: activeTab == (data2 == null ? void 0 : data2.ID) ? rgbColor(!activebgColor ? [255, 255, 255] : activebgColor) : rgbColor(bgColor),
        height: "20px",
        borderBottom: activeTab == (data2 == null ? void 0 : data2.ID) ? "0px" : "1px solid  #DFDFDF",
        color: !fontColor ? "black" : rgbColor(fontColor),
        fontWeight: 600,
        ...customStyles
      },
      onClick: () => {
        console.log(
          JSON.stringify({
            Event: {
              EventName: emitEvent && emitEvent[0],
              ID: data2 == null ? void 0 : data2.ID,
              Info: [data2 == null ? void 0 : data2.ID]
            }
          })
        );
        localStorage.setItem(
          "lastEvent",
          JSON.stringify({
            Event: {
              EventName: emitEvent && emitEvent[0],
              ID: data2 == null ? void 0 : data2.ID,
              Info: [data2 == null ? void 0 : data2.ID]
            }
          })
        );
        socket.send(
          JSON.stringify({
            Event: {
              EventName: emitEvent && emitEvent[0],
              ID: data2 == null ? void 0 : data2.ID,
              Info: [data2 == null ? void 0 : data2.ID]
            }
          })
        );
        handleTabClick(data2.ID);
      },
      children: Caption
    }
  );
};
const TabControl = ({ data: data2 }) => {
  const { BCol, FCol, ActiveBCol, CSS } = data2 == null ? void 0 : data2.Properties;
  let styles = setStyle$1(data2 == null ? void 0 : data2.Properties);
  const customStyles = parseFlexStyles(CSS);
  const updatedData = excludeKeys(data2);
  const Id2 = getLastTabButton(updatedData);
  const [activeTab, setActiveTab] = reactExports.useState(Id2);
  const { Visible } = data2 == null ? void 0 : data2.Properties;
  const updatedStyles = {
    ...styles,
    display: Visible == 0 ? "none" : "block"
  };
  const handleTabClick = (ID2) => {
    setActiveTab(ID2);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      id: data2 == null ? void 0 : data2.ID,
      style: { ...updatedStyles, ...customStyles },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", alignItems: "end", marginLeft: "3px" }, children: Object.keys(updatedData).map((key) => {
          var _a;
          return ((_a = updatedData[key]) == null ? void 0 : _a.Properties.Type) == "TabButton" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
            TabButton,
            {
              bgColor: BCol,
              fontColor: FCol,
              activebgColor: ActiveBCol,
              activeTab: activeTab ? activeTab : Id2,
              data: updatedData[key],
              handleTabClick
            }
          ) : null;
        }) }),
        Object.keys(updatedData).map((key) => {
          var _a, _b, _c, _d;
          const tab = activeTab ? activeTab : Id2;
          return ((_b = (_a = updatedData[key]) == null ? void 0 : _a.Properties) == null ? void 0 : _b.Type) == "SubForm" && tab == ((_d = (_c = updatedData[key]) == null ? void 0 : _c.Properties) == null ? void 0 : _d.TabObj) ? /* @__PURE__ */ jsxRuntimeExports.jsx(SubForm, { data: updatedData[key] }) : null;
        })
      ]
    }
  );
};
const textArea = "";
const TextArea = ({ data: data2 }) => {
  var _a;
  const { handleData, socket, dataRef } = useAppData();
  const textareaRef = reactExports.useRef(null);
  const initialText = () => {
    var _a2;
    if ((_a2 = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _a2.Text) {
      return Array.isArray(data2.Properties.Text) ? data2.Properties.Text.join("\n") : data2.Properties.Text;
    } else {
      const stored = localStorage.getItem(data2.ID);
      return stored ? JSON.parse(stored).Text || "" : "";
    }
  };
  const [localText, setLocalText] = reactExports.useState(initialText);
  let styles = setStyle$1(data2 == null ? void 0 : data2.Properties);
  const { Font, CSS, Event } = data2 == null ? void 0 : data2.Properties;
  const customStyles = parseFlexStyles(CSS);
  reactExports.useEffect(() => {
    var _a2;
    if ((_a2 = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _a2.Text) {
      localStorage.setItem(
        data2.ID,
        JSON.stringify(data2.Properties)
      );
      const text = data2 == null ? void 0 : data2.Properties.Text;
      handleData(
        {
          ID: data2.ID,
          Properties: {
            Text: text
          }
        },
        "WS"
      );
      const newText = Array.isArray(data2.Properties.Text) ? data2.Properties.Text.join("\n") : data2.Properties.Text;
      if (newText !== localText) {
        setLocalText(newText);
      }
    }
  }, [(_a = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _a.Text]);
  let updatedStyles = {
    ...styles,
    scrollbarWidth: "thin",
    scrollbarColor: "transparent transparent",
    fontFamily: Font && Font[0],
    fontSize: Font && `${Font[1]}px`,
    ...customStyles
  };
  const handleChange = (e3) => {
    const newText = e3.target.value;
    setLocalText(newText);
    localStorage.setItem(
      data2.ID,
      JSON.stringify({ ...data2.Properties, Text: newText })
    );
    handleData(
      {
        ID: data2.ID,
        Properties: {
          Text: newText
        }
      },
      "WS"
    );
  };
  const textString = localText;
  const handleMouseUpLocal = (e3, type) => {
    console.log("mousedown", Event);
    switch (type) {
      case "mouseUp":
        handleMouseUp(e3, socket, Event, data2 == null ? void 0 : data2.ID);
        break;
      case "mouseDown":
        handleMouseDown(e3, socket, Event, data2 == null ? void 0 : data2.ID);
        break;
      case "mouseLeave":
        handleMouseLeave(e3, socket, Event, data2 == null ? void 0 : data2.ID);
        break;
      case "mouseEnter":
        handleMouseEnter(e3, socket, Event, data2 == null ? void 0 : data2.ID);
        break;
      case "mouseMove":
        handleMouseMove(e3, socket, Event, data2 == null ? void 0 : data2.ID);
        break;
      case "mouseWheel":
        handleMouseWheel(e3, socket, Event, data2 == null ? void 0 : data2.ID);
        break;
      case "dblclick":
        handleMouseDoubleClick(e3, socket, Event, data2 == null ? void 0 : data2.ID);
        break;
    }
    const textarea = textareaRef.current;
    if (!textarea)
      return;
    const selectionStart = textarea.selectionStart;
    const selectionEnd = textarea.selectionEnd;
    const textLines = textString.split("\n");
    const offsetToLineColumn = (offset2, lines) => {
      let totalChars = 0;
      for (let i16 = 0; i16 < lines.length; i16++) {
        const lineLength = lines[i16].length;
        const lineEnd = totalChars + lineLength;
        if (offset2 <= lineEnd) {
          const lineNumber2 = i16 + 1;
          const columnNumber2 = offset2 - totalChars + 1;
          return [lineNumber2, columnNumber2];
        }
        totalChars += lineLength + 1;
      }
      const lineNumber = lines.length;
      const columnNumber = lines[lines.length - 1].length + 1;
      return [lineNumber, columnNumber];
    };
    const startLineCol = offsetToLineColumn(selectionStart, textLines);
    const endLineCol = offsetToLineColumn(selectionEnd, textLines);
    const selText = [startLineCol, endLineCol];
    console.log("Selection Start:", selectionStart, "End:", selectionEnd);
    console.log("Selection Line/Column:", selText);
    handleData(
      {
        ID: data2 == null ? void 0 : data2.ID,
        Properties: {
          SelText: selText
        }
      },
      "WS"
    );
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { overflow: "hidden" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "textarea",
    {
      ref: textareaRef,
      className: "textArea",
      style: updatedStyles,
      value: textString,
      onChange: handleChange,
      onMouseUp: (e3) => handleMouseUpLocal(e3, "mouseUp"),
      onMouseDown: (e3) => handleMouseUpLocal(e3, "mouseDown"),
      onMouseEnter: (e3) => handleMouseUpLocal(e3, "mouseEnter"),
      onMouseLeave: (e3) => handleMouseUpLocal(e3, "mouseLeave"),
      onMouseMove: (e3) => handleMouseUpLocal(e3, "mouseMove"),
      onWheel: (e3) => handleMouseUpLocal(e3, "mouseWheel"),
      onDoubleClick: (e3) => handleMouseUpLocal(e3, "dblclick"),
      spellCheck: false
    }
  ) });
};
const bootstrap = "";
const bootstrap_min = "";
const reactBootstrapRibbon = "";
const RibbonStyles = "";
const CustomRibbon = ({ data: data2 }) => {
  const updatedData = excludeKeys(data2);
  const { dataRef } = useAppData();
  const { Visible, Size: Size2, ImageListObj, CSS } = data2 == null ? void 0 : data2.Properties;
  const parentSize = JSON.parse(localStorage.getItem("formDimension"));
  const customStyles = parseFlexStyles(CSS);
  reactExports.useEffect(() => {
    const ID2 = getStringafterPeriod(ImageListObj);
    const ImageList = ID2 && JSON.parse(getObjectById(dataRef.current, ID2));
    if (ImageList) {
      localStorage.setItem("ImageList", JSON.stringify(ImageList));
    } else {
      localStorage.removeItem("ImageList");
    }
  }, [data2]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      id: data2 == null ? void 0 : data2.ID,
      className: "row",
      style: {
        height: !Size2 ? "8rem" : Size2[0],
        width: !Size2 ? parentSize && parentSize[1] : Size2 && Size2[1],
        display: Visible == 0 ? "none" : "flex",
        ...customStyles
      },
      children: Object.keys(updatedData).map((key) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectComponent, { data: updatedData[key] });
      })
    }
  );
};
var propTypes$2 = { exports: {} };
var ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;
var ReactPropTypesSecret = ReactPropTypesSecret_1;
function emptyFunction() {
}
function emptyFunctionWithReset() {
}
emptyFunctionWithReset.resetWarningCache = emptyFunction;
var factoryWithThrowingShims = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      return;
    }
    var err = new Error(
      "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
    );
    err.name = "Invariant Violation";
    throw err;
  }
  shim.isRequired = shim;
  function getShim() {
    return shim;
  }
  var ReactPropTypes = {
    array: shim,
    bigint: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,
    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,
    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };
  ReactPropTypes.PropTypes = ReactPropTypes;
  return ReactPropTypes;
};
{
  propTypes$2.exports = factoryWithThrowingShims();
}
var propTypesExports = propTypes$2.exports;
const o$r = /* @__PURE__ */ getDefaultExportFromCjs(propTypesExports);
function _typeof$5(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$5 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$5 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$5(obj);
}
function _classCallCheck$4(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$3(target, props) {
  for (var i16 = 0; i16 < props.length; i16++) {
    var descriptor = props[i16];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$4(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$3(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$3(Constructor, staticProps);
  return Constructor;
}
function _createSuper$3(Derived) {
  return function() {
    var Super = _getPrototypeOf$3(Derived), result;
    if (_isNativeReflectConstruct$3()) {
      var NewTarget = _getPrototypeOf$3(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$4(this, result);
  };
}
function _possibleConstructorReturn$4(self2, call2) {
  if (call2 && (_typeof$5(call2) === "object" || typeof call2 === "function")) {
    return call2;
  }
  return _assertThisInitialized$3(self2);
}
function _assertThisInitialized$3(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$3() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$3(o9) {
  _getPrototypeOf$3 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o10) {
    return o10.__proto__ || Object.getPrototypeOf(o10);
  };
  return _getPrototypeOf$3(o9);
}
function _inherits$4(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$3(subClass, superClass);
}
function _setPrototypeOf$3(o9, p6) {
  _setPrototypeOf$3 = Object.setPrototypeOf || function _setPrototypeOf2(o10, p7) {
    o10.__proto__ = p7;
    return o10;
  };
  return _setPrototypeOf$3(o9, p6);
}
var ReactBootstrapRibbon = /* @__PURE__ */ function(_React$Component) {
  _inherits$4(ReactBootstrapRibbon2, _React$Component);
  var _super = _createSuper$3(ReactBootstrapRibbon2);
  function ReactBootstrapRibbon2() {
    var _this;
    _classCallCheck$4(this, ReactBootstrapRibbon2);
    _this = _super.call(this);
    _this.state = {
      mobileCurrentGroup: 0
    };
    return _this;
  }
  _createClass$4(ReactBootstrapRibbon2, [{
    key: "handleChange",
    value: function handleChange(event) {
      this.setState({
        mobileCurrentGroup: event.target.value * 1
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;
      var children = Array.isArray(this.props.children) ? this.props.children : [this.props.children];
      return /* @__PURE__ */ t$q.createElement("div", {
        className: "bg-light"
      }, /* @__PURE__ */ t$q.createElement("div", {
        className: "d-".concat(this.props.breakpoint, "-none")
      }, /* @__PURE__ */ t$q.createElement("div", {
        className: "mobile-ribbon ribbon"
      }, /* @__PURE__ */ t$q.createElement("div", {
        className: "ribbon-group-content"
      }, /* @__PURE__ */ t$q.createElement("select", {
        className: "mobile-ribbon-select form-control",
        onChange: function onChange(event) {
          return _this2.handleChange(event);
        }
      }, children.map(function(item, index2) {
        return /* @__PURE__ */ t$q.createElement("option", {
          key: index2,
          value: index2
        }, item.props.title);
      }))), children.map(function(item, index2) {
        return /* @__PURE__ */ t$q.createElement("div", {
          key: index2,
          className: "ribbon-group-content " + (index2 === _this2.state.mobileCurrentGroup ? "d-block" : "d-none")
        }, /* @__PURE__ */ t$q.createElement("div", {
          className: "row no-gutters"
        }, item.props.children));
      }))), /* @__PURE__ */ t$q.createElement("div", {
        className: "d-none d-".concat(this.props.breakpoint, "-block")
      }, /* @__PURE__ */ t$q.createElement("div", {
        className: "ribbon d-flex",
        style: {
          height: this.props.height
        }
      }, /* @__PURE__ */ t$q.createElement("div", {
        className: "row no-gutters w-100"
      }, this.props.children))));
    }
  }], [{
    key: "defaultProps",
    get: function get3() {
      return {
        height: "8rem",
        breakpoint: "md"
      };
    }
  }]);
  return ReactBootstrapRibbon2;
}(t$q.Component);
ReactBootstrapRibbon.propTypes = {
  height: o$r.string,
  breakpoint: o$r.oneOf(["sm", "md", "lg", "xl"])
};
const ReactBootstrapRibbon$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: ReactBootstrapRibbon
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(ReactBootstrapRibbon$1);
function _typeof$4(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$4 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$4 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$4(obj);
}
function _classCallCheck$3(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2(target, props) {
  for (var i16 = 0; i16 < props.length; i16++) {
    var descriptor = props[i16];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$3(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2(Constructor, staticProps);
  return Constructor;
}
function _createSuper$2(Derived) {
  return function() {
    var Super = _getPrototypeOf$2(Derived), result;
    if (_isNativeReflectConstruct$2()) {
      var NewTarget = _getPrototypeOf$2(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$3(this, result);
  };
}
function _possibleConstructorReturn$3(self2, call2) {
  if (call2 && (_typeof$4(call2) === "object" || typeof call2 === "function")) {
    return call2;
  }
  return _assertThisInitialized$2(self2);
}
function _assertThisInitialized$2(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$2(o9) {
  _getPrototypeOf$2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o10) {
    return o10.__proto__ || Object.getPrototypeOf(o10);
  };
  return _getPrototypeOf$2(o9);
}
function _inherits$3(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$2(subClass, superClass);
}
function _setPrototypeOf$2(o9, p6) {
  _setPrototypeOf$2 = Object.setPrototypeOf || function _setPrototypeOf2(o10, p7) {
    o10.__proto__ = p7;
    return o10;
  };
  return _setPrototypeOf$2(o9, p6);
}
var ReactBootstrapRibbonGroup = /* @__PURE__ */ function(_React$Component) {
  _inherits$3(ReactBootstrapRibbonGroup2, _React$Component);
  var _super = _createSuper$2(ReactBootstrapRibbonGroup2);
  function ReactBootstrapRibbonGroup2() {
    _classCallCheck$3(this, ReactBootstrapRibbonGroup2);
    return _super.apply(this, arguments);
  }
  _createClass$3(ReactBootstrapRibbonGroup2, [{
    key: "render",
    value: function render() {
      return /* @__PURE__ */ t$q.createElement("div", {
        className: "ribbon-col h-100 " + (this.props.colClass ? this.props.colClass : "col-sm-6")
      }, /* @__PURE__ */ t$q.createElement("div", {
        className: "ribbon-group h-100 d-flex flex-column"
      }, /* @__PURE__ */ t$q.createElement("div", {
        className: "ribbon-group-content h-100 flex-fill"
      }, /* @__PURE__ */ t$q.createElement("div", {
        className: "row no-gutters row-2px h-100 p-1"
      }, this.props.children)), /* @__PURE__ */ t$q.createElement("div", {
        className: "ribbon-group-title text-center"
      }, this.props.title)));
    }
  }]);
  return ReactBootstrapRibbonGroup2;
}(t$q.Component);
const ReactBootstrapRibbonGroup$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: ReactBootstrapRibbonGroup
}, Symbol.toStringTag, { value: "Module" }));
const require$$1 = /* @__PURE__ */ getAugmentedNamespace(ReactBootstrapRibbonGroup$1);
function _typeof$3(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$3 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$3 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$3(obj);
}
function _classCallCheck$2(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1(target, props) {
  for (var i16 = 0; i16 < props.length; i16++) {
    var descriptor = props[i16];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1(Constructor, staticProps);
  return Constructor;
}
function _createSuper$1(Derived) {
  return function() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (_isNativeReflectConstruct$1()) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$2(this, result);
  };
}
function _possibleConstructorReturn$2(self2, call2) {
  if (call2 && (_typeof$3(call2) === "object" || typeof call2 === "function")) {
    return call2;
  }
  return _assertThisInitialized$1(self2);
}
function _assertThisInitialized$1(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$1(o9) {
  _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o10) {
    return o10.__proto__ || Object.getPrototypeOf(o10);
  };
  return _getPrototypeOf$1(o9);
}
function _inherits$2(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$1(subClass, superClass);
}
function _setPrototypeOf$1(o9, p6) {
  _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf2(o10, p7) {
    o10.__proto__ = p7;
    return o10;
  };
  return _setPrototypeOf$1(o9, p6);
}
var ReactBootstrapRibbonGroupItem = /* @__PURE__ */ function(_React$Component) {
  _inherits$2(ReactBootstrapRibbonGroupItem2, _React$Component);
  var _super = _createSuper$1(ReactBootstrapRibbonGroupItem2);
  function ReactBootstrapRibbonGroupItem2() {
    _classCallCheck$2(this, ReactBootstrapRibbonGroupItem2);
    return _super.apply(this, arguments);
  }
  _createClass$2(ReactBootstrapRibbonGroupItem2, [{
    key: "render",
    value: function render() {
      return /* @__PURE__ */ t$q.createElement("div", {
        className: "d-md-flex " + (this.props.colClass ? this.props.colClass : "col-6")
      }, this.props.children);
    }
  }]);
  return ReactBootstrapRibbonGroupItem2;
}(t$q.Component);
const ReactBootstrapRibbonGroupItem$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: ReactBootstrapRibbonGroupItem
}, Symbol.toStringTag, { value: "Module" }));
const require$$2 = /* @__PURE__ */ getAugmentedNamespace(ReactBootstrapRibbonGroupItem$1);
function _typeof$2(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$2 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$2 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$2(obj);
}
function _extends$3() {
  _extends$3 = Object.assign || function(target) {
    for (var i16 = 1; i16 < arguments.length; i16++) {
      var source = arguments[i16];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$3.apply(this, arguments);
}
function _classCallCheck$1(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i16 = 0; i16 < props.length; i16++) {
    var descriptor = props[i16];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _createSuper(Derived) {
  return function() {
    var Super = _getPrototypeOf(Derived), result;
    if (_isNativeReflectConstruct()) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1(this, result);
  };
}
function _possibleConstructorReturn$1(self2, call2) {
  if (call2 && (_typeof$2(call2) === "object" || typeof call2 === "function")) {
    return call2;
  }
  return _assertThisInitialized(self2);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf(o9) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o10) {
    return o10.__proto__ || Object.getPrototypeOf(o10);
  };
  return _getPrototypeOf(o9);
}
function _inherits$1(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o9, p6) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o10, p7) {
    o10.__proto__ = p7;
    return o10;
  };
  return _setPrototypeOf(o9, p6);
}
var ReactBootstrapRibbonButton = /* @__PURE__ */ function(_React$Component) {
  _inherits$1(ReactBootstrapRibbonButton2, _React$Component);
  var _super = _createSuper(ReactBootstrapRibbonButton2);
  function ReactBootstrapRibbonButton2() {
    _classCallCheck$1(this, ReactBootstrapRibbonButton2);
    return _super.apply(this, arguments);
  }
  _createClass$1(ReactBootstrapRibbonButton2, [{
    key: "render",
    value: function render() {
      return /* @__PURE__ */ t$q.createElement("button", _extends$3({
        type: "button",
        className: "btn btn-light btn-block text-nowrap"
      }, this.props), this.props.children);
    }
  }]);
  return ReactBootstrapRibbonButton2;
}(t$q.Component);
const ReactBootstrapRibbonButton$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: ReactBootstrapRibbonButton
}, Symbol.toStringTag, { value: "Module" }));
const require$$3 = /* @__PURE__ */ getAugmentedNamespace(ReactBootstrapRibbonButton$1);
require$$0["default"];
require$$1["default"];
require$$2["default"];
require$$3["default"];
const CustomRibbonGroup = ({ data: data2 }) => {
  const updatedData = excludeKeys(data2);
  const { Size: Size2, Title: Title2, BorderCol, CSS } = data2 == null ? void 0 : data2.Properties;
  const customStyle = parseFlexStyles(CSS);
  const size = Size2 || 1;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { id: data2 == null ? void 0 : data2.ID, className: `col-${size}`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      style: {
        border: `1px solid ${rgbColor(BorderCol)}`,
        borderTop: 0,
        position: "relative",
        height: "100%",
        alignItems: "center",
        ...customStyle
      },
      className: "row",
      children: [
        Object.keys(updatedData).map((key) => {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectComponent, { data: updatedData[key] });
        }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            style: {
              backgroundColor: "rgb(204, 204, 204)",
              position: "absolute",
              bottom: 0,
              width: "100%"
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { margin: 0, fontSize: "12px", fontWeight: "bolder" }, className: "text-center", children: Title2 })
          }
        )
      ]
    }
  ) });
};
const CustomRibbonItem = ({ data: data2 }) => {
  const updatedData = excludeKeys(data2);
  const { Size: Size2, CSS } = data2 == null ? void 0 : data2.Properties;
  const customStyles = parseFlexStyles(CSS);
  const size = Size2 || 12;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      id: data2 == null ? void 0 : data2.ID,
      style: { display: "flex", justifyContent: "center", ...customStyles },
      className: `col-${size}`,
      children: Object.keys(updatedData).map((key) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectComponent, { data: updatedData[key] });
      })
    }
  );
};
function FcCalendar(props) {
  return GenIcon({ "tag": "svg", "attr": { "version": "1", "viewBox": "0 0 48 48", "enableBackground": "new 0 0 48 48" }, "child": [{ "tag": "path", "attr": { "fill": "#CFD8DC", "d": "M5,38V14h38v24c0,2.2-1.8,4-4,4H9C6.8,42,5,40.2,5,38z" } }, { "tag": "path", "attr": { "fill": "#F44336", "d": "M43,10v6H5v-6c0-2.2,1.8-4,4-4h30C41.2,6,43,7.8,43,10z" } }, { "tag": "g", "attr": { "fill": "#B71C1C" }, "child": [{ "tag": "circle", "attr": { "cx": "33", "cy": "10", "r": "3" } }, { "tag": "circle", "attr": { "cx": "15", "cy": "10", "r": "3" } }] }, { "tag": "g", "attr": { "fill": "#B0BEC5" }, "child": [{ "tag": "path", "attr": { "d": "M33,3c-1.1,0-2,0.9-2,2v5c0,1.1,0.9,2,2,2s2-0.9,2-2V5C35,3.9,34.1,3,33,3z" } }, { "tag": "path", "attr": { "d": "M15,3c-1.1,0-2,0.9-2,2v5c0,1.1,0.9,2,2,2s2-0.9,2-2V5C17,3.9,16.1,3,15,3z" } }] }, { "tag": "g", "attr": { "fill": "#90A4AE" }, "child": [{ "tag": "rect", "attr": { "x": "13", "y": "20", "width": "4", "height": "4" } }, { "tag": "rect", "attr": { "x": "19", "y": "20", "width": "4", "height": "4" } }, { "tag": "rect", "attr": { "x": "25", "y": "20", "width": "4", "height": "4" } }, { "tag": "rect", "attr": { "x": "31", "y": "20", "width": "4", "height": "4" } }, { "tag": "rect", "attr": { "x": "13", "y": "26", "width": "4", "height": "4" } }, { "tag": "rect", "attr": { "x": "19", "y": "26", "width": "4", "height": "4" } }, { "tag": "rect", "attr": { "x": "25", "y": "26", "width": "4", "height": "4" } }, { "tag": "rect", "attr": { "x": "31", "y": "26", "width": "4", "height": "4" } }, { "tag": "rect", "attr": { "x": "13", "y": "32", "width": "4", "height": "4" } }, { "tag": "rect", "attr": { "x": "19", "y": "32", "width": "4", "height": "4" } }, { "tag": "rect", "attr": { "x": "25", "y": "32", "width": "4", "height": "4" } }, { "tag": "rect", "attr": { "x": "31", "y": "32", "width": "4", "height": "4" } }] }] })(props);
}
function FcHighPriority(props) {
  return GenIcon({ "tag": "svg", "attr": { "version": "1", "viewBox": "0 0 48 48", "enableBackground": "new 0 0 48 48" }, "child": [{ "tag": "path", "attr": { "fill": "#F44336", "d": "M21.2,44.8l-18-18c-1.6-1.6-1.6-4.1,0-5.7l18-18c1.6-1.6,4.1-1.6,5.7,0l18,18c1.6,1.6,1.6,4.1,0,5.7l-18,18 C25.3,46.4,22.7,46.4,21.2,44.8z" } }, { "tag": "path", "attr": { "fill": "#fff", "d": "M21.6,32.7c0-0.3,0.1-0.6,0.2-0.9c0.1-0.3,0.3-0.5,0.5-0.7c0.2-0.2,0.5-0.4,0.8-0.5s0.6-0.2,1-0.2 s0.7,0.1,1,0.2c0.3,0.1,0.6,0.3,0.8,0.5c0.2,0.2,0.4,0.4,0.5,0.7c0.1,0.3,0.2,0.6,0.2,0.9s-0.1,0.6-0.2,0.9s-0.3,0.5-0.5,0.7 c-0.2,0.2-0.5,0.4-0.8,0.5c-0.3,0.1-0.6,0.2-1,0.2s-0.7-0.1-1-0.2s-0.5-0.3-0.8-0.5c-0.2-0.2-0.4-0.4-0.5-0.7S21.6,33.1,21.6,32.7z M25.8,28.1h-3.6L21.7,13h4.6L25.8,28.1z" } }] })(props);
}
function FcHome(props) {
  return GenIcon({ "tag": "svg", "attr": { "version": "1", "viewBox": "0 0 48 48", "enableBackground": "new 0 0 48 48" }, "child": [{ "tag": "polygon", "attr": { "fill": "#E8EAF6", "points": "42,39 6,39 6,23 24,6 42,23" } }, { "tag": "g", "attr": { "fill": "#C5CAE9" }, "child": [{ "tag": "polygon", "attr": { "points": "39,21 34,16 34,9 39,9" } }, { "tag": "rect", "attr": { "x": "6", "y": "39", "width": "36", "height": "5" } }] }, { "tag": "polygon", "attr": { "fill": "#B71C1C", "points": "24,4.3 4,22.9 6,25.1 24,8.4 42,25.1 44,22.9" } }, { "tag": "rect", "attr": { "x": "18", "y": "28", "fill": "#D84315", "width": "12", "height": "16" } }, { "tag": "rect", "attr": { "x": "21", "y": "17", "fill": "#01579B", "width": "6", "height": "6" } }, { "tag": "path", "attr": { "fill": "#FF8A65", "d": "M27.5,35.5c-0.3,0-0.5,0.2-0.5,0.5v2c0,0.3,0.2,0.5,0.5,0.5S28,38.3,28,38v-2C28,35.7,27.8,35.5,27.5,35.5z" } }] })(props);
}
function FcInfo(props) {
  return GenIcon({ "tag": "svg", "attr": { "version": "1", "viewBox": "0 0 48 48", "enableBackground": "new 0 0 48 48" }, "child": [{ "tag": "circle", "attr": { "fill": "#2196F3", "cx": "24", "cy": "24", "r": "21" } }, { "tag": "rect", "attr": { "x": "22", "y": "22", "fill": "#fff", "width": "4", "height": "11" } }, { "tag": "circle", "attr": { "fill": "#fff", "cx": "24", "cy": "16.5", "r": "2.5" } }] })(props);
}
function FcKindle(props) {
  return GenIcon({ "tag": "svg", "attr": { "version": "1", "viewBox": "0 0 48 48", "enableBackground": "new 0 0 48 48" }, "child": [{ "tag": "path", "attr": { "fill": "#37474F", "d": "M8,41V7c0-2.2,1.8-4,4-4h24c2.2,0,4,1.8,4,4v34c0,2.2-1.8,4-4,4H12C9.8,45,8,43.2,8,41z" } }, { "tag": "path", "attr": { "fill": "#eee", "d": "M35,6H13c-0.6,0-1,0.4-1,1v29c0,0.6,0.4,1,1,1h22c0.6,0,1-0.4,1-1V7C36,6.4,35.6,6,35,6z" } }, { "tag": "rect", "attr": { "x": "20", "y": "40", "fill": "#546E7A", "width": "8", "height": "2" } }, { "tag": "g", "attr": { "fill": "#A1A1A1" }, "child": [{ "tag": "rect", "attr": { "x": "16", "y": "11", "width": "16", "height": "3" } }, { "tag": "rect", "attr": { "x": "16", "y": "18", "width": "16", "height": "2" } }, { "tag": "rect", "attr": { "x": "16", "y": "22", "width": "12", "height": "2" } }, { "tag": "rect", "attr": { "x": "16", "y": "26", "width": "16", "height": "2" } }, { "tag": "rect", "attr": { "x": "16", "y": "30", "width": "12", "height": "2" } }] }] })(props);
}
function FcLibrary(props) {
  return GenIcon({ "tag": "svg", "attr": { "version": "1", "viewBox": "0 0 48 48", "enableBackground": "new 0 0 48 48" }, "child": [{ "tag": "g", "attr": { "fill": "#FF9800" }, "child": [{ "tag": "rect", "attr": { "x": "1", "y": "38", "width": "46", "height": "2" } }, { "tag": "rect", "attr": { "x": "25", "y": "18", "width": "4", "height": "16" } }, { "tag": "rect", "attr": { "x": "31", "y": "18", "width": "4", "height": "16" } }, { "tag": "rect", "attr": { "x": "37", "y": "18", "width": "4", "height": "16" } }, { "tag": "rect", "attr": { "x": "19", "y": "18", "width": "4", "height": "16" } }, { "tag": "rect", "attr": { "x": "13", "y": "18", "width": "4", "height": "16" } }, { "tag": "rect", "attr": { "x": "7", "y": "18", "width": "4", "height": "16" } }, { "tag": "polygon", "attr": { "points": "43,16 5,16 5,13 24,4 43,13" } }, { "tag": "rect", "attr": { "x": "5", "y": "34", "width": "38", "height": "2" } }] }, { "tag": "g", "attr": { "fill": "#EF6C00" }, "child": [{ "tag": "rect", "attr": { "x": "25", "y": "16", "width": "4", "height": "2" } }, { "tag": "rect", "attr": { "x": "31", "y": "16", "width": "4", "height": "2" } }, { "tag": "rect", "attr": { "x": "37", "y": "16", "width": "4", "height": "2" } }, { "tag": "rect", "attr": { "x": "19", "y": "16", "width": "4", "height": "2" } }, { "tag": "rect", "attr": { "x": "13", "y": "16", "width": "4", "height": "2" } }, { "tag": "rect", "attr": { "x": "7", "y": "16", "width": "4", "height": "2" } }, { "tag": "rect", "attr": { "x": "3", "y": "36", "width": "42", "height": "2" } }, { "tag": "circle", "attr": { "cx": "24", "cy": "11", "r": "2" } }] }] })(props);
}
function FcLock(props) {
  return GenIcon({ "tag": "svg", "attr": { "version": "1", "viewBox": "0 0 48 48", "enableBackground": "new 0 0 48 48" }, "child": [{ "tag": "path", "attr": { "fill": "#424242", "d": "M24,4c-5.5,0-10,4.5-10,10v4h4v-4c0-3.3,2.7-6,6-6s6,2.7,6,6v4h4v-4C34,8.5,29.5,4,24,4z" } }, { "tag": "path", "attr": { "fill": "#FB8C00", "d": "M36,44H12c-2.2,0-4-1.8-4-4V22c0-2.2,1.8-4,4-4h24c2.2,0,4,1.8,4,4v18C40,42.2,38.2,44,36,44z" } }, { "tag": "circle", "attr": { "fill": "#C76E00", "cx": "24", "cy": "31", "r": "3" } }] })(props);
}
function FcMoneyTransfer(props) {
  return GenIcon({ "tag": "svg", "attr": { "version": "1", "viewBox": "0 0 48 48", "enableBackground": "new 0 0 48 48" }, "child": [{ "tag": "path", "attr": { "fill": "#78909C", "d": "M40,41H8c-2.2,0-4-1.8-4-4l0-20.9c0-1.3,0.6-2.5,1.7-3.3L24,0l18.3,12.8c1.1,0.7,1.7,2,1.7,3.3V37 C44,39.2,42.2,41,40,41z" } }, { "tag": "rect", "attr": { "x": "14", "y": "1", "fill": "#AED581", "width": "20", "height": "31" } }, { "tag": "g", "attr": { "fill": "#558B2F" }, "child": [{ "tag": "path", "attr": { "d": "M13,0v33h22V0H13z M33,31H15V2h18V31z" } }, { "tag": "path", "attr": { "d": "M34,3c0,1.7-0.3,3-2,3c-1.7,0-3-1.3-3-3s1.3-2,3-2C33.7,1,34,1.3,34,3z" } }, { "tag": "path", "attr": { "d": "M16,1c1.7,0,3,0.3,3,2s-1.3,3-3,3s-2-1.3-2-3S14.3,1,16,1z" } }, { "tag": "circle", "attr": { "cx": "24", "cy": "8", "r": "2" } }, { "tag": "circle", "attr": { "cx": "24", "cy": "20", "r": "6" } }] }, { "tag": "path", "attr": { "fill": "#CFD8DC", "d": "M40,41H8c-2.2,0-4-1.8-4-4l0-20l20,13l20-13v20C44,39.2,42.2,41,40,41z" } }] })(props);
}
function FcPlanner(props) {
  return GenIcon({ "tag": "svg", "attr": { "version": "1", "viewBox": "0 0 48 48", "enableBackground": "new 0 0 48 48" }, "child": [{ "tag": "path", "attr": { "fill": "#CFD8DC", "d": "M5,38V14h38v24c0,2.2-1.8,4-4,4H9C6.8,42,5,40.2,5,38z" } }, { "tag": "path", "attr": { "fill": "#F44336", "d": "M43,10v6H5v-6c0-2.2,1.8-4,4-4h30C41.2,6,43,7.8,43,10z" } }, { "tag": "g", "attr": { "fill": "#B71C1C" }, "child": [{ "tag": "circle", "attr": { "cx": "33", "cy": "10", "r": "3" } }, { "tag": "circle", "attr": { "cx": "15", "cy": "10", "r": "3" } }] }, { "tag": "g", "attr": { "fill": "#B0BEC5" }, "child": [{ "tag": "path", "attr": { "d": "M33,3c-1.1,0-2,0.9-2,2v5c0,1.1,0.9,2,2,2s2-0.9,2-2V5C35,3.9,34.1,3,33,3z" } }, { "tag": "path", "attr": { "d": "M15,3c-1.1,0-2,0.9-2,2v5c0,1.1,0.9,2,2,2s2-0.9,2-2V5C17,3.9,16.1,3,15,3z" } }] }, { "tag": "g", "attr": { "fill": "#B0BEC5" }, "child": [{ "tag": "rect", "attr": { "x": "13", "y": "21", "width": "6", "height": "6" } }, { "tag": "rect", "attr": { "x": "21", "y": "21", "width": "6", "height": "6" } }, { "tag": "rect", "attr": { "x": "29", "y": "21", "width": "6", "height": "6" } }, { "tag": "rect", "attr": { "x": "13", "y": "29", "width": "6", "height": "6" } }, { "tag": "rect", "attr": { "x": "21", "y": "29", "width": "6", "height": "6" } }] }, { "tag": "rect", "attr": { "x": "29", "y": "29", "fill": "#F44336", "width": "6", "height": "6" } }] })(props);
}
function FcPodiumWithSpeaker(props) {
  return GenIcon({ "tag": "svg", "attr": { "version": "1", "viewBox": "0 0 48 48", "enableBackground": "new 0 0 48 48" }, "child": [{ "tag": "circle", "attr": { "fill": "#FFB74D", "cx": "24", "cy": "11", "r": "6" } }, { "tag": "path", "attr": { "fill": "#607D8B", "d": "M36,26.1c0,0-3.3-7.1-12-7.1s-12,7.1-12,7.1V30h24V26.1z" } }, { "tag": "polygon", "attr": { "fill": "#B0BEC5", "points": "41,25 7,25 6,29 11,32 9,29 39,29 37,32 42,29" } }, { "tag": "polygon", "attr": { "fill": "#78909C", "points": "9,29 39,29 35,41 13,41" } }] })(props);
}
function FcSearch(props) {
  return GenIcon({ "tag": "svg", "attr": { "version": "1", "viewBox": "0 0 48 48", "enableBackground": "new 0 0 48 48" }, "child": [{ "tag": "g", "attr": { "fill": "#616161" }, "child": [{ "tag": "rect", "attr": { "x": "34.6", "y": "28.1", "transform": "matrix(.707 -.707 .707 .707 -15.154 36.586)", "width": "4", "height": "17" } }, { "tag": "circle", "attr": { "cx": "20", "cy": "20", "r": "16" } }] }, { "tag": "rect", "attr": { "x": "36.2", "y": "32.1", "transform": "matrix(.707 -.707 .707 .707 -15.839 38.239)", "fill": "#37474F", "width": "4", "height": "12.3" } }, { "tag": "circle", "attr": { "fill": "#64B5F6", "cx": "20", "cy": "20", "r": "13" } }, { "tag": "path", "attr": { "fill": "#BBDEFB", "d": "M26.9,14.2c-1.7-2-4.2-3.2-6.9-3.2s-5.2,1.2-6.9,3.2c-0.4,0.4-0.3,1.1,0.1,1.4c0.4,0.4,1.1,0.3,1.4-0.1 C16,13.9,17.9,13,20,13s4,0.9,5.4,2.5c0.2,0.2,0.5,0.4,0.8,0.4c0.2,0,0.5-0.1,0.6-0.2C27.2,15.3,27.2,14.6,26.9,14.2z" } }] })(props);
}
function FcShare(props) {
  return GenIcon({ "tag": "svg", "attr": { "version": "1", "viewBox": "0 0 48 48", "enableBackground": "new 0 0 48 48" }, "child": [{ "tag": "path", "attr": { "fill": "#1976D2", "d": "M38.1,31.2L19.4,24l18.7-7.2c1.5-0.6,2.3-2.3,1.7-3.9c-0.6-1.5-2.3-2.3-3.9-1.7l-26,10C8.8,21.6,8,22.8,8,24 s0.8,2.4,1.9,2.8l26,10c0.4,0.1,0.7,0.2,1.1,0.2c1.2,0,2.3-0.7,2.8-1.9C40.4,33.5,39.6,31.8,38.1,31.2z" } }, { "tag": "g", "attr": { "fill": "#1E88E5" }, "child": [{ "tag": "circle", "attr": { "cx": "11", "cy": "24", "r": "7" } }, { "tag": "circle", "attr": { "cx": "37", "cy": "14", "r": "7" } }, { "tag": "circle", "attr": { "cx": "37", "cy": "34", "r": "7" } }] }] })(props);
}
function FcTreeStructure(props) {
  return GenIcon({ "tag": "svg", "attr": { "version": "1", "viewBox": "0 0 48 48", "enableBackground": "new 0 0 48 48" }, "child": [{ "tag": "polygon", "attr": { "fill": "#90CAF9", "points": "36.9,13.8 35.1,10.2 7.5,24 35.1,37.8 36.9,34.2 16.5,24" } }, { "tag": "rect", "attr": { "x": "6", "y": "18", "fill": "#D81B60", "width": "12", "height": "12" } }, { "tag": "g", "attr": { "fill": "#2196F3" }, "child": [{ "tag": "rect", "attr": { "x": "30", "y": "6", "width": "12", "height": "12" } }, { "tag": "rect", "attr": { "x": "30", "y": "30", "width": "12", "height": "12" } }] }] })(props);
}
const AppIcons = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  FcCalendar,
  FcHighPriority,
  FcHome,
  FcKindle,
  FcLibrary,
  FcLock,
  FcMoneyTransfer,
  FcPlanner,
  FcPodiumWithSpeaker,
  FcSearch,
  FcShare,
  FcTreeStructure
}, Symbol.toStringTag, { value: "Module" }));
function _typeof$1(obj) {
  "@babel/helpers - typeof";
  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$1(obj);
}
var globalCssModule;
function mapToCssModules() {
  var className = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  var cssModule = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : globalCssModule;
  if (!cssModule)
    return className;
  return className.split(" ").map(function(c6) {
    return cssModule[c6] || c6;
  }).join(" ");
}
var warned = {};
function warnOnce(message) {
  if (!warned[message]) {
    if (typeof console !== "undefined") {
      console.error(message);
    }
    warned[message] = true;
  }
}
function deprecated(propType, explanation) {
  return function validate(props, propName, componentName) {
    if (props[propName] !== null && typeof props[propName] !== "undefined") {
      warnOnce('"'.concat(propName, '" property of "').concat(componentName, '" has been deprecated.\n').concat(explanation));
    }
    for (var _len = arguments.length, rest = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      rest[_key - 3] = arguments[_key];
    }
    return propType.apply(void 0, [props, propName, componentName].concat(rest));
  };
}
var Element$3 = (typeof window === "undefined" ? "undefined" : _typeof$1(window)) === "object" && window.Element || function() {
};
function DOMElement(props, propName, componentName) {
  if (!(props[propName] instanceof Element$3)) {
    return new Error("Invalid prop `" + propName + "` supplied to `" + componentName + "`. Expected prop to be an instance of Element. Validation failed.");
  }
}
o$r.oneOfType([o$r.string, o$r.func, DOMElement, o$r.shape({
  current: o$r.any
})]);
var tagPropType = o$r.oneOfType([o$r.func, o$r.string, o$r.shape({
  $$typeof: o$r.symbol,
  render: o$r.func
}), o$r.arrayOf(o$r.oneOfType([o$r.func, o$r.string, o$r.shape({
  $$typeof: o$r.symbol,
  render: o$r.func
})]))]);
function isObject$1(value2) {
  var type = _typeof$1(value2);
  return value2 != null && (type === "object" || type === "function");
}
var _excluded$1 = ["className", "cssModule", "noGutters", "tag", "widths"];
function _extends$2() {
  _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i16 = 1; i16 < arguments.length; i16++) {
      var source = arguments[i16];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$2.apply(this, arguments);
}
function _objectWithoutProperties$2(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$1(source, excluded);
  var key, i16;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i16 = 0; i16 < sourceSymbolKeys.length; i16++) {
      key = sourceSymbolKeys[i16];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i16;
  for (i16 = 0; i16 < sourceKeys.length; i16++) {
    key = sourceKeys[i16];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var rowColWidths = ["xs", "sm", "md", "lg", "xl", "xxl"];
var rowColsPropType = o$r.oneOfType([o$r.number, o$r.string]);
var propTypes$1 = {
  tag: tagPropType,
  noGutters: deprecated(o$r.bool, "Please use Bootstrap 5 gutter utility classes. https://getbootstrap.com/docs/5.0/layout/gutters/"),
  className: o$r.string,
  cssModule: o$r.object,
  xs: rowColsPropType,
  sm: rowColsPropType,
  md: rowColsPropType,
  lg: rowColsPropType,
  xl: rowColsPropType,
  xxl: rowColsPropType,
  widths: o$r.array
};
function Row(props) {
  var className = props.className, cssModule = props.cssModule, noGutters = props.noGutters, _props$tag = props.tag, Tag = _props$tag === void 0 ? "div" : _props$tag, _props$widths = props.widths, widths = _props$widths === void 0 ? rowColWidths : _props$widths, attributes2 = _objectWithoutProperties$2(props, _excluded$1);
  var colClasses = [];
  widths.forEach(function(colWidth, i16) {
    var colSize = props[colWidth];
    delete attributes2[colWidth];
    if (!colSize) {
      return;
    }
    var isXs = !i16;
    colClasses.push(isXs ? "row-cols-".concat(colSize) : "row-cols-".concat(colWidth, "-").concat(colSize));
  });
  var classes = mapToCssModules(classNames(className, noGutters ? "gx-0" : null, "row", colClasses), cssModule);
  return /* @__PURE__ */ t$q.createElement(Tag, _extends$2({}, attributes2, {
    className: classes
  }));
}
Row.propTypes = propTypes$1;
var _excluded = ["className", "cssModule", "widths", "tag"];
function _extends$1() {
  _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i16 = 1; i16 < arguments.length; i16++) {
      var source = arguments[i16];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
function _objectWithoutProperties$1(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i16;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i16 = 0; i16 < sourceSymbolKeys.length; i16++) {
      key = sourceSymbolKeys[i16];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i16;
  for (i16 = 0; i16 < sourceKeys.length; i16++) {
    key = sourceKeys[i16];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _defineProperty$1(obj, key, value2) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value: value2, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value2;
  }
  return obj;
}
var colWidths = ["xs", "sm", "md", "lg", "xl", "xxl"];
var stringOrNumberProp = o$r.oneOfType([o$r.number, o$r.string]);
var columnProps = o$r.oneOfType([o$r.bool, o$r.number, o$r.string, o$r.shape({
  size: o$r.oneOfType([o$r.bool, o$r.number, o$r.string]),
  order: stringOrNumberProp,
  offset: stringOrNumberProp
})]);
var propTypes = {
  tag: tagPropType,
  xs: columnProps,
  sm: columnProps,
  md: columnProps,
  lg: columnProps,
  xl: columnProps,
  xxl: columnProps,
  className: o$r.string,
  cssModule: o$r.object,
  widths: o$r.array
};
var getColumnSizeClass = function getColumnSizeClass2(isXs, colWidth, colSize) {
  if (colSize === true || colSize === "") {
    return isXs ? "col" : "col-".concat(colWidth);
  }
  if (colSize === "auto") {
    return isXs ? "col-auto" : "col-".concat(colWidth, "-auto");
  }
  return isXs ? "col-".concat(colSize) : "col-".concat(colWidth, "-").concat(colSize);
};
var getColumnClasses = function getColumnClasses2(attributes2, cssModule) {
  var widths = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : colWidths;
  var modifiedAttributes = attributes2;
  var colClasses = [];
  widths.forEach(function(colWidth, i16) {
    var columnProp = modifiedAttributes[colWidth];
    delete modifiedAttributes[colWidth];
    if (!columnProp && columnProp !== "") {
      return;
    }
    var isXs = !i16;
    if (isObject$1(columnProp)) {
      var _classNames;
      var colSizeInterfix = isXs ? "-" : "-".concat(colWidth, "-");
      var colClass = getColumnSizeClass(isXs, colWidth, columnProp.size);
      colClasses.push(mapToCssModules(classNames((_classNames = {}, _defineProperty$1(_classNames, colClass, columnProp.size || columnProp.size === ""), _defineProperty$1(_classNames, "order".concat(colSizeInterfix).concat(columnProp.order), columnProp.order || columnProp.order === 0), _defineProperty$1(_classNames, "offset".concat(colSizeInterfix).concat(columnProp.offset), columnProp.offset || columnProp.offset === 0), _classNames)), cssModule));
    } else {
      var _colClass = getColumnSizeClass(isXs, colWidth, columnProp);
      colClasses.push(_colClass);
    }
  });
  return {
    colClasses,
    modifiedAttributes
  };
};
function Col(props) {
  var className = props.className, cssModule = props.cssModule, _props$widths = props.widths, widths = _props$widths === void 0 ? colWidths : _props$widths, _props$tag = props.tag, Tag = _props$tag === void 0 ? "div" : _props$tag, attributes2 = _objectWithoutProperties$1(props, _excluded);
  var _getColumnClasses = getColumnClasses(attributes2, cssModule, widths), modifiedAttributes = _getColumnClasses.modifiedAttributes, colClasses = _getColumnClasses.colClasses;
  if (!colClasses.length) {
    colClasses.push("col");
  }
  var classes = mapToCssModules(classNames(className, colClasses), cssModule);
  return /* @__PURE__ */ t$q.createElement(Tag, _extends$1({}, modifiedAttributes, {
    className: classes
  }));
}
Col.propTypes = propTypes;
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf$4(subClass, superClass);
}
function hasClass(element, className) {
  if (element.classList)
    return !!className && element.classList.contains(className);
  return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
}
function addClass$1(element, className) {
  if (element.classList)
    element.classList.add(className);
  else if (!hasClass(element, className))
    if (typeof element.className === "string")
      element.className = element.className + " " + className;
    else
      element.setAttribute("class", (element.className && element.className.baseVal || "") + " " + className);
}
function replaceClassName(origClass, classToRemove) {
  return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "");
}
function removeClass$2(element, className) {
  if (element.classList) {
    element.classList.remove(className);
  } else if (typeof element.className === "string") {
    element.className = replaceClassName(element.className, className);
  } else {
    element.setAttribute("class", replaceClassName(element.className && element.className.baseVal || "", className));
  }
}
const config = {
  disabled: false
};
const TransitionGroupContext = t$q.createContext(null);
var forceReflow = function forceReflow2(node) {
  return node.scrollTop;
};
var UNMOUNTED = "unmounted";
var EXITED = "exited";
var ENTERING = "entering";
var ENTERED = "entered";
var EXITING = "exiting";
var Transition$1 = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(Transition2, _React$Component);
  function Transition2(props, context2) {
    var _this;
    _this = _React$Component.call(this, props, context2) || this;
    var parentGroup = context2;
    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;
    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }
    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }
  Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;
    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }
    return null;
  };
  var _proto = Transition2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;
    if (prevProps !== this.props) {
      var status = this.state.status;
      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }
    this.updateStatus(false, nextStatus);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };
  _proto.getTimeouts = function getTimeouts() {
    var timeout = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout;
    if (timeout != null && typeof timeout !== "number") {
      exit = timeout.exit;
      enter = timeout.enter;
      appear = timeout.appear !== void 0 ? timeout.appear : enter;
    }
    return {
      exit,
      enter,
      appear
    };
  };
  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }
    if (nextStatus !== null) {
      this.cancelNextCallback();
      if (nextStatus === ENTERING) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var node = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
          if (node)
            forceReflow(node);
        }
        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };
  _proto.performEnter = function performEnter(mounting) {
    var _this2 = this;
    var enter = this.props.enter;
    var appearing = this.context ? this.context.isMounting : mounting;
    var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
    if (!mounting && !enter || config.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function() {
        _this2.props.onEntered(maybeNode);
      });
      return;
    }
    this.props.onEnter(maybeNode, maybeAppearing);
    this.safeSetState({
      status: ENTERING
    }, function() {
      _this2.props.onEntering(maybeNode, maybeAppearing);
      _this2.onTransitionEnd(enterTimeout, function() {
        _this2.safeSetState({
          status: ENTERED
        }, function() {
          _this2.props.onEntered(maybeNode, maybeAppearing);
        });
      });
    });
  };
  _proto.performExit = function performExit() {
    var _this3 = this;
    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    var maybeNode = this.props.nodeRef ? void 0 : ReactDOM.findDOMNode(this);
    if (!exit || config.disabled) {
      this.safeSetState({
        status: EXITED
      }, function() {
        _this3.props.onExited(maybeNode);
      });
      return;
    }
    this.props.onExit(maybeNode);
    this.safeSetState({
      status: EXITING
    }, function() {
      _this3.props.onExiting(maybeNode);
      _this3.onTransitionEnd(timeouts.exit, function() {
        _this3.safeSetState({
          status: EXITED
        }, function() {
          _this3.props.onExited(maybeNode);
        });
      });
    });
  };
  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };
  _proto.safeSetState = function safeSetState(nextState, callback) {
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };
  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;
    var active = true;
    this.nextCallback = function(event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback(event);
      }
    };
    this.nextCallback.cancel = function() {
      active = false;
    };
    return this.nextCallback;
  };
  _proto.onTransitionEnd = function onTransitionEnd(timeout, handler) {
    this.setNextCallback(handler);
    var node = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
    var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;
    if (!node || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
      this.props.addEndListener(maybeNode, maybeNextCallback);
    }
    if (timeout != null) {
      setTimeout(this.nextCallback, timeout);
    }
  };
  _proto.render = function render() {
    var status = this.state.status;
    if (status === UNMOUNTED) {
      return null;
    }
    var _this$props = this.props, children = _this$props.children;
    _this$props.in;
    _this$props.mountOnEnter;
    _this$props.unmountOnExit;
    _this$props.appear;
    _this$props.enter;
    _this$props.exit;
    _this$props.timeout;
    _this$props.addEndListener;
    _this$props.onEnter;
    _this$props.onEntering;
    _this$props.onEntered;
    _this$props.onExit;
    _this$props.onExiting;
    _this$props.onExited;
    _this$props.nodeRef;
    var childProps = _objectWithoutPropertiesLoose$2(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return (
      // allows for nested Transitions
      /* @__PURE__ */ t$q.createElement(TransitionGroupContext.Provider, {
        value: null
      }, typeof children === "function" ? children(status, childProps) : t$q.cloneElement(t$q.Children.only(children), childProps))
    );
  };
  return Transition2;
}(t$q.Component);
Transition$1.contextType = TransitionGroupContext;
Transition$1.propTypes = {};
function noop$2() {
}
Transition$1.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop$2,
  onEntering: noop$2,
  onEntered: noop$2,
  onExit: noop$2,
  onExiting: noop$2,
  onExited: noop$2
};
Transition$1.UNMOUNTED = UNMOUNTED;
Transition$1.EXITED = EXITED;
Transition$1.ENTERING = ENTERING;
Transition$1.ENTERED = ENTERED;
Transition$1.EXITING = EXITING;
const Transition$2 = Transition$1;
var _addClass = function addClass(node, classes) {
  return node && classes && classes.split(" ").forEach(function(c6) {
    return addClass$1(node, c6);
  });
};
var removeClass$1 = function removeClass(node, classes) {
  return node && classes && classes.split(" ").forEach(function(c6) {
    return removeClass$2(node, c6);
  });
};
var CSSTransition = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(CSSTransition2, _React$Component);
  function CSSTransition2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.appliedClasses = {
      appear: {},
      enter: {},
      exit: {}
    };
    _this.onEnter = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument[0], appearing = _this$resolveArgument[1];
      _this.removeClasses(node, "exit");
      _this.addClass(node, appearing ? "appear" : "enter", "base");
      if (_this.props.onEnter) {
        _this.props.onEnter(maybeNode, maybeAppearing);
      }
    };
    _this.onEntering = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument2 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument2[0], appearing = _this$resolveArgument2[1];
      var type = appearing ? "appear" : "enter";
      _this.addClass(node, type, "active");
      if (_this.props.onEntering) {
        _this.props.onEntering(maybeNode, maybeAppearing);
      }
    };
    _this.onEntered = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument3 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument3[0], appearing = _this$resolveArgument3[1];
      var type = appearing ? "appear" : "enter";
      _this.removeClasses(node, type);
      _this.addClass(node, type, "done");
      if (_this.props.onEntered) {
        _this.props.onEntered(maybeNode, maybeAppearing);
      }
    };
    _this.onExit = function(maybeNode) {
      var _this$resolveArgument4 = _this.resolveArguments(maybeNode), node = _this$resolveArgument4[0];
      _this.removeClasses(node, "appear");
      _this.removeClasses(node, "enter");
      _this.addClass(node, "exit", "base");
      if (_this.props.onExit) {
        _this.props.onExit(maybeNode);
      }
    };
    _this.onExiting = function(maybeNode) {
      var _this$resolveArgument5 = _this.resolveArguments(maybeNode), node = _this$resolveArgument5[0];
      _this.addClass(node, "exit", "active");
      if (_this.props.onExiting) {
        _this.props.onExiting(maybeNode);
      }
    };
    _this.onExited = function(maybeNode) {
      var _this$resolveArgument6 = _this.resolveArguments(maybeNode), node = _this$resolveArgument6[0];
      _this.removeClasses(node, "exit");
      _this.addClass(node, "exit", "done");
      if (_this.props.onExited) {
        _this.props.onExited(maybeNode);
      }
    };
    _this.resolveArguments = function(maybeNode, maybeAppearing) {
      return _this.props.nodeRef ? [_this.props.nodeRef.current, maybeNode] : [maybeNode, maybeAppearing];
    };
    _this.getClassNames = function(type) {
      var classNames2 = _this.props.classNames;
      var isStringClassNames = typeof classNames2 === "string";
      var prefix = isStringClassNames && classNames2 ? classNames2 + "-" : "";
      var baseClassName = isStringClassNames ? "" + prefix + type : classNames2[type];
      var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames2[type + "Active"];
      var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames2[type + "Done"];
      return {
        baseClassName,
        activeClassName,
        doneClassName
      };
    };
    return _this;
  }
  var _proto = CSSTransition2.prototype;
  _proto.addClass = function addClass3(node, type, phase) {
    var className = this.getClassNames(type)[phase + "ClassName"];
    var _this$getClassNames = this.getClassNames("enter"), doneClassName = _this$getClassNames.doneClassName;
    if (type === "appear" && phase === "done" && doneClassName) {
      className += " " + doneClassName;
    }
    if (phase === "active") {
      if (node)
        forceReflow(node);
    }
    if (className) {
      this.appliedClasses[type][phase] = className;
      _addClass(node, className);
    }
  };
  _proto.removeClasses = function removeClasses(node, type) {
    var _this$appliedClasses$ = this.appliedClasses[type], baseClassName = _this$appliedClasses$.base, activeClassName = _this$appliedClasses$.active, doneClassName = _this$appliedClasses$.done;
    this.appliedClasses[type] = {};
    if (baseClassName) {
      removeClass$1(node, baseClassName);
    }
    if (activeClassName) {
      removeClass$1(node, activeClassName);
    }
    if (doneClassName) {
      removeClass$1(node, doneClassName);
    }
  };
  _proto.render = function render() {
    var _this$props = this.props;
    _this$props.classNames;
    var props = _objectWithoutPropertiesLoose$2(_this$props, ["classNames"]);
    return /* @__PURE__ */ t$q.createElement(Transition$2, _extends$4({}, props, {
      onEnter: this.onEnter,
      onEntered: this.onEntered,
      onEntering: this.onEntering,
      onExit: this.onExit,
      onExiting: this.onExiting,
      onExited: this.onExited
    }));
  };
  return CSSTransition2;
}(t$q.Component);
CSSTransition.defaultProps = {
  classNames: ""
};
CSSTransition.propTypes = {};
const z$9 = CSSTransition;
function getChildMapping(children, mapFn) {
  var mapper = function mapper2(child) {
    return mapFn && reactExports.isValidElement(child) ? mapFn(child) : child;
  };
  var result = /* @__PURE__ */ Object.create(null);
  if (children)
    reactExports.Children.map(children, function(c6) {
      return c6;
    }).forEach(function(child) {
      result[child.key] = mapper(child);
    });
  return result;
}
function mergeChildMappings(prev, next) {
  prev = prev || {};
  next = next || {};
  function getValueForKey(key) {
    return key in next ? next[key] : prev[key];
  }
  var nextKeysPending = /* @__PURE__ */ Object.create(null);
  var pendingKeys = [];
  for (var prevKey in prev) {
    if (prevKey in next) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
    } else {
      pendingKeys.push(prevKey);
    }
  }
  var i16;
  var childMapping = {};
  for (var nextKey in next) {
    if (nextKeysPending[nextKey]) {
      for (i16 = 0; i16 < nextKeysPending[nextKey].length; i16++) {
        var pendingNextKey = nextKeysPending[nextKey][i16];
        childMapping[nextKeysPending[nextKey][i16]] = getValueForKey(pendingNextKey);
      }
    }
    childMapping[nextKey] = getValueForKey(nextKey);
  }
  for (i16 = 0; i16 < pendingKeys.length; i16++) {
    childMapping[pendingKeys[i16]] = getValueForKey(pendingKeys[i16]);
  }
  return childMapping;
}
function getProp(child, prop, props) {
  return props[prop] != null ? props[prop] : child.props[prop];
}
function getInitialChildMapping(props, onExited) {
  return getChildMapping(props.children, function(child) {
    return reactExports.cloneElement(child, {
      onExited: onExited.bind(null, child),
      in: true,
      appear: getProp(child, "appear", props),
      enter: getProp(child, "enter", props),
      exit: getProp(child, "exit", props)
    });
  });
}
function getNextChildMapping(nextProps, prevChildMapping, onExited) {
  var nextChildMapping = getChildMapping(nextProps.children);
  var children = mergeChildMappings(prevChildMapping, nextChildMapping);
  Object.keys(children).forEach(function(key) {
    var child = children[key];
    if (!reactExports.isValidElement(child))
      return;
    var hasPrev = key in prevChildMapping;
    var hasNext = key in nextChildMapping;
    var prevChild = prevChildMapping[key];
    var isLeaving = reactExports.isValidElement(prevChild) && !prevChild.props.in;
    if (hasNext && (!hasPrev || isLeaving)) {
      children[key] = reactExports.cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: true,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    } else if (!hasNext && hasPrev && !isLeaving) {
      children[key] = reactExports.cloneElement(child, {
        in: false
      });
    } else if (hasNext && hasPrev && reactExports.isValidElement(prevChild)) {
      children[key] = reactExports.cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: prevChild.props.in,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    }
  });
  return children;
}
var values = Object.values || function(obj) {
  return Object.keys(obj).map(function(k3) {
    return obj[k3];
  });
};
var defaultProps = {
  component: "div",
  childFactory: function childFactory(child) {
    return child;
  }
};
var TransitionGroup = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(TransitionGroup2, _React$Component);
  function TransitionGroup2(props, context2) {
    var _this;
    _this = _React$Component.call(this, props, context2) || this;
    var handleExited = _this.handleExited.bind(_assertThisInitialized$4(_this));
    _this.state = {
      contextValue: {
        isMounting: true
      },
      handleExited,
      firstRender: true
    };
    return _this;
  }
  var _proto = TransitionGroup2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.mounted = true;
    this.setState({
      contextValue: {
        isMounting: false
      }
    });
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.mounted = false;
  };
  TransitionGroup2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
    var prevChildMapping = _ref.children, handleExited = _ref.handleExited, firstRender = _ref.firstRender;
    return {
      children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
      firstRender: false
    };
  };
  _proto.handleExited = function handleExited(child, node) {
    var currentChildMapping = getChildMapping(this.props.children);
    if (child.key in currentChildMapping)
      return;
    if (child.props.onExited) {
      child.props.onExited(node);
    }
    if (this.mounted) {
      this.setState(function(state) {
        var children = _extends$4({}, state.children);
        delete children[child.key];
        return {
          children
        };
      });
    }
  };
  _proto.render = function render() {
    var _this$props = this.props, Component2 = _this$props.component, childFactory2 = _this$props.childFactory, props = _objectWithoutPropertiesLoose$2(_this$props, ["component", "childFactory"]);
    var contextValue = this.state.contextValue;
    var children = values(this.state.children).map(childFactory2);
    delete props.appear;
    delete props.enter;
    delete props.exit;
    if (Component2 === null) {
      return /* @__PURE__ */ t$q.createElement(TransitionGroupContext.Provider, {
        value: contextValue
      }, children);
    }
    return /* @__PURE__ */ t$q.createElement(TransitionGroupContext.Provider, {
      value: contextValue
    }, /* @__PURE__ */ t$q.createElement(Component2, props, children));
  };
  return TransitionGroup2;
}(t$q.Component);
TransitionGroup.propTypes = {};
TransitionGroup.defaultProps = defaultProps;
const q$5 = TransitionGroup;
function MdOutlineQuestionMark(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0z" } }, { "tag": "path", "attr": { "d": "M11.07 12.85c.77-1.39 2.25-2.21 3.11-3.44.91-1.29.4-3.7-2.18-3.7-1.69 0-2.52 1.28-2.87 2.34L6.54 6.96C7.25 4.83 9.18 3 11.99 3c2.35 0 3.96 1.07 4.78 2.41.7 1.15 1.11 3.3.03 4.9-1.2 1.77-2.35 2.31-2.97 3.45-.25.46-.35.76-.35 2.24h-2.89c-.01-.78-.13-2.05.48-3.15zM14 20c0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2 2 .9 2 2z" } }] })(props);
}
const CustomRibbonButton = ({ data: data2 }) => {
  var _a, _b, _c, _d, _e2;
  const ImageList = JSON.parse(localStorage.getItem("ImageList"));
  const ImagesData = JSON.parse(localStorage.getItem("ImagesData"));
  const { socket } = useAppData();
  const { Icon, Caption, Event, ImageIndex, CSS } = data2 == null ? void 0 : data2.Properties;
  const customStyles = parseFlexStyles(CSS);
  const getImageFromData = (data22) => {
    if (data22.Properties && (data22 == null ? void 0 : data22.Properties.ImageListObj)) {
      const imageListObj = data22 == null ? void 0 : data22.Properties.ImageListObj;
      const imageListData = ImagesData == null ? void 0 : ImagesData.find(
        (imageData) => imageData.ID === imageListObj
      );
      if (imageListData) {
        const imageIndex = data22 == null ? void 0 : data22.Properties.ImageIndex;
        const imageUrl = imageListData == null ? void 0 : imageListData.Properties.Files[imageIndex - 1];
        const imageSize = imageListData.Properties.Size;
        return {
          imageUrl,
          imageSize
        };
      }
    }
    return null;
  };
  const ImageData = getImageFromData(data2);
  const handleSelectEvent = () => {
    const selectEvent = JSON.stringify({
      Event: {
        EventName: "Select",
        ID: data2 == null ? void 0 : data2.ID
      }
    });
    const exists = Event && Event.some((item) => item[0] === "Select");
    if (!exists)
      return;
    console.log(selectEvent);
    socket.send(selectEvent);
  };
  const handleButtonEvent = () => {
    handleSelectEvent();
  };
  const IconComponent = AppIcons[Icon] ? AppIcons[Icon] : MdOutlineQuestionMark;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Row, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Col, { md: 12, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      id: data2 == null ? void 0 : data2.ID,
      className: "d-flex align-items-center flex-column justify-content-center",
      onClick: handleButtonEvent,
      style: { cursor: "pointer", ...customStyles },
      children: [
        ImageData ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            style: {
              width: ImageData.imageSize[1],
              height: ImageData.imageSize[0]
            },
            src: `${getCurrentUrl()}${ImageData.imageUrl}`,
            alt: "Image"
          }
        ) : ImageIndex ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            style: {
              width: ((_a = ImageList == null ? void 0 : ImageList.Properties) == null ? void 0 : _a.Size) && ((_b = ImageList == null ? void 0 : ImageList.Properties) == null ? void 0 : _b.Size[1]),
              height: ((_c = ImageList == null ? void 0 : ImageList.Properties) == null ? void 0 : _c.Size) && ((_d = ImageList == null ? void 0 : ImageList.Properties) == null ? void 0 : _d.Size[0])
            },
            src: `${getCurrentUrl()}${(_e2 = ImageList == null ? void 0 : ImageList.Properties) == null ? void 0 : _e2.Files[ImageIndex - 1]}`,
            alt: "Image"
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsx(IconComponent, { size: 35 }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center", style: { fontSize: "12px" }, children: Caption })
      ]
    }
  ) }) });
};
const CustomRibbonButtonGroup = ({ data: data2 }) => {
  const { socket, dataRef } = useAppData();
  let ImageList = JSON.parse(localStorage.getItem("ImageList"));
  const { Captions, Icons, Event, ImageIndex, ImageListObj, CSS } = data2 == null ? void 0 : data2.Properties;
  const customStyles = parseFlexStyles(CSS);
  const colSize = (Captions == null ? void 0 : Captions.length) == 4 ? 6 : 12;
  const handleSelectEvent = (info) => {
    const selectEvent = JSON.stringify({
      Event: {
        EventName: "Select",
        ID: data2 == null ? void 0 : data2.ID,
        Info: [info]
      }
    });
    const exists = Event && Event.some((item) => item[0] === "Select");
    if (!exists)
      return;
    console.log(selectEvent);
    socket.send(selectEvent);
  };
  const handleButtonEvent = (info) => {
    handleSelectEvent(info);
  };
  let ImagesData;
  if (ImageListObj) {
    if (Array.isArray(ImageListObj)) {
      ImagesData = ImageListObj == null ? void 0 : ImageListObj.map((id2) => {
        return id2 && JSON.parse(getObjectById(dataRef.current, id2));
      });
    } else {
      const ID2 = ImageListObj.split(".")[1];
      ImageList = ID2 && JSON.parse(getObjectById(dataRef.current, ID2));
    }
    if (ImagesData) {
      localStorage.setItem("ImagesData", JSON.stringify(ImagesData));
    }
  }
  console.log({ Captions, ImagesData });
  console.log({ ImagesData });
  function getImageDataByCaption(caption) {
    var _a, _b, _c, _d, _e2, _f;
    if (!ImagesData || !ImagesData.length)
      return;
    const captionIndex = (_b = (_a = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _a.Captions) == null ? void 0 : _b.indexOf(caption);
    if (captionIndex === -1) {
      return null;
    }
    const imageListId = (_c = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _c.ImageListObj[captionIndex];
    const imageIndex = (_d = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _d.ImageIndex[captionIndex];
    const imageList = ImagesData == null ? void 0 : ImagesData.find((image) => (image == null ? void 0 : image.ID) === imageListId);
    if (!imageList) {
      return null;
    }
    const img = (_e2 = imageList == null ? void 0 : imageList.Properties) == null ? void 0 : _e2.Files[imageIndex - 1];
    const imgSize = (_f = imageList == null ? void 0 : imageList.Properties) == null ? void 0 : _f.Size;
    return {
      caption,
      imgIndex: imageIndex,
      imgUrl: img,
      imgSize
    };
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "", style: { width: "fit-content" }, children: Captions.map((title2, i16) => {
    var _a, _b, _c, _d, _e2, _f;
    console.log("imgData", title2);
    const result = getImageDataByCaption(title2);
    console.log("imgData", { result });
    const imageIndex = i16;
    const image = result && result.imgUrl ? result.imgUrl : (ImagesData == null ? void 0 : ImagesData[imageIndex]) || ImageList;
    const iconKey = (Icons == null ? void 0 : Icons[i16]) || "MdOutlineQuestionMark";
    const IconComponent = (AppIcons == null ? void 0 : AppIcons[iconKey]) || MdOutlineQuestionMark;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Col,
      {
        id: `${data2 == null ? void 0 : data2.ID}-${i16}`,
        md: colSize,
        className: "d-flex align-items-center justify-content-left gap-1",
        style: { cursor: "pointer", ...customStyles },
        onClick: () => handleButtonEvent(i16 + 1),
        children: [
          result && (result == null ? void 0 : result.imgUrl) ? /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              style: {
                width: result.imgSize[0],
                height: result.imgSize[1]
              },
              src: `${getCurrentUrl()}${result.imgUrl}`,
              alt: title2
            }
          ) : image ? /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              style: {
                width: (_b = (_a = ImageList == null ? void 0 : ImageList.Properties) == null ? void 0 : _a.Size) == null ? void 0 : _b[1],
                height: (_d = (_c = ImageList == null ? void 0 : ImageList.Properties) == null ? void 0 : _c.Size) == null ? void 0 : _d[0]
              },
              src: `${getCurrentUrl()}${(_f = (_e2 = image == null ? void 0 : image.Properties) == null ? void 0 : _e2.Files) == null ? void 0 : _f[imageIndex]}`,
              alt: title2
            }
          ) : /* @__PURE__ */ jsxRuntimeExports.jsx(IconComponent, { size: 35 }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              style: {
                fontSize: "12px",
                textAlign: "center",
                textOverflow: "ellipsis"
              },
              children: title2
            }
          )
        ]
      },
      `col-${i16}`
    );
  }) });
};
const Poly = ({ data: data2 }) => {
  const { FCol, FillCol, LWidth, Points, FStyle, Visible, Event, CSS } = data2 == null ? void 0 : data2.Properties;
  const { socket } = useAppData();
  const customStyles = parseFlexStyles(CSS);
  const parentSize = JSON.parse(localStorage.getItem("formDimension"));
  const hasFCol = data2 == null ? void 0 : data2.Properties.hasOwnProperty("FCol");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      id: data2 == null ? void 0 : data2.ID,
      style: { position: "absolute", display: Visible == 0 ? "none" : "block", ...customStyles },
      onMouseDown: (e3) => {
        handleMouseDown(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseUp: (e3) => {
        handleMouseUp(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseEnter: (e3) => {
        handleMouseEnter(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseMove: (e3) => {
        handleMouseMove(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseLeave: (e3) => {
        handleMouseLeave(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onWheel: (e3) => {
        handleMouseWheel(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onDoubleClick: (e3) => {
        handleMouseDoubleClick(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "svg",
        {
          height: parentSize && parentSize[0],
          width: parentSize && parentSize[1],
          children: Points == null ? void 0 : Points.map((polygonPoints, index2) => {
            const flatArray = polygonPoints && polygonPoints[0].map((x3, i16) => [polygonPoints[1][i16], x3]);
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              "polygon",
              {
                id: index2,
                points: flatArray && flatArray.flat().join(" "),
                fill: FStyle && FStyle[index2] == "-1" ? "none" : FillCol && rgbColor(FillCol[index2]),
                stroke: hasFCol ? FCol && rgbColor(FCol[index2]) : "rgb(0,0,0)",
                "stroke-width": LWidth && LWidth[index2]
              },
              index2
            );
          })
        }
      )
    }
  );
};
var defaultData = {
  en: {
    name: "en",
    identity: {
      version: {
        _unicodeVersion: "14.0.0",
        _cldrVersion: "41"
      },
      language: "en"
    },
    territory: "US",
    numbers: {
      symbols: {
        decimal: ".",
        group: ",",
        list: ";",
        percentSign: "%",
        plusSign: "+",
        minusSign: "-",
        exponential: "E",
        superscriptingExponent: "",
        perMille: "",
        infinity: "",
        nan: "NaN",
        timeSeparator: ":",
        approximatelySign: "~"
      },
      decimal: {
        patterns: [
          "n"
        ],
        groupSize: [
          3
        ]
      },
      scientific: {
        patterns: [
          "nEn"
        ],
        groupSize: []
      },
      percent: {
        patterns: [
          "n%"
        ],
        groupSize: [
          3
        ]
      },
      currency: {
        patterns: [
          "$n"
        ],
        groupSize: [
          3
        ],
        "unitPattern-count-one": "n $",
        "unitPattern-count-other": "n $"
      },
      currencies: {
        BGN: {
          displayName: "Bulgarian Lev",
          "displayName-count-one": "Bulgarian lev",
          "displayName-count-other": "Bulgarian leva",
          symbol: "BGN"
        },
        EUR: {
          displayName: "Euro",
          "displayName-count-one": "euro",
          "displayName-count-other": "euros",
          symbol: "",
          "symbol-alt-narrow": ""
        },
        USD: {
          displayName: "US Dollar",
          "displayName-count-one": "US dollar",
          "displayName-count-other": "US dollars",
          symbol: "$",
          "symbol-alt-narrow": "$"
        }
      },
      localeCurrency: "USD",
      accounting: {
        patterns: [
          "$n",
          "($n)"
        ],
        groupSize: [
          3
        ]
      }
    },
    calendar: {
      gmtFormat: "GMT{0}",
      gmtZeroFormat: "GMT",
      patterns: {
        d: "M/d/y",
        D: "EEEE, MMMM d, y",
        m: "MMM d",
        M: "MMMM d",
        y: "MMM y",
        Y: "MMMM y",
        F: "EEEE, MMMM d, y h:mm:ss a",
        g: "M/d/y h:mm a",
        G: "M/d/y h:mm:ss a",
        t: "h:mm a",
        T: "h:mm:ss a",
        s: "yyyy'-'MM'-'dd'T'HH':'mm':'ss",
        u: "yyyy'-'MM'-'dd HH':'mm':'ss'Z'"
      },
      dateTimeFormats: {
        full: "{1} 'at' {0}",
        long: "{1} 'at' {0}",
        medium: "{1}, {0}",
        short: "{1}, {0}",
        availableFormats: {
          Bh: "h B",
          Bhm: "h:mm B",
          Bhms: "h:mm:ss B",
          d: "d",
          E: "ccc",
          EBhm: "E h:mm B",
          EBhms: "E h:mm:ss B",
          Ed: "d E",
          Ehm: "E h:mm a",
          EHm: "E HH:mm",
          Ehms: "E h:mm:ss a",
          EHms: "E HH:mm:ss",
          Gy: "y G",
          GyMd: "M/d/y GGGGG",
          GyMMM: "MMM y G",
          GyMMMd: "MMM d, y G",
          GyMMMEd: "E, MMM d, y G",
          h: "h a",
          H: "HH",
          hm: "h:mm a",
          Hm: "HH:mm",
          hms: "h:mm:ss a",
          Hms: "HH:mm:ss",
          hmsv: "h:mm:ss a v",
          Hmsv: "HH:mm:ss v",
          hmv: "h:mm a v",
          Hmv: "HH:mm v",
          M: "L",
          Md: "M/d",
          MEd: "E, M/d",
          MMM: "LLL",
          MMMd: "MMM d",
          MMMEd: "E, MMM d",
          MMMMd: "MMMM d",
          "MMMMW-count-one": "'week' W 'of' MMMM",
          "MMMMW-count-other": "'week' W 'of' MMMM",
          ms: "mm:ss",
          y: "y",
          yM: "M/y",
          yMd: "M/d/y",
          yMEd: "E, M/d/y",
          yMMM: "MMM y",
          yMMMd: "MMM d, y",
          yMMMEd: "E, MMM d, y",
          yMMMM: "MMMM y",
          yQQQ: "QQQ y",
          yQQQQ: "QQQQ y",
          "yw-count-one": "'week' w 'of' Y",
          "yw-count-other": "'week' w 'of' Y"
        }
      },
      timeFormats: {
        full: "h:mm:ss a zzzz",
        long: "h:mm:ss a z",
        medium: "h:mm:ss a",
        short: "h:mm a"
      },
      dateFormats: {
        full: "EEEE, MMMM d, y",
        long: "MMMM d, y",
        medium: "MMM d, y",
        short: "M/d/yy"
      },
      days: {
        format: {
          abbreviated: [
            "Sun",
            "Mon",
            "Tue",
            "Wed",
            "Thu",
            "Fri",
            "Sat"
          ],
          narrow: [
            "S",
            "M",
            "T",
            "W",
            "T",
            "F",
            "S"
          ],
          short: [
            "Su",
            "Mo",
            "Tu",
            "We",
            "Th",
            "Fr",
            "Sa"
          ],
          wide: [
            "Sunday",
            "Monday",
            "Tuesday",
            "Wednesday",
            "Thursday",
            "Friday",
            "Saturday"
          ]
        },
        "stand-alone": {
          abbreviated: [
            "Sun",
            "Mon",
            "Tue",
            "Wed",
            "Thu",
            "Fri",
            "Sat"
          ],
          narrow: [
            "S",
            "M",
            "T",
            "W",
            "T",
            "F",
            "S"
          ],
          short: [
            "Su",
            "Mo",
            "Tu",
            "We",
            "Th",
            "Fr",
            "Sa"
          ],
          wide: [
            "Sunday",
            "Monday",
            "Tuesday",
            "Wednesday",
            "Thursday",
            "Friday",
            "Saturday"
          ]
        }
      },
      months: {
        format: {
          abbreviated: [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"
          ],
          narrow: [
            "J",
            "F",
            "M",
            "A",
            "M",
            "J",
            "J",
            "A",
            "S",
            "O",
            "N",
            "D"
          ],
          wide: [
            "January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December"
          ]
        },
        "stand-alone": {
          abbreviated: [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"
          ],
          narrow: [
            "J",
            "F",
            "M",
            "A",
            "M",
            "J",
            "J",
            "A",
            "S",
            "O",
            "N",
            "D"
          ],
          wide: [
            "January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December"
          ]
        }
      },
      quarters: {
        format: {
          abbreviated: [
            "Q1",
            "Q2",
            "Q3",
            "Q4"
          ],
          narrow: [
            "1",
            "2",
            "3",
            "4"
          ],
          wide: [
            "1st quarter",
            "2nd quarter",
            "3rd quarter",
            "4th quarter"
          ]
        },
        "stand-alone": {
          abbreviated: [
            "Q1",
            "Q2",
            "Q3",
            "Q4"
          ],
          narrow: [
            "1",
            "2",
            "3",
            "4"
          ],
          wide: [
            "1st quarter",
            "2nd quarter",
            "3rd quarter",
            "4th quarter"
          ]
        }
      },
      dayPeriods: {
        format: {
          abbreviated: {
            midnight: "midnight",
            am: "AM",
            "am-alt-variant": "am",
            noon: "noon",
            pm: "PM",
            "pm-alt-variant": "pm",
            morning1: "in the morning",
            afternoon1: "in the afternoon",
            evening1: "in the evening",
            night1: "at night"
          },
          narrow: {
            midnight: "mi",
            am: "a",
            "am-alt-variant": "am",
            noon: "n",
            pm: "p",
            "pm-alt-variant": "pm",
            morning1: "in the morning",
            afternoon1: "in the afternoon",
            evening1: "in the evening",
            night1: "at night"
          },
          wide: {
            midnight: "midnight",
            am: "AM",
            "am-alt-variant": "am",
            noon: "noon",
            pm: "PM",
            "pm-alt-variant": "pm",
            morning1: "in the morning",
            afternoon1: "in the afternoon",
            evening1: "in the evening",
            night1: "at night"
          }
        },
        "stand-alone": {
          abbreviated: {
            midnight: "midnight",
            am: "AM",
            "am-alt-variant": "am",
            noon: "noon",
            pm: "PM",
            "pm-alt-variant": "pm",
            morning1: "morning",
            afternoon1: "afternoon",
            evening1: "evening",
            night1: "night"
          },
          narrow: {
            midnight: "midnight",
            am: "AM",
            "am-alt-variant": "am",
            noon: "noon",
            pm: "PM",
            "pm-alt-variant": "pm",
            morning1: "morning",
            afternoon1: "afternoon",
            evening1: "evening",
            night1: "night"
          },
          wide: {
            midnight: "midnight",
            am: "AM",
            "am-alt-variant": "am",
            noon: "noon",
            pm: "PM",
            "pm-alt-variant": "pm",
            morning1: "morning",
            afternoon1: "afternoon",
            evening1: "evening",
            night1: "night"
          }
        }
      },
      eras: {
        format: {
          wide: {
            "0": "Before Christ",
            "1": "Anno Domini",
            "0-alt-variant": "Before Common Era",
            "1-alt-variant": "Common Era"
          },
          abbreviated: {
            "0": "BC",
            "1": "AD",
            "0-alt-variant": "BCE",
            "1-alt-variant": "CE"
          },
          narrow: {
            "0": "B",
            "1": "A",
            "0-alt-variant": "BCE",
            "1-alt-variant": "CE"
          }
        }
      },
      dateFields: {
        era: {
          wide: "era",
          short: "era",
          narrow: "era"
        },
        year: {
          wide: "year",
          short: "yr.",
          narrow: "yr."
        },
        quarter: {
          wide: "quarter",
          short: "qtr.",
          narrow: "qtr."
        },
        month: {
          wide: "month",
          short: "mo.",
          narrow: "mo."
        },
        week: {
          wide: "week",
          short: "wk.",
          narrow: "wk."
        },
        weekOfMonth: {
          wide: "week of month",
          short: "wk. of mo.",
          narrow: "wk. of mo."
        },
        day: {
          wide: "day",
          short: "day",
          narrow: "day"
        },
        dayOfYear: {
          wide: "day of year",
          short: "day of yr.",
          narrow: "day of yr."
        },
        weekday: {
          wide: "day of the week",
          short: "day of wk.",
          narrow: "day of wk."
        },
        weekdayOfMonth: {
          wide: "weekday of the month",
          short: "wkday. of mo.",
          narrow: "wkday. of mo."
        },
        dayperiod: {
          short: "AM/PM",
          wide: "AM/PM",
          narrow: "AM/PM"
        },
        hour: {
          wide: "hour",
          short: "hr.",
          narrow: "hr."
        },
        minute: {
          wide: "minute",
          short: "min.",
          narrow: "min."
        },
        second: {
          wide: "second",
          short: "sec.",
          narrow: "sec."
        },
        zone: {
          wide: "time zone",
          short: "zone",
          narrow: "zone"
        },
        millisecond: {
          narrow: "ms",
          short: "ms",
          wide: "millisecond"
        }
      }
    }
  },
  supplemental: {
    likelySubtags: {
      en: "en-Latn-US"
    },
    currencyData: {
      region: {
        US: [
          {
            USD: {
              _from: "1792-01-01"
            }
          }
        ]
      }
    },
    weekData: {
      firstDay: {
        US: "sun"
      },
      weekendStart: {
        "001": "sat"
      },
      weekendEnd: {
        "001": "sun"
      }
    }
  }
};
function isString$3(value2) {
  return typeof value2 === "string";
}
const errorDetails = {
  "NoLocale": "Missing locale info for '{0}'",
  "NoCurrency": "Cannot determine currency information. Please load the locale currencies data.",
  "NoSupplementalCurrency": "Cannot determine currency. Please load the supplemental currencyData.",
  "NoCurrencyRegion": "No currency data for region '{0}'",
  "NoCurrencyDisplay": "Cannot determine currency display information. Please load the locale currencies data. The default culture does not include the all currencies data.",
  "NoGMTInfo": "Cannot determine locale GMT format. Please load the locale timeZoneNames data.",
  "NoWeekData": "Cannot determine locale first day of week. Please load the supplemental weekData.",
  "NoFirstDay": "Cannot determine locale first day of week. Please load the supplemental weekData. The default culture includes only the 'en-US' first day info.",
  "NoValidCurrency": "Cannot determine a default currency for the {0} locale. Please specify explicitly the currency with the format options.",
  "NoDateFieldNames": "Cannot determine the locale date field names. Please load the locale dateFields data."
};
var formatRegExp$2 = /\{(\d+)}?\}/g;
var IntlError = function IntlError2(ref2) {
  var name2 = ref2.name;
  var message = ref2.message;
  if (!name2 || !message) {
    throw new Error("{ name: string, message: string } object is required!");
  }
  this.name = name2;
  this.message = message;
};
IntlError.prototype.formatMessage = function formatMessage() {
  var values6 = [], len = arguments.length;
  while (len--)
    values6[len] = arguments[len];
  var flattenValues = flatten(values6);
  var formattedMessage = this.message.replace(formatRegExp$2, function(match2, index2) {
    return flattenValues[parseInt(index2, 10)];
  });
  return this.name + ": " + formattedMessage;
};
IntlError.prototype.error = function error() {
  var values6 = [], len = arguments.length;
  while (len--)
    values6[len] = arguments[len];
  return new Error(this.formatMessage(values6));
};
var flatten = function(arr) {
  return arr.reduce(function(a9, b2) {
    return a9.concat(b2);
  }, []);
};
var toIntlErrors = function(errors2) {
  var predicate = function(prev, name2) {
    prev[name2] = new IntlError({ name: name2, message: errors2[name2] });
    return prev;
  };
  return Object.keys(errors2).reduce(predicate, {});
};
var errors = toIntlErrors(errorDetails);
function availableLocaleInfo(fullName, suffixes) {
  var parts = fullName.split("-");
  var language = parts[0];
  var script = parts[1];
  var territory = parts[2];
  return cldr[fullName] || suffixes.indexOf(territory) !== -1 && cldr[language + "-" + territory] || suffixes.indexOf(script) !== -1 && cldr[language + "-" + script] || cldr[language];
}
function localeFullName(language, suffixes) {
  var likelySubtags = cldr.supplemental.likelySubtags;
  for (var idx = 0; idx < suffixes.length; idx++) {
    var name2 = likelySubtags[language + "-" + suffixes[idx]];
    if (name2) {
      return name2;
    }
  }
  if (likelySubtags[language]) {
    return likelySubtags[language];
  }
}
var cldr = defaultData;
function getLocaleInfo(locale) {
  var info;
  if (isString$3(locale)) {
    info = localeInfo(locale);
  } else {
    info = locale;
  }
  return info;
}
function localeInfo(locale) {
  if (cldr[locale]) {
    return cldr[locale];
  }
  var likelySubtags = cldr.supplemental.likelySubtags;
  if (likelySubtags) {
    var parts = locale.split("-");
    var language = parts[0];
    var suffixes = parts.slice(1);
    var fullName = localeFullName(language, suffixes);
    var info = fullName ? availableLocaleInfo(fullName, suffixes) : null;
    if (info) {
      return info;
    }
  }
  throw errors.NoLocale.error(locale);
}
var DECIMAL = "decimal";
var CURRENCY = "currency";
var ACCOUNTING = "accounting";
var PERCENT = "percent";
var SCIENTIFIC = "scientific";
var CURRENCY_PLACEHOLDER = "$";
var PERCENT_PLACEHOLDER = "%";
var NUMBER_PLACEHOLDER = "n";
var LIST_SEPARATOR = ";";
var GROUP_SEPARATOR = ",";
var POINT = ".";
var EMPTY = "";
var DEFAULT_LOCALE = "en";
function territoryFromName(name2, identity) {
  var likelySubtags = cldr.supplemental.likelySubtags;
  var parts = name2.split("-");
  if (likelySubtags) {
    var likelyName = likelySubtags[name2] || likelySubtags[parts[0]];
    if (likelyName) {
      parts = likelyName.split("-");
    }
  }
  if (identity) {
    for (var idx = parts.length - 1; idx >= 1; idx--) {
      var part = parts[idx];
      if (part === identity.variant || part === identity.script) {
        parts.splice(idx, 1);
      }
    }
  }
  var length = parts.length;
  if (length > 1) {
    var territory = parts[length - 1];
    return territory.toUpperCase();
  }
}
function localeTerritory(info) {
  if (info.territory) {
    return info.territory;
  }
  var name2 = info.name;
  var identity = info.identity;
  var territory;
  if (identity && identity.territory) {
    territory = identity.territory;
  } else {
    territory = territoryFromName(name2, identity);
  }
  info.territory = territory;
  return territory;
}
function dateFieldName(options2, locale) {
  if (locale === void 0)
    locale = DEFAULT_LOCALE;
  var info = localeInfo(locale);
  var dateFields = info.calendar.dateFields;
  if (!dateFields) {
    throw errors.NoDateFieldNames.error();
  }
  var fieldNameInfo = dateFields[options2.type] || {};
  return fieldNameInfo[options2.nameType] || fieldNameInfo["wide"];
}
function lowerArray(arr) {
  var result = [];
  for (var idx = 0; idx < arr.length; idx++) {
    result.push(arr[idx].toLowerCase());
  }
  return result;
}
function lowerObject(obj) {
  var result = {};
  for (var field in obj) {
    result[field] = obj[field].toLowerCase();
  }
  return result;
}
function cloneLower(obj) {
  var result = Array.isArray(obj) ? lowerArray(obj) : lowerObject(obj);
  return result;
}
function dateFormatNames(locale, options2) {
  var type = options2.type;
  var nameType = options2.nameType;
  var standAlone = options2.standAlone;
  var lower = options2.lower;
  var info = getLocaleInfo(locale);
  var formatType = standAlone ? "stand-alone" : "format";
  var lowerNameType = (lower ? "lower-" : EMPTY) + nameType;
  var formatNames2 = info.calendar[type][formatType];
  var result = formatNames2[lowerNameType];
  if (!result && lower) {
    result = formatNames2[lowerNameType] = cloneLower(formatNames2[nameType]);
  }
  return result;
}
function parseRangeDate(value2) {
  var parts = value2.split("-");
  var year = parseInt(parts[0], 10);
  var month = parseInt(parts[1], 10) - 1;
  var day = parseInt(parts[2], 10);
  return new Date(year, month, day);
}
var NoCurrency = errors.NoCurrency;
var NoCurrencyDisplay = errors.NoCurrencyDisplay;
var NoSupplementalCurrency = errors.NoSupplementalCurrency;
var NoCurrencyRegion = errors.NoCurrencyRegion;
var NoValidCurrency = errors.NoValidCurrency;
var DEFAULT_CURRENCY_FRACTIONS = 2;
var SYMBOL = "symbol";
var INVALID_CURRENCY_CODE = "XXX";
var GLOBAL_CURRENCIES = {
  "001": "USD",
  // 001 refers to world. not sure if it is correct to assume USD but seems better than throw an error
  "150": "EUR"
  // 150 territory for Europe
};
function getCurrencyInfo(locale, currency, throwIfNoValid) {
  var info = getLocaleInfo(locale);
  var currencies = info.numbers.currencies;
  if (!currencies) {
    if (throwIfNoValid) {
      throw NoCurrency.error();
    }
    return;
  }
  var currencyDisplayInfo = currencies[currency];
  if (!currencyDisplayInfo) {
    if (throwIfNoValid) {
      throw NoCurrencyDisplay.error();
    }
    return;
  }
  return currencyDisplayInfo;
}
function lengthComparer(a9, b2) {
  return b2.length - a9.length;
}
function regionCurrency(regionCurrencies) {
  var latestValidUntil, latestValidUntilRange;
  var latestStillValid, latestStillValidDate;
  for (var idx = 0; idx < regionCurrencies.length; idx++) {
    var currency = regionCurrencies[idx];
    var code = Object.keys(currency)[0];
    var info = currency[code];
    if (code !== INVALID_CURRENCY_CODE && info._tender !== "false" && info._from) {
      if (!info._to) {
        var stillValidDate = parseRangeDate(info._from);
        if (!latestStillValidDate || latestStillValidDate < stillValidDate) {
          latestStillValid = code;
          latestStillValidDate = stillValidDate;
        }
      } else if (!latestStillValid) {
        var validFrom = parseRangeDate(info._from);
        var validTo = parseRangeDate(info._to);
        if (!latestValidUntilRange || latestValidUntilRange.to < validTo || latestValidUntilRange.from < validFrom) {
          latestValidUntil = code;
          latestValidUntilRange = {
            from: validFrom,
            to: validTo
          };
        }
      }
    }
  }
  return latestStillValid || latestValidUntil;
}
function currencyDisplays(locale, currency, throwIfNoValid) {
  if (throwIfNoValid === void 0)
    throwIfNoValid = true;
  var currencyInfo = getCurrencyInfo(locale, currency, throwIfNoValid);
  if (!currencyInfo) {
    return;
  }
  if (!currencyInfo.displays) {
    var displays = [currency];
    for (var field in currencyInfo) {
      displays.push(currencyInfo[field]);
    }
    displays.sort(lengthComparer);
    currencyInfo.displays = displays;
  }
  return currencyInfo.displays;
}
function currencyDisplay(locale, options2) {
  var value2 = options2.value;
  var currency = options2.currency;
  var currencyDisplay2 = options2.currencyDisplay;
  if (currencyDisplay2 === void 0)
    currencyDisplay2 = SYMBOL;
  if (currencyDisplay2 === "code") {
    return currency;
  }
  var currencyInfo = getCurrencyInfo(locale, currency, true);
  var result;
  if (currencyDisplay2 === SYMBOL) {
    result = currencyInfo["symbol-alt-narrow"] || currencyInfo[SYMBOL] || currency;
  } else {
    if (typeof value2 === "undefined" || value2 !== 1) {
      result = currencyInfo["displayName-count-other"];
    } else {
      result = currencyInfo["displayName-count-one"];
    }
  }
  return result;
}
function currencyFractionOptions(code) {
  var minimumFractionDigits = DEFAULT_CURRENCY_FRACTIONS;
  var maximumFractionDigits = DEFAULT_CURRENCY_FRACTIONS;
  var fractions = ((cldr.supplemental.currencyData || {}).fractions || {})[code];
  if (fractions && fractions._digits) {
    maximumFractionDigits = minimumFractionDigits = parseInt(fractions._digits, 10);
  }
  return {
    minimumFractionDigits,
    maximumFractionDigits
  };
}
function territoryCurrencyCode(territory, throwIfNoValid) {
  if (throwIfNoValid === void 0)
    throwIfNoValid = true;
  if (GLOBAL_CURRENCIES[territory]) {
    return GLOBAL_CURRENCIES[territory];
  }
  var currencyData = cldr.supplemental.currencyData;
  if (!currencyData) {
    if (throwIfNoValid) {
      throw NoSupplementalCurrency.error();
    }
    return;
  }
  var regionCurrencies = currencyData.region[territory];
  if (!regionCurrencies) {
    if (throwIfNoValid) {
      throw NoCurrencyRegion.error(territory);
    }
    return;
  }
  var currencyCode = regionCurrency(regionCurrencies);
  return currencyCode;
}
function localeCurrency(locale, throwIfNoValid) {
  var info = getLocaleInfo(locale);
  var numbers = info.numbers;
  if (!numbers.localeCurrency) {
    var currency = territoryCurrencyCode(localeTerritory(info), throwIfNoValid);
    if (!currency && throwIfNoValid) {
      throw NoValidCurrency.error(info.name);
    }
    numbers.localeCurrency = currency;
  }
  return numbers.localeCurrency;
}
var DAYS_OF_WEEK = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];
var DEFAULT_TERRITORY = "001";
var NoWeekData = errors.NoWeekData;
var NoFirstDay = errors.NoFirstDay;
function firstDay$1(locale) {
  var info = getLocaleInfo(locale);
  if (!isNaN(info.firstDay)) {
    return info.firstDay;
  }
  var weekData = cldr.supplemental.weekData;
  if (!weekData) {
    throw NoWeekData.error();
  }
  var firstDay2 = weekData.firstDay[localeTerritory(info)] || weekData.firstDay[DEFAULT_TERRITORY];
  if (!firstDay2) {
    throw NoFirstDay.error();
  }
  info.firstDay = DAYS_OF_WEEK.indexOf(firstDay2);
  return info.firstDay;
}
errors.NoWeekData;
function numberSymbols(locale) {
  var info = getLocaleInfo(locale);
  return info.numbers.symbols;
}
function isNegativeZero(value2) {
  return 1 / value2 === -Infinity;
}
function formatCurrencySymbol(info, options2) {
  if (options2 === void 0)
    options2 = {};
  if (!options2.currency) {
    options2.currency = localeCurrency(info, true);
  }
  var display = currencyDisplay(info, options2);
  return display;
}
function groupInteger(number, start, end, options2, info) {
  var symbols = info.numbers.symbols;
  var decimalIndex = number.indexOf(symbols.decimal);
  var groupSizes = options2.groupSize.slice();
  var groupSize = groupSizes.shift();
  var integerEnd = decimalIndex !== -1 ? decimalIndex : end + 1;
  var integer = number.substring(start, integerEnd);
  var result = number;
  var integerLength = integer.length;
  if (integerLength >= groupSize) {
    var idx = integerLength;
    var parts = [];
    while (idx > -1) {
      var value2 = integer.substring(idx - groupSize, idx);
      if (value2) {
        parts.push(value2);
      }
      idx -= groupSize;
      var newGroupSize = groupSizes.shift();
      groupSize = newGroupSize !== void 0 ? newGroupSize : groupSize;
      if (groupSize === 0) {
        value2 = integer.substring(0, idx);
        if (value2) {
          parts.push(value2);
        }
        break;
      }
    }
    integer = parts.reverse().join(symbols.group);
    result = number.substring(0, start) + integer + number.substring(integerEnd);
  }
  return result;
}
function isCurrencyStyle(style2) {
  return style2 === CURRENCY || style2 === ACCOUNTING;
}
function pad$1(number, digits, right) {
  if (digits === void 0)
    digits = 2;
  if (right === void 0)
    right = false;
  var count = digits - String(number).length;
  var result = number;
  if (count > 0) {
    var padString = new Array(count + 1).join("0");
    result = right ? number + padString : padString + number;
  }
  return result;
}
var MAX_PRECISION = 20;
function round$3(value2, precision) {
  var result = value2;
  var decimals = precision || 0;
  result = result.toString().split("e");
  result = Math.round(Number(result[0] + "e" + (result[1] ? Number(result[1]) + decimals : decimals)));
  result = result.toString().split("e");
  result = Number(result[0] + "e" + (result[1] ? Number(result[1]) - decimals : -decimals));
  return result.toFixed(Math.min(decimals, MAX_PRECISION));
}
var DEFAULT_DECIMAL_ROUNDING = 3;
var DEFAULT_PERCENT_ROUNDING = 0;
var trailingZeroRegex = /0+$/;
function fractionOptions(options2) {
  var minimumFractionDigits = options2.minimumFractionDigits;
  var maximumFractionDigits = options2.maximumFractionDigits;
  var style2 = options2.style;
  var isCurrency = isCurrencyStyle(style2);
  var currencyFractions;
  if (isCurrency) {
    currencyFractions = currencyFractionOptions(options2.currency);
  }
  if (minimumFractionDigits === void 0) {
    minimumFractionDigits = isCurrency ? currencyFractions.minimumFractionDigits : 0;
  }
  if (maximumFractionDigits === void 0) {
    if (style2 === PERCENT) {
      maximumFractionDigits = Math.max(minimumFractionDigits, DEFAULT_PERCENT_ROUNDING);
    } else if (isCurrency) {
      maximumFractionDigits = Math.max(minimumFractionDigits, currencyFractions.maximumFractionDigits);
    } else {
      maximumFractionDigits = Math.max(minimumFractionDigits, DEFAULT_DECIMAL_ROUNDING);
    }
  }
  return {
    minimumFractionDigits,
    maximumFractionDigits
  };
}
function applyPattern(value2, pattern, symbol) {
  var result = EMPTY;
  for (var idx = 0, length = pattern.length; idx < length; idx++) {
    var ch2 = pattern.charAt(idx);
    if (ch2 === NUMBER_PLACEHOLDER) {
      result += value2;
    } else if (ch2 === CURRENCY_PLACEHOLDER || ch2 === PERCENT_PLACEHOLDER) {
      result += symbol;
    } else {
      result += ch2;
    }
  }
  return result;
}
function currencyUnitPattern(info, value2) {
  var currencyInfo = info.numbers.currency;
  var pattern = value2 !== 1 ? currencyInfo["unitPattern-count-other"] : currencyInfo["unitPattern-count-one"];
  if (value2 < 0) {
    pattern = pattern.replace(NUMBER_PLACEHOLDER, "-" + NUMBER_PLACEHOLDER);
  }
  return pattern;
}
function standardNumberFormat(number, options2, info) {
  var symbols = info.numbers.symbols;
  var style2 = options2.style;
  var isCurrency = isCurrencyStyle(style2);
  if (style2 === SCIENTIFIC) {
    var exponential = options2.minimumFractionDigits !== void 0 ? number.toExponential(options2.minimumFractionDigits) : number.toExponential();
    return exponential.replace(POINT, symbols.decimal);
  }
  var value2 = number;
  var symbol;
  if (isCurrency) {
    options2.value = value2;
    symbol = formatCurrencySymbol(info, options2);
  }
  if (style2 === PERCENT) {
    value2 *= 100;
    symbol = symbols.percentSign;
  }
  var ref2 = fractionOptions(options2);
  var minimumFractionDigits = ref2.minimumFractionDigits;
  var maximumFractionDigits = ref2.maximumFractionDigits;
  value2 = round$3(value2, maximumFractionDigits);
  var negative = value2 < 0;
  var negativeZero = isNegativeZero(number);
  var parts = value2.split(POINT);
  var integer = parts[0];
  var fraction = pad$1(parts[1] ? parts[1].replace(trailingZeroRegex, EMPTY) : EMPTY, minimumFractionDigits, true);
  if (negative) {
    integer = integer.substring(1);
  }
  if (options2.minimumIntegerDigits) {
    integer = pad$1(integer, options2.minimumIntegerDigits);
  }
  var formattedValue = options2.useGrouping !== false ? groupInteger(integer, 0, integer.length, options2, info) : integer;
  if (fraction) {
    formattedValue += symbols.decimal + fraction;
  }
  var pattern;
  if (isCurrency && options2.currencyDisplay === "name") {
    pattern = currencyUnitPattern(info, number);
  } else {
    var patterns = options2.patterns;
    pattern = negative || negativeZero ? patterns[1] || "-" + patterns[0] : patterns[0];
  }
  if (pattern === NUMBER_PLACEHOLDER && !negative) {
    return formattedValue;
  }
  var result = applyPattern(formattedValue, pattern, symbol);
  return result;
}
var literalRegExp = /(\\.)|(['][^']*[']?)|(["][^"]*["]?)/g;
var PLACEHOLDER$1 = "__??__";
function setStyleOptions(formatOptions2, info) {
  var format2 = formatOptions2.format;
  if (format2.indexOf(PERCENT_PLACEHOLDER) !== -1) {
    formatOptions2.style = PERCENT;
    formatOptions2.symbol = info.numbers.symbols.percentSign;
    formatOptions2.number *= 100;
  }
  if (format2.indexOf(CURRENCY_PLACEHOLDER) !== -1) {
    formatOptions2.style = CURRENCY;
    formatOptions2.symbol = formatCurrencySymbol(info);
  }
}
function setFormatLiterals(formatOptions2) {
  var format2 = formatOptions2.format;
  if (format2.indexOf("'") > -1 || format2.indexOf('"') > -1 || format2.indexOf("\\") > -1) {
    var literals2 = formatOptions2.literals = [];
    formatOptions2.format = format2.replace(literalRegExp, function(match2) {
      var quoteChar = match2.charAt(0).replace("\\", EMPTY);
      var literal = match2.slice(1).replace(quoteChar, EMPTY);
      literals2.push(literal);
      return PLACEHOLDER$1;
    });
  }
}
function replaceLiterals(number, literals2) {
  var result = number;
  if (literals2) {
    var length = literals2.length;
    for (var idx = 0; idx < length; idx++) {
      result = result.replace(PLACEHOLDER$1, literals2[idx]);
    }
  }
  return result;
}
var SHARP = "#";
var ZERO$1 = "0";
var trailingZerosRegExp = /(\.(?:[0-9]*[1-9])?)0+$/g;
var trailingPointRegExp = /\.$/;
var commaRegExp = /,/g;
function trimTrailingZeros(value2, lastZero) {
  var trimRegex;
  if (lastZero === 0) {
    trimRegex = trailingZerosRegExp;
  } else {
    trimRegex = new RegExp("(\\.[0-9]{" + lastZero + "}[1-9]*)0+$", "g");
  }
  return value2.replace(trimRegex, "$1").replace(trailingPointRegExp, EMPTY);
}
function roundNumber(formatOptions2) {
  var number = formatOptions2.number;
  var format2 = formatOptions2.format;
  var decimalIndex = format2.indexOf(POINT);
  if (decimalIndex !== -1) {
    var zeroIndex = format2.lastIndexOf(ZERO$1) - decimalIndex;
    var sharpIndex = format2.lastIndexOf(SHARP) - decimalIndex;
    var hasZero = zeroIndex > -1;
    var hasSharp = sharpIndex > -1;
    var fraction = number.toString().split("e");
    if (fraction[1]) {
      fraction = round$3(number, Math.abs(fraction[1]));
    } else {
      fraction = fraction[0];
    }
    fraction = fraction.split(POINT)[1] || EMPTY;
    var precision = fraction.length;
    var trailingZeros = -1;
    if (!hasZero && !hasSharp) {
      formatOptions2.format = format2.substring(0, decimalIndex) + format2.substring(decimalIndex + 1);
      decimalIndex = -1;
      precision = 0;
    } else if (hasZero && zeroIndex > sharpIndex) {
      precision = zeroIndex;
    } else if (sharpIndex > zeroIndex) {
      if (hasSharp && precision > sharpIndex) {
        precision = sharpIndex;
      } else if (hasZero && precision < zeroIndex) {
        precision = zeroIndex;
      }
      trailingZeros = hasZero ? zeroIndex : 0;
    }
    if (precision > -1) {
      number = round$3(number, precision);
      if (trailingZeros > -1) {
        number = trimTrailingZeros(number, trailingZeros);
      }
    }
  } else {
    number = round$3(number);
  }
  if (formatOptions2.negative && number * -1 >= 0 && !formatOptions2.negativeZero) {
    formatOptions2.negative = false;
  }
  formatOptions2.number = number;
  formatOptions2.decimalIndex = decimalIndex;
}
function isConstantFormat(format2) {
  return format2.indexOf(SHARP) === -1 && format2.indexOf(ZERO$1) === -1;
}
function setValueSpecificFormat(formatOptions2) {
  var number = formatOptions2.number;
  var format2 = formatOptions2.format;
  format2 = format2.split(LIST_SEPARATOR);
  if ((formatOptions2.negative || formatOptions2.negativeZero) && format2[1]) {
    format2 = format2[1];
    formatOptions2.hasNegativeFormat = true;
  } else if (number === 0) {
    var zeroFormat = format2[2];
    format2 = zeroFormat || format2[0];
    if (zeroFormat && isConstantFormat(zeroFormat)) {
      formatOptions2.constant = zeroFormat;
    }
  } else {
    format2 = format2[0];
  }
  formatOptions2.format = format2;
}
function setGroupOptions(formatOptions2) {
  formatOptions2.hasGroup = formatOptions2.format.indexOf(GROUP_SEPARATOR) > -1;
  if (formatOptions2.hasGroup) {
    formatOptions2.format = formatOptions2.format.replace(commaRegExp, EMPTY);
  }
}
function placeholderIndex(index1, index2, start) {
  var index3;
  if (index1 === -1 && index2 !== -1) {
    index3 = index2;
  } else if (index1 !== -1 && index2 === -1) {
    index3 = index1;
  } else {
    index3 = start ? Math.min(index1, index2) : Math.max(index1, index2);
  }
  return index3;
}
function setPlaceholderIndices(formatOptions2) {
  var format2 = formatOptions2.format;
  var sharpIndex = format2.indexOf(SHARP);
  var zeroIndex = format2.indexOf(ZERO$1);
  var start = placeholderIndex(sharpIndex, zeroIndex, true);
  sharpIndex = format2.lastIndexOf(SHARP);
  zeroIndex = format2.lastIndexOf(ZERO$1);
  var end = placeholderIndex(sharpIndex, zeroIndex);
  if (start === format2.length) {
    end = start;
  }
  formatOptions2.start = start;
  formatOptions2.end = end;
  formatOptions2.lastZeroIndex = zeroIndex;
}
function replaceStyleSymbols(number, style2, symbol) {
  var result = number;
  if (style2 === CURRENCY || style2 === PERCENT) {
    result = EMPTY;
    for (var idx = 0, length = number.length; idx < length; idx++) {
      var ch2 = number.charAt(idx);
      result += ch2 === CURRENCY_PLACEHOLDER || ch2 === PERCENT_PLACEHOLDER ? symbol : ch2;
    }
  }
  return result;
}
function replacePlaceHolders(formatOptions2, info) {
  var start = formatOptions2.start;
  var end = formatOptions2.end;
  var negative = formatOptions2.negative;
  var negativeZero = formatOptions2.negativeZero;
  var format2 = formatOptions2.format;
  var decimalIndex = formatOptions2.decimalIndex;
  var lastZeroIndex = formatOptions2.lastZeroIndex;
  var hasNegativeFormat = formatOptions2.hasNegativeFormat;
  var hasGroup = formatOptions2.hasGroup;
  var number = formatOptions2.number;
  var value2 = number.toString().split(POINT);
  var length = format2.length;
  var integer = value2[0];
  var fraction = value2[1] || EMPTY;
  var integerLength = integer.length;
  var replacement = EMPTY;
  number = format2.substring(0, start);
  if ((negative || negativeZero) && !hasNegativeFormat) {
    number += "-";
  }
  for (var idx = start; idx < length; idx++) {
    var ch2 = format2.charAt(idx);
    if (decimalIndex === -1) {
      if (end - idx < integerLength) {
        number += integer;
        break;
      }
    } else {
      if (lastZeroIndex !== -1 && lastZeroIndex < idx) {
        replacement = EMPTY;
      }
      if (decimalIndex - idx <= integerLength && decimalIndex - idx > -1) {
        number += integer;
        idx = decimalIndex;
      }
      if (decimalIndex === idx) {
        number += (fraction ? info.numbers.symbols.decimal : EMPTY) + fraction;
        idx += end - decimalIndex + 1;
        continue;
      }
    }
    if (ch2 === ZERO$1) {
      number += ch2;
      replacement = ch2;
    } else if (ch2 === SHARP) {
      number += replacement;
    }
  }
  if (hasGroup) {
    number = groupInteger(number, start + (negative && !hasNegativeFormat ? 1 : 0), Math.max(end, integerLength + start), info.numbers.decimal, info);
  }
  if (end >= start) {
    number += format2.substring(end + 1);
  }
  return number;
}
function applyCustomFormat(formatOptions2, info) {
  var number = formatOptions2.number;
  if (formatOptions2.start !== -1) {
    number = replacePlaceHolders(formatOptions2, info);
    number = replaceStyleSymbols(number, formatOptions2.style, formatOptions2.symbol);
    number = replaceLiterals(number, formatOptions2.literals);
  }
  return number;
}
function customNumberFormat(number, format2, info) {
  var formatOptions2 = {
    negative: number < 0,
    number: Math.abs(number),
    negativeZero: isNegativeZero(number),
    format: format2
  };
  setValueSpecificFormat(formatOptions2);
  if (formatOptions2.constant) {
    return formatOptions2.constant;
  }
  setFormatLiterals(formatOptions2);
  setStyleOptions(formatOptions2, info);
  setGroupOptions(formatOptions2);
  roundNumber(formatOptions2);
  setPlaceholderIndices(formatOptions2);
  return applyCustomFormat(formatOptions2, info);
}
var standardFormatRegExp = /^(n|c|p|e|a)(\d*)$/i;
function standardFormatOptions(format2) {
  var formatAndPrecision = standardFormatRegExp.exec(format2);
  if (formatAndPrecision) {
    var options2 = {
      style: DECIMAL
    };
    var style2 = formatAndPrecision[1].toLowerCase();
    if (style2 === "c") {
      options2.style = CURRENCY;
    } else if (style2 === "a") {
      options2.style = ACCOUNTING;
    } else if (style2 === "p") {
      options2.style = PERCENT;
    } else if (style2 === "e") {
      options2.style = SCIENTIFIC;
    }
    if (formatAndPrecision[2]) {
      options2.minimumFractionDigits = options2.maximumFractionDigits = parseInt(formatAndPrecision[2], 10);
    }
    return options2;
  }
}
function formatOptions(format2) {
  var options2;
  if (isString$3(format2)) {
    options2 = standardFormatOptions(format2);
  } else {
    options2 = format2;
  }
  return options2;
}
function formatNumber(number, format2, locale) {
  if (format2 === void 0)
    format2 = NUMBER_PLACEHOLDER;
  if (locale === void 0)
    locale = DEFAULT_LOCALE;
  if (number === void 0 || number === null) {
    return EMPTY;
  }
  if (!isFinite(number)) {
    return String(number);
  }
  var info = localeInfo(locale);
  var options2 = formatOptions(format2);
  var result;
  if (options2) {
    var style2 = options2.style || DECIMAL;
    result = standardNumberFormat(number, Object.assign({}, info.numbers[style2], options2), info);
  } else {
    result = customNumberFormat(number, format2, info);
  }
  return result;
}
function isNumber$1(value2) {
  return typeof value2 === "number";
}
var exponentRegExp = /[eE][-+]?[0-9]+/;
var nonBreakingSpaceRegExp = /\u00A0/g;
function cleanNegativePattern(number, patterns) {
  if (patterns.length > 1) {
    var parts = (patterns[1] || EMPTY).replace(CURRENCY_PLACEHOLDER, EMPTY).split(NUMBER_PLACEHOLDER);
    if (number.indexOf(parts[0]) > -1 && number.indexOf(parts[1]) > -1) {
      return number.replace(parts[0], EMPTY).replace(parts[1], EMPTY);
    }
  }
}
function cleanCurrencyNumber(value2, info, format2) {
  var options2 = formatOptions(format2) || {};
  var isCurrency = isCurrencyStyle(options2.style);
  var number = value2;
  var negative;
  var currency = options2.currency || localeCurrency(info, isCurrency);
  if (currency) {
    var displays = currencyDisplays(info, currency, isCurrency);
    if (displays) {
      for (var idx = 0; idx < displays.length; idx++) {
        var display = displays[idx];
        if (number.includes(display)) {
          number = number.replace(display, EMPTY);
          isCurrency = true;
          break;
        }
      }
    }
    if (isCurrency) {
      var cleanNumber = cleanNegativePattern(number, info.numbers.currency.patterns) || cleanNegativePattern(number, info.numbers.accounting.patterns);
      if (cleanNumber) {
        negative = true;
        number = cleanNumber;
      }
    }
  }
  return {
    number,
    negative
  };
}
function cleanLiterals(number, formatOptions2) {
  var literals2 = formatOptions2.literals;
  var result = number;
  if (literals2) {
    for (var idx = 0; idx < literals2.length; idx++) {
      result = result.replace(literals2[idx], EMPTY);
    }
  }
  return result;
}
function divideBy100(number) {
  var strNumber = String(number);
  var pointIndex = strNumber.indexOf(POINT);
  var zeroesCount = 2;
  var result = number / Math.pow(10, zeroesCount);
  if (pointIndex === -1 || String(result).length <= strNumber.length + zeroesCount) {
    return result;
  }
  var fractionDigits = strNumber.length - pointIndex + 1 + zeroesCount;
  return parseFloat(result.toFixed(fractionDigits));
}
function parseNumber(value2, locale, format2) {
  if (locale === void 0)
    locale = DEFAULT_LOCALE;
  if (format2 === void 0)
    format2 = {};
  if (!value2 && value2 !== 0) {
    return null;
  }
  if (isNumber$1(value2)) {
    return value2;
  }
  var info = localeInfo(locale);
  var symbols = info.numbers.symbols;
  var number = value2.toString();
  var formatOptions2 = format2 || {};
  var isPercent;
  if (isString$3(format2)) {
    formatOptions2 = { format: format2 };
    setFormatLiterals(formatOptions2);
    number = cleanLiterals(number, formatOptions2);
    setStyleOptions(formatOptions2, info);
  }
  if (formatOptions2.style === PERCENT || number.indexOf(symbols.percentSign) > -1) {
    number = number.replace(symbols.percentSign, EMPTY);
    isPercent = true;
  }
  if (exponentRegExp.test(number)) {
    number = parseFloat(number.replace(symbols.decimal, POINT));
    return isNaN(number) ? null : number;
  }
  var ref2 = cleanCurrencyNumber(number, info, formatOptions2);
  var negativeCurrency = ref2.negative;
  var currencyNumber = ref2.number;
  number = String(currencyNumber).trim();
  var negativeSignIndex = number.indexOf("-");
  if (negativeSignIndex > 0) {
    return null;
  }
  var isNegative = negativeSignIndex > -1;
  isNegative = negativeCurrency !== void 0 ? negativeCurrency : isNegative;
  number = number.replace("-", EMPTY).replace(nonBreakingSpaceRegExp, " ").split(symbols.group.replace(nonBreakingSpaceRegExp, " ")).join(EMPTY).replace(symbols.decimal, POINT);
  number = parseFloat(number);
  if (isNaN(number)) {
    number = null;
  } else if (isNegative) {
    number *= -1;
  }
  if (number && isPercent) {
    number = divideBy100(number);
  }
  return number;
}
var formatRegExp$1 = /\{(\d+)}/g;
function formatString$1(format2) {
  var values6 = arguments;
  return format2.replace(formatRegExp$1, function(match2, index2) {
    var value2 = values6[parseInt(index2, 10) + 1];
    return value2;
  });
}
var REMOVAL_PENALTY = 120;
var ADDITION_PENALTY = 20;
var LENGHT_DELTA = [2, 1, 5, 3, 4];
var LONG_LESS_PENALTY_DELTA = -2;
var SHORT_LESS_PENALTY_DELTA = -1;
var SHORT_MORE_PENALTY_DELTA = 1;
var LONG_MORE_PENALTY_DELTA = 2;
var PENALTIES = {};
PENALTIES[LONG_LESS_PENALTY_DELTA.toString()] = 8;
PENALTIES[SHORT_LESS_PENALTY_DELTA.toString()] = 6;
PENALTIES[LONG_MORE_PENALTY_DELTA.toString()] = 6;
PENALTIES[SHORT_MORE_PENALTY_DELTA.toString()] = 3;
var VALUE_FORMAT_LENGTH = {
  numeric: 1,
  "2-digit": 2,
  short: 3,
  long: 4,
  narrow: 5
};
var TIME_SPECIFIERS_REGEX = /[hHmsSzZoOvVxX]/;
function getHourSpecifier(options2) {
  return options2.hour12 ? "h" : "H";
}
var DATE_OPTIONS_MAP = [{
  key: "era",
  specifier: "G"
}, {
  key: "year",
  specifier: "y"
}, {
  key: "month",
  specifier: "M"
}, {
  key: "day",
  specifier: "d"
}, {
  key: "weekday",
  specifier: "E"
}, {
  key: "hour",
  getSpecifier: getHourSpecifier
}, {
  key: "minute",
  specifier: "m"
}, {
  key: "second",
  specifier: "s"
}, {
  key: "timeZoneName",
  specifier: "z"
}];
var STAND_ALONE_SPECIFIERS = {
  e: "c",
  E: "c",
  M: "L",
  Q: "q"
};
var specifiersRegex = {};
var resolvedFormats = {};
function getSpecifierRegex(specifier) {
  if (!specifiersRegex[specifier]) {
    specifiersRegex[specifier] = new RegExp(specifier + "+");
  }
  return specifiersRegex[specifier];
}
function skeletonSpecifiers(skeleton) {
  var result = [];
  var current2 = skeleton.charAt(0);
  var specifier = current2;
  for (var idx = 1; idx < skeleton.length; idx++) {
    var character = skeleton.charAt(idx);
    if (character === specifier) {
      current2 += character;
    } else {
      result.push(current2);
      current2 = specifier = character;
    }
  }
  result.push(current2);
  return result;
}
function findBestMatch(specifiers, availableFormats) {
  var specifiersLength = specifiers.length;
  var maxScore = -Number.MAX_VALUE;
  var bestMatches, result;
  for (var format2 in availableFormats) {
    var matches = [];
    var currentFormat = format2.replace("v", "z");
    var score = 0;
    for (var idx = 0; idx < specifiersLength; idx++) {
      var specifier = specifiers[idx];
      var specifierRegex = getSpecifierRegex(specifier[0]);
      var match2 = (specifierRegex.exec(currentFormat) || [])[0];
      if (!match2) {
        score -= REMOVAL_PENALTY;
      } else {
        currentFormat = currentFormat.replace(match2, EMPTY);
        if (match2.length !== specifier.length) {
          var delta = Math.max(Math.min(LENGHT_DELTA[match2.length] - LENGHT_DELTA[specifier.length], 2), -2);
          score -= PENALTIES[delta];
        }
      }
      matches.push(match2);
      if (score < maxScore) {
        break;
      }
    }
    if (currentFormat.length) {
      score -= skeletonSpecifiers(currentFormat).length * ADDITION_PENALTY;
    }
    if (score > maxScore) {
      maxScore = score;
      bestMatches = matches;
      result = availableFormats[format2];
    }
  }
  result = result.replace("v", "z");
  for (var idx$1 = 0; idx$1 < specifiersLength; idx$1++) {
    var bestMatch = bestMatches[idx$1];
    if (bestMatch && bestMatch !== specifiers[idx$1]) {
      var matchSpecifier = bestMatches[idx$1][0];
      result = result.replace(getSpecifierRegex(matchSpecifier), specifiers[idx$1]);
      if (STAND_ALONE_SPECIFIERS[matchSpecifier]) {
        result = result.replace(getSpecifierRegex(STAND_ALONE_SPECIFIERS[matchSpecifier]), specifiers[idx$1]);
      }
    }
  }
  return result;
}
function cacheFormat(skeleton, format2, locale) {
  if (!resolvedFormats[locale]) {
    resolvedFormats[locale] = {};
  }
  resolvedFormats[locale][skeleton] = format2;
}
function skeletonFormat(skeleton, info) {
  var availableFormats = info.calendar.dateTimeFormats.availableFormats;
  if (availableFormats[skeleton]) {
    return availableFormats[skeleton];
  }
  if (resolvedFormats[info.name] && resolvedFormats[info.name][skeleton]) {
    return resolvedFormats[info.name][skeleton];
  }
  var timeStartIndex = skeleton.search(TIME_SPECIFIERS_REGEX);
  var result;
  if (timeStartIndex > 0) {
    var dateSkeleton = skeleton.substr(0, timeStartIndex);
    var timeSkeleton = skeleton.substr(timeStartIndex);
    result = formatString$1(
      info.calendar.dateTimeFormats.short,
      //should be deterimed based on specifiers
      availableFormats[timeSkeleton] || findBestMatch(skeletonSpecifiers(timeSkeleton), availableFormats),
      availableFormats[dateSkeleton] || findBestMatch(skeletonSpecifiers(dateSkeleton), availableFormats)
    );
  } else {
    result = findBestMatch(skeletonSpecifiers(skeleton), availableFormats);
  }
  cacheFormat(skeleton, result, info.name);
  return result;
}
function skeletonFromOptions(options2) {
  var result = [];
  for (var idx = 0; idx < DATE_OPTIONS_MAP.length; idx++) {
    var option = DATE_OPTIONS_MAP[idx];
    var field = option.key;
    var value2 = options2[field];
    if (value2) {
      var spcifier = option.specifier || option.getSpecifier(options2);
      result.push(spcifier.repeat(VALUE_FORMAT_LENGTH[value2]));
    }
  }
  return result.join(EMPTY);
}
function datePattern(format2, info) {
  var calendar = info.calendar;
  var result;
  if (isString$3(format2)) {
    if (calendar.patterns[format2]) {
      result = calendar.patterns[format2];
    } else {
      result = format2;
    }
  } else if (format2) {
    if (format2.pattern) {
      return format2.pattern;
    }
    var skeleton = format2.skeleton;
    if (!skeleton) {
      if (format2.datetime) {
        result = formatString$1(calendar.dateTimeFormats[format2.datetime], calendar.timeFormats[format2.datetime], calendar.dateFormats[format2.datetime]);
      } else if (format2.date) {
        result = calendar.dateFormats[format2.date];
      } else if (format2.time) {
        result = calendar.timeFormats[format2.time];
      } else {
        skeleton = skeletonFromOptions(format2);
      }
    }
    if (skeleton) {
      result = skeletonFormat(skeleton, info);
    }
  }
  if (!result) {
    result = calendar.patterns.d;
  }
  return result;
}
function dateNameType(formatLength) {
  var nameType;
  if (formatLength <= 3) {
    nameType = "abbreviated";
  } else if (formatLength === 4) {
    nameType = "wide";
  } else if (formatLength === 5) {
    nameType = "narrow";
  } else if (formatLength === 6) {
    nameType = "short";
  }
  return nameType;
}
function formatNames(locale, type, formatLength, standAlone, lower) {
  return dateFormatNames(locale, {
    type,
    nameType: dateNameType(formatLength),
    standAlone,
    lower
  });
}
function isFunction$3(fun) {
  return typeof fun === "function";
}
function isDate$1(value2) {
  return Boolean(value2) && isFunction$3(value2.getTime) && isFunction$3(value2.getMonth);
}
var MONTH = "month";
var HOUR = "hour";
var ZONE = "zone";
var WEEKDAY = "weekday";
var QUARTER = "quarter";
var DATE_FIELD_MAP = {
  "G": "era",
  "y": "year",
  "q": QUARTER,
  "Q": QUARTER,
  "M": MONTH,
  "L": MONTH,
  "d": "day",
  "E": WEEKDAY,
  "c": WEEKDAY,
  "e": WEEKDAY,
  "h": HOUR,
  "H": HOUR,
  "k": HOUR,
  "K": HOUR,
  "m": "minute",
  "s": "second",
  "S": "millisecond",
  "a": "dayperiod",
  "x": ZONE,
  "X": ZONE,
  "z": ZONE,
  "Z": ZONE
};
var dateFormatRegExp = /d{1,2}|E{1,6}|e{1,6}|c{3,6}|c{1}|M{1,5}|L{1,5}|y{1,4}|H{1,2}|h{1,2}|k{1,2}|K{1,2}|m{1,2}|a{1,5}|s{1,2}|S{1,3}|z{1,4}|Z{1,5}|x{1,5}|X{1,5}|G{1,5}|q{1,5}|Q{1,5}|"[^"]*"|'[^']*'/g;
function formatDayOfWeekIndex(day, formatLength, localeInfo2) {
  var firstDayIndex = firstDay$1(localeInfo2);
  var dayIndex;
  if (day < firstDayIndex) {
    dayIndex = 7 - firstDayIndex + day;
  } else {
    dayIndex = day - firstDayIndex;
  }
  return dayIndex + 1;
}
function formatMonth(month, formatLength, info, standAlone) {
  if (formatLength <= 2) {
    return pad$1(month + 1, formatLength);
  }
  return formatNames(info, "months", formatLength, standAlone)[month];
}
function formatQuarter(date, formatLength, info, standAlone) {
  var quarter = Math.floor(date.getMonth() / 3);
  if (formatLength < 3) {
    return quarter + 1;
  }
  return formatNames(info, "quarters", formatLength, standAlone)[quarter];
}
function formatTimeZone(date, info, options2) {
  var shortHours = options2.shortHours;
  var optionalMinutes = options2.optionalMinutes;
  var separator = options2.separator;
  var localizedName = options2.localizedName;
  var zZeroOffset = options2.zZeroOffset;
  var offset2 = date.getTimezoneOffset() / 60;
  if (offset2 === 0 && zZeroOffset) {
    return "Z";
  }
  var sign = offset2 <= 0 ? "+" : "-";
  var hoursMinutes = Math.abs(offset2).toString().split(".");
  var minutes = hoursMinutes[1] || 0;
  var result = sign + (shortHours ? hoursMinutes[0] : pad$1(hoursMinutes[0], 2));
  if (minutes || !optionalMinutes) {
    result += (separator ? ":" : EMPTY) + pad$1(minutes, 2);
  }
  if (localizedName) {
    var localizedFormat = offset2 === 0 ? info.calendar.gmtZeroFormat : info.calendar.gmtFormat;
    result = formatString$1(localizedFormat, result);
  }
  return result;
}
function formatDayOfWeek(date, formatLength, info, standAlone) {
  var result;
  if (formatLength < 3) {
    result = formatDayOfWeekIndex(date.getDay(), formatLength, info);
  } else {
    result = formatNames(info, "days", formatLength, standAlone)[date.getDay()];
  }
  return result;
}
var formatters = {};
formatters.d = function(date, formatLength) {
  return pad$1(date.getDate(), formatLength);
};
formatters.E = function(date, formatLength, info) {
  return formatNames(info, "days", formatLength)[date.getDay()];
};
formatters.M = function(date, formatLength, info) {
  return formatMonth(date.getMonth(), formatLength, info, false);
};
formatters.L = function(date, formatLength, info) {
  return formatMonth(date.getMonth(), formatLength, info, true);
};
formatters.y = function(date, formatLength) {
  var year = date.getFullYear();
  if (formatLength === 2) {
    year = year % 100;
  }
  return pad$1(year, formatLength);
};
formatters.h = function(date, formatLength) {
  var hours = date.getHours() % 12 || 12;
  return pad$1(hours, formatLength);
};
formatters.H = function(date, formatLength) {
  return pad$1(date.getHours(), formatLength);
};
formatters.k = function(date, formatLength) {
  return pad$1(date.getHours() || 24, formatLength);
};
formatters.K = function(date, formatLength) {
  return pad$1(date.getHours() % 12, formatLength);
};
formatters.m = function(date, formatLength) {
  return pad$1(date.getMinutes(), formatLength);
};
formatters.s = function(date, formatLength) {
  return pad$1(date.getSeconds(), formatLength);
};
formatters.S = function(date, formatLength) {
  var milliseconds = date.getMilliseconds();
  var result;
  if (milliseconds !== 0) {
    result = pad$1(String(milliseconds / 1e3).split(".")[1].substr(0, formatLength), formatLength, true);
  } else {
    result = pad$1(EMPTY, formatLength);
  }
  return result;
};
formatters.a = function(date, formatLength, info) {
  return formatNames(info, "dayPeriods", formatLength)[date.getHours() < 12 ? "am" : "pm"];
};
formatters.z = function(date, formatLength, info) {
  return formatTimeZone(date, info, {
    shortHours: formatLength < 4,
    optionalMinutes: formatLength < 4,
    separator: true,
    localizedName: true
  });
};
formatters.Z = function(date, formatLength, info) {
  return formatTimeZone(date, info, {
    separator: formatLength > 3,
    localizedName: formatLength === 4,
    zZeroOffset: formatLength === 5
  });
};
formatters.x = function(date, formatLength, info) {
  return formatTimeZone(date, info, {
    optionalMinutes: formatLength === 1,
    separator: formatLength === 3 || formatLength === 5
  });
};
formatters.X = function(date, formatLength, info) {
  return formatTimeZone(date, info, {
    optionalMinutes: formatLength === 1,
    separator: formatLength === 3 || formatLength === 5,
    zZeroOffset: true
  });
};
formatters.G = function(date, formatLength, info) {
  var era = date.getFullYear() >= 0 ? 1 : 0;
  return formatNames(info, "eras", formatLength)[era];
};
formatters.e = formatDayOfWeek;
formatters.c = function(date, formatLength, info) {
  return formatDayOfWeek(date, formatLength, info, true);
};
formatters.q = function(date, formatLength, info) {
  return formatQuarter(date, formatLength, info, true);
};
formatters.Q = formatQuarter;
function formatDate$1(date, format2, locale) {
  if (locale === void 0)
    locale = DEFAULT_LOCALE;
  if (!isDate$1(date)) {
    if (date === void 0 || date === null) {
      return EMPTY;
    }
    return date;
  }
  var info = localeInfo(locale);
  var pattern = datePattern(format2, info);
  return pattern.replace(dateFormatRegExp, function(match2) {
    var formatLength = match2.length;
    var result;
    if (match2.includes("'") || match2.includes('"')) {
      result = match2.slice(1, formatLength - 1);
    } else {
      result = formatters[match2[0]](date, formatLength, info);
    }
    return result;
  });
}
function convertTimeZone(date, fromOffset, toOffset) {
  var fromLocalOffset = date.getTimezoneOffset();
  var offsetDate = new Date(date.getTime() + (fromOffset - toOffset) * 6e4);
  var toLocalOffset = offsetDate.getTimezoneOffset();
  return new Date(offsetDate.getTime() + (toLocalOffset - fromLocalOffset) * 6e4);
}
function adjustDST$2(date, hours) {
  if (!hours && date.getHours() === 23) {
    date.setHours(date.getHours() + 2);
  }
}
var timeZoneOffsetRegExp = /([+|-]\d{1,2})(:?)(\d{2})?/;
var dateRegExp$1 = /^\/Date\((.*?)\)\/$/;
var offsetRegExp = /[+-]\d*/;
var numberRegExp = {
  2: /^\d{1,2}/,
  3: /^\d{1,3}/,
  4: /^\d{4}/
};
var numberRegex$3 = /\d+/;
var PLACEHOLDER = "{0}";
var leadingSpacesRegex = /^ */;
var trailingSpacesRegex = / *$/;
var standardDateFormats = [
  "yyyy/MM/dd HH:mm:ss",
  "yyyy/MM/dd HH:mm",
  "yyyy/MM/dd",
  "E MMM dd yyyy HH:mm:ss",
  "yyyy-MM-ddTHH:mm:ss.SSSSSSSXXX",
  "yyyy-MM-ddTHH:mm:ss.SSSXXX",
  "yyyy-MM-ddTHH:mm:ss.SSXXX",
  "yyyy-MM-ddTHH:mm:ssXXX",
  "yyyy-MM-ddTHH:mm:ss.SSSSSSS",
  "yyyy-MM-ddTHH:mm:ss.SSS",
  "yyyy-MM-ddTHH:mmXXX",
  "yyyy-MM-ddTHH:mmX",
  "yyyy-MM-ddTHH:mm:ss",
  "yyyy-MM-ddTHH:mm",
  "yyyy-MM-dd HH:mm:ss",
  "yyyy-MM-dd HH:mm",
  "yyyy-MM-dd",
  "HH:mm:ss",
  "HH:mm"
];
var FORMATS_SEQUENCE = ["G", "g", "F", "Y", "y", "M", "m", "D", "d", "y", "T", "t"];
var TWO_DIGIT_YEAR_MAX = 2029;
function outOfRange(value2, start, end) {
  return !(value2 >= start && value2 <= end);
}
function lookAhead(match2, state) {
  var format2 = state.format;
  var idx = state.idx;
  var i16 = 0;
  while (format2[idx] === match2) {
    i16++;
    idx++;
  }
  if (i16 > 0) {
    idx -= 1;
  }
  state.idx = idx;
  return i16;
}
function getNumber(size, state) {
  var regex = size ? numberRegExp[size] || new RegExp("^\\d{1," + size + "}") : numberRegex$3, match2 = state.value.substr(state.valueIdx, size).match(regex);
  if (match2) {
    match2 = match2[0];
    state.valueIdx += match2.length;
    return parseInt(match2, 10);
  }
  return null;
}
function getIndexByName(names, state, lower) {
  var i16 = 0, length = names.length, name2, nameLength, matchLength = 0, matchIdx = 0, subValue;
  for (; i16 < length; i16++) {
    name2 = names[i16];
    nameLength = name2.length;
    subValue = state.value.substr(state.valueIdx, nameLength);
    if (lower) {
      subValue = subValue.toLowerCase();
    }
    if (subValue === name2 && nameLength > matchLength) {
      matchLength = nameLength;
      matchIdx = i16;
    }
  }
  if (matchLength) {
    state.valueIdx += matchLength;
    return matchIdx + 1;
  }
  return null;
}
function checkLiteral(state) {
  var result = false;
  if (state.value.charAt(state.valueIdx) === state.format[state.idx]) {
    state.valueIdx++;
    result = true;
  }
  return result;
}
function calendarGmtFormats(calendar) {
  var gmtFormat = calendar.gmtFormat;
  var gmtZeroFormat = calendar.gmtZeroFormat;
  if (!gmtFormat) {
    throw errors.NoGMTInfo.error();
  }
  return [gmtFormat.replace(PLACEHOLDER, EMPTY).toLowerCase(), gmtZeroFormat.replace(PLACEHOLDER, EMPTY).toLowerCase()];
}
function parseTimeZoneOffset(state, info, options2) {
  var shortHours = options2.shortHours;
  var noSeparator = options2.noSeparator;
  var optionalMinutes = options2.optionalMinutes;
  var localizedName = options2.localizedName;
  var zLiteral = options2.zLiteral;
  state.UTC = true;
  if (zLiteral && state.value.charAt(state.valueIdx) === "Z") {
    state.valueIdx++;
    return false;
  }
  if (localizedName && !getIndexByName(calendarGmtFormats(info.calendar), state, true)) {
    return true;
  }
  var matches = timeZoneOffsetRegExp.exec(state.value.substr(state.valueIdx, 6));
  if (!matches) {
    return !localizedName;
  }
  var hoursMatch = matches[1];
  var minutesMatch = matches[3];
  var hoursOffset = parseInt(hoursMatch, 10);
  var separator = matches[2];
  var minutesOffset = parseInt(minutesMatch, 10);
  if (isNaN(hoursOffset) || !shortHours && hoursMatch.length !== 3 || !optionalMinutes && isNaN(minutesOffset) || noSeparator && separator) {
    return true;
  }
  if (isNaN(minutesOffset)) {
    minutesOffset = null;
  }
  if (outOfRange(hoursOffset, -12, 13) || minutesOffset && outOfRange(minutesOffset, 0, 59)) {
    return true;
  }
  state.valueIdx += matches[0].length;
  state.hoursOffset = hoursOffset;
  state.minutesOffset = minutesOffset;
}
function parseMonth(ch2, state, info) {
  var count = lookAhead(ch2, state);
  var names = formatNames(info, "months", count, ch2 === "L", true);
  var month = count < 3 ? getNumber(2, state) : getIndexByName(names, state, true);
  if (month === null || outOfRange(month, 1, 12)) {
    return true;
  }
  state.month = month - 1;
}
function parseDayOfWeek(ch2, state, info) {
  var count = lookAhead(ch2, state);
  var names = formatNames(info, "days", count, ch2 === "c", true);
  var dayOfWeek2 = count < 3 ? getNumber(1, state) : getIndexByName(names, state, true);
  if (!dayOfWeek2 && dayOfWeek2 !== 0 || outOfRange(dayOfWeek2, 1, 7)) {
    return true;
  }
}
var parsers = {};
parsers.d = function(state) {
  lookAhead("d", state);
  var day = getNumber(2, state);
  if (day === null || outOfRange(day, 1, 31)) {
    return true;
  }
  if (state.day === null) {
    state.day = day;
  }
};
parsers.E = function(state, info) {
  var count = lookAhead("E", state);
  var dayOfWeek2 = getIndexByName(formatNames(info, "days", count, false, true), state, true);
  if (dayOfWeek2 === null) {
    return true;
  }
};
parsers.M = function(state, info) {
  return parseMonth("M", state, info);
};
parsers.L = function(state, info) {
  return parseMonth("L", state, info);
};
parsers.y = function(state) {
  var count = lookAhead("y", state);
  var year = getNumber(count === 1 ? void 0 : count, state);
  if (year === null) {
    return true;
  }
  if (count === 2) {
    var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    year = currentYear - currentYear % 100 + year;
    if (year > TWO_DIGIT_YEAR_MAX) {
      year -= 100;
    }
  }
  state.year = year;
};
parsers.h = function(state) {
  lookAhead("h", state);
  var hours = getNumber(2, state);
  if (hours === 12) {
    hours = 0;
  }
  if (hours === null || outOfRange(hours, 0, 11)) {
    return true;
  }
  state.hours = hours;
};
parsers.K = function(state) {
  lookAhead("K", state);
  var hours = getNumber(2, state);
  if (hours === null || outOfRange(hours, 0, 11)) {
    return true;
  }
  state.hours = hours;
};
parsers.a = function(state, info) {
  var count = lookAhead("a", state);
  var periodFormats = formatNames(info, "dayPeriods", count, false, true);
  var pmHour = getIndexByName([periodFormats.pm], state, true);
  if (!pmHour && !getIndexByName([periodFormats.am], state, true)) {
    return true;
  }
  state.pmHour = pmHour;
};
parsers.H = function(state) {
  lookAhead("H", state);
  var hours = getNumber(2, state);
  if (hours === null || outOfRange(hours, 0, 23)) {
    return true;
  }
  state.hours = hours;
};
parsers.k = function(state) {
  lookAhead("k", state);
  var hours = getNumber(2, state);
  if (hours === null || outOfRange(hours, 1, 24)) {
    return true;
  }
  state.hours = hours === 24 ? 0 : hours;
};
parsers.m = function(state) {
  lookAhead("m", state);
  var minutes = getNumber(2, state);
  if (minutes === null || outOfRange(minutes, 0, 59)) {
    return true;
  }
  state.minutes = minutes;
};
parsers.s = function(state) {
  lookAhead("s", state);
  var seconds = getNumber(2, state);
  if (seconds === null || outOfRange(seconds, 0, 59)) {
    return true;
  }
  state.seconds = seconds;
};
parsers.S = function(state) {
  var count = lookAhead("S", state);
  var match2 = state.value.substr(state.valueIdx, count);
  var milliseconds = null;
  if (!isNaN(parseInt(match2, 10))) {
    milliseconds = parseFloat("0." + match2, 10);
    milliseconds = round$3(milliseconds, 3);
    milliseconds *= 1e3;
    state.valueIdx += count;
  }
  if (milliseconds === null || outOfRange(milliseconds, 0, 999)) {
    return true;
  }
  state.milliseconds = milliseconds;
};
parsers.z = function(state, info) {
  var count = lookAhead("z", state);
  var shortFormat = count < 4;
  var invalid = parseTimeZoneOffset(state, info, {
    shortHours: shortFormat,
    optionalMinutes: shortFormat,
    localizedName: true
  });
  if (invalid) {
    return invalid;
  }
};
parsers.Z = function(state, info) {
  var count = lookAhead("Z", state);
  var invalid = parseTimeZoneOffset(state, info, {
    noSeparator: count < 4,
    zLiteral: count === 5,
    localizedName: count === 4
  });
  if (invalid) {
    return invalid;
  }
};
parsers.x = function(state, info) {
  var count = lookAhead("x", state);
  var invalid = parseTimeZoneOffset(state, info, {
    noSeparator: count !== 3 && count !== 5,
    optionalMinutes: count === 1
  });
  if (invalid) {
    return invalid;
  }
};
parsers.X = function(state, info) {
  var count = lookAhead("X", state);
  var invalid = parseTimeZoneOffset(state, info, {
    noSeparator: count !== 3 && count !== 5,
    optionalMinutes: count === 1,
    zLiteral: true
  });
  if (invalid) {
    return invalid;
  }
};
parsers.G = function(state, info) {
  var count = lookAhead("G", state);
  var eras = formatNames(info, "eras", count, false, true);
  var era = getIndexByName([eras[0], eras[1]], state, true);
  if (era === null) {
    return true;
  }
};
parsers.e = function(state, info) {
  return parseDayOfWeek("e", state, info);
};
parsers.c = function(state, info) {
  return parseDayOfWeek("c", state, info);
};
function createDate$1(state) {
  var year = state.year;
  var month = state.month;
  var day = state.day;
  var hours = state.hours;
  var minutes = state.minutes;
  var seconds = state.seconds;
  var milliseconds = state.milliseconds;
  var pmHour = state.pmHour;
  var UTC = state.UTC;
  var hoursOffset = state.hoursOffset;
  var minutesOffset = state.minutesOffset;
  var hasTime = hours !== null || minutes !== null || seconds || null;
  var date = /* @__PURE__ */ new Date();
  var result;
  if (year === null && month === null && day === null && hasTime) {
    year = date.getFullYear();
    month = date.getMonth();
    day = date.getDate();
  } else {
    if (year === null) {
      year = date.getFullYear();
    }
    if (day === null) {
      day = 1;
    }
  }
  if (pmHour && hours < 12) {
    hours += 12;
  }
  if (UTC) {
    if (hoursOffset) {
      hours += -hoursOffset;
    }
    if (minutesOffset) {
      minutes += -minutesOffset * (hoursOffset < 0 ? -1 : 1);
    }
    result = new Date(Date.UTC(year, month, day, hours, minutes, seconds, milliseconds));
  } else {
    result = new Date(year, month, day, hours, minutes, seconds, milliseconds);
    adjustDST$2(result, hours);
  }
  if (year < 100) {
    result.setFullYear(year);
  }
  if (result.getDate() !== day && UTC === void 0) {
    return null;
  }
  return result;
}
function addFormatSpaces(value2, format2) {
  var leadingSpaces = leadingSpacesRegex.exec(format2)[0];
  var trailingSpaces = trailingSpacesRegex.exec(format2)[0];
  return "" + leadingSpaces + value2 + trailingSpaces;
}
function parseExact(value2, format2, info) {
  var pattern = datePattern(format2, info).split(EMPTY);
  var state = {
    format: pattern,
    idx: 0,
    value: addFormatSpaces(value2, format2),
    valueIdx: 0,
    year: null,
    month: null,
    day: null,
    hours: null,
    minutes: null,
    seconds: null,
    milliseconds: null
  };
  var length = pattern.length;
  var literal = false;
  for (; state.idx < length; state.idx++) {
    var ch2 = pattern[state.idx];
    if (literal) {
      if (ch2 === "'") {
        literal = false;
      }
      checkLiteral(state);
    } else {
      if (parsers[ch2]) {
        var invalid = parsers[ch2](state, info);
        if (invalid) {
          return null;
        }
      } else if (ch2 === "'") {
        literal = true;
        checkLiteral(state);
      } else if (!checkLiteral(state)) {
        return null;
      }
    }
  }
  if (state.valueIdx < value2.length) {
    return null;
  }
  return createDate$1(state) || null;
}
function parseMicrosoftDateOffset(offset2) {
  var sign = offset2.substr(0, 1) === "-" ? -1 : 1;
  var result = offset2.substring(1);
  result = parseInt(result.substr(0, 2), 10) * 60 + parseInt(result.substring(2), 10);
  return sign * result;
}
function parseMicrosoftDateFormat(value2) {
  if (value2 && value2.indexOf("/D") === 0) {
    var date = dateRegExp$1.exec(value2);
    if (date) {
      date = date[1];
      var tzoffset = offsetRegExp.exec(date.substring(1));
      date = new Date(parseInt(date, 10));
      if (tzoffset) {
        tzoffset = parseMicrosoftDateOffset(tzoffset[0]);
        date = convertTimeZone(date, date.getTimezoneOffset(), 0);
        date = convertTimeZone(date, 0, -1 * tzoffset);
      }
      return date;
    }
  }
}
function defaultFormats(calendar) {
  var formats = [];
  var patterns = calendar.patterns;
  var length = FORMATS_SEQUENCE.length;
  for (var idx = 0; idx < length; idx++) {
    formats.push(patterns[FORMATS_SEQUENCE[idx]]);
  }
  return formats.concat(standardDateFormats);
}
function parseDate$2(value2, formats, locale) {
  if (locale === void 0)
    locale = DEFAULT_LOCALE;
  if (!value2) {
    return null;
  }
  if (isDate$1(value2)) {
    return value2;
  }
  var parseValue = String(value2).trim();
  var date = parseMicrosoftDateFormat(parseValue);
  if (date) {
    return date;
  }
  var info = localeInfo(locale);
  var parseFormats = formats || defaultFormats(info.calendar);
  parseFormats = Array.isArray(parseFormats) ? parseFormats : [parseFormats];
  var length = parseFormats.length;
  for (var idx = 0; idx < length; idx++) {
    date = parseExact(parseValue, parseFormats[idx], info);
    if (date) {
      return date;
    }
  }
  return date;
}
var NAME_TYPES = {
  month: {
    type: "months",
    minLength: 3,
    standAlone: "L"
  },
  quarter: {
    type: "quarters",
    minLength: 3,
    standAlone: "q"
  },
  weekday: {
    type: "days",
    minLength: {
      E: 0,
      c: 3,
      e: 3
    },
    standAlone: "c"
  },
  dayperiod: {
    type: "dayPeriods",
    minLength: 0
  },
  era: {
    type: "eras",
    minLength: 0
  }
};
var LITERAL = "literal";
function addLiteral(parts, value2) {
  var lastPart = parts[parts.length - 1];
  if (lastPart && lastPart.type === LITERAL) {
    lastPart.pattern += value2;
  } else {
    parts.push({
      type: LITERAL,
      pattern: value2
    });
  }
}
function isHour12(pattern) {
  return pattern === "h" || pattern === "K";
}
function splitDateFormat(format2, locale) {
  if (locale === void 0)
    locale = DEFAULT_LOCALE;
  var info = localeInfo(locale);
  var pattern = datePattern(format2, info);
  var parts = [];
  var lastIndex = dateFormatRegExp.lastIndex = 0;
  var match2 = dateFormatRegExp.exec(pattern);
  while (match2) {
    var value2 = match2[0];
    if (lastIndex < match2.index) {
      addLiteral(parts, pattern.substring(lastIndex, match2.index));
    }
    if (value2.startsWith('"') || value2.startsWith("'")) {
      addLiteral(parts, value2);
    } else {
      var specifier = value2[0];
      var type = DATE_FIELD_MAP[specifier];
      var part = {
        type,
        pattern: value2
      };
      if (type === "hour") {
        part.hour12 = isHour12(value2);
      }
      var names = NAME_TYPES[type];
      if (names) {
        var minLength = isNumber$1(names.minLength) ? names.minLength : names.minLength[specifier];
        var patternLength = value2.length;
        if (patternLength >= minLength) {
          part.names = {
            type: names.type,
            nameType: dateNameType(patternLength),
            standAlone: names.standAlone === specifier
          };
        }
      }
      parts.push(part);
    }
    lastIndex = dateFormatRegExp.lastIndex;
    match2 = dateFormatRegExp.exec(pattern);
  }
  if (lastIndex < pattern.length) {
    addLiteral(parts, pattern.substring(lastIndex));
  }
  return parts;
}
var formatRegExp = /\{(\d+)(:[^}]+)?\}/g;
function toString$1(value2, format2, locale) {
  if (format2) {
    if (isDate$1(value2)) {
      return formatDate$1(value2, format2, locale);
    } else if (isNumber$1(value2)) {
      return formatNumber(value2, format2, locale);
    }
  }
  return value2 !== void 0 && value2 !== null ? value2 : EMPTY;
}
function format(format2, values6, locale) {
  return format2.replace(formatRegExp, function(match2, index2, placeholderFormat) {
    var value2 = values6[parseInt(index2, 10)];
    return toString$1(value2, placeholderFormat ? placeholderFormat.substring(1) : EMPTY, locale);
  });
}
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const t$o = reactExports.createContext(0);
t$o.displayName = "KendoReactZIndexContext";
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const t$n = () => typeof document != "undefined" ? document : {};
let l$r = class l {
  constructor() {
    this.scrollbar = 0;
  }
  get scrollbarWidth() {
    const o9 = t$n();
    if (!this.scrollbar && o9 && o9.createElement) {
      const e3 = o9.createElement("div");
      e3.style.cssText = "overflow:scroll;overflow-x:hidden;zoom:1;clear:both;display:block", e3.innerHTML = "&nbsp;", o9.body.appendChild(e3), this.scrollbar = e3.offsetWidth - e3.scrollWidth, o9.body.removeChild(e3);
    }
    return this.scrollbar;
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const e$C = !!// from fbjs
(typeof window != "undefined" && window.document && window.document.createElement);
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const r$r = (...c6) => {
  const t6 = {}, n10 = (e3) => typeof e3 == "object" ? Object.keys(e3).forEach((s10) => {
    t6[s10] = e3[s10];
  }) : t6[e3] = true, l7 = (e3) => e3.filter((s10) => s10 !== true && !!s10).map((s10) => Array.isArray(s10) ? l7(s10) : n10(s10));
  return l7(c6), Object.keys(t6).map((e3) => t6[e3] && e3 || null).filter((e3) => e3 !== null).join(" ");
}, o$q = (...c6) => r$r(c6).replace(/[^[\]a-zA-Z0-9-_!: ]/g, "");
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const e$B = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  esc: 27,
  space: 32,
  pageUp: 33,
  pageDown: 34,
  end: 35,
  home: 36,
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  delete: 46
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const d$t = /\[(?:(\d+)|['"](.*?)['"])\]|((?:(?!\[.*?\]|\.).)+)/g, t$m = ":not(.k-dropdownlist button):not(.k-colorpicker button):not(.k-numerictextbox button):not(.k-split-button .k-split-button-arrow)", o$p = ":not(.k-dropdownlist select)", n$z = [
  "input:not([disabled]):not([type=hidden])",
  "select:not([disabled]):not(.k-dropdownlist select)",
  "textarea:not([disabled])",
  `button:not([disabled])${t$m}`,
  "a[href]",
  "area[href]",
  "summary",
  "iframe",
  "object",
  "embed",
  "audio[controls]",
  "video[controls]",
  "[contenteditable]"
], s$u = [...n$z, `[tabindex]${t$m}${o$p}`], i$v = [...n$z, `[tabindex]${t$m}${o$p}`].map((e3) => e3 + ':not([tabindex="-1"])');
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const c$p = (s10, f4 = s$u) => s10.querySelectorAll(f4.join(",")), l$q = (s10, f4 = s$u) => {
  if (s10) {
    const t6 = c$p(s10, f4);
    if (t6.length && t6[0].focus)
      return t6[0];
  }
}, a$x = (s10, f4 = s$u) => {
  if (s10) {
    const t6 = c$p(s10, f4);
    if (t6.length && t6[t6.length - 1].focus)
      return t6[t6.length - 1];
  }
}, e$A = (s10, f4) => {
  if (s10) {
    const t6 = l$q(s10, f4);
    t6 && t6.focus();
  }
}, n$y = (s10, f4, t6) => {
  if (!(!f4 || s10.keyCode !== e$B.tab) && f4) {
    const o9 = l$q(f4, t6), i16 = a$x(f4, t6);
    o9 && i16 && !s10.shiftKey && s10.target === i16 && (s10.preventDefault(), o9.focus()), o9 && i16 && s10.shiftKey && s10.target === o9 && (s10.preventDefault(), i16.focus()), o9 || s10.preventDefault();
  }
}, g$j = (s10, f4) => {
  const t6 = c$p(
    s10,
    f4
  );
  t6 && t6.forEach((o9) => {
    o9.tabIndex = 0;
  });
}, y$c = (s10, f4) => {
  const t6 = c$p(
    s10,
    f4
  );
  t6 && t6.forEach((o9) => {
    o9.tabIndex = -1;
  });
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const o$o = (e3, D2, n10) => {
  const t6 = typeof e3 == "string" ? parseInt(e3) : e3;
  if (!Number.isNaN(t6))
    return t6 !== void 0 ? t6 : D2 ? n10 ? void 0 : -1 : 0;
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
function s$t(i16) {
  const t6 = [];
  return i16.replace(d$t, function(r12, e3, o9, c6) {
    t6.push(e3 !== void 0 ? e3 : o9 || c6);
  }), t6;
}
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const e$z = {};
e$z.undefined = () => {
};
function s$s(t6) {
  if (e$z[t6])
    return e$z[t6];
  const o9 = s$t(t6);
  return e$z[t6] = function(u5) {
    let n10 = u5;
    for (let r12 = 0; r12 < o9.length && n10; r12++)
      n10 = n10[o9[r12]];
    return n10;
  }, e$z[t6];
}
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const i$u = () => {
  let e3 = "", t6, r12;
  for (t6 = 0; t6 < 32; t6++)
    r12 = Math.random() * 16 | 0, (t6 === 8 || t6 === 12 || t6 === 16 || t6 === 20) && (e3 += "-"), e3 += (t6 === 12 ? 4 : t6 === 16 ? r12 & 3 | 8 : r12).toString(16);
  return e3;
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const n$x = function() {
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const s$r = () => !e$C || !document.body ? false : new l$r().scrollbarWidth, d$s = (r12) => {
  if (!e$C || !document.body)
    return false;
  const e3 = r12 || new l$r().scrollbarWidth;
  document.body.style.setProperty("--kendo-scrollbar-width", `${e3}px`);
};
var _0x10f4 = ["z2v0vgLTzq==", "ww91CIbSAwnLBNnLigv4CgLYzwqGB24G", "zgf0yq==", "uhjVz3jLC3mG", "AgvmshG=", "u2vLia==", "ChjVzhvJDenVzgvZ", "C2nYAxb0s2v5", "D3rmuhm=", "rKjcwKG=", "tM8GBgLJzw5ZzsbMB3vUzc4k", "CgfJA2fNzu5HBwu=", "qvfYAMq=", "CgfYC2u=", "ChjVzhvJDhm=", "igzVCIbTB3jLigLUzM9YBwf0Aw9UlGO=", "sgr5sMW=", "rg9iAwe=", "zxDJr2C=", "Du9wCuK=", "z2v0rNvSBfLLyxi=", "lcb0AguGCgfJA2fNzsb3yxmGChvIBgLZAgvKig9Uia==", "C2v0", "zxrNsxC=", "C29YDa==", "EeXMBLu=", "AgfZ", "s0XeCe8=", "rM1Ttxy=", "tNvstvG=", "ww91CIb0CMLHBcbSAwnLBNnLigv4CgLYzwqGB24G", "z2v0rgf0zq==", "BgvUz3rO", "txPHwe8=", "BgLJzw5Zzuv4CgLYyxrPB25eyxrL", "DhjPywW=", "vejxq3K=", "r2Ltv1q=", "uhPWBva=", "z2v0", "vgHLihbYB2r1y3qGAxmGBM90igLUy2X1zgvKigLUihrOzsbSAwnLBNnLlGO=", "z2v0tw9UDgG=", "s2DnDfK=", "DMvYC2LVBG==", "rKj6sum=", "DgLTzxn0yw1W", "B2jQzwn0", "DhLWzq==", "BgLJzw5ZAw5Nrg9JC1vYBa==", "BMfTzq==", "DwTXAeq=", "zg9JC1vYBa==", "z3jVDxbfBMq=", "z3jVDxa=", "yuDyzhy=", "zMLUza==", "D2fYBG==", "zNvUy3rPB24=", "Dw5KzwzPBMvK", "ChjVzhvJDe5HBwu=", "y29Uy2f0", "ChvIBgLZAerHDgu=", "zxHWAxj5rgf0zq==", "CeDhAfu=", "y29Kzq==", "Dg9mB2nHBgvtDhjPBMC=", "tgLJzw5ZzsbHy3rPDMf0Aw9UigzHAwXLzcbMB3iG"];
(function(_0x50aaef, _0x10f4b0) {
  var _0x145713 = function(_0x421c90) {
    while (--_0x421c90) {
      _0x50aaef["push"](_0x50aaef["shift"]());
    }
  };
  _0x145713(++_0x10f4b0);
})(_0x10f4, 439);
var _0x1457 = function(_0x50aaef, _0x10f4b0) {
  _0x50aaef = _0x50aaef - 0;
  var _0x145713 = _0x10f4[_0x50aaef];
  if (_0x1457["aWziBr"] === void 0) {
    var _0x421c90 = function(_0x1aecb4) {
      var _0x16aa36 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=", _0x27d11b = String(_0x1aecb4)["replace"](/=+$/, "");
      var _0x46c2e8 = "";
      for (var _0x29c8dd = 0, _0x5ea27f, _0x25dc8b, _0xcce210 = 0; _0x25dc8b = _0x27d11b["charAt"](_0xcce210++); ~_0x25dc8b && (_0x5ea27f = _0x29c8dd % 4 ? _0x5ea27f * 64 + _0x25dc8b : _0x25dc8b, _0x29c8dd++ % 4) ? _0x46c2e8 += String["fromCharCode"](255 & _0x5ea27f >> (-2 * _0x29c8dd & 6)) : 0) {
        _0x25dc8b = _0x16aa36["indexOf"](_0x25dc8b);
      }
      return _0x46c2e8;
    };
    _0x1457["XjGMHe"] = function(_0x2c6af5) {
      var _0x1b5a14 = _0x421c90(_0x2c6af5);
      var _0x2181c6 = [];
      for (var _0x4e0ecf = 0, _0x1a2fc4 = _0x1b5a14["length"]; _0x4e0ecf < _0x1a2fc4; _0x4e0ecf++) {
        _0x2181c6 += "%" + ("00" + _0x1b5a14["charCodeAt"](_0x4e0ecf)["toString"](16))["slice"](-2);
      }
      return decodeURIComponent(_0x2181c6);
    }, _0x1457["XQgCdR"] = {}, _0x1457["aWziBr"] = !![];
  }
  var _0x1b62be = _0x1457["XQgCdR"][_0x50aaef];
  return _0x1b62be === void 0 ? (_0x145713 = _0x1457["XjGMHe"](_0x145713), _0x1457["XQgCdR"][_0x50aaef] = _0x145713) : _0x145713 = _0x1b62be, _0x145713;
};
var context = { data: '  {"timestamp":1727109694,"products":[{"trial":false,"code":"KENDOUIREACT","licenseExpirationDate":1745002800},{"trial":false,"code":"KENDOUICOMPLETE","licenseExpirationDate":1745002800},{"trial":false,"code":"KENDOUIVUE","licenseExpirationDate":1745002800},{"trial":false,"code":"KENDOUIANGULAR","licenseExpirationDate":1745002800}],"integrity":"EQ23gmIVTNOup7FkZTr8Gb2wNXM="}  ' }, cache = /* @__PURE__ */ new Map();
function validatePackage(_0x401145) {
  if (cache[_0x1457("0x38")](_0x401145[_0x1457("0xc")])) {
    if (_0x1457("0x3a") !== _0x1457("0x3a"))
      ;
    else
      return cache[_0x1457("0x2")](_0x401145[_0x1457("0xc")]);
  }
  var _0x13003c = _0x401145[_0x1457("0x6")] ? " v" + _0x401145[_0x1457("0x6")] : "", _0x487465 = _0x401145[_0x1457("0xc")] + _0x13003c, _0x5ac69b = JSON[_0x1457("0x2b")](context[_0x1457("0x20")]), _0x12f1b9 = !_0x5ac69b[_0x1457("0x25")] && !_0x5ac69b[_0x1457("0x8")], _0x404bc6 = _0x5ac69b[_0x1457("0x25")] && typeof KendoLicensing === _0x1457("0x15"), _0x21bd47 = matchProduct(_0x5ac69b, _0x401145[_0x1457("0x24")]), _0x379487;
  if (_0x12f1b9 || _0x404bc6) {
    if (_0x1457("0x2a") === _0x1457("0x2f"))
      ;
    else
      _0x379487 = { "type": 0, "packageName": _0x487465, "docsUrl": _0x401145[_0x1457("0xb")] };
  } else {
    if (_0x1457("0x39") === _0x1457("0x39")) {
      if (!_0x21bd47) {
        if (_0x1457("0x1a") !== _0x1457("0x1a"))
          ;
        else
          _0x379487 = { "type": 1, "packageName": _0x487465, "docsUrl": _0x401145[_0x1457("0xb")] };
      } else {
        if (_0x21bd47[_0x1457("0x41")] === !![] && isExpired(getCurrentDate(), _0x21bd47[_0x1457("0x40")])) {
          if (_0x1457("0x0") === _0x1457("0x0"))
            _0x379487 = { "type": 3, "packageName": _0x487465, "expiryDate": parseDate$1(_0x21bd47[_0x1457("0x40")]), "docsUrl": _0x401145[_0x1457("0xb")] };
        } else {
          if (isExpired(_0x401145[_0x1457("0x18")], _0x21bd47[_0x1457("0x40")])) {
            if (_0x1457("0x22") !== _0x1457("0x22"))
              ;
            else
              _0x379487 = { "type": 2, "packageName": _0x487465, "publishDate": parseDate$1(_0x401145[_0x1457("0x18")]), "expiryDate": parseDate$1(_0x21bd47[_0x1457("0x40")]), "docsUrl": _0x401145[_0x1457("0xb")] };
          }
        }
      }
    }
  }
  if (_0x379487 && typeof console === _0x1457("0x9")) {
    if (_0x1457("0x5") !== _0x1457("0x5"))
      ;
    else {
      var _0x3e0d1b = _0x1457("0x21")[_0x1457("0x17")](_0x401145[_0x1457("0x16")]), _0x225671 = typeof console[_0x1457("0x10")] === _0x1457("0x14");
      if (_0x225671) {
        if (_0x1457("0x2e") === _0x1457("0x2e"))
          console[_0x1457("0x10")](_0x3e0d1b);
      } else {
        if (_0x1457("0x30") !== _0x1457("0x7"))
          console[_0x1457("0x13")](_0x3e0d1b);
      }
      console[_0x1457("0x13")](formatError(_0x379487));
      if (_0x225671) {
        if (_0x1457("0xd") !== _0x1457("0xd"))
          ;
        else
          console[_0x1457("0xf")]();
      }
    }
  }
  var _0x415e0e = !_0x379487;
  return cache[_0x1457("0x34")](_0x401145[_0x1457("0xc")], _0x415e0e), _0x415e0e;
}
function formatError(_0x594e89) {
  var _0x2d7e52 = _0x1457("0x1d")[_0x1457("0x17")](_0x594e89[_0x1457("0x29")], "\n");
  if (_0x594e89[_0x1457("0xa")] === 2) {
    if (_0x1457("0x3f") !== _0x1457("0x1"))
      _0x2d7e52 += _0x1457("0x1f")[_0x1457("0x17")](_0x594e89[_0x1457("0x19")][_0x1457("0x1c")](), _0x1457("0x33"))[_0x1457("0x17")](_0x594e89[_0x1457("0x18")][_0x1457("0x1c")](), ".\n");
  }
  if (_0x594e89[_0x1457("0xa")] === 3) {
    if (_0x1457("0x11") === _0x1457("0x11"))
      _0x2d7e52 += _0x1457("0x3c")[_0x1457("0x17")](_0x594e89[_0x1457("0x19")][_0x1457("0x1c")](), ".\n");
  } else {
    if (_0x594e89[_0x1457("0xa")] === 0) {
      if (_0x1457("0x35") === _0x1457("0x35"))
        _0x2d7e52 += _0x1457("0x28");
    } else {
      if (_0x594e89[_0x1457("0xa")] === 1) {
        if (_0x1457("0x26") !== _0x1457("0x26"))
          ;
        else
          _0x2d7e52 += _0x1457("0x3");
      }
    }
  }
  return _0x2d7e52 += _0x1457("0x23")[_0x1457("0x17")](_0x594e89[_0x1457("0xe")], _0x1457("0x2d")), _0x2d7e52;
}
function matchProduct(_0x408a16, _0x9b416b) {
  var _0x45ca78 = _0x408a16[_0x1457("0x2c")];
  if (!_0x45ca78 || !_0x45ca78[_0x1457("0x3e")]) {
    if (_0x1457("0x27") !== _0x1457("0x37"))
      return null;
  }
  var _0x1880f2 = new Set(_0x9b416b);
  return _0x45ca78[_0x1457("0x36")](function(_0x226118, _0x16f928) {
    if (_0x1457("0x42") !== _0x1457("0x31"))
      return _0x16f928[_0x1457("0x40")] - _0x226118[_0x1457("0x40")];
  })[_0x1457("0x12")](function(_0x4632fe) {
    if (_0x1457("0x3b") === _0x1457("0x3b"))
      return _0x1880f2[_0x1457("0x38")](_0x4632fe[_0x1457("0x1b")]);
  });
}
function parseDate$1(_0xe99283) {
  return new Date(_0xe99283 * 1e3);
}
function getCurrentDate() {
  return (/* @__PURE__ */ new Date())[_0x1457("0x1e")]() / 1e3;
}
function isExpired(_0x4b71d2, _0x1df709) {
  var _0x4f97fc = parseDate$1(_0x1df709), _0xea6b1d = new Date(_0x4f97fc[_0x1457("0x32")](), _0x4f97fc[_0x1457("0x4")](), _0x4f97fc[_0x1457("0x3d")]() + 1), _0x302664 = _0xea6b1d[_0x1457("0x1e")]() / 1e3;
  return _0x4b71d2 > _0x302664;
}
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const i$t = ["telerik.com", "progress.com", "stackblitz.io", "csb.app"], l$p = validatePackage;
function n$w(t6) {
  return !i$t.some((e3) => {
    var a9;
    return (a9 = globalThis.document) == null ? void 0 : a9.location.hostname.endsWith(e3);
  }) && !validatePackage(t6);
}
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const s$q = (o9) => {
  if (!e$C)
    return false;
  const e3 = o9 ? o9.ownerDocument : document;
  if (!e3 || !e3.body)
    return false;
  const i16 = 10, n10 = e3.createElement("div");
  n10.style.transform = "matrix(10, 0, 0, 10, 0, 0)";
  const t6 = e3.createElement("div");
  t6.appendChild(e3.createTextNode("child")), t6.style.position = "fixed", t6.style.top = i16 + "px", n10.appendChild(t6), e3.body.appendChild(n10);
  const r12 = t6.getBoundingClientRect().top !== i16;
  return e3.body.removeChild(n10), r12;
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const f$h = "https://www.telerik.com/kendo-react-ui/components/my-license/?utm_medium=product&utm_source=kendoreact&utm_campaign=kendo-ui-react-purchase-license-keys-banner";
let n$v = false;
const v$e = () => {
  const [t6, o9] = reactExports.useState(true), [A2, r12] = reactExports.useState(false);
  reactExports.useEffect(() => {
    n$v || (r12(true), n$v = true);
  }, []);
  const i16 = () => {
    o9(false);
  }, g6 = /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, t6 && /* @__PURE__ */ reactExports.createElement("div", { style: {
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    position: "fixed",
    top: "16px",
    right: "16px",
    padding: "12px",
    borderRadius: "4px",
    boxShadow: "0px 4px 5px 0px rgba(0, 0, 0, 0.04), 0px 2px 4px 0px rgba(0, 0, 0, 0.03)",
    fontSize: "14px",
    fontWeight: 400,
    lineHeight: "20px",
    backgroundColor: "#FFC000",
    color: "#1E1E1E",
    zIndex: 2e3
  } }, /* @__PURE__ */ reactExports.createElement("span", { style: { display: "flex", alignSelf: "center", marginRight: "8px" } }, /* @__PURE__ */ reactExports.createElement("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "none" }, /* @__PURE__ */ reactExports.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8 1L0 15H16L8 1ZM7 6V11H9V6H7ZM7 14V12H9V14H7Z", fill: "#1E1E1E" }))), /* @__PURE__ */ reactExports.createElement("span", null, "No valid license found for KendoReact. Learn how to activate your license."), /* @__PURE__ */ reactExports.createElement("div", { style: { display: "flex", alignItems: "center", marginLeft: "24px" } }, /* @__PURE__ */ reactExports.createElement("a", { href: f$h, style: { marginRight: "8px", display: "flex" } }, /* @__PURE__ */ reactExports.createElement(
    "button",
    {
      title: "Learn More",
      style: {
        display: "inline-flex",
        position: "relative",
        border: "none",
        borderRadius: "4px",
        padding: "5px",
        backgroundColor: "transparent",
        transition: "color 0.2s ease-in-out",
        outline: "none",
        cursor: "pointer"
      }
    },
    /* @__PURE__ */ reactExports.createElement("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "none" }, /* @__PURE__ */ reactExports.createElement("path", { d: "M15 8C15 11.8656 11.8656 15 8 15C4.13437 15 1 11.8656 1 8C1 4.13437 4.13437 1 8 1C11.8656 1 15 4.13437 15 8ZM14 8C14 4.6875 11.3125 2 8 2C4.6875 2 2 4.6875 2 8C2 11.3125 4.6875 14 8 14C11.3125 14 14 11.3125 14 8ZM11 6C11 7.4125 10.2687 8.05937 9.73125 8.53125C9.25937 8.94688 9 9.17813 9 10H7C7 8.275 7.84688 7.525 8.40938 7.03125C8.84062 6.65312 9 6.50938 9 6C9 5.45 8.55 5 8 5C7.45 5 7 5.45 7 6H5C5 4.34375 6.34375 3 8 3C9.65625 3 11 4.34375 11 6ZM9 13V11H7V13H9Z", fill: "#1E1E1E" }))
  )), /* @__PURE__ */ reactExports.createElement(
    "button",
    {
      title: "Close",
      style: {
        display: "inline-flex",
        position: "relative",
        border: "none",
        borderRadius: "4px",
        padding: "5px",
        backgroundColor: "transparent",
        transition: "color 0.2s ease-in-out",
        outline: "none",
        cursor: "pointer"
      },
      onClick: i16
    },
    /* @__PURE__ */ reactExports.createElement("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "none" }, /* @__PURE__ */ reactExports.createElement("path", { d: "M13 4.41562L9.41563 8L13 11.5844L11.5844 13L8 9.41563L4.41562 13L3 11.5844L6.58437 8L3 4.41562L4.41562 3L8 6.58437L11.5844 3L13 4.41562Z", fill: "#1E1E1E" }))
  ))));
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(
    "div",
    {
      style: {
        position: "absolute",
        width: "100%",
        height: "100%",
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        opacity: 0.12,
        zIndex: 101,
        pointerEvents: "none",
        backgroundImage: "url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAABVxSURBVHgB7Z3tVRtJE4WL9zgANgLLGRCCnAGOADmCxRGgDFAGYiOADKQMIAGO9J8ji42g37mjqlUjBgOanpn+uM85sjC2sKzbVd1dVV0tQgghhBBCCCGEEEIIKRPn3Gn1GAlJmmN1pP558J6OX9540ejh4WGlX09OTk7+EZIclXYXlY43+vVflY7PH3wd9c+AY/Wvvcb9/b0bjUYOz/hBQpICmh1oOPrEa6l/4rTR337AhIMgTSqtzg+0m8gnof7p0mD8EzmGhkFwJiR6np6e7luLL9Q/RTDTBzF+7wfWg2CxWOCHjYVET6XTdLPZrFuLL9Q/NeCkoVUQ4/d+6Ijev1yof1rAUVMvQgjJHebrSRu+CEmWo/O8hISgCjStKpgiGoDWed4AUP/hwGf++Pi4hQYyFHgDzBP3T7A8b0uo/zD4+sMBy1CwWKR/YjF+fS/Uv2di0t/eEAdBT0QnvlD/PolR/xoOgu4JUd7bFdS/e6I1foODoFuqz3M2mUziFF+of5dEb/xGwyAYCwmCVuPNYv5MqX94Yl75NWKD4PLyEm92KqQoqH9Y8Bnis0zC+A14LbxxVqiVCfUPh678plxNFYQe5pjRgAgpDAv4IOAHJyCEkDJoiPaeCyG5UA1oRIYWHNivSSbV0wLq/zbQXz+bS8kV/AeZJ35NCcYPqH8zvv4VS8kVFou8phTjB9T/NcVt+zgI9rjQDRwTgPrvKcn5v4CDYIfT/vtFiS/UHxRr/AYHwQ4t9DiVwihZ/+KN36ATKJsS9U+utr9r/EGQdQSUNFKa/geZkImQ/2rHlznnQDG7oX9b9Xwl5AUl6G9oLcSSxl8Q/p4P13YJIaQMisvzEkJ2lJjnJyQY3lnoJGfNUvP8oUhZf7c70s2eCG1wL7uhRJ0iQnCveiDIhzf7t/f9IvP8IUhJfx/b9rErUkvgRVPIE1fv6xrvbzweu7OzM3d7e4v3OhfSilT092HMJzCxF4u43eWctfFvt1uHu9nxXvF1CWmtroldfx9W+HVErINAjX+M65ngAPxnOAJ1AiMhrUjBCdD4Oya2QYBlPwx8vV47WwFg+a+XZbrz83NzANz/ByBmJ0Dj74lYBgECfrbnt6U/DB/vC7388L2rqyu8vzshwYjRCdD4e8YfBLidVgYA0X7M9jB8PGazmbu5ualnfiz9dSAsufwPTwz6+5jjp/H3CD5ofPB9343u9v3u6+U+0jyY7eEA8Hx3d4c/QjvvMyGdMZT+TeA9wBHR+DPHUn3T6bRe7uMxn89tn18v/TH7O17gQEheYM9vEX7M9hbsg/FbHED3/IPPSISQgNhyE0au+7x7PPtOQFcB3PMTMjTYf4cyRN3zL2DgMHgs/7XU99acgDIWEgUh9W/4uWMh8QKBvCh8qxSR7fmxt0eEv8kJ6MzP8/2REFL/g59bp/o0xsMAb6xAnBB5Yr+6D3X9KOpBxP/ACWA0jFnoEw+h9D/4mYd5/pGQeAlRLFK95tJy+35578PDQ+0E9LAPi3wixAUsFmKRT6I0DIIPzdJuf6R3i+UeZnsz/nqjPx47/fMpZ/54OVb/g5/BZi4pY4Pgo8s2d3CkF0Z/cXFRL/+Xy2W9BdBUH4/5JsBn9W94PZu5pI77QzMOjepiNp/j71hO//fv31sr7qmtfT73i3xWjnvAZHhH/4nquXrLwB2bueSJ27Vmvodhq4df4BmzvQb3IPxWl/zgRl/DwZA4GrhdYFUHfbHE1y0enXsJ2FLfCnggvjqBejDoTI8o38ocgJAscNq8BY4fv/Uf+J46gjkdQcbA+19fXzs7zQfR8TWcgH+kFw/u+fMDKz/o3OQETk9PLcWLPSBbeeWELd91eb+CcTc5gXr6r9J8PNKbF/7S3z+6DYcvDasBOv6M0GUduNDfv+cEYPhjIVmA+I3Vc4gaOQzfHAECvb4joAPICCzlrIJP93h/dAIYDBQ/L8wBNC37rXUblv5CB5AfGvi5h6F7Ed9GJ2CZP0b780O1vreVnnhOAFsBOoCMscg/HMBbTsCO+grJFkvvHmYCSnYA/5MMcbsiH6TykNgfr9fry58/f0oltFxcXMj379+l+h42gBcnJyfr6iXfq1nhJ56FZIeuAq+fn59Xv379Oq0CgVJNBEIydAAavLv98ePHeSX4bfX1OQSv9noQ/a7y9A8HTuAcTqB63FSPZyE5Mq3GwOW3b99kNpu9+5e/fv2Kp3+FpAW8vB3cwbLOOvZYfl9LfGdW9KOn+mZCskZXhCuL9vtLfjvshd97hWArpn8TxGn5rhZzOL/gB19DYBzzxcEeTQEtGfArB7c7xbmyVu4YExoTuNcYEL6eCkkTxHYOmna4wzQfvq8z/+o949e940hIkjTp5/ZXjm/1+VQfr856UP/EcLtqr9s/OQENDl5+wPhH3nHQZK6mJjucNvNo2w+A+icC0jaY4a2LT5MT+Mye3+l58JSupiY7XIA2XtQ/IZw2f7D9v+X6D53AZ/f8LqGrqckOF7CNF/VPAF3Or6xvv53r951Amx5+DYOAXWEjxXXQxov6R4zTSzusht8OfABE+r3U39y1iPbbIODVX3ED4/Tagk8kENQ/QiyaC1Fg7PX6frm0Mk6/wUOQ8l799+j9I0cDwcF1ov4R4Xbde2vjxi92ogsPzPrY92szD7buJiQn3K6+v17q2yxvlV1u3+TRAn4jIYTkAfbymOWx1AcwfHMEXp5/JISQ9PEDd867ohvGbvt+cwRe6+5ee7ltNpuVf7yYdA8+68fHxy0+exkY6t8RGnSxJX19yAd7fWvhjEs7NOCHb2D9/+AGqO3HQGSeuD/8PD/GggwM9e8IBPCwr7ciHnzA6NrqtW5+4QRkIByLRXrDRXhXH/XvCKRccEuPX8mHD9jr7Vc7AV32D9rJh4Oge2I0foP6d8QHnADO9kdxYw8HQXfEbPwG9e+It5yAlvdG1beNgyA8KRi/Qf07oskJIEYQw8x/SMMgGAs5CmR0UjF+g/oHwh00YzAn0OZgT1/YINBU5VTIUeCzw2eYivEb1L8l7o1mDm7X220a48x/iNtVLE4dC5OOxu2794wlMaj/kbgAzRwIIQmS4p6PEBKIp6enexo/IYWCPdNms1nnbPxat7BwvH/+P7Dt08/kUjKH+hcOxGeeeI8f86lYSuZQ/8JhsciehoBv9rMi9VdcwZcucBCkVeEXmuL1dy0vbciBkgdBycZvFKs/8/x7ShwENP49xelP8V9T0iBgncdritGfxv82/iDIORJ+EAGfCKnJXn8a//to7fgy51y45sCX1P812erPZR8hBVMZ/Ax9+2j8hBSIHumcpXikkxBCBsXtz8QnUyXndvfz8Sx8AFLUnwTEveyKE32KyAK+7IYThqT0V88/o+cPBz7TVPLEJdb2d00y+pv4elHHTEgwUigWYaq3O6LXn56/e2IeBDT+7olWf4rfHzEOAurfH9HpT/H7J6ZBQP37Jxr9Kf5w+IMAt9PKQOB6NurfP4Prjyg/jX9Y8JnDAHE/vQwE/m0MQOrfP4PqX/3jp15Dj4kQQspCK5SK7OZDCCGEEBIfbneH4kgCoT9vLCQJguqPaD8CDdXzlZDogaEuFotgKSLL9uBnYmAJiZqg+vupPlzbJSR6YKSh8sSODVyTI5j+LO9NlxDFIqzzSJfW+jPPnz4Ng+DDGRvqnz5t9GeePxNsEHx2+U798+BY/e3FzPNnwLE6Uv88oI6EEEIIIYQQQgghhBBCCCGEEEIIIYQQQkiRoHyQxz/T51gdqX8evKfjlzdeNHp4eFjp15OTk5N/hCQHjoFWOt7o139VOj5/8HXUPwOO1f+/02ApXEhJmmnTzIP6p49r28wlRFMJMgwhmnlQ/3RB854g/RwaBgF7wkVOyGYe1D9N0L4vWDMXGwTaFHIsJGpgpF5TyIm0hPqnR6XTdLPZrF2oZi7aVIDePxFgqCH1ov6EEEIIITHRtl7jixBCkuToPH8ocGMQrihmiqh/8Jnjau6hrwen/sPQOs8fAgxA5on7xxcfBigDQf2HIUSdR6g3wmKRnolGfKH+QxCT/vaGOAh6Ijrxhfr3SYz613AQdE+04gv174Ng5b1dwUHQHTEbv0H9u6X6PGeTySTu69oaBsFYSCui9/we1L87tBpzFv1naoPg8vISA2AqpBX4DPFZxm78BvUn9awF8R07yrRGPf80pdmU+hNCyJHoYa4ZHSghhWEBXwT84ASEEFIGDdmec8mJ6j+EyNAiu/9YACC+fjaXkinU/21SSPW2BuIzT/waX/yKpWQK9W+mCOMHLBZ5TfbLPg/q/5pijN/gINhTnPhC/X1cwAauScFBUKbxG9R/h9P7F0rTv6bkQVCy8Rt0Aju00OtUSqTEQZBSbX/X0AmQF4Mg5wi4cRAJn0jhlKY/aUBrx5c558ANzYUvafx7StAfqxv0UKyer4QQUg5+zAfXdgkhpAxKqvMghHgUm+cPhdufhU/Oa+qRTp6Jb0HK+oOi8/whcC+74SSTIrJlH7vitCMl/RHcqx4I8uHN/u19v9w8f1swi6aWJ+aeLxyp6F+9r2u8v/F47M7Oztzt7S3e61xIe1IqFmGFX3hi19/tLuesjX+73brFYlG/V3xdQlq7F1JwAjT+7ohVfzX+Ma5ngwPwn+EI1AmMhLQnZidA4++e2PTHsh8Gvl6vna0AsPzXy1Ld+fm5OQDu/0MRoxOg8fdHLPoj4Gd7flv6w/DxvtDLD9+7urrC+7sTEhZ/EOB2WhkYE57G3w8x6I9oP2Z7GD4es9nM3dzc1DM/lv46FpZc/ncEBgEMD7XVMjB4DxiINP7+GEp/t7/voF7uI0WJ2R4OAM93d3f4I7TzPhNCSD5Yqm86ndbLfTzm87nt8+ulP2Z/x+vQCMkL7Pktwo/Z3oJ9MH6LA+ief/AVKSEkILbdgJHr3v4ez74T0FUA9/wxgP1XF0Lozx0LiZqQ+uuefwEDh8Fj+a+lvrfmBJSxkOGBEF4UNliKyFJ9usdjgCdSQupve37s7RHhb3ICOvPzfH8swDhD54kb8vwjIVESSn+/ug91/SjqQcT/wAlgNhiz0CcyQhaLsMgnPULoX73m0nL7fnnvw8ND7QT0sA+LfGKlYRB82ks7NnNIlmP1d/sjvVtsJTDbm/HXG/3x2OmfTznzR44NgmOX7Y7NHJLms/q7gyO9MPqLi4t6+b9cLustgKb6eMw3FdwfmjFggKg3X71l4I7NHJLmHf3PVPs5/o7l9H///r214p7a2udzv8hn5RgDShsN3Czg1SE4lom6xKO4heB2rdnvYdi6QljgGbO9BvfgOLa65Ac3+hpOBinjtHkDhMdv/Qe+p45gTkeQL7bUtwIeaK5OoJ4MdKZHlG9lDkBIPsDzQ/QmJ3B6emopHqwB2corQzDDX19fOzvNh7GAr+EE/CO9eHDPnxH+0t8/ugnBpWE1QOHzwpbvurxfwbibnEA9/VdpPh7pzQjs3yyfK2rkMHxzBAj0+I6ADiAvdFsHLvT37zkBGP5YSB6YA2ha9lvrJiz9hQ4gO7CVswo+jfH80QlgMqD2GaKC35unF88JYCtAB5AnGvi9h6F7GZ9GJ2CZP0b7M8XSO4eZADqAvLHIPxzAW07AjvpKYfxPCkBngevn5+fVr1+/TqtAoFQDQUieuF2RD1J5SOyP1+v15c+fP6Vy9HJxcSHfv3+X6nsIAF2cnJysq5d8r1YAP/EshVGEA6iYVkZ/+e3bN5nNZu/+5a9fv+LpXyHJocG72x8/fpxXDv+2+vocDr+K9cDp31UrvYcDJ3AOJ1A9bqrHs5D80BlhZdF+f8lvhz3we68QZMX0T3pglWcHd6Cjdeyx/L6W+M6s6EdP9c2ElIHbneJaWStnFIRoTOBe94D4eiokSZyW72oxl/MLfvA1jB6642CPpoCXDPhljO79RwffG6kj2OrzqT5e1Xo3vZ7EC2K7B0073GGaD9/XmX/1nvFT/4Rx2syjbT+AIW+gIZ/D7ao9b//kBDQ4ePkB46f+qeICtPFy2g8gpavJSwZpW8zw1sWnyQl8Zs9P/RPFBWzj5RK6mrxkTCfb/1uu/9AJfHbPT/0Tw3XQxqthELArcETocn5lffvtXL/vBNr08KP+CQFxvLbQEwmEDQJe/RQXTi/tsBp+O/AFEOn3Un9z1yLaT/0TQgNBwb20Zg/o/SPBsjkwShh7vb5fLq2M22/wEqS8V/+9sRBChsXtuvfWxo1f7EQnHpj1se/XZh5s3U1ITrhdfX+91LdZ3io73b7JqwX8RkIIyQPs5THLY6kPYPjmCLw8/0hI3iAd8/j4uN1sNisZGLwH/3gpCYcfuHPeFd0wdtv3myPwWnf32suR+veMn+fHBy8DA0fEPHF4NOhmS/r6kA/2+tbCHZd2aMAP38D6/8ENUNtP/XvERXhXn2OxSCcggId9vRXx4LNF12avdfsLJyADQf17IkbjNzgIwoOUK27p8Sv58Nl6vf1qJ6DL/kE7+VD/jonZ+A0OgvB8wAngbH8UN/ZQ/45IwfgNDoLwvOUEtLw3qr6N1D8wiOimYvxGwyAYC2lFkxNAjCCGmf8Q6h8QRHeR7knF+A0bBJqqmgr5NO6gGYc5gTYHe/qC+gfC7bv3jCUx3K5ibepYmPJp3BvNXNyut+M0xpn/EOpPyBG4AM1cCCEJkmLMhxASiKenp3saf4Fg2Vc9FsjpSuZo3hr/115r1lMAe+bNZrPO2fip/wH+nq9iKZkD8ZknLhfq79EQ8MneK7JYpGyov5JShV9oOAjKvnSjeP1LNn6j5EHgWl7akgPF6k/j31PiIGCef09x+jPP+5qSBgGd/2uKcgIHEdCJkBp/EOSaCaHxv00J+tdoDnRJ8V+jtePLHGshaPzvk7P+pGC47SOkYCqDn6FvH42fkAJxuyPdaN01FlIGbnc/37TkFE8o3L4nAmvHCyQ5/S3gw24oYXAvuyKxbLgwktK/xNr+rsFqKpU8sa78Zlz5hSMZ/Znq6Y4UikVMf72oYyYkGNHrT+PvnpgHAVd+3ROt/jT+/ohxEFD//ohOf4rfPzENAurfP1E5AVzPRPH7xx8EuJ1WBoDGPxyH+ruhjlTjbnR9AxMhvYLPHA4YGkjPIMpP4x+WIfUnhYMZx2voMRFCSFlohVqR3XwIIaQc3O5OtrGQJFC9RkKKRCsyRxICi/YuFgvs986ERA3Eh1ahUkT4GQg0Vc9XQqInqP6ODRyTA046VJ7Y1x/XdgmJnmD6M8+bLiGKRVjemy6t9WeeN30aBsGHI/bUP33a6M88bybYIPjs9o3658Gx+tuLmefNgGN1pP55QB0JIYQQQgghhBBCCJGy+T9ftRg+rVNPfAAAAABJRU5ErkJggg==')"
      }
    }
  ), A2 && reactDomExports.createPortal(g6, document.body));
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
function c$o(t6, n10, e3, i16) {
  if (t6) {
    const a9 = {
      syntheticEvent: n10,
      nativeEvent: n10.nativeEvent,
      target: e3
    };
    t6.call(void 0, Object.assign(a9, i16));
  }
}
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
function o$n({ onFocus: u5, onBlur: l7, onSyncFocus: i16, onSyncBlur: a9 }) {
  const r12 = reactExports.useRef(false), c6 = reactExports.useRef(0), s10 = reactExports.useCallback(
    (e3) => {
      clearTimeout(c6.current), c6.current = window.setTimeout(() => e3());
    },
    [c6]
  ), f4 = reactExports.useCallback(
    (...e3) => {
      clearTimeout(c6.current), i16 && i16.call(void 0, e3[0]), !r12.current && (r12.current = true, u5 && u5.call(void 0, ...e3));
    },
    [r12, u5, i16]
  ), n10 = reactExports.useCallback(
    (...e3) => {
      a9 && a9.call(void 0, e3[0]), s10(() => {
        r12.current && l7 && (r12.current = false, l7.call(void 0, ...e3));
      });
    },
    [r12, s10, l7, a9]
  );
  return reactExports.useEffect(() => () => {
    clearTimeout(c6.current);
  }, []), {
    onFocus: f4,
    onBlur: n10
  };
}
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const a$w = ({
  children: e3,
  onFocus: t6,
  onBlur: c6,
  onSyncFocus: o9,
  onSyncBlur: s10
}) => {
  const n10 = o$n({ onFocus: t6, onBlur: c6, onSyncFocus: o9, onSyncBlur: s10 });
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, e3.call(void 0, { ...n10 }));
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const n$u = (t6, o9) => reactExports.useContext(t6)(o9);
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const a$v = () => reactExports.createContext((t6) => t6), x$l = (t6, o9) => reactExports.forwardRef((r12, n10) => {
  const s10 = n$u(t6, r12);
  return /* @__PURE__ */ reactExports.createElement(o9, { ...s10, ref: n10 });
});
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const t$l = typeof window != "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
function m$m(e3) {
  const [u5, c6] = reactExports.useState(false);
  reactExports.useEffect(() => {
    c6(true);
  }, []);
  const [r12, n10] = reactExports.useState(() => {
    if (e3)
      return e3;
    if (u5)
      return i$u();
  });
  t$l(() => {
    r12 === void 0 && n10(i$u());
  }, []);
  const o9 = t$r[`useId${i$u()}`.slice(0, 5)];
  if (o9 !== void 0) {
    const f4 = o9();
    return e3 != null ? e3 : f4;
  }
  return r12;
}
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const m$l = (r12) => reactExports.forwardRef((e3, o9) => {
  const i16 = m$m(e3.id);
  return /* @__PURE__ */ reactExports.createElement(r12, { ...e3, id: i16, ref: o9 });
});
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const e$y = t$q.createContext(void 0), n$t = () => t$q.useContext(e$y);
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const l$o = (t6) => reactExports.forwardRef((r12, n10) => {
  const o9 = n$t();
  return /* @__PURE__ */ reactExports.createElement(t6, { ...r12, ref: n10, unstyled: o9 });
});
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const h$e = (o9, l7, u5 = {}) => {
  const c6 = reactExports.useCallback(
    (n10) => {
      u5.onMouseDown && u5.onMouseDown.call(void 0, n10), o9.onMouseDown && o9.onMouseDown.call(void 0, {
        target: l7.current,
        syntheticEvent: n10
      });
    },
    [u5.onMouseDown, o9.onMouseDown, l7]
  ), M3 = reactExports.useCallback(
    (n10) => {
      u5.onMouseUp && u5.onMouseUp.call(void 0, n10), o9.onMouseUp && o9.onMouseUp.call(void 0, {
        target: l7.current,
        syntheticEvent: n10
      });
    },
    [u5.onMouseUp, o9.onMouseUp, l7]
  ), i16 = reactExports.useCallback(
    (n10) => {
      u5.onClick && u5.onClick.call(void 0, n10), o9.onClick && o9.onClick.call(void 0, {
        target: l7.current,
        syntheticEvent: n10
      });
    },
    [u5.onClick, o9.onClick, l7]
  ), s10 = reactExports.useCallback(
    (n10) => {
      u5.onDoubleClick && u5.onDoubleClick.call(void 0, n10), o9.onDoubleClick && o9.onDoubleClick.call(void 0, {
        target: l7.current,
        syntheticEvent: n10
      });
    },
    [u5.onDoubleClick, o9.onDoubleClick, l7]
  ), a9 = reactExports.useCallback(
    (n10) => {
      u5.onMouseEnter && u5.onMouseEnter.call(void 0, n10), o9.onMouseEnter && o9.onMouseEnter.call(void 0, {
        target: l7.current,
        syntheticEvent: n10
      });
    },
    [u5.onMouseEnter, o9.onMouseEnter, l7]
  ), v3 = reactExports.useCallback(
    (n10) => {
      u5.onMouseLeave && u5.onMouseLeave.call(void 0, n10), o9.onMouseLeave && o9.onMouseLeave.call(void 0, {
        target: l7.current,
        syntheticEvent: n10
      });
    },
    [u5.onMouseLeave, o9.onMouseLeave, l7]
  ), k3 = reactExports.useCallback(
    (n10) => {
      u5.onMouseMove && u5.onMouseMove.call(void 0, n10), o9.onMouseMove && o9.onMouseMove.call(void 0, {
        target: l7.current,
        syntheticEvent: n10
      });
    },
    [u5.onMouseMove, o9.onMouseMove, l7]
  ), C2 = reactExports.useCallback(
    (n10) => {
      u5.onMouseOut && u5.onMouseOut.call(void 0, n10), o9.onMouseOut && o9.onMouseOut.call(void 0, {
        target: l7.current,
        syntheticEvent: n10
      });
    },
    [u5.onMouseOut, o9.onMouseOut, l7]
  ), f4 = reactExports.useCallback(
    (n10) => {
      u5.onMouseOver && u5.onMouseOver.call(void 0, n10), o9.onMouseOver && o9.onMouseOver.call(void 0, {
        target: l7.current,
        syntheticEvent: n10
      });
    },
    [u5.onMouseOver, o9.onMouseOver, l7]
  );
  return {
    onClick: i16,
    onMouseUp: M3,
    onMouseDown: c6,
    onDoubleClick: s10,
    onMouseEnter: a9,
    onMouseLeave: v3,
    onMouseMove: k3,
    onMouseOut: C2,
    onMouseOver: f4
  };
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const n$s = () => null, r$q = ({ children: e3 }) => e3, s$p = (e3) => {
  if (e3) {
    if (e3 === reactExports.Fragment)
      return [r$q, {}];
    if (reactExports.isValidElement(e3))
      return [e3.type, e3.props];
  } else
    return [n$s, {}];
  return [e3, {}];
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const o$m = (e3) => {
  const t6 = reactExports.useCallback(
    () => e3.current && e3.current.element ? e3.current.element : e3.current,
    [e3]
  );
  return reactExports.useCallback(() => {
    const n10 = t6();
    return n10 && n10.ownerDocument || document;
  }, [t6]);
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const x$k = {
  default: "",
  xsmall: "k-icon-xs",
  small: "k-icon-sm",
  medium: "k-icon-md",
  large: "k-icon-lg",
  xlarge: "k-icon-xl",
  xxlarge: "k-icon-xxl",
  xxxlarge: "k-icon-xxxl"
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const n$r = (o9) => "k-i-" + o9, t$k = o$r.shape({
  name: o$r.string.isRequired,
  content: o$r.string.isRequired,
  viewBox: o$r.string.isRequired
});
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const u$p = reactExports.forwardRef((a9, d8) => {
  const {
    className: n10,
    name: s10,
    themeColor: t6,
    size: i16,
    flip: m3,
    style: h3,
    id: g6,
    tabIndex: x3,
    ...y4
  } = a9, l7 = reactExports.useRef(null), c6 = reactExports.useRef(null);
  reactExports.useImperativeHandle(l7, () => ({
    element: c6.current
  })), reactExports.useImperativeHandle(d8, () => l7.current);
  const f4 = reactExports.useMemo(
    () => i16 || p$y.size,
    [i16]
  ), r12 = reactExports.useMemo(
    () => m3 || p$y.flip,
    [m3]
  ), z3 = reactExports.useMemo(
    () => r$r(
      "k-icon",
      "k-font-icon",
      s10 && n$r(s10),
      {
        [`k-color-${t6}`]: t6,
        "k-flip-h": r12 === "horizontal" || r12 === "both",
        "k-flip-v": r12 === "vertical" || r12 === "both"
      },
      x$k[f4],
      n10
    ),
    [s10, t6, f4, r12, n10]
  ), I3 = h$e(a9, l7);
  return /* @__PURE__ */ reactExports.createElement(
    "span",
    {
      ref: c6,
      ...y4,
      ...I3,
      className: z3,
      id: g6,
      tabIndex: x3,
      style: h3,
      role: "presentation"
    }
  );
});
u$p.propTypes = {
  style: o$r.object,
  classNames: o$r.string,
  name: o$r.string,
  themeColor: o$r.oneOf([
    "inherit",
    "primary",
    "secondary",
    "tertiary",
    "info",
    "success",
    "error",
    "warning",
    "dark",
    "light",
    "inverse"
  ]),
  size: o$r.oneOf(["default", "xsmall", "small", "medium", "large", "xlarge", "xxlarge", "xxxlarge"]),
  flip: o$r.oneOf(["default", "horizontal", "vertical", "both"])
};
const p$y = {
  size: "default",
  flip: "default"
};
u$p.displayName = "KendoIcon";
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const e$x = {
  prefix: "k",
  important: "!",
  rtl: "rtl",
  rounded: "rounded",
  value: "value",
  state: "state",
  filter: "filter",
  virtual: "virtual",
  infinite: "infinite",
  clear: "clear",
  reset: "reset",
  data: "data",
  nodata: "nodata",
  scroller: "scroller"
}, n$q = {
  center: "center",
  hbox: "hbox",
  vstack: "vstack",
  hstack: "hstack",
  overflow: "overflow"
}, t$j = {
  actionsheet: "actionsheet",
  calendar: "calendar",
  buttongroup: "buttongroup",
  dateinput: "dateinput",
  datetime: "datetime",
  datetimepicker: "datetimepicker",
  dropdownlist: "dropdownlist",
  combobox: "combobox",
  maskedtextbox: "maskedtextbox",
  menu: "menu",
  searchbox: "searchbox",
  timepicker: "timepicker"
}, l$n = {
  xsmall: "xs",
  small: "sm",
  medium: "md",
  large: "lg",
  xlarge: "xl",
  xxlarge: "xxl",
  xxxlarge: "xxxl"
}, s$o = {
  solid: "solid",
  outline: "outline",
  flat: "flat",
  link: "link",
  clear: "clear"
}, c$n = {
  base: "base",
  primary: "primary",
  secondary: "secondary",
  tertiary: "tertiary",
  info: "info",
  success: "success",
  warning: "warning",
  error: "error",
  dark: "dark",
  light: "light",
  inherit: "inherit",
  inverse: "inverse"
}, d$r = {
  small: "sm",
  medium: "md",
  large: "lg",
  full: "full"
}, p$x = {
  vertical: "vertical",
  horizontal: "horizontal"
}, m$k = {
  height: "height",
  width: "width"
}, u$o = {
  default: "cursor-default"
}, f$g = {
  up: "up",
  down: "down",
  left: "left",
  right: "right",
  start: "start",
  mid: "mid",
  end: "end"
}, r$p = {
  actions: "actions",
  container: "container",
  content: "content",
  group: "group",
  row: "row",
  nav: "nav",
  wrap: "wrap",
  wrapper: "wrapper",
  list: "list",
  placeholder: "placeholder",
  popup: "popup",
  item: "item",
  part: "part",
  picker: "picker",
  separator: "separator",
  spacer: "spacer",
  tab: "tab",
  titlebar: "titlebar",
  optionLabel: "optionlabel",
  view: "view"
}, a$u = {
  table: "table",
  text: "text",
  button: "button",
  tbody: "tbody",
  thead: "thead",
  tr: "tr",
  th: "th",
  td: "td",
  header: "header",
  footer: "footer",
  icon: "icon",
  title: "title",
  subtitle: "subtitle",
  link: "link",
  label: "label",
  ul: "ul",
  caption: "caption"
}, h$d = {
  increase: "increase",
  decrease: "decrease",
  cancel: "cancel",
  accept: "accept",
  split: "split"
}, x$j = {
  active: "active",
  adaptive: "adaptive",
  first: "first",
  focus: "focus",
  pending: "pending",
  last: "last",
  draggable: "draggable",
  filterable: "filterable",
  grouping: "grouping",
  selected: "selected",
  disabled: "disabled",
  hidden: "hidden",
  highlight: "highlight",
  invalid: "invalid",
  loading: "loading",
  required: "required",
  checked: "checked",
  empty: "empty",
  scrollable: "scrollable",
  sorted: "sorted",
  sort: "sort",
  sticky: "sticky",
  stretched: "stretched",
  order: "order",
  alt: "alt",
  edit: "edit",
  template: "template",
  shown: "shown",
  horizontal: "horizontal",
  vertical: "vertical",
  fullscreen: "fullscreen",
  bottom: "bottom"
}, b$c = {
  prefix: "animation",
  child: "child",
  relative: "relative",
  slide: "slide",
  appear: "appear",
  active: "active",
  enter: "enter",
  exit: "exit",
  pushRight: "push-right",
  pushLeft: "push-left",
  pushDown: "push-down",
  pushUp: "push-up",
  expandVertical: "expand-vertical",
  expandHorizontal: "expand-horizontal",
  fade: "fade",
  zoomIn: "zoom-in",
  zoomOut: "zoom-out",
  slideIn: "slide-in",
  slideDown: "slide-down",
  slideUp: "slide-up",
  slideRight: "slide-right",
  slideLeft: "slide-left",
  revealVertical: "reveal-vertical",
  revealHorizontal: "reveal-horizontal",
  "animation-container": "animation-container",
  "animation-container-shown": "animation-container-shown",
  "animation-container-relative": "animation-container-relative",
  "animation-container-fixed": "animation-container-fixed",
  "child-animation-container": "child-animation-container"
}, i$s = {
  input: "input",
  inner: "inner",
  spin: "spin",
  spinner: "spinner",
  maskedtextbox: "maskedtextbox",
  radio: "radio",
  textbox: "textbox",
  prefix: "prefix",
  suffix: "suffix"
}, g$i = {
  week: "week",
  weekdays: "weekdays",
  weekend: "weekend",
  month: "month",
  year: "year",
  decade: "decade",
  century: "century",
  number: "number",
  navigation: "navigation",
  marker: "marker",
  now: "now",
  range: "range",
  today: "today",
  other: "other",
  date: "date",
  time: "time",
  selector: "selector",
  timeselector: "timeselector"
}, v$d = {
  prefix: "icon",
  svg: "svg",
  i: "i",
  color: "color",
  flipH: "flip-h",
  flipV: "flip-v"
}, w$d = {
  label: "label",
  text: "text",
  floatingLabel: "floating-label",
  container: "container",
  hint: "form-hint",
  error: "form-error"
}, y$b = {
  prefix: "popup"
}, o$l = {
  prefix: "grid",
  ariaRoot: "aria-root",
  tableWrap: "table-wrap",
  master: "master",
  column: "column",
  cell: "cell",
  cellInner: "cell-inner",
  row: "row",
  group: "group",
  hierarchy: "hierarchy",
  detail: "detail",
  noRecords: "norecords",
  pager: "pager"
}, $$a = `${e$x.prefix}-${i$s.input}`, z$8 = `${e$x.prefix}-${t$j.calendar}`, L$c = `${e$x.prefix}-${a$u.button}`, I$d = `${e$x.prefix}-${t$j.menu}`, R$7 = `${e$x.prefix}-${r$p.picker}`, D$5 = `${e$x.prefix}-${t$j.dropdownlist}`, H$4 = `${e$x.prefix}-${t$j.combobox}`, U$5 = `${e$x.prefix}-${o$l.prefix}`;
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const c$m = {
  wrapper: {
    main: `${e$x.prefix}-${v$d.prefix}`,
    svgPrefix: `${e$x.prefix}-${v$d.svg}-${v$d.prefix}`,
    namePrefix: `${e$x.prefix}-${v$d.svg}-${v$d.i}-`,
    flipH: `${e$x.prefix}-${v$d.flipH}`,
    flipV: `${e$x.prefix}-${v$d.flipV}`,
    themeColor: {
      inherit: `${e$x.prefix}-${v$d.color}-${c$n.inherit}`,
      primary: `${e$x.prefix}-${v$d.color}-${c$n.primary}`,
      secondary: `${e$x.prefix}-${v$d.color}-${c$n.secondary}`,
      tertiary: `${e$x.prefix}-${v$d.color}-${c$n.tertiary}`,
      info: `${e$x.prefix}-${v$d.color}-${c$n.info}`,
      success: `${e$x.prefix}-${v$d.color}-${c$n.success}`,
      warning: `${e$x.prefix}-${v$d.color}-${c$n.warning}`,
      error: `${e$x.prefix}-${v$d.color}-${c$n.error}`,
      dark: `${e$x.prefix}-${v$d.color}-${c$n.dark}`,
      light: `${e$x.prefix}-${v$d.color}-${c$n.light}`
    },
    size: {
      default: "",
      xsmall: `${e$x.prefix}-${v$d.prefix}-${l$n.xsmall}`,
      small: `${e$x.prefix}-${v$d.prefix}-${l$n.small}`,
      medium: `${e$x.prefix}-${v$d.prefix}-${l$n.medium}`,
      large: `${e$x.prefix}-${v$d.prefix}-${l$n.large}`,
      xlarge: `${e$x.prefix}-${v$d.prefix}-${l$n.xlarge}`,
      xxlarge: `${e$x.prefix}-${v$d.prefix}-${l$n.xxlarge}`,
      xxxlarge: `${e$x.prefix}-${v$d.prefix}-${l$n.xxxlarge}`
    }
  },
  svg: {
    main: "",
    flipH: "",
    flipV: ""
  }
}, m$j = {
  wrapper: (o9) => {
    const { iconNameProp: x3, themeColor: l7, flipH: a9, flipV: f4, size: s10, c: n10 = c$m } = o9, $2 = n10.wrapper || {};
    return {
      [$2.main || ""]: true,
      [$2.svgPrefix || ""]: true,
      [`${$2.namePrefix || ""}${x3}`]: x3,
      [$2.themeColor[l7] || ""]: l7,
      [$2.flipH || ""]: a9,
      [$2.flipV || ""]: f4,
      [$2.size[s10] || ""]: $2.size[s10]
    };
  },
  svg: (o9) => {
    const { flipH: x3, flipV: l7, c: a9 = c$m } = o9, f4 = a9.svg;
    return {
      [f4.main || ""]: true,
      [f4.flipH || ""]: x3,
      [f4.flipV || ""]: l7
    };
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const y$a = reactExports.forwardRef((e3, b2) => {
  const {
    children: z3,
    className: a9,
    svgClassName: N3,
    icon: o9,
    flip: c6,
    id: p6,
    tabIndex: I3,
    size: h3,
    style: l7,
    svgStyle: M3,
    themeColor: r12,
    viewBox: m3,
    name: O2,
    onClick: S2,
    ...B2
  } = e3, d8 = reactExports.useRef(null), f4 = n$t(), u5 = f4 && f4.uSvgIcon;
  reactExports.useImperativeHandle(
    b2,
    () => ({
      element: d8.current
    })
  );
  const g6 = reactExports.useMemo(
    () => o9 ? o9.name : n$p.icon,
    [o9]
  ), v3 = reactExports.useMemo(
    () => h3 || n$p.size,
    [h3]
  ), i16 = reactExports.useMemo(
    () => c6 || n$p.flip,
    [c6]
  ), C2 = reactExports.useMemo(
    () => m3 || n$p.viewBox,
    [m3]
  ), P2 = reactExports.useMemo(
    () => r$r(m$j.wrapper({
      c: u5,
      iconNameProp: g6,
      themeColor: r12,
      flipH: i16 === "horizontal" || i16 === "both",
      flipV: i16 === "vertical" || i16 === "both",
      size: v3
    }), a9),
    [g6, r12, v3, i16, a9]
  ), H3 = reactExports.useMemo(
    () => e3.width && e3.height ? { width: e3.width, height: e3.height, ...l7 } : e3.width ? { width: e3.width, height: e3.width, ...l7 } : e3.height ? { width: e3.height, height: e3.height, ...l7 } : { ...l7 },
    [e3.width, e3.height, l7]
  );
  return /* @__PURE__ */ reactExports.createElement(
    "span",
    {
      className: r$r(m$j.svg({
        c: u5,
        themeColor: r12,
        flipH: i16 === "horizontal" || i16 === "both",
        flipV: i16 === "vertical" || i16 === "both"
      }), P2),
      style: H3,
      ref: d8,
      onClick: S2,
      "aria-hidden": true
    },
    /* @__PURE__ */ reactExports.createElement(
      "svg",
      {
        id: p6,
        className: N3,
        style: M3,
        "aria-hidden": true,
        tabIndex: I3,
        focusable: false,
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: o9 ? o9.viewBox : C2,
        dangerouslySetInnerHTML: o9 ? { __html: o9.content } : void 0,
        ...B2
      },
      o9 ? void 0 : z3
    )
  );
});
y$a.propTypes = {
  style: o$r.object,
  classNames: o$r.string,
  children: o$r.any,
  icon: o$r.object,
  themeColor: o$r.oneOf([
    "inherit",
    "primary",
    "secondary",
    "tertiary",
    "info",
    "success",
    "error",
    "warning",
    "dark",
    "light",
    "inverse"
  ]),
  size: o$r.oneOf(["default", "xsmall", "small", "medium", "large", "xlarge", "xxlarge", "xxxlarge"]),
  flip: o$r.oneOf(["default", "horizontal", "vertical", "both"])
};
const n$p = {
  size: "default",
  flip: "default",
  icon: "",
  viewBox: "0 0 24 24"
};
y$a.displayName = "KendoSvgIcon";
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const e$w = reactExports.createContext({ type: "svg" });
e$w.displayName = "KendoReactIconsContext";
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const v$c = reactExports.forwardRef((o9, c6) => {
  var r12, i16;
  const { type: m3, icons: e3 } = reactExports.useContext(e$w), { icon: s10, ...f4 } = o9;
  let n10 = m3 === "svg" ? ((r12 = o9.icon) == null ? void 0 : r12.name) || o9.name : o9.name || ((i16 = o9.icon) == null ? void 0 : i16.name);
  n10 = n10 && e3 && e3[n10] && typeof e3[n10] == "string" ? e3[n10] : n10;
  const a9 = n10 && e3 && e3[n10] && typeof e3[n10] != "string" ? e3[n10] : s10;
  return m3 === "svg" && a9 ? /* @__PURE__ */ reactExports.createElement(y$a, { ...o9, icon: a9, ref: c6 }) : /* @__PURE__ */ reactExports.createElement(u$p, { ...f4, name: n10, ref: c6 });
});
v$c.displayName = "KendoIconWrap";
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const n$o = reactExports.createContext([
  void 0,
  n$x
]), r$o = reactExports.createContext([
  void 0,
  n$x
]), c$l = reactExports.createContext([[], n$x, n$x]), x$i = reactExports.createContext([[], n$x, n$x]);
var getRatio = function(element, target) {
  var elementRect = element.getBoundingClientRect();
  var targetRect = target.getBoundingClientRect();
  var top = Math.max(targetRect.top, elementRect.top);
  var left = Math.max(targetRect.left, elementRect.left);
  var right = Math.min(targetRect.left + targetRect.width, elementRect.left + elementRect.width);
  var bottom = Math.min(targetRect.top + targetRect.height, elementRect.top + elementRect.height);
  var width = right - left;
  var height = bottom - top;
  if (left < right && top < bottom) {
    var targetArea = targetRect.width * targetRect.height;
    var entryArea = elementRect.width * elementRect.height;
    var intersectionArea = width * height;
    var intersectionRatio = intersectionArea / (targetArea + entryArea - intersectionArea);
    return Number(intersectionRatio.toFixed(4));
  }
  return 0;
};
var intersect$1 = function(element, candidates) {
  var max2 = 0;
  var result = null;
  candidates.forEach(function(candidate) {
    if (candidate && element) {
      var ration = getRatio(element, candidate);
      if (ration > max2) {
        max2 = ration;
        result = candidate;
      }
    }
  });
  return result;
};
var detectBrowser = function() {
  var ua2 = window && window.navigator.userAgent;
  if (!ua2) {
    return false;
  }
  var browser2 = false;
  var match2 = [];
  var browserRxs = {
    edge: /(edge)[ \/]([\w.]+)/i,
    webkit: /(chrome|crios)[ \/]([\w.]+)/i,
    safari: /(webkit)[ \/]([\w.]+)/i,
    opera: /(opera)(?:.*version|)[ \/]([\w.]+)/i,
    msie: /(msie\s|trident.*? rv:)([\w.]+)/i,
    mozilla: /(mozilla)(?:.*? rv:([\w.]+)|)/i
  };
  for (var agent in browserRxs) {
    if (browserRxs.hasOwnProperty(agent)) {
      match2 = ua2.match(browserRxs[agent]);
      if (match2) {
        browser2 = {};
        browser2[agent] = true;
        browser2[match2[1].toLowerCase().split(" ")[0].split("/")[0]] = true;
        browser2.version = parseInt(document.DOCUMENT_NODE || match2[2], 10);
        break;
      }
    }
  }
  return browser2;
};
var getDocument$1 = function(element) {
  return element ? element.ownerDocument || window.document : window.document;
};
var getWindow$2 = function(element) {
  var document2 = getDocument$1(element);
  return document2 ? document2.defaultView || window : window;
};
var scrollableRoot = function(element) {
  var support2 = { browser: detectBrowser() };
  var document2 = getDocument$1(element);
  return support2.browser.edge || support2.browser.safari ? document2.body : document2.documentElement;
};
var isScrollable = function(el2) {
  if (el2 && el2.className && typeof el2.className === "string" && el2.className.indexOf("k-auto-scrollable") > -1) {
    return true;
  }
  var overflow = window.getComputedStyle(el2, "overflow").overflow;
  return overflow.indexOf("auto") > -1 || overflow.indexOf("scroll") > -1;
};
var getScrollableParent = function(el2) {
  var root = scrollableRoot(el2);
  if (!el2 || el2 === document.body || el2 === document.documentElement) {
    return root;
  }
  var parent = el2;
  while (parent && parent !== document.body && parent.nodeType !== Node.DOCUMENT_FRAGMENT_NODE && parent.nodeType !== Node.DOCUMENT_NODE && !isScrollable(parent)) {
    parent = parent.parentNode;
  }
  if (parent && (parent === document.body || parent.nodeType === Node.DOCUMENT_FRAGMENT_NODE)) {
    return root;
  }
  return parent;
};
var autoScrollVelocity = function(mouseX, mouseY, rect) {
  var velocity = { x: 0, y: 0 };
  var AUTO_SCROLL_AREA = 50;
  if (mouseX - rect.left < AUTO_SCROLL_AREA) {
    velocity.x = -(AUTO_SCROLL_AREA - (mouseX - rect.left));
  } else if (rect.right - mouseX < AUTO_SCROLL_AREA) {
    velocity.x = AUTO_SCROLL_AREA - (rect.right - mouseX);
  }
  if (mouseY - rect.top < AUTO_SCROLL_AREA) {
    velocity.y = -(AUTO_SCROLL_AREA - (mouseY - rect.top));
  } else if (rect.bottom - mouseY < AUTO_SCROLL_AREA) {
    velocity.y = AUTO_SCROLL_AREA - (rect.bottom - mouseY);
  }
  return velocity;
};
var scrollableViewPort = function(el2, window2) {
  var root = scrollableRoot(el2);
  if (el2 === root) {
    return {
      top: root.scrollTop,
      left: root.scrollLeft,
      bottom: root.scrollTop + window2.innerHeight,
      right: root.scrollLeft + window2.innerWidth
    };
  } else {
    var rect = el2.getBoundingClientRect();
    return {
      bottom: rect.top + rect.height,
      right: rect.left + rect.width,
      left: rect.left,
      top: rect.top
    };
  }
};
var isPointerInsideContainer = function(x3, y4, container) {
  var rect = container.getBoundingClientRect();
  return rect.top <= y4 && rect.left <= x3 && y4 <= rect.bottom && x3 <= rect.right;
};
var DRAG_AND_DROP_DISPATCH_ACTION;
(function(DRAG_AND_DROP_DISPATCH_ACTION2) {
  DRAG_AND_DROP_DISPATCH_ACTION2["POINTER_DOWN"] = "pointerdown";
  DRAG_AND_DROP_DISPATCH_ACTION2["POINTER_MOVE"] = "pointermove";
  DRAG_AND_DROP_DISPATCH_ACTION2["POINTER_UP"] = "pointerup";
  DRAG_AND_DROP_DISPATCH_ACTION2["POINTER_CANCEL"] = "pointercancel";
  DRAG_AND_DROP_DISPATCH_ACTION2["MOUSE_DOWN"] = "mousedown";
  DRAG_AND_DROP_DISPATCH_ACTION2["MOUSE_MOVE"] = "mousemove";
  DRAG_AND_DROP_DISPATCH_ACTION2["MOUSE_UP"] = "mouseup";
  DRAG_AND_DROP_DISPATCH_ACTION2["CONTEXT_MENU"] = "contextmenu";
  DRAG_AND_DROP_DISPATCH_ACTION2["TOUCH_START"] = "touchstart";
  DRAG_AND_DROP_DISPATCH_ACTION2["TOUCH_MOVE"] = "touchmove";
  DRAG_AND_DROP_DISPATCH_ACTION2["TOUCH_END"] = "touchend";
  DRAG_AND_DROP_DISPATCH_ACTION2["TOUCH_CANCEL"] = "touchcancel";
  DRAG_AND_DROP_DISPATCH_ACTION2["SCROLL"] = "scroll";
  DRAG_AND_DROP_DISPATCH_ACTION2["START"] = "KENDO_DRAG_AND_DROP_START";
  DRAG_AND_DROP_DISPATCH_ACTION2["MOVE"] = "KENDO_DRAG_AND_DROP_MOVE";
  DRAG_AND_DROP_DISPATCH_ACTION2["END"] = "KENDO_DRAG_AND_DROP_END";
  DRAG_AND_DROP_DISPATCH_ACTION2["CANCEL"] = "KENDO_DRAG_AND_DROP_CANCEL";
})(DRAG_AND_DROP_DISPATCH_ACTION || (DRAG_AND_DROP_DISPATCH_ACTION = {}));
var isTouchEvent = function(event) {
  return /^touch/.test(event.type);
};
var isScrollEvent = function(event) {
  return /^(scroll)/.test(event.type);
};
var normalizeEvent = function(event, state) {
  return isTouchEvent(event) ? {
    pageX: event.changedTouches[0].pageX,
    pageY: event.changedTouches[0].pageY,
    clientX: event.changedTouches[0].clientX,
    clientY: event.changedTouches[0].clientY,
    scrollX: state.scrollOffset.x,
    scrollY: state.scrollOffset.y,
    offsetX: state.offset.x,
    offsetY: state.offset.y,
    type: event.type,
    originalEvent: event,
    isTouch: true,
    altKey: false,
    ctrlKey: false,
    shiftKey: false,
    metaKey: false
  } : isScrollEvent(event) ? {
    pageX: state.pageOffset.x,
    pageY: state.pageOffset.y,
    clientX: state.clientOffset.x,
    clientY: state.clientOffset.y,
    scrollX: state.scrollOffset.x,
    scrollY: state.scrollOffset.y,
    offsetX: state.offset.x,
    offsetY: state.offset.y,
    type: event.type,
    originalEvent: event,
    altKey: false,
    ctrlKey: false,
    shiftKey: false,
    metaKey: false
  } : {
    pageX: event.pageX,
    pageY: event.pageY,
    clientX: event.clientX,
    clientY: event.clientY,
    offsetX: event.offsetX,
    offsetY: event.offsetY,
    scrollX: state.scrollOffset.x,
    scrollY: state.scrollOffset.y,
    type: event.type,
    ctrlKey: event.ctrlKey,
    shiftKey: event.shiftKey,
    altKey: event.altKey,
    metaKey: event.metaKey,
    originalEvent: event
  };
};
var noop$1 = function() {
};
var dispatchDragAndDrop = function(state, action, callbacks) {
  if (callbacks === void 0) {
    callbacks = {};
  }
  var _a = callbacks.onIsPressedChange, onIsPressedChange = _a === void 0 ? noop$1 : _a, _b = callbacks.onIsScrollingChange, onIsScrollingChange = _b === void 0 ? noop$1 : _b, _c = callbacks.onVelocityChange, onVelocityChange = _c === void 0 ? noop$1 : _c, _d = callbacks.onOffsetChange, onOffsetChange = _d === void 0 ? noop$1 : _d, _e2 = callbacks.onPageOffsetChange, onPageOffsetChange = _e2 === void 0 ? noop$1 : _e2, _f = callbacks.onClientOffsetChange, onClientOffsetChange = _f === void 0 ? noop$1 : _f, _g = callbacks.onScrollOffsetChange, onScrollOffsetChange = _g === void 0 ? noop$1 : _g, _h = callbacks.onInitialScrollOffsetChange, onInitialScrollOffsetChange = _h === void 0 ? noop$1 : _h;
  var drag = action.payload;
  var element = drag.element;
  var hint = drag.hint;
  var autoScrollDirection = state.autoScrollDirection;
  var overrideScrollableParent = state.scrollableParent;
  var event = normalizeEvent(action.event, state);
  switch (event.type) {
    case DRAG_AND_DROP_DISPATCH_ACTION.POINTER_DOWN:
      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.POINTER_DOWN && (!event.originalEvent.isPrimary || event.originalEvent.button !== 0)) {
        break;
      }
    case DRAG_AND_DROP_DISPATCH_ACTION.MOUSE_DOWN:
      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.MOUSE_DOWN && (event.originalEvent.which && event.originalEvent.which > 1) || state.ignoreMouse) {
        break;
      }
    case DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_START:
      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_START && event.originalEvent.touches.length !== 1) {
        break;
      }
    case DRAG_AND_DROP_DISPATCH_ACTION.START: {
      var scrollableParent_1 = overrideScrollableParent || getScrollableParent(action.payload.element);
      onInitialScrollOffsetChange(scrollableParent_1 instanceof Window ? { x: scrollableParent_1.scrollX, y: scrollableParent_1.scrollY } : { x: scrollableParent_1.scrollLeft, y: scrollableParent_1.scrollTop });
      onClientOffsetChange({
        x: event.clientX,
        y: event.clientY
      });
      onPageOffsetChange({
        x: event.pageX,
        y: event.pageY
      });
      onOffsetChange({
        x: event.offsetX,
        y: event.offsetY
      });
      onIsPressedChange(true);
      if (drag.onPress) {
        drag.onPress(event);
      }
      break;
    }
    case DRAG_AND_DROP_DISPATCH_ACTION.SCROLL:
      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.SCROLL && !state.pressed) {
        break;
      }
      var scrollableParent = overrideScrollableParent || getScrollableParent(element);
      var scrollOffset = scrollableParent instanceof Window ? { x: scrollableParent.scrollX, y: scrollableParent.scrollY } : { x: scrollableParent.scrollLeft, y: scrollableParent.scrollTop };
      event.scrollX = scrollOffset.x - state.initialScrollOffset.x;
      event.scrollY = scrollOffset.y - state.initialScrollOffset.y;
      onScrollOffsetChange({
        x: event.scrollX,
        y: event.scrollY
      });
    case DRAG_AND_DROP_DISPATCH_ACTION.POINTER_MOVE:
      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.POINTER_MOVE && !event.originalEvent.isPrimary) {
        break;
      }
    case DRAG_AND_DROP_DISPATCH_ACTION.MOUSE_MOVE:
    case DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_MOVE:
      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_MOVE && event.originalEvent.touches.length !== 1) {
        break;
      }
    case DRAG_AND_DROP_DISPATCH_ACTION.MOVE: {
      if (state.pressed) {
        if (state.autoScroll && event.originalEvent.type !== "scroll") {
          if (element) {
            var document_1 = getDocument$1(element);
            var scrollableParent_2 = overrideScrollableParent || getScrollableParent(document_1.elementFromPoint(event.clientX, event.clientY));
            var newVelocity = autoScrollVelocity(event.clientX, event.clientY, scrollableViewPort(scrollableParent_2, getWindow$2(element)));
            onVelocityChange({
              x: autoScrollDirection && autoScrollDirection.horizontal === false ? 0 : newVelocity.x,
              y: autoScrollDirection && autoScrollDirection.vertical === false ? 0 : newVelocity.y
            });
            onIsScrollingChange(newVelocity.y !== 0 || newVelocity.x !== 0);
          }
        }
        if (!state.drag && drag.onDragStart) {
          drag.onDragStart(event);
        }
        if (drag.onDrag) {
          drag.onDrag(event);
        }
        var dropElement_1 = intersect$1(hint || element, state.drops.map(function(drop2) {
          return drop2 && drop2.element;
        }).filter(function(d8) {
          return d8 !== (hint || element);
        }));
        var drop = state.drops.find(function(drop2) {
          return drop2.element === dropElement_1;
        });
        if (drop && dropElement_1 && isPointerInsideContainer(event.clientX, event.clientY, overrideScrollableParent || getScrollableParent(dropElement_1)) && dropElement_1 !== element) {
          if ((state.drop && state.drop.element) !== dropElement_1) {
            if (state.drop && state.drop.onDragLeave) {
              state.drop.onDragLeave(event);
            }
            if (drop.onDragEnter) {
              drop.onDragEnter(event);
            }
          } else {
            if (drop.onDragOver) {
              drop.onDragOver(event);
            }
          }
        } else if (state.drop && state.drop.onDragLeave) {
          state.drop.onDragLeave(event);
        }
      }
      onClientOffsetChange({
        x: event.clientX,
        y: event.clientY
      });
      onPageOffsetChange({
        x: event.pageX,
        y: event.pageY
      });
      break;
    }
    case DRAG_AND_DROP_DISPATCH_ACTION.POINTER_UP:
      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.POINTER_UP && !event.originalEvent.isPrimary) {
        break;
      }
    case DRAG_AND_DROP_DISPATCH_ACTION.MOUSE_UP:
    case DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_END:
      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_END && event.originalEvent.touches.length !== 1) {
        break;
      }
    case DRAG_AND_DROP_DISPATCH_ACTION.END: {
      onIsPressedChange(false);
      onIsScrollingChange(false);
      onScrollOffsetChange({ x: 0, y: 0 });
      if (drag.onRelease) {
        drag.onRelease(event);
      }
      if (state.drop && state.drop.onDrop) {
        state.drop.onDrop(event);
      }
      if (state.drag && drag.onDragEnd) {
        drag.onDragEnd(event);
      }
      break;
    }
    case DRAG_AND_DROP_DISPATCH_ACTION.POINTER_CANCEL:
    case DRAG_AND_DROP_DISPATCH_ACTION.CONTEXT_MENU:
    case DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_CANCEL:
    case DRAG_AND_DROP_DISPATCH_ACTION.CANCEL: {
      onIsPressedChange(false);
      onIsScrollingChange(false);
      onScrollOffsetChange({ x: 0, y: 0 });
      if (drag.onDragEnd) {
        drag.onDragEnd(event);
      }
      if (state.drop && state.drop.onDragLeave) {
        state.drop.onDragLeave(event);
      }
      break;
    }
  }
};
var autoScroll = function(scrollableParent, vel) {
  if (!scrollableParent) {
    return;
  }
  var yIsScrollable;
  var xIsScrollable;
  var isRootNode = scrollableParent === scrollableRoot(scrollableParent);
  if (isRootNode) {
    yIsScrollable = document.body.scrollHeight > window.innerHeight;
    xIsScrollable = document.body.scrollWidth > window.innerWidth;
  } else {
    yIsScrollable = scrollableParent.offsetHeight <= scrollableParent.scrollHeight;
    xIsScrollable = scrollableParent.offsetWidth <= scrollableParent.scrollWidth;
  }
  var yDelta = scrollableParent.scrollTop + vel.y;
  var yInBounds = yIsScrollable && yDelta > 0 && yDelta < scrollableParent.scrollHeight;
  var xDelta = scrollableParent.scrollLeft + vel.x;
  var xInBounds = xIsScrollable && xDelta > 0 && xDelta < scrollableParent.scrollWidth;
  if (yInBounds) {
    scrollableParent.scrollTop += vel.y;
  } else if (yIsScrollable && yDelta < 0) {
    scrollableParent.scrollTop = 0;
  }
  if (xInBounds) {
    scrollableParent.scrollLeft += vel.x;
  } else if (xIsScrollable && xDelta < 0) {
    scrollableParent.scrollLeft = 0;
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const d$q = (n10, o9) => {
  const [e3, l7] = reactExports.useContext(n10), [c6, u5] = reactExports.useState(o9);
  return [
    e3 !== void 0 ? e3 : c6,
    (...t6) => {
      e3 !== void 0 ? l7(...t6) : u5(t6[0]);
    }
  ];
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const je = 2e3;
function _e(l7, ge2, ve2 = {}) {
  const {
    onPress: B2 = n$x,
    onRelease: H3 = n$x,
    onDragStart: W3 = n$x,
    onDrag: _2 = n$x,
    onDragEnd: q2 = n$x
  } = ge2, {
    hint: a9 = null,
    mouseOnly: E2 = false,
    autoScroll: o9 = true,
    scrollContainer: u5 = null
  } = ve2, [f4, pe2] = reactExports.useState(false), [C2, be2] = reactExports.useState(false), [k3] = d$q(r$o), [y4, g6] = d$q(n$o), [z3] = reactExports.useContext(x$i), [F2, G2, N3] = reactExports.useContext(c$l), v3 = reactExports.useRef({ x: 0, y: 0 }), D2 = reactExports.useRef(), S2 = reactExports.useRef(false), $2 = reactExports.useRef(), m3 = reactExports.useRef(null), L3 = reactExports.useRef(false), J2 = reactExports.useRef({ x: 0, y: 0 }), K3 = reactExports.useRef({ x: 0, y: 0 }), p6 = reactExports.useRef({ x: 0, y: 0 }), Q2 = reactExports.useRef({ x: 0, y: 0 }), X2 = reactExports.useRef({ x: 0, y: 0 }), Y2 = reactExports.useRef({ x: 0, y: 0 }), Ee2 = !!(typeof window != "undefined" && window.PointerEvent), Z2 = !E2 && Ee2, c6 = reactExports.useCallback(
    () => l7.current && l7.current.element ? l7.current.element : l7.current,
    [l7]
  ), ke2 = reactExports.useCallback(
    () => a9 && a9.current && a9.current.element ? a9.current.element : a9 ? a9.current : null,
    [a9]
  ), ee2 = reactExports.useCallback(
    () => u5 && u5.current && u5.current.element ? u5.current.element : u5 ? u5.current : null,
    [u5]
  ), te2 = reactExports.useCallback(
    () => typeof o9 == "object" && o9.boundaryElementRef && o9.boundaryElementRef.current && o9.boundaryElementRef.current.element ? o9.boundaryElementRef.current.element : typeof o9 == "object" && o9.boundaryElementRef && o9.boundaryElementRef.current ? o9.boundaryElementRef.current : null,
    [o9]
  ), h3 = reactExports.useRef(null);
  reactExports.useImperativeHandle(h3, () => ({
    element: c6(),
    hint: ke2(),
    onPress: ye2,
    onDragStart: Se2,
    onDrag: Le2,
    onDragEnd: Oe2,
    onRelease: De2,
    data: l7.current
  }));
  const b2 = reactExports.useCallback(
    () => {
      const e3 = c6();
      return e3 && e3.ownerDocument || document;
    },
    [c6]
  ), d8 = reactExports.useCallback(
    () => {
      const e3 = b2();
      return e3 && e3.defaultView || window;
    },
    [b2]
  ), ne2 = reactExports.useCallback(
    () => ({
      drag: y4 ? y4.current : null,
      drop: k3 ? k3.current : null,
      drags: F2.map((e3) => e3.current),
      drops: z3.map((e3) => e3.current),
      pressed: f4,
      ignoreMouse: S2.current,
      scrollOffset: X2.current,
      offset: J2.current,
      pageOffset: K3.current,
      initialScrollOffset: Y2.current,
      clientOffset: p6.current,
      initialClientOffset: Q2.current,
      velocity: v3.current,
      autoScroll: !!(typeof o9 == "object" ? o9.enabled !== false : o9),
      scrollableParent: te2(),
      autoScrollDirection: typeof o9 == "object" ? o9.direction : { horizontal: true, vertical: true },
      isScrolling: C2
    }),
    [y4, k3, F2, z3, f4, o9, te2, C2]
  ), re2 = reactExports.useCallback(
    (e3) => {
      pe2(e3);
    },
    []
  ), oe2 = reactExports.useCallback(
    (e3) => {
      be2(e3);
    },
    []
  ), se2 = reactExports.useCallback(
    (e3) => {
      v3.current = e3;
    },
    []
  ), le2 = reactExports.useCallback(
    (e3) => {
      J2.current = e3;
    },
    []
  ), ce2 = reactExports.useCallback(
    (e3) => {
      p6.current = e3;
    },
    []
  ), ae2 = reactExports.useCallback(
    (e3) => {
      K3.current = e3;
    },
    []
  ), ue2 = reactExports.useCallback(
    (e3) => {
      Q2.current = e3;
    },
    []
  ), ie2 = reactExports.useCallback(
    (e3) => {
      X2.current = e3;
    },
    []
  ), fe2 = reactExports.useCallback(
    (e3) => {
      Y2.current = e3;
    },
    []
  ), ye2 = reactExports.useCallback(
    (e3) => {
      B2(e3);
    },
    [B2]
  ), De2 = reactExports.useCallback(
    (e3) => {
      H3(e3);
    },
    [H3]
  ), Se2 = reactExports.useCallback(
    (e3) => {
      g6(h3, { target: l7.current, event: e3 }), W3(e3);
    },
    [g6, l7, W3]
  ), Le2 = reactExports.useCallback(
    (e3) => {
      _2(e3);
    },
    [_2]
  ), Oe2 = reactExports.useCallback(
    (e3) => {
      L3.current || (g6(null, { target: l7.current, event: e3 }), q2(e3));
    },
    [q2, g6, l7]
  ), n10 = reactExports.useCallback(
    (e3) => {
      dispatchDragAndDrop(
        ne2(),
        { event: e3, payload: h3.current },
        {
          onVelocityChange: se2,
          onOffsetChange: le2,
          onClientOffsetChange: ce2,
          onPageOffsetChange: ae2,
          onInitialClientOffsetChange: ue2,
          onScrollOffsetChange: ie2,
          onInitialScrollOffsetChange: fe2,
          onIsPressedChange: re2,
          onIsScrollingChange: oe2
        }
      );
    },
    [
      ne2,
      se2,
      le2,
      ae2,
      ce2,
      ue2,
      fe2,
      re2,
      ie2,
      oe2
    ]
  ), O2 = reactExports.useCallback(
    (e3) => {
      n10(e3);
    },
    [n10]
  ), R2 = reactExports.useCallback(
    (e3) => {
      n10(e3);
    },
    [n10]
  ), w3 = reactExports.useCallback(
    (e3) => {
      n10(e3);
    },
    [n10]
  ), x3 = reactExports.useCallback(
    (e3) => {
      n10(e3);
    },
    [n10]
  ), P2 = reactExports.useCallback(
    (e3) => {
      n10(e3);
    },
    [n10]
  ), I3 = reactExports.useCallback(
    (e3) => {
      n10(e3);
    },
    [n10]
  ), M3 = reactExports.useCallback(
    (e3) => {
      n10(e3);
    },
    [n10]
  ), T3 = reactExports.useCallback(
    (e3) => {
      e3.preventDefault(), n10(e3);
    },
    [n10]
  ), A2 = reactExports.useCallback(
    (e3) => {
      e3.preventDefault(), n10(e3);
    },
    [n10]
  ), j2 = reactExports.useCallback(
    (e3) => {
      e3.preventDefault(), n10(e3);
    },
    [n10]
  ), U3 = reactExports.useCallback(
    (e3) => {
      if (e3.touches.length === 0 && e3.changedTouches.length === 1) {
        const r12 = d8();
        S2.current = true, $2.current = r12.setTimeout(() => {
          S2.current = false;
        }, je);
      }
      n10(e3);
    },
    [n10, d8]
  ), V3 = reactExports.useCallback(
    (e3) => {
      n10(e3);
    },
    [n10]
  ), de2 = reactExports.useCallback(
    () => {
      const e3 = c6();
      if (e3) {
        const r12 = e3.style.touchAction;
        return e3.style.touchAction = "none", () => {
          e3.style.touchAction = r12;
        };
      }
    },
    [c6]
  ), me2 = reactExports.useCallback(
    () => (G2(h3), () => {
      N3(h3);
    }),
    [N3, G2]
  ), Re2 = () => {
    const e3 = d8(), r12 = c6(), s10 = b2();
    return Z2 ? (r12 && (m3.current = getScrollableParent(r12), m3.current && m3.current.addEventListener("scroll", V3, { passive: true }), r12.addEventListener("pointerdown", O2, { passive: true })), f4 && (s10.addEventListener("pointermove", R2), s10.addEventListener("pointerup", x3, true), s10.addEventListener("contextmenu", T3), s10.addEventListener("pointercancel", w3, { passive: true }))) : (e3.addEventListener("touchmove", n$x, { capture: false, passive: false }), r12 && (r12.addEventListener("mousedown", P2, { passive: true }), E2 || (r12.addEventListener("touchstart", A2, { passive: true }), f4 && (r12.addEventListener("touchmove", j2, { passive: true }), r12.addEventListener("touchend", U3, { passive: true })))), f4 && (s10.addEventListener("mousemove", I3, { passive: true }), s10.addEventListener("mouseup", M3, { passive: true }))), () => {
      m3.current && m3.current.removeEventListener("scroll", V3), r12 && (r12.removeEventListener("pointerdown", O2), r12.removeEventListener("mousedown", P2), r12.removeEventListener("touchstart", A2), r12.removeEventListener("touchmove", j2), r12.removeEventListener("touchend", U3)), s10.removeEventListener("pointermove", R2), s10.removeEventListener("pointerup", x3, true), s10.removeEventListener("contextmenu", T3), s10.removeEventListener("pointercancel", w3), s10.removeEventListener("mousemove", I3), s10.removeEventListener("mouseup", M3), e3.removeEventListener("touchmove", n$x), e3.clearTimeout($2.current);
    };
  };
  reactExports.useEffect(() => {
    const e3 = d8();
    if (C2) {
      const r12 = ee2() || getScrollableParent(document.elementFromPoint(p6.current.x, p6.current.y));
      e3.clearInterval(D2.current), D2.current = e3.setInterval(() => {
        autoScroll(r12, { x: v3.current.x, y: v3.current.y });
      }, 50);
    }
    return () => {
      e3.clearInterval(D2.current);
    };
  }, [c6, ee2, d8, C2]), reactExports.useEffect(de2, [de2]), reactExports.useEffect(Re2, [
    f4,
    d8,
    c6,
    b2,
    E2,
    Z2,
    T3,
    P2,
    I3,
    M3,
    w3,
    O2,
    R2,
    x3,
    U3,
    j2,
    A2,
    V3
  ]), reactExports.useEffect(() => (L3.current = false, () => {
    L3.current = true;
  }), []), t$l(me2, [me2]);
}
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const m$i = reactExports.forwardRef((e3, c6) => {
  const l7 = reactExports.useRef(null), r12 = reactExports.useRef(null), t6 = reactExports.useCallback(
    () => l7.current && l7.current.element ? l7.current.element : l7.current,
    [l7]
  );
  reactExports.useImperativeHandle(r12, () => ({ element: t6() || null })), reactExports.useImperativeHandle(c6, () => r12.current), reactExports.useImperativeHandle(e3.childRef, () => l7.current);
  const u5 = reactExports.useCallback(
    (a9) => {
      e3.onPress && e3.onPress({
        element: t6(),
        target: r12.current,
        event: a9
      });
    },
    [t6, e3.onPress]
  ), g6 = reactExports.useCallback(
    (a9) => {
      e3.onRelease && e3.onRelease({
        element: t6(),
        target: r12.current,
        event: a9
      });
    },
    [t6, e3.onRelease]
  ), o9 = reactExports.useCallback(
    (a9) => {
      e3.onDragStart && e3.onDragStart({
        element: t6(),
        target: r12.current,
        event: a9
      });
    },
    [e3, t6]
  ), s10 = reactExports.useCallback(
    (a9) => {
      e3.onDrag && e3.onDrag({
        element: t6(),
        target: r12.current,
        event: a9
      });
    },
    [t6, e3.onDrag]
  ), d8 = reactExports.useCallback(
    (a9) => {
      e3.onDragEnd && e3.onDragEnd({
        element: t6(),
        target: r12.current,
        event: a9
      });
    },
    [t6, e3.onDragEnd]
  );
  return _e(l7, {
    onPress: u5,
    onRelease: g6,
    onDragStart: o9,
    onDrag: s10,
    onDragEnd: d8
  }, {
    mouseOnly: e3.mouseOnly,
    autoScroll: e3.autoScroll,
    hint: e3.hint,
    scrollContainer: e3.scrollContainer
  }), e3.children ? reactExports.cloneElement(reactExports.Children.only(e3.children), { ref: l7 }) : null;
});
m$i.displayName = "KendoReactDraggable";
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const e$v = {
  sizeMap: {
    small: "sm",
    medium: "md",
    large: "lg"
  },
  roundedMap: {
    small: "sm",
    medium: "md",
    large: "lg"
  },
  orientationMap: {
    vertical: "vstack",
    horizontal: "hstack"
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
function n$n(e3, l7) {
  return e3 === l7 || Number.isNaN(e3) && Number.isNaN(l7);
}
function a$t(e3, l7) {
  if (e3.length !== l7.length)
    return false;
  for (let t6 = 0; t6 < e3.length; t6++)
    if (!n$n(e3[t6], l7[t6]))
      return false;
  return true;
}
function s$n(e3, l7 = a$t) {
  let t6 = null;
  function u5(...r12) {
    if (t6 && t6.lastThis === this && l7(r12, t6.lastArgs))
      return t6.lastResult;
    const i16 = e3.apply(this, r12);
    return t6 = {
      lastResult: i16,
      lastArgs: r12,
      lastThis: this
    }, i16;
  }
  return u5.clear = function() {
    t6 = null;
  }, u5;
}
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let l$m = class l2 {
  constructor(t6) {
    this.rovingTabIndex = true, this.update = () => {
    }, this.setFocusClass = (s10) => {
      s10.target.classList.add(this.focusClass);
    }, this.disableTabindexForRest = (s10) => {
      this.elements.forEach((e3) => {
        e3 !== s10 && e3.setAttribute("tabindex", "-1");
      });
    }, this.focusNextIndex = (s10, e3, i16) => {
      const n10 = e3 === 1 ? this.next(s10, i16) : this.previous(s10, i16);
      return this.focusElement(n10, s10), n10;
    }, this.tabIndex = t6.tabIndex || 0, this.root = t6.root, this.selectors = t6.selectors, this.focusOptions = t6.focusOptions || { preventScroll: true }, this.rovingTabIndex = t6.rovingTabIndex !== void 0 ? t6.rovingTabIndex : true, this.mouseEvents = t6.mouseEvents || {}, this.keyboardEvents = t6.keyboardEvents || {}, this.focusClass = t6.focusClass, this.lastFocused = null;
  }
  /**
   * Returns the collection of DOM elements which the module will navigate in.
   */
  get elements() {
    return this.root.current ? Array.from(this.root.current.querySelectorAll(this.selectors.join(","))) : [];
  }
  /**
   * Returns the first navigation DOM element.
   */
  get first() {
    return this.root.current && this.root.current.querySelector(this.selectors.join(",")) || null;
  }
  /**
   * Returns the last navigation DOM element.
   */
  get last() {
    const t6 = this.elements;
    return t6[t6.length - 1] || null;
  }
  /**
   * Returns the focused DOM element from the navigation collection of DOM elements.
   */
  get current() {
    return this.elements.find((t6) => t6.matches(":focus")) || null;
  }
  /**
   * Returns the next DOM element from the navigation collection of DOM elements.
   */
  next(t6, s10) {
    const e3 = s10 ? this.customElements(s10) : this.elements;
    let i16 = e3.indexOf(t6) + 1;
    return i16 = i16 < 0 ? e3.length - 1 : i16, e3[i16 % e3.length];
  }
  /**
   * Returns the previous DOM element from the navigation collection of DOM elements.
   */
  previous(t6, s10) {
    const e3 = s10 ? this.customElements(s10) : this.elements;
    let i16 = e3.indexOf(t6) - 1;
    return i16 = i16 < 0 ? e3.length - 1 : i16, e3[i16 % e3.length];
  }
  /**
   * Focuses the next element from the navigation collection of DOM elements.
   */
  focusNext(t6, s10) {
    return this.focusNextIndex(t6, 1, s10);
  }
  /**
   * Focuses the previous element from the navigation collection of DOM elements.
   */
  focusPrevious(t6, s10) {
    return this.focusNextIndex(t6, -1, s10);
  }
  /**
   * The keyboard events handler.
   */
  triggerKeyboardEvent(t6, s10) {
    const e3 = this.target(t6.target), i16 = e3 && e3.closest(this.selectors.join(",")), n10 = t6.key === " " ? "Space" : t6.key, r12 = t6.nativeEvent.type;
    i16 && this.keyboardEvents[r12][n10] && this.keyboardEvents[r12][n10].call(void 0, i16, this, t6, s10);
  }
  /**
   * The mouse events handler.
   */
  triggerMouseEvent(t6) {
    const s10 = this.target(t6.target), e3 = s10 && s10.closest(this.selectors.join(",")), i16 = t6.nativeEvent.type;
    e3 && this.mouseEvents[i16].call(void 0, e3, this, t6);
  }
  /**
   * Focuses the passed element from the navigation collection of DOM elements.
   */
  focusElement(t6, s10) {
    t6 && (s10 && (this.rovingTabIndex && s10.setAttribute("tabindex", "-1"), this.focusClass && (this.removeFocusClass(s10), s10.removeEventListener("focus", this.setFocusClass))), this.rovingTabIndex && t6.setAttribute("tabindex", String(this.tabIndex)), this.focusClass && (t6.classList.add(this.focusClass), t6.addEventListener("focus", this.setFocusClass)), t6.focus(this.focusOptions), this.lastFocused = t6);
  }
  /**
   * Set the first element tabIndex to `1` and `-1` for the rest.
   */
  initializeRovingTab(t6) {
    const s10 = t6 ? this.elements[t6] : this.first;
    s10 && (this.focusClass && s10.addEventListener("focus", this.setFocusClass), s10.setAttribute("tabindex", String(this.tabIndex)), this.disableTabindexForRest(s10));
  }
  /**
   * Remove a focus listener.
   */
  removeFocusListener() {
    this.lastFocused && this.lastFocused.removeEventListener("focus", this.setFocusClass);
  }
  /**
   * Remove a focus class.
   */
  removeFocusClass(t6) {
    this.focusClass && t6.classList.remove(this.focusClass);
  }
  customElements(t6) {
    return this.root.current ? Array.from(this.root.current.querySelectorAll(t6.join(","))) : [];
  }
  target(t6) {
    var n10;
    const s10 = t6, e3 = s10 && s10.ownerDocument || null, i16 = e3 && ((n10 = e3 == null ? void 0 : e3.defaultView) == null ? void 0 : n10.Element) || Element;
    return t6 instanceof i16 ? t6 : null;
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const c$k = (t6) => {
  const e3 = t6.shadowRoot, n10 = t6.contentDocument;
  return e3 && e3.activeElement ? c$k(e3.activeElement) : n10 && n10.activeElement ? c$k(n10.activeElement) : t6;
}, o$k = (t6) => {
  if (!(!t6 || !t6.activeElement))
    return c$k(t6.activeElement);
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let g$h = class g {
  constructor(t6 = 0, s10, r12, h3) {
    this.total = t6, this.offsets = [], this.heights = [];
    let i16 = 0;
    for (let e3 = 0; e3 < t6; e3++) {
      this.offsets.push(i16);
      const f4 = h3 && h3[e3].expanded && h3[e3].rowType === "data" ? r12 : s10;
      i16 += f4, this.heights.push(f4);
    }
  }
  height(t6) {
    return this.heights[t6];
  }
  index(t6) {
    for (let s10 = 0; s10 < this.offsets.length; s10++) {
      if (t6 === this.offsets[s10])
        return s10;
      if (t6 < this.offsets[s10])
        return s10 - 1;
    }
    return this.total - 1;
  }
  offset(t6) {
    return this.offsets[t6];
  }
  totalHeight() {
    const t6 = this.offsets[this.offsets.length - 1], s10 = this.heights[this.heights.length - 1];
    return t6 + s10;
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const p$w = {
  child: {
    container: `${e$x.prefix}-${b$c[`${b$c.prefix}-${r$p.container}`]}`,
    relative: `${e$x.prefix}-${b$c[`${b$c.prefix}-${r$p.container}-${b$c.relative}`]}`
  },
  childContainer: {
    container: `${e$x.prefix}-${b$c[`${b$c.child}-${b$c.prefix}-${r$p.container}`]}`
  },
  appear: {
    "push-right": `${e$x.prefix}-${b$c.pushRight}-${b$c.appear}`,
    "push-left": `${e$x.prefix}-${b$c.pushLeft}-${b$c.appear}`,
    "push-down": `${e$x.prefix}-${b$c.pushDown}-${b$c.appear}`,
    "push-up": `${e$x.prefix}-${b$c.pushUp}-${b$c.appear}`,
    "expand-vertical": `${e$x.prefix}-${b$c.expandVertical}-${b$c.appear}`,
    "expand-horizontal": `${e$x.prefix}-${b$c.expandHorizontal}-${b$c.appear}`,
    fade: `${e$x.prefix}-${b$c.fade}-${b$c.appear}`,
    "zoom-in": `${e$x.prefix}-${b$c.zoomIn}-${b$c.appear}`,
    "zoom-out": `${e$x.prefix}-${b$c.zoomOut}-${b$c.appear}`,
    "slide-in": `${e$x.prefix}-${b$c.slideIn}-${b$c.appear}`,
    "slide-down": `${e$x.prefix}-${b$c.slideDown}-${b$c.appear}`,
    "slide-up": `${e$x.prefix}-${b$c.slideUp}-${b$c.appear}`,
    "slide-right": `${e$x.prefix}-${b$c.slideRight}-${b$c.appear}`,
    "slide-left": `${e$x.prefix}-${b$c.slideLeft}-${b$c.appear}`,
    "reveal-vertical": `${e$x.prefix}-${b$c.revealVertical}-${b$c.appear}`,
    "reveal-horizontal": `${e$x.prefix}-${b$c.revealHorizontal}-${b$c.appear}`
  },
  appearActive: {
    "push-right": `${e$x.prefix}-${b$c.pushRight}-${b$c.appear}-${b$c.active}`,
    "push-left": `${e$x.prefix}-${b$c.pushLeft}-${b$c.appear}-${b$c.active}`,
    "push-down": `${e$x.prefix}-${b$c.pushDown}-${b$c.appear}-${b$c.active}`,
    "push-up": `${e$x.prefix}-${b$c.pushUp}-${b$c.appear}-${b$c.active}`,
    "expand-vertical": `${e$x.prefix}-${b$c.expandVertical}-${b$c.appear}-${b$c.active}`,
    "expand-horizontal": `${e$x.prefix}-${b$c.expandHorizontal}-${b$c.appear}-${b$c.active}`,
    fade: `${e$x.prefix}-${b$c.fade}-${b$c.appear}-${b$c.active}`,
    "zoom-in": `${e$x.prefix}-${b$c.zoomIn}-${b$c.appear}-${b$c.active}`,
    "zoom-out": `${e$x.prefix}-${b$c.zoomOut}-${b$c.appear}-${b$c.active}`,
    "slide-in": `${e$x.prefix}-${b$c.slideIn}-${b$c.appear}-${b$c.active}`,
    "slide-down": `${e$x.prefix}-${b$c.slideDown}-${b$c.appear}-${b$c.active}`,
    "slide-up": `${e$x.prefix}-${b$c.slideUp}-${b$c.appear}-${b$c.active}`,
    "slide-right": `${e$x.prefix}-${b$c.slideRight}-${b$c.appear}-${b$c.active}`,
    "slide-left": `${e$x.prefix}-${b$c.slideLeft}-${b$c.appear}-${b$c.active}`,
    "reveal-vertical": `${e$x.prefix}-${b$c.revealVertical}-${b$c.appear}-${b$c.active}`,
    "reveal-horizontal": `${e$x.prefix}-${b$c.revealHorizontal}-${b$c.appear}-${b$c.active}`
  },
  enter: {
    "push-right": `${e$x.prefix}-${b$c.pushRight}-${b$c.enter}`,
    "push-left": `${e$x.prefix}-${b$c.pushLeft}-${b$c.enter}`,
    "push-down": `${e$x.prefix}-${b$c.pushDown}-${b$c.enter}`,
    "push-up": `${e$x.prefix}-${b$c.pushUp}-${b$c.enter}`,
    "expand-vertical": `${e$x.prefix}-${b$c.expandVertical}-${b$c.enter}`,
    "expand-horizontal": `${e$x.prefix}-${b$c.expandHorizontal}-${b$c.enter}`,
    fade: `${e$x.prefix}-${b$c.fade}-${b$c.enter}`,
    "zoom-in": `${e$x.prefix}-${b$c.zoomIn}-${b$c.enter}`,
    "zoom-out": `${e$x.prefix}-${b$c.zoomOut}-${b$c.enter}`,
    "slide-in": `${e$x.prefix}-${b$c.slideIn}-${b$c.enter}`,
    "slide-down": `${e$x.prefix}-${b$c.slideDown}-${b$c.enter}`,
    "slide-up": `${e$x.prefix}-${b$c.slideUp}-${b$c.enter}`,
    "slide-right": `${e$x.prefix}-${b$c.slideRight}-${b$c.enter}`,
    "slide-left": `${e$x.prefix}-${b$c.slideLeft}-${b$c.enter}`,
    "reveal-vertical": `${e$x.prefix}-${b$c.revealVertical}-${b$c.enter}`,
    "reveal-horizontal": `${e$x.prefix}-${b$c.revealHorizontal}-${b$c.enter}`
  },
  enterActive: {
    "push-right": `${e$x.prefix}-${b$c.pushRight}-${b$c.enter}-${b$c.active}`,
    "push-left": `${e$x.prefix}-${b$c.pushLeft}-${b$c.enter}-${b$c.active}`,
    "push-down": `${e$x.prefix}-${b$c.pushDown}-${b$c.enter}-${b$c.active}`,
    "push-up": `${e$x.prefix}-${b$c.pushUp}-${b$c.enter}-${b$c.active}`,
    "expand-vertical": `${e$x.prefix}-${b$c.expandVertical}-${b$c.enter}-${b$c.active}`,
    "expand-horizontal": `${e$x.prefix}-${b$c.expandHorizontal}-${b$c.enter}-${b$c.active}`,
    fade: `${e$x.prefix}-${b$c.fade}-${b$c.enter}-${b$c.active}`,
    "zoom-in": `${e$x.prefix}-${b$c.zoomIn}-${b$c.enter}-${b$c.active}`,
    "zoom-out": `${e$x.prefix}-${b$c.zoomOut}-${b$c.enter}-${b$c.active}`,
    "slide-in": `${e$x.prefix}-${b$c.slideIn}-${b$c.enter}-${b$c.active}`,
    "slide-down": `${e$x.prefix}-${b$c.slideDown}-${b$c.enter}-${b$c.active}`,
    "slide-up": `${e$x.prefix}-${b$c.slideUp}-${b$c.enter}-${b$c.active}`,
    "slide-right": `${e$x.prefix}-${b$c.slideRight}-${b$c.enter}-${b$c.active}`,
    "slide-left": `${e$x.prefix}-${b$c.slideLeft}-${b$c.enter}-${b$c.active}`,
    "reveal-vertical": `${e$x.prefix}-${b$c.revealVertical}-${b$c.enter}-${b$c.active}`,
    "reveal-horizontal": `${e$x.prefix}-${b$c.revealHorizontal}-${b$c.enter}-${b$c.active}`
  },
  exit: {
    "push-right": `${e$x.prefix}-${b$c.pushRight}-${b$c.exit}`,
    "push-left": `${e$x.prefix}-${b$c.pushLeft}-${b$c.exit}`,
    "push-down": `${e$x.prefix}-${b$c.pushDown}-${b$c.exit}`,
    "push-up": `${e$x.prefix}-${b$c.pushUp}-${b$c.exit}`,
    "expand-vertical": `${e$x.prefix}-${b$c.expandVertical}-${b$c.exit}`,
    "expand-horizontal": `${e$x.prefix}-${b$c.expandHorizontal}-${b$c.exit}`,
    fade: `${e$x.prefix}-${b$c.fade}-${b$c.exit}`,
    "zoom-in": `${e$x.prefix}-${b$c.zoomIn}-${b$c.exit}`,
    "zoom-out": `${e$x.prefix}-${b$c.zoomOut}-${b$c.exit}`,
    "slide-in": `${e$x.prefix}-${b$c.slideIn}-${b$c.exit}`,
    "slide-down": `${e$x.prefix}-${b$c.slideDown}-${b$c.exit}`,
    "slide-up": `${e$x.prefix}-${b$c.slideUp}-${b$c.exit}`,
    "slide-right": `${e$x.prefix}-${b$c.slideRight}-${b$c.exit}`,
    "slide-left": `${e$x.prefix}-${b$c.slideLeft}-${b$c.exit}`,
    "reveal-vertical": `${e$x.prefix}-${b$c.revealVertical}-${b$c.exit}`,
    "reveal-horizontal": `${e$x.prefix}-${b$c.revealHorizontal}-${b$c.exit}`
  },
  exitActive: {
    "push-right": `${e$x.prefix}-${b$c.pushRight}-${b$c.exit}-${b$c.active}`,
    "push-left": `${e$x.prefix}-${b$c.pushLeft}-${b$c.exit}-${b$c.active}`,
    "push-down": `${e$x.prefix}-${b$c.pushDown}-${b$c.exit}-${b$c.active}`,
    "push-up": `${e$x.prefix}-${b$c.pushUp}-${b$c.exit}-${b$c.active}`,
    "expand-vertical": `${e$x.prefix}-${b$c.expandVertical}-${b$c.exit}-${b$c.active}`,
    "expand-horizontal": `${e$x.prefix}-${b$c.expandHorizontal}-${b$c.exit}-${b$c.active}`,
    fade: `${e$x.prefix}-${b$c.fade}-${b$c.exit}-${b$c.active}`,
    "zoom-in": `${e$x.prefix}-${b$c.zoomIn}-${b$c.exit}-${b$c.active}`,
    "zoom-out": `${e$x.prefix}-${b$c.zoomOut}-${b$c.exit}-${b$c.active}`,
    "slide-in": `${e$x.prefix}-${b$c.slideIn}-${b$c.exit}-${b$c.active}`,
    "slide-down": `${e$x.prefix}-${b$c.slideDown}-${b$c.exit}-${b$c.active}`,
    "slide-up": `${e$x.prefix}-${b$c.slideUp}-${b$c.exit}-${b$c.active}`,
    "slide-right": `${e$x.prefix}-${b$c.slideRight}-${b$c.exit}-${b$c.active}`,
    "slide-left": `${e$x.prefix}-${b$c.slideLeft}-${b$c.exit}-${b$c.active}`,
    "reveal-vertical": `${e$x.prefix}-${b$c.revealVertical}-${b$c.exit}-${b$c.active}`,
    "reveal-horizontal": `${e$x.prefix}-${b$c.revealHorizontal}-${b$c.exit}-${b$c.active}`
  }
}, x$h = {
  child: (t6) => {
    const { c: r12 = p$w } = t6;
    return {
      [r12.child.container]: true,
      [r12.child.relative]: true
    };
  },
  childContainer: (t6) => {
    const { c: r12 = p$w } = t6;
    return {
      [r12.childContainer.container]: true
    };
  },
  appear: (t6) => {
    const { c: r12 = p$w, transitionName: $2 } = t6;
    return {
      [`${r12.appear[$2]}`]: r12.appear[$2],
      [`${$2}-${b$c.appear}`]: !r12.appear[$2]
    };
  },
  appearActive: (t6) => {
    const { c: r12 = p$w, transitionName: $2 } = t6;
    return {
      [`${r12.appearActive[$2]}`]: r12.appearActive[$2],
      [`${$2}-${b$c.appear}-${b$c.active}`]: !r12.appearActive[$2]
    };
  },
  enter: (t6) => {
    const { c: r12 = p$w, transitionName: $2 } = t6;
    return {
      [`${r12.enter[$2]}`]: r12.enter[$2],
      [`${$2}-${b$c.enter}`]: !r12.enter[$2]
    };
  },
  enterActive: (t6) => {
    const { c: r12 = p$w, transitionName: $2 } = t6;
    return {
      [`${r12.enterActive[$2]}`]: r12.enterActive[$2],
      [`${$2}-${b$c.enter}-${b$c.active}`]: !r12.enterActive[$2]
    };
  },
  exit: (t6) => {
    const { c: r12 = p$w, transitionName: $2 } = t6;
    return {
      [`${r12.exit[$2]}`]: r12.exit[$2],
      [`${$2}-${b$c.exit}`]: !r12.exit[$2]
    };
  },
  exitActive: (t6) => {
    const { c: r12 = p$w, transitionName: $2 } = t6;
    return {
      [`${r12.exitActive[$2]}`]: r12.exitActive[$2],
      [`${$2}-${b$c.exit}-${b$c.active}`]: !r12.exitActive[$2]
    };
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const s$m = (e3, t6) => (r12) => {
  const { c: n10 = e3 } = r12;
  return {
    [n10[t6] || ""]: true
  };
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const M$b = {
  wrapper: {
    main: L$c,
    size: {
      small: `${L$c}-${l$n.small}`,
      medium: `${L$c}-${l$n.medium}`,
      large: `${L$c}-${l$n.large}`
    },
    fillMode: {
      solid: `${L$c}-${s$o.solid}`,
      outline: `${L$c}-${s$o.outline}`,
      flat: `${L$c}-${s$o.flat}`,
      link: `${L$c}-${s$o.link}`,
      clear: `${L$c}-${s$o.clear}`
    },
    themeColor: {
      base: {
        fillMode: {
          solid: `${L$c}-${s$o.solid}-${c$n.base}`,
          outline: `${L$c}-${s$o.outline}-${c$n.base}`,
          flat: `${L$c}-${s$o.flat}-${c$n.base}`,
          link: `${L$c}-${s$o.link}-${c$n.base}`,
          clear: `${L$c}-${s$o.clear}-${c$n.base}`
        }
      },
      primary: {
        fillMode: {
          solid: `${L$c}-${s$o.solid}-${c$n.primary}`,
          outline: `${L$c}-${s$o.outline}-${c$n.primary}`,
          flat: `${L$c}-${s$o.flat}-${c$n.primary}`,
          link: `${L$c}-${s$o.link}-${c$n.primary}`,
          clear: `${L$c}-${s$o.clear}-${c$n.primary}`
        }
      },
      secondary: {
        fillMode: {
          solid: `${L$c}-${s$o.solid}-${c$n.secondary}`,
          outline: `${L$c}-${s$o.outline}-${c$n.secondary}`,
          flat: `${L$c}-${s$o.flat}-${c$n.secondary}`,
          link: `${L$c}-${s$o.link}-${c$n.secondary}`,
          clear: `${L$c}-${s$o.clear}-${c$n.secondary}`
        }
      },
      tertiary: {
        fillMode: {
          solid: `${L$c}-${s$o.solid}-${c$n.tertiary}`,
          outline: `${L$c}-${s$o.outline}-${c$n.tertiary}`,
          flat: `${L$c}-${s$o.flat}-${c$n.tertiary}`,
          link: `${L$c}-${s$o.link}-${c$n.tertiary}`,
          clear: `${L$c}-${s$o.clear}-${c$n.tertiary}`
        }
      },
      info: {
        fillMode: {
          solid: `${L$c}-${s$o.solid}-${c$n.info}`,
          outline: `${L$c}-${s$o.outline}-${c$n.info}`,
          flat: `${L$c}-${s$o.flat}-${c$n.info}`,
          link: `${L$c}-${s$o.link}-${c$n.info}`,
          clear: `${L$c}-${s$o.clear}-${c$n.info}`
        }
      },
      success: {
        fillMode: {
          solid: `${L$c}-${s$o.solid}-${c$n.success}`,
          outline: `${L$c}-${s$o.outline}-${c$n.success}`,
          flat: `${L$c}-${s$o.flat}-${c$n.success}`,
          link: `${L$c}-${s$o.link}-${c$n.success}`,
          clear: `${L$c}-${s$o.clear}-${c$n.success}`
        }
      },
      warning: {
        fillMode: {
          solid: `${L$c}-${s$o.solid}-${c$n.warning}`,
          outline: `${L$c}-${s$o.outline}-${c$n.warning}`,
          flat: `${L$c}-${s$o.flat}-${c$n.warning}`,
          link: `${L$c}-${s$o.link}-${c$n.warning}`,
          clear: `${L$c}-${s$o.clear}-${c$n.warning}`
        }
      },
      error: {
        fillMode: {
          solid: `${L$c}-${s$o.solid}-${c$n.error}`,
          outline: `${L$c}-${s$o.outline}-${c$n.error}`,
          flat: `${L$c}-${s$o.flat}-${c$n.error}`,
          link: `${L$c}-${s$o.link}-${c$n.error}`,
          clear: `${L$c}-${s$o.clear}-${c$n.error}`
        }
      },
      dark: {
        fillMode: {
          solid: `${L$c}-${s$o.solid}-${c$n.dark}`,
          outline: `${L$c}-${s$o.outline}-${c$n.dark}`,
          flat: `${L$c}-${s$o.flat}-${c$n.dark}`,
          link: `${L$c}-${s$o.link}-${c$n.dark}`,
          clear: `${L$c}-${s$o.clear}-${c$n.dark}`
        }
      },
      light: {
        fillMode: {
          solid: `${L$c}-${s$o.solid}-${c$n.light}`,
          outline: `${L$c}-${s$o.outline}-${c$n.light}`,
          flat: `${L$c}-${s$o.flat}-${c$n.light}`,
          link: `${L$c}-${s$o.link}-${c$n.light}`,
          clear: `${L$c}-${s$o.clear}-${c$n.light}`
        }
      },
      inverse: {
        fillMode: {
          solid: `${L$c}-${s$o.solid}-${c$n.inverse}`,
          outline: `${L$c}-${s$o.outline}-${c$n.inverse}`,
          flat: `${L$c}-${s$o.flat}-${c$n.inverse}`,
          link: `${L$c}-${s$o.link}-${c$n.inverse}`,
          clear: `${L$c}-${s$o.clear}-${c$n.inverse}`
        }
      }
    },
    rounded: {
      small: `${e$x.prefix}-${e$x.rounded}-${d$r.small}`,
      medium: `${e$x.prefix}-${e$x.rounded}-${d$r.medium}`,
      large: `${e$x.prefix}-${e$x.rounded}-${d$r.large}`
    },
    iconButton: `${e$x.prefix}-${a$u.icon}-${a$u.button}`,
    disabled: `${e$x.prefix}-${x$j.disabled}`,
    selected: `${e$x.prefix}-${x$j.selected}`,
    isRtl: `${e$x.prefix}-${e$x.rtl}`
  },
  text: `${L$c}-${a$u.text}`,
  icon: `${L$c}-${a$u.icon}`
}, G$9 = {
  wrapper: (n10) => {
    const { isRtl: r12, selected: s10, disabled: o9, size: t6, fillMode: g6, rounded: b2, themeColor: C2, iconButton: B2, c: v3 = M$b } = n10, a9 = v3.wrapper, p6 = a9.themeColor[C2], w3 = p6.fillMode[g6];
    return {
      [a9.main]: true,
      [a9.size[t6]]: a9.size[t6],
      [`${L$c}-${t6}`]: t6 && !a9.size[t6],
      [a9.fillMode[g6]]: a9.fillMode[g6],
      [w3]: w3,
      [a9.rounded[b2]]: a9.rounded[b2],
      [`${e$x.prefix}-${e$x.rounded}-${b2}`]: b2 && !a9.rounded[b2],
      [a9.iconButton]: B2,
      [p6.disabled]: o9 && p6 && p6.disabled,
      [p6.selected]: s10 && p6 && p6.selected,
      [a9.disabled]: o9,
      [a9.selected]: s10,
      [a9.isRtl]: r12
    };
  },
  text: (n10) => {
    const { c: r12 = M$b } = n10;
    return {
      [r12.text]: true
    };
  },
  icon: (n10) => {
    const { c: r12 = M$b } = n10;
    return {
      [r12.icon]: true
    };
  }
}, m$h = {
  wrapper: {
    main: `${I$d}-${a$u.button}`,
    focus: `${e$x.prefix}-${x$j.focus}`,
    disabled: `${e$x.prefix}-${x$j.disabled}`
  },
  ul: {
    group: `${I$d}-${r$p.group}`,
    size: {
      small: `${I$d}-${r$p.group}-${l$n.small}`,
      medium: `${I$d}-${r$p.group}-${l$n.medium}`,
      large: `${I$d}-${r$p.group}-${l$n.large}`
    }
  },
  li: {
    item: `${e$x.prefix}-${r$p.item}`,
    focus: `${e$x.prefix}-${x$j.focus}`
  },
  item: `${I$d}-${r$p.item}`,
  link: {
    main: `${e$x.prefix}-${a$u.link}`,
    link: `${I$d}-${a$u.link}`,
    selected: `${e$x.prefix}-${x$j.selected}`,
    disabled: `${e$x.prefix}-${x$j.disabled}`
  },
  popup: `${I$d}-${r$p.popup}`
}, F$4 = {
  wrapper: (n10) => {
    const { focused: r12, disabled: s10, c: o9 = m$h } = n10, t6 = o9.wrapper;
    return {
      [t6.main]: true,
      [t6.focus]: r12,
      [t6.disabled]: s10
    };
  },
  ul: (n10) => {
    const { size: r12, c: s10 = m$h } = n10, o9 = s10.ul;
    return {
      [o9.group]: true,
      [o9.size[r12]]: o9.size[r12],
      [`${I$d}-${r$p.group}-${r12}`]: r12 && !o9.size[r12]
    };
  },
  li: (n10) => {
    const { focused: r12, c: s10 = m$h } = n10, o9 = s10.li;
    return {
      [o9.item]: true,
      [o9.focus]: r12
    };
  },
  item: s$m(m$h, "item"),
  link: (n10) => {
    const { selected: r12, disabled: s10, c: o9 = m$h } = n10, t6 = o9.link;
    return {
      [t6.main]: true,
      [t6.link]: true,
      [t6.selected]: r12,
      [t6.disabled]: s10
    };
  },
  popup: s$m(m$h, "popup")
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const d$p = {
  clearButton: `${e$x.prefix}-${e$x.clear}-${e$x.value}`,
  groupStickyHeader: `${e$x.prefix}-${r$p.list}-${r$p.group}-${x$j.sticky}-${a$u.header}`,
  listHeaderText: `${e$x.prefix}-${r$p.list}-${a$u.header}-${a$u.text}`,
  ul: `${e$x.prefix}-${r$p.list}-${a$u.ul}`,
  li: {
    main: `${e$x.prefix}-${r$p.list}-${r$p.item}`,
    selected: `${e$x.prefix}-${x$j.selected}`,
    focused: `${e$x.prefix}-${x$j.focus}`,
    first: `${e$x.prefix}-${x$j.first}`,
    disabled: `${e$x.prefix}-${x$j.disabled}`
  },
  groupLi: {
    list: `${e$x.prefix}-${r$p.list}-${r$p.group}-${r$p.item}`,
    table: `${e$x.prefix}-${a$u.table}-${r$p.group}-${r$p.row}`
  },
  itemText: `${e$x.prefix}-${r$p.list}-${r$p.item}-${a$u.text}`,
  groupItemText: {
    list: `${e$x.prefix}-${r$p.list}-${r$p.item}-${a$u.text}`,
    table: `${e$x.prefix}-${a$u.table}-${a$u.th}`
  },
  itemGroupLabel: `${e$x.prefix}-${r$p.list}-${r$p.item}-${r$p.group}-${a$u.label}`,
  noData: `${e$x.prefix}-${e$x.nodata}`,
  heightContainer: `${e$x.prefix}-${m$k.height}-${r$p.container}`,
  optionLabel: {
    main: `${e$x.prefix}-${r$p.list}-${r$p.optionLabel}`,
    selected: `${e$x.prefix}-${x$j.selected}`
  },
  inputInner: `${$$a}-${i$s.inner}`,
  inputIcon: `${e$x.prefix}-${i$s.input}-${v$d.prefix}`,
  searchbox: `${e$x.prefix}-${t$j.searchbox}`,
  listFilter: `${e$x.prefix}-${r$p.list}-${e$x.filter}`
}, j$4 = {
  clearButton: s$m(d$p, "clearButton"),
  groupStickyHeader: s$m(d$p, "groupStickyHeader"),
  listHeaderText: s$m(d$p, "listHeaderText"),
  ul: s$m(d$p, "ul"),
  li: (n10) => {
    const { c: $2 = d$p, selected: t6, focused: l7, first: c6, disabled: x3 } = n10, m3 = $2.li;
    return {
      [m3.main]: true,
      [m3.selected]: t6,
      [m3.focused]: l7,
      [m3.first]: c6,
      [m3.disabled]: x3
    };
  },
  groupLi: (n10) => {
    const { c: $2 = d$p, isMultiColumn: t6 } = n10, l7 = $2.groupLi;
    return {
      [l7.table]: t6,
      [l7.list]: !t6
    };
  },
  itemText: s$m(d$p, "itemText"),
  groupItemText: (n10) => {
    const { c: $2 = d$p, isMultiColumn: t6 } = n10, l7 = $2.groupItemText;
    return {
      [l7.table]: t6,
      [l7.list]: !t6
    };
  },
  itemGroupLabel: s$m(d$p, "itemGroupLabel"),
  noData: s$m(d$p, "noData"),
  heightContainer: s$m(d$p, "heightContainer"),
  optionLabel: (n10) => {
    const { c: $2 = d$p, selected: t6 } = n10, l7 = $2.optionLabel;
    return {
      [l7.main]: true,
      [l7.selected]: t6
    };
  },
  inputInner: s$m(d$p, "inputInner"),
  inputIcon: s$m(d$p, "inputIcon"),
  searchbox: s$m(d$p, "searchbox"),
  listFilter: s$m(d$p, "listFilter")
}, v$b = {
  wrapper: {
    main: `${e$x.prefix}-${x$j.adaptive}-${t$j.actionsheet}`,
    fullscreen: `${e$x.prefix}-${t$j.actionsheet}-${x$j.fullscreen}`,
    bottom: `${e$x.prefix}-${t$j.actionsheet}-${x$j.bottom}`
  },
  header: `${e$x.prefix}-${a$u.text}-${n$q.center}`,
  titleBar: {
    main: `${e$x.prefix}-${t$j.actionsheet}-${r$p.titlebar}-${r$p.group}`,
    position: `${e$x.prefix}-${n$q.hbox}`
  },
  title: `${e$x.prefix}-${t$j.actionsheet}-${a$u.title}`,
  subtitle: {
    main: `${e$x.prefix}-${t$j.actionsheet}-${a$u.subtitle}`,
    textCenter: `${e$x.prefix}-${a$u.text}-${n$q.center}`
  },
  actions: `${e$x.prefix}-${t$j.actionsheet}-${r$p.actions}`,
  titleBarGroup: {
    main: `${e$x.prefix}-${t$j.actionsheet}-${r$p.titlebar}-${r$p.group}`,
    filter: `${e$x.prefix}-${t$j.actionsheet}-${e$x.filter}`
  }
}, E$c = {
  wrapper: (n10) => {
    const { c: $2 = v$b, isFullScreen: t6 } = n10, l7 = $2.wrapper;
    return {
      [l7.main]: true,
      [l7.fullscreen]: t6,
      [l7.bottom]: !t6
    };
  },
  header: s$m(v$b, "header"),
  titleBar: (n10) => {
    const { c: $2 = v$b } = n10, t6 = $2.titleBar;
    return {
      [t6.main]: true,
      [t6.position]: true
    };
  },
  title: s$m(v$b, "title"),
  subtitle: (n10) => {
    const { c: $2 = v$b } = n10, t6 = $2.subtitle;
    return {
      [t6.main]: true,
      [t6.textCenter]: true
    };
  },
  actions: s$m(v$b, "actions"),
  titleBarGroup: (n10) => {
    const { c: $2 = v$b } = n10, t6 = $2.titleBarGroup;
    return {
      [t6.main]: true,
      [t6.filter]: true
    };
  }
}, h$c = {
  wrapper: {
    main: D$5,
    picker: R$7,
    size: {
      small: `${R$7}-${l$n.small}`,
      medium: `${R$7}-${l$n.medium}`,
      large: `${R$7}-${l$n.large}`
    },
    fillMode: {
      solid: `${R$7}-${s$o.solid}`,
      outline: `${R$7}-${s$o.outline}`,
      flat: `${R$7}-${s$o.flat}`,
      link: `${R$7}-${s$o.link}`,
      clear: `${R$7}-${s$o.clear}`
    },
    rounded: {
      small: `${e$x.prefix}-${e$x.rounded}-${d$r.small}`,
      medium: `${e$x.prefix}-${e$x.rounded}-${d$r.medium}`,
      large: `${e$x.prefix}-${e$x.rounded}-${d$r.large}`
    },
    disabled: `${e$x.prefix}-${x$j.disabled}`,
    focused: `${e$x.prefix}-${x$j.focus}`,
    invalid: `${e$x.prefix}-${x$j.invalid}`,
    loading: `${e$x.prefix}-${x$j.loading}`,
    required: `${e$x.prefix}-${x$j.required}`
  },
  loadingIcon: `${$$a}-${x$j.loading}-${v$d.prefix}`,
  inputButton: `${$$a}-${a$u.button}`,
  listContainer: {
    main: `${e$x.prefix}-${r$p.list}-${r$p.container}`,
    popup: `${e$x.prefix}-${t$j.dropdownlist}-${r$p.popup}`
  },
  inputInner: `${$$a}-${i$s.inner}`,
  inputText: `${$$a}-${e$x.value}-${a$u.text}`,
  listHeader: `${e$x.prefix}-${r$p.list}-${a$u.header}`,
  list: {
    main: `${e$x.prefix}-${r$p.list}`,
    size: {
      small: `${e$x.prefix}-${r$p.list}-${l$n.small}`,
      medium: `${e$x.prefix}-${r$p.list}-${l$n.medium}`,
      large: `${e$x.prefix}-${r$p.list}-${l$n.large}`
    },
    virtual: `${e$x.prefix}-${e$x.virtual}-${r$p.list}`
  },
  listContent: `${e$x.prefix}-${r$p.list}-${r$p.content}`,
  listFooter: `${e$x.prefix}-${r$p.list}-${a$u.footer}`
}, J$6 = {
  wrapper: (n10) => {
    const {
      c: $2 = h$c,
      size: t6,
      rounded: l7,
      fillMode: c6,
      focused: x3,
      disabled: m3,
      invalid: C2,
      loading: I3,
      required: r12
    } = n10, a9 = $2.wrapper;
    return {
      [a9.main]: true,
      [a9.picker]: true,
      [a9.size[t6]]: a9.size[t6],
      [`${R$7}-${t6}`]: t6 && !a9.size[t6],
      [a9.fillMode[c6]]: a9.fillMode[c6],
      [a9.rounded[l7]]: a9.rounded[l7],
      [`${e$x.prefix}-${e$x.rounded}-${l7}`]: l7 && !a9.rounded[l7],
      [a9.focused]: x3,
      [a9.disabled]: m3,
      [a9.loading]: I3,
      [a9.invalid]: C2,
      [a9.required]: r12
    };
  },
  loadingIcon: s$m(h$c, "loadingIcon"),
  inputButton: s$m(h$c, "inputButton"),
  listContainer: (n10) => {
    const { c: $2 = h$c } = n10, t6 = $2.listContainer;
    return {
      [t6.main]: true,
      [t6.popup]: true
    };
  },
  inputInner: s$m(h$c, "inputInner"),
  inputText: s$m(h$c, "inputText"),
  listHeader: s$m(h$c, "listHeader"),
  list: (n10) => {
    const { c: $2 = h$c, size: t6, virtual: l7 } = n10, c6 = $2.list;
    return {
      [c6.main]: true,
      [c6.size[t6]]: c6.size[t6],
      [`${e$x.prefix}-${r$p.list}-${t6}`]: t6 && !c6.size[t6],
      [c6.virtual]: l7
    };
  },
  listContent: s$m(h$c, "listContent"),
  listFooter: s$m(h$c, "listFooter")
};
({
  wrapper: {
    main: H$4,
    input: $$a,
    size: {
      small: `${$$a}-${l$n.small}`,
      medium: `${$$a}-${l$n.medium}`,
      large: `${$$a}-${l$n.large}`
    },
    fillMode: {
      solid: `${$$a}-${s$o.solid}`,
      outline: `${$$a}-${s$o.outline}`,
      flat: `${$$a}-${s$o.flat}`,
      link: `${$$a}-${s$o.link}`,
      clear: `${$$a}-${s$o.clear}`
    },
    rounded: {
      small: `${e$x.prefix}-${e$x.rounded}-${d$r.small}`,
      medium: `${e$x.prefix}-${e$x.rounded}-${d$r.medium}`,
      large: `${e$x.prefix}-${e$x.rounded}-${d$r.large}`
    },
    disabled: `${e$x.prefix}-${x$j.disabled}`,
    invalid: `${e$x.prefix}-${x$j.invalid}`,
    loading: `${e$x.prefix}-${x$j.loading}`,
    required: `${e$x.prefix}-${x$j.required}`
  },
  loadingIcon: `${$$a}-${x$j.loading}-${v$d.prefix}`,
  inputButton: `${$$a}-${a$u.button}`,
  listContainer: {
    main: `${e$x.prefix}-${r$p.list}-${r$p.container}`,
    popup: `${e$x.prefix}-${t$j.combobox}-${r$p.popup}`
  },
  listHeader: `${e$x.prefix}-${a$u.table}-${a$u.header}`,
  list: {
    list: `${e$x.prefix}-${r$p.list}`,
    table: `${e$x.prefix}-${e$x.data}-${a$u.table}`,
    size: {
      prefix: `${e$x.prefix}-${r$p.list}-`,
      small: `${e$x.prefix}-${r$p.list}-${l$n.small}`,
      medium: `${e$x.prefix}-${r$p.list}-${l$n.medium}`,
      large: `${e$x.prefix}-${r$p.list}-${l$n.large}`
    },
    tableSize: {
      prefix: `${e$x.prefix}-${a$u.table}-`,
      small: `${e$x.prefix}-${a$u.table}-${l$n.small}`,
      medium: `${e$x.prefix}-${a$u.table}-${l$n.medium}`,
      large: `${e$x.prefix}-${a$u.table}-${l$n.large}`
    },
    virtual: `${e$x.prefix}-${e$x.virtual}-${r$p.list}`
  },
  listContent: {
    main: `${e$x.prefix}-${r$p.list}-${r$p.content}`,
    scroller: `${e$x.prefix}-${r$p.list}-${e$x.scroller}`
  },
  listFooter: `${e$x.prefix}-${r$p.list}-${a$u.footer}`
});
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
({
  footer: {
    main: `${e$x.prefix}-${g$i.time}-${a$u.footer}`,
    actions: `${e$x.prefix}-${r$p.actions}`,
    stretched: `${e$x.prefix}-${r$p.actions}-${x$j.stretched}`,
    horizontal: `${e$x.prefix}-${r$p.actions}-${p$x.horizontal}`
  },
  cancel: `${e$x.prefix}-${g$i.time}-${h$d.cancel}`,
  accept: `${e$x.prefix}-${g$i.time}-${h$d.accept}`,
  part: {
    main: `${e$x.prefix}-${g$i.time}-${r$p.part}`,
    disabled: `${e$x.prefix}-${x$j.disabled}`
  },
  header: `${e$x.prefix}-${g$i.time}-${a$u.header}`,
  now: `${e$x.prefix}-${g$i.time}-${g$i.now}`,
  listContainer: `${e$x.prefix}-${g$i.time}-${r$p.list}-${r$p.container}`,
  highlight: `${e$x.prefix}-${g$i.time}-${x$j.highlight}`,
  listWrapper: {
    main: `${e$x.prefix}-${g$i.time}-${r$p.list}-${r$p.wrapper}`,
    focused: `${e$x.prefix}-${x$j.focus}`
  },
  list: `${e$x.prefix}-${g$i.time}-${r$p.list}`,
  container: {
    main: `${e$x.prefix}-${g$i.time}-${r$p.container}`,
    scrollable: `${e$x.prefix}-${x$j.scrollable}`,
    content: `${e$x.prefix}-${r$p.content}`
  },
  containerSelector: `${e$x.prefix}-${g$i.time}-${r$p.container}`,
  separator: `${e$x.prefix}-${g$i.time}-${r$p.separator}`,
  ul: `${e$x.prefix}-${e$x.reset}`,
  li: `${e$x.prefix}-${r$p.item}`,
  title: `${e$x.prefix}-${a$u.title}`,
  scrollablePlaceholder: `${e$x.prefix}-${x$j.scrollable}-${r$p.placeholder}`
});
({
  wrapper: {
    main: `${e$x.prefix}-${t$j.timepicker}`,
    input: `${$$a}`,
    size: {
      small: `${$$a}-${l$n.small}`,
      medium: `${$$a}-${l$n.medium}`,
      large: `${$$a}-${l$n.large}`
    },
    fillMode: {
      solid: `${$$a}-${s$o.solid}`,
      outline: `${$$a}-${s$o.outline}`,
      flat: `${$$a}-${s$o.flat}`
    },
    rounded: {
      small: `${e$x.prefix}-${e$x.rounded}-${d$r.small}`,
      medium: `${e$x.prefix}-${e$x.rounded}-${d$r.medium}`,
      large: `${e$x.prefix}-${e$x.rounded}-${d$r.large}`
    },
    disabled: `${e$x.prefix}-${x$j.disabled}`,
    required: `${e$x.prefix}-${x$j.required}`,
    invalid: `${e$x.prefix}-${x$j.invalid}`
  },
  inputButton: `${$$a}-${a$u.button}`,
  popup: {
    main: `${e$x.prefix}-${t$j.timepicker}-${r$p.popup}`,
    container: `${e$x.prefix}-${r$p.list}-${r$p.container}`
  },
  timeSelector: {
    main: `${e$x.prefix}-${g$i.timeselector}`,
    size: {
      medium: `${e$x.prefix}-${g$i.timeselector}-${l$n.medium}`,
      large: `${e$x.prefix}-${g$i.timeselector}-${l$n.large}`
    },
    disabled: `${e$x.prefix}-${x$j.disabled}`,
    reset: `${e$x.prefix}-${e$x.reset}`
  }
});
const u$n = {
  wrapper: {
    main: `${z$8}`,
    infinite: `${z$8}-${e$x.infinite}`,
    disabled: `${e$x.prefix}-${x$j.disabled}`,
    weekNumber: `${e$x.prefix}-${g$i.week}-${g$i.number}`,
    size: {
      medium: `${z$8}-${l$n.medium}`,
      large: `${z$8}-${l$n.large}`
    }
  },
  view: {
    main: `${z$8}-${r$p.view}`,
    vertical: `${e$x.prefix}-${n$q.vstack}`,
    month: `${z$8}-${g$i.month}${r$p.view}`,
    year: `${z$8}-${g$i.year}${r$p.view}`,
    decade: `${z$8}-${g$i.decade}${r$p.view}`,
    century: `${z$8}-${g$i.century}${r$p.view}`
  },
  navigation: `${z$8}-${g$i.navigation}`,
  navigationHighlight: `${z$8}-${g$i.navigation}-${x$j.highlight}`,
  table: {
    main: `${z$8}-${a$u.table}`,
    weekdays: `${z$8}-${g$i.weekdays}`
  },
  thead: `${z$8}-${a$u.thead}`,
  tr: `${z$8}-${a$u.tr}`,
  th: `${z$8}-${a$u.th}`,
  caption: `${z$8}-${a$u.caption}`,
  tbody: `${z$8}-${a$u.tbody}`,
  ul: `${e$x.prefix}-${e$x.reset}`,
  li: "",
  td: {
    main: `${z$8}-${a$u.td}`,
    rangeStart: `${e$x.prefix}-${g$i.range}-${f$g.start}`,
    rangeEnd: `${e$x.prefix}-${g$i.range}-${f$g.end}`,
    rangeMid: `${e$x.prefix}-${g$i.range}-${f$g.mid}`,
    rangeSplitEnd: `${e$x.prefix}-${g$i.range}-${h$d.split}-${f$g.end}`,
    rangeSplitStart: `${e$x.prefix}-${g$i.range}-${h$d.split}-${f$g.start}`,
    active: `${e$x.prefix}-${x$j.active}`,
    focused: `${e$x.prefix}-${e$x.state}-${x$j.pending}-${x$j.focus}`,
    selected: `${e$x.prefix}-${x$j.selected}`,
    today: `${e$x.prefix}-${g$i.today}`,
    weekend: `${e$x.prefix}-${g$i.weekend}`,
    disabled: `${e$x.prefix}-${x$j.disabled}`,
    isOtherMonth: `${e$x.prefix}-${g$i.other}-${g$i.month}`,
    isEmpty: `${e$x.prefix}-${x$j.empty}`,
    isWeek: `${e$x.prefix}-${x$j.alt}`
  },
  title: `${z$8}-${a$u.title}`,
  header: {
    main: `${z$8}-${a$u.header}`,
    vertical: `${e$x.prefix}-${n$q.hstack}`
  },
  spacer: `${e$x.prefix}-${r$p.spacer}`,
  nav: `${z$8}-${r$p.nav}`,
  today: {
    main: `${z$8}-${r$p.nav}-${g$i.today}`,
    disabled: `${e$x.prefix}-${x$j.disabled}`
  },
  scrollable: {
    main: `${e$x.prefix}-${x$j.scrollable}`,
    content: `${e$x.prefix}-${r$p.content}`,
    horizontal: `${e$x.prefix}-${x$j.scrollable}-${p$x.horizontal}`
  },
  scrollableSelector: `${e$x.prefix}-${x$j.scrollable}`,
  scrollablePlaceholder: {
    main: `${e$x.prefix}-${x$j.scrollable}-${r$p.placeholder}`,
    horizontal: `${e$x.prefix}-${x$j.scrollable}-${p$x.horizontal}-${r$p.placeholder}`
  },
  link: `${e$x.prefix}-${a$u.link}`,
  navigationMarker: `${z$8}-${g$i.navigation}-${g$i.marker}`
}, j$3 = {
  wrapper: (t6) => {
    const { c: a9 = u$n, disabled: i16, weekNumber: r12, mobileMode: l7 } = t6, m3 = a9.wrapper;
    return {
      [m3.main]: true,
      [m3.infinite]: true,
      [m3.disabled]: i16,
      [m3.weekNumber]: r12,
      [m3.size.large]: l7,
      [m3.size.medium]: !l7
    };
  },
  view: (t6) => {
    const { c: a9 = u$n, month: i16, year: r12, decade: l7, century: m3 } = t6, g6 = a9.view;
    return {
      [g6.main]: true,
      [g6.vertical]: true,
      [g6.month]: i16,
      [g6.year]: r12,
      [g6.decade]: l7,
      [g6.century]: m3
    };
  },
  navigation: s$m(u$n, "navigation"),
  navigationHighlight: s$m(u$n, "navigationHighlight"),
  table: (t6) => {
    const { c: a9 = u$n, weekdays: i16 } = t6, r12 = a9.table;
    return {
      [r12.main]: true,
      [r12.weekdays]: i16
    };
  },
  thead: s$m(u$n, "thead"),
  tr: s$m(u$n, "tr"),
  th: s$m(u$n, "th"),
  tbody: s$m(u$n, "tbody"),
  title: s$m(u$n, "title"),
  header: (t6) => {
    const { c: a9 = u$n, vertical: i16 } = t6, r12 = a9.header;
    return {
      [r12.main]: true,
      [r12.vertical]: i16
    };
  },
  today: (t6) => {
    const { c: a9 = u$n, disabled: i16 } = t6, r12 = a9.today;
    return {
      [r12.main]: true,
      [r12.disabled]: i16
    };
  },
  spacer: s$m(u$n, "spacer"),
  nav: s$m(u$n, "nav"),
  caption: s$m(u$n, "caption"),
  ul: s$m(u$n, "ul"),
  li: s$m(u$n, "li"),
  td: (t6) => {
    const {
      c: a9 = u$n,
      rangeStart: i16,
      rangeEnd: r12,
      rangeMid: l7,
      rangeSplitEnd: m3,
      rangeSplitStart: g6,
      active: M3,
      focused: $2,
      selected: D2,
      today: F2,
      weekend: N3,
      disabled: T3,
      isOtherMonth: G2,
      isEmpty: C2,
      isWeek: E2
    } = t6, f4 = a9.td;
    return E2 ? {
      [f4.main]: true,
      [f4.isWeek]: E2
    } : C2 ? {
      [f4.main]: true,
      [f4.isEmpty]: C2
    } : {
      [f4.main]: true,
      [f4.rangeStart]: i16,
      [f4.rangeEnd]: r12,
      [f4.rangeMid]: l7,
      [f4.rangeSplitEnd]: m3,
      [f4.rangeSplitStart]: g6,
      [f4.active]: M3,
      [f4.focused]: $2,
      [f4.selected]: D2,
      [f4.today]: F2,
      [f4.weekend]: N3,
      [f4.disabled]: T3,
      [f4.isOtherMonth]: G2
    };
  },
  scrollable: (t6) => {
    const { c: a9 = u$n, horizontal: i16 } = t6, r12 = a9.scrollable;
    return {
      [r12.main]: true,
      [r12.content]: true,
      [r12.horizontal]: i16
    };
  },
  scrollableSelector: s$m(u$n, "scrollableSelector"),
  scrollablePlaceholder: (t6) => {
    const { c: a9 = u$n, horizontal: i16 } = t6, r12 = a9.scrollablePlaceholder;
    return {
      [r12.main]: true,
      [r12.horizontal]: i16
    };
  },
  link: s$m(u$n, "link"),
  navigationMarker: (t6) => {
    const { c: a9 = u$n, isRangeStart: i16 } = t6;
    return {
      [a9.navigationMarker]: i16
    };
  }
}, S$b = {
  wrapper: {
    main: `${e$x.prefix}-${t$j.dateinput}`,
    input: `${$$a}`,
    size: {
      small: `${$$a}-${l$n.small}`,
      medium: `${$$a}-${l$n.medium}`,
      large: `${$$a}-${l$n.large}`
    },
    fillMode: {
      solid: `${$$a}-${s$o.solid}`,
      outline: `${$$a}-${s$o.outline}`,
      flat: `${$$a}-${s$o.flat}`
    },
    rounded: {
      small: `${e$x.prefix}-${e$x.rounded}-${d$r.small}`,
      medium: `${e$x.prefix}-${e$x.rounded}-${d$r.medium}`,
      large: `${e$x.prefix}-${e$x.rounded}-${d$r.large}`
    },
    disabled: `${e$x.prefix}-${x$j.disabled}`,
    required: `${e$x.prefix}-${x$j.required}`,
    invalid: `${e$x.prefix}-${x$j.invalid}`
  },
  inputInner: `${$$a}-${i$s.inner}`,
  inputSpinner: {
    main: `${$$a}-${i$s.spinner}`,
    button: `${e$x.prefix}-${i$s.spin}-${a$u.button}`
  },
  spinnerIncrease: `${e$x.prefix}-${i$s.spinner}-${h$d.increase}`,
  spinnerDecrease: `${e$x.prefix}-${i$s.spinner}-${h$d.decrease}`,
  clearButton: `${e$x.prefix}-${e$x.clear}-${e$x.value}`
}, A$c = {
  wrapper: (t6) => {
    const { c: a9 = S$b, size: i16, fillMode: r12, rounded: l7, disabled: m3, required: g6, invalid: M3 } = t6, $2 = a9.wrapper;
    return {
      [$2.main]: true,
      [$2.input]: true,
      [$2.size[i16]]: $2.size[i16],
      [`${$$a}-${i16}`]: i16 && !$2.size[i16],
      [$2.fillMode[r12]]: $2.fillMode[r12],
      [$2.rounded[l7]]: $2.rounded[l7],
      [`${e$x.prefix}-${e$x.rounded}-${l7}`]: l7 && !$2.rounded[l7],
      [$2.disabled]: m3,
      [$2.invalid]: M3,
      [$2.required]: g6
    };
  },
  inputInner: s$m(S$b, "inputInner"),
  inputSpinner: (t6) => {
    const { c: a9 = S$b } = t6, i16 = a9.inputSpinner;
    return {
      [i16.main]: true,
      [i16.button]: true
    };
  },
  spinnerIncrease: s$m(S$b, "spinnerIncrease"),
  spinnerDecrease: s$m(S$b, "spinnerDecrease"),
  clearButton: s$m(S$b, "clearButton")
};
({
  wrapper: {
    main: `${e$x.prefix}-${t$j.datetimepicker}`,
    input: `${$$a}`,
    size: {
      small: `${$$a}-${l$n.small}`,
      medium: `${$$a}-${l$n.medium}`,
      large: `${$$a}-${l$n.large}`
    },
    fillMode: {
      solid: `${$$a}-${s$o.solid}`,
      outline: `${$$a}-${s$o.outline}`,
      flat: `${$$a}-${s$o.flat}`
    },
    rounded: {
      small: `${e$x.prefix}-${e$x.rounded}-${d$r.small}`,
      medium: `${e$x.prefix}-${e$x.rounded}-${d$r.medium}`,
      large: `${e$x.prefix}-${e$x.rounded}-${d$r.large}`
    },
    disabled: `${e$x.prefix}-${x$j.disabled}`,
    required: `${e$x.prefix}-${x$j.required}`,
    invalid: `${e$x.prefix}-${x$j.invalid}`
  },
  inputButton: `${$$a}-${a$u.button}`,
  popup: {
    main: `${e$x.prefix}-${t$j.datetime}-${r$p.container}`,
    reset: `${e$x.prefix}-${e$x.reset}`
  },
  wrap: {
    main: `${e$x.prefix}-${t$j.datetime}-${r$p.wrap}`,
    date: `${e$x.prefix}-${g$i.date}-${r$p.tab}`,
    time: `${e$x.prefix}-${g$i.time}-${r$p.tab}`,
    disabled: `${e$x.prefix}-${x$j.disabled}`
  },
  timeFooter: {
    main: `${e$x.prefix}-${t$j.datetime}-${a$u.footer}`,
    actions: `${e$x.prefix}-${r$p.actions}`,
    stretched: `${e$x.prefix}-${r$p.actions}-${x$j.stretched}`
  },
  buttonGroup: `${e$x.prefix}-${t$j.datetime}-${t$j.buttongroup}`,
  selector: `${e$x.prefix}-${t$j.datetime}-${g$i.selector}`,
  calendarWrap: `${e$x.prefix}-${t$j.datetime}-${z$8}-${r$p.wrap}`,
  timeWrap: `${e$x.prefix}-${t$j.datetime}-${g$i.time}-${r$p.wrap}`,
  timeSelector: {
    main: `${e$x.prefix}-${g$i.timeselector}`,
    size: {
      medium: `${e$x.prefix}-${g$i.timeselector}-${l$n.medium}`,
      large: `${e$x.prefix}-${g$i.timeselector}-${l$n.large}`
    },
    disabled: `${e$x.prefix}-${x$j.disabled}`,
    reset: `${e$x.prefix}-${e$x.reset}`
  }
});
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const s$l = `${e$x.prefix}-${i$s.input}`, m$g = `${e$x.prefix}-${i$s.radio}`, N$9 = `${e$x.prefix}-${i$s.textbox}`, h$b = `${e$x.prefix}-${i$s.input}-${i$s.prefix}`, p$v = `${e$x.prefix}-${i$s.input}-${i$s.suffix}`;
({
  input: {
    radio: m$g,
    size: {
      prefix: `${m$g}-`,
      small: `${m$g}-${l$n.small}`,
      medium: `${m$g}-${l$n.medium}`,
      large: `${m$g}-${l$n.large}`
    },
    invalid: `${e$x.prefix}-${x$j.invalid}`,
    checked: `${e$x.prefix}-${x$j.checked}`
  },
  wrap: `${m$g}-${r$p.wrap}`,
  label: `${m$g}-${a$u.label}`
});
const M$a = {
  wrapper: {
    main: N$9,
    input: s$l,
    size: {
      small: `${s$l}-${l$n.small}`,
      medium: `${s$l}-${l$n.medium}`,
      large: `${s$l}-${l$n.large}`
    },
    fillMode: {
      solid: `${s$l}-${s$o.solid}`,
      outline: `${s$l}-${s$o.outline}`,
      flat: `${s$l}-${s$o.flat}`
    },
    rounded: {
      small: `${e$x.prefix}-${e$x.rounded}-${d$r.small}`,
      medium: `${e$x.prefix}-${e$x.rounded}-${d$r.medium}`,
      large: `${e$x.prefix}-${e$x.rounded}-${d$r.large}`
    },
    disabled: `${e$x.prefix}-${x$j.disabled}`,
    focused: `${e$x.prefix}-${x$j.focus}`,
    required: `${e$x.prefix}-${x$j.required}`,
    invalid: `${e$x.prefix}-${x$j.invalid}`,
    isRtl: `${e$x.prefix}-${e$x.rtl}`
  },
  inputInner: `${s$l}-${i$s.inner}`,
  prefix: {
    main: h$b,
    orientation: {
      horizontal: `${h$b}-${p$x.horizontal}`,
      vertical: `${h$b}-${p$x.vertical}`
    }
  },
  suffix: {
    main: p$v,
    orientation: {
      horizontal: `${p$v}-${p$x.horizontal}`,
      vertical: `${p$v}-${p$x.vertical}`
    }
  }
}, E$b = {
  wrapper: (d8) => {
    const { disabled: t6, invalid: a9, focused: l7, required: o9, size: n10, fillMode: $2, rounded: r12, isRtl: q2, c: T3 = M$a } = d8, e3 = T3.wrapper;
    return {
      [e3 == null ? void 0 : e3.main]: true,
      [e3 == null ? void 0 : e3.input]: true,
      [e3 == null ? void 0 : e3.size[n10]]: e3 == null ? void 0 : e3.size[n10],
      [`${s$l}-${n10}`]: n10 && !(e3 != null && e3.size[n10]),
      [e3 == null ? void 0 : e3.fillMode[$2]]: e3 == null ? void 0 : e3.fillMode[$2],
      [e3 == null ? void 0 : e3.rounded[r12]]: e3 == null ? void 0 : e3.rounded[r12],
      [`${e$x.prefix}-${e$x.rounded}-${r12}`]: r12 && !(e3 != null && e3.rounded[r12]),
      [e3 == null ? void 0 : e3.disabled]: t6,
      [e3 == null ? void 0 : e3.focused]: l7,
      [e3 == null ? void 0 : e3.required]: o9,
      [e3 == null ? void 0 : e3.invalid]: a9,
      [e3 == null ? void 0 : e3.isRtl]: q2
    };
  },
  inputInner: s$m(M$a, "inputInner"),
  prefix: (d8) => {
    const { orientation: t6, c: a9 = M$a } = d8, l7 = a9.prefix;
    return {
      [l7.main]: true,
      [l7.orientation[t6]]: l7.orientation[t6]
    };
  },
  suffix: (d8) => {
    const { orientation: t6, c: a9 = M$a } = d8, l7 = a9.suffix;
    return {
      [l7 == null ? void 0 : l7.main]: true,
      [l7 == null ? void 0 : l7.orientation[t6]]: l7 == null ? void 0 : l7.orientation[t6]
    };
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const m$f = `${e$x.prefix}-${w$d.floatingLabel}`, f$f = {
  wrapper: {
    main: `${m$f}-${w$d.container}`,
    focused: `${e$x.prefix}-${x$j.focus}`,
    empty: `${e$x.prefix}-${x$j.empty}`,
    notEmpty: "",
    disabled: `${e$x.prefix}-${w$d.text}-${x$j.disabled}`,
    isRtl: `${e$x.prefix}-${e$x.rtl}`
  },
  label: {
    main: m$f,
    focused: "",
    empty: "",
    notEmpty: "",
    invalid: `${e$x.prefix}-${w$d.text}-${c$n.error}`,
    disabled: `${e$x.prefix}-${w$d.text}-${x$j.disabled}`
  }
}, g$g = {
  wrapper: ($2) => {
    const { focused: d8, empty: c6, notEmpty: s10, disabled: e3, isRtl: n10, c: l7 = f$f } = $2, t6 = l7.wrapper;
    return {
      [t6 == null ? void 0 : t6.main]: true,
      [t6 == null ? void 0 : t6.focused]: d8,
      [t6 == null ? void 0 : t6.empty]: c6,
      [t6 == null ? void 0 : t6.notEmpty]: s10,
      [t6 == null ? void 0 : t6.disabled]: e3,
      [t6 == null ? void 0 : t6.isRtl]: n10
    };
  },
  label: ($2) => {
    const { focused: d8, empty: c6, notEmpty: s10, invalid: e3, disabled: n10, c: l7 = f$f } = $2, t6 = l7.label;
    return {
      [t6 == null ? void 0 : t6.main]: true,
      [t6 == null ? void 0 : t6.focused]: d8,
      [t6 == null ? void 0 : t6.empty]: c6,
      [t6 == null ? void 0 : t6.notEmpty]: s10,
      [t6 == null ? void 0 : t6.invalid]: e3,
      [t6 == null ? void 0 : t6.disabled]: n10
    };
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const p$u = {
  animationContainer: `${e$x.prefix}-${b$c.prefix}-${r$p.container}`,
  animationContainerShown: `${e$x.prefix}-${b$c.prefix}-${r$p.container}-${x$j.shown}`,
  animationChild: `${e$x.prefix}-${b$c.child}-${b$c.prefix}-${r$p.container}`,
  popup: `${e$x.prefix}-${y$b.prefix}`,
  slide: {
    up: {
      enter: `${e$x.prefix}-${b$c.slide}-${f$g.up}-${b$c.enter}`,
      exit: `${e$x.prefix}-${b$c.slide}-${f$g.up}-${b$c.exit}`
    },
    down: {
      enter: `${e$x.prefix}-${b$c.slide}-${f$g.down}-${b$c.enter}`,
      exit: `${e$x.prefix}-${b$c.slide}-${f$g.down}-${b$c.exit}`
    },
    left: {
      enter: `${e$x.prefix}-${b$c.slide}-${f$g.left}-${b$c.enter}`,
      exit: `${e$x.prefix}-${b$c.slide}-${f$g.left}-${b$c.exit}`
    },
    right: {
      enter: `${e$x.prefix}-${b$c.slide}-${f$g.right}-${b$c.enter}`,
      exit: `${e$x.prefix}-${b$c.slide}-${f$g.right}-${b$c.exit}`
    }
  },
  slideActive: {
    up: {
      enter: `${e$x.prefix}-${b$c.slide}-${f$g.up}-${b$c.enter}-${b$c.active}`,
      exit: `${e$x.prefix}-${b$c.slide}-${f$g.up}-${b$c.exit}-${b$c.active}`
    },
    down: {
      enter: `${e$x.prefix}-${b$c.slide}-${f$g.down}-${b$c.enter}-${b$c.active}`,
      exit: `${e$x.prefix}-${b$c.slide}-${f$g.down}-${b$c.exit}-${b$c.active}`
    },
    left: {
      enter: `${e$x.prefix}-${b$c.slide}-${f$g.left}-${b$c.enter}-${b$c.active}`,
      exit: `${e$x.prefix}-${b$c.slide}-${f$g.left}-${b$c.exit}-${b$c.active}`
    },
    right: {
      enter: `${e$x.prefix}-${b$c.slide}-${f$g.right}-${b$c.enter}-${b$c.active}`,
      exit: `${e$x.prefix}-${b$c.slide}-${f$g.right}-${b$c.exit}-${b$c.active}`
    }
  }
}, l$l = {
  animationContainer: (n10) => {
    const { c: $2 = p$u } = n10;
    return {
      [$2.animationContainer]: true
    };
  },
  animationContainerShown: (n10) => {
    const { c: $2 = p$u } = n10;
    return {
      [$2.animationContainerShown]: true
    };
  },
  animationChild: (n10) => {
    const { c: $2 = p$u } = n10;
    return {
      [$2.animationChild]: true
    };
  },
  popup: (n10) => {
    const { c: $2 = p$u } = n10;
    return {
      [$2.popup]: true
    };
  },
  slide: (n10) => {
    const { direction: $2, type: o9, c: r12 = p$u } = n10;
    return {
      [r12.slide[$2][o9]]: r12.slide[$2] && r12.slide[$2][o9]
    };
  },
  slideActive: (n10) => {
    const { direction: $2, type: o9, c: r12 = p$u } = n10;
    return {
      [r12.slideActive[$2][o9]]: r12.slideActive[$2] && r12.slideActive[$2][o9]
    };
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const $$9 = {
  wrapper: {
    main: U$5,
    size: {
      small: `${U$5}-${l$n.small}`,
      medium: `${U$5}-${l$n.medium}`
    },
    virtual: `${U$5}-${e$x.virtual}`
  },
  ariaRoot: `${U$5}-${o$l.ariaRoot}`,
  container: `${U$5}-${r$p.container}`,
  content: {
    main: `${U$5}-${r$p.content}`,
    virtual: `${e$x.prefix}-${e$x.virtual}-${r$p.content}`
  },
  tableWrap: `${U$5}-${o$l.tableWrap}`,
  table: {
    main: `${e$x.prefix}-${a$u.table}`,
    gridTable: `${U$5}-${a$u.table}`,
    size: {
      small: `${e$x.prefix}-${a$u.table}-${l$n.small}`,
      medium: `${e$x.prefix}-${a$u.table}-${l$n.medium}`
    }
  },
  tbody: `${e$x.prefix}-${a$u.table}-${a$u.tbody}`,
  thead: {
    main: `${U$5}-${a$u.table}-${a$u.thead}`,
    draggable: `${U$5}-${x$j.draggable}-${a$u.header}`
  },
  header: {
    main: `${U$5}-${a$u.header}`,
    draggable: `${U$5}-${x$j.draggable}-${a$u.header}`
  },
  headerWrap: `${U$5}-${a$u.header}-${r$p.wrap}`,
  headerTable: {
    main: `${e$x.prefix}-${a$u.table}`,
    header: `${U$5}-${a$u.header}-${a$u.table}`,
    size: {
      small: `${e$x.prefix}-${a$u.table}-${l$n.small}`,
      medium: `${e$x.prefix}-${a$u.table}-${l$n.medium}`
    }
  },
  headerTh: {
    main: `${e$x.prefix}-${a$u.table}-${a$u.th}`,
    header: `${e$x.prefix}-${a$u.header}`,
    first: `${e$x.prefix}-${x$j.first}`,
    filterable: `${e$x.prefix}-${x$j.filterable}`,
    locked: `${U$5}-${a$u.header}-${x$j.sticky}`,
    sorted: `${e$x.prefix}-${x$j.sorted}`
  },
  tableThead: `${e$x.prefix}-${a$u.table}-${a$u.thead}`,
  heightContainer: `${e$x.prefix}-${m$k.height}-${r$p.container}`,
  sortIcon: `${e$x.prefix}-${x$j.sort}-${a$u.icon}`,
  sortOrder: `${e$x.prefix}-${x$j.sort}-${x$j.order}`,
  tr: {
    main: `${e$x.prefix}-${a$u.table}-${o$l.row}`,
    header: `${e$x.prefix}-${a$u.table}-${o$l.group}-${o$l.row}`,
    grouping: `${e$x.prefix}-${x$j.grouping}-${o$l.row}`,
    footer: `${e$x.prefix}-${o$l.group}-${a$u.footer}`,
    master: `${e$x.prefix}-${o$l.master}-${o$l.row}`,
    rowAlt: `${e$x.prefix}-${a$u.table}-${x$j.alt}-${o$l.row}`,
    alt: `${e$x.prefix}-${x$j.alt}`,
    selected: `${e$x.prefix}-${x$j.selected}`,
    isInEdit: `${U$5}-${x$j.edit}-${o$l.row}`
  },
  detailTr: {
    main: `${e$x.prefix}-${a$u.table}-${o$l.row}`,
    row: `${e$x.prefix}-${o$l.detail}-${o$l.row}`,
    rowAlt: `${e$x.prefix}-${a$u.table}-${x$j.alt}-${o$l.row}`,
    alt: `${e$x.prefix}-${x$j.alt}`
  },
  simpleTr: `${e$x.prefix}-${a$u.table}-${o$l.row}`,
  headerCellInner: `${e$x.prefix}-${o$l.cellInner}`,
  columnTitle: `${e$x.prefix}-${o$l.column}-${a$u.title}`,
  headerCellLink: {
    main: `${e$x.prefix}-${a$u.link}`,
    notSortable: `${e$x.important}${e$x.prefix}-${u$o.default}`
  },
  noRecords: `${U$5}-${o$l.noRecords}`,
  noRecordsTemplate: `${U$5}-${o$l.noRecords}-${x$j.template}`,
  pager: `${U$5}-${o$l.pager}`,
  sorted: `${e$x.prefix}-${x$j.sorted}`,
  contentSticky: `${U$5}-${r$p.content}-${x$j.sticky}`,
  hierarchyCell: {
    main: `${e$x.prefix}-${o$l.hierarchy}-${o$l.cell}`,
    header: `${e$x.prefix}-${a$u.header}`
  },
  td: {
    main: `${e$x.prefix}-${a$u.table}-${a$u.td}`,
    selected: `${e$x.prefix}-${x$j.selected}`
  },
  detailTd: {
    main: `${e$x.prefix}-${a$u.table}-${a$u.td}`,
    cell: `${e$x.prefix}-${o$l.detail}-${o$l.cell}`
  },
  editTd: {
    main: `${e$x.prefix}-${a$u.table}-${a$u.td}`,
    cell: `${U$5}-${x$j.edit}-${o$l.cell}`,
    selected: `${e$x.prefix}-${x$j.selected}`
  },
  hierarchyTd: {
    main: `${e$x.prefix}-${a$u.table}-${a$u.td}`,
    cell: `${e$x.prefix}-${o$l.hierarchy}-${o$l.cell}`
  }
}, g$f = {
  wrapper: (r12) => {
    const { size: e3, virtual: i16, c: c6 = $$9.wrapper } = r12;
    return {
      [c6.main]: true,
      [c6.size[e3]]: c6.size[e3],
      [`${U$5}-${e3}`]: e3 && !c6.size[e3],
      [c6.virtual]: i16
    };
  },
  ariaRoot: (r12) => {
    const { c: e3 = $$9 } = r12;
    return e3.ariaRoot;
  },
  container: (r12) => {
    const { c: e3 = $$9 } = r12;
    return e3.container;
  },
  content: (r12) => {
    const { c: e3 = $$9.content } = r12;
    return {
      [e3.main]: true,
      [e3.virtual]: true
    };
  },
  tableWrap: (r12) => {
    const { c: e3 = $$9 } = r12;
    return e3.tableWrap;
  },
  table: (r12) => {
    const { size: e3, c: i16 = $$9.table } = r12;
    return {
      [i16.main]: true,
      [i16.gridTable]: true,
      [i16.size[e3]]: i16.size[e3],
      [`${e$x.prefix}-${a$u}-${e3}`]: !i16.size[e3]
    };
  },
  tbody: (r12) => {
    const { c: e3 = $$9 } = r12;
    return e3.tbody;
  },
  thead: (r12) => {
    const { draggable: e3, c: i16 = $$9.thead } = r12;
    return {
      [i16.main]: true,
      [i16.draggable]: e3
    };
  },
  header: (r12) => {
    const { draggable: e3, c: i16 = $$9.header } = r12;
    return {
      [i16.main]: true,
      [i16.draggable]: e3
    };
  },
  headerWrap: (r12) => {
    const { c: e3 = $$9 } = r12;
    return e3.headerWrap;
  },
  headerTable: (r12) => {
    const { size: e3, c: i16 = $$9.headerTable } = r12;
    return {
      [i16.main]: true,
      [i16.header]: true,
      [i16.size[e3]]: i16.size[e3],
      [`${e$x.prefix}-${a$u.table}-${e3}`]: !i16.size[e3]
    };
  },
  headerTh: (r12) => {
    const { first: e3, filterable: i16, locked: c6, sorted: h3, c: s10 = $$9.headerTh } = r12;
    return {
      [s10.main]: true,
      [s10.header]: true,
      [s10.first]: e3,
      [s10.filterable]: i16,
      [s10.locked]: c6,
      [s10.sorted]: h3
    };
  },
  tableThead: (r12) => {
    const { c: e3 = $$9 } = r12;
    return e3.tableThead;
  },
  heightContainer: (r12) => {
    const { c: e3 = $$9 } = r12;
    return e3.heightContainer;
  },
  sortIcon: (r12) => {
    const { c: e3 = $$9 } = r12;
    return e3.sortIcon;
  },
  sortOrder: (r12) => {
    const { c: e3 = $$9 } = r12;
    return e3.sortOrder;
  },
  tr: (r12) => {
    const { isHeader: e3, isFooter: i16, isMaster: c6, isAltRow: h3, selected: s10, isInEdit: m3, c: d8 = $$9.tr } = r12;
    return {
      [d8.main]: true,
      [d8.header]: e3,
      [d8.grouping]: e3,
      [d8.footer]: i16,
      [d8.master]: c6,
      [d8.rowAlt]: c6 && h3,
      [d8.alt]: c6 && h3,
      [d8.selected]: s10,
      [d8.isInEdit]: m3
    };
  },
  detailTr: (r12) => {
    const { isAlt: e3, c: i16 = $$9.detailTr } = r12;
    return {
      [i16.main]: true,
      [i16.row]: true,
      [i16.rowAlt]: e3,
      [i16.alt]: e3
    };
  },
  simpleTr: (r12) => {
    const { c: e3 = $$9 } = r12;
    return e3.simpleTr;
  },
  headerCellInner: (r12) => {
    const { c: e3 = $$9 } = r12;
    return e3.headerCellInner;
  },
  columnTitle: (r12) => {
    const { c: e3 = $$9 } = r12;
    return e3.columnTitle;
  },
  headerCellLink: (r12) => {
    const { sortable: e3, c: i16 = $$9.headerCellLink } = r12;
    return {
      [i16.main]: true,
      [i16.notSortable]: !e3
    };
  },
  noRecords: (r12) => {
    const { c: e3 = $$9 } = r12;
    return e3.noRecords;
  },
  noRecordsTemplate: (r12) => {
    const { c: e3 = $$9 } = r12;
    return e3.noRecordsTemplate;
  },
  pager: (r12) => {
    const { c: e3 = $$9 } = r12;
    return e3.pager;
  },
  sorted: (r12) => {
    const { c: e3 = $$9 } = r12;
    return e3.sorted;
  },
  contentSticky: (r12) => {
    const { locked: e3, c: i16 = $$9 } = r12;
    return {
      [i16.contentSticky]: e3
    };
  },
  hierarchyCell: (r12) => {
    const { c: e3 = $$9.hierarchyCell } = r12;
    return {
      [e3.main]: true,
      [e3.header]: true
    };
  },
  td: (r12) => {
    const { selected: e3, c: i16 = $$9.td } = r12;
    return {
      [i16.main]: true,
      [i16.selected]: e3
    };
  },
  detailTd: (r12) => {
    const { c: e3 = $$9.detailTd } = r12;
    return {
      [e3.main]: true,
      [e3.cell]: true
    };
  },
  editTd: (r12) => {
    const { selected: e3, c: i16 = $$9.editTd } = r12;
    return {
      [i16.main]: true,
      [i16.cell]: true,
      [i16.selected]: e3
    };
  },
  hierarchyTd: (r12) => {
    const { c: e3 = $$9.hierarchyTd } = r12;
    return {
      [e3.main]: true,
      [e3.cell]: true
    };
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const e$u = {
  name: "@progress/kendo-react-intl",
  productName: "KendoReact",
  productCodes: ["KENDOUIREACT", "KENDOUICOMPLETE"],
  publishDate: 1728906363,
  version: "",
  licensingDocsUrl: "https://www.telerik.com/kendo-react-ui/components/my-license/"
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let c$j = class c {
  /**
   * Creates a new instance of the internationalization service.
   *
   * @param locale - The locale that will be used by the internationalization methods.
   */
  constructor(r12) {
    if (this.locale = r12, l$p(e$u), r12 === "" && false)
      throw "Locale should not be empty string";
  }
  /**
   * Formats a string with placeholders such as `Total amount {0:c}`.
   *
   * @param format - The format string.
   * @param values - One or more values to output in the format string placeholders.
   * @return - The formatted string.
   */
  format(r12, ...t6) {
    return t6.length === 1 && Array.isArray(t6[0]) ? format(r12, t6[0], this.locale) : format(r12, t6, this.locale);
  }
  /**
   * Converts a `Date` object to a string based on the specified format. If no format is provided, the default short date format is used.
   *
   * @param value - The date which will be formatted.
   * @param format - The format string or options.
   * @return - The formatted date.
   */
  formatDate(r12, t6) {
    return formatDate$1(r12, t6, this.locale);
  }
  /**
   * Converts an object to a string based on the specified format.
   *
   * @param value - The value which will be formatted.
   * @param format - The format to use.
   * @return - The formatted object.
   */
  toString(r12, t6) {
    return toString$1(r12, t6, this.locale);
  }
  /**
   * Converts a string to a `Number`.
   *
   * @param value - The string which will be parsed.
   * @param format - The format string or options.
   * @return - The parsed number.
   */
  parseNumber(r12, t6) {
    return parseNumber(r12, this.locale, t6);
  }
  /**
   * Converts a string to a `Date` object based on the specified format.
   *
   * @param value - The string which will be converted.
   * @param format - The format strings or options.
   * @return - The parsed date.
   */
  parseDate(r12, t6) {
    return parseDate$2(r12, t6, this.locale);
  }
  /**
   * Converts a `Number` to a string based on the specified format.
   *
   * @param value - The number which will be formatted.
   * @param format - The format string or options.
   * @return - The formatted number.
   */
  formatNumber(r12, t6) {
    return formatNumber(r12, t6, this.locale);
  }
  /**
   * Returns a localized date field name based on specific `dateFieldName` options.
   *
   * @param options - The detailed configuration for the desired date field name.
   * @returns - The localized date field name from the current locale based on the option.
   */
  dateFieldName(r12) {
    return dateFieldName(r12, this.locale);
  }
  /**
   * Returns the day names from the current locale based on the option.
   *
   * @param options - The detailed configuration for the desired date format.
   * @return - The day names from the current locale based on the option.
   */
  dateFormatNames(r12) {
    return dateFormatNames(this.locale, r12);
  }
  /**
   * Splits the date format into objects which contain information about each part of the pattern.
   *
   * @param format - The format string or options.
   * @returns - The date format parts.
   */
  splitDateFormat(r12) {
    return splitDateFormat(r12, this.locale);
  }
  /**
   * Returns the number symbols from the current locale.
   *
   * @return - The number symbols from the current locale.
   */
  numberSymbols() {
    return numberSymbols(this.locale);
  }
  /**
   * Returns the first day index, starting from Sunday.
   *
   * @return - The index of the first day of the week (0 == Sunday).
   */
  firstDay() {
    return firstDay$1(this.locale);
  }
  /**
   * @hidden
   */
  localeInfo() {
    return localeInfo(this.locale);
  }
  /**
   * @hidden
   */
  localeCurrency() {
    return localeCurrency(this.locale);
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const e$t = /* @__PURE__ */ Object.create({});
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let r$n = class r {
  constructor(e3) {
    if (this.language = e3, e3 === "" && false)
      throw "Language should not be an empty string";
  }
  /* eslint-disable max-len */
  /**
   * Provides a string based on a key for the current language. When no string for the current language is available under this key, the `defaultValue` is returned.
   *
   * @param key - The key which identifies the string for the current language.
   * @param defaultValue - The default value which will be returned when no string
   * for the current language is available under the key.
   * @return - The string for the current language.
   */
  // tslint:enable:max-line-length
  toLanguageString(e3, a9) {
    return this.language && e$t[this.language] && e$t[this.language].hasOwnProperty(e3) ? e$t[this.language][e3] : a9;
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const r$m = reactExports.createContext({
  intl: new c$j("en"),
  localization: new r$n()
});
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
function a$s(t6) {
  if (!t6 && false)
    throw `Passed component - ${t6} is invalid.`;
  const i16 = t6.context;
  return i16 && i16.intl ? i16.intl : new c$j("en");
}
function s$k(t6) {
  if (!t6 && false)
    throw `Passed component - ${t6} is invalid.`;
  const i16 = t6.context;
  return i16 && i16.localization ? i16.localization : new r$n();
}
function p$t(t6) {
  t6.contextType = r$m;
}
function v$a(t6) {
  t6.contextType = r$m;
}
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const e$s = () => reactExports.useContext(r$m).intl;
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const a$r = () => reactExports.useContext(r$m).localization;
var ARC = "arc";
var ARROW_UP = "ArrowUp";
var ARROW_DOWN = "ArrowDown";
var ARROW_LEFT = "ArrowLeft";
var ARROW_RIGHT = "ArrowRight";
var TAB = "Tab";
var ARIA_ACTIVE_DESCENDANT = "aria-activedescendant";
var AXIS_LABEL_CLICK = "axisLabelClick";
var BLACK$1 = "#000";
var BOTTOM = "bottom";
var CENTER = "center";
var CIRCLE = "circle";
var COORD_PRECISION = 3;
var CROSS = "cross";
var DATE = "date";
var DEFAULT_FONT$1 = "12px sans-serif";
var DEFAULT_HEIGHT$1 = 400;
var DEFAULT_PRECISION = 10;
var DEFAULT_WIDTH$1 = 600;
var END$1 = "end";
var ENTER = "Enter";
var ESCAPE = "Escape";
var FORMAT_REGEX = /\{\d+:?/;
var HEIGHT = "height";
var HIGHLIGHT_ZINDEX = 100;
var INSIDE$2 = "inside";
var INHERIT = "inherit";
var LEFT = "left";
var MAX_VALUE = Number.MAX_VALUE;
var MIN_VALUE = -Number.MAX_VALUE;
var NONE$1 = "none";
var NOTE_CLICK = "noteClick";
var NOTE_HOVER = "noteHover";
var NOTE_LEAVE = "noteLeave";
var OBJECT$1 = "object";
var OUTSIDE$1 = "outside";
var RIGHT = "right";
var ROUNDED_RECT = "roundedRect";
var START$1 = "start";
var STRING$1 = "string";
var TOP = "top";
var TRIANGLE = "triangle";
var SQUARE = "square";
var RECT = "rect";
var VALUE = "value";
var WHITE$1 = "#fff";
var WIDTH = "width";
var X$4 = "x";
var Y$7 = "y";
var DEFAULT_SERIES_OPACITY = 1;
var POINTER = "pointer";
var HORIZONTAL = "horizontal";
var VERTICAL = "vertical";
function isArray$1(value2) {
  return Array.isArray(value2);
}
function addClass2(element, classes) {
  var classArray = isArray$1(classes) ? classes : [classes];
  for (var idx = 0; idx < classArray.length; idx++) {
    var className = classArray[idx];
    if (element.className.indexOf(className) === -1) {
      element.className += " " + className;
    }
  }
}
var SPACE_REGEX = /\s+/g;
function removeClass2(element, className) {
  if (element && element.className) {
    element.className = element.className.replace(className, "").replace(SPACE_REGEX, " ");
  }
}
var Class = function Class2() {
};
const Class$1 = Class;
var Observable$1 = function(Class3) {
  function Observable2() {
    Class3.call(this);
    this._events = {};
  }
  if (Class3)
    Observable2.__proto__ = Class3;
  Observable2.prototype = Object.create(Class3 && Class3.prototype);
  Observable2.prototype.constructor = Observable2;
  Observable2.prototype.bind = function bind(eventName, handlers, one) {
    var arguments$1 = arguments;
    var this$1$1 = this;
    var eventNames = getArray(eventName);
    var handlersIsFunction = isFunction$2(handlers);
    var length = eventNames.length;
    if (handlers === void 0) {
      for (var field in eventName) {
        this$1$1.bind(field, eventName[field]);
      }
      return this;
    }
    var loop = function(idx2) {
      var eventName$1 = eventNames[idx2];
      var handler = handlersIsFunction ? handlers : handlers[eventName$1];
      if (handler) {
        if (one) {
          var original = handler;
          handler = function() {
            this$1$1.unbind(eventName$1, handler);
            original.apply(this$1$1, arguments$1);
          };
          handler.original = original;
        }
        var events2 = this$1$1._events[eventName$1] = this$1$1._events[eventName$1] || [];
        events2.push(handler);
      }
    };
    for (var idx = 0; idx < length; idx++)
      loop(idx);
    return this;
  };
  Observable2.prototype.one = function one(eventNames, handlers) {
    return this.bind(eventNames, handlers, true);
  };
  Observable2.prototype.first = function first(eventName, handlers) {
    var this$1$1 = this;
    var eventNames = getArray(eventName);
    var handlersIsFunction = isFunction$2(handlers);
    for (var idx = 0, length = eventNames.length; idx < length; idx++) {
      var eventName$1 = eventNames[idx];
      var handler = handlersIsFunction ? handlers : handlers[eventName$1];
      if (handler) {
        var events2 = this$1$1._events[eventName$1] = this$1$1._events[eventName$1] || [];
        events2.unshift(handler);
      }
    }
    return this;
  };
  Observable2.prototype.trigger = function trigger2(eventName, e3) {
    var this$1$1 = this;
    if (e3 === void 0)
      e3 = {};
    var events2 = this._events[eventName];
    if (events2) {
      var length = events2.length;
      e3.sender = this;
      e3._defaultPrevented = false;
      e3.preventDefault = preventDefault$3;
      e3.isDefaultPrevented = isDefaultPrevented$1;
      events2 = events2.slice();
      for (var idx = 0; idx < length; idx++) {
        events2[idx].call(this$1$1, e3);
      }
      return e3._defaultPrevented === true;
    }
    return false;
  };
  Observable2.prototype.unbind = function unbind(eventName, handler) {
    var events2 = this._events[eventName];
    if (eventName === void 0) {
      this._events = {};
    } else if (events2) {
      if (handler) {
        for (var idx = events2.length - 1; idx >= 0; idx--) {
          if (events2[idx] === handler || events2[idx].original === handler) {
            events2.splice(idx, 1);
          }
        }
      } else {
        this._events[eventName] = [];
      }
    }
    return this;
  };
  return Observable2;
}(Class$1);
function isFunction$2(value2) {
  return typeof value2 === "function";
}
function getArray(value2) {
  return typeof value2 === "string" ? [value2] : value2;
}
function preventDefault$3() {
  this._defaultPrevented = true;
}
function isDefaultPrevented$1() {
  return this._defaultPrevented === true;
}
const Observable$2 = Observable$1;
var animationFrameProxy = function(callback) {
  var wnd = typeof window !== "undefined" ? window : {};
  var animationFrame2 = wnd.requestAnimationFrame || wnd.webkitRequestAnimationFrame || wnd.mozRequestAnimationFrame || wnd.oRequestAnimationFrame || wnd.msRequestAnimationFrame || function(callback2) {
    setTimeout(callback2, 1e3 / 60);
  };
  animationFrameProxy = function(callback2) {
    return animationFrame2.call(wnd, callback2);
  };
  animationFrameProxy(callback);
};
const animationFrame$1 = animationFrameProxy;
var ampRegExp = /&/g;
var ltRegExp = /</g;
var quoteRegExp = /"/g;
var aposRegExp = /'/g;
var gtRegExp = />/g;
function htmlEncode(value2) {
  return String(value2).replace(ampRegExp, "&amp;").replace(ltRegExp, "&lt;").replace(gtRegExp, "&gt;").replace(quoteRegExp, "&quot;").replace(aposRegExp, "&#39;");
}
function logToConsole(message) {
  var console2 = window.console;
  if (typeof console2 != "undefined" && console2.log) {
    console2.log(message);
  }
}
function matchUserAgent(userAgent2) {
  var browserRxs = {
    edge: /(edge)[ \/]([\w.]+)/i,
    webkit: /(chrome)[ \/]([\w.]+)/i,
    safari: /(webkit)[ \/]([\w.]+)/i,
    opera: /(opera)(?:.*version|)[ \/]([\w.]+)/i,
    msie: /(msie\s|trident.*? rv:)([\w.]+)/i,
    mozilla: /(mozilla)(?:.*? rv:([\w.]+))/i
  };
  var browser2 = {};
  for (var agent in browserRxs) {
    if (browserRxs.hasOwnProperty(agent)) {
      var match2 = userAgent2.match(browserRxs[agent]);
      if (match2) {
        browser2[agent] = true;
        browser2[match2[1].toLowerCase().split(" ")[0].split("/")[0]] = true;
        browser2.version = parseInt(document.documentMode || match2[2], 10);
        break;
      }
    }
  }
  return browser2;
}
var browser$4 = null;
var support$1 = {
  get browser() {
    if (typeof window === "undefined" || browser$4) {
      return browser$4;
    }
    browser$4 = matchUserAgent(window.navigator.userAgent);
    return browser$4;
  }
};
const support$2 = support$1;
var now$1 = Date.now || function() {
  return (/* @__PURE__ */ new Date()).getTime();
};
const now$2 = now$1;
function throttle(fn, delay) {
  var lastExecTime = 0;
  var timeout;
  if (!delay || delay <= 0) {
    return fn;
  }
  var throttled = function() {
    var elapsed = now$2() - lastExecTime;
    var args = arguments;
    var exec = function() {
      fn.apply(null, args);
      lastExecTime = now$2();
    };
    if (!lastExecTime) {
      return exec();
    }
    if (timeout) {
      clearTimeout(timeout);
    }
    if (elapsed > delay) {
      exec();
    } else {
      timeout = setTimeout(exec, delay - elapsed);
    }
  };
  throttled.cancel = function() {
    clearTimeout(timeout);
  };
  return throttled;
}
var namedColors = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "00ffff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000000",
  blanchedalmond: "ffebcd",
  blue: "0000ff",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "00ffff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgrey: "a9a9a9",
  darkgreen: "006400",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "ff00ff",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  grey: "808080",
  green: "008000",
  greenyellow: "adff2f",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgrey: "d3d3d3",
  lightgreen: "90ee90",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "778899",
  lightslategrey: "778899",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "00ff00",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "ff00ff",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370d8",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "d87093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  red: "ff0000",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "ffffff",
  whitesmoke: "f5f5f5",
  yellow: "ffff00",
  yellowgreen: "9acd32"
};
const namedColors$1 = namedColors;
var browser$3 = support$2.browser;
var matchNamedColor = function(color) {
  var colorNames = Object.keys(namedColors$1);
  colorNames.push("transparent");
  var regexp = new RegExp("^(" + colorNames.join("|") + ")(\\W|$)", "i");
  matchNamedColor = function(color2) {
    return regexp.exec(color2);
  };
  return regexp.exec(color);
};
var BaseColor = function(Class3) {
  function BaseColor2() {
    Class3.call(this);
  }
  if (Class3)
    BaseColor2.__proto__ = Class3;
  BaseColor2.prototype = Object.create(Class3 && Class3.prototype);
  BaseColor2.prototype.constructor = BaseColor2;
  BaseColor2.prototype.toHSV = function toHSV() {
    return this;
  };
  BaseColor2.prototype.toRGB = function toRGB() {
    return this;
  };
  BaseColor2.prototype.toHex = function toHex(options2) {
    return this.toBytes().toHex(options2);
  };
  BaseColor2.prototype.toBytes = function toBytes() {
    return this;
  };
  BaseColor2.prototype.toCss = function toCss(options2) {
    return "#" + this.toHex(options2);
  };
  BaseColor2.prototype.toCssRgba = function toCssRgba() {
    var rgb = this.toBytes();
    return "rgba(" + rgb.r + ", " + rgb.g + ", " + rgb.b + ", " + parseFloat(Number(this.a).toFixed(3)) + ")";
  };
  BaseColor2.prototype.toDisplay = function toDisplay() {
    if (browser$3.msie && browser$3.version < 9) {
      return this.toCss();
    }
    return this.toCssRgba();
  };
  BaseColor2.prototype.equals = function equals(c6) {
    return c6 === this || c6 !== null && c6 !== void 0 && this.toCssRgba() === parseColor(c6).toCssRgba();
  };
  BaseColor2.prototype.diff = function diff(other) {
    if (other === null) {
      return NaN;
    }
    var c1 = this.toBytes();
    var c22 = other.toBytes();
    return Math.sqrt(Math.pow((c1.r - c22.r) * 0.3, 2) + Math.pow((c1.g - c22.g) * 0.59, 2) + Math.pow((c1.b - c22.b) * 0.11, 2));
  };
  BaseColor2.prototype.clone = function clone3() {
    var c6 = this.toBytes();
    if (c6 === this) {
      c6 = new Bytes(c6.r, c6.g, c6.b, c6.a);
    }
    return c6;
  };
  return BaseColor2;
}(Class$1);
var RGB = function(BaseColor2) {
  function RGB2(r12, g6, b2, a9) {
    BaseColor2.call(this);
    this.r = r12;
    this.g = g6;
    this.b = b2;
    this.a = a9;
  }
  if (BaseColor2)
    RGB2.__proto__ = BaseColor2;
  RGB2.prototype = Object.create(BaseColor2 && BaseColor2.prototype);
  RGB2.prototype.constructor = RGB2;
  RGB2.prototype.toHSV = function toHSV() {
    var ref2 = this;
    var r12 = ref2.r;
    var g6 = ref2.g;
    var b2 = ref2.b;
    var min2 = Math.min(r12, g6, b2);
    var max2 = Math.max(r12, g6, b2);
    var delta = max2 - min2;
    var v3 = max2;
    var h3, s10;
    if (delta === 0) {
      return new HSV(0, 0, v3, this.a);
    }
    if (max2 !== 0) {
      s10 = delta / max2;
      if (r12 === max2) {
        h3 = (g6 - b2) / delta;
      } else if (g6 === max2) {
        h3 = 2 + (b2 - r12) / delta;
      } else {
        h3 = 4 + (r12 - g6) / delta;
      }
      h3 *= 60;
      if (h3 < 0) {
        h3 += 360;
      }
    } else {
      s10 = 0;
      h3 = -1;
    }
    return new HSV(h3, s10, v3, this.a);
  };
  RGB2.prototype.toHSL = function toHSL() {
    var ref2 = this;
    var r12 = ref2.r;
    var g6 = ref2.g;
    var b2 = ref2.b;
    var max2 = Math.max(r12, g6, b2);
    var min2 = Math.min(r12, g6, b2);
    var h3, s10, l7 = (max2 + min2) / 2;
    if (max2 === min2) {
      h3 = s10 = 0;
    } else {
      var d8 = max2 - min2;
      s10 = l7 > 0.5 ? d8 / (2 - max2 - min2) : d8 / (max2 + min2);
      switch (max2) {
        case r12:
          h3 = (g6 - b2) / d8 + (g6 < b2 ? 6 : 0);
          break;
        case g6:
          h3 = (b2 - r12) / d8 + 2;
          break;
        case b2:
          h3 = (r12 - g6) / d8 + 4;
          break;
      }
    }
    return new HSL(h3 * 60, s10 * 100, l7 * 100, this.a);
  };
  RGB2.prototype.toBytes = function toBytes() {
    return new Bytes(this.r * 255, this.g * 255, this.b * 255, this.a);
  };
  return RGB2;
}(BaseColor);
var Bytes = function(RGB2) {
  function Bytes2(r12, g6, b2, a9) {
    RGB2.call(this, Math.round(r12), Math.round(g6), Math.round(b2), a9);
  }
  if (RGB2)
    Bytes2.__proto__ = RGB2;
  Bytes2.prototype = Object.create(RGB2 && RGB2.prototype);
  Bytes2.prototype.constructor = Bytes2;
  Bytes2.prototype.toRGB = function toRGB() {
    return new RGB2(this.r / 255, this.g / 255, this.b / 255, this.a);
  };
  Bytes2.prototype.toHSV = function toHSV() {
    return this.toRGB().toHSV();
  };
  Bytes2.prototype.toHSL = function toHSL() {
    return this.toRGB().toHSL();
  };
  Bytes2.prototype.toHex = function toHex(options2) {
    var value2 = hex(this.r, 2) + hex(this.g, 2) + hex(this.b, 2);
    if (options2 && options2.alpha) {
      value2 += hex(Math.round(this.a * 255), 2);
    }
    return value2;
  };
  Bytes2.prototype.toBytes = function toBytes() {
    return this;
  };
  return Bytes2;
}(RGB);
function hex(n10, width, pad2) {
  if (pad2 === void 0)
    pad2 = "0";
  var result = n10.toString(16);
  while (width > result.length) {
    result = pad2 + result;
  }
  return result;
}
var HSV = function(BaseColor2) {
  function HSV2(h3, s10, v3, a9) {
    BaseColor2.call(this);
    this.h = h3;
    this.s = s10;
    this.v = v3;
    this.a = a9;
  }
  if (BaseColor2)
    HSV2.__proto__ = BaseColor2;
  HSV2.prototype = Object.create(BaseColor2 && BaseColor2.prototype);
  HSV2.prototype.constructor = HSV2;
  HSV2.prototype.toRGB = function toRGB() {
    var ref2 = this;
    var h3 = ref2.h;
    var s10 = ref2.s;
    var v3 = ref2.v;
    var r12, g6, b2;
    if (s10 === 0) {
      r12 = g6 = b2 = v3;
    } else {
      h3 /= 60;
      var i16 = Math.floor(h3);
      var f4 = h3 - i16;
      var p6 = v3 * (1 - s10);
      var q2 = v3 * (1 - s10 * f4);
      var t6 = v3 * (1 - s10 * (1 - f4));
      switch (i16) {
        case 0:
          r12 = v3;
          g6 = t6;
          b2 = p6;
          break;
        case 1:
          r12 = q2;
          g6 = v3;
          b2 = p6;
          break;
        case 2:
          r12 = p6;
          g6 = v3;
          b2 = t6;
          break;
        case 3:
          r12 = p6;
          g6 = q2;
          b2 = v3;
          break;
        case 4:
          r12 = t6;
          g6 = p6;
          b2 = v3;
          break;
        default:
          r12 = v3;
          g6 = p6;
          b2 = q2;
          break;
      }
    }
    return new RGB(r12, g6, b2, this.a);
  };
  HSV2.prototype.toHSL = function toHSL() {
    return this.toRGB().toHSL();
  };
  HSV2.prototype.toBytes = function toBytes() {
    return this.toRGB().toBytes();
  };
  return HSV2;
}(BaseColor);
var HSL = function(BaseColor2) {
  function HSL2(h3, s10, l7, a9) {
    BaseColor2.call(this);
    this.h = h3;
    this.s = s10;
    this.l = l7;
    this.a = a9;
  }
  if (BaseColor2)
    HSL2.__proto__ = BaseColor2;
  HSL2.prototype = Object.create(BaseColor2 && BaseColor2.prototype);
  HSL2.prototype.constructor = HSL2;
  HSL2.prototype.toRGB = function toRGB() {
    var h3 = this.h / 360;
    var s10 = this.s / 100;
    var l7 = this.l / 100;
    var r12, g6, b2;
    if (s10 === 0) {
      r12 = g6 = b2 = l7;
    } else {
      var q2 = l7 < 0.5 ? l7 * (1 + s10) : l7 + s10 - l7 * s10;
      var p6 = 2 * l7 - q2;
      r12 = hue2rgb(p6, q2, h3 + 1 / 3);
      g6 = hue2rgb(p6, q2, h3);
      b2 = hue2rgb(p6, q2, h3 - 1 / 3);
    }
    return new RGB(r12, g6, b2, this.a);
  };
  HSL2.prototype.toHSV = function toHSV() {
    return this.toRGB().toHSV();
  };
  HSL2.prototype.toBytes = function toBytes() {
    return this.toRGB().toBytes();
  };
  return HSL2;
}(BaseColor);
function hue2rgb(p6, q2, s10) {
  var t6 = s10;
  if (t6 < 0) {
    t6 += 1;
  }
  if (t6 > 1) {
    t6 -= 1;
  }
  if (t6 < 1 / 6) {
    return p6 + (q2 - p6) * 6 * t6;
  }
  if (t6 < 1 / 2) {
    return q2;
  }
  if (t6 < 2 / 3) {
    return p6 + (q2 - p6) * (2 / 3 - t6) * 6;
  }
  return p6;
}
function alphaFromHex(a9) {
  return parseFloat(parseFloat(parseInt(a9, 16) / 255).toFixed(3));
}
function parseColor(value2, safe) {
  var m3, ret;
  if (!value2 || value2 === "none") {
    return null;
  }
  if (value2 instanceof BaseColor) {
    return value2;
  }
  var color = value2.toLowerCase();
  if (m3 = matchNamedColor(color)) {
    if (m3[1] === "transparent") {
      color = new RGB(1, 1, 1, 0);
    } else {
      color = parseColor(namedColors$1[m3[1]], safe);
    }
    color.match = [m3[1]];
    return color;
  }
  if (m3 = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})\b/i.exec(color)) {
    ret = new Bytes(
      parseInt(m3[1], 16),
      parseInt(m3[2], 16),
      parseInt(m3[3], 16),
      1
    );
  } else if (m3 = /^#?([0-9a-f])([0-9a-f])([0-9a-f])\b/i.exec(color)) {
    ret = new Bytes(
      parseInt(m3[1] + m3[1], 16),
      parseInt(m3[2] + m3[2], 16),
      parseInt(m3[3] + m3[3], 16),
      1
    );
  } else if (m3 = /^#?([0-9a-f])([0-9a-f])([0-9a-f])([0-9a-f])\b/i.exec(color)) {
    ret = new Bytes(
      parseInt(m3[1] + m3[1], 16),
      parseInt(m3[2] + m3[2], 16),
      parseInt(m3[3] + m3[3], 16),
      alphaFromHex(m3[4] + m3[4])
    );
  } else if (m3 = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})\b/i.exec(color)) {
    ret = new Bytes(
      parseInt(m3[1], 16),
      parseInt(m3[2], 16),
      parseInt(m3[3], 16),
      alphaFromHex(m3[4])
    );
  } else if (m3 = /^rgb\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)/.exec(color)) {
    ret = new Bytes(
      parseInt(m3[1], 10),
      parseInt(m3[2], 10),
      parseInt(m3[3], 10),
      1
    );
  } else if (m3 = /^rgba\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9.]+)\s*\)/.exec(color)) {
    ret = new Bytes(
      parseInt(m3[1], 10),
      parseInt(m3[2], 10),
      parseInt(m3[3], 10),
      parseFloat(m3[4])
    );
  } else if (m3 = /^rgb\(\s*([0-9]*\.?[0-9]+)%\s*,\s*([0-9]*\.?[0-9]+)%\s*,\s*([0-9]*\.?[0-9]+)%\s*\)/.exec(color)) {
    ret = new RGB(
      parseFloat(m3[1]) / 100,
      parseFloat(m3[2]) / 100,
      parseFloat(m3[3]) / 100,
      1
    );
  } else if (m3 = /^rgba\(\s*([0-9]*\.?[0-9]+)%\s*,\s*([0-9]*\.?[0-9]+)%\s*,\s*([0-9]*\.?[0-9]+)%\s*,\s*([0-9.]+)\s*\)/.exec(color)) {
    ret = new RGB(
      parseFloat(m3[1]) / 100,
      parseFloat(m3[2]) / 100,
      parseFloat(m3[3]) / 100,
      parseFloat(m3[4])
    );
  } else if (m3 = /^color\(\s*srgb\s*([0-9]*\.?[0-9]+)\s+([0-9]*\.?[0-9]+)\s+([0-9]*\.?[0-9]+)\s*(\/\s+([0-9]*\.?[0-9]+))?\)/.exec(color)) {
    ret = new RGB(
      parseFloat(m3[1]),
      parseFloat(m3[2]),
      parseFloat(m3[3]),
      parseFloat(m3[5] || "1")
    );
  }
  if (ret) {
    ret.match = m3;
  } else if (!safe) {
    throw new Error("Cannot parse color: " + color);
  }
  return ret;
}
var DARK_TRESHOLD = 180;
var Color = function(Class3) {
  function Color2(value2) {
    var this$1$1 = this;
    Class3.call(this);
    if (arguments.length === 1) {
      var formats = Color2.formats;
      var resolvedColor = this.resolveColor(value2);
      for (var idx = 0; idx < formats.length; idx++) {
        var formatRegex = formats[idx].re;
        var processor = formats[idx].process;
        var parts = formatRegex.exec(resolvedColor);
        if (parts) {
          var channels = processor(parts);
          this$1$1.r = channels[0];
          this$1$1.g = channels[1];
          this$1$1.b = channels[2];
        }
      }
    } else {
      this.r = arguments[0];
      this.g = arguments[1];
      this.b = arguments[2];
    }
    this.r = this.normalizeByte(this.r);
    this.g = this.normalizeByte(this.g);
    this.b = this.normalizeByte(this.b);
  }
  if (Class3)
    Color2.__proto__ = Class3;
  Color2.prototype = Object.create(Class3 && Class3.prototype);
  Color2.prototype.constructor = Color2;
  Color2.prototype.toHex = function toHex() {
    var pad2 = this.padDigit;
    var r12 = this.r.toString(16);
    var g6 = this.g.toString(16);
    var b2 = this.b.toString(16);
    return "#" + pad2(r12) + pad2(g6) + pad2(b2);
  };
  Color2.prototype.resolveColor = function resolveColor(value2) {
    var color = value2 || "black";
    if (color.charAt(0) === "#") {
      color = color.substr(1, 6);
    }
    color = color.replace(/ /g, "");
    color = color.toLowerCase();
    color = Color2.namedColors[color] || color;
    return color;
  };
  Color2.prototype.normalizeByte = function normalizeByte(value2) {
    if (value2 < 0 || isNaN(value2)) {
      return 0;
    }
    return value2 > 255 ? 255 : value2;
  };
  Color2.prototype.padDigit = function padDigit(value2) {
    return value2.length === 1 ? "0" + value2 : value2;
  };
  Color2.prototype.brightness = function brightness(value2) {
    var round2 = Math.round;
    this.r = round2(this.normalizeByte(this.r * value2));
    this.g = round2(this.normalizeByte(this.g * value2));
    this.b = round2(this.normalizeByte(this.b * value2));
    return this;
  };
  Color2.prototype.percBrightness = function percBrightness() {
    return Math.sqrt(0.241 * this.r * this.r + 0.691 * this.g * this.g + 0.068 * this.b * this.b);
  };
  Color2.prototype.isDark = function isDark() {
    return this.percBrightness() < DARK_TRESHOLD;
  };
  Color2.fromBytes = function fromBytes(r12, g6, b2, a9) {
    return new Bytes(r12, g6, b2, a9 != null ? a9 : 1);
  };
  Color2.fromRGB = function fromRGB(r12, g6, b2, a9) {
    return new RGB(r12, g6, b2, a9 != null ? a9 : 1);
  };
  Color2.fromHSV = function fromHSV(h3, s10, v3, a9) {
    return new HSV(h3, s10, v3, a9 != null ? a9 : 1);
  };
  Color2.fromHSL = function fromHSL(h3, s10, l7, a9) {
    return new HSL(h3, s10, l7, a9 != null ? a9 : 1);
  };
  return Color2;
}(Class$1);
Color.formats = [{
  re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
  process: function(parts) {
    return [
      parseInt(parts[1], 10),
      parseInt(parts[2], 10),
      parseInt(parts[3], 10)
    ];
  }
}, {
  re: /^(\w{2})(\w{2})(\w{2})$/,
  process: function(parts) {
    return [
      parseInt(parts[1], 16),
      parseInt(parts[2], 16),
      parseInt(parts[3], 16)
    ];
  }
}, {
  re: /^(\w{1})(\w{1})(\w{1})$/,
  process: function(parts) {
    return [
      parseInt(parts[1] + parts[1], 16),
      parseInt(parts[2] + parts[2], 16),
      parseInt(parts[3] + parts[3], 16)
    ];
  }
}];
Color.namedColors = namedColors$1;
const m$e = Color;
var HasObservers = function(Class3) {
  function HasObservers2() {
    Class3.apply(this, arguments);
  }
  if (Class3)
    HasObservers2.__proto__ = Class3;
  HasObservers2.prototype = Object.create(Class3 && Class3.prototype);
  HasObservers2.prototype.constructor = HasObservers2;
  HasObservers2.prototype.observers = function observers2() {
    this._observers = this._observers || [];
    return this._observers;
  };
  HasObservers2.prototype.addObserver = function addObserver(element) {
    if (!this._observers) {
      this._observers = [element];
    } else {
      this._observers.push(element);
    }
    return this;
  };
  HasObservers2.prototype.removeObserver = function removeObserver(element) {
    var observers2 = this.observers();
    var index2 = observers2.indexOf(element);
    if (index2 !== -1) {
      observers2.splice(index2, 1);
    }
    return this;
  };
  HasObservers2.prototype.trigger = function trigger2(methodName, event) {
    var observers2 = this._observers;
    if (observers2 && !this._suspended) {
      for (var idx = 0; idx < observers2.length; idx++) {
        var observer = observers2[idx];
        if (observer[methodName]) {
          observer[methodName](event);
        }
      }
    }
    return this;
  };
  HasObservers2.prototype.optionsChange = function optionsChange(e3) {
    if (e3 === void 0)
      e3 = {};
    e3.element = this;
    this.trigger("optionsChange", e3);
  };
  HasObservers2.prototype.geometryChange = function geometryChange() {
    this.trigger("geometryChange", {
      element: this
    });
  };
  HasObservers2.prototype.suspend = function suspend() {
    this._suspended = (this._suspended || 0) + 1;
    return this;
  };
  HasObservers2.prototype.resume = function resume() {
    this._suspended = Math.max((this._suspended || 0) - 1, 0);
    return this;
  };
  HasObservers2.prototype._observerField = function _observerField(field, value2) {
    if (this[field]) {
      this[field].removeObserver(this);
    }
    this[field] = value2;
    value2.addObserver(this);
  };
  return HasObservers2;
}(Class$1);
const HasObservers$1 = HasObservers;
function append$1(first, second) {
  first.push.apply(first, second);
  return first;
}
var literals = {
  1: "i",
  10: "x",
  100: "c",
  2: "ii",
  20: "xx",
  200: "cc",
  3: "iii",
  30: "xxx",
  300: "ccc",
  4: "iv",
  40: "xl",
  400: "cd",
  5: "v",
  50: "l",
  500: "d",
  6: "vi",
  60: "lx",
  600: "dc",
  7: "vii",
  70: "lxx",
  700: "dcc",
  8: "viii",
  80: "lxxx",
  800: "dccc",
  9: "ix",
  90: "xc",
  900: "cm",
  1e3: "m"
};
function arabicToRoman(n10) {
  var values6 = [
    1e3,
    900,
    800,
    700,
    600,
    500,
    400,
    300,
    200,
    100,
    90,
    80,
    70,
    60,
    50,
    40,
    30,
    20,
    10,
    9,
    8,
    7,
    6,
    5,
    4,
    3,
    2,
    1
  ];
  var roman = "";
  while (n10 > 0) {
    if (n10 < values6[0]) {
      values6.shift();
    } else {
      roman += literals[values6[0]];
      n10 -= values6[0];
    }
  }
  return roman;
}
function createPromise() {
  var resolveFn, rejectFn;
  var promise = new Promise(function(resolve, reject) {
    resolveFn = function(data2) {
      promise._state = "resolved";
      resolve(data2);
      return promise;
    };
    rejectFn = function(data2) {
      promise._state = "rejected";
      reject(data2);
      return promise;
    };
  });
  promise._state = "pending";
  promise.resolve = resolveFn;
  promise.reject = rejectFn;
  promise.state = function() {
    return promise._state;
  };
  return promise;
}
var UNDEFINED$1 = "undefined";
function defined$1(value2) {
  return typeof value2 !== UNDEFINED$1;
}
var defId = 1;
function definitionId() {
  return "kdef" + defId++;
}
var DEG_TO_RAD$1 = Math.PI / 180;
var MAX_NUM = Number.MAX_VALUE;
var MIN_NUM = -Number.MAX_VALUE;
function deg$1(radians) {
  return radians / DEG_TO_RAD$1;
}
var fromCharCode = String.fromCharCode;
function encodeUTF8(input) {
  var output = "";
  for (var i16 = 0; i16 < input.length; i16++) {
    var code = input.charCodeAt(i16);
    if (55296 <= code && code <= 56319) {
      var hi2 = code;
      var low = input.charCodeAt(++i16);
      if (!isNaN(low)) {
        code = (hi2 - 55296) * 1024 + (low - 56320) + 65536;
      }
    }
    if (code < 128) {
      output += fromCharCode(code);
    } else if (code < 2048) {
      output += fromCharCode(192 | code >>> 6);
      output += fromCharCode(128 | code & 63);
    } else if (code < 65536) {
      output += fromCharCode(224 | code >>> 12);
      output += fromCharCode(128 | code >>> 6 & 63);
      output += fromCharCode(128 | code & 63);
    } else if (code < 1114111) {
      output += fromCharCode(240 | code >>> 18);
      output += fromCharCode(128 | code >>> 12 & 63);
      output += fromCharCode(128 | code >>> 6 & 63);
      output += fromCharCode(128 | code & 63);
    }
  }
  return output;
}
var KEY_STR = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
function encodeBase64(input) {
  var output = "";
  var i16 = 0;
  var utfInput = encodeUTF8(input);
  while (i16 < utfInput.length) {
    var chr1 = utfInput.charCodeAt(i16++);
    var chr2 = utfInput.charCodeAt(i16++);
    var chr3 = utfInput.charCodeAt(i16++);
    var enc1 = chr1 >> 2;
    var enc2 = (chr1 & 3) << 4 | chr2 >> 4;
    var enc3 = (chr2 & 15) << 2 | chr3 >> 6;
    var enc4 = chr3 & 63;
    if (isNaN(chr2)) {
      enc3 = enc4 = 64;
    } else if (isNaN(chr3)) {
      enc4 = 64;
    }
    output = output + KEY_STR.charAt(enc1) + KEY_STR.charAt(enc2) + KEY_STR.charAt(enc3) + KEY_STR.charAt(enc4);
  }
  return output;
}
function eventCoordinates$1(e3) {
  if (defined$1((e3.x || {}).location)) {
    return {
      x: e3.x.location,
      y: e3.y.location
    };
  }
  return {
    x: e3.pageX || e3.clientX || 0,
    y: e3.pageY || e3.clientY || 0
  };
}
function eventElement$1(e3) {
  if (e3 === void 0)
    e3 = {};
  return e3.touch ? e3.touch.initialTouch : e3.target;
}
function isTransparent$1(color) {
  return color === "" || color === null || color === "none" || color === "transparent" || !defined$1(color);
}
function last$1(array) {
  if (array) {
    return array[array.length - 1];
  }
}
function limitValue$1(value2, min2, max2) {
  return Math.max(Math.min(value2, max2), min2);
}
function mergeSort(a9, cmp) {
  if (a9.length < 2) {
    return a9.slice();
  }
  function merge(a10, b2) {
    var r12 = [], ai2 = 0, bi2 = 0, i16 = 0;
    while (ai2 < a10.length && bi2 < b2.length) {
      if (cmp(a10[ai2], b2[bi2]) <= 0) {
        r12[i16++] = a10[ai2++];
      } else {
        r12[i16++] = b2[bi2++];
      }
    }
    if (ai2 < a10.length) {
      r12.push.apply(r12, a10.slice(ai2));
    }
    if (bi2 < b2.length) {
      r12.push.apply(r12, b2.slice(bi2));
    }
    return r12;
  }
  return function sort2(a10) {
    if (a10.length <= 1) {
      return a10;
    }
    var m3 = Math.floor(a10.length / 2);
    var left = a10.slice(0, m3);
    var right = a10.slice(m3);
    left = sort2(left);
    right = sort2(right);
    return merge(left, right);
  }(a9);
}
function promiseAll(promises) {
  return Promise.all(promises);
}
function rad$1(degrees) {
  return degrees * DEG_TO_RAD$1;
}
function pow$3(p6) {
  if (p6) {
    return Math.pow(10, p6);
  }
  return 1;
}
function round$2(value2, precision) {
  var power = pow$3(precision);
  return Math.round(value2 * power) / power;
}
function valueOrDefault$2(value2, defaultValue) {
  return defined$1(value2) ? value2 : defaultValue;
}
function bindEvents$1(element, events2) {
  for (var eventName in events2) {
    var eventNames = eventName.trim().split(" ");
    for (var idx = 0; idx < eventNames.length; idx++) {
      element.addEventListener(eventNames[idx], events2[eventName], false);
    }
  }
}
function elementOffset$1(element) {
  var box = element.getBoundingClientRect();
  var documentElement = document.documentElement;
  return {
    top: box.top + (window.pageYOffset || documentElement.scrollTop) - (documentElement.clientTop || 0),
    left: box.left + (window.pageXOffset || documentElement.scrollLeft) - (documentElement.clientLeft || 0)
  };
}
function elementStyles$1(element, styles) {
  var result = {};
  var style2 = window.getComputedStyle(element) || {};
  var stylesArray = Array.isArray(styles) ? styles : [styles];
  for (var idx = 0; idx < stylesArray.length; idx++) {
    var field = stylesArray[idx];
    result[field] = style2[field];
  }
  return result;
}
function getPixels(value2) {
  if (isNaN(value2)) {
    return value2;
  }
  return value2 + "px";
}
function elementSize$1(element, size) {
  if (size) {
    var width = size.width;
    var height = size.height;
    if (defined$1(width)) {
      element.style.width = getPixels(width);
    }
    if (defined$1(height)) {
      element.style.height = getPixels(height);
    }
  } else {
    var size$1 = elementStyles$1(element, ["width", "height"]);
    return {
      width: parseInt(size$1.width, 10),
      height: parseInt(size$1.height, 10)
    };
  }
}
function unbindEvents$1(element, events2) {
  if (events2 === void 0)
    events2 = {};
  for (var name2 in events2) {
    var eventNames = name2.trim().split(" ");
    for (var idx = 0; idx < eventNames.length; idx++) {
      element.removeEventListener(eventNames[idx], events2[name2], false);
    }
  }
}
function elementPadding(element) {
  var ref2 = elementStyles$1(element, ["paddingLeft", "paddingTop"]);
  var paddingLeft = ref2.paddingLeft;
  var paddingTop = ref2.paddingTop;
  return {
    top: parseFloat(paddingTop),
    left: parseFloat(paddingLeft)
  };
}
var Matrix$2 = function(Class3) {
  function Matrix3(a9, b2, c6, d8, e3, f4) {
    if (a9 === void 0)
      a9 = 0;
    if (b2 === void 0)
      b2 = 0;
    if (c6 === void 0)
      c6 = 0;
    if (d8 === void 0)
      d8 = 0;
    if (e3 === void 0)
      e3 = 0;
    if (f4 === void 0)
      f4 = 0;
    Class3.call(this);
    this.a = a9;
    this.b = b2;
    this.c = c6;
    this.d = d8;
    this.e = e3;
    this.f = f4;
  }
  if (Class3)
    Matrix3.__proto__ = Class3;
  Matrix3.prototype = Object.create(Class3 && Class3.prototype);
  Matrix3.prototype.constructor = Matrix3;
  Matrix3.prototype.multiplyCopy = function multiplyCopy(matrix) {
    return new Matrix3(
      this.a * matrix.a + this.c * matrix.b,
      this.b * matrix.a + this.d * matrix.b,
      this.a * matrix.c + this.c * matrix.d,
      this.b * matrix.c + this.d * matrix.d,
      this.a * matrix.e + this.c * matrix.f + this.e,
      this.b * matrix.e + this.d * matrix.f + this.f
    );
  };
  Matrix3.prototype.invert = function invert() {
    var ref2 = this;
    var a9 = ref2.a;
    var b2 = ref2.b;
    var d8 = ref2.c;
    var e3 = ref2.d;
    var g6 = ref2.e;
    var h3 = ref2.f;
    var det = a9 * e3 - b2 * d8;
    if (det === 0) {
      return null;
    }
    return new Matrix3(
      e3 / det,
      -b2 / det,
      -d8 / det,
      a9 / det,
      (d8 * h3 - e3 * g6) / det,
      (b2 * g6 - a9 * h3) / det
    );
  };
  Matrix3.prototype.clone = function clone3() {
    return new Matrix3(this.a, this.b, this.c, this.d, this.e, this.f);
  };
  Matrix3.prototype.equals = function equals(other) {
    if (!other) {
      return false;
    }
    return this.a === other.a && this.b === other.b && this.c === other.c && this.d === other.d && this.e === other.e && this.f === other.f;
  };
  Matrix3.prototype.round = function round$12(precision) {
    this.a = round$2(this.a, precision);
    this.b = round$2(this.b, precision);
    this.c = round$2(this.c, precision);
    this.d = round$2(this.d, precision);
    this.e = round$2(this.e, precision);
    this.f = round$2(this.f, precision);
    return this;
  };
  Matrix3.prototype.toArray = function toArray2(precision) {
    var result = [this.a, this.b, this.c, this.d, this.e, this.f];
    if (defined$1(precision)) {
      for (var i16 = 0; i16 < result.length; i16++) {
        result[i16] = round$2(result[i16], precision);
      }
    }
    return result;
  };
  Matrix3.prototype.toString = function toString2(precision, separator) {
    if (separator === void 0)
      separator = ",";
    return this.toArray(precision).join(separator);
  };
  Matrix3.translate = function translate2(x3, y4) {
    return new Matrix3(1, 0, 0, 1, x3, y4);
  };
  Matrix3.unit = function unit2() {
    return new Matrix3(1, 0, 0, 1, 0, 0);
  };
  Matrix3.rotate = function rotate(angle, x3, y4) {
    var matrix = new Matrix3();
    matrix.a = Math.cos(rad$1(angle));
    matrix.b = Math.sin(rad$1(angle));
    matrix.c = -matrix.b;
    matrix.d = matrix.a;
    matrix.e = x3 - x3 * matrix.a + y4 * matrix.b || 0;
    matrix.f = y4 - y4 * matrix.a - x3 * matrix.b || 0;
    return matrix;
  };
  Matrix3.scale = function scale(scaleX, scaleY) {
    return new Matrix3(scaleX, 0, 0, scaleY, 0, 0);
  };
  return Matrix3;
}(Class$1);
Matrix$2.IDENTITY = Matrix$2.unit();
const Matrix$3 = Matrix$2;
var matrixRegexp$1 = /matrix\((.*)\)/;
function parseMatrix$1(matrixString) {
  var match2 = matrixString.match(matrixRegexp$1);
  if (match2 === null || match2.length !== 2) {
    return Matrix$3.unit();
  }
  var members = match2[1].split(",").map(function(x3) {
    return parseFloat(x3);
  });
  return new (Function.prototype.bind.apply(Matrix$3, [null].concat(members)))();
}
function transformMatrix$1(element) {
  var transform2 = getComputedStyle(element).transform;
  if (transform2 === "none") {
    return Matrix$3.unit();
  }
  return parseMatrix$1(transform2);
}
function elementScale$1(element) {
  if (!element) {
    return Matrix$3.unit();
  }
  var matrix = transformMatrix$1(element);
  var parent = element.parentElement;
  while (parent) {
    var parentMatrix = transformMatrix$1(parent);
    matrix = matrix.multiplyCopy(parentMatrix);
    parent = parent.parentElement;
  }
  matrix.b = matrix.c = matrix.e = matrix.f = 0;
  return matrix;
}
var LRUCache = function(Class3) {
  function LRUCache2(size) {
    Class3.call(this);
    this._size = size;
    this._length = 0;
    this._map = {};
  }
  if (Class3)
    LRUCache2.__proto__ = Class3;
  LRUCache2.prototype = Object.create(Class3 && Class3.prototype);
  LRUCache2.prototype.constructor = LRUCache2;
  LRUCache2.prototype.put = function put(key, value2) {
    var map3 = this._map;
    var entry = { key, value: value2 };
    map3[key] = entry;
    if (!this._head) {
      this._head = this._tail = entry;
    } else {
      this._tail.newer = entry;
      entry.older = this._tail;
      this._tail = entry;
    }
    if (this._length >= this._size) {
      map3[this._head.key] = null;
      this._head = this._head.newer;
      this._head.older = null;
    } else {
      this._length++;
    }
  };
  LRUCache2.prototype.get = function get3(key) {
    var entry = this._map[key];
    if (entry) {
      if (entry === this._head && entry !== this._tail) {
        this._head = entry.newer;
        this._head.older = null;
      }
      if (entry !== this._tail) {
        if (entry.older) {
          entry.older.newer = entry.newer;
          entry.newer.older = entry.older;
        }
        entry.older = this._tail;
        entry.newer = null;
        this._tail.newer = entry;
        this._tail = entry;
      }
      return entry.value;
    }
  };
  return LRUCache2;
}(Class$1);
const LRUCache$1 = LRUCache;
var REPLACE_REGEX = /\r?\n|\r|\t/g;
var SPACE$1 = " ";
function normalizeText(text) {
  return String(text).replace(REPLACE_REGEX, SPACE$1);
}
function objectKey$1(object) {
  var parts = [];
  for (var key in object) {
    parts.push(key + object[key]);
  }
  return parts.sort().join("");
}
function hashKey$1(str) {
  var hash = 2166136261;
  for (var i16 = 0; i16 < str.length; ++i16) {
    hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
    hash ^= str.charCodeAt(i16);
  }
  return hash >>> 0;
}
function zeroSize() {
  return { width: 0, height: 0, baseline: 0 };
}
var DEFAULT_OPTIONS$1 = {
  baselineMarkerSize: 1
};
var defaultMeasureBox;
if (typeof document !== "undefined") {
  defaultMeasureBox = document.createElement("div");
  defaultMeasureBox.style.setProperty("position", "absolute", "important");
  defaultMeasureBox.style.setProperty("top", "-4000px", "important");
  defaultMeasureBox.style.setProperty("width", "auto", "important");
  defaultMeasureBox.style.setProperty("height", "auto", "important");
  defaultMeasureBox.style.setProperty("padding", "0", "important");
  defaultMeasureBox.style.setProperty("margin", "0", "important");
  defaultMeasureBox.style.setProperty("border", "0", "important");
  defaultMeasureBox.style.setProperty("line-height", "normal", "important");
  defaultMeasureBox.style.setProperty("visibility", "hidden", "important");
  defaultMeasureBox.style.setProperty("white-space", "pre", "important");
}
var TextMetrics = function(Class3) {
  function TextMetrics2(options2) {
    Class3.call(this);
    this._cache = new LRUCache$1(1e3);
    this.options = Object.assign({}, DEFAULT_OPTIONS$1, options2);
  }
  if (Class3)
    TextMetrics2.__proto__ = Class3;
  TextMetrics2.prototype = Object.create(Class3 && Class3.prototype);
  TextMetrics2.prototype.constructor = TextMetrics2;
  TextMetrics2.prototype.measure = function measure(text, style2, options2) {
    if (options2 === void 0)
      options2 = {};
    if (typeof text === "undefined" || text === null) {
      return zeroSize();
    }
    var styleKey = objectKey$1(style2);
    var cacheKey = hashKey$1(text + styleKey);
    var cachedResult = this._cache.get(cacheKey);
    if (cachedResult) {
      return cachedResult;
    }
    var size = zeroSize();
    var measureBox = options2.box || defaultMeasureBox;
    var baselineMarker = this._baselineMarker().cloneNode(false);
    for (var key in style2) {
      var value2 = style2[key];
      if (typeof value2 !== "undefined") {
        measureBox.style[key] = value2;
      }
    }
    var textStr = options2.normalizeText !== false ? normalizeText(text) : String(text);
    measureBox.textContent = textStr;
    measureBox.appendChild(baselineMarker);
    document.body.appendChild(measureBox);
    if (textStr.length) {
      size.width = measureBox.offsetWidth - this.options.baselineMarkerSize;
      size.height = measureBox.offsetHeight;
      size.baseline = baselineMarker.offsetTop + this.options.baselineMarkerSize;
    }
    if (size.width > 0 && size.height > 0) {
      this._cache.put(cacheKey, size);
    }
    measureBox.parentNode.removeChild(measureBox);
    return size;
  };
  TextMetrics2.prototype._baselineMarker = function _baselineMarker() {
    var marker = document.createElement("div");
    marker.style.display = "inline-block";
    marker.style.verticalAlign = "baseline";
    marker.style.width = this.options.baselineMarkerSize + "px";
    marker.style.height = this.options.baselineMarkerSize + "px";
    marker.style.overflow = "hidden";
    return marker;
  };
  return TextMetrics2;
}(Class$1);
TextMetrics.current = new TextMetrics();
const TextMetrics$1 = TextMetrics;
function measureText(text, style2, measureBox) {
  return TextMetrics$1.current.measure(text, style2, measureBox);
}
const util = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DEG_TO_RAD: DEG_TO_RAD$1,
  LRUCache: LRUCache$1,
  MAX_NUM,
  MIN_NUM,
  TextMetrics: TextMetrics$1,
  append: append$1,
  arabicToRoman,
  bindEvents: bindEvents$1,
  createPromise,
  defined: defined$1,
  definitionId,
  deg: deg$1,
  elementOffset: elementOffset$1,
  elementPadding,
  elementScale: elementScale$1,
  elementSize: elementSize$1,
  elementStyles: elementStyles$1,
  encodeBase64,
  eventCoordinates: eventCoordinates$1,
  eventElement: eventElement$1,
  hashKey: hashKey$1,
  isTransparent: isTransparent$1,
  last: last$1,
  limitValue: limitValue$1,
  measureText,
  mergeSort,
  normalizeText,
  now: now$2,
  objectKey: objectKey$1,
  promiseAll,
  rad: rad$1,
  round: round$2,
  unbindEvents: unbindEvents$1,
  valueOrDefault: valueOrDefault$2
}, Symbol.toStringTag, { value: "Module" }));
var toString = {}.toString;
var OptionsStore = function(HasObservers2) {
  function OptionsStore2(options2, prefix) {
    var this$1$1 = this;
    if (prefix === void 0)
      prefix = "";
    HasObservers2.call(this);
    this.prefix = prefix;
    for (var field in options2) {
      var member = options2[field];
      member = this$1$1._wrap(member, field);
      this$1$1[field] = member;
    }
  }
  if (HasObservers2)
    OptionsStore2.__proto__ = HasObservers2;
  OptionsStore2.prototype = Object.create(HasObservers2 && HasObservers2.prototype);
  OptionsStore2.prototype.constructor = OptionsStore2;
  OptionsStore2.prototype.get = function get3(field) {
    var parts = field.split(".");
    var result = this;
    while (parts.length && result) {
      var part = parts.shift();
      result = result[part];
    }
    return result;
  };
  OptionsStore2.prototype.set = function set4(field, value2) {
    var current2 = this.get(field);
    if (current2 !== value2) {
      this._set(field, this._wrap(value2, field));
      this.optionsChange({
        field: this.prefix + field,
        value: value2
      });
    }
  };
  OptionsStore2.prototype._set = function _set(field, value2) {
    var this$1$1 = this;
    var composite = field.indexOf(".") >= 0;
    var parentObj = this;
    var fieldName = field;
    if (composite) {
      var parts = fieldName.split(".");
      var prefix = this.prefix;
      while (parts.length > 1) {
        fieldName = parts.shift();
        prefix += fieldName + ".";
        var obj = parentObj[fieldName];
        if (!obj) {
          obj = new OptionsStore2({}, prefix);
          obj.addObserver(this$1$1);
          parentObj[fieldName] = obj;
        }
        parentObj = obj;
      }
      fieldName = parts[0];
    }
    parentObj._clear(fieldName);
    parentObj[fieldName] = value2;
  };
  OptionsStore2.prototype._clear = function _clear(field) {
    var current2 = this[field];
    if (current2 && current2.removeObserver) {
      current2.removeObserver(this);
    }
  };
  OptionsStore2.prototype._wrap = function _wrap(object, field) {
    var type = toString.call(object);
    var wrapped = object;
    if (wrapped !== null && defined$1(wrapped) && type === "[object Object]") {
      if (!(object instanceof OptionsStore2) && !(object instanceof Class$1)) {
        wrapped = new OptionsStore2(wrapped, this.prefix + field + ".");
      }
      wrapped.addObserver(this);
    }
    return wrapped;
  };
  return OptionsStore2;
}(HasObservers$1);
const OptionsStore$1 = OptionsStore;
function setAccessor(field) {
  return function(value2) {
    if (this[field] !== value2) {
      this[field] = value2;
      this.geometryChange();
    }
    return this;
  };
}
function getAccessor(field) {
  return function() {
    return this[field];
  };
}
function defineAccessors(fn, fields) {
  for (var i16 = 0; i16 < fields.length; i16++) {
    var name2 = fields[i16];
    var capitalized = name2.charAt(0).toUpperCase() + name2.substring(1, name2.length);
    fn["set" + capitalized] = setAccessor(name2);
    fn["get" + capitalized] = getAccessor(name2);
  }
}
var withAccessors = function(TBase, names) {
  var result = function(TBase2) {
    function result2() {
      TBase2.apply(this, arguments);
    }
    if (TBase2)
      result2.__proto__ = TBase2;
    result2.prototype = Object.create(TBase2 && TBase2.prototype);
    result2.prototype.constructor = result2;
    return result2;
  }(TBase);
  defineAccessors(result.prototype, names);
  return result;
};
const withAccessors$1 = withAccessors;
function toMatrix(transformation) {
  if (transformation && typeof transformation.matrix === "function") {
    return transformation.matrix();
  }
  return transformation;
}
var Point$6 = function(superclass) {
  function Point2(x3, y4) {
    superclass.call(this);
    this.x = x3 || 0;
    this.y = y4 || 0;
  }
  if (superclass)
    Point2.__proto__ = superclass;
  Point2.prototype = Object.create(superclass && superclass.prototype);
  Point2.prototype.constructor = Point2;
  var staticAccessors2 = { ZERO: { configurable: true } };
  Point2.prototype.equals = function equals(other) {
    return other && other.x === this.x && other.y === this.y;
  };
  Point2.prototype.clone = function clone3() {
    return new Point2(this.x, this.y);
  };
  Point2.prototype.rotate = function rotate(angle, origin) {
    var originPoint = Point2.create(origin) || Point2.ZERO;
    return this.transform(Matrix$3.rotate(angle, originPoint.x, originPoint.y));
  };
  Point2.prototype.translate = function translate2(x3, y4) {
    this.x += x3;
    this.y += y4;
    this.geometryChange();
    return this;
  };
  Point2.prototype.translateWith = function translateWith(point2) {
    return this.translate(point2.x, point2.y);
  };
  Point2.prototype.move = function move(x3, y4) {
    this.x = this.y = 0;
    return this.translate(x3, y4);
  };
  Point2.prototype.scale = function scale(scaleX, scaleY) {
    if (scaleY === void 0)
      scaleY = scaleX;
    this.x *= scaleX;
    this.y *= scaleY;
    this.geometryChange();
    return this;
  };
  Point2.prototype.scaleCopy = function scaleCopy(scaleX, scaleY) {
    return this.clone().scale(scaleX, scaleY);
  };
  Point2.prototype.transform = function transform2(transformation) {
    var matrix = toMatrix(transformation);
    var ref2 = this;
    var x3 = ref2.x;
    var y4 = ref2.y;
    this.x = matrix.a * x3 + matrix.c * y4 + matrix.e;
    this.y = matrix.b * x3 + matrix.d * y4 + matrix.f;
    this.geometryChange();
    return this;
  };
  Point2.prototype.transformCopy = function transformCopy(transformation) {
    var point2 = this.clone();
    if (transformation) {
      point2.transform(transformation);
    }
    return point2;
  };
  Point2.prototype.distanceTo = function distanceTo(point2) {
    var dx = this.x - point2.x;
    var dy = this.y - point2.y;
    return Math.sqrt(dx * dx + dy * dy);
  };
  Point2.prototype.round = function round$12(digits) {
    this.x = round$2(this.x, digits);
    this.y = round$2(this.y, digits);
    this.geometryChange();
    return this;
  };
  Point2.prototype.toArray = function toArray2(digits) {
    var doRound = defined$1(digits);
    var x3 = doRound ? round$2(this.x, digits) : this.x;
    var y4 = doRound ? round$2(this.y, digits) : this.y;
    return [x3, y4];
  };
  Point2.prototype.toString = function toString2(digits, separator) {
    if (separator === void 0)
      separator = " ";
    var ref2 = this;
    var x3 = ref2.x;
    var y4 = ref2.y;
    if (defined$1(digits)) {
      x3 = round$2(x3, digits);
      y4 = round$2(y4, digits);
    }
    return x3 + separator + y4;
  };
  Point2.create = function create2(arg0, arg1) {
    if (defined$1(arg0)) {
      if (arg0 instanceof Point2) {
        return arg0;
      } else if (arguments.length === 1 && arg0.length === 2) {
        return new Point2(arg0[0], arg0[1]);
      }
      return new Point2(arg0, arg1);
    }
  };
  Point2.min = function min2() {
    var arguments$1 = arguments;
    var minX = MAX_NUM;
    var minY = MAX_NUM;
    for (var i16 = 0; i16 < arguments.length; i16++) {
      var point2 = arguments$1[i16];
      minX = Math.min(point2.x, minX);
      minY = Math.min(point2.y, minY);
    }
    return new Point2(minX, minY);
  };
  Point2.max = function max2() {
    var arguments$1 = arguments;
    var maxX = MIN_NUM;
    var maxY = MIN_NUM;
    for (var i16 = 0; i16 < arguments.length; i16++) {
      var point2 = arguments$1[i16];
      maxX = Math.max(point2.x, maxX);
      maxY = Math.max(point2.y, maxY);
    }
    return new Point2(maxX, maxY);
  };
  Point2.minPoint = function minPoint() {
    return new Point2(MIN_NUM, MIN_NUM);
  };
  Point2.maxPoint = function maxPoint() {
    return new Point2(MAX_NUM, MAX_NUM);
  };
  staticAccessors2.ZERO.get = function() {
    return new Point2(0, 0);
  };
  Object.defineProperties(Point2, staticAccessors2);
  return Point2;
}(withAccessors$1(HasObservers$1, ["x", "y"]));
const Point$7 = Point$6;
var Size = function(superclass) {
  function Size2(width, height) {
    superclass.call(this);
    this.width = width || 0;
    this.height = height || 0;
  }
  if (superclass)
    Size2.__proto__ = superclass;
  Size2.prototype = Object.create(superclass && superclass.prototype);
  Size2.prototype.constructor = Size2;
  var staticAccessors2 = { ZERO: { configurable: true } };
  Size2.prototype.equals = function equals(other) {
    return other && other.width === this.width && other.height === this.height;
  };
  Size2.prototype.clone = function clone3() {
    return new Size2(this.width, this.height);
  };
  Size2.prototype.toArray = function toArray2(digits) {
    var doRound = defined$1(digits);
    var width = doRound ? round$2(this.width, digits) : this.width;
    var height = doRound ? round$2(this.height, digits) : this.height;
    return [width, height];
  };
  Size2.create = function create2(arg0, arg1) {
    if (defined$1(arg0)) {
      if (arg0 instanceof Size2) {
        return arg0;
      } else if (arguments.length === 1 && arg0.length === 2) {
        return new Size2(arg0[0], arg0[1]);
      }
      return new Size2(arg0, arg1);
    }
  };
  staticAccessors2.ZERO.get = function() {
    return new Size2(0, 0);
  };
  Object.defineProperties(Size2, staticAccessors2);
  return Size2;
}(withAccessors$1(HasObservers$1, ["width", "height"]));
const Size$1 = Size;
var Rect = function(HasObservers2) {
  function Rect2(origin, size, cornerRadius) {
    if (origin === void 0)
      origin = new Point$7();
    if (size === void 0)
      size = new Size$1();
    if (cornerRadius === void 0)
      cornerRadius = 0;
    HasObservers2.call(this);
    this.setOrigin(origin);
    this.setSize(size);
    this.setCornerRadius(cornerRadius);
  }
  if (HasObservers2)
    Rect2.__proto__ = HasObservers2;
  Rect2.prototype = Object.create(HasObservers2 && HasObservers2.prototype);
  Rect2.prototype.constructor = Rect2;
  Rect2.prototype.clone = function clone3() {
    return new Rect2(
      this.origin.clone(),
      this.size.clone()
    );
  };
  Rect2.prototype.equals = function equals(other) {
    return other && other.origin.equals(this.origin) && other.size.equals(this.size);
  };
  Rect2.prototype.setOrigin = function setOrigin(value2) {
    this._observerField("origin", Point$7.create(value2));
    this.geometryChange();
    return this;
  };
  Rect2.prototype.getOrigin = function getOrigin() {
    return this.origin;
  };
  Rect2.prototype.setCornerRadius = function setCornerRadius(radius) {
    this.cornerRadius = Array.isArray(radius) ? radius : [radius, radius];
    this.geometryChange();
    return this;
  };
  Rect2.prototype.getCornerRadius = function getCornerRadius() {
    return this.cornerRadius;
  };
  Rect2.prototype.setSize = function setSize(value2) {
    this._observerField("size", Size$1.create(value2));
    this.geometryChange();
    return this;
  };
  Rect2.prototype.getSize = function getSize() {
    return this.size;
  };
  Rect2.prototype.width = function width() {
    return this.size.width;
  };
  Rect2.prototype.height = function height() {
    return this.size.height;
  };
  Rect2.prototype.topLeft = function topLeft() {
    return this.origin.clone();
  };
  Rect2.prototype.bottomRight = function bottomRight() {
    return this.origin.clone().translate(this.width(), this.height());
  };
  Rect2.prototype.topRight = function topRight() {
    return this.origin.clone().translate(this.width(), 0);
  };
  Rect2.prototype.bottomLeft = function bottomLeft() {
    return this.origin.clone().translate(0, this.height());
  };
  Rect2.prototype.center = function center() {
    return this.origin.clone().translate(this.width() / 2, this.height() / 2);
  };
  Rect2.prototype.bbox = function bbox(matrix) {
    var tl2 = this.topLeft().transformCopy(matrix);
    var tr = this.topRight().transformCopy(matrix);
    var br = this.bottomRight().transformCopy(matrix);
    var bl2 = this.bottomLeft().transformCopy(matrix);
    return Rect2.fromPoints(tl2, tr, br, bl2);
  };
  Rect2.prototype.transformCopy = function transformCopy(m3) {
    return Rect2.fromPoints(
      this.topLeft().transform(m3),
      this.bottomRight().transform(m3)
    );
  };
  Rect2.prototype.expand = function expand(x3, y4) {
    if (y4 === void 0)
      y4 = x3;
    this.size.width += 2 * x3;
    this.size.height += 2 * y4;
    this.origin.translate(-x3, -y4);
    return this;
  };
  Rect2.prototype.expandCopy = function expandCopy(x3, y4) {
    return this.clone().expand(x3, y4);
  };
  Rect2.prototype.containsPoint = function containsPoint(point2) {
    var origin = this.origin;
    var bottomRight = this.bottomRight();
    return !(point2.x < origin.x || point2.y < origin.y || bottomRight.x < point2.x || bottomRight.y < point2.y);
  };
  Rect2.prototype._isOnPath = function _isOnPath(point2, width) {
    var rectOuter = this.expandCopy(width, width);
    var rectInner = this.expandCopy(-width, -width);
    return rectOuter.containsPoint(point2) && !rectInner.containsPoint(point2);
  };
  Rect2.fromPoints = function fromPoints() {
    var topLeft = Point$7.min.apply(null, arguments);
    var bottomRight = Point$7.max.apply(null, arguments);
    var size = new Size$1(
      bottomRight.x - topLeft.x,
      bottomRight.y - topLeft.y
    );
    return new Rect2(topLeft, size);
  };
  Rect2.union = function union(a9, b2) {
    return Rect2.fromPoints(
      Point$7.min(a9.topLeft(), b2.topLeft()),
      Point$7.max(a9.bottomRight(), b2.bottomRight())
    );
  };
  Rect2.intersect = function intersect2(a9, b2) {
    var rect1 = {
      left: a9.topLeft().x,
      top: a9.topLeft().y,
      right: a9.bottomRight().x,
      bottom: a9.bottomRight().y
    };
    var rect2 = {
      left: b2.topLeft().x,
      top: b2.topLeft().y,
      right: b2.bottomRight().x,
      bottom: b2.bottomRight().y
    };
    if (rect1.left <= rect2.right && rect2.left <= rect1.right && rect1.top <= rect2.bottom && rect2.top <= rect1.bottom) {
      return Rect2.fromPoints(
        new Point$7(Math.max(rect1.left, rect2.left), Math.max(rect1.top, rect2.top)),
        new Point$7(Math.min(rect1.right, rect2.right), Math.min(rect1.bottom, rect2.bottom))
      );
    }
  };
  return Rect2;
}(HasObservers$1);
const Rect$1 = Rect;
var Transformation = function(HasObservers2) {
  function Transformation2(matrix) {
    if (matrix === void 0)
      matrix = Matrix$3.unit();
    HasObservers2.call(this);
    this._matrix = matrix;
  }
  if (HasObservers2)
    Transformation2.__proto__ = HasObservers2;
  Transformation2.prototype = Object.create(HasObservers2 && HasObservers2.prototype);
  Transformation2.prototype.constructor = Transformation2;
  Transformation2.prototype.clone = function clone3() {
    return new Transformation2(
      this._matrix.clone()
    );
  };
  Transformation2.prototype.equals = function equals(other) {
    return other && other._matrix.equals(this._matrix);
  };
  Transformation2.prototype.translate = function translate2(x3, y4) {
    this._matrix = this._matrix.multiplyCopy(Matrix$3.translate(x3, y4));
    this._optionsChange();
    return this;
  };
  Transformation2.prototype.scale = function scale(scaleX, scaleY, origin) {
    if (scaleY === void 0)
      scaleY = scaleX;
    if (origin === void 0)
      origin = null;
    var originPoint = origin;
    if (originPoint) {
      originPoint = Point$7.create(originPoint);
      this._matrix = this._matrix.multiplyCopy(Matrix$3.translate(originPoint.x, originPoint.y));
    }
    this._matrix = this._matrix.multiplyCopy(Matrix$3.scale(scaleX, scaleY));
    if (originPoint) {
      this._matrix = this._matrix.multiplyCopy(Matrix$3.translate(-originPoint.x, -originPoint.y));
    }
    this._optionsChange();
    return this;
  };
  Transformation2.prototype.rotate = function rotate(angle, origin) {
    var originPoint = Point$7.create(origin) || Point$7.ZERO;
    this._matrix = this._matrix.multiplyCopy(Matrix$3.rotate(angle, originPoint.x, originPoint.y));
    this._optionsChange();
    return this;
  };
  Transformation2.prototype.multiply = function multiply2(transformation) {
    var matrix = toMatrix(transformation);
    this._matrix = this._matrix.multiplyCopy(matrix);
    this._optionsChange();
    return this;
  };
  Transformation2.prototype.matrix = function matrix(value2) {
    if (value2) {
      this._matrix = value2;
      this._optionsChange();
      return this;
    }
    return this._matrix;
  };
  Transformation2.prototype._optionsChange = function _optionsChange() {
    this.optionsChange({
      field: "transform",
      value: this
    });
  };
  return Transformation2;
}(HasObservers$1);
const Transformation$1 = Transformation;
function transform(matrix) {
  if (matrix === null) {
    return null;
  }
  if (matrix instanceof Transformation$1) {
    return matrix;
  }
  return new Transformation$1(matrix);
}
var DASH_ARRAYS = {
  dot: [1.5, 3.5],
  dash: [4, 3.5],
  longdash: [8, 3.5],
  dashdot: [3.5, 3.5, 1.5, 3.5],
  longdashdot: [8, 3.5, 1.5, 3.5],
  longdashdotdot: [8, 3.5, 1.5, 3.5, 1.5, 3.5]
};
var SOLID = "solid";
var BUTT = "butt";
var PATTERN = "Pattern";
var Element$1 = function(HasObservers2) {
  function Element2(options2) {
    HasObservers2.call(this);
    this._initOptions(options2);
  }
  if (HasObservers2)
    Element2.__proto__ = HasObservers2;
  Element2.prototype = Object.create(HasObservers2 && HasObservers2.prototype);
  Element2.prototype.constructor = Element2;
  var prototypeAccessors2 = { nodeType: { configurable: true } };
  prototypeAccessors2.nodeType.get = function() {
    return "Rect";
  };
  Element2.prototype._initOptions = function _initOptions(options2) {
    if (options2 === void 0)
      options2 = {};
    var clip = options2.clip;
    var transform$1 = options2.transform;
    if (transform$1) {
      options2.transform = transform(transform$1);
    }
    if (clip && !clip.id) {
      clip.id = definitionId();
    }
    this.options = new OptionsStore$1(options2);
    this.options.addObserver(this);
  };
  Element2.prototype.transform = function transform$1(value2) {
    if (defined$1(value2)) {
      this.options.set("transform", transform(value2));
    } else {
      return this.options.get("transform");
    }
  };
  Element2.prototype.parentTransform = function parentTransform() {
    var element = this;
    var parentMatrix;
    while (element.parent) {
      element = element.parent;
      var transformation = element.transform();
      if (transformation) {
        parentMatrix = transformation.matrix().multiplyCopy(parentMatrix || Matrix$3.unit());
      }
    }
    if (parentMatrix) {
      return transform(parentMatrix);
    }
  };
  Element2.prototype.currentTransform = function currentTransform(parentTransform) {
    if (parentTransform === void 0)
      parentTransform = this.parentTransform();
    var elementTransform = this.transform();
    var elementMatrix = toMatrix(elementTransform);
    var parentMatrix = toMatrix(parentTransform);
    var combinedMatrix;
    if (elementMatrix && parentMatrix) {
      combinedMatrix = parentMatrix.multiplyCopy(elementMatrix);
    } else {
      combinedMatrix = elementMatrix || parentMatrix;
    }
    if (combinedMatrix) {
      return transform(combinedMatrix);
    }
  };
  Element2.prototype.visible = function visible(value2) {
    if (defined$1(value2)) {
      this.options.set("visible", value2);
      return this;
    }
    return this.options.get("visible") !== false;
  };
  Element2.prototype.clip = function clip(value2) {
    var options2 = this.options;
    if (defined$1(value2)) {
      if (value2 && !value2.id) {
        value2.id = definitionId();
      }
      options2.set("clip", value2);
      return this;
    }
    return options2.get("clip");
  };
  Element2.prototype.opacity = function opacity(value2) {
    if (defined$1(value2)) {
      this.options.set("opacity", value2);
      return this;
    }
    return valueOrDefault$2(this.options.get("opacity"), 1);
  };
  Element2.prototype.className = function className(value2) {
    if (defined$1(value2)) {
      this.options.set("className", value2);
      return this;
    }
    return this.options.get("className");
  };
  Element2.prototype.clippedBBox = function clippedBBox(transformation) {
    var bbox = this._clippedBBox(transformation);
    if (bbox) {
      var clip = this.clip();
      return clip ? Rect$1.intersect(bbox, clip.bbox(transformation)) : bbox;
    }
  };
  Element2.prototype.containsPoint = function containsPoint(point2, parentTransform) {
    if (this.visible()) {
      var transform2 = this.currentTransform(parentTransform);
      var transformedPoint = point2;
      if (transform2) {
        transformedPoint = point2.transformCopy(transform2.matrix().invert());
      }
      return this._hasFill() && this._containsPoint(transformedPoint) || this._isOnPath && this._hasStroke() && this._isOnPath(transformedPoint);
    }
    return false;
  };
  Element2.prototype._hasFill = function _hasFill() {
    var fill = this.options.fill;
    return fill && (fill.nodeType === PATTERN || !isTransparent$1(fill.color));
  };
  Element2.prototype._hasStroke = function _hasStroke() {
    var stroke = this.options.stroke;
    return stroke && stroke.width > 0 && !isTransparent$1(stroke.color);
  };
  Element2.prototype._clippedBBox = function _clippedBBox(transformation) {
    return this.bbox(transformation);
  };
  Object.defineProperties(Element2.prototype, prototypeAccessors2);
  return Element2;
}(HasObservers$1);
const Element$2 = Element$1;
function ellipseExtremeAngles(center, rx, ry, matrix) {
  var extremeX = 0;
  var extremeY = 0;
  if (matrix) {
    extremeX = Math.atan2(matrix.c * ry, matrix.a * rx);
    if (matrix.b !== 0) {
      extremeY = Math.atan2(matrix.d * ry, matrix.b * rx);
    }
  }
  return {
    x: extremeX,
    y: extremeY
  };
}
var PI_DIV_2$1 = Math.PI / 2;
var Circle$4 = function(superclass) {
  function Circle2(center, radius) {
    if (center === void 0)
      center = new Point$7();
    if (radius === void 0)
      radius = 0;
    superclass.call(this);
    this.setCenter(center);
    this.setRadius(radius);
  }
  if (superclass)
    Circle2.__proto__ = superclass;
  Circle2.prototype = Object.create(superclass && superclass.prototype);
  Circle2.prototype.constructor = Circle2;
  Circle2.prototype.setCenter = function setCenter(value2) {
    this._observerField("center", Point$7.create(value2));
    this.geometryChange();
    return this;
  };
  Circle2.prototype.getCenter = function getCenter() {
    return this.center;
  };
  Circle2.prototype.equals = function equals(other) {
    return other && other.center.equals(this.center) && other.radius === this.radius;
  };
  Circle2.prototype.clone = function clone3() {
    return new Circle2(this.center.clone(), this.radius);
  };
  Circle2.prototype.pointAt = function pointAt(angle) {
    return this._pointAt(rad$1(angle));
  };
  Circle2.prototype.bbox = function bbox(matrix) {
    var this$1$1 = this;
    var extremeAngles = ellipseExtremeAngles(this.center, this.radius, this.radius, matrix);
    var minPoint = Point$7.maxPoint();
    var maxPoint = Point$7.minPoint();
    for (var i16 = 0; i16 < 4; i16++) {
      var currentPointX = this$1$1._pointAt(extremeAngles.x + i16 * PI_DIV_2$1).transformCopy(matrix);
      var currentPointY = this$1$1._pointAt(extremeAngles.y + i16 * PI_DIV_2$1).transformCopy(matrix);
      var currentPoint = new Point$7(currentPointX.x, currentPointY.y);
      minPoint = Point$7.min(minPoint, currentPoint);
      maxPoint = Point$7.max(maxPoint, currentPoint);
    }
    return Rect$1.fromPoints(minPoint, maxPoint);
  };
  Circle2.prototype._pointAt = function _pointAt(angle) {
    var ref2 = this;
    var center = ref2.center;
    var radius = ref2.radius;
    return new Point$7(
      center.x + radius * Math.cos(angle),
      center.y + radius * Math.sin(angle)
    );
  };
  Circle2.prototype.containsPoint = function containsPoint(point2) {
    var ref2 = this;
    var center = ref2.center;
    var radius = ref2.radius;
    var inCircle = Math.pow(point2.x - center.x, 2) + Math.pow(point2.y - center.y, 2) <= Math.pow(radius, 2);
    return inCircle;
  };
  Circle2.prototype._isOnPath = function _isOnPath(point2, width) {
    var ref2 = this;
    var center = ref2.center;
    var radius = ref2.radius;
    var pointDistance = center.distanceTo(point2);
    return radius - width <= pointDistance && pointDistance <= radius + width;
  };
  return Circle2;
}(withAccessors$1(HasObservers$1, ["radius"]));
const geomCircle = Circle$4;
var GRADIENT = "Gradient";
var paintable = function(TBase) {
  return function(TBase2) {
    function anonymous() {
      TBase2.apply(this, arguments);
    }
    if (TBase2)
      anonymous.__proto__ = TBase2;
    anonymous.prototype = Object.create(TBase2 && TBase2.prototype);
    anonymous.prototype.constructor = anonymous;
    anonymous.prototype.fill = function fill(color, opacity) {
      var options2 = this.options;
      if (defined$1(color)) {
        if (color && color.nodeType !== GRADIENT) {
          var newFill = {
            color
          };
          if (defined$1(opacity)) {
            newFill.opacity = opacity;
          }
          options2.set("fill", newFill);
        } else {
          options2.set("fill", color);
        }
        return this;
      }
      return options2.get("fill");
    };
    anonymous.prototype.stroke = function stroke(color, width, opacity) {
      if (defined$1(color)) {
        this.options.set("stroke.color", color);
        if (defined$1(width)) {
          this.options.set("stroke.width", width);
        }
        if (defined$1(opacity)) {
          this.options.set("stroke.opacity", opacity);
        }
        return this;
      }
      return this.options.get("stroke");
    };
    return anonymous;
  }(TBase);
};
const paintable$1 = paintable;
var IDENTITY_MATRIX_HASH = Matrix$3.IDENTITY.toString();
var measurable = function(TBase) {
  return function(TBase2) {
    function anonymous() {
      TBase2.apply(this, arguments);
    }
    if (TBase2)
      anonymous.__proto__ = TBase2;
    anonymous.prototype = Object.create(TBase2 && TBase2.prototype);
    anonymous.prototype.constructor = anonymous;
    anonymous.prototype.bbox = function bbox(transformation) {
      var combinedMatrix = toMatrix(this.currentTransform(transformation));
      var matrixHash = combinedMatrix ? combinedMatrix.toString() : IDENTITY_MATRIX_HASH;
      var bbox2;
      if (this._bboxCache && this._matrixHash === matrixHash) {
        bbox2 = this._bboxCache.clone();
      } else {
        bbox2 = this._bbox(combinedMatrix);
        this._bboxCache = bbox2 ? bbox2.clone() : null;
        this._matrixHash = matrixHash;
      }
      var strokeWidth = this.options.get("stroke.width");
      if (strokeWidth && bbox2) {
        bbox2.expand(strokeWidth / 2);
      }
      return bbox2;
    };
    anonymous.prototype.geometryChange = function geometryChange() {
      delete this._bboxCache;
      this.trigger("geometryChange", {
        element: this
      });
    };
    return anonymous;
  }(TBase);
};
const measurable$1 = measurable;
function geometryAccessor(name2) {
  var fieldName = "_" + name2;
  return function(value2) {
    if (defined$1(value2)) {
      this._observerField(fieldName, value2);
      this.geometryChange();
      return this;
    }
    return this[fieldName];
  };
}
function defineGeometryAccessors(fn, names) {
  for (var i16 = 0; i16 < names.length; i16++) {
    fn[names[i16]] = geometryAccessor(names[i16]);
  }
}
var withGeometry = function(TBase, names) {
  if (names === void 0)
    names = ["geometry"];
  var result = function(TBase2) {
    function result2() {
      TBase2.apply(this, arguments);
    }
    if (TBase2)
      result2.__proto__ = TBase2;
    result2.prototype = Object.create(TBase2 && TBase2.prototype);
    result2.prototype.constructor = result2;
    return result2;
  }(TBase);
  defineGeometryAccessors(result.prototype, names);
  return result;
};
const withGeometry$1 = withGeometry;
var DEFAULT_STROKE$1 = "#000";
var Circle$2 = function(superclass) {
  function Circle2(geometry, options2) {
    if (geometry === void 0)
      geometry = new geomCircle();
    if (options2 === void 0)
      options2 = {};
    superclass.call(this, options2);
    this.geometry(geometry);
    if (!defined$1(this.options.stroke)) {
      this.stroke(DEFAULT_STROKE$1);
    }
  }
  if (superclass)
    Circle2.__proto__ = superclass;
  Circle2.prototype = Object.create(superclass && superclass.prototype);
  Circle2.prototype.constructor = Circle2;
  var prototypeAccessors2 = { nodeType: { configurable: true } };
  prototypeAccessors2.nodeType.get = function() {
    return "Circle";
  };
  Circle2.prototype.rawBBox = function rawBBox() {
    return this._geometry.bbox();
  };
  Circle2.prototype._bbox = function _bbox(matrix) {
    return this._geometry.bbox(matrix);
  };
  Circle2.prototype._containsPoint = function _containsPoint(point2) {
    return this.geometry().containsPoint(point2);
  };
  Circle2.prototype._isOnPath = function _isOnPath(point2) {
    return this.geometry()._isOnPath(point2, this.options.stroke.width / 2);
  };
  Object.defineProperties(Circle2.prototype, prototypeAccessors2);
  return Circle2;
}(paintable$1(measurable$1(withGeometry$1(Element$2))));
const Circle$3 = Circle$2;
var PRECISION = 10;
function close(a9, b2, tolerance) {
  if (tolerance === void 0)
    tolerance = PRECISION;
  return round$2(Math.abs(a9 - b2), tolerance) === 0;
}
function closeOrLess(a9, b2, tolerance) {
  return a9 < b2 || close(a9, b2, tolerance);
}
function lineIntersection(p0, p1, p22, p32) {
  var s1x = p1.x - p0.x;
  var s2x = p32.x - p22.x;
  var s1y = p1.y - p0.y;
  var s2y = p32.y - p22.y;
  var nx = p0.x - p22.x;
  var ny = p0.y - p22.y;
  var d8 = s1x * s2y - s2x * s1y;
  var s10 = (s1x * ny - s1y * nx) / d8;
  var t6 = (s2x * ny - s2y * nx) / d8;
  if (s10 >= 0 && s10 <= 1 && t6 >= 0 && t6 <= 1) {
    return new Point$7(p0.x + t6 * s1x, p0.y + t6 * s1y);
  }
}
var MAX_INTERVAL = 45;
var pow$2 = Math.pow;
var accessors = ["radiusX", "radiusY", "startAngle", "endAngle", "anticlockwise"];
var Arc$3 = function(superclass) {
  function Arc2(center, options2) {
    if (center === void 0)
      center = new Point$7();
    if (options2 === void 0)
      options2 = {};
    superclass.call(this);
    this.setCenter(center);
    this.radiusX = options2.radiusX;
    this.radiusY = options2.radiusY || options2.radiusX;
    this.startAngle = options2.startAngle;
    this.endAngle = options2.endAngle;
    this.anticlockwise = options2.anticlockwise || false;
    this.xRotation = options2.xRotation;
  }
  if (superclass)
    Arc2.__proto__ = superclass;
  Arc2.prototype = Object.create(superclass && superclass.prototype);
  Arc2.prototype.constructor = Arc2;
  Arc2.prototype.clone = function clone3() {
    return new Arc2(this.center, {
      radiusX: this.radiusX,
      radiusY: this.radiusY,
      startAngle: this.startAngle,
      endAngle: this.endAngle,
      anticlockwise: this.anticlockwise
    });
  };
  Arc2.prototype.setCenter = function setCenter(value2) {
    this._observerField("center", Point$7.create(value2));
    this.geometryChange();
    return this;
  };
  Arc2.prototype.getCenter = function getCenter() {
    return this.center;
  };
  Arc2.prototype.pointAt = function pointAt(angle) {
    var center = this.center;
    var radian = rad$1(angle);
    return new Point$7(
      center.x + this.radiusX * Math.cos(radian),
      center.y + this.radiusY * Math.sin(radian)
    );
  };
  Arc2.prototype.curvePoints = function curvePoints() {
    var this$1$1 = this;
    var startAngle = this.startAngle;
    var dir = this.anticlockwise ? -1 : 1;
    var curvePoints2 = [this.pointAt(startAngle)];
    var interval = this._arcInterval();
    var intervalAngle = interval.endAngle - interval.startAngle;
    var subIntervalsCount = Math.ceil(intervalAngle / MAX_INTERVAL);
    var subIntervalAngle = intervalAngle / subIntervalsCount;
    var currentAngle = startAngle;
    var transformation;
    if (this.xRotation) {
      transformation = transform().rotate(this.xRotation, this.center);
    }
    for (var i16 = 1; i16 <= subIntervalsCount; i16++) {
      var nextAngle = currentAngle + dir * subIntervalAngle;
      var points2 = this$1$1._intervalCurvePoints(currentAngle, nextAngle, transformation);
      curvePoints2.push(points2.cp1, points2.cp2, points2.p2);
      currentAngle = nextAngle;
    }
    return curvePoints2;
  };
  Arc2.prototype.bbox = function bbox(matrix) {
    var this$1$1 = this;
    var interval = this._arcInterval();
    var startAngle = interval.startAngle;
    var endAngle = interval.endAngle;
    var extremeAngles = ellipseExtremeAngles(this.center, this.radiusX, this.radiusY, matrix);
    var extremeX = deg$1(extremeAngles.x);
    var extremeY = deg$1(extremeAngles.y);
    var endPoint = this.pointAt(endAngle).transformCopy(matrix);
    var currentAngleX = bboxStartAngle(extremeX, startAngle);
    var currentAngleY = bboxStartAngle(extremeY, startAngle);
    var currentPoint = this.pointAt(startAngle).transformCopy(matrix);
    var minPoint = Point$7.min(currentPoint, endPoint);
    var maxPoint = Point$7.max(currentPoint, endPoint);
    while (currentAngleX < endAngle || currentAngleY < endAngle) {
      var currentPointX = void 0;
      if (currentAngleX < endAngle) {
        currentPointX = this$1$1.pointAt(currentAngleX).transformCopy(matrix);
        currentAngleX += 90;
      }
      var currentPointY = void 0;
      if (currentAngleY < endAngle) {
        currentPointY = this$1$1.pointAt(currentAngleY).transformCopy(matrix);
        currentAngleY += 90;
      }
      currentPoint = new Point$7(currentPointX.x, currentPointY.y);
      minPoint = Point$7.min(minPoint, currentPoint);
      maxPoint = Point$7.max(maxPoint, currentPoint);
    }
    return Rect$1.fromPoints(minPoint, maxPoint);
  };
  Arc2.prototype._arcInterval = function _arcInterval() {
    var ref2 = this;
    var startAngle = ref2.startAngle;
    var endAngle = ref2.endAngle;
    var anticlockwise = ref2.anticlockwise;
    if (anticlockwise) {
      var oldStart = startAngle;
      startAngle = endAngle;
      endAngle = oldStart;
    }
    if (startAngle > endAngle || anticlockwise && startAngle === endAngle) {
      endAngle += 360;
    }
    return {
      startAngle,
      endAngle
    };
  };
  Arc2.prototype._intervalCurvePoints = function _intervalCurvePoints(startAngle, endAngle, transformation) {
    var p1 = this.pointAt(startAngle);
    var p22 = this.pointAt(endAngle);
    var p1Derivative = this._derivativeAt(startAngle);
    var p2Derivative = this._derivativeAt(endAngle);
    var t6 = (rad$1(endAngle) - rad$1(startAngle)) / 3;
    var cp1 = new Point$7(p1.x + t6 * p1Derivative.x, p1.y + t6 * p1Derivative.y);
    var cp2 = new Point$7(p22.x - t6 * p2Derivative.x, p22.y - t6 * p2Derivative.y);
    if (transformation) {
      p1.transform(transformation);
      p22.transform(transformation);
      cp1.transform(transformation);
      cp2.transform(transformation);
    }
    return {
      p1,
      cp1,
      cp2,
      p2: p22
    };
  };
  Arc2.prototype._derivativeAt = function _derivativeAt(angle) {
    var radian = rad$1(angle);
    return new Point$7(-this.radiusX * Math.sin(radian), this.radiusY * Math.cos(radian));
  };
  Arc2.prototype.containsPoint = function containsPoint(point2) {
    var interval = this._arcInterval();
    var intervalAngle = interval.endAngle - interval.startAngle;
    var ref2 = this;
    var center = ref2.center;
    var radiusX = ref2.radiusX;
    var radiusY = ref2.radiusY;
    var distance = center.distanceTo(point2);
    var angleRad = Math.atan2(point2.y - center.y, point2.x - center.x);
    var pointRadius = radiusX * radiusY / Math.sqrt(pow$2(radiusX, 2) * pow$2(Math.sin(angleRad), 2) + pow$2(radiusY, 2) * pow$2(Math.cos(angleRad), 2));
    var startPoint = this.pointAt(this.startAngle).round(PRECISION);
    var endPoint = this.pointAt(this.endAngle).round(PRECISION);
    var intersection2 = lineIntersection(center, point2.round(PRECISION), startPoint, endPoint);
    var containsPoint2;
    if (intervalAngle < 180) {
      containsPoint2 = intersection2 && closeOrLess(center.distanceTo(intersection2), distance) && closeOrLess(distance, pointRadius);
    } else {
      var angle = calculateAngle(center.x, center.y, radiusX, radiusY, point2.x, point2.y);
      if (angle !== 360) {
        angle = (360 + angle) % 360;
      }
      var inAngleRange = interval.startAngle <= angle && angle <= interval.endAngle;
      containsPoint2 = inAngleRange && closeOrLess(distance, pointRadius) || !inAngleRange && (!intersection2 || intersection2.equals(point2));
    }
    return containsPoint2;
  };
  Arc2.prototype._isOnPath = function _isOnPath(point2, width) {
    var interval = this._arcInterval();
    var center = this.center;
    var angle = calculateAngle(center.x, center.y, this.radiusX, this.radiusY, point2.x, point2.y);
    if (angle !== 360) {
      angle = (360 + angle) % 360;
    }
    var inAngleRange = interval.startAngle <= angle && angle <= interval.endAngle;
    return inAngleRange && this.pointAt(angle).distanceTo(point2) <= width;
  };
  Arc2.fromPoints = function fromPoints(start, end, rx, ry, largeArc, swipe, rotation) {
    var arcParameters = normalizeArcParameters({
      x1: start.x,
      y1: start.y,
      x2: end.x,
      y2: end.y,
      rx,
      ry,
      largeArc,
      swipe,
      rotation
    });
    return new Arc2(arcParameters.center, {
      startAngle: arcParameters.startAngle,
      endAngle: arcParameters.endAngle,
      radiusX: arcParameters.radiusX,
      radiusY: arcParameters.radiusY,
      xRotation: arcParameters.xRotation,
      anticlockwise: swipe === 0
    });
  };
  return Arc2;
}(withAccessors$1(HasObservers$1, accessors));
function calculateAngle(cx, cy, rx, ry, x3, y4) {
  var cos2 = round$2((x3 - cx) / rx, 3);
  var sin2 = round$2((y4 - cy) / ry, 3);
  return round$2(deg$1(Math.atan2(sin2, cos2)));
}
function normalizeArcParameters(parameters) {
  var x1 = parameters.x1;
  var y1 = parameters.y1;
  var x22 = parameters.x2;
  var y22 = parameters.y2;
  var rx = parameters.rx;
  var ry = parameters.ry;
  var largeArc = parameters.largeArc;
  var swipe = parameters.swipe;
  var rotation = parameters.rotation;
  if (rotation === void 0)
    rotation = 0;
  var radians = rad$1(rotation);
  var cosine = Math.cos(radians);
  var sine = Math.sin(radians);
  var xT = cosine * (x1 - x22) / 2 + sine * (y1 - y22) / 2;
  var yT = -sine * (x1 - x22) / 2 + cosine * (y1 - y22) / 2;
  var sign = largeArc !== swipe ? 1 : -1;
  var xt2 = Math.pow(xT, 2);
  var yt2 = Math.pow(yT, 2);
  var rx2 = Math.pow(rx, 2);
  var ry2 = Math.pow(ry, 2);
  var delta = xt2 / rx2 + yt2 / ry2;
  if (delta > 1) {
    delta = Math.sqrt(xt2 / rx2 + yt2 / ry2);
    rx = delta * rx;
    rx2 = Math.pow(rx, 2);
    ry = delta * ry;
    ry2 = Math.pow(ry, 2);
  }
  var constT = sign * Math.sqrt((rx2 * ry2 - rx2 * yt2 - ry2 * xt2) / (rx2 * yt2 + ry2 * xt2));
  if (isNaN(constT)) {
    constT = 0;
  }
  var cxT = constT * (rx * yT) / ry;
  var cyT = -constT * (ry * xT) / rx;
  var cx = cosine * cxT - sine * cyT + (x1 + x22) / 2;
  var cy = sine * cxT + cosine * cyT + (y1 + y22) / 2;
  var uX = (xT - cxT) / rx;
  var uY = (yT - cyT) / ry;
  var vX = -(xT + cxT) / rx;
  var vY = -(yT + cyT) / ry;
  var startAngle = (uY >= 0 ? 1 : -1) * deg$1(Math.acos(uX / Math.sqrt(uX * uX + uY * uY)));
  var angleCosine = round$2((uX * vX + uY * vY) / (Math.sqrt(uX * uX + uY * uY) * Math.sqrt(vX * vX + vY * vY)), 10);
  var angle = (uX * vY - uY * vX >= 0 ? 1 : -1) * deg$1(Math.acos(angleCosine));
  if (!swipe && angle > 0) {
    angle -= 360;
  }
  if (swipe && angle < 0) {
    angle += 360;
  }
  var endAngle = startAngle + angle;
  var signEndAngle = endAngle >= 0 ? 1 : -1;
  endAngle = Math.abs(endAngle) % 360 * signEndAngle;
  return {
    center: new Point$7(cx, cy),
    startAngle,
    endAngle,
    radiusX: rx,
    radiusY: ry,
    xRotation: rotation
  };
}
function bboxStartAngle(angle, start) {
  var startAngle = angle;
  while (startAngle < start) {
    startAngle += 90;
  }
  return startAngle;
}
const GeometryArc = Arc$3;
var push = [].push;
var pop = [].pop;
var splice = [].splice;
var shift = [].shift;
var slice = [].slice;
var unshift = [].unshift;
var ElementsArray = function(HasObservers2) {
  function ElementsArray2(array) {
    if (array === void 0)
      array = [];
    HasObservers2.call(this);
    this.length = 0;
    this._splice(0, array.length, array);
  }
  if (HasObservers2)
    ElementsArray2.__proto__ = HasObservers2;
  ElementsArray2.prototype = Object.create(HasObservers2 && HasObservers2.prototype);
  ElementsArray2.prototype.constructor = ElementsArray2;
  ElementsArray2.prototype.elements = function elements(value2) {
    if (value2) {
      this._splice(0, this.length, value2);
      this._change();
      return this;
    }
    return this.slice(0);
  };
  ElementsArray2.prototype.push = function push$1() {
    var elements = arguments;
    var result = push.apply(this, elements);
    this._add(elements);
    return result;
  };
  ElementsArray2.prototype.slice = function slice$1() {
    return slice.call(this);
  };
  ElementsArray2.prototype.pop = function pop$1() {
    var length = this.length;
    var result = pop.apply(this);
    if (length) {
      this._remove([result]);
    }
    return result;
  };
  ElementsArray2.prototype.splice = function splice2(index2, howMany) {
    var elements = slice.call(arguments, 2);
    var result = this._splice(index2, howMany, elements);
    this._change();
    return result;
  };
  ElementsArray2.prototype.shift = function shift$1() {
    var length = this.length;
    var result = shift.apply(this);
    if (length) {
      this._remove([result]);
    }
    return result;
  };
  ElementsArray2.prototype.unshift = function unshift$1() {
    var elements = arguments;
    var result = unshift.apply(this, elements);
    this._add(elements);
    return result;
  };
  ElementsArray2.prototype.indexOf = function indexOf2(element) {
    var this$1$1 = this;
    var length = this.length;
    for (var idx = 0; idx < length; idx++) {
      if (this$1$1[idx] === element) {
        return idx;
      }
    }
    return -1;
  };
  ElementsArray2.prototype._splice = function _splice(index2, howMany, elements) {
    var result = splice.apply(this, [index2, howMany].concat(elements));
    this._clearObserver(result);
    this._setObserver(elements);
    return result;
  };
  ElementsArray2.prototype._add = function _add(elements) {
    this._setObserver(elements);
    this._change();
  };
  ElementsArray2.prototype._remove = function _remove(elements) {
    this._clearObserver(elements);
    this._change();
  };
  ElementsArray2.prototype._setObserver = function _setObserver(elements) {
    var this$1$1 = this;
    for (var idx = 0; idx < elements.length; idx++) {
      elements[idx].addObserver(this$1$1);
    }
  };
  ElementsArray2.prototype._clearObserver = function _clearObserver(elements) {
    var this$1$1 = this;
    for (var idx = 0; idx < elements.length; idx++) {
      elements[idx].removeObserver(this$1$1);
    }
  };
  ElementsArray2.prototype._change = function _change() {
  };
  return ElementsArray2;
}(HasObservers$1);
const ElementsArray$1 = ElementsArray;
var GeometryElementsArray = function(ElementsArray2) {
  function GeometryElementsArray2() {
    ElementsArray2.apply(this, arguments);
  }
  if (ElementsArray2)
    GeometryElementsArray2.__proto__ = ElementsArray2;
  GeometryElementsArray2.prototype = Object.create(ElementsArray2 && ElementsArray2.prototype);
  GeometryElementsArray2.prototype.constructor = GeometryElementsArray2;
  GeometryElementsArray2.prototype._change = function _change() {
    this.geometryChange();
  };
  return GeometryElementsArray2;
}(ElementsArray$1);
const GeometryElementsArray$1 = GeometryElementsArray;
function isOutOfEndPoint(endPoint, controlPoint, point2) {
  var angle = deg$1(Math.atan2(controlPoint.y - endPoint.y, controlPoint.x - endPoint.x));
  var rotatedPoint = point2.transformCopy(transform().rotate(-angle, endPoint));
  return rotatedPoint.x < endPoint.x;
}
function calculateCurveAt(t6, field, points2) {
  var t1 = 1 - t6;
  return Math.pow(t1, 3) * points2[0][field] + 3 * Math.pow(t1, 2) * t6 * points2[1][field] + 3 * Math.pow(t6, 2) * t1 * points2[2][field] + Math.pow(t6, 3) * points2[3][field];
}
function toCubicPolynomial(points2, field) {
  return [
    -points2[0][field] + 3 * points2[1][field] - 3 * points2[2][field] + points2[3][field],
    3 * (points2[0][field] - 2 * points2[1][field] + points2[2][field]),
    3 * (-points2[0][field] + points2[1][field]),
    points2[0][field]
  ];
}
var ComplexNumber = function(Class3) {
  function ComplexNumber2(real, img) {
    if (real === void 0)
      real = 0;
    if (img === void 0)
      img = 0;
    Class3.call(this);
    this.real = real;
    this.img = img;
  }
  if (Class3)
    ComplexNumber2.__proto__ = Class3;
  ComplexNumber2.prototype = Object.create(Class3 && Class3.prototype);
  ComplexNumber2.prototype.constructor = ComplexNumber2;
  ComplexNumber2.prototype.add = function add3(cNumber) {
    return new ComplexNumber2(round$2(this.real + cNumber.real, PRECISION), round$2(this.img + cNumber.img, PRECISION));
  };
  ComplexNumber2.prototype.addConstant = function addConstant(value2) {
    return new ComplexNumber2(this.real + value2, this.img);
  };
  ComplexNumber2.prototype.negate = function negate() {
    return new ComplexNumber2(-this.real, -this.img);
  };
  ComplexNumber2.prototype.multiply = function multiply2(cNumber) {
    return new ComplexNumber2(
      this.real * cNumber.real - this.img * cNumber.img,
      this.real * cNumber.img + this.img * cNumber.real
    );
  };
  ComplexNumber2.prototype.multiplyConstant = function multiplyConstant(value2) {
    return new ComplexNumber2(this.real * value2, this.img * value2);
  };
  ComplexNumber2.prototype.nthRoot = function nthRoot(n10) {
    var rad2 = Math.atan2(this.img, this.real);
    var r12 = Math.sqrt(Math.pow(this.img, 2) + Math.pow(this.real, 2));
    var nthR = Math.pow(r12, 1 / n10);
    return new ComplexNumber2(nthR * Math.cos(rad2 / n10), nthR * Math.sin(rad2 / n10));
  };
  ComplexNumber2.prototype.equals = function equals(cNumber) {
    return this.real === cNumber.real && this.img === cNumber.img;
  };
  ComplexNumber2.prototype.isReal = function isReal() {
    return this.img === 0;
  };
  return ComplexNumber2;
}(Class$1);
const ComplexNumber$1 = ComplexNumber;
function numberSign$2(x3) {
  return x3 < 0 ? -1 : 1;
}
function solveQuadraticEquation(a9, b2, c6) {
  var squareRoot = Math.sqrt(Math.pow(b2, 2) - 4 * a9 * c6);
  return [
    (-b2 + squareRoot) / (2 * a9),
    (-b2 - squareRoot) / (2 * a9)
  ];
}
function solveCubicEquation(a9, b2, c6, d8) {
  if (a9 === 0) {
    return solveQuadraticEquation(b2, c6, d8);
  }
  var p6 = (3 * a9 * c6 - Math.pow(b2, 2)) / (3 * Math.pow(a9, 2));
  var q2 = (2 * Math.pow(b2, 3) - 9 * a9 * b2 * c6 + 27 * Math.pow(a9, 2) * d8) / (27 * Math.pow(a9, 3));
  var Q2 = Math.pow(p6 / 3, 3) + Math.pow(q2 / 2, 2);
  var i16 = new ComplexNumber$1(0, 1);
  var b3a = -b2 / (3 * a9);
  var x1, x22, y1, y22, y32, z1, z22;
  if (Q2 < 0) {
    x1 = new ComplexNumber$1(-q2 / 2, Math.sqrt(-Q2)).nthRoot(3);
    x22 = new ComplexNumber$1(-q2 / 2, -Math.sqrt(-Q2)).nthRoot(3);
  } else {
    x1 = -q2 / 2 + Math.sqrt(Q2);
    x1 = new ComplexNumber$1(numberSign$2(x1) * Math.pow(Math.abs(x1), 1 / 3));
    x22 = -q2 / 2 - Math.sqrt(Q2);
    x22 = new ComplexNumber$1(numberSign$2(x22) * Math.pow(Math.abs(x22), 1 / 3));
  }
  y1 = x1.add(x22);
  z1 = x1.add(x22).multiplyConstant(-1 / 2);
  z22 = x1.add(x22.negate()).multiplyConstant(Math.sqrt(3) / 2);
  y22 = z1.add(i16.multiply(z22));
  y32 = z1.add(i16.negate().multiply(z22));
  var result = [];
  if (y1.isReal()) {
    result.push(round$2(y1.real + b3a, PRECISION));
  }
  if (y22.isReal()) {
    result.push(round$2(y22.real + b3a, PRECISION));
  }
  if (y32.isReal()) {
    result.push(round$2(y32.real + b3a, PRECISION));
  }
  return result;
}
function hasRootsInRange(points2, point2, field, rootField, range) {
  var polynomial = toCubicPolynomial(points2, rootField);
  var roots = solveCubicEquation(polynomial[0], polynomial[1], polynomial[2], polynomial[3] - point2[rootField]);
  var intersection2;
  for (var idx = 0; idx < roots.length; idx++) {
    if (0 <= roots[idx] && roots[idx] <= 1) {
      intersection2 = calculateCurveAt(roots[idx], field, points2);
      if (Math.abs(intersection2 - point2[field]) <= range) {
        return true;
      }
    }
  }
}
function curveIntersectionsCount(points2, point2, bbox) {
  var polynomial = toCubicPolynomial(points2, "x");
  var roots = solveCubicEquation(polynomial[0], polynomial[1], polynomial[2], polynomial[3] - point2.x);
  var rayIntersection, intersectsRay;
  var count = 0;
  for (var i16 = 0; i16 < roots.length; i16++) {
    rayIntersection = calculateCurveAt(roots[i16], "y", points2);
    intersectsRay = close(rayIntersection, point2.y) || rayIntersection > point2.y;
    if (intersectsRay && ((roots[i16] === 0 || roots[i16] === 1) && bbox.bottomRight().x > point2.x || 0 < roots[i16] && roots[i16] < 1)) {
      count++;
    }
  }
  return count;
}
function lineIntersectionsCount(a9, b2, point2) {
  var intersects;
  if (a9.x !== b2.x) {
    var minX = Math.min(a9.x, b2.x);
    var maxX = Math.max(a9.x, b2.x);
    var minY = Math.min(a9.y, b2.y);
    var maxY = Math.max(a9.y, b2.y);
    var inRange = minX <= point2.x && point2.x < maxX;
    if (minY === maxY) {
      intersects = point2.y <= minY && inRange;
    } else {
      intersects = inRange && (maxY - minY) * ((a9.x - b2.x) * (a9.y - b2.y) > 0 ? point2.x - minX : maxX - point2.x) / (maxX - minX) + minY - point2.y >= 0;
    }
  }
  return intersects ? 1 : 0;
}
function pointAccessor(name2) {
  var fieldName = "_" + name2;
  return function(value2) {
    if (defined$1(value2)) {
      this._observerField(fieldName, Point$7.create(value2));
      this.geometryChange();
      return this;
    }
    return this[fieldName];
  };
}
function definePointAccessors(fn, names) {
  for (var i16 = 0; i16 < names.length; i16++) {
    fn[names[i16]] = pointAccessor(names[i16]);
  }
}
var withPoints = function(TBase, names) {
  var result = function(TBase2) {
    function result2() {
      TBase2.apply(this, arguments);
    }
    if (TBase2)
      result2.__proto__ = TBase2;
    result2.prototype = Object.create(TBase2 && TBase2.prototype);
    result2.prototype.constructor = result2;
    return result2;
  }(TBase);
  definePointAccessors(result.prototype, names);
  return result;
};
const withPoints$1 = withPoints;
var points$1 = ["anchor", "controlIn", "controlOut"];
var Segment = function(superclass) {
  function Segment2(anchor, controlIn, controlOut) {
    superclass.call(this);
    this.anchor(anchor || new Point$7());
    this.controlIn(controlIn);
    this.controlOut(controlOut);
  }
  if (superclass)
    Segment2.__proto__ = superclass;
  Segment2.prototype = Object.create(superclass && superclass.prototype);
  Segment2.prototype.constructor = Segment2;
  Segment2.prototype.bboxTo = function bboxTo(toSegment, matrix) {
    var segmentAnchor = this.anchor().transformCopy(matrix);
    var toSegmentAnchor = toSegment.anchor().transformCopy(matrix);
    var rect;
    if (this.controlOut() && toSegment.controlIn()) {
      rect = this._curveBoundingBox(
        segmentAnchor,
        this.controlOut().transformCopy(matrix),
        toSegment.controlIn().transformCopy(matrix),
        toSegmentAnchor
      );
    } else {
      rect = this._lineBoundingBox(segmentAnchor, toSegmentAnchor);
    }
    return rect;
  };
  Segment2.prototype._lineBoundingBox = function _lineBoundingBox(p1, p22) {
    return Rect$1.fromPoints(p1, p22);
  };
  Segment2.prototype._curveBoundingBox = function _curveBoundingBox(p1, cp1, cp2, p22) {
    var points2 = [p1, cp1, cp2, p22];
    var extremesX = this._curveExtremesFor(points2, "x");
    var extremesY = this._curveExtremesFor(points2, "y");
    var xLimits = arrayLimits([extremesX.min, extremesX.max, p1.x, p22.x]);
    var yLimits = arrayLimits([extremesY.min, extremesY.max, p1.y, p22.y]);
    return Rect$1.fromPoints(new Point$7(xLimits.min, yLimits.min), new Point$7(xLimits.max, yLimits.max));
  };
  Segment2.prototype._curveExtremesFor = function _curveExtremesFor(points2, field) {
    var extremes = this._curveExtremes(
      points2[0][field],
      points2[1][field],
      points2[2][field],
      points2[3][field]
    );
    return {
      min: calculateCurveAt(extremes.min, field, points2),
      max: calculateCurveAt(extremes.max, field, points2)
    };
  };
  Segment2.prototype._curveExtremes = function _curveExtremes(x1, x22, x3, x4) {
    var a9 = x1 - 3 * x22 + 3 * x3 - x4;
    var b2 = -2 * (x1 - 2 * x22 + x3);
    var c6 = x1 - x22;
    var sqrt = Math.sqrt(b2 * b2 - 4 * a9 * c6);
    var t1 = 0;
    var t22 = 1;
    if (a9 === 0) {
      if (b2 !== 0) {
        t1 = t22 = -c6 / b2;
      }
    } else if (!isNaN(sqrt)) {
      t1 = (-b2 + sqrt) / (2 * a9);
      t22 = (-b2 - sqrt) / (2 * a9);
    }
    var min2 = Math.max(Math.min(t1, t22), 0);
    if (min2 < 0 || min2 > 1) {
      min2 = 0;
    }
    var max2 = Math.min(Math.max(t1, t22), 1);
    if (max2 > 1 || max2 < 0) {
      max2 = 1;
    }
    return {
      min: min2,
      max: max2
    };
  };
  Segment2.prototype._intersectionsTo = function _intersectionsTo(segment, point2) {
    var intersectionsCount;
    if (this.controlOut() && segment.controlIn()) {
      intersectionsCount = curveIntersectionsCount([this.anchor(), this.controlOut(), segment.controlIn(), segment.anchor()], point2, this.bboxTo(segment));
    } else {
      intersectionsCount = lineIntersectionsCount(this.anchor(), segment.anchor(), point2);
    }
    return intersectionsCount;
  };
  Segment2.prototype._isOnCurveTo = function _isOnCurveTo(segment, point2, width, endSegment) {
    var bbox = this.bboxTo(segment).expand(width, width);
    if (bbox.containsPoint(point2)) {
      var p1 = this.anchor();
      var p22 = this.controlOut();
      var p32 = segment.controlIn();
      var p42 = segment.anchor();
      if (endSegment === "start" && p1.distanceTo(point2) <= width) {
        return !isOutOfEndPoint(p1, p22, point2);
      } else if (endSegment === "end" && p42.distanceTo(point2) <= width) {
        return !isOutOfEndPoint(p42, p32, point2);
      }
      var points2 = [p1, p22, p32, p42];
      if (hasRootsInRange(points2, point2, "x", "y", width) || hasRootsInRange(points2, point2, "y", "x", width)) {
        return true;
      }
      var rotation = transform().rotate(45, point2);
      var rotatedPoints = [p1.transformCopy(rotation), p22.transformCopy(rotation), p32.transformCopy(rotation), p42.transformCopy(rotation)];
      return hasRootsInRange(rotatedPoints, point2, "x", "y", width) || hasRootsInRange(rotatedPoints, point2, "y", "x", width);
    }
  };
  Segment2.prototype._isOnLineTo = function _isOnLineTo(segment, point2, width) {
    var p1 = this.anchor();
    var p22 = segment.anchor();
    var angle = deg$1(Math.atan2(p22.y - p1.y, p22.x - p1.x));
    var rect = new Rect$1([p1.x, p1.y - width / 2], [p1.distanceTo(p22), width]);
    return rect.containsPoint(point2.transformCopy(transform().rotate(-angle, p1)));
  };
  Segment2.prototype._isOnPathTo = function _isOnPathTo(segment, point2, width, endSegment) {
    var isOnPath;
    if (this.controlOut() && segment.controlIn()) {
      isOnPath = this._isOnCurveTo(segment, point2, width / 2, endSegment);
    } else {
      isOnPath = this._isOnLineTo(segment, point2, width);
    }
    return isOnPath;
  };
  return Segment2;
}(withPoints$1(HasObservers$1, points$1));
function arrayLimits(arr) {
  var length = arr.length;
  var min2 = MAX_NUM;
  var max2 = MIN_NUM;
  for (var i16 = 0; i16 < length; i16++) {
    max2 = Math.max(max2, arr[i16]);
    min2 = Math.min(min2, arr[i16]);
  }
  return {
    min: min2,
    max: max2
  };
}
const Segment$1 = Segment;
var WEIGHT$1 = 0.333;
var EXTREMUM_ALLOWED_DEVIATION$1 = 0.01;
var X$3 = "x";
var Y$6 = "y";
function pointsToCurve(pointsIn, closed) {
  var points2 = pointsIn.slice(0);
  var segments = [];
  var length = points2.length;
  if (length > 2) {
    removeDuplicates(0, points2);
    length = points2.length;
  }
  if (length < 2 || length === 2 && points2[0].equals(points2[1])) {
    return segments;
  }
  var p0 = points2[0];
  var p1 = points2[1];
  var p22 = points2[2];
  segments.push(new Segment$1(p0));
  while (p0.equals(points2[length - 1])) {
    closed = true;
    points2.pop();
    length--;
  }
  if (length === 2) {
    var tangent = getTangent(p0, p1, X$3, Y$6);
    last$1(segments).controlOut(
      firstControlPoint(tangent, p0, p1, X$3, Y$6)
    );
    segments.push(new Segment$1(
      p1,
      secondControlPoint(tangent, p0, p1, X$3, Y$6)
    ));
    return segments;
  }
  var initialControlPoint, lastControlPoint;
  if (closed) {
    p0 = points2[length - 1];
    p1 = points2[0];
    p22 = points2[1];
    var controlPoints = getControlPoints(p0, p1, p22);
    initialControlPoint = controlPoints[1];
    lastControlPoint = controlPoints[0];
  } else {
    var tangent$1 = getTangent(p0, p1, X$3, Y$6);
    initialControlPoint = firstControlPoint(tangent$1, p0, p1, X$3, Y$6);
  }
  var cp0 = initialControlPoint;
  for (var idx = 0; idx <= length - 3; idx++) {
    removeDuplicates(idx, points2);
    length = points2.length;
    if (idx + 3 <= length) {
      p0 = points2[idx];
      p1 = points2[idx + 1];
      p22 = points2[idx + 2];
      var controlPoints$1 = getControlPoints(p0, p1, p22);
      last$1(segments).controlOut(cp0);
      cp0 = controlPoints$1[1];
      var cp1 = controlPoints$1[0];
      segments.push(new Segment$1(p1, cp1));
    }
  }
  if (closed) {
    p0 = points2[length - 2];
    p1 = points2[length - 1];
    p22 = points2[0];
    var controlPoints$2 = getControlPoints(p0, p1, p22);
    last$1(segments).controlOut(cp0);
    segments.push(new Segment$1(
      p1,
      controlPoints$2[0]
    ));
    last$1(segments).controlOut(controlPoints$2[1]);
    segments.push(new Segment$1(
      p22,
      lastControlPoint
    ));
  } else {
    var tangent$2 = getTangent(p1, p22, X$3, Y$6);
    last$1(segments).controlOut(cp0);
    segments.push(new Segment$1(
      p22,
      secondControlPoint(tangent$2, p1, p22, X$3, Y$6)
    ));
  }
  return segments;
}
function removeDuplicates(idx, points2) {
  while (points2[idx + 1] && (points2[idx].equals(points2[idx + 1]) || points2[idx + 1].equals(points2[idx + 2]))) {
    points2.splice(idx + 1, 1);
  }
}
function invertAxis(p0, p1, p22) {
  var invertAxis2 = false;
  if (p0.x === p1.x) {
    invertAxis2 = true;
  } else if (p1.x === p22.x) {
    if (p1.y < p22.y && p0.y <= p1.y || p22.y < p1.y && p1.y <= p0.y) {
      invertAxis2 = true;
    }
  } else {
    var fn = lineFunction(p0, p1);
    var y22 = calculateFunction(fn, p22.x);
    if (!(p0.y <= p1.y && p22.y <= y22) && !(p1.y <= p0.y && p22.y >= y22)) {
      invertAxis2 = true;
    }
  }
  return invertAxis2;
}
function isLine(p0, p1, p22) {
  var fn = lineFunction(p0, p1);
  var y22 = calculateFunction(fn, p22.x);
  return p0.x === p1.x && p1.x === p22.x || round$2(y22, 1) === round$2(p22.y, 1);
}
function lineFunction(p1, p22) {
  var a9 = (p22.y - p1.y) / (p22.x - p1.x);
  var b2 = p1.y - a9 * p1.x;
  return [b2, a9];
}
function getControlPoints(p0, p1, p22) {
  var xField = X$3;
  var yField = Y$6;
  var restrict = false;
  var switchOrientation = false;
  var tangent;
  if (isLine(p0, p1, p22)) {
    tangent = getTangent(p0, p1, X$3, Y$6);
  } else {
    var monotonic = {
      x: isMonotonicByField(p0, p1, p22, X$3),
      y: isMonotonicByField(p0, p1, p22, Y$6)
    };
    if (monotonic.x && monotonic.y) {
      tangent = getTangent(p0, p22, X$3, Y$6);
      restrict = true;
    } else {
      if (invertAxis(p0, p1, p22)) {
        xField = Y$6;
        yField = X$3;
      }
      if (monotonic[xField]) {
        tangent = 0;
      } else {
        var sign;
        if (p22[yField] < p0[yField] && p0[yField] <= p1[yField] || p0[yField] < p22[yField] && p1[yField] <= p0[yField]) {
          sign = numberSign$1((p22[yField] - p0[yField]) * (p1[xField] - p0[xField]));
        } else {
          sign = -numberSign$1((p22[xField] - p0[xField]) * (p1[yField] - p0[yField]));
        }
        tangent = EXTREMUM_ALLOWED_DEVIATION$1 * sign;
        switchOrientation = true;
      }
    }
  }
  var secondCP = secondControlPoint(tangent, p0, p1, xField, yField);
  if (switchOrientation) {
    var oldXField = xField;
    xField = yField;
    yField = oldXField;
  }
  var firstCP = firstControlPoint(tangent, p1, p22, xField, yField);
  if (restrict) {
    restrictControlPoint(p0, p1, secondCP, tangent);
    restrictControlPoint(p1, p22, firstCP, tangent);
  }
  return [secondCP, firstCP];
}
function restrictControlPoint(p1, p22, cp, tangent) {
  if (p1.y < p22.y) {
    if (p22.y < cp.y) {
      cp.x = p1.x + (p22.y - p1.y) / tangent;
      cp.y = p22.y;
    } else if (cp.y < p1.y) {
      cp.x = p22.x - (p22.y - p1.y) / tangent;
      cp.y = p1.y;
    }
  } else {
    if (cp.y < p22.y) {
      cp.x = p1.x - (p1.y - p22.y) / tangent;
      cp.y = p22.y;
    } else if (p1.y < cp.y) {
      cp.x = p22.x + (p1.y - p22.y) / tangent;
      cp.y = p1.y;
    }
  }
}
function getTangent(p0, p1, xField, yField) {
  var x3 = p1[xField] - p0[xField];
  var y4 = p1[yField] - p0[yField];
  var tangent;
  if (x3 === 0) {
    tangent = 0;
  } else {
    tangent = y4 / x3;
  }
  return tangent;
}
function isMonotonicByField(p0, p1, p22, field) {
  return p22[field] > p1[field] && p1[field] > p0[field] || p22[field] < p1[field] && p1[field] < p0[field];
}
function firstControlPoint(tangent, p0, p32, xField, yField) {
  var t1 = p0[xField];
  var t22 = p32[xField];
  var distance = (t22 - t1) * WEIGHT$1;
  return point(t1 + distance, p0[yField] + distance * tangent, xField, yField);
}
function secondControlPoint(tangent, p0, p32, xField, yField) {
  var t1 = p0[xField];
  var t22 = p32[xField];
  var distance = (t22 - t1) * WEIGHT$1;
  return point(t22 - distance, p32[yField] - distance * tangent, xField, yField);
}
function point(xValue, yValue, xField, yField) {
  var controlPoint = new Point$7();
  controlPoint[xField] = xValue;
  controlPoint[yField] = yValue;
  return controlPoint;
}
function calculateFunction(fn, x3) {
  var length = fn.length;
  var result = 0;
  for (var i16 = 0; i16 < length; i16++) {
    result += Math.pow(x3, i16) * fn[i16];
  }
  return result;
}
function numberSign$1(value2) {
  return value2 <= 0 ? -1 : 1;
}
var ShapeMap = {
  l: function(path, options2) {
    var parameters = options2.parameters;
    var position2 = options2.position;
    for (var i16 = 0; i16 < parameters.length; i16 += 2) {
      var point2 = new Point$7(parameters[i16], parameters[i16 + 1]);
      if (options2.isRelative) {
        point2.translateWith(position2);
      }
      path.lineTo(point2.x, point2.y);
      position2.x = point2.x;
      position2.y = point2.y;
    }
  },
  c: function(path, options2) {
    var parameters = options2.parameters;
    var position2 = options2.position;
    for (var i16 = 0; i16 < parameters.length; i16 += 6) {
      var controlOut = new Point$7(parameters[i16], parameters[i16 + 1]);
      var controlIn = new Point$7(parameters[i16 + 2], parameters[i16 + 3]);
      var point2 = new Point$7(parameters[i16 + 4], parameters[i16 + 5]);
      if (options2.isRelative) {
        controlIn.translateWith(position2);
        controlOut.translateWith(position2);
        point2.translateWith(position2);
      }
      path.curveTo(controlOut, controlIn, point2);
      position2.x = point2.x;
      position2.y = point2.y;
    }
  },
  v: function(path, options2) {
    var value2 = options2.isRelative ? 0 : options2.position.x;
    toLineParamaters(options2.parameters, true, value2);
    this.l(path, options2);
  },
  h: function(path, options2) {
    var value2 = options2.isRelative ? 0 : options2.position.y;
    toLineParamaters(options2.parameters, false, value2);
    this.l(path, options2);
  },
  a: function(path, options2) {
    var parameters = options2.parameters;
    var position2 = options2.position;
    for (var i16 = 0; i16 < parameters.length; i16 += 7) {
      var radiusX = parameters[i16];
      var radiusY = parameters[i16 + 1];
      var rotation = parameters[i16 + 2];
      var largeArc = parameters[i16 + 3];
      var swipe = parameters[i16 + 4];
      var endPoint = new Point$7(parameters[i16 + 5], parameters[i16 + 6]);
      if (options2.isRelative) {
        endPoint.translateWith(position2);
      }
      if (position2.x !== endPoint.x || position2.y !== endPoint.y) {
        path.arcTo(endPoint, radiusX, radiusY, largeArc, swipe, rotation);
        position2.x = endPoint.x;
        position2.y = endPoint.y;
      }
    }
  },
  s: function(path, options2) {
    var parameters = options2.parameters;
    var position2 = options2.position;
    var previousCommand = options2.previousCommand;
    var lastControlIn;
    if (previousCommand === "s" || previousCommand === "c") {
      lastControlIn = last$1(last$1(path.paths).segments).controlIn();
    }
    for (var i16 = 0; i16 < parameters.length; i16 += 4) {
      var controlIn = new Point$7(parameters[i16], parameters[i16 + 1]);
      var endPoint = new Point$7(parameters[i16 + 2], parameters[i16 + 3]);
      var controlOut = void 0;
      if (options2.isRelative) {
        controlIn.translateWith(position2);
        endPoint.translateWith(position2);
      }
      if (lastControlIn) {
        controlOut = reflectionPoint(lastControlIn, position2);
      } else {
        controlOut = position2.clone();
      }
      lastControlIn = controlIn;
      path.curveTo(controlOut, controlIn, endPoint);
      position2.x = endPoint.x;
      position2.y = endPoint.y;
    }
  },
  q: function(path, options2) {
    var parameters = options2.parameters;
    var position2 = options2.position;
    for (var i16 = 0; i16 < parameters.length; i16 += 4) {
      var controlPoint = new Point$7(parameters[i16], parameters[i16 + 1]);
      var endPoint = new Point$7(parameters[i16 + 2], parameters[i16 + 3]);
      if (options2.isRelative) {
        controlPoint.translateWith(position2);
        endPoint.translateWith(position2);
      }
      var cubicControlPoints = quadraticToCubicControlPoints(position2, controlPoint, endPoint);
      path.curveTo(cubicControlPoints.controlOut, cubicControlPoints.controlIn, endPoint);
      position2.x = endPoint.x;
      position2.y = endPoint.y;
    }
  },
  t: function(path, options2) {
    var parameters = options2.parameters;
    var position2 = options2.position;
    var previousCommand = options2.previousCommand;
    var controlPoint;
    if (previousCommand === "q" || previousCommand === "t") {
      var lastSegment = last$1(last$1(path.paths).segments);
      controlPoint = lastSegment.controlIn().clone().translateWith(position2.scaleCopy(-1 / 3)).scale(3 / 2);
    }
    for (var i16 = 0; i16 < parameters.length; i16 += 2) {
      var endPoint = new Point$7(parameters[i16], parameters[i16 + 1]);
      if (options2.isRelative) {
        endPoint.translateWith(position2);
      }
      if (controlPoint) {
        controlPoint = reflectionPoint(controlPoint, position2);
      } else {
        controlPoint = position2.clone();
      }
      var cubicControlPoints = quadraticToCubicControlPoints(position2, controlPoint, endPoint);
      path.curveTo(cubicControlPoints.controlOut, cubicControlPoints.controlIn, endPoint);
      position2.x = endPoint.x;
      position2.y = endPoint.y;
    }
  }
};
function toLineParamaters(parameters, isVertical, value2) {
  var insertPosition = isVertical ? 0 : 1;
  for (var i16 = 0; i16 < parameters.length; i16 += 2) {
    parameters.splice(i16 + insertPosition, 0, value2);
  }
}
function reflectionPoint(point2, center) {
  if (point2 && center) {
    return center.scaleCopy(2).translate(-point2.x, -point2.y);
  }
}
var third = 1 / 3;
function quadraticToCubicControlPoints(position2, controlPoint, endPoint) {
  var scaledPoint = controlPoint.clone().scale(2 / 3);
  return {
    controlOut: scaledPoint.clone().translateWith(position2.scaleCopy(third)),
    controlIn: scaledPoint.translateWith(endPoint.scaleCopy(third))
  };
}
const ShapeMap$1 = ShapeMap;
var SEGMENT_REGEX = /([a-df-z]{1})([^a-df-z]*)(z)?/gi;
var SPLIT_REGEX = /[,\s]?([+\-]?(?:\d*\.\d+|\d+)(?:[eE][+\-]?\d+)?)/g;
var MOVE$1 = "m";
var CLOSE = "z";
function parseParameters(str) {
  var parameters = [];
  str.replace(SPLIT_REGEX, function(match2, number) {
    parameters.push(parseFloat(number));
  });
  return parameters;
}
function parsePath(pathInstance, str) {
  var position2 = new Point$7();
  var previousCommand;
  str.replace(SEGMENT_REGEX, function(match2, element, params, closePath) {
    var command = element.toLowerCase();
    var isRelative = command === element;
    var parameters = parseParameters(params.trim());
    if (command === MOVE$1) {
      if (isRelative) {
        position2.x += parameters[0];
        position2.y += parameters[1];
      } else {
        position2.x = parameters[0];
        position2.y = parameters[1];
      }
      pathInstance.moveTo(position2.x, position2.y);
      if (parameters.length > 2) {
        command = "l";
        parameters.splice(0, 2);
      }
    }
    if (ShapeMap$1[command]) {
      ShapeMap$1[command](
        pathInstance,
        {
          parameters,
          position: position2,
          isRelative,
          previousCommand
        }
      );
      if (closePath && closePath.toLowerCase() === CLOSE) {
        pathInstance.close();
      }
    } else if (command !== MOVE$1) {
      throw new Error("Error while parsing SVG path. Unsupported command: " + command);
    }
    previousCommand = command;
  });
  return pathInstance;
}
function elementsBoundingBox(elements, applyTransform, transformation) {
  var boundingBox;
  for (var i16 = 0; i16 < elements.length; i16++) {
    var element = elements[i16];
    if (element.visible()) {
      var elementBoundingBox = applyTransform ? element.bbox(transformation) : element.rawBBox();
      if (elementBoundingBox) {
        if (boundingBox) {
          boundingBox = Rect$1.union(boundingBox, elementBoundingBox);
        } else {
          boundingBox = elementBoundingBox;
        }
      }
    }
  }
  return boundingBox;
}
function elementsClippedBoundingBox(elements, transformation) {
  var boundingBox;
  for (var i16 = 0; i16 < elements.length; i16++) {
    var element = elements[i16];
    if (element.visible()) {
      var elementBoundingBox = element.clippedBBox(transformation);
      if (elementBoundingBox) {
        if (boundingBox) {
          boundingBox = Rect$1.union(boundingBox, elementBoundingBox);
        } else {
          boundingBox = elementBoundingBox;
        }
      }
    }
  }
  return boundingBox;
}
var SPACE = " ";
var printPoints = function(precision) {
  return function() {
    var points2 = [], len = arguments.length;
    while (len--)
      points2[len] = arguments[len];
    return points2.map(function(p6) {
      return p6.toString(precision);
    }).join(SPACE);
  };
};
var segmentType = function(segmentStart, segmentEnd) {
  return segmentStart.controlOut() && segmentEnd.controlIn() ? "C" : "L";
};
var Path$7 = function(superclass) {
  function Path2(options2) {
    superclass.call(this, options2);
    this.segments = new GeometryElementsArray$1();
    this.segments.addObserver(this);
    if (!defined$1(this.options.stroke)) {
      this.stroke("#000");
      if (!defined$1(this.options.stroke.lineJoin)) {
        this.options.set("stroke.lineJoin", "miter");
      }
    }
  }
  if (superclass)
    Path2.__proto__ = superclass;
  Path2.prototype = Object.create(superclass && superclass.prototype);
  Path2.prototype.constructor = Path2;
  var prototypeAccessors2 = { nodeType: { configurable: true } };
  prototypeAccessors2.nodeType.get = function() {
    return "Path";
  };
  Path2.prototype.moveTo = function moveTo(x3, y4) {
    this.suspend();
    this.segments.elements([]);
    this.resume();
    this.lineTo(x3, y4);
    return this;
  };
  Path2.prototype.lineTo = function lineTo(x3, y4) {
    var point2 = defined$1(y4) ? new Point$7(x3, y4) : x3;
    var segment = new Segment$1(point2);
    this.segments.push(segment);
    return this;
  };
  Path2.prototype.curveTo = function curveTo(controlOut, controlIn, point2) {
    if (this.segments.length > 0) {
      var lastSegment = last$1(this.segments);
      var segment = new Segment$1(point2, controlIn);
      this.suspend();
      lastSegment.controlOut(controlOut);
      this.resume();
      this.segments.push(segment);
    }
    return this;
  };
  Path2.prototype.arc = function arc(startAngle, endAngle, radiusX, radiusY, anticlockwise) {
    if (this.segments.length > 0) {
      var lastSegment = last$1(this.segments);
      var anchor = lastSegment.anchor();
      var start = rad$1(startAngle);
      var center = new Point$7(
        anchor.x - radiusX * Math.cos(start),
        anchor.y - radiusY * Math.sin(start)
      );
      var arc2 = new GeometryArc(center, {
        startAngle,
        endAngle,
        radiusX,
        radiusY,
        anticlockwise
      });
      this._addArcSegments(arc2);
    }
    return this;
  };
  Path2.prototype.arcTo = function arcTo(end, rx, ry, largeArc, swipe, rotation) {
    if (this.segments.length > 0) {
      var lastSegment = last$1(this.segments);
      var anchor = lastSegment.anchor();
      var arc = GeometryArc.fromPoints(anchor, Point$7.create(end), rx, ry, largeArc, swipe, rotation);
      this._addArcSegments(arc);
    }
    return this;
  };
  Path2.prototype._addArcSegments = function _addArcSegments(arc) {
    var this$1$1 = this;
    this.suspend();
    var curvePoints = arc.curvePoints();
    for (var i16 = 1; i16 < curvePoints.length; i16 += 3) {
      this$1$1.curveTo(curvePoints[i16], curvePoints[i16 + 1], curvePoints[i16 + 2]);
    }
    this.resume();
    this.geometryChange();
  };
  Path2.prototype.close = function close2() {
    this.options.closed = true;
    this.geometryChange();
    return this;
  };
  Path2.prototype.rawBBox = function rawBBox() {
    return this._bbox();
  };
  Path2.prototype.toString = function toString2(digits) {
    var output = "";
    var segments = this.segments;
    var length = segments.length;
    if (length > 0) {
      var parts = [];
      var print = printPoints(digits);
      var currentType;
      for (var i16 = 1; i16 < length; i16++) {
        var type = segmentType(segments[i16 - 1], segments[i16]);
        if (type !== currentType) {
          currentType = type;
          parts.push(type);
        }
        if (type === "L") {
          parts.push(print(segments[i16].anchor()));
        } else {
          parts.push(print(
            segments[i16 - 1].controlOut(),
            segments[i16].controlIn(),
            segments[i16].anchor()
          ));
        }
      }
      output = "M" + print(segments[0].anchor()) + SPACE + parts.join(SPACE);
      if (this.options.closed) {
        output += "Z";
      }
    }
    return output;
  };
  Path2.prototype._containsPoint = function _containsPoint(point2) {
    var segments = this.segments;
    var length = segments.length;
    var intersectionsCount = 0;
    var previous, current2;
    for (var idx = 1; idx < length; idx++) {
      previous = segments[idx - 1];
      current2 = segments[idx];
      intersectionsCount += previous._intersectionsTo(current2, point2);
    }
    if (this.options.closed || !segments[0].anchor().equals(segments[length - 1].anchor())) {
      intersectionsCount += lineIntersectionsCount(segments[0].anchor(), segments[length - 1].anchor(), point2);
    }
    return intersectionsCount % 2 !== 0;
  };
  Path2.prototype._isOnPath = function _isOnPath(point2, width) {
    var segments = this.segments;
    var length = segments.length;
    var pathWidth = width || this.options.stroke.width;
    if (length > 1) {
      if (segments[0]._isOnPathTo(segments[1], point2, pathWidth, "start")) {
        return true;
      }
      for (var idx = 2; idx <= length - 2; idx++) {
        if (segments[idx - 1]._isOnPathTo(segments[idx], point2, pathWidth)) {
          return true;
        }
      }
      if (segments[length - 2]._isOnPathTo(segments[length - 1], point2, pathWidth, "end")) {
        return true;
      }
    }
    return false;
  };
  Path2.prototype._bbox = function _bbox(matrix) {
    var segments = this.segments;
    var length = segments.length;
    var boundingBox;
    if (length === 1) {
      var anchor = segments[0].anchor().transformCopy(matrix);
      boundingBox = new Rect$1(anchor, Size$1.ZERO);
    } else if (length > 0) {
      for (var i16 = 1; i16 < length; i16++) {
        var segmentBox = segments[i16 - 1].bboxTo(segments[i16], matrix);
        if (boundingBox) {
          boundingBox = Rect$1.union(boundingBox, segmentBox);
        } else {
          boundingBox = segmentBox;
        }
      }
    }
    return boundingBox;
  };
  Path2.parse = function parse(str, options2) {
    return MultiPath.parse(str, options2);
  };
  Path2.fromRect = function fromRect(rect, options2) {
    var path = new Path2(options2);
    var ref2 = rect.cornerRadius;
    var rx = ref2[0];
    var ry = ref2[1];
    if (rx === 0 && ry === 0) {
      path.moveTo(rect.topLeft()).lineTo(rect.topRight()).lineTo(rect.bottomRight()).lineTo(rect.bottomLeft()).close();
    } else {
      var origin = rect.origin;
      var x3 = origin.x;
      var y4 = origin.y;
      var width = rect.width();
      var height = rect.height();
      rx = limitValue$1(rx, 0, width / 2);
      ry = limitValue$1(ry, 0, height / 2);
      path.moveTo(x3 + rx, y4).lineTo(x3 + width - rx, y4).arcTo([x3 + width, y4 + ry], rx, ry, false).lineTo(x3 + width, y4 + height - ry).arcTo([x3 + width - rx, y4 + height], rx, ry, false).lineTo(x3 + rx, y4 + height).arcTo([x3, y4 + height - ry], rx, ry, false).lineTo(x3, y4 + ry).arcTo([x3 + rx, y4], rx, ry, false);
    }
    return path;
  };
  Path2.fromPoints = function fromPoints(points2, options2) {
    if (points2) {
      var path = new Path2(options2);
      for (var i16 = 0; i16 < points2.length; i16++) {
        var point2 = Point$7.create(points2[i16]);
        if (point2) {
          if (i16 === 0) {
            path.moveTo(point2);
          } else {
            path.lineTo(point2);
          }
        }
      }
      return path;
    }
  };
  Path2.curveFromPoints = function curveFromPoints(points2, options2) {
    if (points2) {
      var segments = pointsToCurve(points2);
      var path = new Path2(options2);
      path.segments.push.apply(path.segments, segments);
      return path;
    }
  };
  Path2.fromArc = function fromArc(arc, options2) {
    var path = new Path2(options2);
    var startAngle = arc.startAngle;
    var start = arc.pointAt(startAngle);
    path.moveTo(start.x, start.y);
    path.arc(startAngle, arc.endAngle, arc.radiusX, arc.radiusY, arc.anticlockwise);
    return path;
  };
  Object.defineProperties(Path2.prototype, prototypeAccessors2);
  return Path2;
}(paintable$1(measurable$1(Element$2)));
var MultiPath = function(superclass) {
  function MultiPath2(options2) {
    superclass.call(this, options2);
    this.paths = new GeometryElementsArray$1();
    this.paths.addObserver(this);
    if (!defined$1(this.options.stroke)) {
      this.stroke("#000");
    }
  }
  if (superclass)
    MultiPath2.__proto__ = superclass;
  MultiPath2.prototype = Object.create(superclass && superclass.prototype);
  MultiPath2.prototype.constructor = MultiPath2;
  var prototypeAccessors$12 = { nodeType: { configurable: true } };
  MultiPath2.parse = function parse(str, options2) {
    var instance2 = new MultiPath2(options2);
    return parsePath(instance2, str);
  };
  MultiPath2.prototype.toString = function toString2(digits) {
    var paths = this.paths;
    var output = "";
    if (paths.length > 0) {
      var result = [];
      for (var i16 = 0; i16 < paths.length; i16++) {
        result.push(paths[i16].toString(digits));
      }
      output = result.join(SPACE);
    }
    return output;
  };
  prototypeAccessors$12.nodeType.get = function() {
    return "MultiPath";
  };
  MultiPath2.prototype.moveTo = function moveTo(x3, y4) {
    var path = new Path$7();
    path.moveTo(x3, y4);
    this.paths.push(path);
    return this;
  };
  MultiPath2.prototype.lineTo = function lineTo(x3, y4) {
    if (this.paths.length > 0) {
      last$1(this.paths).lineTo(x3, y4);
    }
    return this;
  };
  MultiPath2.prototype.curveTo = function curveTo(controlOut, controlIn, point2) {
    if (this.paths.length > 0) {
      last$1(this.paths).curveTo(controlOut, controlIn, point2);
    }
    return this;
  };
  MultiPath2.prototype.arc = function arc(startAngle, endAngle, radiusX, radiusY, anticlockwise) {
    if (this.paths.length > 0) {
      last$1(this.paths).arc(startAngle, endAngle, radiusX, radiusY, anticlockwise);
    }
    return this;
  };
  MultiPath2.prototype.arcTo = function arcTo(end, rx, ry, largeArc, swipe, rotation) {
    if (this.paths.length > 0) {
      last$1(this.paths).arcTo(end, rx, ry, largeArc, swipe, rotation);
    }
    return this;
  };
  MultiPath2.prototype.close = function close2() {
    if (this.paths.length > 0) {
      last$1(this.paths).close();
    }
    return this;
  };
  MultiPath2.prototype._bbox = function _bbox(matrix) {
    return elementsBoundingBox(this.paths, true, matrix);
  };
  MultiPath2.prototype.rawBBox = function rawBBox() {
    return elementsBoundingBox(this.paths, false);
  };
  MultiPath2.prototype._containsPoint = function _containsPoint(point2) {
    var paths = this.paths;
    for (var idx = 0; idx < paths.length; idx++) {
      if (paths[idx]._containsPoint(point2)) {
        return true;
      }
    }
    return false;
  };
  MultiPath2.prototype._isOnPath = function _isOnPath(point2) {
    var paths = this.paths;
    var width = this.options.stroke.width;
    for (var idx = 0; idx < paths.length; idx++) {
      if (paths[idx]._isOnPath(point2, width)) {
        return true;
      }
    }
    return false;
  };
  MultiPath2.prototype._clippedBBox = function _clippedBBox(transformation) {
    return elementsClippedBoundingBox(this.paths, this.currentTransform(transformation));
  };
  Object.defineProperties(MultiPath2.prototype, prototypeAccessors$12);
  return MultiPath2;
}(paintable$1(measurable$1(Element$2)));
var DEFAULT_STROKE = "#000";
var Arc$1 = function(superclass) {
  function Arc2(geometry, options2) {
    if (geometry === void 0)
      geometry = new GeometryArc();
    if (options2 === void 0)
      options2 = {};
    superclass.call(this, options2);
    this.geometry(geometry);
    if (!defined$1(this.options.stroke)) {
      this.stroke(DEFAULT_STROKE);
    }
  }
  if (superclass)
    Arc2.__proto__ = superclass;
  Arc2.prototype = Object.create(superclass && superclass.prototype);
  Arc2.prototype.constructor = Arc2;
  var prototypeAccessors2 = { nodeType: { configurable: true } };
  prototypeAccessors2.nodeType.get = function() {
    return "Arc";
  };
  Arc2.prototype._bbox = function _bbox(matrix) {
    return this._geometry.bbox(matrix);
  };
  Arc2.prototype.rawBBox = function rawBBox() {
    return this.geometry().bbox();
  };
  Arc2.prototype.toPath = function toPath() {
    var path = new Path$7();
    var curvePoints = this.geometry().curvePoints();
    if (curvePoints.length > 0) {
      path.moveTo(curvePoints[0].x, curvePoints[0].y);
      for (var i16 = 1; i16 < curvePoints.length; i16 += 3) {
        path.curveTo(curvePoints[i16], curvePoints[i16 + 1], curvePoints[i16 + 2]);
      }
    }
    return path;
  };
  Arc2.prototype._containsPoint = function _containsPoint(point2) {
    return this.geometry().containsPoint(point2);
  };
  Arc2.prototype._isOnPath = function _isOnPath(point2) {
    return this.geometry()._isOnPath(point2, this.options.stroke.width / 2);
  };
  Object.defineProperties(Arc2.prototype, prototypeAccessors2);
  return Arc2;
}(paintable$1(measurable$1(withGeometry$1(Element$2))));
const Arc$2 = Arc$1;
var DEFAULT_FONT = "12px sans-serif";
var DEFAULT_FILL = "#000";
var Text$3 = function(superclass) {
  function Text2(content, position2, options2) {
    if (position2 === void 0)
      position2 = new Point$7();
    if (options2 === void 0)
      options2 = {};
    superclass.call(this, options2);
    this.content(content);
    this.position(position2);
    if (!this.options.font) {
      this.options.font = DEFAULT_FONT;
    }
    if (!defined$1(this.options.fill)) {
      this.fill(DEFAULT_FILL);
    }
  }
  if (superclass)
    Text2.__proto__ = superclass;
  Text2.prototype = Object.create(superclass && superclass.prototype);
  Text2.prototype.constructor = Text2;
  var prototypeAccessors2 = { nodeType: { configurable: true } };
  prototypeAccessors2.nodeType.get = function() {
    return "Text";
  };
  Text2.prototype.content = function content(value2) {
    if (defined$1(value2)) {
      this.options.set("content", value2);
      return this;
    }
    return this.options.get("content");
  };
  Text2.prototype.measure = function measure() {
    var metrics = measureText(this.content(), {
      font: this.options.get("font")
    });
    return metrics;
  };
  Text2.prototype.rect = function rect() {
    var size = this.measure();
    var pos = this.position().clone();
    return new Rect$1(pos, [size.width, size.height]);
  };
  Text2.prototype.bbox = function bbox(transformation) {
    var combinedMatrix = toMatrix(this.currentTransform(transformation));
    return this.rect().bbox(combinedMatrix);
  };
  Text2.prototype.rawBBox = function rawBBox() {
    return this.rect().bbox();
  };
  Text2.prototype._containsPoint = function _containsPoint(point2) {
    return this.rect().containsPoint(point2);
  };
  Object.defineProperties(Text2.prototype, prototypeAccessors2);
  return Text2;
}(paintable$1(withPoints$1(Element$2, ["position"])));
const Text$4 = Text$3;
var Image$2 = function(superclass) {
  function Image2(src, rect, options2) {
    if (rect === void 0)
      rect = new Rect$1();
    if (options2 === void 0)
      options2 = {};
    superclass.call(this, options2);
    this.src(src);
    this.rect(rect);
  }
  if (superclass)
    Image2.__proto__ = superclass;
  Image2.prototype = Object.create(superclass && superclass.prototype);
  Image2.prototype.constructor = Image2;
  var prototypeAccessors2 = { nodeType: { configurable: true } };
  prototypeAccessors2.nodeType.get = function() {
    return "Image";
  };
  Image2.prototype.src = function src(value2) {
    if (defined$1(value2)) {
      this.options.set("src", value2);
      return this;
    }
    return this.options.get("src");
  };
  Image2.prototype.bbox = function bbox(transformation) {
    var combinedMatrix = toMatrix(this.currentTransform(transformation));
    return this._rect.bbox(combinedMatrix);
  };
  Image2.prototype.rawBBox = function rawBBox() {
    return this._rect.bbox();
  };
  Image2.prototype._containsPoint = function _containsPoint(point2) {
    return this._rect.containsPoint(point2);
  };
  Image2.prototype._hasFill = function _hasFill() {
    return this.src();
  };
  Object.defineProperties(Image2.prototype, prototypeAccessors2);
  return Image2;
}(withGeometry$1(Element$2, ["rect"]));
const Image$3 = Image$2;
var traversable = function(TBase, childrenField) {
  return function(TBase2) {
    function anonymous() {
      TBase2.apply(this, arguments);
    }
    if (TBase2)
      anonymous.__proto__ = TBase2;
    anonymous.prototype = Object.create(TBase2 && TBase2.prototype);
    anonymous.prototype.constructor = anonymous;
    anonymous.prototype.traverse = function traverse(callback) {
      var children = this[childrenField];
      for (var i16 = 0; i16 < children.length; i16++) {
        var child = children[i16];
        if (child.traverse) {
          child.traverse(callback);
        } else {
          callback(child);
        }
      }
      return this;
    };
    return anonymous;
  }(TBase);
};
const traversable$1 = traversable;
var Group$8 = function(superclass) {
  function Group2(options2) {
    superclass.call(this, options2);
    this.children = [];
  }
  if (superclass)
    Group2.__proto__ = superclass;
  Group2.prototype = Object.create(superclass && superclass.prototype);
  Group2.prototype.constructor = Group2;
  var prototypeAccessors2 = { nodeType: { configurable: true } };
  prototypeAccessors2.nodeType.get = function() {
    return "Group";
  };
  Group2.prototype.childrenChange = function childrenChange(action, items, index2) {
    this.trigger("childrenChange", {
      action,
      items,
      index: index2
    });
  };
  Group2.prototype.append = function append$1$1() {
    append$1(this.children, arguments);
    this._reparent(arguments, this);
    this.childrenChange("add", arguments);
    return this;
  };
  Group2.prototype.insert = function insert(index2, element) {
    this.children.splice(index2, 0, element);
    element.parent = this;
    this.childrenChange("add", [element], index2);
    return this;
  };
  Group2.prototype.insertAt = function insertAt(element, index2) {
    return this.insert(index2, element);
  };
  Group2.prototype.remove = function remove(element) {
    var index2 = this.children.indexOf(element);
    if (index2 >= 0) {
      this.children.splice(index2, 1);
      element.parent = null;
      this.childrenChange("remove", [element], index2);
    }
    return this;
  };
  Group2.prototype.removeAt = function removeAt(index2) {
    if (0 <= index2 && index2 < this.children.length) {
      var element = this.children[index2];
      this.children.splice(index2, 1);
      element.parent = null;
      this.childrenChange("remove", [element], index2);
    }
    return this;
  };
  Group2.prototype.clear = function clear4() {
    var items = this.children;
    this.children = [];
    this._reparent(items, null);
    this.childrenChange("remove", items, 0);
    return this;
  };
  Group2.prototype.bbox = function bbox(transformation) {
    return elementsBoundingBox(this.children, true, this.currentTransform(transformation));
  };
  Group2.prototype.rawBBox = function rawBBox() {
    return elementsBoundingBox(this.children, false);
  };
  Group2.prototype._clippedBBox = function _clippedBBox(transformation) {
    return elementsClippedBoundingBox(this.children, this.currentTransform(transformation));
  };
  Group2.prototype.currentTransform = function currentTransform(transformation) {
    return Element$2.prototype.currentTransform.call(this, transformation) || null;
  };
  Group2.prototype.containsPoint = function containsPoint(point2, parentTransform) {
    if (this.visible()) {
      var children = this.children;
      var transform2 = this.currentTransform(parentTransform);
      for (var idx = 0; idx < children.length; idx++) {
        if (children[idx].containsPoint(point2, transform2)) {
          return true;
        }
      }
    }
    return false;
  };
  Group2.prototype._reparent = function _reparent(elements, newParent) {
    var this$1$1 = this;
    for (var i16 = 0; i16 < elements.length; i16++) {
      var child = elements[i16];
      var parent = child.parent;
      if (parent && parent !== this$1$1 && parent.remove) {
        parent.remove(child);
      }
      child.parent = newParent;
    }
  };
  Object.defineProperties(Group2.prototype, prototypeAccessors2);
  return Group2;
}(traversable$1(Element$2, "children"));
const Group$9 = Group$8;
function translateToPoint(point2, bbox, element) {
  var transofrm = element.transform() || transform();
  var matrix = transofrm.matrix();
  matrix.e += point2.x - bbox.origin.x;
  matrix.f += point2.y - bbox.origin.y;
  transofrm.matrix(matrix);
  element.transform(transofrm);
}
function alignStart(size, rect, align2, axis, sizeField) {
  var start;
  if (align2 === "start") {
    start = rect.origin[axis];
  } else if (align2 === "end") {
    start = rect.origin[axis] + rect.size[sizeField] - size;
  } else {
    start = rect.origin[axis] + (rect.size[sizeField] - size) / 2;
  }
  return start;
}
function alignStartReverse(size, rect, align2, axis, sizeField) {
  var start;
  if (align2 === "start") {
    start = rect.origin[axis] + rect.size[sizeField] - size;
  } else if (align2 === "end") {
    start = rect.origin[axis];
  } else {
    start = rect.origin[axis] + (rect.size[sizeField] - size) / 2;
  }
  return start;
}
var DEFAULT_OPTIONS = {
  alignContent: "start",
  justifyContent: "start",
  alignItems: "start",
  spacing: 0,
  orientation: "horizontal",
  lineSpacing: 0,
  wrap: true,
  revers: false
};
var forEach$1 = function(elements, callback) {
  elements.forEach(callback);
};
var forEachReverse$1 = function(elements, callback) {
  var length = elements.length;
  for (var idx = length - 1; idx >= 0; idx--) {
    callback(elements[idx], idx);
  }
};
var Layout = function(Group2) {
  function Layout2(rect, options2) {
    Group2.call(this, Object.assign({}, DEFAULT_OPTIONS, options2));
    this._rect = rect;
    this._fieldMap = {};
  }
  if (Group2)
    Layout2.__proto__ = Group2;
  Layout2.prototype = Object.create(Group2 && Group2.prototype);
  Layout2.prototype.constructor = Layout2;
  Layout2.prototype.rect = function rect(value2) {
    if (value2) {
      this._rect = value2;
      return this;
    }
    return this._rect;
  };
  Layout2.prototype._initMap = function _initMap() {
    var options2 = this.options;
    var fieldMap = this._fieldMap;
    if (options2.orientation === "horizontal") {
      fieldMap.sizeField = "width";
      fieldMap.groupsSizeField = "height";
      fieldMap.groupAxis = "x";
      fieldMap.groupsAxis = "y";
    } else {
      fieldMap.sizeField = "height";
      fieldMap.groupsSizeField = "width";
      fieldMap.groupAxis = "y";
      fieldMap.groupsAxis = "x";
    }
    if (options2.reverse) {
      this.forEach = forEachReverse$1;
      this.justifyAlign = alignStartReverse;
    } else {
      this.forEach = forEach$1;
      this.justifyAlign = alignStart;
    }
  };
  Layout2.prototype.reflow = function reflow() {
    var this$1$1 = this;
    if (!this._rect || this.children.length === 0) {
      return;
    }
    this._initMap();
    if (this.options.transform) {
      this.transform(null);
    }
    var options2 = this.options;
    var rect = this._rect;
    var ref2 = this._initGroups();
    var groups = ref2.groups;
    var groupsSize = ref2.groupsSize;
    var ref$1 = this._fieldMap;
    var sizeField = ref$1.sizeField;
    var groupsSizeField = ref$1.groupsSizeField;
    var groupAxis = ref$1.groupAxis;
    var groupsAxis = ref$1.groupsAxis;
    var groupOrigin = new Point$7();
    var elementOrigin = new Point$7();
    var size = new Size$1();
    var groupStart = alignStart(groupsSize, rect, options2.alignContent, groupsAxis, groupsSizeField);
    var elementStart, group2, groupBox;
    var arrangeElements = function(bbox, idx) {
      var element = group2.elements[idx];
      elementOrigin[groupAxis] = elementStart;
      elementOrigin[groupsAxis] = alignStart(bbox.size[groupsSizeField], groupBox, options2.alignItems, groupsAxis, groupsSizeField);
      translateToPoint(elementOrigin, bbox, element);
      elementStart += bbox.size[sizeField] + options2.spacing;
    };
    for (var groupIdx = 0; groupIdx < groups.length; groupIdx++) {
      group2 = groups[groupIdx];
      groupOrigin[groupAxis] = elementStart = this$1$1.justifyAlign(group2.size, rect, options2.justifyContent, groupAxis, sizeField);
      groupOrigin[groupsAxis] = groupStart;
      size[sizeField] = group2.size;
      size[groupsSizeField] = group2.lineSize;
      groupBox = new Rect$1(groupOrigin, size);
      this$1$1.forEach(group2.bboxes, arrangeElements);
      groupStart += group2.lineSize + options2.lineSpacing;
    }
    if (!options2.wrap && group2.size > rect.size[sizeField]) {
      var scale = rect.size[sizeField] / groupBox.size[sizeField];
      var scaledStart = groupBox.topLeft().scale(scale, scale);
      var scaledSize = groupBox.size[groupsSizeField] * scale;
      var newStart = alignStart(scaledSize, rect, options2.alignContent, groupsAxis, groupsSizeField);
      var transform$1 = transform();
      if (groupAxis === "x") {
        transform$1.translate(rect.origin.x - scaledStart.x, newStart - scaledStart.y);
      } else {
        transform$1.translate(newStart - scaledStart.x, rect.origin.y - scaledStart.y);
      }
      transform$1.scale(scale, scale);
      this.transform(transform$1);
    }
  };
  Layout2.prototype._initGroups = function _initGroups() {
    var this$1$1 = this;
    var ref2 = this;
    var options2 = ref2.options;
    var children = ref2.children;
    var lineSpacing = options2.lineSpacing;
    var wrap = options2.wrap;
    var spacing = options2.spacing;
    var sizeField = this._fieldMap.sizeField;
    var group2 = this._newGroup();
    var groups = [];
    var addGroup = function() {
      groups.push(group2);
      groupsSize += group2.lineSize + lineSpacing;
    };
    var groupsSize = -lineSpacing;
    for (var idx = 0; idx < children.length; idx++) {
      var element = children[idx];
      var bbox = children[idx].clippedBBox();
      if (element.visible() && bbox) {
        if (wrap && group2.size + bbox.size[sizeField] + spacing > this$1$1._rect.size[sizeField]) {
          if (group2.bboxes.length === 0) {
            this$1$1._addToGroup(group2, bbox, element);
            addGroup();
            group2 = this$1$1._newGroup();
          } else {
            addGroup();
            group2 = this$1$1._newGroup();
            this$1$1._addToGroup(group2, bbox, element);
          }
        } else {
          this$1$1._addToGroup(group2, bbox, element);
        }
      }
    }
    if (group2.bboxes.length) {
      addGroup();
    }
    return {
      groups,
      groupsSize
    };
  };
  Layout2.prototype._addToGroup = function _addToGroup(group2, bbox, element) {
    group2.size += bbox.size[this._fieldMap.sizeField] + this.options.spacing;
    group2.lineSize = Math.max(bbox.size[this._fieldMap.groupsSizeField], group2.lineSize);
    group2.bboxes.push(bbox);
    group2.elements.push(element);
  };
  Layout2.prototype._newGroup = function _newGroup() {
    return {
      lineSize: 0,
      size: -this.options.spacing,
      bboxes: [],
      elements: []
    };
  };
  return Layout2;
}(Group$9);
const Layout$1 = Layout;
var StopsArray = function(ElementsArray2) {
  function StopsArray2() {
    ElementsArray2.apply(this, arguments);
  }
  if (ElementsArray2)
    StopsArray2.__proto__ = ElementsArray2;
  StopsArray2.prototype = Object.create(ElementsArray2 && ElementsArray2.prototype);
  StopsArray2.prototype.constructor = StopsArray2;
  StopsArray2.prototype._change = function _change() {
    this.optionsChange({
      field: "stops"
    });
  };
  return StopsArray2;
}(ElementsArray$1);
const StopsArray$1 = StopsArray;
function optionsAccessor(name2) {
  return function(value2) {
    if (defined$1(value2)) {
      this.options.set(name2, value2);
      return this;
    }
    return this.options.get(name2);
  };
}
function defineOptionsAccessors(fn, names) {
  for (var i16 = 0; i16 < names.length; i16++) {
    fn[names[i16]] = optionsAccessor(names[i16]);
  }
}
var withOptions = function(TBase, names) {
  var result = function(TBase2) {
    function result2() {
      TBase2.apply(this, arguments);
    }
    if (TBase2)
      result2.__proto__ = TBase2;
    result2.prototype = Object.create(TBase2 && TBase2.prototype);
    result2.prototype.constructor = result2;
    return result2;
  }(TBase);
  defineOptionsAccessors(result.prototype, names);
  return result;
};
const withOptions$1 = withOptions;
var options = ["offset", "color", "opacity"];
var GradientStop = function(superclass) {
  function GradientStop2(offset2, color, opacity) {
    superclass.call(this);
    this.options = new OptionsStore$1({
      offset: offset2,
      color,
      opacity: defined$1(opacity) ? opacity : 1
    });
    this.options.addObserver(this);
  }
  if (superclass)
    GradientStop2.__proto__ = superclass;
  GradientStop2.prototype = Object.create(superclass && superclass.prototype);
  GradientStop2.prototype.constructor = GradientStop2;
  GradientStop2.create = function create2(arg) {
    if (defined$1(arg)) {
      var stop;
      if (arg instanceof GradientStop2) {
        stop = arg;
      } else if (arg.length > 1) {
        stop = new GradientStop2(arg[0], arg[1], arg[2]);
      } else {
        stop = new GradientStop2(arg.offset, arg.color, arg.opacity);
      }
      return stop;
    }
  };
  return GradientStop2;
}(withOptions$1(HasObservers$1, options));
const GradientStop$1 = GradientStop;
var Gradient = function(HasObservers2) {
  function Gradient2(options2) {
    if (options2 === void 0)
      options2 = {};
    HasObservers2.call(this);
    this.stops = new StopsArray$1(this._createStops(options2.stops));
    this.stops.addObserver(this);
    this._userSpace = options2.userSpace;
    this.id = definitionId();
  }
  if (HasObservers2)
    Gradient2.__proto__ = HasObservers2;
  Gradient2.prototype = Object.create(HasObservers2 && HasObservers2.prototype);
  Gradient2.prototype.constructor = Gradient2;
  var prototypeAccessors2 = { nodeType: { configurable: true } };
  prototypeAccessors2.nodeType.get = function() {
    return "Gradient";
  };
  Gradient2.prototype.userSpace = function userSpace(value2) {
    if (defined$1(value2)) {
      this._userSpace = value2;
      this.optionsChange();
      return this;
    }
    return this._userSpace;
  };
  Gradient2.prototype._createStops = function _createStops(stops) {
    if (stops === void 0)
      stops = [];
    var result = [];
    for (var idx = 0; idx < stops.length; idx++) {
      result.push(GradientStop$1.create(stops[idx]));
    }
    return result;
  };
  Gradient2.prototype.addStop = function addStop(offset2, color, opacity) {
    this.stops.push(new GradientStop$1(offset2, color, opacity));
  };
  Gradient2.prototype.removeStop = function removeStop(stop) {
    var index2 = this.stops.indexOf(stop);
    if (index2 >= 0) {
      this.stops.splice(index2, 1);
    }
  };
  Gradient2.prototype.optionsChange = function optionsChange(e3) {
    this.trigger("optionsChange", {
      field: "gradient" + (e3 ? "." + e3.field : ""),
      value: this
    });
  };
  Gradient2.prototype.geometryChange = function geometryChange() {
    this.optionsChange();
  };
  Object.defineProperties(Gradient2.prototype, prototypeAccessors2);
  return Gradient2;
}(HasObservers$1);
const Gradient$1 = Gradient;
var points = ["start", "end"];
var LinearGradient = function(superclass) {
  function LinearGradient2(options2) {
    if (options2 === void 0)
      options2 = {};
    superclass.call(this, options2);
    this.start(options2.start || new Point$7());
    this.end(options2.end || new Point$7(1, 0));
  }
  if (superclass)
    LinearGradient2.__proto__ = superclass;
  LinearGradient2.prototype = Object.create(superclass && superclass.prototype);
  LinearGradient2.prototype.constructor = LinearGradient2;
  return LinearGradient2;
}(withPoints$1(Gradient$1, points));
const LinearGradient$1 = LinearGradient;
var RadialGradient = function(superclass) {
  function RadialGradient2(options2) {
    if (options2 === void 0)
      options2 = {};
    superclass.call(this, options2);
    this.center(options2.center || new Point$7());
    this._radius = defined$1(options2.radius) ? options2.radius : 1;
    this._fallbackFill = options2.fallbackFill;
  }
  if (superclass)
    RadialGradient2.__proto__ = superclass;
  RadialGradient2.prototype = Object.create(superclass && superclass.prototype);
  RadialGradient2.prototype.constructor = RadialGradient2;
  RadialGradient2.prototype.radius = function radius(value2) {
    if (defined$1(value2)) {
      this._radius = value2;
      this.geometryChange();
      return this;
    }
    return this._radius;
  };
  RadialGradient2.prototype.fallbackFill = function fallbackFill(value2) {
    if (defined$1(value2)) {
      this._fallbackFill = value2;
      this.optionsChange();
      return this;
    }
    return this._fallbackFill;
  };
  return RadialGradient2;
}(withPoints$1(Gradient$1, ["center"]));
const RadialGradient$1 = RadialGradient;
function swing(position2) {
  return 0.5 - Math.cos(position2 * Math.PI) / 2;
}
function linear(position2) {
  return position2;
}
function easeOutElastic(position2, time, start, diff) {
  var s10 = 1.70158, p6 = 0, a9 = diff;
  if (position2 === 0) {
    return start;
  }
  if (position2 === 1) {
    return start + diff;
  }
  if (!p6) {
    p6 = 0.5;
  }
  if (a9 < Math.abs(diff)) {
    a9 = diff;
    s10 = p6 / 4;
  } else {
    s10 = p6 / (2 * Math.PI) * Math.asin(diff / a9);
  }
  return a9 * Math.pow(2, -10 * position2) * Math.sin((Number(position2) - s10) * (1.1 * Math.PI) / p6) + diff + start;
}
const easingFunctions = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  easeOutElastic,
  linear,
  swing
}, Symbol.toStringTag, { value: "Module" }));
var instance$1;
var AnimationFactory = function(Class3) {
  function AnimationFactory2() {
    Class3.call(this);
    this._items = [];
  }
  if (Class3)
    AnimationFactory2.__proto__ = Class3;
  AnimationFactory2.prototype = Object.create(Class3 && Class3.prototype);
  AnimationFactory2.prototype.constructor = AnimationFactory2;
  var staticAccessors2 = { current: { configurable: true } };
  staticAccessors2.current.get = function() {
    if (!instance$1) {
      instance$1 = new AnimationFactory2();
    }
    return instance$1;
  };
  AnimationFactory2.prototype.register = function register4(name2, type) {
    this._items.push({
      name: name2,
      type
    });
  };
  AnimationFactory2.prototype.create = function create2(element, options2) {
    var items = this._items;
    var match2;
    if (options2 && options2.type) {
      var type = options2.type.toLowerCase();
      for (var i16 = 0; i16 < items.length; i16++) {
        if (items[i16].name.toLowerCase() === type) {
          match2 = items[i16];
          break;
        }
      }
    }
    if (match2) {
      return new match2.type(element, options2);
    }
  };
  Object.defineProperties(AnimationFactory2, staticAccessors2);
  return AnimationFactory2;
}(Class$1);
const AnimationFactory$1 = AnimationFactory;
var Animation$1 = function(Class3) {
  function Animation2(element, options2) {
    Class3.call(this);
    this.options = Object.assign({}, this.options, options2);
    this.element = element;
  }
  if (Class3)
    Animation2.__proto__ = Class3;
  Animation2.prototype = Object.create(Class3 && Class3.prototype);
  Animation2.prototype.constructor = Animation2;
  var prototypeAccessors2 = { options: { configurable: true } };
  Animation2.create = function create2(type, element, options2) {
    return AnimationFactory$1.current.create(type, element, options2);
  };
  prototypeAccessors2.options.get = function() {
    return this._options || {
      duration: 500,
      easing: "swing"
    };
  };
  prototypeAccessors2.options.set = function(value2) {
    this._options = value2;
  };
  Animation2.prototype.setup = function setup() {
  };
  Animation2.prototype.step = function step() {
  };
  Animation2.prototype.play = function play() {
    var this$1$1 = this;
    var options2 = this.options;
    var duration2 = options2.duration;
    var delay = options2.delay;
    if (delay === void 0)
      delay = 0;
    var easing = easingFunctions[options2.easing];
    var start = now$2() + delay;
    var finish = start + duration2;
    if (duration2 === 0) {
      this.step(1);
      this.abort();
    } else {
      setTimeout(function() {
        var loop = function() {
          if (this$1$1._stopped) {
            return;
          }
          var wallTime = now$2();
          var time = limitValue$1(wallTime - start, 0, duration2);
          var position2 = time / duration2;
          var easingPosition = easing(position2, time, 0, 1, duration2);
          this$1$1.step(easingPosition);
          if (wallTime < finish) {
            animationFrame$1(loop);
          } else {
            this$1$1.abort();
          }
        };
        loop();
      }, delay);
    }
  };
  Animation2.prototype.abort = function abort() {
    this._stopped = true;
  };
  Animation2.prototype.destroy = function destroy2() {
    this.abort();
  };
  Object.defineProperties(Animation2.prototype, prototypeAccessors2);
  return Animation2;
}(Class$1);
const Animation$2 = Animation$1;
var BaseNode = function(Class3) {
  function BaseNode2(srcElement) {
    Class3.call(this);
    this.childNodes = [];
    this.parent = null;
    if (srcElement) {
      this.srcElement = srcElement;
      this.observe();
    }
  }
  if (Class3)
    BaseNode2.__proto__ = Class3;
  BaseNode2.prototype = Object.create(Class3 && Class3.prototype);
  BaseNode2.prototype.constructor = BaseNode2;
  BaseNode2.prototype.destroy = function destroy2() {
    var this$1$1 = this;
    if (this.srcElement) {
      this.srcElement.removeObserver(this);
    }
    var children = this.childNodes;
    for (var i16 = 0; i16 < children.length; i16++) {
      this$1$1.childNodes[i16].destroy();
    }
    this.parent = null;
  };
  BaseNode2.prototype.load = function load() {
  };
  BaseNode2.prototype.observe = function observe2() {
    if (this.srcElement) {
      this.srcElement.addObserver(this);
    }
  };
  BaseNode2.prototype.append = function append2(node) {
    this.childNodes.push(node);
    node.parent = this;
  };
  BaseNode2.prototype.insertAt = function insertAt(node, pos) {
    this.childNodes.splice(pos, 0, node);
    node.parent = this;
  };
  BaseNode2.prototype.remove = function remove(index2, count) {
    var this$1$1 = this;
    var end = index2 + count;
    for (var i16 = index2; i16 < end; i16++) {
      this$1$1.childNodes[i16].removeSelf();
    }
    this.childNodes.splice(index2, count);
  };
  BaseNode2.prototype.removeSelf = function removeSelf() {
    this.clear();
    this.destroy();
  };
  BaseNode2.prototype.clear = function clear4() {
    this.remove(0, this.childNodes.length);
  };
  BaseNode2.prototype.invalidate = function invalidate() {
    if (this.parent) {
      this.parent.invalidate();
    }
  };
  BaseNode2.prototype.geometryChange = function geometryChange() {
    this.invalidate();
  };
  BaseNode2.prototype.optionsChange = function optionsChange() {
    this.invalidate();
  };
  BaseNode2.prototype.childrenChange = function childrenChange(e3) {
    if (e3.action === "add") {
      this.load(e3.items, e3.index);
    } else if (e3.action === "remove") {
      this.remove(e3.index, e3.items.length);
    }
    this.invalidate();
  };
  return BaseNode2;
}(Class$1);
const BaseNode$1 = BaseNode;
var events = [
  "click",
  "mouseenter",
  "mouseleave",
  "mousemove",
  "resize"
];
var Surface$6 = function(Observable2) {
  function Surface2(element, options2) {
    Observable2.call(this);
    this.options = Object.assign({}, options2);
    this.element = element;
    this.element._kendoExportVisual = this.exportVisual.bind(this);
    this._click = this._handler("click");
    this._mouseenter = this._handler("mouseenter");
    this._mouseleave = this._handler("mouseleave");
    this._mousemove = this._handler("mousemove");
    this._visual = new Group$9();
    elementSize$1(element, this.options);
    this.bind(events, this.options);
    this._enableTracking();
  }
  if (Observable2)
    Surface2.__proto__ = Observable2;
  Surface2.prototype = Object.create(Observable2 && Observable2.prototype);
  Surface2.prototype.constructor = Surface2;
  Surface2.prototype.draw = function draw(element) {
    this._visual.children.push(element);
  };
  Surface2.prototype.clear = function clear4() {
    this._visual.children = [];
  };
  Surface2.prototype.destroy = function destroy2() {
    this._visual = null;
    this.element._kendoExportVisual = null;
    this.unbind();
  };
  Surface2.prototype.eventTarget = function eventTarget(e3) {
    var this$1$1 = this;
    var domNode = eventElement$1(e3);
    var node;
    while (!node && domNode) {
      node = domNode._kendoNode;
      if (domNode === this$1$1.element) {
        break;
      }
      domNode = domNode.parentElement;
    }
    if (node) {
      return node.srcElement;
    }
  };
  Surface2.prototype.exportVisual = function exportVisual() {
    return this._visual;
  };
  Surface2.prototype.getSize = function getSize() {
    return elementSize$1(this.element);
  };
  Surface2.prototype.currentSize = function currentSize(size) {
    if (size) {
      this._size = size;
    } else {
      return this._size;
    }
  };
  Surface2.prototype.setSize = function setSize(size) {
    elementSize$1(this.element, size);
    this.currentSize(size);
    this._resize();
  };
  Surface2.prototype.resize = function resize(force) {
    var size = this.getSize();
    var currentSize = this.currentSize();
    if (force || (size.width > 0 || size.height > 0) && (!currentSize || size.width !== currentSize.width || size.height !== currentSize.height)) {
      this.currentSize(size);
      this._resize(size, force);
      this.trigger("resize", size);
    }
  };
  Surface2.prototype.size = function size(value2) {
    if (!value2) {
      return this.getSize();
    }
    this.setSize(value2);
  };
  Surface2.prototype.suspendTracking = function suspendTracking() {
    this._suspendedTracking = true;
  };
  Surface2.prototype.resumeTracking = function resumeTracking() {
    this._suspendedTracking = false;
  };
  Surface2.prototype._enableTracking = function _enableTracking() {
  };
  Surface2.prototype._resize = function _resize() {
  };
  Surface2.prototype._handler = function _handler(eventName) {
    var this$1$1 = this;
    return function(e3) {
      var node = this$1$1.eventTarget(e3);
      if (node && !this$1$1._suspendedTracking) {
        this$1$1.trigger(eventName, {
          element: node,
          originalEvent: e3,
          type: eventName
        });
      }
    };
  };
  Surface2.prototype._elementOffset = function _elementOffset() {
    var element = this.element;
    var padding = elementPadding(element);
    var ref2 = elementOffset$1(element);
    var left = ref2.left;
    var top = ref2.top;
    return {
      left: left + padding.left,
      top: top + padding.top
    };
  };
  Surface2.prototype._surfacePoint = function _surfacePoint(e3) {
    var offset2 = this._elementOffset();
    var coord = eventCoordinates$1(e3);
    var x3 = coord.x - offset2.left;
    var y4 = coord.y - offset2.top;
    var inverseTransform = elementScale$1(this.element).invert();
    var point2 = new Point$7(
      x3,
      y4
    ).transform(inverseTransform);
    return point2;
  };
  return Surface2;
}(Observable$2);
const BaseSurface = Surface$6;
function renderAttr(name2, value2) {
  return defined$1(value2) && value2 !== null ? " " + name2 + '="' + value2 + '" ' : "";
}
function renderAllAttr(attrs) {
  var output = "";
  for (var i16 = 0; i16 < attrs.length; i16++) {
    output += renderAttr(attrs[i16][0], attrs[i16][1]);
  }
  return output;
}
function renderStyle(attrs) {
  var output = "";
  for (var i16 = 0; i16 < attrs.length; i16++) {
    var value2 = attrs[i16][1];
    if (defined$1(value2)) {
      output += attrs[i16][0] + ":" + value2 + ";";
    }
  }
  if (output !== "") {
    return output;
  }
}
var NODE_MAP$2 = {};
const NODE_MAP$3 = NODE_MAP$2;
var isWindowAvailable = function() {
  return typeof window !== "undefined";
};
var agentRxs = {
  wp: /(Windows Phone(?: OS)?)\s(\d+)\.(\d+(\.\d+)?)/,
  fire: /(Silk)\/(\d+)\.(\d+(\.\d+)?)/,
  android: /(Android|Android.*(?:Opera|Firefox).*?\/)\s*(\d+)(\.(\d+(\.\d+)?))?/,
  iphone: /(iPhone|iPod).*OS\s+(\d+)[\._]([\d\._]+)/,
  ipad: /(iPad).*OS\s+(\d+)[\._]([\d_]+)/,
  meego: /(MeeGo).+NokiaBrowser\/(\d+)\.([\d\._]+)/,
  webos: /(webOS)\/(\d+)\.(\d+(\.\d+)?)/,
  blackberry: /(BlackBerry|BB10).*?Version\/(\d+)\.(\d+(\.\d+)?)/,
  playbook: /(PlayBook).*?Tablet\s*OS\s*(\d+)\.(\d+(\.\d+)?)/,
  windows: /(MSIE)\s+(\d+)\.(\d+(\.\d+)?)/,
  tizen: /(tizen).*?Version\/(\d+)\.(\d+(\.\d+)?)/i,
  sailfish: /(sailfish).*rv:(\d+)\.(\d+(\.\d+)?).*firefox/i,
  ffos: /(Mobile).*rv:(\d+)\.(\d+(\.\d+)?).*Firefox/
};
var osRxs = {
  ios: /^i(phone|pad|pod)$/i,
  android: /^android|fire$/i,
  blackberry: /^blackberry|playbook/i,
  windows: /windows/,
  wp: /wp/,
  flat: /sailfish|ffos|tizen/i,
  meego: /meego/
};
var desktopBrowserRxs = {
  edge: /(edge)[ \/]([\w.]+)/i,
  webkit: /(chrome)[ \/]([\w.]+)/i,
  safari: /(webkit)[ \/]([\w.]+)/i,
  opera: /(opera)(?:.*version|)[ \/]([\w.]+)/i,
  msie: /(msie\s|trident.*? rv:)([\w.]+)/i,
  mozilla: /(mozilla)(?:.*? rv:([\w.]+)|)/i
};
var mobileBrowserRxs = {
  omini: /Opera\sMini/i,
  omobile: /Opera\sMobi/i,
  firefox: /Firefox|Fennec/i,
  mobilesafari: /version\/.*safari/i,
  ie: /MSIE|Windows\sPhone/i,
  chrome: /chrome|crios/i,
  webkit: /webkit/i
};
var testRx = function(agent, rxs, dflt) {
  for (var rx in rxs) {
    if (rxs.hasOwnProperty(rx) && rxs[rx].test(agent)) {
      return rx;
    }
  }
  return dflt !== void 0 ? dflt : agent;
};
var detectMobileOS = function(ua2) {
  var minorVersion;
  var match2 = [];
  for (var agent in agentRxs) {
    if (agentRxs.hasOwnProperty(agent)) {
      match2 = ua2.match(agentRxs[agent]);
      if (!match2) {
        continue;
      }
      if (agent === "windows" && "plugins" in window.navigator) {
        return null;
      }
      var os = {};
      os.device = agent;
      os.browser = testRx(ua2, mobileBrowserRxs, "default");
      os.name = testRx(agent, osRxs);
      os[os.name] = true;
      os.majorVersion = match2[2];
      os.minorVersion = match2[3] ? match2[3].replace("_", ".") : ".0";
      minorVersion = os.minorVersion.replace(".", "").substr(0, 2);
      os.flatVersion = os.majorVersion + minorVersion + new Array(3 - (minorVersion.length < 3 ? minorVersion.length : 2)).join("0");
      os.cordova = typeof window.PhoneGap !== void 0 || typeof window.cordova !== void 0;
      os.appMode = window.navigator.standalone || /file|local|wmapp/.test(window.location.protocol) || os.cordova;
      return os;
    }
  }
  return null;
};
var detectDesktopBrowser = function(ua2) {
  var browserInfo = null;
  var match2 = [];
  for (var agent in desktopBrowserRxs) {
    if (desktopBrowserRxs.hasOwnProperty(agent)) {
      match2 = ua2.match(desktopBrowserRxs[agent]);
      if (match2) {
        browserInfo = {};
        browserInfo[agent] = true;
        browserInfo[match2[1].toLowerCase().split(" ")[0].split("/")[0]] = true;
        browserInfo.version = parseInt(document.documentMode || match2[2], 10);
        break;
      }
    }
  }
  return browserInfo;
};
var userAgent = isWindowAvailable() && window.navigator ? window.navigator.userAgent : null;
var browser$2 = userAgent ? detectDesktopBrowser(userAgent) : null;
userAgent ? detectMobileOS(userAgent) : null;
browser$2 && !browser$2.chrome && window.MSPointerEvent;
browser$2 && !browser$2.chrome && window.PointerEvent;
var reComment = /\/\*[\s\S]*?\*\//g;
var reDeclaration = /([^:;\s]+?)\s*:\s*((?:[^;"']+|"(?:[^"\\]|\\.|url\([^)]*\))*"|'(?:[^'\\]|\\.|url\([^)]*\))*'|url\(\s*(?:[^'")\s]+|'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*")\s*\))*?)(?=;|$)/gi;
function parseInlineStyles(styleString) {
  var styleObject = {};
  var input = (styleString || "").replace(reComment, "");
  var match2 = reDeclaration.exec(input), property, value2;
  while (match2 !== null) {
    property = match2[1].trim();
    value2 = match2[2].trim();
    styleObject[property] = value2;
    match2 = reDeclaration.exec(input);
  }
  return styleObject;
}
var setStyle = function(element, styleString) {
  var styles = parseInlineStyles(styleString);
  Object.keys(styles).forEach(function(key) {
    element.style[key] = styles[key];
  });
};
var styleAttr = "data-style";
var replaceStyleAttr = function(html2) {
  return (html2 || "").replace(/\sstyle=/g, " " + styleAttr + "=");
};
var restoreStyleAttr = function(container) {
  Array.from(container.querySelectorAll("[" + styleAttr + "]")).forEach(function(element) {
    var styleString = element.getAttribute(styleAttr);
    element.removeAttribute(styleAttr);
    setStyle(element, styleString);
  });
};
var setInnerHTML = function(container, html2) {
  container.innerHTML = replaceStyleAttr(html2);
  restoreStyleAttr(container);
};
var SVG_NS = "http://www.w3.org/2000/svg";
var NONE = "none";
var POINT_DIGITS = 3;
var renderSVG = function(container, svg) {
  setInnerHTML(container, svg);
};
if (typeof document !== "undefined") {
  var testFragment = "<svg xmlns='" + SVG_NS + "'></svg>";
  var testContainer = document.createElement("div");
  var hasParser = typeof DOMParser !== "undefined";
  testContainer.innerHTML = testFragment;
  if (hasParser && testContainer.firstChild.namespaceURI !== SVG_NS) {
    renderSVG = function(container, svg) {
      var parser = new DOMParser();
      var chartDoc = parser.parseFromString(replaceStyleAttr(svg), "text/xml");
      restoreStyleAttr(chartDoc);
      var importedDoc = document.adoptNode(chartDoc.documentElement);
      container.innerHTML = "";
      container.appendChild(importedDoc);
    };
  }
}
const renderSVG$1 = renderSVG;
var TRANSFORM = "transform";
var DefinitionMap = {
  clip: "clip-path",
  fill: "fill"
};
function isDefinition(type, value2) {
  return type === "clip" || type === "fill" && (!value2 || value2.nodeType === "Gradient" || value2.nodeType === PATTERN);
}
function baseUrl() {
  var base = document.getElementsByTagName("base")[0];
  var href = document.location.href;
  var url = "";
  if (base && !(support$2.browser || {}).msie) {
    var hashIndex = href.indexOf("#");
    if (hashIndex !== -1) {
      href = href.substring(0, hashIndex);
    }
    url = href;
  }
  return url;
}
var Node$4 = function(BaseNode2) {
  function Node2(srcElement, options2) {
    BaseNode2.call(this, srcElement);
    this.definitions = {};
    this.options = options2;
  }
  if (BaseNode2)
    Node2.__proto__ = BaseNode2;
  Node2.prototype = Object.create(BaseNode2 && BaseNode2.prototype);
  Node2.prototype.constructor = Node2;
  Node2.prototype.destroy = function destroy2() {
    if (this.element) {
      this.element._kendoNode = null;
      this.element = null;
    }
    this.clearDefinitions();
    BaseNode2.prototype.destroy.call(this);
  };
  Node2.prototype.load = function load(elements, pos) {
    var this$1$1 = this;
    for (var i16 = 0; i16 < elements.length; i16++) {
      var srcElement = elements[i16];
      var children = srcElement.children;
      var childNode = new NODE_MAP$3[srcElement.nodeType](srcElement, this$1$1.options);
      if (defined$1(pos)) {
        this$1$1.insertAt(childNode, pos);
      } else {
        this$1$1.append(childNode);
      }
      childNode.createDefinitions();
      if (children && children.length > 0) {
        childNode.load(children);
      }
      var element = this$1$1.element;
      if (element) {
        childNode.attachTo(element, pos);
      }
    }
  };
  Node2.prototype.root = function root() {
    var root2 = this;
    while (root2.parent) {
      root2 = root2.parent;
    }
    return root2;
  };
  Node2.prototype.attachTo = function attachTo(domElement, pos) {
    var container = document.createElement("div");
    renderSVG$1(
      container,
      "<svg xmlns='" + SVG_NS + "' version='1.1'>" + this.render() + "</svg>"
    );
    var element = container.firstChild.firstChild;
    if (element) {
      if (defined$1(pos)) {
        domElement.insertBefore(element, domElement.childNodes[pos] || null);
      } else {
        domElement.appendChild(element);
      }
      this.setElement(element);
    }
  };
  Node2.prototype.setElement = function setElement(element) {
    if (this.element) {
      this.element._kendoNode = null;
    }
    this.element = element;
    this.element._kendoNode = this;
    var nodes = this.childNodes;
    for (var i16 = 0; i16 < nodes.length; i16++) {
      var childElement = element.childNodes[i16];
      nodes[i16].setElement(childElement);
    }
  };
  Node2.prototype.clear = function clear4() {
    this.clearDefinitions();
    if (this.element) {
      this.element.innerHTML = "";
    }
    var children = this.childNodes;
    for (var i16 = 0; i16 < children.length; i16++) {
      children[i16].destroy();
    }
    this.childNodes = [];
  };
  Node2.prototype.removeSelf = function removeSelf() {
    if (this.element) {
      var parentNode = this.element.parentNode;
      if (parentNode) {
        parentNode.removeChild(this.element);
      }
      this.element = null;
    }
    BaseNode2.prototype.removeSelf.call(this);
  };
  Node2.prototype.template = function template() {
    return this.renderChildren();
  };
  Node2.prototype.render = function render() {
    return this.template();
  };
  Node2.prototype.renderChildren = function renderChildren() {
    var nodes = this.childNodes;
    var output = "";
    for (var i16 = 0; i16 < nodes.length; i16++) {
      output += nodes[i16].render();
    }
    return output;
  };
  Node2.prototype.optionsChange = function optionsChange(e3) {
    var field = e3.field;
    var value2 = e3.value;
    if (field === "visible") {
      this.css("display", value2 ? "" : NONE);
    } else if (DefinitionMap[field] && isDefinition(field, value2)) {
      this.updateDefinition(field, value2);
    } else if (field === "opacity") {
      this.attr("opacity", value2);
    } else if (field === "cursor") {
      this.css("cursor", value2);
    } else if (field === "id") {
      if (value2) {
        this.attr("id", value2);
      } else {
        this.removeAttr("id");
      }
    }
    BaseNode2.prototype.optionsChange.call(this, e3);
  };
  Node2.prototype.accessibilityOptionsChange = function accessibilityOptionsChange(e3) {
    var field = e3.field;
    var value2 = e3.value;
    if (field === "role") {
      if (value2) {
        this.attr("role", value2);
      } else {
        this.removeAttr("role");
      }
    } else if (field === "ariaLabel") {
      if (value2) {
        this.attr("aria-label", htmlEncode(value2));
      } else {
        this.removeAttr("aria-label");
      }
    } else if (field === "ariaRoleDescription") {
      if (value2) {
        this.attr("aria-roledescription", htmlEncode(value2));
      } else {
        this.removeAttr("aria-roledescription");
      }
    } else if (field === "ariaChecked") {
      if (defined$1(value2)) {
        this.attr("aria-checked", value2);
      } else {
        this.removeAttr("aria-checked");
      }
    } else if (field === "className") {
      this.className(value2);
    }
  };
  Node2.prototype.attr = function attr(name2, value2) {
    if (this.element) {
      this.element.setAttribute(name2, value2);
    }
  };
  Node2.prototype.allAttr = function allAttr(attrs) {
    var this$1$1 = this;
    for (var i16 = 0; i16 < attrs.length; i16++) {
      this$1$1.attr(attrs[i16][0], attrs[i16][1]);
    }
  };
  Node2.prototype.toggleAttr = function toggleAttr(name2, value2) {
    if (value2) {
      this.attr(name2, value2);
    } else {
      this.removeAttr(name2);
    }
  };
  Node2.prototype.css = function css(name2, value2) {
    if (this.element) {
      this.element.style[name2] = value2;
    }
  };
  Node2.prototype.allCss = function allCss(styles) {
    var this$1$1 = this;
    for (var i16 = 0; i16 < styles.length; i16++) {
      this$1$1.css(styles[i16][0], styles[i16][1]);
    }
  };
  Node2.prototype.className = function className(value2) {
    var this$1$1 = this;
    if (this.element) {
      (ref2 = this.element.classList).remove.apply(ref2, this.element.classList);
      value2.split(" ").forEach(function(item) {
        this$1$1.element.classList.add(item);
      });
    }
    var ref2;
  };
  Node2.prototype.removeAttr = function removeAttr(name2) {
    if (this.element) {
      this.element.removeAttribute(name2);
    }
  };
  Node2.prototype.mapTransform = function mapTransform(transform2) {
    var attrs = [];
    if (transform2) {
      attrs.push([
        TRANSFORM,
        "matrix(" + transform2.matrix().toString(6) + ")"
      ]);
    }
    return attrs;
  };
  Node2.prototype.renderTransform = function renderTransform() {
    return renderAllAttr(
      this.mapTransform(this.srcElement.transform())
    );
  };
  Node2.prototype.transformChange = function transformChange(value2) {
    if (value2) {
      this.allAttr(this.mapTransform(value2));
    } else {
      this.removeAttr(TRANSFORM);
    }
  };
  Node2.prototype.mapStyle = function mapStyle() {
    var options2 = this.srcElement.options;
    var style2 = [["cursor", options2.cursor]];
    if (options2.visible === false) {
      style2.push(["display", NONE]);
    }
    return style2;
  };
  Node2.prototype.renderStyle = function renderStyle$1() {
    return renderAttr("style", renderStyle(this.mapStyle(true)));
  };
  Node2.prototype.renderOpacity = function renderOpacity() {
    return renderAttr("opacity", this.srcElement.options.opacity);
  };
  Node2.prototype.renderId = function renderId() {
    return renderAttr("id", this.srcElement.options.id);
  };
  Node2.prototype.renderClassName = function renderClassName() {
    return renderAttr("class", this.srcElement.options.className);
  };
  Node2.prototype.renderRole = function renderRole() {
    return renderAttr("role", this.srcElement.options.role);
  };
  Node2.prototype.renderAriaLabel = function renderAriaLabel() {
    var value2 = this.srcElement.options.ariaLabel;
    if (value2) {
      value2 = htmlEncode(value2);
    }
    return renderAttr("aria-label", value2);
  };
  Node2.prototype.renderAriaRoleDescription = function renderAriaRoleDescription() {
    var value2 = this.srcElement.options.ariaRoleDescription;
    if (value2) {
      value2 = htmlEncode(value2);
    }
    return renderAttr("aria-roledescription", value2);
  };
  Node2.prototype.renderAriaChecked = function renderAriaChecked() {
    return renderAttr("aria-checked", this.srcElement.options.ariaChecked);
  };
  Node2.prototype.createDefinitions = function createDefinitions() {
    var srcElement = this.srcElement;
    var definitions = this.definitions;
    if (srcElement) {
      var options2 = srcElement.options;
      var hasDefinitions;
      for (var field in DefinitionMap) {
        var definition = options2.get(field);
        if (definition && isDefinition(field, definition)) {
          definitions[field] = definition;
          hasDefinitions = true;
        }
      }
      if (hasDefinitions) {
        this.definitionChange({
          action: "add",
          definitions
        });
      }
    }
  };
  Node2.prototype.definitionChange = function definitionChange(e3) {
    if (this.parent) {
      this.parent.definitionChange(e3);
    }
  };
  Node2.prototype.updateDefinition = function updateDefinition(type, value2) {
    var definitions = this.definitions;
    var current2 = definitions[type];
    var attr = DefinitionMap[type];
    var definition = {};
    if (current2) {
      definition[type] = current2;
      this.definitionChange({
        action: "remove",
        definitions: definition
      });
      delete definitions[type];
    }
    if (!value2) {
      if (current2) {
        this.removeAttr(attr);
      }
    } else {
      definition[type] = value2;
      this.definitionChange({
        action: "add",
        definitions: definition
      });
      definitions[type] = value2;
      this.attr(attr, this.refUrl(value2.id));
    }
  };
  Node2.prototype.clearDefinitions = function clearDefinitions() {
    var definitions = this.definitions;
    this.definitionChange({
      action: "remove",
      definitions
    });
    this.definitions = {};
  };
  Node2.prototype.renderDefinitions = function renderDefinitions() {
    return renderAllAttr(this.mapDefinitions());
  };
  Node2.prototype.mapDefinitions = function mapDefinitions() {
    var this$1$1 = this;
    var definitions = this.definitions;
    var attrs = [];
    for (var field in definitions) {
      attrs.push([DefinitionMap[field], this$1$1.refUrl(definitions[field].id)]);
    }
    return attrs;
  };
  Node2.prototype.refUrl = function refUrl(id2) {
    var skipBaseHref = (this.options || {}).skipBaseHref;
    var baseHref = this.baseUrl().replace(/'/g, "\\'");
    var base = skipBaseHref ? "" : baseHref;
    return "url(" + base + "#" + id2 + ")";
  };
  Node2.prototype.baseUrl = function baseUrl$1() {
    return baseUrl();
  };
  return Node2;
}(BaseNode$1);
const Node$5 = Node$4;
var GradientStopNode = function(Node2) {
  function GradientStopNode2() {
    Node2.apply(this, arguments);
  }
  if (Node2)
    GradientStopNode2.__proto__ = Node2;
  GradientStopNode2.prototype = Object.create(Node2 && Node2.prototype);
  GradientStopNode2.prototype.constructor = GradientStopNode2;
  GradientStopNode2.prototype.template = function template() {
    return "<stop " + this.renderOffset() + " " + this.renderStyle() + " />";
  };
  GradientStopNode2.prototype.renderOffset = function renderOffset() {
    return renderAttr("offset", this.srcElement.offset());
  };
  GradientStopNode2.prototype.mapStyle = function mapStyle() {
    var srcElement = this.srcElement;
    return [
      ["stop-color", srcElement.color()],
      ["stop-opacity", srcElement.opacity()]
    ];
  };
  GradientStopNode2.prototype.optionsChange = function optionsChange(e3) {
    if (e3.field === "offset") {
      this.attr(e3.field, e3.value);
    } else if (e3.field === "color" || e3.field === "opacity") {
      this.css("stop-" + e3.field, e3.value);
    }
  };
  return GradientStopNode2;
}(Node$5);
const GradientStopNode$1 = GradientStopNode;
var GradientNode = function(Node2) {
  function GradientNode2(srcElement) {
    Node2.call(this, srcElement);
    this.id = srcElement.id;
    this.loadStops();
  }
  if (Node2)
    GradientNode2.__proto__ = Node2;
  GradientNode2.prototype = Object.create(Node2 && Node2.prototype);
  GradientNode2.prototype.constructor = GradientNode2;
  GradientNode2.prototype.loadStops = function loadStops() {
    var this$1$1 = this;
    var stops = this.srcElement.stops;
    var element = this.element;
    for (var idx = 0; idx < stops.length; idx++) {
      var stopNode = new GradientStopNode$1(stops[idx]);
      this$1$1.append(stopNode);
      if (element) {
        stopNode.attachTo(element);
      }
    }
  };
  GradientNode2.prototype.optionsChange = function optionsChange(e3) {
    if (e3.field === "gradient.stops") {
      BaseNode$1.prototype.clear.call(this);
      this.loadStops();
    } else if (e3.field === "gradient") {
      this.allAttr(this.mapCoordinates());
    }
  };
  GradientNode2.prototype.renderCoordinates = function renderCoordinates() {
    return renderAllAttr(this.mapCoordinates());
  };
  GradientNode2.prototype.mapSpace = function mapSpace() {
    return ["gradientUnits", this.srcElement.userSpace() ? "userSpaceOnUse" : "objectBoundingBox"];
  };
  return GradientNode2;
}(Node$5);
const GradientNode$1 = GradientNode;
var LinearGradientNode = function(GradientNode2) {
  function LinearGradientNode2() {
    GradientNode2.apply(this, arguments);
  }
  if (GradientNode2)
    LinearGradientNode2.__proto__ = GradientNode2;
  LinearGradientNode2.prototype = Object.create(GradientNode2 && GradientNode2.prototype);
  LinearGradientNode2.prototype.constructor = LinearGradientNode2;
  LinearGradientNode2.prototype.template = function template() {
    return "<linearGradient id='" + this.id + "' " + this.renderCoordinates() + ">" + this.renderChildren() + "</linearGradient>";
  };
  LinearGradientNode2.prototype.mapCoordinates = function mapCoordinates() {
    var srcElement = this.srcElement;
    var start = srcElement.start();
    var end = srcElement.end();
    var attrs = [
      ["x1", start.x],
      ["y1", start.y],
      ["x2", end.x],
      ["y2", end.y],
      this.mapSpace()
    ];
    return attrs;
  };
  return LinearGradientNode2;
}(GradientNode$1);
const LinearGradientNode$1 = LinearGradientNode;
var RadialGradientNode = function(GradientNode2) {
  function RadialGradientNode2() {
    GradientNode2.apply(this, arguments);
  }
  if (GradientNode2)
    RadialGradientNode2.__proto__ = GradientNode2;
  RadialGradientNode2.prototype = Object.create(GradientNode2 && GradientNode2.prototype);
  RadialGradientNode2.prototype.constructor = RadialGradientNode2;
  RadialGradientNode2.prototype.template = function template() {
    return "<radialGradient id='" + this.id + "' " + this.renderCoordinates() + ">" + this.renderChildren() + "</radialGradient>";
  };
  RadialGradientNode2.prototype.mapCoordinates = function mapCoordinates() {
    var srcElement = this.srcElement;
    var center = srcElement.center();
    var radius = srcElement.radius();
    var attrs = [
      ["cx", center.x],
      ["cy", center.y],
      ["r", radius],
      this.mapSpace()
    ];
    return attrs;
  };
  return RadialGradientNode2;
}(GradientNode$1);
const RadialGradientNode$1 = RadialGradientNode;
var PatternNode = function(Node2) {
  function PatternNode2(pattern) {
    Node2.call(this, pattern);
    this.id = pattern.id;
    this.load(pattern.children);
  }
  if (Node2)
    PatternNode2.__proto__ = Node2;
  PatternNode2.prototype = Object.create(Node2 && Node2.prototype);
  PatternNode2.prototype.constructor = PatternNode2;
  PatternNode2.prototype.template = function template() {
    var width = this.srcElement.size().getWidth();
    var height = this.srcElement.size().getHeight();
    return "<pattern id='" + this.srcElement.id + "' width='" + width + "' height='" + height + "' patternUnits='userSpaceOnUse'>" + this.renderChildren() + "</pattern>";
  };
  return PatternNode2;
}(Node$5);
var ClipNode = function(Node2) {
  function ClipNode2(srcElement) {
    Node2.call(this);
    this.srcElement = srcElement;
    this.id = srcElement.id;
    this.load([srcElement]);
  }
  if (Node2)
    ClipNode2.__proto__ = Node2;
  ClipNode2.prototype = Object.create(Node2 && Node2.prototype);
  ClipNode2.prototype.constructor = ClipNode2;
  ClipNode2.prototype.renderClipRule = function renderClipRule() {
    return renderAttr("clip-rule", "evenodd");
  };
  ClipNode2.prototype.template = function template() {
    return "<clipPath " + this.renderClipRule() + " id='" + this.id + "'>" + this.renderChildren() + "</clipPath>";
  };
  return ClipNode2;
}(Node$5);
const ClipNode$1 = ClipNode;
var DefinitionNode = function(Node2) {
  function DefinitionNode2() {
    Node2.call(this);
    this.definitionMap = {};
  }
  if (Node2)
    DefinitionNode2.__proto__ = Node2;
  DefinitionNode2.prototype = Object.create(Node2 && Node2.prototype);
  DefinitionNode2.prototype.constructor = DefinitionNode2;
  DefinitionNode2.prototype.attachTo = function attachTo(domElement) {
    this.element = domElement;
  };
  DefinitionNode2.prototype.template = function template() {
    return "<defs>" + this.renderChildren() + "</defs>";
  };
  DefinitionNode2.prototype.definitionChange = function definitionChange(e3) {
    var definitions = e3.definitions;
    var action = e3.action;
    if (action === "add") {
      this.addDefinitions(definitions);
    } else if (action === "remove") {
      this.removeDefinitions(definitions);
    }
  };
  DefinitionNode2.prototype.createDefinition = function createDefinition(type, item) {
    var nodeType;
    if (type === "clip") {
      nodeType = ClipNode$1;
    } else if (type === "fill") {
      if (item instanceof LinearGradient$1) {
        nodeType = LinearGradientNode$1;
      } else if (item instanceof RadialGradient$1) {
        nodeType = RadialGradientNode$1;
      } else if (item.nodeType === PATTERN) {
        nodeType = PatternNode;
      }
    }
    return new nodeType(item);
  };
  DefinitionNode2.prototype.addDefinitions = function addDefinitions(definitions) {
    var this$1$1 = this;
    for (var field in definitions) {
      this$1$1.addDefinition(field, definitions[field]);
    }
  };
  DefinitionNode2.prototype.addDefinition = function addDefinition(type, srcElement) {
    var ref2 = this;
    var element = ref2.element;
    var definitionMap = ref2.definitionMap;
    var id2 = srcElement.id;
    var mapItem = definitionMap[id2];
    if (!mapItem) {
      var node = this.createDefinition(type, srcElement);
      definitionMap[id2] = {
        element: node,
        count: 1
      };
      this.append(node);
      if (element) {
        node.attachTo(this.element);
      }
    } else {
      mapItem.count++;
    }
  };
  DefinitionNode2.prototype.removeDefinitions = function removeDefinitions(definitions) {
    var this$1$1 = this;
    for (var field in definitions) {
      this$1$1.removeDefinition(definitions[field]);
    }
  };
  DefinitionNode2.prototype.removeDefinition = function removeDefinition(srcElement) {
    var definitionMap = this.definitionMap;
    var id2 = srcElement.id;
    var mapItem = definitionMap[id2];
    if (mapItem) {
      mapItem.count--;
      if (mapItem.count === 0) {
        this.remove(this.childNodes.indexOf(mapItem.element), 1);
        delete definitionMap[id2];
      }
    }
  };
  return DefinitionNode2;
}(Node$5);
const DefinitionNode$1 = DefinitionNode;
var RootNode$2 = function(Node2) {
  function RootNode2(options2) {
    Node2.call(this);
    this.options = options2;
    this.defs = new DefinitionNode$1();
  }
  if (Node2)
    RootNode2.__proto__ = Node2;
  RootNode2.prototype = Object.create(Node2 && Node2.prototype);
  RootNode2.prototype.constructor = RootNode2;
  RootNode2.prototype.attachTo = function attachTo(domElement) {
    this.element = domElement;
    this.defs.attachTo(domElement.firstElementChild);
  };
  RootNode2.prototype.clear = function clear4() {
    BaseNode$1.prototype.clear.call(this);
  };
  RootNode2.prototype.template = function template() {
    return this.defs.render() + this.renderChildren();
  };
  RootNode2.prototype.definitionChange = function definitionChange(e3) {
    this.defs.definitionChange(e3);
  };
  return RootNode2;
}(Node$5);
const RootNode$3 = RootNode$2;
var ATTRIBUTE_MAP = {
  "fill.opacity": "fill-opacity",
  "stroke.color": "stroke",
  "stroke.width": "stroke-width",
  "stroke.opacity": "stroke-opacity"
};
var PathNode$2 = function(Node2) {
  function PathNode2() {
    Node2.apply(this, arguments);
  }
  if (Node2)
    PathNode2.__proto__ = Node2;
  PathNode2.prototype = Object.create(Node2 && Node2.prototype);
  PathNode2.prototype.constructor = PathNode2;
  PathNode2.prototype.geometryChange = function geometryChange() {
    this.attr("d", this.renderData());
    this.invalidate();
  };
  PathNode2.prototype.optionsChange = function optionsChange(e3) {
    switch (e3.field) {
      case "fill":
        if (e3.value) {
          this.allAttr(this.mapFill(e3.value));
        } else {
          this.removeAttr("fill");
        }
        break;
      case "fill.color":
        this.allAttr(this.mapFill({ color: e3.value }));
        break;
      case "stroke":
        if (e3.value) {
          this.allAttr(this.mapStroke(e3.value));
        } else {
          this.removeAttr("stroke");
        }
        break;
      case "transform":
        this.transformChange(e3.value);
        break;
      default:
        var name2 = ATTRIBUTE_MAP[e3.field];
        if (name2) {
          this.attr(name2, e3.value);
        }
        break;
    }
    this.accessibilityOptionsChange(e3);
    Node2.prototype.optionsChange.call(this, e3);
  };
  PathNode2.prototype.content = function content() {
    if (this.element) {
      this.element.textContent = this.srcElement.content();
    }
  };
  PathNode2.prototype.renderData = function renderData() {
    return this.srcElement.toString(POINT_DIGITS) || void 0;
  };
  PathNode2.prototype.mapStroke = function mapStroke(stroke) {
    var attrs = [];
    if (stroke && !isTransparent$1(stroke.color)) {
      attrs.push(["stroke", stroke.color]);
      attrs.push(["stroke-width", stroke.width]);
      attrs.push(["stroke-linecap", this.renderLinecap(stroke)]);
      attrs.push(["stroke-linejoin", stroke.lineJoin]);
      if (defined$1(stroke.opacity)) {
        attrs.push(["stroke-opacity", stroke.opacity]);
      }
      if (defined$1(stroke.dashType)) {
        attrs.push(["stroke-dasharray", this.renderDashType(stroke)]);
      }
    } else {
      attrs.push(["stroke", NONE]);
    }
    return attrs;
  };
  PathNode2.prototype.renderStroke = function renderStroke() {
    return renderAllAttr(
      this.mapStroke(this.srcElement.options.stroke)
    );
  };
  PathNode2.prototype.renderDashType = function renderDashType(stroke) {
    var dashType = stroke.dashType;
    var width = stroke.width;
    if (width === void 0)
      width = 1;
    if (dashType && dashType !== SOLID) {
      var dashArray = DASH_ARRAYS[dashType.toLowerCase()];
      var result = [];
      for (var i16 = 0; i16 < dashArray.length; i16++) {
        result.push(dashArray[i16] * width);
      }
      return result.join(" ");
    }
  };
  PathNode2.prototype.renderLinecap = function renderLinecap(stroke) {
    var dashType = stroke.dashType;
    var lineCap = stroke.lineCap;
    return dashType && dashType !== SOLID ? BUTT : lineCap;
  };
  PathNode2.prototype.mapFill = function mapFill(fill) {
    var attrs = [];
    if (!(fill && (fill.nodeType === "Gradient" || fill.nodeType === PATTERN))) {
      if (fill && !isTransparent$1(fill.color)) {
        attrs.push(["fill", fill.color]);
        if (defined$1(fill.opacity)) {
          attrs.push(["fill-opacity", fill.opacity]);
        }
      } else {
        attrs.push(["fill", NONE]);
      }
    }
    return attrs;
  };
  PathNode2.prototype.renderFill = function renderFill() {
    return renderAllAttr(
      this.mapFill(this.srcElement.options.fill)
    );
  };
  PathNode2.prototype.template = function template() {
    return "<path " + this.renderId() + " " + this.renderStyle() + " " + this.renderOpacity() + " " + renderAttr("d", this.renderData()) + this.renderStroke() + this.renderFill() + this.renderDefinitions() + this.renderTransform() + this.renderClassName() + " " + this.renderRole() + this.renderAriaLabel() + " " + this.renderAriaRoleDescription() + this.renderAriaChecked() + " ></path>";
  };
  return PathNode2;
}(Node$5);
const PathNode$3 = PathNode$2;
var ArcNode$2 = function(PathNode2) {
  function ArcNode2() {
    PathNode2.apply(this, arguments);
  }
  if (PathNode2)
    ArcNode2.__proto__ = PathNode2;
  ArcNode2.prototype = Object.create(PathNode2 && PathNode2.prototype);
  ArcNode2.prototype.constructor = ArcNode2;
  ArcNode2.prototype.renderData = function renderData() {
    return this.srcElement.toPath().toString(POINT_DIGITS);
  };
  return ArcNode2;
}(PathNode$3);
const ArcNode$3 = ArcNode$2;
var CircleNode$2 = function(PathNode2) {
  function CircleNode2() {
    PathNode2.apply(this, arguments);
  }
  if (PathNode2)
    CircleNode2.__proto__ = PathNode2;
  CircleNode2.prototype = Object.create(PathNode2 && PathNode2.prototype);
  CircleNode2.prototype.constructor = CircleNode2;
  CircleNode2.prototype.geometryChange = function geometryChange() {
    var center = this.center();
    this.attr("cx", center.x);
    this.attr("cy", center.y);
    this.attr("r", this.radius());
    this.invalidate();
  };
  CircleNode2.prototype.center = function center() {
    return this.srcElement.geometry().center;
  };
  CircleNode2.prototype.radius = function radius() {
    return this.srcElement.geometry().radius;
  };
  CircleNode2.prototype.template = function template() {
    return "<circle " + this.renderId() + " " + this.renderStyle() + " " + this.renderOpacity() + "cx='" + this.center().x + "' cy='" + this.center().y + "' r='" + this.radius() + "'" + this.renderStroke() + " " + this.renderFill() + " " + this.renderDefinitions() + this.renderClassName() + " " + this.renderRole() + this.renderAriaLabel() + " " + this.renderAriaRoleDescription() + this.renderAriaChecked() + " " + this.renderTransform() + " ></circle>";
  };
  return CircleNode2;
}(PathNode$3);
const CircleNode$3 = CircleNode$2;
var GroupNode$2 = function(Node2) {
  function GroupNode2() {
    Node2.apply(this, arguments);
  }
  if (Node2)
    GroupNode2.__proto__ = Node2;
  GroupNode2.prototype = Object.create(Node2 && Node2.prototype);
  GroupNode2.prototype.constructor = GroupNode2;
  GroupNode2.prototype.template = function template() {
    return "<g" + (this.renderId() + this.renderTransform() + this.renderClassName() + this.renderStyle() + this.renderOpacity() + this.renderRole() + this.renderAriaLabel() + this.renderAriaRoleDescription() + this.renderAriaChecked() + this.renderDefinitions()) + ">" + this.renderChildren() + "</g>";
  };
  GroupNode2.prototype.optionsChange = function optionsChange(e3) {
    var field = e3.field;
    var value2 = e3.value;
    if (field === "transform") {
      this.transformChange(value2);
    }
    this.accessibilityOptionsChange(e3);
    Node2.prototype.optionsChange.call(this, e3);
  };
  return GroupNode2;
}(Node$5);
const GroupNode$3 = GroupNode$2;
var ImageNode$2 = function(PathNode2) {
  function ImageNode2() {
    PathNode2.apply(this, arguments);
  }
  if (PathNode2)
    ImageNode2.__proto__ = PathNode2;
  ImageNode2.prototype = Object.create(PathNode2 && PathNode2.prototype);
  ImageNode2.prototype.constructor = ImageNode2;
  ImageNode2.prototype.geometryChange = function geometryChange() {
    this.allAttr(this.mapPosition());
    this.invalidate();
  };
  ImageNode2.prototype.optionsChange = function optionsChange(e3) {
    if (e3.field === "src") {
      this.allAttr(this.mapSource());
    }
    PathNode2.prototype.optionsChange.call(this, e3);
  };
  ImageNode2.prototype.mapPosition = function mapPosition() {
    var rect = this.srcElement.rect();
    var tl2 = rect.topLeft();
    return [
      ["x", tl2.x],
      ["y", tl2.y],
      ["width", rect.width() + "px"],
      ["height", rect.height() + "px"]
    ];
  };
  ImageNode2.prototype.renderPosition = function renderPosition() {
    return renderAllAttr(this.mapPosition());
  };
  ImageNode2.prototype.mapSource = function mapSource(encode) {
    var src = this.srcElement.src();
    if (encode) {
      src = htmlEncode(src);
    }
    return [["xlink:href", src]];
  };
  ImageNode2.prototype.renderSource = function renderSource() {
    return renderAllAttr(this.mapSource(true));
  };
  ImageNode2.prototype.template = function template() {
    return "<image preserveAspectRatio='none' " + this.renderId() + " " + this.renderStyle() + " " + this.renderTransform() + " " + this.renderOpacity() + this.renderPosition() + " " + this.renderSource() + " " + this.renderDefinitions() + this.renderClassName() + " " + this.renderRole() + this.renderAriaLabel() + " " + this.renderAriaRoleDescription() + this.renderAriaChecked() + " ></image>";
  };
  return ImageNode2;
}(PathNode$3);
const ImageNode$3 = ImageNode$2;
var MultiPathNode$2 = function(PathNode2) {
  function MultiPathNode2() {
    PathNode2.apply(this, arguments);
  }
  if (PathNode2)
    MultiPathNode2.__proto__ = PathNode2;
  MultiPathNode2.prototype = Object.create(PathNode2 && PathNode2.prototype);
  MultiPathNode2.prototype.constructor = MultiPathNode2;
  MultiPathNode2.prototype.renderData = function renderData() {
    return this.srcElement.toString(POINT_DIGITS) || "undefined";
  };
  return MultiPathNode2;
}(PathNode$3);
const MultiPathNode$3 = MultiPathNode$2;
var RectNode$2 = function(PathNode2) {
  function RectNode2() {
    PathNode2.apply(this, arguments);
  }
  if (PathNode2)
    RectNode2.__proto__ = PathNode2;
  RectNode2.prototype = Object.create(PathNode2 && PathNode2.prototype);
  RectNode2.prototype.constructor = RectNode2;
  RectNode2.prototype.geometryChange = function geometryChange() {
    var geometry = this.srcElement.geometry();
    this.attr("x", geometry.origin.x);
    this.attr("y", geometry.origin.y);
    this.attr("width", geometry.size.width);
    this.attr("height", geometry.size.height);
    this.attr("rx", geometry.cornerRadius[0]);
    this.attr("ry", geometry.cornerRadius[1]);
    this.invalidate();
  };
  RectNode2.prototype.size = function size() {
    return this.srcElement.geometry().size;
  };
  RectNode2.prototype.origin = function origin() {
    return this.srcElement.geometry().origin;
  };
  RectNode2.prototype.rx = function rx() {
    return this.srcElement.geometry().cornerRadius[0];
  };
  RectNode2.prototype.ry = function ry() {
    return this.srcElement.geometry().cornerRadius[1];
  };
  RectNode2.prototype.template = function template() {
    return "<rect " + this.renderId() + " " + this.renderStyle() + " " + this.renderOpacity() + " x='" + this.origin().x + "' y='" + this.origin().y + "' rx='" + this.rx() + "' ry='" + this.ry() + "' width='" + this.size().width + "' height='" + this.size().height + "' " + this.renderStroke() + " " + this.renderFill() + " " + this.renderDefinitions() + " " + this.renderTransform() + this.renderClassName() + " " + this.renderRole() + this.renderAriaLabel() + " " + this.renderAriaRoleDescription() + this.renderAriaChecked() + " />";
  };
  return RectNode2;
}(PathNode$3);
const RectNode$3 = RectNode$2;
var ENTITY_REGEX = /&(?:[a-zA-Z]+|#\d+);/g;
function decodeEntities(text) {
  if (!text || typeof text !== "string" || !ENTITY_REGEX.test(text)) {
    return text;
  }
  var element = decodeEntities._element;
  ENTITY_REGEX.lastIndex = 0;
  return text.replace(ENTITY_REGEX, function(match2) {
    element.innerHTML = match2;
    return element.textContent || element.innerText;
  });
}
if (typeof document !== "undefined") {
  decodeEntities._element = document.createElement("span");
}
var TextNode$2 = function(PathNode2) {
  function TextNode2() {
    PathNode2.apply(this, arguments);
  }
  if (PathNode2)
    TextNode2.__proto__ = PathNode2;
  TextNode2.prototype = Object.create(PathNode2 && PathNode2.prototype);
  TextNode2.prototype.constructor = TextNode2;
  TextNode2.prototype.geometryChange = function geometryChange() {
    var pos = this.pos();
    this.attr("x", pos.x);
    this.attr("y", pos.y);
    this.invalidate();
  };
  TextNode2.prototype.optionsChange = function optionsChange(e3) {
    if (e3.field === "font") {
      this.attr("style", renderStyle(this.mapStyle()));
      this.geometryChange();
    } else if (e3.field === "content") {
      PathNode2.prototype.content.call(this, this.srcElement.content());
    }
    PathNode2.prototype.optionsChange.call(this, e3);
  };
  TextNode2.prototype.mapStyle = function mapStyle(encode) {
    var style2 = PathNode2.prototype.mapStyle.call(this, encode);
    var font2 = this.srcElement.options.font;
    if (encode) {
      font2 = htmlEncode(font2);
    }
    style2.push(["font", font2], ["white-space", "pre"]);
    return style2;
  };
  TextNode2.prototype.pos = function pos() {
    var pos2 = this.srcElement.position();
    var size = this.srcElement.measure();
    return pos2.clone().setY(pos2.y + size.baseline);
  };
  TextNode2.prototype.renderContent = function renderContent() {
    var content = this.srcElement.content();
    content = decodeEntities(content);
    content = htmlEncode(content);
    return normalizeText(content);
  };
  TextNode2.prototype.renderTextAnchor = function renderTextAnchor() {
    var anchor;
    if ((this.options || {}).rtl && !(support$2.browser.msie || support$2.browser.edge)) {
      anchor = "end";
    }
    return renderAttr("text-anchor", anchor);
  };
  TextNode2.prototype.renderPaintOrder = function renderPaintOrder() {
    var paintOrder = this.srcElement.options.paintOrder;
    return paintOrder ? renderAttr("paint-order", paintOrder) : "";
  };
  TextNode2.prototype.template = function template() {
    return "<text " + this.renderId() + " " + this.renderTextAnchor() + " " + this.renderStyle() + " " + this.renderOpacity() + "x='" + this.pos().x + "' y='" + this.pos().y + "' " + this.renderStroke() + " " + this.renderTransform() + " " + this.renderDefinitions() + this.renderPaintOrder() + this.renderFill() + this.renderClassName() + " " + this.renderRole() + this.renderAriaLabel() + " " + this.renderAriaRoleDescription() + this.renderAriaChecked() + ">" + this.renderContent() + "</text>";
  };
  return TextNode2;
}(PathNode$3);
const TextNode$3 = TextNode$2;
NODE_MAP$3.Arc = ArcNode$3;
NODE_MAP$3.Circle = CircleNode$3;
NODE_MAP$3.Group = GroupNode$3;
NODE_MAP$3.Image = ImageNode$3;
NODE_MAP$3.MultiPath = MultiPathNode$3;
NODE_MAP$3.Path = PathNode$3;
NODE_MAP$3.Rect = RectNode$3;
NODE_MAP$3.Text = TextNode$3;
var RTL = "rtl";
function alignToScreen(element) {
  var ctm;
  try {
    ctm = element.getScreenCTM ? element.getScreenCTM() : null;
  } catch (e3) {
  }
  if (ctm) {
    var left = -ctm.e % 1;
    var top = -ctm.f % 1;
    var style2 = element.style;
    if (left !== 0 || top !== 0) {
      style2.left = left + "px";
      style2.top = top + "px";
    }
  }
}
var Surface$5 = function(BaseSurface2) {
  function Surface2(element, options2) {
    BaseSurface2.call(this, element, options2);
    this._root = new RootNode$3(Object.assign({
      rtl: elementStyles$1(element, "direction").direction === RTL
    }, this.options));
    renderSVG$1(this.element, this._template(""));
    this._rootElement = this.element.firstElementChild;
    this._rootElement.style.width = "100%";
    this._rootElement.style.height = "100%";
    this._rootElement.style.overflow = "hidden";
    alignToScreen(this._rootElement);
    this._root.attachTo(this._rootElement);
    bindEvents$1(this.element, {
      click: this._click,
      mouseover: this._mouseenter,
      mouseout: this._mouseleave,
      mousemove: this._mousemove
    });
    this.resize();
  }
  if (BaseSurface2)
    Surface2.__proto__ = BaseSurface2;
  Surface2.prototype = Object.create(BaseSurface2 && BaseSurface2.prototype);
  Surface2.prototype.constructor = Surface2;
  var prototypeAccessors2 = { type: { configurable: true } };
  prototypeAccessors2.type.get = function() {
    return "svg";
  };
  Surface2.prototype.destroy = function destroy2() {
    if (this._root) {
      this._root.destroy();
      this._root = null;
      this._rootElement = null;
      unbindEvents$1(this.element, {
        click: this._click,
        mouseover: this._mouseenter,
        mouseout: this._mouseleave,
        mousemove: this._mousemove
      });
    }
    BaseSurface2.prototype.destroy.call(this);
  };
  Surface2.prototype.translate = function translate2(offset2) {
    var viewBox = Math.round(offset2.x) + " " + Math.round(offset2.y) + " " + this._size.width + " " + this._size.height;
    this._offset = offset2;
    this._rootElement.setAttribute("viewBox", viewBox);
  };
  Surface2.prototype.draw = function draw(element) {
    BaseSurface2.prototype.draw.call(this, element);
    this._root.load([element]);
  };
  Surface2.prototype.clear = function clear4() {
    BaseSurface2.prototype.clear.call(this);
    this._root.clear();
  };
  Surface2.prototype.svg = function svg() {
    return "<?xml version='1.0' ?>" + this._template();
  };
  Surface2.prototype.exportVisual = function exportVisual() {
    var ref2 = this;
    var visual = ref2._visual;
    var offset2 = ref2._offset;
    if (offset2) {
      var wrap = new Group$9();
      wrap.children.push(visual);
      wrap.transform(
        transform().translate(-offset2.x, -offset2.y)
      );
      visual = wrap;
    }
    return visual;
  };
  Surface2.prototype._resize = function _resize() {
    if (this._offset) {
      this.translate(this._offset);
    }
  };
  Surface2.prototype._template = function _template(svgStyles) {
    var styles = typeof svgStyles === "string" ? svgStyles : "style='width: 100%; height: 100%; overflow: hidden;' ";
    return "<svg " + styles + "xmlns='" + SVG_NS + "' xmlns:xlink='http://www.w3.org/1999/xlink' version='1.1'>" + this._root.render() + "</svg>";
  };
  Object.defineProperties(Surface2.prototype, prototypeAccessors2);
  return Surface2;
}(BaseSurface);
const SVGSurface = Surface$5;
var NODE_MAP = {};
const NODE_MAP$1 = NODE_MAP;
var Node$2 = function(BaseNode2) {
  function Node2(srcElement) {
    BaseNode2.call(this, srcElement);
    if (srcElement) {
      this.initClip();
    }
  }
  if (BaseNode2)
    Node2.__proto__ = BaseNode2;
  Node2.prototype = Object.create(BaseNode2 && BaseNode2.prototype);
  Node2.prototype.constructor = Node2;
  Node2.prototype.initClip = function initClip() {
    var clip = this.srcElement.clip();
    if (clip) {
      this.clip = clip;
      clip.addObserver(this);
    }
  };
  Node2.prototype.clear = function clear4() {
    if (this.srcElement) {
      this.srcElement.removeObserver(this);
    }
    this.clearClip();
    BaseNode2.prototype.clear.call(this);
  };
  Node2.prototype.clearClip = function clearClip() {
    if (this.clip) {
      this.clip.removeObserver(this);
      delete this.clip;
    }
  };
  Node2.prototype.setClip = function setClip(ctx) {
    if (this.clip) {
      ctx.beginPath();
      var clipNode = new NODE_MAP$1[this.clip.nodeType](this.clip);
      clipNode.renderPoints(ctx, this.clip);
      ctx.clip("evenodd");
    }
  };
  Node2.prototype.optionsChange = function optionsChange(e3) {
    if (e3.field === "clip") {
      this.clearClip();
      this.initClip();
    }
    BaseNode2.prototype.optionsChange.call(this, e3);
  };
  Node2.prototype.setTransform = function setTransform(ctx) {
    if (this.srcElement) {
      var transform2 = this.srcElement.transform();
      if (transform2) {
        ctx.transform.apply(ctx, transform2.matrix().toArray(6));
      }
    }
  };
  Node2.prototype.loadElements = function loadElements(elements, pos, cors) {
    var this$1$1 = this;
    for (var i16 = 0; i16 < elements.length; i16++) {
      var srcElement = elements[i16];
      var children = srcElement.children;
      var childNode = new NODE_MAP$1[srcElement.nodeType](srcElement, cors);
      if (children && children.length > 0) {
        childNode.load(children, pos, cors);
      }
      if (defined$1(pos)) {
        this$1$1.insertAt(childNode, pos);
      } else {
        this$1$1.append(childNode);
      }
    }
  };
  Node2.prototype.load = function load(elements, pos, cors) {
    this.loadElements(elements, pos, cors);
    this.invalidate();
  };
  Node2.prototype.setOpacity = function setOpacity(ctx) {
    if (this.srcElement) {
      var opacity = this.srcElement.opacity();
      if (defined$1(opacity)) {
        this.globalAlpha(ctx, opacity);
      }
    }
  };
  Node2.prototype.globalAlpha = function globalAlpha(ctx, value2) {
    var opactity = value2;
    if (opactity && ctx.globalAlpha) {
      opactity *= ctx.globalAlpha;
    }
    ctx.globalAlpha = opactity;
  };
  Node2.prototype.visible = function visible() {
    var src = this.srcElement;
    return !src || src && src.options.visible !== false;
  };
  return Node2;
}(BaseNode$1);
const Node$3 = Node$2;
var GroupNode = function(superclass) {
  function GroupNode2() {
    superclass.apply(this, arguments);
  }
  if (superclass)
    GroupNode2.__proto__ = superclass;
  GroupNode2.prototype = Object.create(superclass && superclass.prototype);
  GroupNode2.prototype.constructor = GroupNode2;
  GroupNode2.prototype.renderTo = function renderTo(ctx) {
    if (!this.visible()) {
      return;
    }
    ctx.save();
    this.setTransform(ctx);
    this.setClip(ctx);
    this.setOpacity(ctx);
    var childNodes = this.childNodes;
    for (var i16 = 0; i16 < childNodes.length; i16++) {
      var child = childNodes[i16];
      if (child.visible()) {
        child.renderTo(ctx);
      }
    }
    ctx.restore();
  };
  return GroupNode2;
}(traversable$1(Node$3, "childNodes"));
const GroupNode$1 = GroupNode;
var FRAME_DELAY = 1e3 / 60;
var RootNode = function(superclass) {
  function RootNode2(canvas, size) {
    superclass.call(this);
    this.canvas = canvas;
    this.size = size;
    this.ctx = canvas.getContext("2d");
    var invalidateHandler = this._invalidate.bind(this);
    this.invalidate = throttle(function() {
      animationFrame$1(invalidateHandler);
    }, FRAME_DELAY);
  }
  if (superclass)
    RootNode2.__proto__ = superclass;
  RootNode2.prototype = Object.create(superclass && superclass.prototype);
  RootNode2.prototype.constructor = RootNode2;
  RootNode2.prototype.destroy = function destroy2() {
    superclass.prototype.destroy.call(this);
    this.canvas = null;
    this.ctx = null;
  };
  RootNode2.prototype.load = function load(elements, pos, cors) {
    this.loadElements(elements, pos, cors);
    this._invalidate();
  };
  RootNode2.prototype._rescale = function _rescale(scale) {
    var ref2 = this;
    var canvas = ref2.canvas;
    var size = ref2.size;
    canvas.width = size.width * scale;
    canvas.height = size.height * scale;
    this.ctx.scale(scale, scale);
  };
  RootNode2.prototype._devicePixelRatio = function _devicePixelRatio() {
    if (typeof window.devicePixelRatio === "number") {
      return window.devicePixelRatio;
    }
    return 1;
  };
  RootNode2.prototype._invalidate = function _invalidate(options2) {
    if (!this.ctx) {
      return;
    }
    var fixedScale = options2 && options2.fixedScale;
    var scale = fixedScale ? 1 : this._devicePixelRatio();
    this._rescale(scale);
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.renderTo(this.ctx);
  };
  return RootNode2;
}(traversable$1(GroupNode$1, "childNodes"));
const RootNode$1 = RootNode;
var QuadRoot = function(Class3) {
  function QuadRoot2() {
    Class3.call(this);
    this.shapes = [];
  }
  if (Class3)
    QuadRoot2.__proto__ = Class3;
  QuadRoot2.prototype = Object.create(Class3 && Class3.prototype);
  QuadRoot2.prototype.constructor = QuadRoot2;
  QuadRoot2.prototype._add = function _add(shape, bbox) {
    this.shapes.push({
      bbox,
      shape
    });
    shape._quadNode = this;
  };
  QuadRoot2.prototype.pointShapes = function pointShapes(point2) {
    var shapes = this.shapes;
    var length = shapes.length;
    var result = [];
    for (var idx = 0; idx < length; idx++) {
      if (shapes[idx].bbox.containsPoint(point2)) {
        result.push(shapes[idx].shape);
      }
    }
    return result;
  };
  QuadRoot2.prototype.insert = function insert(shape, bbox) {
    this._add(shape, bbox);
  };
  QuadRoot2.prototype.remove = function remove(shape) {
    var shapes = this.shapes;
    var length = shapes.length;
    for (var idx = 0; idx < length; idx++) {
      if (shapes[idx].shape === shape) {
        shapes.splice(idx, 1);
        break;
      }
    }
  };
  return QuadRoot2;
}(Class$1);
const QuadRoot$1 = QuadRoot;
var QuadNode = function(QuadRoot2) {
  function QuadNode2(rect) {
    QuadRoot2.call(this);
    this.children = [];
    this.rect = rect;
  }
  if (QuadRoot2)
    QuadNode2.__proto__ = QuadRoot2;
  QuadNode2.prototype = Object.create(QuadRoot2 && QuadRoot2.prototype);
  QuadNode2.prototype.constructor = QuadNode2;
  QuadNode2.prototype.inBounds = function inBounds(rect) {
    var nodeRect = this.rect;
    var nodeBottomRight = nodeRect.bottomRight();
    var bottomRight = rect.bottomRight();
    var inBounds2 = nodeRect.origin.x <= rect.origin.x && nodeRect.origin.y <= rect.origin.y && bottomRight.x <= nodeBottomRight.x && bottomRight.y <= nodeBottomRight.y;
    return inBounds2;
  };
  QuadNode2.prototype.pointShapes = function pointShapes(point2) {
    var children = this.children;
    var length = children.length;
    var result = QuadRoot2.prototype.pointShapes.call(this, point2);
    for (var idx = 0; idx < length; idx++) {
      append$1(result, children[idx].pointShapes(point2));
    }
    return result;
  };
  QuadNode2.prototype.insert = function insert(shape, bbox) {
    var children = this.children;
    var inserted = false;
    if (this.inBounds(bbox)) {
      if (this.shapes.length < 4) {
        this._add(shape, bbox);
      } else {
        if (!children.length) {
          this._initChildren();
        }
        for (var idx = 0; idx < children.length; idx++) {
          if (children[idx].insert(shape, bbox)) {
            inserted = true;
            break;
          }
        }
        if (!inserted) {
          this._add(shape, bbox);
        }
      }
      inserted = true;
    }
    return inserted;
  };
  QuadNode2.prototype._initChildren = function _initChildren() {
    var ref2 = this;
    var rect = ref2.rect;
    var children = ref2.children;
    var center = rect.center();
    var halfWidth = rect.width() / 2;
    var halfHeight = rect.height() / 2;
    children.push(
      new QuadNode2(new Rect$1([rect.origin.x, rect.origin.y], [halfWidth, halfHeight])),
      new QuadNode2(new Rect$1([center.x, rect.origin.y], [halfWidth, halfHeight])),
      new QuadNode2(new Rect$1([rect.origin.x, center.y], [halfWidth, halfHeight])),
      new QuadNode2(new Rect$1([center.x, center.y], [halfWidth, halfHeight]))
    );
  };
  return QuadNode2;
}(QuadRoot$1);
const QuadNode$1 = QuadNode;
var ROOT_SIZE = 3e3;
var LEVEL_STEP = 1e4;
var MAX_LEVEL = 75;
var ShapesQuadTree = function(Class3) {
  function ShapesQuadTree2() {
    Class3.call(this);
    this.initRoots();
  }
  if (Class3)
    ShapesQuadTree2.__proto__ = Class3;
  ShapesQuadTree2.prototype = Object.create(Class3 && Class3.prototype);
  ShapesQuadTree2.prototype.constructor = ShapesQuadTree2;
  ShapesQuadTree2.prototype.initRoots = function initRoots() {
    this.rootMap = {};
    this.root = new QuadRoot$1();
    this.rootElements = [];
  };
  ShapesQuadTree2.prototype.clear = function clear4() {
    var this$1$1 = this;
    var rootElements = this.rootElements;
    for (var idx = 0; idx < rootElements.length; idx++) {
      this$1$1.remove(rootElements[idx]);
    }
    this.initRoots();
  };
  ShapesQuadTree2.prototype.pointShape = function pointShape(point2) {
    var sectorRoot = (this.rootMap[Math.floor(point2.x / ROOT_SIZE)] || {})[Math.floor(point2.y / ROOT_SIZE)];
    var result = this.root.pointShapes(point2);
    if (sectorRoot) {
      result = result.concat(sectorRoot.pointShapes(point2));
    }
    this.assignZindex(result);
    result.sort(zIndexComparer);
    for (var idx = 0; idx < result.length; idx++) {
      if (result[idx].containsPoint(point2)) {
        return result[idx];
      }
    }
  };
  ShapesQuadTree2.prototype.assignZindex = function assignZindex(elements) {
    var this$1$1 = this;
    for (var idx = 0; idx < elements.length; idx++) {
      var element = elements[idx];
      var zIndex2 = 0;
      var levelWeight = Math.pow(LEVEL_STEP, MAX_LEVEL);
      var parents2 = [];
      while (element) {
        parents2.push(element);
        element = element.parent;
      }
      while (parents2.length) {
        element = parents2.pop();
        zIndex2 += ((element.parent ? element.parent.children : this$1$1.rootElements).indexOf(element) + 1) * levelWeight;
        levelWeight /= LEVEL_STEP;
      }
      elements[idx]._zIndex = zIndex2;
    }
  };
  ShapesQuadTree2.prototype.optionsChange = function optionsChange(e3) {
    if (e3.field === "transform" || e3.field === "stroke.width") {
      this.bboxChange(e3.element);
    }
  };
  ShapesQuadTree2.prototype.geometryChange = function geometryChange(e3) {
    this.bboxChange(e3.element);
  };
  ShapesQuadTree2.prototype.bboxChange = function bboxChange(element) {
    var this$1$1 = this;
    if (element.nodeType === "Group") {
      for (var idx = 0; idx < element.children.length; idx++) {
        this$1$1.bboxChange(element.children[idx]);
      }
    } else {
      if (element._quadNode) {
        element._quadNode.remove(element);
      }
      this._insertShape(element);
    }
  };
  ShapesQuadTree2.prototype.add = function add3(elements) {
    var elementsArray = Array.isArray(elements) ? elements.slice(0) : [elements];
    append$1(this.rootElements, elementsArray);
    this._insert(elementsArray);
  };
  ShapesQuadTree2.prototype.childrenChange = function childrenChange(e3) {
    var this$1$1 = this;
    if (e3.action === "remove") {
      for (var idx = 0; idx < e3.items.length; idx++) {
        this$1$1.remove(e3.items[idx]);
      }
    } else {
      this._insert(Array.prototype.slice.call(e3.items, 0));
    }
  };
  ShapesQuadTree2.prototype._insert = function _insert(elements) {
    var this$1$1 = this;
    var element;
    while (elements.length > 0) {
      element = elements.pop();
      element.addObserver(this$1$1);
      if (element.nodeType === "Group") {
        append$1(elements, element.children);
      } else {
        this$1$1._insertShape(element);
      }
    }
  };
  ShapesQuadTree2.prototype._insertShape = function _insertShape(shape) {
    var bbox = shape.bbox();
    if (bbox) {
      var sectors = this.getSectors(bbox);
      var x3 = sectors[0][0];
      var y4 = sectors[1][0];
      if (this.inRoot(sectors)) {
        this.root.insert(shape, bbox);
      } else {
        var rootMap = this.rootMap;
        if (!rootMap[x3]) {
          rootMap[x3] = {};
        }
        if (!rootMap[x3][y4]) {
          rootMap[x3][y4] = new QuadNode$1(
            new Rect$1([x3 * ROOT_SIZE, y4 * ROOT_SIZE], [ROOT_SIZE, ROOT_SIZE])
          );
        }
        rootMap[x3][y4].insert(shape, bbox);
      }
    }
  };
  ShapesQuadTree2.prototype.remove = function remove(element) {
    var this$1$1 = this;
    element.removeObserver(this);
    if (element.nodeType === "Group") {
      var children = element.children;
      for (var idx = 0; idx < children.length; idx++) {
        this$1$1.remove(children[idx]);
      }
    } else if (element._quadNode) {
      element._quadNode.remove(element);
      delete element._quadNode;
    }
  };
  ShapesQuadTree2.prototype.inRoot = function inRoot(sectors) {
    return sectors[0].length > 1 || sectors[1].length > 1;
  };
  ShapesQuadTree2.prototype.getSectors = function getSectors(rect) {
    var bottomRight = rect.bottomRight();
    var bottomX = Math.floor(bottomRight.x / ROOT_SIZE);
    var bottomY = Math.floor(bottomRight.y / ROOT_SIZE);
    var sectors = [[], []];
    for (var x3 = Math.floor(rect.origin.x / ROOT_SIZE); x3 <= bottomX; x3++) {
      sectors[0].push(x3);
    }
    for (var y4 = Math.floor(rect.origin.y / ROOT_SIZE); y4 <= bottomY; y4++) {
      sectors[1].push(y4);
    }
    return sectors;
  };
  return ShapesQuadTree2;
}(Class$1);
function zIndexComparer(x1, x22) {
  if (x1._zIndex < x22._zIndex) {
    return 1;
  }
  if (x1._zIndex > x22._zIndex) {
    return -1;
  }
  return 0;
}
const ShapesQuadTree$1 = ShapesQuadTree;
var SurfaceCursor = function SurfaceCursor2(surface) {
  surface.bind("mouseenter", this._mouseenter.bind(this));
  surface.bind("mouseleave", this._mouseleave.bind(this));
  this.element = surface.element;
};
SurfaceCursor.prototype.clear = function clear() {
  this._resetCursor();
};
SurfaceCursor.prototype.destroy = function destroy() {
  this._resetCursor();
  delete this.element;
};
SurfaceCursor.prototype._mouseenter = function _mouseenter(e3) {
  var cursor = this._shapeCursor(e3);
  if (!cursor) {
    this._resetCursor();
  } else {
    if (!this._current) {
      this._defaultCursor = this._getCursor();
    }
    this._setCursor(cursor);
  }
};
SurfaceCursor.prototype._mouseleave = function _mouseleave() {
  this._resetCursor();
};
SurfaceCursor.prototype._shapeCursor = function _shapeCursor(e3) {
  var shape = e3.element;
  while (shape && !defined$1(shape.options.cursor)) {
    shape = shape.parent;
  }
  if (shape) {
    return shape.options.cursor;
  }
};
SurfaceCursor.prototype._getCursor = function _getCursor() {
  if (this.element) {
    return this.element.style.cursor;
  }
};
SurfaceCursor.prototype._setCursor = function _setCursor(cursor) {
  if (this.element) {
    this.element.style.cursor = cursor;
    this._current = cursor;
  }
};
SurfaceCursor.prototype._resetCursor = function _resetCursor() {
  if (this._current) {
    this._setCursor(this._defaultCursor || "");
    delete this._current;
  }
};
const SurfaceCursor$1 = SurfaceCursor;
function renderPath(ctx, path) {
  var segments = path.segments;
  if (segments.length === 0) {
    return;
  }
  var segment = segments[0];
  var anchor = segment.anchor();
  ctx.moveTo(anchor.x, anchor.y);
  for (var i16 = 1; i16 < segments.length; i16++) {
    segment = segments[i16];
    anchor = segment.anchor();
    var prevSeg = segments[i16 - 1];
    var prevOut = prevSeg.controlOut();
    var controlIn = segment.controlIn();
    if (prevOut && controlIn) {
      ctx.bezierCurveTo(
        prevOut.x,
        prevOut.y,
        controlIn.x,
        controlIn.y,
        anchor.x,
        anchor.y
      );
    } else {
      ctx.lineTo(anchor.x, anchor.y);
    }
  }
  if (path.options.closed) {
    ctx.closePath();
  }
}
function addGradientStops(gradient, stops) {
  for (var idx = 0; idx < stops.length; idx++) {
    var stop = stops[idx];
    var color = parseColor(stop.color());
    color.a *= stop.opacity();
    gradient.addColorStop(stop.offset(), color.toCssRgba());
  }
}
var PathNode = function(Node2) {
  function PathNode2() {
    Node2.apply(this, arguments);
  }
  if (Node2)
    PathNode2.__proto__ = Node2;
  PathNode2.prototype = Object.create(Node2 && Node2.prototype);
  PathNode2.prototype.constructor = PathNode2;
  PathNode2.prototype.renderTo = function renderTo(ctx) {
    ctx.save();
    this.setTransform(ctx);
    this.setClip(ctx);
    this.setOpacity(ctx);
    ctx.beginPath();
    this.renderPoints(ctx, this.srcElement);
    this.setLineDash(ctx);
    this.setLineCap(ctx);
    this.setLineJoin(ctx);
    this.setFill(ctx);
    this.setStroke(ctx);
    ctx.restore();
  };
  PathNode2.prototype.setFill = function setFill(ctx) {
    var fill = this.srcElement.options.fill;
    var hasFill = false;
    if (fill) {
      if (fill.nodeType === "Gradient") {
        this.setGradientFill(ctx, fill);
        hasFill = true;
      } else if (fill.nodeType === PATTERN) {
        this.setPatternFill(ctx, fill);
        hasFill = true;
      } else if (!isTransparent$1(fill.color)) {
        ctx.fillStyle = fill.color;
        ctx.save();
        this.globalAlpha(ctx, fill.opacity);
        ctx.fill();
        ctx.restore();
        hasFill = true;
      }
    }
    return hasFill;
  };
  PathNode2.prototype.setGradientFill = function setGradientFill(ctx, fill) {
    var bbox = this.srcElement.rawBBox();
    var gradient;
    if (fill instanceof LinearGradient$1) {
      var start = fill.start();
      var end = fill.end();
      gradient = ctx.createLinearGradient(start.x, start.y, end.x, end.y);
    } else if (fill instanceof RadialGradient$1) {
      var center = fill.center();
      gradient = ctx.createRadialGradient(center.x, center.y, 0, center.x, center.y, fill.radius());
    }
    addGradientStops(gradient, fill.stops);
    ctx.save();
    if (!fill.userSpace()) {
      ctx.transform(bbox.width(), 0, 0, bbox.height(), bbox.origin.x, bbox.origin.y);
    }
    ctx.fillStyle = gradient;
    ctx.fill();
    ctx.restore();
  };
  PathNode2.prototype.setPatternFill = function setPatternFill(ctx, pattern) {
    var size = pattern.size();
    var patternCanvas = document.createElement("canvas");
    var patternContext = patternCanvas.getContext("2d");
    patternCanvas.width = size.getWidth();
    patternCanvas.height = size.getHeight();
    this.childNodes.length = 0;
    this.loadElements(pattern.children);
    var childNodes = this.childNodes;
    for (var i16 = 0; i16 < childNodes.length; i16++) {
      var child = childNodes[i16];
      child.renderTo(patternContext);
    }
    ctx.save();
    ctx.fillStyle = ctx.createPattern(patternCanvas, "repeat");
    ctx.fill();
    ctx.restore();
  };
  PathNode2.prototype.setStroke = function setStroke(ctx) {
    var stroke = this.srcElement.options.stroke;
    if (stroke && !isTransparent$1(stroke.color) && stroke.width > 0) {
      ctx.strokeStyle = stroke.color;
      ctx.lineWidth = valueOrDefault$2(stroke.width, 1);
      ctx.lineJoin = valueOrDefault$2(stroke.lineJoin, ctx.lineJoin);
      ctx.save();
      this.globalAlpha(ctx, stroke.opacity);
      ctx.stroke();
      ctx.restore();
      return true;
    }
  };
  PathNode2.prototype.dashType = function dashType() {
    var stroke = this.srcElement.options.stroke;
    if (stroke && stroke.dashType) {
      return stroke.dashType.toLowerCase();
    }
  };
  PathNode2.prototype.setLineDash = function setLineDash(ctx) {
    var dashType = this.dashType();
    if (dashType && dashType !== SOLID) {
      var dashArray = DASH_ARRAYS[dashType];
      if (ctx.setLineDash) {
        ctx.setLineDash(dashArray);
      } else {
        ctx.mozDash = dashArray;
        ctx.webkitLineDash = dashArray;
      }
    }
  };
  PathNode2.prototype.setLineCap = function setLineCap(ctx) {
    var dashType = this.dashType();
    var stroke = this.srcElement.options.stroke;
    if (dashType && dashType !== SOLID) {
      ctx.lineCap = BUTT;
    } else if (stroke && stroke.lineCap) {
      ctx.lineCap = stroke.lineCap;
    }
  };
  PathNode2.prototype.setLineJoin = function setLineJoin(ctx) {
    var stroke = this.srcElement.options.stroke;
    if (stroke && stroke.lineJoin) {
      ctx.lineJoin = stroke.lineJoin;
    }
  };
  PathNode2.prototype.renderPoints = function renderPoints(ctx, path) {
    renderPath(ctx, path);
  };
  return PathNode2;
}(Node$3);
const PathNode$1 = PathNode;
var ArcNode = function(PathNode2) {
  function ArcNode2() {
    PathNode2.apply(this, arguments);
  }
  if (PathNode2)
    ArcNode2.__proto__ = PathNode2;
  ArcNode2.prototype = Object.create(PathNode2 && PathNode2.prototype);
  ArcNode2.prototype.constructor = ArcNode2;
  ArcNode2.prototype.renderPoints = function renderPoints(ctx) {
    var path = this.srcElement.toPath();
    renderPath(ctx, path);
  };
  return ArcNode2;
}(PathNode$1);
const ArcNode$1 = ArcNode;
var CircleNode = function(PathNode2) {
  function CircleNode2() {
    PathNode2.apply(this, arguments);
  }
  if (PathNode2)
    CircleNode2.__proto__ = PathNode2;
  CircleNode2.prototype = Object.create(PathNode2 && PathNode2.prototype);
  CircleNode2.prototype.constructor = CircleNode2;
  CircleNode2.prototype.renderPoints = function renderPoints(ctx) {
    var ref2 = this.srcElement.geometry();
    var center = ref2.center;
    var radius = ref2.radius;
    ctx.arc(center.x, center.y, radius, 0, Math.PI * 2);
  };
  return CircleNode2;
}(PathNode$1);
const CircleNode$1 = CircleNode;
var ImageNode = function(PathNode2) {
  function ImageNode2(srcElement, cors) {
    PathNode2.call(this, srcElement);
    this.onLoad = this.onLoad.bind(this);
    this.onError = this.onError.bind(this);
    this.loading = createPromise();
    var img = this.img = new Image();
    var src = srcElement.src();
    if (cors && !/^data:/i.test(src)) {
      img.crossOrigin = cors;
    }
    if (src) {
      img.src = src;
    }
    if (img.complete) {
      this.onLoad();
    } else {
      img.onload = this.onLoad;
      img.onerror = this.onError;
    }
  }
  if (PathNode2)
    ImageNode2.__proto__ = PathNode2;
  ImageNode2.prototype = Object.create(PathNode2 && PathNode2.prototype);
  ImageNode2.prototype.constructor = ImageNode2;
  ImageNode2.prototype.renderTo = function renderTo(ctx) {
    if (this.loading.state() === "resolved") {
      ctx.save();
      this.setTransform(ctx);
      this.setClip(ctx);
      this.drawImage(ctx);
      ctx.restore();
    }
  };
  ImageNode2.prototype.optionsChange = function optionsChange(e3) {
    if (e3.field === "src") {
      this.loading = createPromise();
      this.img.src = this.srcElement.src();
    } else {
      PathNode2.prototype.optionsChange.call(this, e3);
    }
  };
  ImageNode2.prototype.onLoad = function onLoad() {
    this.loading.resolve();
    this.invalidate();
  };
  ImageNode2.prototype.onError = function onError() {
    this.loading.reject(new Error(
      "Unable to load image '" + this.img.src + "'. Check for connectivity and verify CORS headers."
    ));
  };
  ImageNode2.prototype.drawImage = function drawImage(ctx) {
    var rect = this.srcElement.rect();
    var topLeft = rect.topLeft();
    ctx.drawImage(
      this.img,
      topLeft.x,
      topLeft.y,
      rect.width(),
      rect.height()
    );
  };
  return ImageNode2;
}(PathNode$1);
const ImageNode$1 = ImageNode;
var MultiPathNode = function(PathNode2) {
  function MultiPathNode2() {
    PathNode2.apply(this, arguments);
  }
  if (PathNode2)
    MultiPathNode2.__proto__ = PathNode2;
  MultiPathNode2.prototype = Object.create(PathNode2 && PathNode2.prototype);
  MultiPathNode2.prototype.constructor = MultiPathNode2;
  MultiPathNode2.prototype.renderPoints = function renderPoints(ctx) {
    var paths = this.srcElement.paths;
    for (var i16 = 0; i16 < paths.length; i16++) {
      renderPath(ctx, paths[i16]);
    }
  };
  return MultiPathNode2;
}(PathNode$1);
const MultiPathNode$1 = MultiPathNode;
var RectNode = function(PathNode2) {
  function RectNode2() {
    PathNode2.apply(this, arguments);
  }
  if (PathNode2)
    RectNode2.__proto__ = PathNode2;
  RectNode2.prototype = Object.create(PathNode2 && PathNode2.prototype);
  RectNode2.prototype.constructor = RectNode2;
  RectNode2.prototype.renderPoints = function renderPoints(ctx) {
    var geometry = this.srcElement.geometry();
    var ref2 = geometry.cornerRadius;
    var rx = ref2[0];
    var ry = ref2[1];
    if (rx === 0 && ry === 0) {
      var origin = geometry.origin;
      var size = geometry.size;
      ctx.rect(origin.x, origin.y, size.width, size.height);
    } else {
      PathNode2.prototype.renderPoints.call(this, ctx, Path$7.fromRect(geometry));
    }
  };
  return RectNode2;
}(PathNode$1);
const RectNode$1 = RectNode;
var TextNode = function(PathNode2) {
  function TextNode2() {
    PathNode2.apply(this, arguments);
  }
  if (PathNode2)
    TextNode2.__proto__ = PathNode2;
  TextNode2.prototype = Object.create(PathNode2 && PathNode2.prototype);
  TextNode2.prototype.constructor = TextNode2;
  TextNode2.prototype.renderTo = function renderTo(ctx) {
    var text = this.srcElement;
    var pos = text.position();
    var size = text.measure();
    ctx.save();
    this.setTransform(ctx);
    this.setClip(ctx);
    this.setOpacity(ctx);
    ctx.beginPath();
    ctx.font = text.options.font;
    ctx.textAlign = "left";
    if (text.options.paintOrder === "stroke") {
      this.stroke(ctx, text, pos, size);
      this.fill(ctx, text, pos, size);
    } else {
      this.fill(ctx, text, pos, size);
      this.stroke(ctx, text, pos, size);
    }
    ctx.restore();
  };
  TextNode2.prototype.stroke = function stroke(ctx, text, pos, size) {
    if (this.setStroke(ctx)) {
      this.setLineDash(ctx);
      ctx.strokeText(text.content(), pos.x, pos.y + size.baseline);
    }
  };
  TextNode2.prototype.fill = function fill(ctx, text, pos, size) {
    if (this.setFill(ctx)) {
      ctx.fillText(text.content(), pos.x, pos.y + size.baseline);
    }
  };
  return TextNode2;
}(PathNode$1);
const TextNode$1 = TextNode;
NODE_MAP$1.Arc = ArcNode$1;
NODE_MAP$1.Circle = CircleNode$1;
NODE_MAP$1.Group = GroupNode$1;
NODE_MAP$1.Image = ImageNode$1;
NODE_MAP$1.MultiPath = MultiPathNode$1;
NODE_MAP$1.Path = PathNode$1;
NODE_MAP$1.Rect = RectNode$1;
NODE_MAP$1.Text = TextNode$1;
var Surface$3 = function(BaseSurface2) {
  function Surface2(element, options2) {
    BaseSurface2.call(this, element, options2);
    this.element.innerHTML = this._template(this);
    var canvas = this.element.firstElementChild;
    canvas.style.width = "100%";
    canvas.style.height = "100%";
    var size = elementSize$1(element);
    canvas.width = size.width;
    canvas.height = size.height;
    this._rootElement = canvas;
    this._root = new RootNode$1(canvas, size);
    this._mouseTrackHandler = this._trackMouse.bind(this);
    bindEvents$1(this.element, {
      click: this._mouseTrackHandler,
      mousemove: this._mouseTrackHandler
    });
  }
  if (BaseSurface2)
    Surface2.__proto__ = BaseSurface2;
  Surface2.prototype = Object.create(BaseSurface2 && BaseSurface2.prototype);
  Surface2.prototype.constructor = Surface2;
  var prototypeAccessors2 = { type: { configurable: true } };
  prototypeAccessors2.type.get = function() {
    return "canvas";
  };
  Surface2.prototype.destroy = function destroy2() {
    BaseSurface2.prototype.destroy.call(this);
    if (this._root) {
      this._root.destroy();
      this._root = null;
    }
    if (this._searchTree) {
      this._searchTree.clear();
      delete this._searchTree;
    }
    if (this._cursor) {
      this._cursor.destroy();
      delete this._cursor;
    }
    unbindEvents$1(this.element, {
      click: this._mouseTrackHandler,
      mousemove: this._mouseTrackHandler
    });
  };
  Surface2.prototype.draw = function draw(element) {
    BaseSurface2.prototype.draw.call(this, element);
    this._root.load([element], void 0, this.options.cors);
    if (this._searchTree) {
      this._searchTree.add([element]);
    }
  };
  Surface2.prototype.clear = function clear4() {
    BaseSurface2.prototype.clear.call(this);
    this._root.clear();
    if (this._searchTree) {
      this._searchTree.clear();
    }
    if (this._cursor) {
      this._cursor.clear();
    }
  };
  Surface2.prototype.eventTarget = function eventTarget(e3) {
    if (this._searchTree) {
      var point2 = this._surfacePoint(e3);
      var shape = this._searchTree.pointShape(point2);
      return shape;
    }
  };
  Surface2.prototype.image = function image() {
    var ref2 = this;
    var root = ref2._root;
    var rootElement = ref2._rootElement;
    var loadingStates = [];
    root.traverse(function(childNode) {
      if (childNode.loading) {
        loadingStates.push(childNode.loading);
      }
    });
    var promise = createPromise();
    var resolveDataURL = function() {
      root._invalidate({ fixedScale: true });
      try {
        var data2 = rootElement.toDataURL();
        promise.resolve(data2);
      } catch (e3) {
        promise.reject(e3);
      }
    };
    promiseAll(loadingStates).then(resolveDataURL, resolveDataURL);
    return promise;
  };
  Surface2.prototype.suspendTracking = function suspendTracking() {
    BaseSurface2.prototype.suspendTracking.call(this);
    if (this._searchTree) {
      this._searchTree.clear();
      delete this._searchTree;
    }
  };
  Surface2.prototype.resumeTracking = function resumeTracking() {
    BaseSurface2.prototype.resumeTracking.call(this);
    if (!this._searchTree) {
      this._searchTree = new ShapesQuadTree$1();
      var childNodes = this._root.childNodes;
      var rootElements = [];
      for (var idx = 0; idx < childNodes.length; idx++) {
        rootElements.push(childNodes[idx].srcElement);
      }
      this._searchTree.add(rootElements);
    }
  };
  Surface2.prototype._resize = function _resize() {
    this._rootElement.width = this._size.width;
    this._rootElement.height = this._size.height;
    this._root.size = this._size;
    this._root.invalidate();
  };
  Surface2.prototype._template = function _template() {
    return "<canvas></canvas>";
  };
  Surface2.prototype._enableTracking = function _enableTracking() {
    this._searchTree = new ShapesQuadTree$1();
    this._cursor = new SurfaceCursor$1(this);
    BaseSurface2.prototype._enableTracking.call(this);
  };
  Surface2.prototype._trackMouse = function _trackMouse(e3) {
    if (this._suspendedTracking) {
      return;
    }
    var shape = this.eventTarget(e3);
    if (e3.type !== "click") {
      var currentShape = this._currentShape;
      if (currentShape && currentShape !== shape) {
        this.trigger("mouseleave", {
          element: currentShape,
          originalEvent: e3,
          type: "mouseleave"
        });
      }
      if (shape && currentShape !== shape) {
        this.trigger("mouseenter", {
          element: shape,
          originalEvent: e3,
          type: "mouseenter"
        });
      }
      this.trigger("mousemove", {
        element: shape,
        originalEvent: e3,
        type: "mousemove"
      });
      this._currentShape = shape;
    } else if (shape) {
      this.trigger("click", {
        element: shape,
        originalEvent: e3,
        type: "click"
      });
    }
  };
  Object.defineProperties(Surface2.prototype, prototypeAccessors2);
  return Surface2;
}(BaseSurface);
const Surface$4 = Surface$3;
var instance;
var support;
var hasDocument = function() {
  return typeof document !== "undefined";
};
var supportsCanvas = function() {
  return hasDocument() && document.createElement("canvas").getContext;
};
var supportsSVG = function() {
  return hasDocument() && document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1");
};
var SurfaceFactory = function(Class3) {
  function SurfaceFactory2() {
    Class3.call(this);
    this._items = [{
      name: "svg",
      type: SVGSurface
    }, {
      name: "canvas",
      type: Surface$4
    }];
  }
  if (Class3)
    SurfaceFactory2.__proto__ = Class3;
  SurfaceFactory2.prototype = Object.create(Class3 && Class3.prototype);
  SurfaceFactory2.prototype.constructor = SurfaceFactory2;
  var staticAccessors2 = { support: { configurable: true }, current: { configurable: true } };
  staticAccessors2.support.get = function() {
    if (!support) {
      support = {
        canvas: supportsCanvas(),
        svg: supportsSVG()
      };
    }
    return support;
  };
  staticAccessors2.current.get = function() {
    if (!instance) {
      instance = new SurfaceFactory2();
    }
    return instance;
  };
  SurfaceFactory2.prototype.create = function create2(element, options2) {
    var items = this._items;
    var match2 = items[0];
    if (options2 && options2.type) {
      var preferred = options2.type.toLowerCase();
      for (var i16 = 0; i16 < items.length; i16++) {
        if (items[i16].name === preferred) {
          match2 = items[i16];
          break;
        }
      }
    }
    if (match2) {
      return new match2.type(element, options2);
    }
    logToConsole(
      "Warning: Unable to create Kendo UI Drawing Surface. Possible causes:\n- The browser does not support SVG and Canvas. User agent: " + navigator.userAgent
    );
  };
  Object.defineProperties(SurfaceFactory2, staticAccessors2);
  return SurfaceFactory2;
}(Class$1);
const SurfaceFactory$1 = SurfaceFactory;
var Surface$1 = function(BaseSurface2) {
  function Surface2() {
    BaseSurface2.apply(this, arguments);
  }
  if (BaseSurface2)
    Surface2.__proto__ = BaseSurface2;
  Surface2.prototype = Object.create(BaseSurface2 && BaseSurface2.prototype);
  Surface2.prototype.constructor = Surface2;
  var staticAccessors2 = { support: { configurable: true } };
  staticAccessors2.support.get = function() {
    return SurfaceFactory$1.support;
  };
  Surface2.create = function create2(element, options2) {
    return SurfaceFactory$1.current.create(element, options2);
  };
  Object.defineProperties(Surface2, staticAccessors2);
  return Surface2;
}(BaseSurface);
const Surface$2 = Surface$1;
function alignPathToPixel(path) {
  var offset2 = 0.5;
  if (path.options.stroke && defined$1(path.options.stroke.width)) {
    if (path.options.stroke.width % 2 === 0) {
      offset2 = 0;
    }
  }
  for (var i16 = 0; i16 < path.segments.length; i16++) {
    path.segments[i16].anchor().round(0).translate(offset2, offset2);
  }
  return path;
}
function clockwise(angle1, angle2) {
  return -angle1.x * angle2.y + angle1.y * angle2.x < 0;
}
function isNumber(value2) {
  return typeof value2 === "number" && !isNaN(value2);
}
function isString$2(value2) {
  return typeof value2 === STRING$1;
}
function convertableToNumber(value2) {
  return isNumber(value2) || isString$2(value2) && isFinite(value2);
}
function cycleUp(index2, count) {
  return (index2 + 1) % count;
}
function cycleDown(index2, count) {
  var result = index2 - 1;
  return result < 0 ? count - 1 : result;
}
function cycleIndex(index2, length) {
  if (length === 1 || index2 % length === 0) {
    return 0;
  }
  if (index2 < 0) {
    return length + index2 % length;
  } else if (index2 >= length) {
    return index2 % length;
  }
  return index2;
}
function isFunction$1(fn) {
  return typeof fn === "function";
}
var OBJECT = "object";
var UNDEFINED = "undefined";
function deepExtendOne(destination, source) {
  for (var property in source) {
    if (property === "__proto__" || property === "constructor") {
      continue;
    }
    var propValue = source[property];
    var propType = typeof propValue;
    var propInit = void 0;
    if (propType === OBJECT && propValue !== null) {
      propInit = propValue.constructor;
    } else {
      propInit = null;
    }
    if (propInit && propInit !== Array) {
      if (propValue instanceof Date) {
        destination[property] = new Date(propValue.getTime());
      } else if (isFunction$1(propValue.clone)) {
        destination[property] = propValue.clone();
      } else {
        var destProp = destination[property];
        if (typeof destProp === OBJECT) {
          destination[property] = destProp || {};
        } else {
          destination[property] = {};
        }
        deepExtendOne(destination[property], propValue);
      }
    } else if (propType !== UNDEFINED) {
      destination[property] = propValue;
    }
  }
  return destination;
}
function deepExtend(destination) {
  var arguments$1 = arguments;
  var length = arguments.length;
  for (var i16 = 1; i16 < length; i16++) {
    deepExtendOne(destination, arguments$1[i16]);
  }
  return destination;
}
function isObject(value2) {
  return typeof value2 === "object";
}
function styleValue(value2) {
  if (isNumber(value2)) {
    return value2 + "px";
  }
  return value2;
}
var SIZE_STYLES_REGEX = /width|height|top|left|bottom|right/i;
function isSizeField(field) {
  return SIZE_STYLES_REGEX.test(field);
}
function elementStyles(element, styles) {
  var stylesArray = isString$2(styles) ? [styles] : styles;
  if (isArray$1(stylesArray)) {
    var result = {};
    var style2 = window.getComputedStyle(element);
    for (var idx = 0; idx < stylesArray.length; idx++) {
      var field = stylesArray[idx];
      result[field] = isSizeField(field) ? parseFloat(style2[field]) : style2[field];
    }
    return result;
  } else if (isObject(styles)) {
    for (var field$1 in styles) {
      element.style[field$1] = styleValue(styles[field$1]);
    }
  }
}
function getSpacing(value2, defaultSpacing) {
  if (defaultSpacing === void 0)
    defaultSpacing = 0;
  var spacing = { top: 0, right: 0, bottom: 0, left: 0 };
  if (typeof value2 === "number") {
    spacing[TOP] = spacing[RIGHT] = spacing[BOTTOM] = spacing[LEFT] = value2;
  } else {
    spacing[TOP] = value2[TOP] || defaultSpacing;
    spacing[RIGHT] = value2[RIGHT] || defaultSpacing;
    spacing[BOTTOM] = value2[BOTTOM] || defaultSpacing;
    spacing[LEFT] = value2[LEFT] || defaultSpacing;
  }
  return spacing;
}
var current$2 = {
  compile: function(template) {
    return template;
  }
};
var TemplateService = function TemplateService2() {
};
TemplateService.register = function register(userImplementation) {
  current$2 = userImplementation;
};
TemplateService.compile = function compile(template, options2) {
  return current$2.compile(template, options2);
};
function getTemplate$1(options2) {
  if (options2 === void 0)
    options2 = {};
  var template;
  if (options2.template) {
    options2.template = template = TemplateService.compile(options2.template);
  } else if (isFunction$1(options2.content)) {
    template = options2.content;
  }
  return template;
}
function getTemplate(options2) {
  if (options2 === void 0)
    options2 = {};
  var ariaTemplate;
  if (options2.ariaTemplate) {
    options2.ariaTemplate = ariaTemplate = TemplateService.compile(options2.ariaTemplate);
  } else if (isFunction$1(options2.ariaContent)) {
    ariaTemplate = options2.ariaContent;
  }
  return ariaTemplate;
}
var FIELD_REGEX$1 = /\[(?:(\d+)|['"](.*?)['"])\]|((?:(?!\[.*?\]|\.).)+)/g;
var getterCache$1 = {};
getterCache$1["undefined"] = function(obj) {
  return obj;
};
function getter$1(field) {
  if (getterCache$1[field]) {
    return getterCache$1[field];
  }
  var fields = [];
  field.replace(FIELD_REGEX$1, function(match2, index2, indexAccessor, field2) {
    fields.push(defined$1(index2) ? index2 : indexAccessor || field2);
  });
  getterCache$1[field] = function(obj) {
    var result = obj;
    for (var idx = 0; idx < fields.length && result; idx++) {
      result = result[fields[idx]];
    }
    return result;
  };
  return getterCache$1[field];
}
function grep(array, callback) {
  var length = array.length;
  var result = [];
  for (var idx = 0; idx < length; idx++) {
    if (callback(array[idx])) {
      result.push(array[idx]);
    }
  }
  return result;
}
function hasClasses(element, classNames2) {
  if (element.className) {
    var names = classNames2.split(" ");
    for (var idx = 0; idx < names.length; idx++) {
      if (element.className.indexOf && element.className.indexOf(names[idx]) !== -1) {
        return true;
      }
    }
  }
}
var HashMap = function HashMap2() {
  this._map = /* @__PURE__ */ new Map();
};
HashMap.prototype.get = function get(key) {
  return this._map.get(key);
};
HashMap.prototype.set = function set(key, value2) {
  this._map.set(key, value2);
};
function inArray(value2, array) {
  if (array) {
    return array.indexOf(value2) !== -1;
  }
}
function interpolateValue(start, end, progress) {
  return round$2(start + (end - start) * progress, COORD_PRECISION);
}
var TRIGGER = "trigger";
var InstanceObserver = function InstanceObserver2(observer, handlers) {
  this.observer = observer;
  this.handlerMap = deepExtend({}, this.handlerMap, handlers);
};
InstanceObserver.prototype.trigger = function trigger(name2, args) {
  var ref2 = this;
  var observer = ref2.observer;
  var handlerMap = ref2.handlerMap;
  var isDefaultPrevented2;
  if (handlerMap[name2]) {
    isDefaultPrevented2 = this.callObserver(handlerMap[name2], args);
  } else if (observer[TRIGGER]) {
    isDefaultPrevented2 = this.callObserver(TRIGGER, name2, args);
  }
  return isDefaultPrevented2;
};
InstanceObserver.prototype.callObserver = function callObserver(fnName) {
  var args = [], len = arguments.length - 1;
  while (len-- > 0)
    args[len] = arguments[len + 1];
  return this.observer[fnName].apply(this.observer, args);
};
InstanceObserver.prototype.requiresHandlers = function requiresHandlers(names) {
  var this$1$1 = this;
  if (this.observer.requiresHandlers) {
    return this.observer.requiresHandlers(names);
  }
  for (var idx = 0; idx < names.length; idx++) {
    if (this$1$1.handlerMap[names[idx]]) {
      return true;
    }
  }
};
function isPlainObject(value2) {
  return Object.prototype.toString.call(value2) === "[object Object]";
}
function map(array, callback) {
  var length = array.length;
  var result = [];
  for (var idx = 0; idx < length; idx++) {
    var value2 = callback(array[idx]);
    if (defined$1(value2)) {
      result.push(value2);
    }
  }
  return result;
}
var browser$1 = support$2.browser || {};
function mousewheelDelta(e3) {
  var delta = 0;
  if (e3.wheelDelta) {
    delta = -e3.wheelDelta / 120;
    if (browser$1.webkit) {
      delta = delta / (2 * Math.max(window.devicePixelRatio, 0.625));
    }
  } else if (e3.detail) {
    delta = e3.detail / 3;
  }
  delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);
  return delta;
}
var ref = util;
var append = ref.append;
var bindEvents = ref.bindEvents;
var defined = ref.defined;
var deg = ref.deg;
var elementOffset = ref.elementOffset;
var elementSize = ref.elementSize;
var eventCoordinates = ref.eventCoordinates;
var eventElement = ref.eventElement;
var hashKey = ref.hashKey;
var last = ref.last;
var limitValue = ref.limitValue;
var objectKey = ref.objectKey;
var rad = ref.rad;
var round$1 = ref.round;
var unbindEvents = ref.unbindEvents;
var valueOrDefault$1 = ref.valueOrDefault;
var FontLoader = function FontLoader2() {
};
FontLoader.fetchFonts = function fetchFonts(options2, fonts, state) {
  if (state === void 0)
    state = { depth: 0 };
  var MAX_DEPTH = 5;
  if (!options2 || state.depth > MAX_DEPTH || !document.fonts) {
    return;
  }
  Object.keys(options2).forEach(function(key) {
    var value2 = options2[key];
    if (key === "dataSource" || key[0] === "$" || !value2) {
      return;
    }
    if (key === "font") {
      fonts.push(value2);
    } else if (typeof value2 === "object") {
      state.depth++;
      FontLoader.fetchFonts(value2, fonts, state);
      state.depth--;
    }
  });
};
FontLoader.loadFonts = function loadFonts(fonts, callback) {
  var promises = [];
  if (fonts.length > 0 && document.fonts) {
    try {
      promises = fonts.map(function(font2) {
        return document.fonts.load(font2);
      });
    } catch (e3) {
      logToConsole(e3);
    }
    Promise.all(promises).then(callback, callback);
  } else {
    callback();
  }
};
FontLoader.preloadFonts = function preloadFonts(options2, callback) {
  var fonts = [];
  FontLoader.fetchFonts(options2, fonts);
  FontLoader.loadFonts(fonts, callback);
};
function setDefaultOptions(type, options2) {
  var proto = type.prototype;
  if (proto.options) {
    proto.options = deepExtend({}, proto.options, options2);
  } else {
    proto.options = options2;
  }
}
var KICON = "k-icon";
var KI_PREFFIX = "k-i-";
var KFONTICON = "k-font-icon";
var KSVGICON = "k-svg-icon";
var KSVG_PREFFIX = "k-svg-i-";
var HTMLBaseIcon = function HTMLBaseIcon2(element, options2) {
  this.element = element;
  this.options = deepExtend({}, this.options, options2);
  this.wrapper();
};
HTMLBaseIcon.prototype.wrapper = function wrapper() {
  this.addClasses();
};
HTMLBaseIcon.prototype.addClasses = function addClasses() {
};
HTMLBaseIcon.prototype.html = function html() {
  return this.element.outerHTML;
};
setDefaultOptions(HTMLBaseIcon, {
  name: "",
  size: "none",
  themeColor: "none",
  flip: "default",
  iconClass: "",
  stylingOptions: ["size", "themeColor", "fill"]
});
var HTMLFontIcon = function(HTMLBaseIcon3) {
  function HTMLFontIcon2(element, options2) {
    HTMLBaseIcon3.call(this, element, options2);
  }
  if (HTMLBaseIcon3)
    HTMLFontIcon2.__proto__ = HTMLBaseIcon3;
  HTMLFontIcon2.prototype = Object.create(HTMLBaseIcon3 && HTMLBaseIcon3.prototype);
  HTMLFontIcon2.prototype.constructor = HTMLFontIcon2;
  HTMLFontIcon2.prototype.wrapper = function wrapper2() {
    var currentIconClass = this.element.className.split(" ").find(function(x3) {
      return x3.startsWith(KI_PREFFIX);
    });
    var className = this.options.icon ? "" + (this.options.icon.startsWith(KI_PREFFIX) ? "" : KI_PREFFIX) + this.options.icon : "";
    this._className = className;
    addClass2(this.element, KICON);
    addClass2(this.element, KFONTICON);
    removeClass2(this.element, currentIconClass);
    addClass2(this.element, className);
    addClass2(this.element, this.options.iconClass || "");
    HTMLBaseIcon3.prototype.wrapper.call(this);
  };
  return HTMLFontIcon2;
}(HTMLBaseIcon);
setDefaultOptions(HTMLFontIcon, {
  name: "HTMLFontIcon",
  icon: null
});
var HTMLSvgIcon = function(HTMLBaseIcon3) {
  function HTMLSvgIcon2(element, options2) {
    element.innerHTML = "";
    HTMLBaseIcon3.call(this, element, options2);
  }
  if (HTMLBaseIcon3)
    HTMLSvgIcon2.__proto__ = HTMLBaseIcon3;
  HTMLSvgIcon2.prototype = Object.create(HTMLBaseIcon3 && HTMLBaseIcon3.prototype);
  HTMLSvgIcon2.prototype.constructor = HTMLSvgIcon2;
  HTMLSvgIcon2.prototype.wrapper = function wrapper2() {
    var icon = this.options.icon;
    var iconClass = this.options.iconClass;
    var currentIconClass = this.element.className.split(" ").find(function(x3) {
      return x3.startsWith(KSVG_PREFFIX);
    });
    if (!icon && iconClass) {
      var regex = /k-i-(\w+(?:-\w+)*)/;
      var iconNameMatch = iconClass.match(regex);
      if (iconNameMatch) {
        icon = iconNameMatch[1];
        iconClass = iconClass.replace(iconNameMatch[0], "");
      }
    }
    if (isString$2(icon)) {
      icon = icon.replace("k-i-", "").replace(/-./g, function(x3) {
        return x3[1].toUpperCase();
      });
      icon = this.options.svgIcons[icon] || this.options.svgIcons[icon + "Icon"];
    }
    var className = icon && icon.name ? "" + KSVG_PREFFIX + icon.name : "";
    this._className = className;
    addClass2(this.element, KSVGICON);
    removeClass2(this.element, currentIconClass);
    addClass2(this.element, className);
    addClass2(this.element, iconClass || "");
    this.element.setAttribute("aria-hidden", "true");
    if (icon && isPlainObject(icon)) {
      var svgElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svgElement.setAttribute("viewBox", icon.viewBox || "");
      svgElement.setAttribute("focusable", "false");
      svgElement.innerHTML = icon.content || "";
      this.element.appendChild(svgElement);
    }
    HTMLBaseIcon3.prototype.wrapper.call(this);
  };
  return HTMLSvgIcon2;
}(HTMLBaseIcon);
setDefaultOptions(HTMLSvgIcon, {
  name: "HTMLSvgIcon",
  icon: null,
  svgIcons: {}
});
var ICON_TYPES = {
  "svg": HTMLSvgIcon,
  "font": HTMLFontIcon
};
function renderIcon(iconElement, iconOptions) {
  var element = iconElement;
  var options2 = iconOptions;
  if (!element || isObject(element) && !(element instanceof HTMLElement) || isString$2(element)) {
    options2 = element;
    element = document.createElement("span");
  }
  if (isString$2(options2)) {
    options2 = {
      icon: options2
    };
  }
  if (!options2.type) {
    options2.type = "svg";
  }
  if (!ICON_TYPES[options2.type]) {
    return null;
  }
  return new ICON_TYPES[options2.type](element, options2).html();
}
function sparseArrayLimits(arr) {
  var min2 = MAX_VALUE;
  var max2 = MIN_VALUE;
  for (var idx = 0, length = arr.length; idx < length; idx++) {
    var value2 = arr[idx];
    if (value2 !== null && isFinite(value2)) {
      min2 = Math.min(min2, value2);
      max2 = Math.max(max2, value2);
    }
  }
  return {
    min: min2 === MAX_VALUE ? void 0 : min2,
    max: max2 === MIN_VALUE ? void 0 : max2
  };
}
function find(array, predicate) {
  for (var i16 = 0; i16 < array.length; i16++) {
    var item = array[i16];
    if (predicate(item, i16, array)) {
      return item;
    }
  }
}
var Matrix$1 = Matrix$3;
var matrixRegexp = /matrix\((.*)\)/;
function parseMatrix(matrixString) {
  var match2 = matrixString.match(matrixRegexp);
  if (match2 === null || match2.length !== 2) {
    return Matrix$1.unit();
  }
  var members = match2[1].split(",").map(function(x3) {
    return parseFloat(x3);
  });
  return new (Function.prototype.bind.apply(Matrix$1, [null].concat(members)))();
}
function transformMatrix(element) {
  var transform2 = getComputedStyle(element).transform;
  if (transform2 === "none") {
    return Matrix$1.unit();
  }
  return parseMatrix(transform2);
}
function elementScale(element) {
  if (!element) {
    return Matrix$1.unit();
  }
  var matrix = transformMatrix(element);
  var parent = element.parentElement;
  while (parent) {
    var parentMatrix = transformMatrix(parent);
    matrix = matrix.multiplyCopy(parentMatrix);
    parent = parent.parentElement;
  }
  matrix.b = matrix.c = matrix.e = matrix.f = 0;
  return matrix;
}
function autoTextColor(color) {
  var isDark = new m$e(color).isDark();
  if (isDark) {
    return WHITE$1;
  }
  return BLACK$1;
}
var DELETED = {};
var LegacySet = function LegacySet2(values6) {
  var this$1$1 = this;
  this._index = {};
  this._values = values6 ? values6.slice(0) : [];
  for (var i16 = 0; i16 < this._values.length; i16++) {
    this$1$1._index[this$1$1._values[i16]] = i16;
  }
};
var prototypeAccessors$2 = { size: { configurable: true } };
LegacySet.prototype.values = function values2() {
  return this._values.filter(function(item) {
    return item !== DELETED;
  });
};
LegacySet.prototype.has = function has(value2) {
  return this._index[value2] !== void 0;
};
LegacySet.prototype.add = function add(value2) {
  if (!this.has(value2)) {
    this._index[value2] = this._values.length;
    this._values.push(value2);
  }
};
LegacySet.prototype.delete = function delete$1(value2) {
  var index2 = this._index[value2];
  if (index2 !== void 0) {
    this._values[index2] = DELETED;
    delete this._index[value2];
  }
};
LegacySet.prototype.clear = function clear2() {
  this._index = {};
  this._values = [];
};
prototypeAccessors$2.size.get = function() {
  return this._values.length;
};
Object.defineProperties(LegacySet.prototype, prototypeAccessors$2);
var SetWrapper = function SetWrapper2(values6) {
  this._set = new Set(values6);
};
var prototypeAccessors$1$1 = { size: { configurable: true } };
SetWrapper.prototype.values = function values3() {
  return Array.from(this._set);
};
SetWrapper.prototype.has = function has2(value2) {
  return this._set.has(value2);
};
SetWrapper.prototype.add = function add2(value2) {
  this._set.add(value2);
};
SetWrapper.prototype.delete = function delete$2(value2) {
  this._set.delete(value2);
};
SetWrapper.prototype.clear = function clear3() {
  this._set.clear();
};
prototypeAccessors$1$1.size.get = function() {
  return this._set.size;
};
Object.defineProperties(SetWrapper.prototype, prototypeAccessors$1$1);
var supportsSet = function() {
  var supported = false;
  if (typeof Set === "function") {
    var set4 = /* @__PURE__ */ new Set([1]);
    supported = set4.has(1);
  }
  return supported;
};
function createHashSet(values6) {
  if (supportsSet()) {
    return new SetWrapper(values6);
  }
  return new LegacySet(values6);
}
function defaultErrorHandler(error2) {
  throw error2;
}
var keys = {
  INSERT: 45,
  DELETE: 46,
  BACKSPACE: 8,
  TAB: 9,
  ENTER: 13,
  ESC: 27,
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40,
  END: 35,
  HOME: 36,
  SPACEBAR: 32,
  PAGEUP: 33,
  PAGEDOWN: 34,
  F2: 113,
  F10: 121,
  F12: 123,
  NUMPAD_PLUS: 107,
  NUMPAD_MINUS: 109,
  NUMPAD_DOT: 110
};
function hasOwnProperty(obj, property) {
  return Object.prototype.hasOwnProperty.call(obj, property);
}
var Matrix = function Matrix2() {
  this.height = 0;
  this.width = 0;
  this.data = [];
};
Matrix.prototype.clone = function clone() {
  var m3 = new Matrix();
  m3.height = this.height;
  m3.width = this.width;
  m3.data = this.data.map(function(row) {
    return row.slice();
  });
  return m3;
};
Matrix.prototype.get = function get2(row, col) {
  var line = this.data[row];
  var val = line ? line[col] : null;
  return val;
};
Matrix.prototype.set = function set2(row, col, data2) {
  var line = this.data[row];
  if (line == null) {
    line = this.data[row] = [];
  }
  line[col] = data2;
  if (row >= this.height) {
    this.height = row + 1;
  }
  if (col >= this.width) {
    this.width = col + 1;
  }
};
Matrix.prototype.each = function each(f4, includeEmpty) {
  var this$1$1 = this;
  for (var row = 0; row < this.height; ++row) {
    for (var col = 0; col < this.width; ++col) {
      var val = this$1$1.get(row, col);
      if (includeEmpty || val != null) {
        val = f4(val, row, col);
        if (val !== void 0) {
          return val;
        }
      }
    }
  }
};
Matrix.prototype.map = function map2(f4, includeEmpty) {
  var m3 = new Matrix();
  this.each(function(el2, row, col) {
    m3.set(row, col, f4(el2, row, col));
  }, includeEmpty);
  return m3;
};
Matrix.prototype.transpose = function transpose() {
  var m3 = new Matrix();
  this.each(function(el2, row, col) {
    m3.set(col, row, el2);
  });
  return m3;
};
Matrix.prototype.unit = function unit(n10) {
  this.width = this.height = n10;
  var a9 = this.data = new Array(n10);
  for (var i16 = n10; --i16 >= 0; ) {
    var row = a9[i16] = new Array(n10);
    for (var j2 = n10; --j2 >= 0; ) {
      row[j2] = i16 === j2 ? 1 : 0;
    }
  }
  return this;
};
Matrix.prototype.multiply = function multiply(b2) {
  var a9 = this;
  var m3 = new Matrix();
  for (var row = 0; row < a9.height; ++row) {
    for (var col = 0; col < b2.width; ++col) {
      var s10 = 0;
      for (var i16 = 0; i16 < a9.width; ++i16) {
        var va2 = a9.get(row, i16);
        var vb2 = b2.get(i16, col);
        if (typeof va2 === "number" && typeof vb2 === "number") {
          s10 += va2 * vb2;
        }
      }
      m3.set(row, col, s10);
    }
  }
  return m3;
};
Matrix.prototype.inverse = function inverse() {
  var n10 = this.width;
  var m3 = this.augment(new Matrix().unit(n10));
  var a9 = m3.data;
  var loop = function(k4) {
    var imax = argmax(k4, n10, function(i17) {
      return a9[i17][k4];
    });
    if (!a9[imax][k4]) {
      return { v: null };
    }
    if (k4 !== imax) {
      var tmp = a9[k4];
      a9[k4] = a9[imax];
      a9[imax] = tmp;
    }
    for (var i16 = k4 + 1; i16 < n10; ++i16) {
      for (var j2 = k4 + 1; j2 < 2 * n10; ++j2) {
        a9[i16][j2] -= a9[k4][j2] * a9[i16][k4] / a9[k4][k4];
      }
      a9[i16][k4] = 0;
    }
  };
  for (var k3 = 0; k3 < n10; ++k3) {
    var returned = loop(k3);
    if (returned)
      return returned.v;
  }
  for (var i$12 = 0; i$12 < n10; ++i$12) {
    for (var f4 = a9[i$12][i$12], j$12 = 0; j$12 < 2 * n10; ++j$12) {
      a9[i$12][j$12] /= f4;
    }
  }
  for (var k$12 = n10; --k$12 >= 0; ) {
    for (var i$22 = k$12; --i$22 >= 0; ) {
      if (a9[i$22][k$12]) {
        for (var j$22 = 2 * n10; --j$22 >= n10; ) {
          a9[i$22][j$22] -= a9[k$12][j$22] * a9[i$22][k$12];
        }
      }
    }
  }
  return m3.slice(0, n10, n10, n10);
};
Matrix.prototype.augment = function augment(m3) {
  var ret = this.clone();
  var n10 = ret.width;
  m3.each(function(val, row, col) {
    ret.set(row, col + n10, val);
  });
  return ret;
};
Matrix.prototype.slice = function slice2(row, col, height, width) {
  var this$1$1 = this;
  var m3 = new Matrix();
  for (var i16 = 0; i16 < height; ++i16) {
    for (var j2 = 0; j2 < width; ++j2) {
      m3.set(i16, j2, this$1$1.get(row + i16, col + j2));
    }
  }
  return m3;
};
function argmax(start, end, f4) {
  var max2 = f4(start), pos = start;
  for (var i16 = start + 1; i16 < end; i16++) {
    var v3 = f4(start);
    if (v3 > max2) {
      max2 = v3;
      pos = start;
    }
  }
  return pos;
}
var eventMap = {
  down: "pointerdown",
  move: "pointermove",
  up: "pointerup",
  cancel: "pointercancel pointerleave"
};
function queryEventMap(e3) {
  return eventMap[e3] || e3;
}
var applyEventMap = function(events2) {
  var eventRegEx = /([^ ]+)/g;
  var appliedEvents = events2.replace(eventRegEx, queryEventMap);
  return appliedEvents;
};
function guid() {
  var id2 = "";
  var i16;
  var random;
  for (i16 = 0; i16 < 32; i16++) {
    random = Math.random() * 16 | 0;
    if (i16 === 8 || i16 === 12 || i16 === 16 || i16 === 20) {
      id2 += "-";
    }
    id2 += (i16 === 12 ? 4 : i16 === 16 ? random & 3 | 8 : random).toString(16);
  }
  return id2;
}
var elementEventHandlers = /* @__PURE__ */ new WeakMap();
var ID$1 = Symbol("id");
function on(element, events2, filter, handler, useCapture) {
  addEventListeners(element, events2, filter, handler, useCapture);
}
function off(element, events2, filter, handler, useCapture) {
  removeEventListeners(element, events2, filter, handler);
}
function isString$1(value2) {
  return typeof value2 === "string";
}
function addEventListeners(element, events2, filter, handler, useCapture) {
  var eventNames = isArray$1(events2) ? events2 : (events2 || "").split(" ");
  eventNames.forEach(function(eventName) {
    addEventListener(element, eventName, filter, handler, useCapture);
  });
}
function addEventListener(element, event, filter, handler, useCapture) {
  var eventHandler = handler;
  var eventFilter;
  if (filter && isFunction$1(filter) && !handler) {
    eventHandler = filter;
  } else if (filter && isString$1(filter) && isFunction$1(eventHandler)) {
    eventFilter = filter;
  }
  var attachedHandler = function(e3) {
    var closestMatchingTarget = e3.target ? e3.target.closest(eventFilter) : null;
    if (!eventFilter || eventFilter && e3.target && closestMatchingTarget) {
      var currentTarget = eventFilter ? closestMatchingTarget : e3.currentTarget;
      Object.defineProperty(e3, "currentTarget", { value: currentTarget });
      Object.defineProperty(e3, "delegateTarget", { value: element });
      eventHandler(e3);
    }
  };
  eventHandler[ID$1] = guid();
  var eventHandlers = elementEventHandlers.get(element);
  if (!eventHandlers) {
    eventHandlers = /* @__PURE__ */ new Map();
    elementEventHandlers.set(element, eventHandlers);
  }
  eventHandlers.set(eventHandler[ID$1], attachedHandler);
  element.addEventListener(event, attachedHandler, Boolean(useCapture));
}
function removeEventListeners(element, events2, handler, useCapture) {
  var eventNames = isArray$1(events2) ? events2 : (events2 || "").split(" ");
  eventNames.forEach(function(eventName) {
    removeEventListener(element, eventName, handler, useCapture);
  });
}
function removeEventListener(element, event, handler, useCapture) {
  var eventHandlers = elementEventHandlers.get(element);
  if (eventHandlers && handler && handler[ID$1]) {
    var handlerId = handler[ID$1];
    var attachedHandler = eventHandlers.get(handlerId);
    eventHandlers.delete(handlerId);
    if (attachedHandler) {
      element.removeEventListener(event, attachedHandler, Boolean(useCapture));
    }
  }
}
function getSupportedFeatures() {
  var os = detectOS(navigator.userAgent);
  var support2 = {};
  support2.mobileOS = os;
  return support2;
}
function detectOS(ua2) {
  var os = false;
  var agentRxs2 = {
    wp: /(Windows Phone(?: OS)?)\s(\d+)\.(\d+(\.\d+)?)/,
    fire: /(Silk)\/(\d+)\.(\d+(\.\d+)?)/,
    android: /(Android|Android.*(?:Opera|Firefox).*?\/)\s*(\d+)\.?(\d+(\.\d+)?)?/,
    iphone: /(iPhone|iPod).*OS\s+(\d+)[\._]([\d\._]+)/,
    ipad: /(iPad).*OS\s+(\d+)[\._]([\d_]+)/,
    playbook: /(PlayBook).*?Tablet\s*OS\s*(\d+)\.(\d+(\.\d+)?)/,
    windows: /(MSIE)\s+(\d+)\.(\d+(\.\d+)?)/,
    tizen: /(tizen).*?Version\/(\d+)\.(\d+(\.\d+)?)/i,
    sailfish: /(sailfish).*rv:(\d+)\.(\d+(\.\d+)?).*firefox/i
  }, osRxs2 = {
    ios: /^i(phone|pad|pod)$/i,
    android: /^android|fire$/i,
    windows: /windows/,
    wp: /wp/,
    flat: /sailfish|ffos|tizen/i
  };
  for (var agent in agentRxs2) {
    var match2 = ua2.match(agentRxs2[agent]);
    if (match2) {
      if (agent === "windows" && "plugins" in navigator) {
        return false;
      }
      os = {};
      os.device = agent;
      os.name = testRegex(agent, osRxs2);
      os[os.name] = true;
      break;
    }
  }
  return os;
}
function testRegex(agent, regexes, dflt) {
  for (var regex in regexes) {
    if (regexes[regex].test(agent)) {
      return regex;
    }
  }
  return dflt !== void 0 ? dflt : agent;
}
function noop2() {
}
function now() {
  return (/* @__PURE__ */ new Date()).getTime();
}
var STRING = "string";
var FUNCTION = "function";
var preventDefault$2 = function() {
  this._defaultPrevented = true;
};
var isDefaultPrevented = function() {
  return this._defaultPrevented === true;
};
var Observable = function(Class3) {
  function Observable2() {
    Class3.call(this);
    this._events = {};
  }
  if (Class3)
    Observable2.__proto__ = Class3;
  Observable2.prototype = Object.create(Class3 && Class3.prototype);
  Observable2.prototype.constructor = Observable2;
  Observable2.prototype.destroy = function destroy2() {
    this.unbind();
  };
  Observable2.prototype.bind = function bind(event, handlers, one) {
    var that = this, idx, eventNames = typeof event === STRING ? [event] : event || [], length, original, handler, handlersIsFunction = typeof handlers === FUNCTION, events2;
    if (handlers === void 0) {
      for (idx in event) {
        that.bind(idx, event[idx]);
      }
      return that;
    }
    var loop = function() {
      var eventName = eventNames[idx];
      handler = handlersIsFunction ? handlers : handlers[eventName];
      if (handler) {
        if (one) {
          original = handler;
          handler = function() {
            that.unbind(eventName, handler);
            original.apply(that, arguments);
          };
          handler.original = original;
        }
        events2 = that._events[eventName] = that._events[eventName] || [];
        events2.push(handler);
      }
    };
    for (idx = 0, length = eventNames.length; idx < length; idx++)
      loop();
    return that;
  };
  Observable2.prototype.one = function one(eventNames, handlers) {
    return this.bind(eventNames, handlers, true);
  };
  Observable2.prototype.first = function first(eventName, handlers) {
    var that = this, idx, eventNames = typeof eventName === STRING ? [eventName] : eventName, length, handler, handlersIsFunction = typeof handlers === FUNCTION, events2;
    for (idx = 0, length = eventNames.length; idx < length; idx++) {
      var eventName$1 = eventNames[idx];
      handler = handlersIsFunction ? handlers : handlers[eventName$1];
      if (handler) {
        events2 = that._events[eventName$1] = that._events[eventName$1] || [];
        events2.unshift(handler);
      }
    }
    return that;
  };
  Observable2.prototype.trigger = function trigger2(eventName, eventArgs) {
    var that = this, events2 = that._events[eventName], idx, length;
    if (events2) {
      var e3 = eventArgs || {};
      e3.sender = that;
      e3._defaultPrevented = false;
      e3.preventDefault = preventDefault$2;
      e3.isDefaultPrevented = isDefaultPrevented;
      events2 = events2.slice();
      for (idx = 0, length = events2.length; idx < length; idx++) {
        events2[idx].call(that, e3);
      }
      return e3._defaultPrevented === true;
    }
    return false;
  };
  Observable2.prototype.unbind = function unbind(eventName, handler) {
    var that = this, events2 = that._events[eventName], idx;
    if (eventName === void 0) {
      that._events = {};
    } else if (events2) {
      if (handler) {
        for (idx = events2.length - 1; idx >= 0; idx--) {
          if (events2[idx] === handler || events2[idx].original === handler) {
            events2.splice(idx, 1);
          }
        }
      } else {
        that._events[eventName] = [];
      }
    }
    return that;
  };
  Observable2.prototype._setEvents = function _setEvents(options2) {
    var this$1$1 = this;
    var length = (this.events || []).length;
    for (var idx = 0; idx < length; idx++) {
      var e3 = this$1$1.events[idx];
      if (this$1$1.options[e3] && options2[e3]) {
        this$1$1.unbind(e3, this$1$1.options[e3]);
        if (this$1$1._events && this$1$1._events[e3]) {
          delete this$1$1._events[e3];
        }
      }
    }
    this.bind(this.events, options2);
  };
  return Observable2;
}(Class$1);
var extend$d = Object.assign;
var preventDefault$1 = function(e3) {
  e3.preventDefault();
};
var DEFAULT_MIN_HOLD = 800, CLICK_DELAY = 300, DEFAULT_THRESHOLD = 0, PRESS = "press", HOLD = "hold", SELECT$1 = "select", START = "start", MOVE = "move", END = "end", CANCEL = "cancel", TAP = "tap", DOUBLETAP = "doubleTap", RELEASE = "release", GESTURESTART = "gesturestart", GESTURECHANGE = "gesturechange", GESTUREEND = "gestureend", GESTURETAP = "gesturetap";
var THRESHOLD = {
  "api": 0,
  "touch": 0,
  "mouse": 9,
  "pointer": 9
};
function touchDelta(touch1, touch2) {
  var x1 = touch1.x.location, y1 = touch1.y.location, x22 = touch2.x.location, y22 = touch2.y.location, dx = x1 - x22, dy = y1 - y22;
  return {
    center: {
      x: (x1 + x22) / 2,
      y: (y1 + y22) / 2
    },
    distance: Math.sqrt(dx * dx + dy * dy)
  };
}
function getTouches(e3) {
  var touches = [], originalEvent = e3.originalEvent || e3, currentTarget = e3.currentTarget;
  if (e3.api) {
    touches.push({
      id: 2,
      // hardcoded ID for API call
      event: e3,
      target: e3.target,
      currentTarget: e3.target,
      location: e3,
      type: "api"
    });
  } else {
    touches.push({
      location: originalEvent,
      event: e3,
      target: e3.target,
      currentTarget,
      id: originalEvent.pointerId,
      type: "pointer"
    });
  }
  return touches;
}
var TouchAxis = function(Class3) {
  function TouchAxis2(axis, location) {
    Class3.call(this);
    var that = this;
    that.support = getSupportedFeatures();
    that.invalidZeroEvents = this.support.mobileOS && this.support.mobileOS.android;
    that.axis = axis;
    that._updateLocationData(location);
    that.startLocation = that.location;
    that.velocity = that.delta = 0;
    that.timeStamp = now();
  }
  if (Class3)
    TouchAxis2.__proto__ = Class3;
  TouchAxis2.prototype = Object.create(Class3 && Class3.prototype);
  TouchAxis2.prototype.constructor = TouchAxis2;
  TouchAxis2.prototype.move = function move(location) {
    var that = this, offset2 = location["page" + that.axis], timeStamp = now(), timeDelta = timeStamp - that.timeStamp || 1;
    if (!offset2 && this.invalidZeroEvents) {
      return;
    }
    that.delta = offset2 - that.location;
    that._updateLocationData(location);
    that.initialDelta = offset2 - that.startLocation;
    that.velocity = that.delta / timeDelta;
    that.timeStamp = timeStamp;
  };
  TouchAxis2.prototype._updateLocationData = function _updateLocationData(location) {
    var that = this, axis = that.axis;
    that.location = location["page" + axis];
    that.client = location["client" + axis];
    that.screen = location["screen" + axis];
  };
  return TouchAxis2;
}(Class$1);
var Touch = function(Class3) {
  function Touch2(userEvents, target, touchInfo) {
    Class3.call(this);
    extend$d(this, {
      x: new TouchAxis("X", touchInfo.location),
      y: new TouchAxis("Y", touchInfo.location),
      type: touchInfo.type,
      threshold: userEvents.threshold || THRESHOLD[touchInfo.type],
      userEvents,
      target,
      currentTarget: touchInfo.currentTarget,
      initialTouch: touchInfo.target,
      id: touchInfo.id,
      pressEvent: touchInfo,
      _clicks: userEvents._clicks,
      supportDoubleTap: userEvents.supportDoubleTap,
      _moved: false,
      _finished: false
    });
  }
  if (Class3)
    Touch2.__proto__ = Class3;
  Touch2.prototype = Object.create(Class3 && Class3.prototype);
  Touch2.prototype.constructor = Touch2;
  Touch2.prototype.press = function press() {
    var this$1$1 = this;
    this._holdTimeout = setTimeout(function() {
      return this$1$1._hold();
    }, this.userEvents.minHold);
    this._trigger(PRESS, this.pressEvent);
  };
  Touch2.prototype._tap = function _tap(touchInfo) {
    var that = this;
    that.userEvents._clicks++;
    if (that.userEvents._clicks === 1) {
      that._clickTimeout = setTimeout(function() {
        if (that.userEvents._clicks === 1) {
          that._trigger(TAP, touchInfo);
        } else {
          that._trigger(DOUBLETAP, touchInfo);
        }
        that.userEvents._clicks = 0;
      }, CLICK_DELAY);
    }
  };
  Touch2.prototype._hold = function _hold() {
    this._trigger(HOLD, this.pressEvent);
  };
  Touch2.prototype.move = function move(touchInfo) {
    var that = this;
    var preventMove = touchInfo.type !== "api" && that.userEvents._shouldNotMove;
    if (that._finished || preventMove) {
      return;
    }
    that.x.move(touchInfo.location);
    that.y.move(touchInfo.location);
    if (!that._moved) {
      if (that._withinIgnoreThreshold()) {
        return;
      }
      if (!UserEvents.current || UserEvents.current === that.userEvents) {
        that._start(touchInfo);
      } else {
        return that.dispose();
      }
    }
    if (!that._finished) {
      that._trigger(MOVE, touchInfo);
    }
  };
  Touch2.prototype.end = function end(touchInfo) {
    this.endTime = now();
    if (this._finished) {
      return;
    }
    this._finished = true;
    this._trigger(RELEASE, touchInfo);
    if (this._moved) {
      this._trigger(END, touchInfo);
    } else {
      if (this.supportDoubleTap) {
        this._tap(touchInfo);
      } else {
        this._trigger(TAP, touchInfo);
      }
    }
    clearTimeout(this._holdTimeout);
    this.dispose();
  };
  Touch2.prototype.dispose = function dispose() {
    var userEvents = this.userEvents, activeTouches = userEvents.touches || [];
    this._finished = true;
    this.pressEvent = null;
    clearTimeout(this._holdTimeout);
    var activeTouchIndex = activeTouches.indexOf(this);
    activeTouches.splice(activeTouchIndex, 1);
  };
  Touch2.prototype.skip = function skip() {
    this.dispose();
  };
  Touch2.prototype.cancel = function cancel() {
    this.dispose();
  };
  Touch2.prototype.isMoved = function isMoved() {
    return this._moved;
  };
  Touch2.prototype._start = function _start(touchInfo) {
    clearTimeout(this._holdTimeout);
    this.startTime = now();
    this._moved = true;
    this._trigger(START, touchInfo);
  };
  Touch2.prototype._trigger = function _trigger(name2, touchInfo) {
    var e3 = touchInfo.event;
    var data2 = {
      touch: this,
      x: this.x,
      y: this.y,
      target: this.target,
      event: e3
    };
    if (this.userEvents.notify(name2, data2)) {
      e3.preventDefault();
    }
  };
  Touch2.prototype._withinIgnoreThreshold = function _withinIgnoreThreshold() {
    var xDelta = this.x.initialDelta, yDelta = this.y.initialDelta;
    return Math.sqrt(xDelta * xDelta + yDelta * yDelta) <= this.threshold;
  };
  return Touch2;
}(Class$1);
function withEachUpEvent(callback) {
  var downEvents = eventMap.up.split(" "), idx = 0, length = downEvents.length;
  for (; idx < length; idx++) {
    callback(downEvents[idx]);
  }
}
var UserEvents = function(Observable2) {
  function UserEvents2(element, options2) {
    Observable2.call(this);
    var that = this;
    var filter;
    var support2 = getSupportedFeatures();
    this.support = support2;
    options2 = options2 || {};
    this.options = options2;
    filter = that.filter = options2.filter;
    that.threshold = options2.threshold || DEFAULT_THRESHOLD;
    that.minHold = options2.minHold || DEFAULT_MIN_HOLD;
    that.touches = [];
    that._maxTouches = options2.multiTouch ? 2 : 1;
    that.allowSelection = options2.allowSelection;
    that.captureUpIfMoved = options2.captureUpIfMoved;
    that._clicks = 0;
    that.supportDoubleTap = options2.supportDoubleTap;
    extend$d(that, {
      element,
      surface: options2.surface || element,
      stopPropagation: options2.stopPropagation,
      pressed: false
    });
    this._surfaceMoveHandler = this._move.bind(this);
    on(that.surface, applyEventMap("move"), this._surfaceMoveHandler);
    this._surfaceEndHandler = this._end.bind(this);
    on(that.surface, applyEventMap("up cancel"), this._surfaceEndHandler);
    this._elementStartHandler = this._start.bind(this);
    on(element, applyEventMap("down"), filter, this._elementStartHandler);
    element.style["touch-action"] = options2.touchAction || "none";
    if (options2.preventDragEvent) {
      this._elementDragStartHandler = preventDefault$1;
      on(element, applyEventMap("dragstart"), this._elementDragStartHandler);
    }
    this._elementSelectHandler = this._select.bind(this);
    on(element, applyEventMap("mousedown"), filter, this._elementSelectHandler);
    if (that.captureUpIfMoved) {
      var surfaceElement = that.surface, preventIfMovingProxy = that.preventIfMoving.bind(that);
      withEachUpEvent(function(eventName) {
        surfaceElement.addEventListener(eventName, preventIfMovingProxy, true);
      });
    }
    that.bind([
      PRESS,
      HOLD,
      TAP,
      DOUBLETAP,
      START,
      MOVE,
      END,
      RELEASE,
      CANCEL,
      GESTURESTART,
      GESTURECHANGE,
      GESTUREEND,
      GESTURETAP,
      SELECT$1
    ], options2);
  }
  if (Observable2)
    UserEvents2.__proto__ = Observable2;
  UserEvents2.prototype = Object.create(Observable2 && Observable2.prototype);
  UserEvents2.prototype.constructor = UserEvents2;
  UserEvents2.prototype.preventIfMoving = function preventIfMoving(e3) {
    if (this._isMoved()) {
      e3.preventDefault();
    }
  };
  UserEvents2.prototype.destroy = function destroy2() {
    var that = this;
    var options2 = this.options;
    var element = this.element;
    if (that._destroyed) {
      return;
    }
    that._destroyed = true;
    if (that.captureUpIfMoved) {
      var surfaceElement = that.surface;
      withEachUpEvent(function(eventName) {
        surfaceElement.removeEventListener(eventName, that.preventIfMoving);
      });
    }
    off(that.surface, applyEventMap("move"), this._surfaceMoveHandler);
    off(that.surface, applyEventMap("up cancel"), this._surfaceEndHandler);
    off(element, applyEventMap("down"), this._elementStartHandler);
    if (options2.preventDragEvent) {
      off(element, applyEventMap("dragstart"), this._elementDragStartHandler);
    }
    off(element, applyEventMap("mousedown"), this._elementSelectHandler);
    that._disposeAll();
    that.unbind();
    delete that.surface;
    delete that.element;
    delete that.currentTarget;
  };
  UserEvents2.prototype.capture = function capture() {
    UserEvents2.current = this;
  };
  UserEvents2.prototype.cancel = function cancel() {
    this._disposeAll();
    this.trigger(CANCEL);
  };
  UserEvents2.prototype.notify = function notify3(event, data2) {
    var that = this, touches = that.touches;
    var eventName = event;
    if (this._isMultiTouch()) {
      switch (eventName) {
        case MOVE:
          eventName = GESTURECHANGE;
          break;
        case END:
          eventName = GESTUREEND;
          break;
        case TAP:
          eventName = GESTURETAP;
          break;
      }
      extend$d(data2, {
        touches
      }, touchDelta(touches[0], touches[1]));
    }
    return this.trigger(eventName, extend$d(data2, {
      type: eventName
    }));
  };
  UserEvents2.prototype.press = function press(x3, y4, target) {
    this._apiCall("_start", x3, y4, target);
  };
  UserEvents2.prototype.move = function move(x3, y4) {
    this._apiCall("_move", x3, y4);
  };
  UserEvents2.prototype.end = function end(x3, y4) {
    this._apiCall("_end", x3, y4);
  };
  UserEvents2.prototype._isMultiTouch = function _isMultiTouch() {
    return this.touches.length > 1;
  };
  UserEvents2.prototype._maxTouchesReached = function _maxTouchesReached() {
    return this.touches.length >= this._maxTouches;
  };
  UserEvents2.prototype._disposeAll = function _disposeAll() {
    var touches = this.touches;
    while (touches.length > 0) {
      touches.pop().dispose();
    }
  };
  UserEvents2.prototype._isMoved = function _isMoved() {
    return grep(this.touches, function(touch) {
      return touch.isMoved();
    }).length;
  };
  UserEvents2.prototype._select = function _select(e3) {
    if (!this.allowSelection || this.trigger(SELECT$1, { event: e3 })) {
      e3.preventDefault();
    }
  };
  UserEvents2.prototype._start = function _start(e3) {
    var this$1$1 = this;
    if (e3.which && e3.which > 1 || this._maxTouchesReached()) {
      return;
    }
    UserEvents2.current = null;
    this.currentTarget = e3.currentTarget;
    if (this.stopPropagation) {
      e3.stopPropagation();
    }
    var target;
    var eventTouches = getTouches(e3);
    for (var idx = 0; idx < eventTouches.length; idx++) {
      if (this$1$1._maxTouchesReached()) {
        break;
      }
      var eventTouch = eventTouches[idx];
      if (this$1$1.filter) {
        target = eventTouch.currentTarget;
      } else {
        target = this$1$1.element;
      }
      if (target && target.length === 0) {
        continue;
      }
      var touch = new Touch(this$1$1, target, eventTouch);
      this$1$1.touches.push(touch);
      touch.press();
      if (this$1$1._isMultiTouch()) {
        this$1$1.notify("gesturestart", {});
      }
    }
  };
  UserEvents2.prototype._move = function _move(e3) {
    this._eachTouch("move", e3);
  };
  UserEvents2.prototype._end = function _end(e3) {
    this._eachTouch("end", e3);
  };
  UserEvents2.prototype._eachTouch = function _eachTouch(methodName, e3) {
    var this$1$1 = this;
    var that = this, dict = {}, touches = getTouches(e3), activeTouches = that.touches, idx, touch, touchInfo, matchingTouch;
    for (idx = 0; idx < activeTouches.length; idx++) {
      touch = activeTouches[idx];
      dict[touch.id] = touch;
    }
    for (idx = 0; idx < touches.length; idx++) {
      touchInfo = touches[idx];
      matchingTouch = dict[touchInfo.id];
      if (matchingTouch) {
        var shouldCapture = methodName === "move" && touchInfo.type === "pointer" && !this$1$1.surface.hasPointerCapture(touchInfo.id);
        if (shouldCapture) {
          this$1$1.surface.setPointerCapture(touchInfo.id);
        }
        matchingTouch[methodName](touchInfo);
      }
    }
  };
  UserEvents2.prototype._apiCall = function _apiCall(type, x3, y4, target) {
    this[type]({
      api: true,
      pageX: x3,
      pageY: y4,
      clientX: x3,
      clientY: y4,
      target: target || this.element,
      stopPropagation: noop2,
      preventDefault: noop2
    });
  };
  UserEvents2.defaultThreshold = function defaultThreshold(value2) {
    DEFAULT_THRESHOLD = value2;
  };
  UserEvents2.minHold = function minHold(value2) {
    DEFAULT_MIN_HOLD = value2;
  };
  return UserEvents2;
}(Observable);
function autoMajorUnit(min2, max2) {
  var diff = round$1(max2 - min2, DEFAULT_PRECISION - 1);
  if (diff === 0) {
    if (max2 === 0) {
      return 0.1;
    }
    diff = Math.abs(max2);
  }
  var scale = Math.pow(10, Math.floor(Math.log(diff) / Math.log(10)));
  var relativeValue = round$1(diff / scale, DEFAULT_PRECISION);
  var scaleMultiplier = 1;
  if (relativeValue < 1.904762) {
    scaleMultiplier = 0.2;
  } else if (relativeValue < 4.761904) {
    scaleMultiplier = 0.5;
  } else if (relativeValue < 9.523809) {
    scaleMultiplier = 1;
  } else {
    scaleMultiplier = 2;
  }
  return round$1(scale * scaleMultiplier, DEFAULT_PRECISION);
}
var Point$5 = function(Class3) {
  function Point2(x3, y4) {
    Class3.call(this);
    this.x = x3 || 0;
    this.y = y4 || 0;
  }
  if (Class3)
    Point2.__proto__ = Class3;
  Point2.prototype = Object.create(Class3 && Class3.prototype);
  Point2.prototype.constructor = Point2;
  Point2.prototype.clone = function clone3() {
    return new Point2(this.x, this.y);
  };
  Point2.prototype.equals = function equals(point2) {
    return point2 && this.x === point2.x && this.y === point2.y;
  };
  Point2.prototype.rotate = function rotate(center, degrees) {
    var theta = rad(degrees);
    var cosT = Math.cos(theta);
    var sinT = Math.sin(theta);
    var cx = center.x;
    var cy = center.y;
    var ref2 = this;
    var x3 = ref2.x;
    var y4 = ref2.y;
    this.x = round$1(
      cx + (x3 - cx) * cosT + (y4 - cy) * sinT,
      COORD_PRECISION
    );
    this.y = round$1(
      cy + (y4 - cy) * cosT - (x3 - cx) * sinT,
      COORD_PRECISION
    );
    return this;
  };
  Point2.prototype.multiply = function multiply2(a9) {
    this.x *= a9;
    this.y *= a9;
    return this;
  };
  Point2.prototype.distanceTo = function distanceTo(point2) {
    var dx = this.x - point2.x;
    var dy = this.y - point2.y;
    return Math.sqrt(dx * dx + dy * dy);
  };
  Point2.onCircle = function onCircle(center, angle, radius) {
    var radians = rad(angle);
    return new Point2(
      center.x - radius * Math.cos(radians),
      center.y - radius * Math.sin(radians)
    );
  };
  return Point2;
}(Class$1);
var Box = function(Class3) {
  function Box2(x1, y1, x22, y22) {
    Class3.call(this);
    this.x1 = x1 || 0;
    this.y1 = y1 || 0;
    this.x2 = x22 || 0;
    this.y2 = y22 || 0;
  }
  if (Class3)
    Box2.__proto__ = Class3;
  Box2.prototype = Object.create(Class3 && Class3.prototype);
  Box2.prototype.constructor = Box2;
  Box2.prototype.equals = function equals(box) {
    return this.x1 === box.x1 && this.x2 === box.x2 && this.y1 === box.y1 && this.y2 === box.y2;
  };
  Box2.prototype.width = function width() {
    return this.x2 - this.x1;
  };
  Box2.prototype.height = function height() {
    return this.y2 - this.y1;
  };
  Box2.prototype.translate = function translate2(dx, dy) {
    this.x1 += dx;
    this.x2 += dx;
    this.y1 += dy;
    this.y2 += dy;
    return this;
  };
  Box2.prototype.move = function move(x3, y4) {
    var height = this.height();
    var width = this.width();
    if (defined(x3)) {
      this.x1 = x3;
      this.x2 = this.x1 + width;
    }
    if (defined(y4)) {
      this.y1 = y4;
      this.y2 = this.y1 + height;
    }
    return this;
  };
  Box2.prototype.wrap = function wrap(targetBox) {
    this.x1 = Math.min(this.x1, targetBox.x1);
    this.y1 = Math.min(this.y1, targetBox.y1);
    this.x2 = Math.max(this.x2, targetBox.x2);
    this.y2 = Math.max(this.y2, targetBox.y2);
    return this;
  };
  Box2.prototype.wrapPoint = function wrapPoint(point2) {
    var arrayPoint = isArray$1(point2);
    var x3 = arrayPoint ? point2[0] : point2.x;
    var y4 = arrayPoint ? point2[1] : point2.y;
    this.wrap(new Box2(x3, y4, x3, y4));
    return this;
  };
  Box2.prototype.snapTo = function snapTo(targetBox, axis) {
    if (axis === X$4 || !axis) {
      this.x1 = targetBox.x1;
      this.x2 = targetBox.x2;
    }
    if (axis === Y$7 || !axis) {
      this.y1 = targetBox.y1;
      this.y2 = targetBox.y2;
    }
    return this;
  };
  Box2.prototype.alignTo = function alignTo(targetBox, anchor) {
    var height = this.height();
    var width = this.width();
    var axis = anchor === TOP || anchor === BOTTOM ? Y$7 : X$4;
    var offset2 = axis === Y$7 ? height : width;
    if (anchor === CENTER) {
      var targetCenter = targetBox.center();
      var center = this.center();
      this.x1 += targetCenter.x - center.x;
      this.y1 += targetCenter.y - center.y;
    } else if (anchor === TOP || anchor === LEFT) {
      this[axis + 1] = targetBox[axis + 1] - offset2;
    } else {
      this[axis + 1] = targetBox[axis + 2];
    }
    this.x2 = this.x1 + width;
    this.y2 = this.y1 + height;
    return this;
  };
  Box2.prototype.shrink = function shrink(dw, dh2) {
    this.x2 -= dw;
    this.y2 -= dh2;
    return this;
  };
  Box2.prototype.expand = function expand(dw, dh2) {
    this.shrink(-dw, -dh2);
    return this;
  };
  Box2.prototype.pad = function pad2(padding) {
    var spacing = getSpacing(padding);
    this.x1 -= spacing.left;
    this.x2 += spacing.right;
    this.y1 -= spacing.top;
    this.y2 += spacing.bottom;
    return this;
  };
  Box2.prototype.unpad = function unpad2(padding) {
    var spacing = getSpacing(padding);
    spacing.left = -spacing.left;
    spacing.top = -spacing.top;
    spacing.right = -spacing.right;
    spacing.bottom = -spacing.bottom;
    return this.pad(spacing);
  };
  Box2.prototype.clone = function clone3() {
    return new Box2(this.x1, this.y1, this.x2, this.y2);
  };
  Box2.prototype.center = function center() {
    return new Point$5(
      this.x1 + this.width() / 2,
      this.y1 + this.height() / 2
    );
  };
  Box2.prototype.containsPoint = function containsPoint(point2) {
    return point2.x >= this.x1 && point2.x <= this.x2 && point2.y >= this.y1 && point2.y <= this.y2;
  };
  Box2.prototype.points = function points2() {
    return [
      new Point$5(this.x1, this.y1),
      new Point$5(this.x2, this.y1),
      new Point$5(this.x2, this.y2),
      new Point$5(this.x1, this.y2)
    ];
  };
  Box2.prototype.getHash = function getHash() {
    return [this.x1, this.y1, this.x2, this.y2].join(",");
  };
  Box2.prototype.overlaps = function overlaps(box) {
    return !(box.y2 < this.y1 || this.y2 < box.y1 || box.x2 < this.x1 || this.x2 < box.x1);
  };
  Box2.prototype.rotate = function rotate(rotation) {
    var width = this.width();
    var height = this.height();
    var ref2 = this.center();
    var cx = ref2.x;
    var cy = ref2.y;
    var r1 = rotatePoint(0, 0, cx, cy, rotation);
    var r22 = rotatePoint(width, 0, cx, cy, rotation);
    var r32 = rotatePoint(width, height, cx, cy, rotation);
    var r42 = rotatePoint(0, height, cx, cy, rotation);
    width = Math.max(r1.x, r22.x, r32.x, r42.x) - Math.min(r1.x, r22.x, r32.x, r42.x);
    height = Math.max(r1.y, r22.y, r32.y, r42.y) - Math.min(r1.y, r22.y, r32.y, r42.y);
    this.x2 = this.x1 + width;
    this.y2 = this.y1 + height;
    return this;
  };
  Box2.prototype.toRect = function toRect() {
    return new Rect$1([this.x1, this.y1], [this.width(), this.height()]);
  };
  Box2.prototype.hasSize = function hasSize() {
    return this.width() !== 0 && this.height() !== 0;
  };
  Box2.prototype.align = function align2(targetBox, axis, alignment) {
    var c1 = axis + 1;
    var c22 = axis + 2;
    var sizeFunc = axis === X$4 ? WIDTH : HEIGHT;
    var size = this[sizeFunc]();
    if (inArray(alignment, [LEFT, TOP])) {
      this[c1] = targetBox[c1];
      this[c22] = this[c1] + size;
    } else if (inArray(alignment, [RIGHT, BOTTOM])) {
      this[c22] = targetBox[c22];
      this[c1] = this[c22] - size;
    } else if (alignment === CENTER) {
      this[c1] = targetBox[c1] + (targetBox[sizeFunc]() - size) / 2;
      this[c22] = this[c1] + size;
    }
  };
  return Box2;
}(Class$1);
function rotatePoint(x3, y4, cx, cy, angle) {
  var theta = rad(angle);
  return new Point$5(
    cx + (x3 - cx) * Math.cos(theta) + (y4 - cy) * Math.sin(theta),
    cy - (x3 - cx) * Math.sin(theta) + (y4 - cy) * Math.cos(theta)
  );
}
var Ring = function(Class3) {
  function Ring2(center, innerRadius, radius, startAngle, angle) {
    Class3.call(this);
    this.center = center;
    this.innerRadius = innerRadius;
    this.radius = radius;
    this.startAngle = startAngle;
    this.angle = angle;
  }
  if (Class3)
    Ring2.__proto__ = Class3;
  Ring2.prototype = Object.create(Class3 && Class3.prototype);
  Ring2.prototype.constructor = Ring2;
  Ring2.prototype.clone = function clone3() {
    return new Ring2(this.center, this.innerRadius, this.radius, this.startAngle, this.angle);
  };
  Ring2.prototype.middle = function middle() {
    return this.startAngle + this.angle / 2;
  };
  Ring2.prototype.setRadius = function setRadius(newRadius, innerRadius) {
    if (innerRadius) {
      this.innerRadius = newRadius;
    } else {
      this.radius = newRadius;
    }
    return this;
  };
  Ring2.prototype.point = function point2(angle, innerRadius) {
    var radianAngle = rad(angle);
    var ax = Math.cos(radianAngle);
    var ay = Math.sin(radianAngle);
    var radius = innerRadius ? this.innerRadius : this.radius;
    var x3 = round$1(this.center.x - ax * radius, COORD_PRECISION);
    var y4 = round$1(this.center.y - ay * radius, COORD_PRECISION);
    return new Point$5(x3, y4);
  };
  Ring2.prototype.adjacentBox = function adjacentBox(distance, width, height) {
    var sector = this.clone().expand(distance);
    var midAndle = sector.middle();
    var midPoint = sector.point(midAndle);
    var hw = width / 2;
    var hh2 = height / 2;
    var sa2 = Math.sin(rad(midAndle));
    var ca2 = Math.cos(rad(midAndle));
    var x3 = midPoint.x - hw;
    var y4 = midPoint.y - hh2;
    if (Math.abs(sa2) < 0.9) {
      x3 += hw * -ca2 / Math.abs(ca2);
    }
    if (Math.abs(ca2) < 0.9) {
      y4 += hh2 * -sa2 / Math.abs(sa2);
    }
    return new Box(x3, y4, x3 + width, y4 + height);
  };
  Ring2.prototype.containsPoint = function containsPoint(p6) {
    var center = this.center;
    var innerRadius = this.innerRadius;
    var radius = this.radius;
    var startAngle = this.startAngle;
    var endAngle = this.startAngle + this.angle;
    var dx = p6.x - center.x;
    var dy = p6.y - center.y;
    var vector = new Point$5(dx, dy);
    var startPoint = this.point(startAngle);
    var startVector = new Point$5(startPoint.x - center.x, startPoint.y - center.y);
    var endPoint = this.point(endAngle);
    var endVector = new Point$5(endPoint.x - center.x, endPoint.y - center.y);
    var dist = round$1(dx * dx + dy * dy, COORD_PRECISION);
    return (startVector.equals(vector) || clockwise(startVector, vector)) && !clockwise(endVector, vector) && dist >= innerRadius * innerRadius && dist <= radius * radius;
  };
  Ring2.prototype.getBBox = function getBBox() {
    var this$1$1 = this;
    var box = new Box(MAX_VALUE, MAX_VALUE, MIN_VALUE, MIN_VALUE);
    var startAngle = round$1(this.startAngle % 360);
    var endAngle = round$1((startAngle + this.angle) % 360);
    var innerRadius = this.innerRadius;
    var allAngles = [0, 90, 180, 270, startAngle, endAngle].sort(numericComparer);
    var startAngleIndex = allAngles.indexOf(startAngle);
    var endAngleIndex = allAngles.indexOf(endAngle);
    var angles;
    if (startAngle === endAngle) {
      angles = allAngles;
    } else {
      if (startAngleIndex < endAngleIndex) {
        angles = allAngles.slice(startAngleIndex, endAngleIndex + 1);
      } else {
        angles = [].concat(
          allAngles.slice(0, endAngleIndex + 1),
          allAngles.slice(startAngleIndex, allAngles.length)
        );
      }
    }
    for (var i16 = 0; i16 < angles.length; i16++) {
      var point2 = this$1$1.point(angles[i16]);
      box.wrapPoint(point2);
      box.wrapPoint(point2, innerRadius);
    }
    if (!innerRadius) {
      box.wrapPoint(this.center);
    }
    return box;
  };
  Ring2.prototype.expand = function expand(value2) {
    this.radius += value2;
    return this;
  };
  return Ring2;
}(Class$1);
function numericComparer(a9, b2) {
  return a9 - b2;
}
(function(Ring2) {
  function Sector(center, radius, startAngle, angle) {
    Ring2.call(this, center, 0, radius, startAngle, angle);
  }
  if (Ring2)
    Sector.__proto__ = Ring2;
  Sector.prototype = Object.create(Ring2 && Ring2.prototype);
  Sector.prototype.constructor = Sector;
  Sector.prototype.expand = function expand(value2) {
    return Ring2.prototype.expand.call(this, value2);
  };
  Sector.prototype.clone = function clone3() {
    return new Sector(this.center, this.radius, this.startAngle, this.angle);
  };
  Sector.prototype.setRadius = function setRadius(newRadius) {
    this.radius = newRadius;
    return this;
  };
  return Sector;
})(Ring);
var DIRECTION_ANGLE = 1e-3;
var ShapeBuilder = function(Class3) {
  function ShapeBuilder2() {
    Class3.apply(this, arguments);
  }
  if (Class3)
    ShapeBuilder2.__proto__ = Class3;
  ShapeBuilder2.prototype = Object.create(Class3 && Class3.prototype);
  ShapeBuilder2.prototype.constructor = ShapeBuilder2;
  ShapeBuilder2.prototype.createRing = function createRing(sector, options2) {
    var startAngle = sector.startAngle + 180;
    var endAngle = sector.angle + startAngle;
    if (sector.angle === 0 || sector.angle > 0 && startAngle === endAngle) {
      endAngle += DIRECTION_ANGLE;
    }
    var center = new Point$7(sector.center.x, sector.center.y);
    var radius = Math.max(sector.radius, 0);
    var innerRadius = Math.max(sector.innerRadius, 0);
    var arc = new GeometryArc(center, {
      startAngle,
      endAngle,
      radiusX: radius,
      radiusY: radius
    });
    var path = Path$7.fromArc(arc, options2).close();
    if (innerRadius) {
      arc.radiusX = arc.radiusY = innerRadius;
      var innerEnd = arc.pointAt(endAngle);
      path.lineTo(innerEnd.x, innerEnd.y);
      path.arc(endAngle, startAngle, innerRadius, innerRadius, true);
    } else {
      path.lineTo(center.x, center.y);
    }
    return path;
  };
  return ShapeBuilder2;
}(Class$1);
ShapeBuilder.current = new ShapeBuilder();
var ChartElement = function(Class3) {
  function ChartElement2(options2) {
    Class3.call(this);
    this.children = [];
    this.options = deepExtend({}, this.options, this.initUserOptions(options2));
  }
  if (Class3)
    ChartElement2.__proto__ = Class3;
  ChartElement2.prototype = Object.create(Class3 && Class3.prototype);
  ChartElement2.prototype.constructor = ChartElement2;
  ChartElement2.prototype.initUserOptions = function initUserOptions(options2) {
    return options2;
  };
  ChartElement2.prototype.reflow = function reflow(targetBox) {
    var children = this.children;
    var box;
    for (var i16 = 0; i16 < children.length; i16++) {
      var currentChild = children[i16];
      currentChild.reflow(targetBox);
      box = box ? box.wrap(currentChild.box) : currentChild.box.clone();
    }
    this.box = box || targetBox;
  };
  ChartElement2.prototype.destroy = function destroy2() {
    var children = this.children;
    if (this.animation) {
      this.animation.destroy();
    }
    for (var i16 = 0; i16 < children.length; i16++) {
      children[i16].destroy();
    }
  };
  ChartElement2.prototype.getRoot = function getRoot() {
    var parent = this.parent;
    return parent ? parent.getRoot() : null;
  };
  ChartElement2.prototype.getSender = function getSender() {
    var service = this.getService();
    if (service) {
      return service.sender;
    }
  };
  ChartElement2.prototype.getService = function getService() {
    var element = this;
    while (element) {
      if (element.chartService) {
        return element.chartService;
      }
      element = element.parent;
    }
  };
  ChartElement2.prototype.translateChildren = function translateChildren(dx, dy) {
    var children = this.children;
    var childrenCount = children.length;
    for (var i16 = 0; i16 < childrenCount; i16++) {
      children[i16].box.translate(dx, dy);
    }
  };
  ChartElement2.prototype.append = function append2() {
    var arguments$1 = arguments;
    var this$1$1 = this;
    for (var i16 = 0; i16 < arguments.length; i16++) {
      var item = arguments$1[i16];
      this$1$1.children.push(item);
      item.parent = this$1$1;
    }
  };
  ChartElement2.prototype.renderVisual = function renderVisual() {
    if (this.options.visible === false) {
      return;
    }
    this.createVisual();
    this.addVisual();
    this.renderChildren();
    this.createAnimation();
    this.renderComplete();
  };
  ChartElement2.prototype.addVisual = function addVisual() {
    if (this.visual) {
      this.visual.chartElement = this;
      if (this.parent) {
        this.parent.appendVisual(this.visual);
      }
    }
  };
  ChartElement2.prototype.renderChildren = function renderChildren() {
    var children = this.children;
    var length = children.length;
    for (var i16 = 0; i16 < length; i16++) {
      children[i16].renderVisual();
    }
  };
  ChartElement2.prototype.createVisual = function createVisual() {
    this.visual = new Group$9({
      zIndex: this.options.zIndex,
      visible: valueOrDefault$1(this.options.visible, true)
    });
  };
  ChartElement2.prototype.createAnimation = function createAnimation() {
    if (this.visual && this.options.animation) {
      this.animation = Animation$2.create(
        this.visual,
        this.options.animation
      );
    }
  };
  ChartElement2.prototype.appendVisual = function appendVisual(childVisual) {
    if (!childVisual.chartElement) {
      childVisual.chartElement = this;
    }
    if (childVisual.options.noclip) {
      this.clipRoot().visual.append(childVisual);
    } else if (defined(childVisual.options.zIndex)) {
      this.stackRoot().stackVisual(childVisual);
    } else if (this.isStackRoot) {
      this.stackVisual(childVisual);
    } else if (this.visual) {
      this.visual.append(childVisual);
    } else {
      this.parent.appendVisual(childVisual);
    }
  };
  ChartElement2.prototype.clipRoot = function clipRoot() {
    if (this.parent) {
      return this.parent.clipRoot();
    }
    return this;
  };
  ChartElement2.prototype.stackRoot = function stackRoot() {
    if (this.parent) {
      return this.parent.stackRoot();
    }
    return this;
  };
  ChartElement2.prototype.stackVisual = function stackVisual(childVisual) {
    var zIndex2 = childVisual.options.zIndex || 0;
    var visuals = this.visual.children;
    var length = visuals.length;
    var pos;
    for (pos = 0; pos < length; pos++) {
      var sibling = visuals[pos];
      var here = valueOrDefault$1(sibling.options.zIndex, 0);
      if (here > zIndex2) {
        break;
      }
    }
    this.visual.insert(pos, childVisual);
  };
  ChartElement2.prototype.traverse = function traverse(callback) {
    var children = this.children;
    var length = children.length;
    for (var i16 = 0; i16 < length; i16++) {
      var child = children[i16];
      callback(child);
      if (child.traverse) {
        child.traverse(callback);
      }
    }
  };
  ChartElement2.prototype.closest = function closest(match2) {
    var element = this;
    var matched = false;
    while (element && !matched) {
      matched = match2(element);
      if (!matched) {
        element = element.parent;
      }
    }
    if (matched) {
      return element;
    }
  };
  ChartElement2.prototype.renderComplete = function renderComplete() {
  };
  ChartElement2.prototype.hasHighlight = function hasHighlight() {
    var options2 = (this.options || {}).highlight;
    return !(!this.createHighlight || options2 && options2.visible === false || this.visible === false);
  };
  ChartElement2.prototype.toggleHighlight = function toggleHighlight(show2, opacity) {
    var this$1$1 = this;
    var options2 = (this.options || {}).highlight || {};
    var customVisual = options2.visual;
    var highlight = this._highlight;
    if (!highlight) {
      var highlightOptions2 = {
        fill: {
          color: WHITE$1,
          opacity: opacity || 0.2
        },
        stroke: {
          color: WHITE$1,
          width: 1,
          opacity: opacity || 0.2
        }
      };
      if (customVisual) {
        highlight = this._highlight = customVisual(
          Object.assign(this.highlightVisualArgs(), {
            createVisual: function() {
              return this$1$1.createHighlight(highlightOptions2);
            },
            sender: this.getSender(),
            series: this.series,
            dataItem: this.dataItem,
            category: this.category,
            value: this.value,
            percentage: this.percentage,
            runningTotal: this.runningTotal,
            total: this.total
          })
        );
        if (!highlight) {
          return;
        }
      } else {
        highlight = this._highlight = this.createHighlight(highlightOptions2);
      }
      if (!defined(highlight.options.zIndex)) {
        highlight.options.zIndex = valueOrDefault$1(options2.zIndex, this.options.zIndex);
      }
      this.appendVisual(highlight);
    }
    highlight.visible(show2);
  };
  ChartElement2.prototype.toggleFocusHighlight = function toggleFocusHighlight(show2) {
    var options2 = ((this.options || {}).accessibility || {}).highlight || {};
    var focusHighlight = this._focusHighlight;
    if (!show2 && !focusHighlight) {
      return;
    }
    if (!focusHighlight) {
      var rootBackground = this.getRoot().options.background;
      var highlightColor = autoTextColor(rootBackground);
      var focusHighlightOptions = {
        fill: {
          opacity: options2.opacity,
          color: options2.color
        },
        stroke: Object.assign({}, { color: highlightColor }, options2.border),
        zIndex: options2.zIndex
      };
      focusHighlight = this._focusHighlight = this.createFocusHighlight(focusHighlightOptions);
      this.appendVisual(focusHighlight);
    }
    focusHighlight.visible(show2);
  };
  ChartElement2.prototype.createGradientOverlay = function createGradientOverlay(element, options2, gradientOptions) {
    var overlay = new Path$7(Object.assign({
      stroke: {
        color: "none"
      },
      fill: this.createGradient(gradientOptions),
      closed: element.options.closed
    }, options2));
    overlay.segments.elements(element.segments.elements());
    return overlay;
  };
  ChartElement2.prototype.createGradient = function createGradient(options2) {
    if (this.parent) {
      return this.parent.createGradient(options2);
    }
  };
  ChartElement2.prototype.supportsPointInactiveOpacity = function supportsPointInactiveOpacity() {
    return true;
  };
  return ChartElement2;
}(Class$1);
ChartElement.prototype.options = {};
var BoxElement = function(ChartElement2) {
  function BoxElement2(options2) {
    ChartElement2.call(this, options2);
    this.options.margin = getSpacing(this.options.margin);
    this.options.padding = getSpacing(this.options.padding);
  }
  if (ChartElement2)
    BoxElement2.__proto__ = ChartElement2;
  BoxElement2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  BoxElement2.prototype.constructor = BoxElement2;
  BoxElement2.prototype.reflow = function reflow(targetBox) {
    var this$1$1 = this;
    var options2 = this.options;
    var width = options2.width;
    var height = options2.height;
    var shrinkToFit = options2.shrinkToFit;
    var hasSetSize = width && height;
    var margin = options2.margin;
    var padding = options2.padding;
    var borderWidth = options2.border.width;
    var box;
    var reflowPaddingBox = function() {
      this$1$1.align(targetBox, X$4, options2.align);
      this$1$1.align(targetBox, Y$7, options2.vAlign);
      this$1$1.paddingBox = box.clone().unpad(margin).unpad(borderWidth);
    };
    var contentBox = targetBox.clone();
    if (hasSetSize) {
      contentBox.x2 = contentBox.x1 + width;
      contentBox.y2 = contentBox.y1 + height;
    }
    if (shrinkToFit) {
      contentBox.unpad(margin).unpad(borderWidth).unpad(padding);
    }
    ChartElement2.prototype.reflow.call(this, contentBox);
    if (hasSetSize) {
      box = this.box = new Box(0, 0, width, height);
    } else {
      box = this.box;
    }
    if (shrinkToFit && hasSetSize) {
      reflowPaddingBox();
      contentBox = this.contentBox = this.paddingBox.clone().unpad(padding);
    } else {
      contentBox = this.contentBox = box.clone();
      box.pad(padding).pad(borderWidth).pad(margin);
      reflowPaddingBox();
    }
    this.translateChildren(
      box.x1 - contentBox.x1 + margin.left + borderWidth + padding.left,
      box.y1 - contentBox.y1 + margin.top + borderWidth + padding.top
    );
    var children = this.children;
    for (var i16 = 0; i16 < children.length; i16++) {
      var item = children[i16];
      item.reflow(item.box);
    }
  };
  BoxElement2.prototype.align = function align2(targetBox, axis, alignment) {
    this.box.align(targetBox, axis, alignment);
  };
  BoxElement2.prototype.hasBox = function hasBox() {
    var options2 = this.options;
    return options2.border.width || options2.background;
  };
  BoxElement2.prototype.createVisual = function createVisual() {
    ChartElement2.prototype.createVisual.call(this);
    var options2 = this.options;
    if (options2.visible && this.hasBox()) {
      this.visual.append(Path$7.fromRect(
        this.paddingBox.toRect(),
        this.visualStyle()
      ));
    }
  };
  BoxElement2.prototype.visualStyle = function visualStyle() {
    var options2 = this.options;
    var border = options2.border || {};
    return {
      stroke: {
        width: border.width,
        color: border.color,
        opacity: valueOrDefault$1(border.opacity, options2.opacity),
        dashType: border.dashType
      },
      fill: {
        color: options2.background,
        opacity: options2.opacity
      },
      cursor: options2.cursor
    };
  };
  return BoxElement2;
}(ChartElement);
setDefaultOptions(BoxElement, {
  align: LEFT,
  vAlign: TOP,
  margin: {},
  padding: {},
  border: {
    color: BLACK$1,
    width: 0
  },
  background: "",
  shrinkToFit: false,
  width: 0,
  height: 0,
  visible: true
});
function addAccessibilityAttributesToVisual(visual, accessibilityOptions) {
  if (accessibilityOptions) {
    visual.options.className = accessibilityOptions.className;
    visual.options.role = accessibilityOptions.role;
    visual.options.ariaLabel = accessibilityOptions.ariaLabel;
    visual.options.ariaRoleDescription = accessibilityOptions.ariaRoleDescription;
    visual.options.ariaChecked = accessibilityOptions.ariaChecked;
  }
}
var ShapeElement = function(BoxElement2) {
  function ShapeElement2(options2, pointData) {
    BoxElement2.call(this, options2);
    this.pointData = pointData;
  }
  if (BoxElement2)
    ShapeElement2.__proto__ = BoxElement2;
  ShapeElement2.prototype = Object.create(BoxElement2 && BoxElement2.prototype);
  ShapeElement2.prototype.constructor = ShapeElement2;
  ShapeElement2.prototype.getElement = function getElement() {
    var ref2 = this;
    var options2 = ref2.options;
    var box = ref2.paddingBox;
    var type = options2.type;
    var rotation = options2.rotation;
    var center = box.center();
    var halfWidth = box.width() / 2;
    var halfHeight = box.height() / 2;
    if (!options2.visible || !this.hasBox()) {
      return null;
    }
    var style2 = this.visualStyle();
    var element;
    if (type === CIRCLE) {
      element = new Circle$3(
        new geomCircle([
          round$1(box.x1 + halfWidth, COORD_PRECISION),
          round$1(box.y1 + halfHeight, COORD_PRECISION)
        ], Math.min(halfWidth, halfHeight)),
        style2
      );
    } else if (type === TRIANGLE) {
      element = Path$7.fromPoints([
        [box.x1 + halfWidth, box.y1],
        [box.x1, box.y2],
        [box.x2, box.y2]
      ], style2).close();
    } else if (type === CROSS) {
      element = new MultiPath(style2);
      element.moveTo(box.x1, box.y1).lineTo(box.x2, box.y2);
      element.moveTo(box.x1, box.y2).lineTo(box.x2, box.y1);
    } else {
      var rect = box.toRect();
      if (type === ROUNDED_RECT) {
        var borderRadius = valueOrDefault$1(options2.borderRadius, rect.width() / 5);
        rect.setCornerRadius(borderRadius);
      }
      element = Path$7.fromRect(rect, style2);
    }
    if (rotation) {
      element.transform(
        transform().rotate(-rotation, [center.x, center.y])
      );
    }
    element.options.zIndex = options2.zIndex;
    return element;
  };
  ShapeElement2.prototype.createElement = function createElement() {
    var this$1$1 = this;
    var customVisual = this.options.visual;
    var pointData = this.pointData || {};
    var visual;
    if (customVisual) {
      visual = customVisual({
        value: pointData.value,
        dataItem: pointData.dataItem,
        sender: this.getSender(),
        series: pointData.series,
        category: pointData.category,
        rect: this.paddingBox.toRect(),
        options: this.visualOptions(),
        createVisual: function() {
          return this$1$1.getElement();
        }
      });
    } else {
      visual = this.getElement();
    }
    return visual;
  };
  ShapeElement2.prototype.visualOptions = function visualOptions() {
    var options2 = this.options;
    return {
      background: options2.background,
      border: options2.border,
      margin: options2.margin,
      padding: options2.padding,
      type: options2.type,
      size: options2.width,
      visible: options2.visible
    };
  };
  ShapeElement2.prototype.createVisual = function createVisual() {
    this.visual = this.createElement();
    addAccessibilityAttributesToVisual(this.visual, this.options.accessibilityOptions);
  };
  return ShapeElement2;
}(BoxElement);
setDefaultOptions(ShapeElement, {
  type: CIRCLE,
  align: CENTER,
  vAlign: CENTER
});
var LINEAR$1 = "linear";
var RADIAL = "radial";
var GRADIENTS = {
  glass: {
    type: LINEAR$1,
    rotation: 0,
    stops: [{
      offset: 0,
      color: WHITE$1,
      opacity: 0
    }, {
      offset: 0.25,
      color: WHITE$1,
      opacity: 0.3
    }, {
      offset: 1,
      color: WHITE$1,
      opacity: 0
    }]
  },
  sharpBevel: {
    type: RADIAL,
    stops: [{
      offset: 0,
      color: WHITE$1,
      opacity: 0.55
    }, {
      offset: 0.65,
      color: WHITE$1,
      opacity: 0
    }, {
      offset: 0.95,
      color: WHITE$1,
      opacity: 0.25
    }]
  },
  roundedBevel: {
    type: RADIAL,
    stops: [{
      offset: 0.33,
      color: WHITE$1,
      opacity: 0.06
    }, {
      offset: 0.83,
      color: WHITE$1,
      opacity: 0.2
    }, {
      offset: 0.95,
      color: WHITE$1,
      opacity: 0
    }]
  },
  roundedGlass: {
    type: RADIAL,
    supportVML: false,
    stops: [{
      offset: 0,
      color: WHITE$1,
      opacity: 0
    }, {
      offset: 0.5,
      color: WHITE$1,
      opacity: 0.3
    }, {
      offset: 0.99,
      color: WHITE$1,
      opacity: 0
    }]
  },
  sharpGlass: {
    type: RADIAL,
    supportVML: false,
    stops: [{
      offset: 0,
      color: WHITE$1,
      opacity: 0.2
    }, {
      offset: 0.15,
      color: WHITE$1,
      opacity: 0.15
    }, {
      offset: 0.17,
      color: WHITE$1,
      opacity: 0.35
    }, {
      offset: 0.85,
      color: WHITE$1,
      opacity: 0.05
    }, {
      offset: 0.87,
      color: WHITE$1,
      opacity: 0.15
    }, {
      offset: 0.99,
      color: WHITE$1,
      opacity: 0
    }]
  },
  bubbleShadow: {
    type: RADIAL,
    center: [0.5, 0.5],
    radius: 0.5
  }
};
function boxDiff(r12, s10) {
  if (r12.x1 === s10.x1 && r12.y1 === s10.y1 && r12.x2 === s10.x2 && r12.y2 === s10.y2) {
    return s10;
  }
  var a9 = Math.min(r12.x1, s10.x1);
  var b2 = Math.max(r12.x1, s10.x1);
  var c6 = Math.min(r12.x2, s10.x2);
  var d8 = Math.max(r12.x2, s10.x2);
  var e3 = Math.min(r12.y1, s10.y1);
  var f4 = Math.max(r12.y1, s10.y1);
  var g6 = Math.min(r12.y2, s10.y2);
  var h3 = Math.max(r12.y2, s10.y2);
  var boxes = [];
  boxes[0] = new Box(b2, e3, c6, f4);
  boxes[1] = new Box(a9, f4, b2, g6);
  boxes[2] = new Box(c6, f4, d8, g6);
  boxes[3] = new Box(b2, g6, c6, h3);
  if (r12.x1 === a9 && r12.y1 === e3 || s10.x1 === a9 && s10.y1 === e3) {
    boxes[4] = new Box(a9, e3, b2, f4);
    boxes[5] = new Box(c6, g6, d8, h3);
  } else {
    boxes[4] = new Box(c6, e3, d8, f4);
    boxes[5] = new Box(a9, g6, b2, h3);
  }
  return grep(boxes, function(box) {
    return box.height() > 0 && box.width() > 0;
  })[0];
}
var RootElement = function(ChartElement2) {
  function RootElement2(options2) {
    ChartElement2.call(this, options2);
    var rootOptions = this.options;
    rootOptions.width = parseInt(rootOptions.width, 10);
    rootOptions.height = parseInt(rootOptions.height, 10);
    this.gradients = {};
  }
  if (ChartElement2)
    RootElement2.__proto__ = ChartElement2;
  RootElement2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  RootElement2.prototype.constructor = RootElement2;
  RootElement2.prototype.reflow = function reflow() {
    var ref2 = this;
    var options2 = ref2.options;
    var children = ref2.children;
    var currentBox = new Box(0, 0, options2.width, options2.height);
    this.box = currentBox.unpad(options2.margin);
    for (var i16 = 0; i16 < children.length; i16++) {
      children[i16].reflow(currentBox);
      currentBox = boxDiff(currentBox, children[i16].box) || new Box();
    }
  };
  RootElement2.prototype.createVisual = function createVisual() {
    this.visual = new Group$9();
    this.createBackground();
  };
  RootElement2.prototype.createBackground = function createBackground() {
    var options2 = this.options;
    var border = options2.border || {};
    var box = this.box.clone().pad(options2.margin).unpad(border.width);
    var background = Path$7.fromRect(box.toRect(), {
      stroke: {
        color: border.width ? border.color : "",
        width: border.width,
        dashType: border.dashType
      },
      fill: {
        color: options2.background,
        opacity: options2.opacity
      },
      zIndex: -10
    });
    this.visual.append(background);
  };
  RootElement2.prototype.getRoot = function getRoot() {
    return this;
  };
  RootElement2.prototype.createGradient = function createGradient(options2) {
    var gradients = this.gradients;
    var hashCode = objectKey(options2);
    var gradient = GRADIENTS[options2.gradient];
    var drawingGradient;
    if (gradients[hashCode]) {
      drawingGradient = gradients[hashCode];
    } else {
      var gradientOptions = Object.assign({}, gradient, options2);
      if (gradient.type === "linear") {
        drawingGradient = new LinearGradient$1(gradientOptions);
      } else {
        if (options2.innerRadius) {
          gradientOptions.stops = innerRadialStops(gradientOptions);
        }
        drawingGradient = new RadialGradient$1(gradientOptions);
        drawingGradient.supportVML = gradient.supportVML !== false;
      }
      gradients[hashCode] = drawingGradient;
    }
    return drawingGradient;
  };
  RootElement2.prototype.cleanGradients = function cleanGradients() {
    var gradients = this.gradients;
    for (var hashCode in gradients) {
      gradients[hashCode]._observers = [];
    }
  };
  RootElement2.prototype.size = function size() {
    var options2 = this.options;
    return new Box(0, 0, options2.width, options2.height);
  };
  return RootElement2;
}(ChartElement);
setDefaultOptions(RootElement, {
  width: DEFAULT_WIDTH$1,
  height: DEFAULT_HEIGHT$1,
  background: WHITE$1,
  border: {
    color: BLACK$1,
    width: 0
  },
  margin: getSpacing(5),
  zIndex: -2
});
function innerRadialStops(options2) {
  var stops = options2.stops;
  var usedSpace = options2.innerRadius / options2.radius * 100;
  var length = stops.length;
  var currentStops = [];
  for (var i16 = 0; i16 < length; i16++) {
    var currentStop = Object.assign({}, stops[i16]);
    currentStop.offset = (currentStop.offset * (100 - usedSpace) + usedSpace) / 100;
    currentStops.push(currentStop);
  }
  return currentStops;
}
var FloatElement = function(ChartElement2) {
  function FloatElement2(options2) {
    ChartElement2.call(this, options2);
    this._initDirection();
  }
  if (ChartElement2)
    FloatElement2.__proto__ = ChartElement2;
  FloatElement2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  FloatElement2.prototype.constructor = FloatElement2;
  FloatElement2.prototype._initDirection = function _initDirection() {
    var options2 = this.options;
    if (options2.vertical) {
      this.groupAxis = X$4;
      this.elementAxis = Y$7;
      this.groupSizeField = WIDTH;
      this.elementSizeField = HEIGHT;
      this.groupSpacing = options2.spacing;
      this.elementSpacing = options2.vSpacing;
    } else {
      this.groupAxis = Y$7;
      this.elementAxis = X$4;
      this.groupSizeField = HEIGHT;
      this.elementSizeField = WIDTH;
      this.groupSpacing = options2.vSpacing;
      this.elementSpacing = options2.spacing;
    }
  };
  FloatElement2.prototype.reflow = function reflow(targetBox) {
    this.box = targetBox.clone();
    this.reflowChildren();
  };
  FloatElement2.prototype.reflowChildren = function reflowChildren() {
    var this$1$1 = this;
    var ref2 = this;
    var box = ref2.box;
    var elementAxis = ref2.elementAxis;
    var groupAxis = ref2.groupAxis;
    var elementSizeField = ref2.elementSizeField;
    var groupSizeField = ref2.groupSizeField;
    var ref$1 = this.groupOptions();
    var groups = ref$1.groups;
    var groupsSize = ref$1.groupsSize;
    var maxGroupElementsSize = ref$1.maxGroupElementsSize;
    var groupsCount = groups.length;
    var groupsStart = box[groupAxis + 1] + this.alignStart(groupsSize, box[groupSizeField]());
    if (groupsCount) {
      var groupStart = groupsStart;
      for (var groupIdx = 0; groupIdx < groupsCount; groupIdx++) {
        var group2 = groups[groupIdx];
        var groupElements = group2.groupElements;
        var elementStart = box[elementAxis + 1];
        var groupElementsCount = groupElements.length;
        for (var idx = 0; idx < groupElementsCount; idx++) {
          var element = groupElements[idx];
          var elementSize2 = this$1$1.elementSize(element);
          var groupElementStart = groupStart + this$1$1.alignStart(elementSize2[groupSizeField], group2.groupSize);
          var elementBox = new Box();
          elementBox[groupAxis + 1] = groupElementStart;
          elementBox[groupAxis + 2] = groupElementStart + elementSize2[groupSizeField];
          elementBox[elementAxis + 1] = elementStart;
          elementBox[elementAxis + 2] = elementStart + elementSize2[elementSizeField];
          element.reflow(elementBox);
          elementStart += elementSize2[elementSizeField] + this$1$1.elementSpacing;
        }
        groupStart += group2.groupSize + this$1$1.groupSpacing;
      }
      box[groupAxis + 1] = groupsStart;
      box[groupAxis + 2] = groupsStart + groupsSize;
      box[elementAxis + 2] = box[elementAxis + 1] + maxGroupElementsSize;
    }
  };
  FloatElement2.prototype.alignStart = function alignStart2(size, maxSize) {
    var start = 0;
    var align2 = this.options.align;
    if (align2 === RIGHT || align2 === BOTTOM) {
      start = maxSize - size;
    } else if (align2 === CENTER) {
      start = (maxSize - size) / 2;
    }
    return start;
  };
  FloatElement2.prototype.groupOptions = function groupOptions() {
    var this$1$1 = this;
    var ref2 = this;
    var box = ref2.box;
    var children = ref2.children;
    var elementSizeField = ref2.elementSizeField;
    var groupSizeField = ref2.groupSizeField;
    var elementSpacing = ref2.elementSpacing;
    var groupSpacing = ref2.groupSpacing;
    var maxSize = round$1(box[elementSizeField]());
    var childrenCount = children.length;
    var groups = [];
    var groupSize = 0;
    var groupElementsSize = 0;
    var groupsSize = 0;
    var maxGroupElementsSize = 0;
    var groupElements = [];
    for (var idx = 0; idx < childrenCount; idx++) {
      var element = children[idx];
      if (!element.box) {
        element.reflow(box);
      }
      var elementSize2 = this$1$1.elementSize(element);
      if (this$1$1.options.wrap && round$1(groupElementsSize + elementSpacing + elementSize2[elementSizeField]) > maxSize) {
        groups.push({
          groupElements,
          groupSize,
          groupElementsSize
        });
        maxGroupElementsSize = Math.max(maxGroupElementsSize, groupElementsSize);
        groupsSize += groupSpacing + groupSize;
        groupSize = 0;
        groupElementsSize = 0;
        groupElements = [];
      }
      groupSize = Math.max(groupSize, elementSize2[groupSizeField]);
      if (groupElementsSize > 0) {
        groupElementsSize += elementSpacing;
      }
      groupElementsSize += elementSize2[elementSizeField];
      groupElements.push(element);
    }
    groups.push({
      groupElements,
      groupSize,
      groupElementsSize
    });
    maxGroupElementsSize = Math.max(maxGroupElementsSize, groupElementsSize);
    groupsSize += groupSize;
    return {
      groups,
      groupsSize,
      maxGroupElementsSize
    };
  };
  FloatElement2.prototype.elementSize = function elementSize2(element) {
    return {
      width: element.box.width(),
      height: element.box.height()
    };
  };
  FloatElement2.prototype.createVisual = function createVisual() {
  };
  return FloatElement2;
}(ChartElement);
setDefaultOptions(FloatElement, {
  vertical: true,
  wrap: true,
  vSpacing: 0,
  spacing: 0
});
var DrawingText = Text$4;
var Text$2 = function(ChartElement2) {
  function Text2(content, options2) {
    ChartElement2.call(this, options2);
    this.content = content;
    this.reflow(new Box());
  }
  if (ChartElement2)
    Text2.__proto__ = ChartElement2;
  Text2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  Text2.prototype.constructor = Text2;
  Text2.prototype.reflow = function reflow(targetBox) {
    var options2 = this.options;
    var size = options2.size = measureText(this.content, { font: options2.font });
    this.baseline = size.baseline;
    this.box = new Box(
      targetBox.x1,
      targetBox.y1,
      targetBox.x1 + size.width,
      targetBox.y1 + size.height
    );
  };
  Text2.prototype.createVisual = function createVisual() {
    var ref2 = this.options;
    var font2 = ref2.font;
    var color = ref2.color;
    var opacity = ref2.opacity;
    var cursor = ref2.cursor;
    var stroke = ref2.stroke;
    var paintOrder = ref2.paintOrder;
    this.visual = new DrawingText(this.content, this.box.toRect().topLeft(), {
      font: font2,
      fill: { color, opacity },
      cursor,
      stroke,
      paintOrder
    });
  };
  return Text2;
}(ChartElement);
setDefaultOptions(Text$2, {
  font: DEFAULT_FONT$1,
  color: BLACK$1
});
function rectToBox(rect) {
  var origin = rect.origin;
  var bottomRight = rect.bottomRight();
  return new Box(origin.x, origin.y, bottomRight.x, bottomRight.y);
}
var ROWS_SPLIT_REGEX = /\n/m;
var TextBox = function(BoxElement2) {
  function TextBox2(content, options2, data2) {
    BoxElement2.call(this, options2);
    this.content = content;
    this.data = data2;
    this._initContainer();
    if (this.options._autoReflow !== false) {
      this.reflow(new Box());
    }
  }
  if (BoxElement2)
    TextBox2.__proto__ = BoxElement2;
  TextBox2.prototype = Object.create(BoxElement2 && BoxElement2.prototype);
  TextBox2.prototype.constructor = TextBox2;
  TextBox2.prototype._initContainer = function _initContainer() {
    var options2 = this.options;
    var rows = String(this.content).split(ROWS_SPLIT_REGEX);
    var floatElement = new FloatElement({ vertical: true, align: options2.align, wrap: false });
    var textOptions = deepExtend({}, options2, { opacity: 1, animation: null });
    this.container = floatElement;
    this.append(floatElement);
    for (var rowIdx = 0; rowIdx < rows.length; rowIdx++) {
      var text = new Text$2(rows[rowIdx].trim(), textOptions);
      floatElement.append(text);
    }
  };
  TextBox2.prototype.reflow = function reflow(targetBox) {
    var options2 = this.options;
    var visualFn = options2.visual;
    this.container.options.align = options2.align;
    if (visualFn && !this._boxReflow) {
      var visualBox = targetBox;
      if (!visualBox.hasSize()) {
        this._boxReflow = true;
        this.reflow(visualBox);
        this._boxReflow = false;
        visualBox = this.box;
      }
      var visual = this.visual = visualFn(this.visualContext(visualBox));
      if (visual) {
        visualBox = rectToBox(visual.clippedBBox() || new Rect$1());
        visual.options.zIndex = options2.zIndex;
      }
      this.box = this.contentBox = this.paddingBox = visualBox;
    } else {
      BoxElement2.prototype.reflow.call(this, targetBox);
      if (options2.rotation) {
        var margin = getSpacing(options2.margin);
        var box = this.box.unpad(margin);
        this.targetBox = targetBox;
        this.normalBox = box.clone();
        box = this.rotate();
        box.translate(margin.left - margin.right, margin.top - margin.bottom);
        this.rotatedBox = box.clone();
        box.pad(margin);
      }
    }
  };
  TextBox2.prototype.createVisual = function createVisual() {
    var options2 = this.options;
    this.visual = new Group$9({
      transform: this.rotationTransform(),
      zIndex: options2.zIndex,
      noclip: options2.noclip
    });
    if (this.hasBox()) {
      var box = Path$7.fromRect(this.paddingBox.toRect(), this.visualStyle());
      this.visual.append(box);
    }
  };
  TextBox2.prototype.renderVisual = function renderVisual() {
    if (!this.options.visible) {
      return;
    }
    if (this.options.visual) {
      var visual = this.visual;
      if (visual && !defined(visual.options.noclip)) {
        visual.options.noclip = this.options.noclip;
      }
      this.addVisual();
      this.createAnimation();
    } else {
      BoxElement2.prototype.renderVisual.call(this);
    }
  };
  TextBox2.prototype.visualContext = function visualContext(targetBox) {
    var this$1$1 = this;
    var context2 = {
      text: this.content,
      rect: targetBox.toRect(),
      sender: this.getSender(),
      options: this.options,
      createVisual: function() {
        this$1$1._boxReflow = true;
        this$1$1.reflow(targetBox);
        this$1$1._boxReflow = false;
        return this$1$1.getDefaultVisual();
      }
    };
    if (this.data) {
      Object.assign(context2, this.data);
    }
    return context2;
  };
  TextBox2.prototype.getDefaultVisual = function getDefaultVisual() {
    this.createVisual();
    this.renderChildren();
    var visual = this.visual;
    delete this.visual;
    return visual;
  };
  TextBox2.prototype.rotate = function rotate() {
    var options2 = this.options;
    this.box.rotate(options2.rotation);
    this.align(this.targetBox, X$4, options2.align);
    this.align(this.targetBox, Y$7, options2.vAlign);
    return this.box;
  };
  TextBox2.prototype.rotationTransform = function rotationTransform() {
    var rotation = this.options.rotation;
    if (!rotation) {
      return null;
    }
    var ref2 = this.normalBox.center();
    var cx = ref2.x;
    var cy = ref2.y;
    var boxCenter = this.rotatedBox.center();
    return transform().translate(boxCenter.x - cx, boxCenter.y - cy).rotate(rotation, [cx, cy]);
  };
  return TextBox2;
}(BoxElement);
var Title$1 = function(ChartElement2) {
  function Title2(options2) {
    ChartElement2.call(this, options2);
    this._textBox = new TextBox(this.options.text, Object.assign({}, this.options, {
      vAlign: this.options.position
    }));
    this.append(this._textBox);
  }
  if (ChartElement2)
    Title2.__proto__ = ChartElement2;
  Title2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  Title2.prototype.constructor = Title2;
  Title2.prototype.reflow = function reflow(targetBox) {
    ChartElement2.prototype.reflow.call(this, targetBox);
    this.box.snapTo(targetBox, X$4);
  };
  Title2.buildTitle = function buildTitle(options2, defaultOptions) {
    var titleOptions = options2;
    if (typeof options2 === "string") {
      titleOptions = { text: options2 };
    }
    titleOptions = Object.assign({ visible: true }, defaultOptions, titleOptions);
    var title2;
    if (titleOptions && titleOptions.visible && titleOptions.text) {
      title2 = new Title2(titleOptions);
    }
    return title2;
  };
  Title2.orderTitles = function orderTitles(titles) {
    var items = [].concat(titles);
    var top = items.filter(function(item) {
      return item && item.options.position !== BOTTOM;
    });
    var bottom = items.filter(function(item) {
      return item && item.options.position === BOTTOM;
    });
    collapseVerticalMargins(top);
    collapseVerticalMargins(bottom);
    bottom.reverse();
    return top.concat(bottom);
  };
  return Title2;
}(ChartElement);
function collapseVerticalMargins(items) {
  for (var i16 = 1; i16 < items.length; i16++) {
    var box = items[i16]._textBox;
    var prevBox = items[i16 - 1]._textBox;
    prevBox.options.margin = Object.assign(getSpacing(prevBox.options.margin), { bottom: 0 });
    box.options.margin = Object.assign(getSpacing(box.options.margin), { top: 0 });
  }
}
setDefaultOptions(Title$1, {
  color: BLACK$1,
  position: TOP,
  align: CENTER,
  margin: getSpacing(5),
  padding: getSpacing(5)
});
var AxisLabel = function(TextBox2) {
  function AxisLabel2(value2, text, index2, dataItem, options2) {
    TextBox2.call(this, text, options2);
    this.text = text;
    this.value = value2;
    this.index = index2;
    this.dataItem = dataItem;
    this.reflow(new Box());
  }
  if (TextBox2)
    AxisLabel2.__proto__ = TextBox2;
  AxisLabel2.prototype = Object.create(TextBox2 && TextBox2.prototype);
  AxisLabel2.prototype.constructor = AxisLabel2;
  AxisLabel2.prototype.visualContext = function visualContext(targetBox) {
    var context2 = TextBox2.prototype.visualContext.call(this, targetBox);
    context2.value = this.value;
    context2.dataItem = this.dataItem;
    context2.format = this.options.format;
    context2.culture = this.options.culture;
    return context2;
  };
  AxisLabel2.prototype.click = function click(widget, e3) {
    widget.trigger(AXIS_LABEL_CLICK, {
      element: eventElement(e3),
      value: this.value,
      text: this.text,
      index: this.index,
      dataItem: this.dataItem,
      axis: this.parent.options
    });
  };
  AxisLabel2.prototype.rotate = function rotate() {
    if (this.options.alignRotation !== CENTER) {
      var box = this.normalBox.toRect();
      var transform2 = this.rotationTransform();
      this.box = rectToBox(box.bbox(transform2.matrix()));
    } else {
      TextBox2.prototype.rotate.call(this);
    }
    return this.box;
  };
  AxisLabel2.prototype.rotationTransform = function rotationTransform() {
    var options2 = this.options;
    var rotation = options2.rotation;
    if (!rotation) {
      return null;
    }
    if (options2.alignRotation === CENTER) {
      return TextBox2.prototype.rotationTransform.call(this);
    }
    var rotationMatrix = transform().rotate(rotation).matrix();
    var box = this.normalBox.toRect();
    var rect = this.targetBox.toRect();
    var rotationOrigin = options2.rotationOrigin || TOP;
    var alignAxis = rotationOrigin === TOP || rotationOrigin === BOTTOM ? X$4 : Y$7;
    var distanceAxis = rotationOrigin === TOP || rotationOrigin === BOTTOM ? Y$7 : X$4;
    var axisAnchor = rotationOrigin === TOP || rotationOrigin === LEFT ? rect.origin : rect.bottomRight();
    var topLeft = box.topLeft().transformCopy(rotationMatrix);
    var topRight = box.topRight().transformCopy(rotationMatrix);
    var bottomRight = box.bottomRight().transformCopy(rotationMatrix);
    var bottomLeft = box.bottomLeft().transformCopy(rotationMatrix);
    var rotatedBox = Rect$1.fromPoints(topLeft, topRight, bottomRight, bottomLeft);
    var translate2 = {};
    translate2[distanceAxis] = rect.origin[distanceAxis] - rotatedBox.origin[distanceAxis];
    var distanceLeft = Math.abs(topLeft[distanceAxis] + translate2[distanceAxis] - axisAnchor[distanceAxis]);
    var distanceRight = Math.abs(topRight[distanceAxis] + translate2[distanceAxis] - axisAnchor[distanceAxis]);
    var alignStart2, alignEnd;
    if (round$1(distanceLeft, DEFAULT_PRECISION) === round$1(distanceRight, DEFAULT_PRECISION)) {
      alignStart2 = topLeft;
      alignEnd = topRight;
    } else if (distanceRight < distanceLeft) {
      alignStart2 = topRight;
      alignEnd = bottomRight;
    } else {
      alignStart2 = topLeft;
      alignEnd = bottomLeft;
    }
    var alignCenter = alignStart2[alignAxis] + (alignEnd[alignAxis] - alignStart2[alignAxis]) / 2;
    translate2[alignAxis] = rect.center()[alignAxis] - alignCenter;
    return transform().translate(translate2.x, translate2.y).rotate(rotation);
  };
  return AxisLabel2;
}(TextBox);
setDefaultOptions(AxisLabel, {
  _autoReflow: false
});
var DEFAULT_ICON_SIZE = 7;
var DEFAULT_LABEL_COLOR = "#fff";
var Note = function(BoxElement2) {
  function Note2(fields, options2, chartService) {
    BoxElement2.call(this, options2);
    this.fields = fields;
    this.chartService = chartService;
    this.render();
  }
  if (BoxElement2)
    Note2.__proto__ = BoxElement2;
  Note2.prototype = Object.create(BoxElement2 && BoxElement2.prototype);
  Note2.prototype.constructor = Note2;
  Note2.prototype.hide = function hide2() {
    this.options.visible = false;
  };
  Note2.prototype.show = function show2() {
    this.options.visible = true;
  };
  Note2.prototype.render = function render() {
    var this$1$1 = this;
    var options2 = this.options;
    if (options2.visible) {
      var label = options2.label;
      var icon = options2.icon;
      var box = new Box();
      var childAlias = function() {
        return this$1$1;
      };
      var size = icon.size;
      var text = this.fields.text;
      var width, height;
      if (defined(label) && label.visible) {
        var noteTemplate = getTemplate$1(label);
        if (noteTemplate) {
          text = noteTemplate(this.fields);
        } else if (label.format) {
          text = this.chartService.format.auto(label.format, text);
        }
        if (!label.color) {
          label.color = label.position === INSIDE$2 ? DEFAULT_LABEL_COLOR : icon.background;
        }
        this.label = new TextBox(text, deepExtend({}, label));
        this.label.aliasFor = childAlias;
        if (label.position === INSIDE$2 && !defined(size)) {
          if (icon.type === CIRCLE) {
            size = Math.max(this.label.box.width(), this.label.box.height());
          } else {
            width = this.label.box.width();
            height = this.label.box.height();
          }
          box.wrap(this.label.box);
        }
      }
      icon.width = width || size || DEFAULT_ICON_SIZE;
      icon.height = height || size || DEFAULT_ICON_SIZE;
      var marker = new ShapeElement(deepExtend({}, icon));
      marker.aliasFor = childAlias;
      this.marker = marker;
      this.append(marker);
      if (this.label) {
        this.append(this.label);
      }
      marker.reflow(new Box());
      this.wrapperBox = box.wrap(marker.box);
    }
  };
  Note2.prototype.reflow = function reflow(targetBox) {
    var ref2 = this;
    var options2 = ref2.options;
    var label = ref2.label;
    var marker = ref2.marker;
    var wrapperBox = ref2.wrapperBox;
    var center = targetBox.center();
    var length = options2.line.length;
    var position2 = options2.position;
    if (options2.visible) {
      var lineStart, box, contentBox;
      if (inArray(position2, [LEFT, RIGHT])) {
        if (position2 === LEFT) {
          contentBox = wrapperBox.alignTo(targetBox, position2).translate(-length, targetBox.center().y - wrapperBox.center().y);
          if (options2.line.visible) {
            lineStart = [targetBox.x1, center.y];
            this.linePoints = [
              lineStart,
              [contentBox.x2, center.y]
            ];
            box = contentBox.clone().wrapPoint(lineStart);
          }
        } else {
          contentBox = wrapperBox.alignTo(targetBox, position2).translate(length, targetBox.center().y - wrapperBox.center().y);
          if (options2.line.visible) {
            lineStart = [targetBox.x2, center.y];
            this.linePoints = [
              lineStart,
              [contentBox.x1, center.y]
            ];
            box = contentBox.clone().wrapPoint(lineStart);
          }
        }
      } else {
        if (position2 === BOTTOM) {
          contentBox = wrapperBox.alignTo(targetBox, position2).translate(targetBox.center().x - wrapperBox.center().x, length);
          if (options2.line.visible) {
            lineStart = [center.x, targetBox.y2];
            this.linePoints = [
              lineStart,
              [center.x, contentBox.y1]
            ];
            box = contentBox.clone().wrapPoint(lineStart);
          }
        } else {
          contentBox = wrapperBox.alignTo(targetBox, position2).translate(targetBox.center().x - wrapperBox.center().x, -length);
          if (options2.line.visible) {
            lineStart = [center.x, targetBox.y1];
            this.linePoints = [
              lineStart,
              [center.x, contentBox.y2]
            ];
            box = contentBox.clone().wrapPoint(lineStart);
          }
        }
      }
      if (marker) {
        marker.reflow(contentBox);
      }
      if (label) {
        label.reflow(contentBox);
        if (marker) {
          if (options2.label.position === OUTSIDE$1) {
            label.box.alignTo(marker.box, position2);
          }
          label.reflow(label.box);
        }
      }
      this.contentBox = contentBox;
      this.targetBox = targetBox;
      this.box = box || contentBox;
    }
  };
  Note2.prototype.createVisual = function createVisual() {
    BoxElement2.prototype.createVisual.call(this);
    this.visual.options.noclip = this.options.noclip;
    if (this.options.visible) {
      this.createLine();
    }
  };
  Note2.prototype.renderVisual = function renderVisual() {
    var this$1$1 = this;
    var options2 = this.options;
    var customVisual = options2.visual;
    if (options2.visible && customVisual) {
      this.visual = customVisual(Object.assign(this.fields, {
        sender: this.getSender(),
        rect: this.targetBox.toRect(),
        options: {
          background: options2.background,
          border: options2.background,
          icon: options2.icon,
          label: options2.label,
          line: options2.line,
          position: options2.position,
          visible: options2.visible
        },
        createVisual: function() {
          this$1$1.createVisual();
          this$1$1.renderChildren();
          var defaultVisual = this$1$1.visual;
          delete this$1$1.visual;
          return defaultVisual;
        }
      }));
      this.addVisual();
    } else {
      BoxElement2.prototype.renderVisual.call(this);
    }
  };
  Note2.prototype.createLine = function createLine() {
    var options2 = this.options.line;
    if (this.linePoints) {
      var path = Path$7.fromPoints(this.linePoints, {
        stroke: {
          color: options2.color,
          width: options2.width,
          dashType: options2.dashType
        }
      });
      alignPathToPixel(path);
      this.visual.append(path);
    }
  };
  Note2.prototype.click = function click(widget, e3) {
    var args = this.eventArgs(e3);
    if (!widget.trigger(NOTE_CLICK, args)) {
      e3.preventDefault();
    }
  };
  Note2.prototype.over = function over(widget, e3) {
    var args = this.eventArgs(e3);
    if (!widget.trigger(NOTE_HOVER, args)) {
      e3.preventDefault();
    }
  };
  Note2.prototype.out = function out(widget, e3) {
    var args = this.eventArgs(e3);
    widget.trigger(NOTE_LEAVE, args);
  };
  Note2.prototype.eventArgs = function eventArgs(e3) {
    var options2 = this.options;
    return Object.assign(this.fields, {
      element: eventElement(e3),
      text: defined(options2.label) ? options2.label.text : "",
      visual: this.visual
    });
  };
  return Note2;
}(BoxElement);
setDefaultOptions(Note, {
  icon: {
    visible: true,
    type: CIRCLE
  },
  label: {
    position: INSIDE$2,
    visible: true,
    align: CENTER,
    vAlign: CENTER
  },
  line: {
    visible: true
  },
  visible: true,
  position: TOP,
  zIndex: 2
});
var defaultImplementation = {
  format: function(format2, value2) {
    return value2;
  },
  toString: function(value2) {
    return value2;
  },
  parseDate: function(value2) {
    return new Date(value2);
  },
  firstDay: function() {
    return 0;
  }
};
var current$1 = defaultImplementation;
var IntlService = function IntlService2() {
};
var staticAccessors = { implementation: { configurable: true } };
IntlService.register = function register2(userImplementation) {
  current$1 = userImplementation;
};
staticAccessors.implementation.get = function() {
  return current$1;
};
Object.defineProperties(IntlService, staticAccessors);
var FORMAT_REPLACE_REGEX = /\{(\d+)(:[^\}]+)?\}/g;
var FormatService = function FormatService2(intlService) {
  this._intlService = intlService;
};
var prototypeAccessors$1 = { intl: { configurable: true } };
prototypeAccessors$1.intl.get = function() {
  return this._intlService || IntlService.implementation;
};
prototypeAccessors$1.intl.set = function(value2) {
  this._intlService = value2;
};
FormatService.prototype.auto = function auto(formatString2) {
  var values6 = [], len = arguments.length - 1;
  while (len-- > 0)
    values6[len] = arguments[len + 1];
  var intl = this.intl;
  if (isString$2(formatString2) && formatString2.match(FORMAT_REGEX)) {
    return intl.format.apply(intl, [formatString2].concat(values6));
  }
  return intl.toString(values6[0], formatString2);
};
FormatService.prototype.localeAuto = function localeAuto(formatString2, values6, locale) {
  var intl = this.intl;
  var result;
  if (isString$2(formatString2) && formatString2.match(FORMAT_REGEX)) {
    result = formatString2.replace(FORMAT_REPLACE_REGEX, function(match2, index2, placeholderFormat) {
      var value2 = values6[parseInt(index2, 10)];
      return intl.toString(value2, placeholderFormat ? placeholderFormat.substring(1) : "", locale);
    });
  } else {
    result = intl.toString(values6[0], formatString2, locale);
  }
  return result;
};
Object.defineProperties(FormatService.prototype, prototypeAccessors$1);
var ChartService = function ChartService2(chart, context2) {
  if (context2 === void 0)
    context2 = {};
  this._intlService = context2.intlService;
  this.sender = context2.sender || chart;
  this.format = new FormatService(context2.intlService);
  this.chart = chart;
  this.rtl = Boolean(context2.rtl);
};
var prototypeAccessors = { intl: { configurable: true } };
prototypeAccessors.intl.get = function() {
  return this._intlService || IntlService.implementation;
};
prototypeAccessors.intl.set = function(value2) {
  this._intlService = value2;
  this.format.intl = value2;
};
ChartService.prototype.notify = function notify(name2, args) {
  if (this.chart) {
    this.chart.trigger(name2, args);
  }
};
ChartService.prototype.isPannable = function isPannable(axis) {
  var pannable = ((this.chart || {}).options || {}).pannable;
  return pannable && pannable.lock !== axis;
};
Object.defineProperties(ChartService.prototype, prototypeAccessors);
var current;
var DomEventsBuilder = function DomEventsBuilder2() {
};
DomEventsBuilder.register = function register3(userImplementation) {
  current = userImplementation;
};
DomEventsBuilder.create = function create(element, events2) {
  var builder;
  if (current) {
    builder = current.create(element, events2);
  } else {
    builder = new UserEvents(element, Object.assign(
      {},
      { multiTouch: true },
      events2
    ));
  }
  return builder;
};
function createAxisTick(options2, tickOptions) {
  var tickX = options2.tickX;
  var tickY = options2.tickY;
  var position2 = options2.position;
  var tick = new Path$7({
    stroke: {
      width: tickOptions.width,
      color: tickOptions.color
    }
  });
  if (options2.vertical) {
    tick.moveTo(tickX, position2).lineTo(tickX + tickOptions.size, position2);
  } else {
    tick.moveTo(position2, tickY).lineTo(position2, tickY + tickOptions.size);
  }
  alignPathToPixel(tick);
  return tick;
}
function createAxisGridLine(options2, gridLine) {
  var lineStart = options2.lineStart;
  var lineEnd = options2.lineEnd;
  var position2 = options2.position;
  var line = new Path$7({
    stroke: {
      width: gridLine.width,
      color: gridLine.color,
      dashType: gridLine.dashType
    }
  });
  if (options2.vertical) {
    line.moveTo(lineStart, position2).lineTo(lineEnd, position2);
  } else {
    line.moveTo(position2, lineStart).lineTo(position2, lineEnd);
  }
  alignPathToPixel(line);
  return line;
}
var Axis = function(ChartElement2) {
  function Axis2(options2, chartService) {
    if (chartService === void 0)
      chartService = new ChartService();
    ChartElement2.call(this, options2);
    this.chartService = chartService;
    if (!this.options.visible) {
      this.options = deepExtend({}, this.options, {
        labels: {
          visible: false
        },
        line: {
          visible: false
        },
        margin: 0,
        majorTickSize: 0,
        minorTickSize: 0
      });
    }
    this.options.minorTicks = deepExtend({}, {
      color: this.options.line.color,
      width: this.options.line.width,
      visible: this.options.minorTickType !== NONE$1
    }, this.options.minorTicks, {
      size: this.options.minorTickSize,
      align: this.options.minorTickType
    });
    this.options.majorTicks = deepExtend({}, {
      color: this.options.line.color,
      width: this.options.line.width,
      visible: this.options.majorTickType !== NONE$1
    }, this.options.majorTicks, {
      size: this.options.majorTickSize,
      align: this.options.majorTickType
    });
    this.initFields();
    if (!this.options._deferLabels) {
      this.createLabels();
    }
    this.createTitle();
    this.createNotes();
  }
  if (ChartElement2)
    Axis2.__proto__ = ChartElement2;
  Axis2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  Axis2.prototype.constructor = Axis2;
  Axis2.prototype.initFields = function initFields() {
  };
  Axis2.prototype.labelsRange = function labelsRange() {
    return {
      min: this.options.labels.skip,
      max: this.labelsCount()
    };
  };
  Axis2.prototype.normalizeLabelRotation = function normalizeLabelRotation(labelOptions) {
    var rotation = labelOptions.rotation;
    if (isObject(rotation)) {
      labelOptions.alignRotation = rotation.align;
      labelOptions.rotation = rotation.angle;
    }
  };
  Axis2.prototype.createLabels = function createLabels() {
    var this$1$1 = this;
    var options2 = this.options;
    var align2 = options2.vertical ? RIGHT : CENTER;
    var labelOptions = deepExtend({}, options2.labels, {
      align: align2,
      zIndex: options2.zIndex
    });
    var step = Math.max(1, labelOptions.step);
    this.clearLabels();
    if (labelOptions.visible) {
      this.normalizeLabelRotation(labelOptions);
      if (labelOptions.rotation === "auto") {
        labelOptions.rotation = 0;
        options2.autoRotateLabels = true;
      }
      var range = this.labelsRange();
      for (var idx = range.min; idx < range.max; idx += step) {
        var labelContext = { index: idx, count: range.max };
        var label = this$1$1.createAxisLabel(idx, labelOptions, labelContext);
        if (label) {
          this$1$1.append(label);
          this$1$1.labels.push(label);
        }
      }
    }
  };
  Axis2.prototype.clearLabels = function clearLabels() {
    this.children = grep(this.children, function(child) {
      return !(child instanceof AxisLabel);
    });
    this.labels = [];
  };
  Axis2.prototype.clearTitle = function clearTitle() {
    var this$1$1 = this;
    if (this.title) {
      this.children = grep(this.children, function(child) {
        return child !== this$1$1.title;
      });
      this.title = void 0;
    }
  };
  Axis2.prototype.clear = function clear4() {
    this.clearLabels();
    this.clearTitle();
  };
  Axis2.prototype.lineBox = function lineBox() {
    var ref2 = this;
    var options2 = ref2.options;
    var box = ref2.box;
    var vertical = options2.vertical;
    var mirror = options2.labels.mirror;
    var axisX = mirror ? box.x1 : box.x2;
    var axisY = mirror ? box.y2 : box.y1;
    var lineWidth = options2.line.width || 0;
    return vertical ? new Box(axisX, box.y1, axisX, box.y2 - lineWidth) : new Box(box.x1, axisY, box.x2 - lineWidth, axisY);
  };
  Axis2.prototype.createTitle = function createTitle() {
    var options2 = this.options;
    var titleOptions = deepExtend({
      rotation: options2.vertical ? -90 : 0,
      text: "",
      zIndex: 1,
      visualSize: true
    }, options2.title);
    if (titleOptions.visible && titleOptions.text) {
      var title2 = new TextBox(titleOptions.text, titleOptions);
      this.append(title2);
      this.title = title2;
    }
  };
  Axis2.prototype.createNotes = function createNotes() {
    var this$1$1 = this;
    var options2 = this.options;
    var notes2 = options2.notes;
    var items = notes2.data || [];
    this.notes = [];
    for (var i16 = 0; i16 < items.length; i16++) {
      var item = deepExtend({}, notes2, items[i16]);
      item.value = this$1$1.parseNoteValue(item.value);
      var note2 = new Note({
        value: item.value,
        text: item.label.text,
        dataItem: item
      }, item, this$1$1.chartService);
      if (note2.options.visible) {
        if (defined(note2.options.position)) {
          if (options2.vertical && !inArray(note2.options.position, [LEFT, RIGHT])) {
            note2.options.position = options2.reverse ? LEFT : RIGHT;
          } else if (!options2.vertical && !inArray(note2.options.position, [TOP, BOTTOM])) {
            note2.options.position = options2.reverse ? BOTTOM : TOP;
          }
        } else {
          if (options2.vertical) {
            note2.options.position = options2.reverse ? LEFT : RIGHT;
          } else {
            note2.options.position = options2.reverse ? BOTTOM : TOP;
          }
        }
        this$1$1.append(note2);
        this$1$1.notes.push(note2);
      }
    }
  };
  Axis2.prototype.parseNoteValue = function parseNoteValue(value2) {
    return value2;
  };
  Axis2.prototype.renderVisual = function renderVisual() {
    ChartElement2.prototype.renderVisual.call(this);
    this.createPlotBands();
  };
  Axis2.prototype.createVisual = function createVisual() {
    ChartElement2.prototype.createVisual.call(this);
    this.createBackground();
    this.createLine();
  };
  Axis2.prototype.gridLinesVisual = function gridLinesVisual() {
    var gridLines = this._gridLines;
    if (!gridLines) {
      gridLines = this._gridLines = new Group$9({
        zIndex: -2
      });
      this.appendVisual(this._gridLines);
    }
    return gridLines;
  };
  Axis2.prototype.createTicks = function createTicks(lineGroup) {
    var options2 = this.options;
    var lineBox = this.lineBox();
    var mirror = options2.labels.mirror;
    var majorUnit = options2.majorTicks.visible ? options2.majorUnit : 0;
    var tickLineOptions = {
      // TODO
      // _alignLines: options._alignLines,
      vertical: options2.vertical
    };
    function render(tickPositions, tickOptions, skipUnit) {
      var count = tickPositions.length;
      var step = Math.max(1, tickOptions.step);
      if (tickOptions.visible) {
        for (var i16 = tickOptions.skip; i16 < count; i16 += step) {
          if (defined(skipUnit) && i16 % skipUnit === 0) {
            continue;
          }
          tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;
          tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;
          tickLineOptions.position = tickPositions[i16];
          lineGroup.append(createAxisTick(tickLineOptions, tickOptions));
        }
      }
    }
    render(this.getMajorTickPositions(), options2.majorTicks);
    render(this.getMinorTickPositions(), options2.minorTicks, majorUnit / options2.minorUnit);
  };
  Axis2.prototype.createLine = function createLine() {
    var options2 = this.options;
    var line = options2.line;
    var lineBox = this.lineBox();
    if (line.width > 0 && line.visible) {
      var path = new Path$7({
        stroke: {
          width: line.width,
          color: line.color,
          dashType: line.dashType
        }
        /* TODO
        zIndex: line.zIndex,
        */
      });
      path.moveTo(lineBox.x1, lineBox.y1).lineTo(lineBox.x2, lineBox.y2);
      if (options2._alignLines) {
        alignPathToPixel(path);
      }
      var group2 = this._lineGroup = new Group$9();
      group2.append(path);
      this.visual.append(group2);
      this.createTicks(group2);
    }
  };
  Axis2.prototype.getActualTickSize = function getActualTickSize() {
    var options2 = this.options;
    var tickSize = 0;
    if (options2.majorTicks.visible && options2.minorTicks.visible) {
      tickSize = Math.max(options2.majorTicks.size, options2.minorTicks.size);
    } else if (options2.majorTicks.visible) {
      tickSize = options2.majorTicks.size;
    } else if (options2.minorTicks.visible) {
      tickSize = options2.minorTicks.size;
    }
    return tickSize;
  };
  Axis2.prototype.createBackground = function createBackground() {
    var ref2 = this;
    var options2 = ref2.options;
    var box = ref2.box;
    var background = options2.background;
    if (background) {
      this._backgroundPath = Path$7.fromRect(box.toRect(), {
        fill: {
          color: background
        },
        stroke: null
      });
      this.visual.append(this._backgroundPath);
    }
  };
  Axis2.prototype.createPlotBands = function createPlotBands() {
    var this$1$1 = this;
    var options2 = this.options;
    var plotBands = options2.plotBands || [];
    var vertical = options2.vertical;
    var plotArea = this.plotArea;
    if (plotBands.length === 0) {
      return;
    }
    var group2 = this._plotbandGroup = new Group$9({
      zIndex: -1
    });
    var altAxis = grep(this.pane.axes, function(axis) {
      return axis.options.vertical !== this$1$1.options.vertical;
    })[0];
    for (var idx = 0; idx < plotBands.length; idx++) {
      var item = plotBands[idx];
      var slotX = void 0, slotY = void 0;
      var labelOptions = item.label;
      var label = void 0;
      if (vertical) {
        slotX = (altAxis || plotArea.axisX).lineBox();
        slotY = this$1$1.getSlot(item.from, item.to, true);
      } else {
        slotX = this$1$1.getSlot(item.from, item.to, true);
        slotY = (altAxis || plotArea.axisY).lineBox();
      }
      if (labelOptions) {
        labelOptions.vAlign = labelOptions.position || LEFT;
        label = this$1$1.createPlotBandLabel(
          labelOptions,
          item,
          new Box(
            slotX.x1,
            slotY.y1,
            slotX.x2,
            slotY.y2
          )
        );
      }
      if (slotX.width() !== 0 && slotY.height() !== 0) {
        var bandRect = new Rect$1(
          [slotX.x1, slotY.y1],
          [slotX.width(), slotY.height()]
        );
        var path = Path$7.fromRect(bandRect, {
          fill: {
            color: item.color,
            opacity: item.opacity
          },
          stroke: null
        });
        group2.append(path);
        if (label) {
          group2.append(label);
        }
      }
    }
    this.appendVisual(group2);
  };
  Axis2.prototype.createPlotBandLabel = function createPlotBandLabel(label, item, box) {
    if (label.visible === false) {
      return null;
    }
    var text = label.text;
    var textbox;
    if (defined(label) && label.visible) {
      var labelTemplate = getTemplate$1(label);
      if (labelTemplate) {
        text = labelTemplate({ text, item });
      } else if (label.format) {
        text = this.chartService.format.auto(label.format, text);
      }
      if (!label.color) {
        label.color = this.options.labels.color;
      }
    }
    textbox = new TextBox(text, label);
    textbox.reflow(box);
    textbox.renderVisual();
    return textbox.visual;
  };
  Axis2.prototype.createGridLines = function createGridLines(altAxis) {
    var options2 = this.options;
    var minorGridLines = options2.minorGridLines;
    var majorGridLines = options2.majorGridLines;
    var minorUnit = options2.minorUnit;
    var vertical = options2.vertical;
    var axisLineVisible = altAxis.options.line.visible;
    var majorUnit = majorGridLines.visible ? options2.majorUnit : 0;
    var lineBox = altAxis.lineBox();
    var linePos = lineBox[vertical ? "y1" : "x1"];
    var lineOptions = {
      lineStart: lineBox[vertical ? "x1" : "y1"],
      lineEnd: lineBox[vertical ? "x2" : "y2"],
      vertical
    };
    var majorTicks = [];
    var container = this.gridLinesVisual();
    function render(tickPositions, gridLine, skipUnit) {
      var count = tickPositions.length;
      var step = Math.max(1, gridLine.step);
      if (gridLine.visible) {
        for (var i16 = gridLine.skip; i16 < count; i16 += step) {
          var pos = round$1(tickPositions[i16]);
          if (!inArray(pos, majorTicks)) {
            if (i16 % skipUnit !== 0 && (!axisLineVisible || linePos !== pos)) {
              lineOptions.position = pos;
              container.append(createAxisGridLine(lineOptions, gridLine));
              majorTicks.push(pos);
            }
          }
        }
      }
    }
    render(this.getMajorTickPositions(), majorGridLines);
    render(this.getMinorTickPositions(), minorGridLines, majorUnit / minorUnit);
    return container.children;
  };
  Axis2.prototype.reflow = function reflow(box) {
    var ref2 = this;
    var options2 = ref2.options;
    var labels = ref2.labels;
    var title2 = ref2.title;
    var vertical = options2.vertical;
    var count = labels.length;
    var sizeFn = vertical ? WIDTH : HEIGHT;
    var titleSize = title2 ? title2.box[sizeFn]() : 0;
    var space = this.getActualTickSize() + options2.margin + titleSize;
    var rootBox = (this.getRoot() || {}).box || box;
    var boxSize = rootBox[sizeFn]();
    var maxLabelSize = 0;
    for (var i16 = 0; i16 < count; i16++) {
      var labelSize = labels[i16].box[sizeFn]();
      if (labelSize + space <= boxSize) {
        maxLabelSize = Math.max(maxLabelSize, labelSize);
      }
    }
    if (vertical) {
      this.box = new Box(
        box.x1,
        box.y1,
        box.x1 + maxLabelSize + space,
        box.y2
      );
    } else {
      this.box = new Box(
        box.x1,
        box.y1,
        box.x2,
        box.y1 + maxLabelSize + space
      );
    }
    this.arrangeTitle();
    this.arrangeLabels();
    this.arrangeNotes();
  };
  Axis2.prototype.getLabelsTickPositions = function getLabelsTickPositions() {
    return this.getMajorTickPositions();
  };
  Axis2.prototype.labelTickIndex = function labelTickIndex(label) {
    return label.index;
  };
  Axis2.prototype.arrangeLabels = function arrangeLabels() {
    var this$1$1 = this;
    var ref2 = this;
    var options2 = ref2.options;
    var labels = ref2.labels;
    var labelsBetweenTicks = this.labelsBetweenTicks();
    var vertical = options2.vertical;
    var mirror = options2.labels.mirror;
    var tickPositions = this.getLabelsTickPositions();
    for (var idx = 0; idx < labels.length; idx++) {
      var label = labels[idx];
      var tickIx = this$1$1.labelTickIndex(label);
      var labelSize = vertical ? label.box.height() : label.box.width();
      var firstTickPosition = tickPositions[tickIx];
      var nextTickPosition = tickPositions[tickIx + 1];
      var positionStart = void 0, positionEnd = void 0;
      if (vertical) {
        if (labelsBetweenTicks) {
          var middle = firstTickPosition + (nextTickPosition - firstTickPosition) / 2;
          positionStart = middle - labelSize / 2;
        } else {
          positionStart = firstTickPosition - labelSize / 2;
        }
        positionEnd = positionStart;
      } else {
        if (labelsBetweenTicks) {
          positionStart = firstTickPosition;
          positionEnd = nextTickPosition;
        } else {
          positionStart = firstTickPosition - labelSize / 2;
          positionEnd = positionStart + labelSize;
        }
      }
      this$1$1.positionLabel(label, mirror, positionStart, positionEnd);
    }
  };
  Axis2.prototype.positionLabel = function positionLabel(label, mirror, positionStart, positionEnd) {
    if (positionEnd === void 0)
      positionEnd = positionStart;
    var options2 = this.options;
    var vertical = options2.vertical;
    var lineBox = this.lineBox();
    var labelOffset = this.getActualTickSize() + options2.margin;
    var labelBox;
    if (vertical) {
      var labelX = lineBox.x2;
      if (mirror) {
        labelX += labelOffset;
        label.options.rotationOrigin = LEFT;
      } else {
        labelX -= labelOffset + label.box.width();
        label.options.rotationOrigin = RIGHT;
      }
      labelBox = label.box.move(labelX, positionStart);
    } else {
      var labelY = lineBox.y1;
      if (mirror) {
        labelY -= labelOffset + label.box.height();
        label.options.rotationOrigin = BOTTOM;
      } else {
        labelY += labelOffset;
        label.options.rotationOrigin = TOP;
      }
      labelBox = new Box(
        positionStart,
        labelY,
        positionEnd,
        labelY + label.box.height()
      );
    }
    label.reflow(labelBox);
  };
  Axis2.prototype.autoRotateLabelAngle = function autoRotateLabelAngle(labelBox, slotWidth) {
    if (labelBox.width() < slotWidth) {
      return 0;
    }
    if (labelBox.height() > slotWidth) {
      return -90;
    }
    return -45;
  };
  Axis2.prototype.autoRotateLabels = function autoRotateLabels() {
    var this$1$1 = this;
    if (!this.options.autoRotateLabels || this.options.vertical) {
      return false;
    }
    var tickPositions = this.getMajorTickPositions();
    var labels = this.labels;
    var limit = Math.min(labels.length, tickPositions.length - 1);
    var angle = 0;
    for (var idx = 0; idx < limit; idx++) {
      var width = Math.abs(tickPositions[idx + 1] - tickPositions[idx]);
      var labelBox = labels[idx].box;
      var labelAngle = this$1$1.autoRotateLabelAngle(labelBox, width);
      if (labelAngle !== 0) {
        angle = labelAngle;
      }
      if (angle === -90) {
        break;
      }
    }
    if (angle !== 0) {
      for (var idx$1 = 0; idx$1 < labels.length; idx$1++) {
        labels[idx$1].options.rotation = angle;
        labels[idx$1].reflow(new Box());
      }
      return true;
    }
  };
  Axis2.prototype.arrangeTitle = function arrangeTitle() {
    var ref2 = this;
    var options2 = ref2.options;
    var title2 = ref2.title;
    var mirror = options2.labels.mirror;
    var vertical = options2.vertical;
    if (title2) {
      if (vertical) {
        title2.options.align = mirror ? RIGHT : LEFT;
        title2.options.vAlign = title2.options.position;
      } else {
        title2.options.align = title2.options.position;
        title2.options.vAlign = mirror ? TOP : BOTTOM;
      }
      title2.reflow(this.box);
    }
  };
  Axis2.prototype.arrangeNotes = function arrangeNotes() {
    var this$1$1 = this;
    for (var idx = 0; idx < this.notes.length; idx++) {
      var item = this$1$1.notes[idx];
      var value2 = item.options.value;
      var slot = void 0;
      if (defined(value2)) {
        if (this$1$1.shouldRenderNote(value2)) {
          item.show();
        } else {
          item.hide();
        }
        slot = this$1$1.noteSlot(value2);
      } else {
        item.hide();
      }
      item.reflow(slot || this$1$1.lineBox());
    }
  };
  Axis2.prototype.noteSlot = function noteSlot(value2) {
    return this.getSlot(value2);
  };
  Axis2.prototype.alignTo = function alignTo(secondAxis) {
    var lineBox = secondAxis.lineBox();
    var vertical = this.options.vertical;
    var pos = vertical ? Y$7 : X$4;
    this.box.snapTo(lineBox, pos);
    if (vertical) {
      this.box.shrink(0, this.lineBox().height() - lineBox.height());
    } else {
      this.box.shrink(this.lineBox().width() - lineBox.width(), 0);
    }
    this.box[pos + 1] -= this.lineBox()[pos + 1] - lineBox[pos + 1];
    this.box[pos + 2] -= this.lineBox()[pos + 2] - lineBox[pos + 2];
  };
  Axis2.prototype.axisLabelText = function axisLabelText(value2, options2, context2) {
    var this$1$1 = this;
    var text;
    var tmpl = getTemplate$1(options2);
    var defaultText = function() {
      if (!options2.format) {
        return value2;
      }
      return this$1$1.chartService.format.localeAuto(
        options2.format,
        [value2],
        options2.culture
      );
    };
    if (tmpl) {
      var templateContext = Object.assign({}, context2, {
        get text() {
          return defaultText();
        },
        value: value2,
        format: options2.format,
        culture: options2.culture
      });
      text = tmpl(templateContext);
    } else {
      text = defaultText();
    }
    return text;
  };
  Axis2.prototype.slot = function slot(from, to, limit) {
    var slot2 = this.getSlot(from, to, limit);
    if (slot2) {
      return slot2.toRect();
    }
  };
  Axis2.prototype.contentBox = function contentBox() {
    var box = this.box.clone();
    var labels = this.labels;
    if (labels.length) {
      var axis = this.options.vertical ? Y$7 : X$4;
      if (this.chartService.isPannable(axis)) {
        var offset2 = this.maxLabelOffset();
        box[axis + 1] -= offset2.start;
        box[axis + 2] += offset2.end;
      } else {
        if (labels[0].options.visible) {
          box.wrap(labels[0].box);
        }
        var lastLabel = labels[labels.length - 1];
        if (lastLabel.options.visible) {
          box.wrap(lastLabel.box);
        }
      }
    }
    return box;
  };
  Axis2.prototype.maxLabelOffset = function maxLabelOffset() {
    var this$1$1 = this;
    var ref2 = this.options;
    var vertical = ref2.vertical;
    var reverse = ref2.reverse;
    var labelsBetweenTicks = this.labelsBetweenTicks();
    var tickPositions = this.getLabelsTickPositions();
    var offsetField = vertical ? Y$7 : X$4;
    var labels = this.labels;
    var startPosition = reverse ? 1 : 0;
    var endPosition = reverse ? 0 : 1;
    var maxStartOffset = 0;
    var maxEndOffset = 0;
    for (var idx = 0; idx < labels.length; idx++) {
      var label = labels[idx];
      var tickIx = this$1$1.labelTickIndex(label);
      var startTick = void 0, endTick = void 0;
      if (labelsBetweenTicks) {
        startTick = tickPositions[tickIx + startPosition];
        endTick = tickPositions[tickIx + endPosition];
      } else {
        startTick = endTick = tickPositions[tickIx];
      }
      maxStartOffset = Math.max(maxStartOffset, startTick - label.box[offsetField + 1]);
      maxEndOffset = Math.max(maxEndOffset, label.box[offsetField + 2] - endTick);
    }
    return {
      start: maxStartOffset,
      end: maxEndOffset
    };
  };
  Axis2.prototype.limitRange = function limitRange(from, to, min2, max2, offset2) {
    var options2 = this.options;
    if (from < min2 && offset2 < 0 && (!defined(options2.min) || options2.min <= min2) || max2 < to && offset2 > 0 && (!defined(options2.max) || max2 <= options2.max)) {
      return null;
    }
    if (to < min2 && offset2 > 0 || max2 < from && offset2 < 0) {
      return {
        min: from,
        max: to
      };
    }
    var rangeSize = to - from;
    var minValue = from;
    var maxValue = to;
    if (from < min2 && offset2 < 0) {
      minValue = limitValue(from, min2, max2);
      maxValue = limitValue(from + rangeSize, min2 + rangeSize, max2);
    } else if (to > max2 && offset2 > 0) {
      maxValue = limitValue(to, min2, max2);
      minValue = limitValue(to - rangeSize, min2, max2 - rangeSize);
    }
    return {
      min: minValue,
      max: maxValue
    };
  };
  Axis2.prototype.valueRange = function valueRange3() {
    return {
      min: this.seriesMin,
      max: this.seriesMax
    };
  };
  Axis2.prototype.lineDir = function lineDir() {
    var ref2 = this.options;
    var vertical = ref2.vertical;
    var reverse = ref2.reverse;
    return (vertical ? -1 : 1) * (reverse ? -1 : 1);
  };
  Axis2.prototype.lineInfo = function lineInfo() {
    var ref2 = this.options;
    var vertical = ref2.vertical;
    var lineBox = this.lineBox();
    var lineSize = vertical ? lineBox.height() : lineBox.width();
    var axis = vertical ? Y$7 : X$4;
    var axisDir = this.lineDir();
    var startEdge = axisDir === 1 ? 1 : 2;
    var axisOrigin = axis + startEdge.toString();
    var lineStart = lineBox[axisOrigin];
    return {
      axis,
      axisOrigin,
      axisDir,
      lineBox,
      lineSize,
      lineStart
    };
  };
  Axis2.prototype.pointOffset = function pointOffset(point2) {
    var ref2 = this.lineInfo();
    var axis = ref2.axis;
    var axisDir = ref2.axisDir;
    var axisOrigin = ref2.axisOrigin;
    var lineBox = ref2.lineBox;
    var lineSize = ref2.lineSize;
    var relative = axisDir > 0 ? point2[axis] - lineBox[axisOrigin] : lineBox[axisOrigin] - point2[axis];
    var offset2 = relative / lineSize;
    return offset2;
  };
  Axis2.prototype.scaleToDelta = function scaleToDelta(rawScale, range) {
    var MAX_SCALE = 0.999;
    var scale = limitValue(rawScale, -MAX_SCALE, MAX_SCALE);
    var delta;
    if (scale > 0) {
      delta = range * Math.min(1, scale);
    } else {
      delta = range - range / (1 + scale);
    }
    return delta;
  };
  Axis2.prototype.labelsBetweenTicks = function labelsBetweenTicks() {
    return !this.options.justified;
  };
  Axis2.prototype.prepareUserOptions = function prepareUserOptions() {
  };
  return Axis2;
}(ChartElement);
setDefaultOptions(Axis, {
  labels: {
    visible: true,
    rotation: 0,
    mirror: false,
    step: 1,
    skip: 0
  },
  line: {
    width: 1,
    color: BLACK$1,
    visible: true
  },
  title: {
    visible: true,
    position: CENTER
  },
  majorTicks: {
    align: OUTSIDE$1,
    size: 4,
    skip: 0,
    step: 1
  },
  minorTicks: {
    align: OUTSIDE$1,
    size: 3,
    skip: 0,
    step: 1
  },
  axisCrossingValue: 0,
  majorTickType: OUTSIDE$1,
  minorTickType: NONE$1,
  majorGridLines: {
    skip: 0,
    step: 1
  },
  minorGridLines: {
    visible: false,
    width: 1,
    color: BLACK$1,
    skip: 0,
    step: 1
  },
  // TODO: Move to line or labels options
  margin: 5,
  visible: true,
  reverse: false,
  justified: true,
  notes: {
    label: {
      text: ""
    }
  },
  _alignLines: true,
  _deferLabels: false
});
var MILLISECONDS = "milliseconds";
var SECONDS = "seconds";
var MINUTES = "minutes";
var HOURS = "hours";
var DAYS = "days";
var WEEKS = "weeks";
var MONTHS = "months";
var YEARS = "years";
var TIME_PER_MILLISECOND = 1;
var TIME_PER_SECOND = 1e3;
var TIME_PER_MINUTE = 60 * TIME_PER_SECOND;
var TIME_PER_HOUR = 60 * TIME_PER_MINUTE;
var TIME_PER_DAY = 24 * TIME_PER_HOUR;
var TIME_PER_WEEK = 7 * TIME_PER_DAY;
var TIME_PER_MONTH = 31 * TIME_PER_DAY;
var TIME_PER_YEAR = 365 * TIME_PER_DAY;
var TIME_PER_UNIT = {
  "years": TIME_PER_YEAR,
  "months": TIME_PER_MONTH,
  "weeks": TIME_PER_WEEK,
  "days": TIME_PER_DAY,
  "hours": TIME_PER_HOUR,
  "minutes": TIME_PER_MINUTE,
  "seconds": TIME_PER_SECOND,
  "milliseconds": TIME_PER_MILLISECOND
};
function absoluteDateDiff(a9, b2) {
  var diff = a9.getTime() - b2;
  var offsetDiff = a9.getTimezoneOffset() - b2.getTimezoneOffset();
  return diff - offsetDiff * TIME_PER_MINUTE;
}
function addTicks(date, ticks) {
  return new Date(date.getTime() + ticks);
}
function toDate(value2) {
  var result;
  if (value2 instanceof Date) {
    result = value2;
  } else if (value2) {
    result = new Date(value2);
  }
  return result;
}
function startOfWeek(date, weekStartDay) {
  if (weekStartDay === void 0)
    weekStartDay = 0;
  var daysToSubtract = 0;
  var day = date.getDay();
  if (!isNaN(day)) {
    while (day !== weekStartDay) {
      if (day === 0) {
        day = 6;
      } else {
        day--;
      }
      daysToSubtract++;
    }
  }
  return addTicks(date, -daysToSubtract * TIME_PER_DAY);
}
function adjustDST$1(date, hours) {
  if (hours === 0 && date.getHours() === 23) {
    date.setHours(date.getHours() + 2);
    return true;
  }
  return false;
}
function addHours(date, hours) {
  var roundedDate = new Date(date);
  roundedDate.setMinutes(0, 0, 0);
  var tzDiff = (date.getTimezoneOffset() - roundedDate.getTimezoneOffset()) * TIME_PER_MINUTE;
  return addTicks(roundedDate, tzDiff + hours * TIME_PER_HOUR);
}
function addDuration(dateValue, value2, unit2, weekStartDay) {
  var result = dateValue;
  if (dateValue) {
    var date = toDate(dateValue);
    var hours = date.getHours();
    if (unit2 === YEARS) {
      result = new Date(date.getFullYear() + value2, 0, 1);
      adjustDST$1(result, 0);
    } else if (unit2 === MONTHS) {
      result = new Date(date.getFullYear(), date.getMonth() + value2, 1);
      adjustDST$1(result, hours);
    } else if (unit2 === WEEKS) {
      result = addDuration(startOfWeek(date, weekStartDay), value2 * 7, DAYS);
      adjustDST$1(result, hours);
    } else if (unit2 === DAYS) {
      result = new Date(date.getFullYear(), date.getMonth(), date.getDate() + value2);
      adjustDST$1(result, hours);
    } else if (unit2 === HOURS) {
      result = addHours(date, value2);
    } else if (unit2 === MINUTES) {
      result = addTicks(date, value2 * TIME_PER_MINUTE);
      if (result.getSeconds() > 0) {
        result.setSeconds(0);
      }
    } else if (unit2 === SECONDS) {
      result = addTicks(date, value2 * TIME_PER_SECOND);
    } else if (unit2 === MILLISECONDS) {
      result = addTicks(date, value2);
    }
    if (unit2 !== MILLISECONDS && result.getMilliseconds() > 0) {
      result.setMilliseconds(0);
    }
  }
  return result;
}
function floorDate(date, unit2, weekStartDay) {
  return addDuration(toDate(date), 0, unit2, weekStartDay);
}
function ceilDate(dateValue, unit2, weekStartDay) {
  var date = toDate(dateValue);
  if (date && floorDate(date, unit2, weekStartDay).getTime() === date.getTime()) {
    return date;
  }
  return addDuration(date, 1, unit2, weekStartDay);
}
function dateComparer(a9, b2) {
  if (a9 && b2) {
    return a9.getTime() - b2.getTime();
  }
  return -1;
}
function dateDiff(a9, b2) {
  return a9.getTime() - b2;
}
function toTime(value2) {
  if (isArray$1(value2)) {
    var result = [];
    for (var idx = 0; idx < value2.length; idx++) {
      result.push(toTime(value2[idx]));
    }
    return result;
  } else if (value2) {
    return toDate(value2).getTime();
  }
}
function dateEquals(a9, b2) {
  if (a9 && b2) {
    return toTime(a9) === toTime(b2);
  }
  return a9 === b2;
}
function timeIndex(date, start, baseUnit) {
  return absoluteDateDiff(date, start) / TIME_PER_UNIT[baseUnit];
}
function dateIndex(value2, start, baseUnit, baseUnitStep) {
  var date = toDate(value2);
  var startDate = toDate(start);
  var index2;
  if (baseUnit === MONTHS) {
    index2 = date.getMonth() - startDate.getMonth() + (date.getFullYear() - startDate.getFullYear()) * 12 + timeIndex(date, new Date(date.getFullYear(), date.getMonth()), DAYS) / new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
  } else if (baseUnit === YEARS) {
    index2 = date.getFullYear() - startDate.getFullYear() + dateIndex(date, new Date(date.getFullYear(), 0), MONTHS, 1) / 12;
  } else if (baseUnit === DAYS || baseUnit === WEEKS) {
    index2 = timeIndex(date, startDate, baseUnit);
  } else {
    index2 = dateDiff(date, start) / TIME_PER_UNIT[baseUnit];
  }
  return index2 / baseUnitStep;
}
function duration(a9, b2, unit2) {
  var diff;
  if (unit2 === YEARS) {
    diff = b2.getFullYear() - a9.getFullYear();
  } else if (unit2 === MONTHS) {
    diff = duration(a9, b2, YEARS) * 12 + b2.getMonth() - a9.getMonth();
  } else if (unit2 === DAYS) {
    diff = Math.floor(dateDiff(b2, a9) / TIME_PER_DAY);
  } else {
    diff = Math.floor(dateDiff(b2, a9) / TIME_PER_UNIT[unit2]);
  }
  return diff;
}
function parseDate(intlService, date) {
  var result;
  if (isString$2(date)) {
    result = intlService.parseDate(date) || toDate(date);
  } else {
    result = toDate(date);
  }
  return result;
}
function parseDates(intlService, dates) {
  if (isArray$1(dates)) {
    var result = [];
    for (var idx = 0; idx < dates.length; idx++) {
      result.push(parseDate(intlService, dates[idx]));
    }
    return result;
  }
  return parseDate(intlService, dates);
}
function firstDay(options2, intlService) {
  if (isNumber(options2.weekStartDay)) {
    return options2.weekStartDay;
  }
  if (intlService && intlService.firstDay) {
    return intlService.firstDay();
  }
  return 0;
}
var MIN_CATEGORY_POINTS_RANGE = 0.01;
var MIN_CATEGORY_RANGE = 0.1;
function indexOf(value2, arr) {
  if (value2 instanceof Date) {
    var length = arr.length;
    for (var idx = 0; idx < length; idx++) {
      if (dateEquals(arr[idx], value2)) {
        return idx;
      }
    }
    return -1;
  }
  return arr.indexOf(value2);
}
var CategoryAxis = function(Axis2) {
  function CategoryAxis2() {
    Axis2.apply(this, arguments);
  }
  if (Axis2)
    CategoryAxis2.__proto__ = Axis2;
  CategoryAxis2.prototype = Object.create(Axis2 && Axis2.prototype);
  CategoryAxis2.prototype.constructor = CategoryAxis2;
  CategoryAxis2.prototype.initFields = function initFields() {
    this._ticks = {};
  };
  CategoryAxis2.prototype.categoriesHash = function categoriesHash() {
    return "";
  };
  CategoryAxis2.prototype.clone = function clone3() {
    var copy = new CategoryAxis2(Object.assign({}, this.options, {
      categories: this.options.srcCategories
    }), this.chartService);
    copy.createLabels();
    return copy;
  };
  CategoryAxis2.prototype.initUserOptions = function initUserOptions(options2) {
    var categories = options2.categories || [];
    var definedMin = defined(options2.min);
    var definedMax = defined(options2.max);
    options2.srcCategories = options2.categories = categories;
    if ((definedMin || definedMax) && categories.length) {
      var min2 = definedMin ? Math.floor(options2.min) : 0;
      var max2;
      if (definedMax) {
        max2 = options2.justified ? Math.floor(options2.max) + 1 : Math.ceil(options2.max);
      } else {
        max2 = categories.length;
      }
      options2.categories = options2.categories.slice(min2, max2);
    }
    return options2;
  };
  CategoryAxis2.prototype.rangeIndices = function rangeIndices() {
    var options2 = this.options;
    var length = options2.categories.length || 1;
    var min2 = isNumber(options2.min) ? options2.min % 1 : 0;
    var max2;
    if (isNumber(options2.max) && options2.max % 1 !== 0 && options2.max < this.totalRange().max) {
      max2 = length - (1 - options2.max % 1);
    } else {
      max2 = length - (options2.justified ? 1 : 0);
    }
    return {
      min: min2,
      max: max2
    };
  };
  CategoryAxis2.prototype.range = function range() {
    var options2 = this.options;
    var min2 = isNumber(options2.min) ? options2.min : 0;
    var max2 = isNumber(options2.max) ? options2.max : this.totalRange().max;
    return {
      min: min2,
      max: max2
    };
  };
  CategoryAxis2.prototype.roundedRange = function roundedRange() {
    return this.range();
  };
  CategoryAxis2.prototype.totalRange = function totalRange() {
    var options2 = this.options;
    return { min: 0, max: Math.max(this._seriesMax || 0, options2.srcCategories.length) - (options2.justified ? 1 : 0) };
  };
  CategoryAxis2.prototype.scaleOptions = function scaleOptions() {
    var ref2 = this.rangeIndices();
    var min2 = ref2.min;
    var max2 = ref2.max;
    var lineBox = this.lineBox();
    var size = this.options.vertical ? lineBox.height() : lineBox.width();
    var scale = size / (max2 - min2 || 1);
    return {
      scale: scale * (this.options.reverse ? -1 : 1),
      box: lineBox,
      min: min2,
      max: max2
    };
  };
  CategoryAxis2.prototype.arrangeLabels = function arrangeLabels() {
    Axis2.prototype.arrangeLabels.call(this);
    this.hideOutOfRangeLabels();
  };
  CategoryAxis2.prototype.hideOutOfRangeLabels = function hideOutOfRangeLabels() {
    var ref2 = this;
    var box = ref2.box;
    var labels = ref2.labels;
    if (labels.length > 0) {
      var valueAxis = this.options.vertical ? Y$7 : X$4;
      var start = box[valueAxis + 1];
      var end = box[valueAxis + 2];
      var firstLabel = labels[0];
      var lastLabel = last(labels);
      if (firstLabel.box[valueAxis + 1] > end || firstLabel.box[valueAxis + 2] < start) {
        firstLabel.options.visible = false;
      }
      if (lastLabel.box[valueAxis + 1] > end || lastLabel.box[valueAxis + 2] < start) {
        lastLabel.options.visible = false;
      }
    }
  };
  CategoryAxis2.prototype.getMajorTickPositions = function getMajorTickPositions() {
    return this.getTicks().majorTicks;
  };
  CategoryAxis2.prototype.getMinorTickPositions = function getMinorTickPositions() {
    return this.getTicks().minorTicks;
  };
  CategoryAxis2.prototype.getLabelsTickPositions = function getLabelsTickPositions() {
    return this.getTicks().labelTicks;
  };
  CategoryAxis2.prototype.tickIndices = function tickIndices(stepSize) {
    var ref2 = this.rangeIndices();
    var min2 = ref2.min;
    var max2 = ref2.max;
    var limit = Math.ceil(max2);
    var current2 = Math.floor(min2);
    var indices = [];
    while (current2 <= limit) {
      indices.push(current2);
      current2 += stepSize;
    }
    return indices;
  };
  CategoryAxis2.prototype.getTickPositions = function getTickPositions(stepSize) {
    var ref2 = this.options;
    var vertical = ref2.vertical;
    var reverse = ref2.reverse;
    var ref$1 = this.scaleOptions();
    var scale = ref$1.scale;
    var box = ref$1.box;
    var min2 = ref$1.min;
    var pos = box[(vertical ? Y$7 : X$4) + (reverse ? 2 : 1)];
    var indices = this.tickIndices(stepSize);
    var positions = [];
    for (var idx = 0; idx < indices.length; idx++) {
      positions.push(pos + round$1(scale * (indices[idx] - min2), COORD_PRECISION));
    }
    return positions;
  };
  CategoryAxis2.prototype.getTicks = function getTicks() {
    var options2 = this.options;
    var cache2 = this._ticks;
    var range = this.rangeIndices();
    var lineBox = this.lineBox();
    var hash = lineBox.getHash() + range.min + "," + range.max + options2.reverse + options2.justified;
    if (cache2._hash !== hash) {
      var hasMinor = options2.minorTicks.visible || options2.minorGridLines.visible;
      cache2._hash = hash;
      cache2.labelTicks = this.getTickPositions(1);
      cache2.majorTicks = this.filterOutOfRangePositions(cache2.labelTicks, lineBox);
      cache2.minorTicks = hasMinor ? this.filterOutOfRangePositions(this.getTickPositions(0.5), lineBox) : [];
    }
    return cache2;
  };
  CategoryAxis2.prototype.filterOutOfRangePositions = function filterOutOfRangePositions(positions, lineBox) {
    if (!positions.length) {
      return positions;
    }
    var axis = this.options.vertical ? Y$7 : X$4;
    var inRange = function(position2) {
      return lineBox[axis + 1] <= position2 && position2 <= lineBox[axis + 2];
    };
    var end = positions.length - 1;
    var startIndex = 0;
    while (!inRange(positions[startIndex]) && startIndex <= end) {
      startIndex++;
    }
    var endIndex = end;
    while (!inRange(positions[endIndex]) && endIndex >= 0) {
      endIndex--;
    }
    return positions.slice(startIndex, endIndex + 1);
  };
  CategoryAxis2.prototype.lineInfo = function lineInfo() {
    var ref2 = this.options;
    var vertical = ref2.vertical;
    var reverse = ref2.reverse;
    var lineBox = this.lineBox();
    var lineSize = vertical ? lineBox.height() : lineBox.width();
    var axis = vertical ? Y$7 : X$4;
    var axisDir = reverse ? -1 : 1;
    var startEdge = axisDir === 1 ? 1 : 2;
    var axisOrigin = axis + startEdge.toString();
    var lineStart = lineBox[axisOrigin];
    return {
      axis,
      axisOrigin,
      axisDir,
      lineBox,
      lineSize,
      lineStart
    };
  };
  CategoryAxis2.prototype.lineDir = function lineDir() {
    var ref2 = this.options;
    var reverse = ref2.reverse;
    return reverse ? -1 : 1;
  };
  CategoryAxis2.prototype.getSlot = function getSlot(from, to, limit) {
    var options2 = this.options;
    var reverse = options2.reverse;
    var justified = options2.justified;
    var ref2 = this.scaleOptions();
    var scale = ref2.scale;
    var box = ref2.box;
    var min2 = ref2.min;
    var ref$1 = this.lineInfo();
    var valueAxis = ref$1.axis;
    var lineStart = ref$1.lineStart;
    var slotBox = box.clone();
    var singleSlot = !defined(to);
    var start = valueOrDefault$1(from, 0);
    var end = valueOrDefault$1(to, start);
    end = Math.max(end - 1, start);
    end = Math.max(start, end);
    var p1 = lineStart + (start - min2) * scale;
    var p22 = lineStart + (end + 1 - min2) * scale;
    if (singleSlot && justified) {
      p22 = p1;
    }
    if (limit) {
      p1 = limitValue(p1, box[valueAxis + 1], box[valueAxis + 2]);
      p22 = limitValue(p22, box[valueAxis + 1], box[valueAxis + 2]);
    }
    slotBox[valueAxis + 1] = reverse ? p22 : p1;
    slotBox[valueAxis + 2] = reverse ? p1 : p22;
    return slotBox;
  };
  CategoryAxis2.prototype.limitSlot = function limitSlot(slot) {
    var vertical = this.options.vertical;
    var valueAxis = vertical ? Y$7 : X$4;
    var lineBox = this.lineBox();
    var limittedSlot = slot.clone();
    limittedSlot[valueAxis + 1] = limitValue(slot[valueAxis + 1], lineBox[valueAxis + 1], lineBox[valueAxis + 2]);
    limittedSlot[valueAxis + 2] = limitValue(slot[valueAxis + 2], lineBox[valueAxis + 1], lineBox[valueAxis + 2]);
    return limittedSlot;
  };
  CategoryAxis2.prototype.slot = function slot(from, to, limit) {
    var min2 = Math.floor(this.options.min || 0);
    var start = from;
    var end = to;
    if (typeof start === "string") {
      start = this.categoryIndex(start);
    } else if (isNumber(start)) {
      start -= min2;
    }
    if (typeof end === "string") {
      end = this.categoryIndex(end);
    } else if (isNumber(end)) {
      end -= min2;
    }
    return Axis2.prototype.slot.call(this, start, end, limit);
  };
  CategoryAxis2.prototype.pointCategoryIndex = function pointCategoryIndex(point2) {
    var ref2 = this.options;
    var reverse = ref2.reverse;
    var justified = ref2.justified;
    var vertical = ref2.vertical;
    var valueAxis = vertical ? Y$7 : X$4;
    var ref$1 = this.scaleOptions();
    var scale = ref$1.scale;
    var box = ref$1.box;
    var min2 = ref$1.min;
    var max2 = ref$1.max;
    var startValue = reverse ? max2 : min2;
    var lineStart = box[valueAxis + 1];
    var lineEnd = box[valueAxis + 2];
    var pos = point2[valueAxis];
    if (pos < lineStart || pos > lineEnd) {
      return null;
    }
    var value2 = startValue + (pos - lineStart) / scale;
    var diff = value2 % 1;
    if (justified) {
      value2 = Math.round(value2);
    } else if (diff === 0 && value2 > 0) {
      value2--;
    }
    return Math.floor(value2);
  };
  CategoryAxis2.prototype.getCategory = function getCategory(point2) {
    var index2 = this.pointCategoryIndex(point2);
    if (index2 === null) {
      return null;
    }
    return this.options.categories[index2];
  };
  CategoryAxis2.prototype.categoryIndex = function categoryIndex(value2) {
    return this.totalIndex(value2) - Math.floor(this.options.min || 0);
  };
  CategoryAxis2.prototype.categoryAt = function categoryAt(index2, total3) {
    var options2 = this.options;
    return (total3 ? options2.srcCategories : options2.categories)[index2];
  };
  CategoryAxis2.prototype.categoriesCount = function categoriesCount2() {
    return (this.options.categories || []).length;
  };
  CategoryAxis2.prototype.translateRange = function translateRange(delta) {
    var options2 = this.options;
    var lineBox = this.lineBox();
    var size = options2.vertical ? lineBox.height() : lineBox.width();
    var range = options2.categories.length;
    var scale = size / range;
    var offset2 = round$1(delta / scale, DEFAULT_PRECISION);
    return {
      min: offset2,
      max: range + offset2
    };
  };
  CategoryAxis2.prototype.scaleRange = function scaleRange(scale, cursor) {
    var position2 = Math.abs(this.pointOffset(cursor));
    var rangeIndices = this.limitedRangeIndices();
    var range = rangeIndices.max - rangeIndices.min;
    var delta = this.scaleToDelta(scale, range);
    var minDelta = position2 * delta;
    var maxDelta = (1 - position2) * delta;
    var min2 = rangeIndices.min + minDelta;
    var max2 = rangeIndices.max - maxDelta;
    if (max2 - min2 < MIN_CATEGORY_RANGE) {
      max2 = min2 + MIN_CATEGORY_RANGE;
    }
    return {
      min: min2,
      max: max2
    };
  };
  CategoryAxis2.prototype.zoomRange = function zoomRange(scale, cursor) {
    var ref2 = this.totalRange();
    var totalMin = ref2.min;
    var totalMax = ref2.max;
    var range = this.scaleRange(scale, cursor);
    return {
      min: limitValue(range.min, totalMin, totalMax),
      max: limitValue(range.max, totalMin, totalMax)
    };
  };
  CategoryAxis2.prototype.labelsCount = function labelsCount() {
    var labelsRange = this.labelsRange();
    return labelsRange.max - labelsRange.min;
  };
  CategoryAxis2.prototype.labelsRange = function labelsRange() {
    var options2 = this.options;
    var justified = options2.justified;
    var labelOptions = options2.labels;
    var ref2 = this.limitedRangeIndices(true);
    var min2 = ref2.min;
    var max2 = ref2.max;
    var start = Math.floor(min2);
    if (!justified) {
      min2 = Math.floor(min2);
      max2 = Math.ceil(max2);
    } else {
      min2 = Math.ceil(min2);
      max2 = Math.floor(max2);
    }
    var skip;
    if (min2 > labelOptions.skip) {
      skip = labelOptions.skip + labelOptions.step * Math.ceil((min2 - labelOptions.skip) / labelOptions.step);
    } else {
      skip = labelOptions.skip;
    }
    return {
      min: skip - start,
      max: (options2.categories.length ? max2 + (justified ? 1 : 0) : 0) - start
    };
  };
  CategoryAxis2.prototype.createAxisLabel = function createAxisLabel(index2, labelOptions, labelContext) {
    var options2 = this.options;
    var dataItem = options2.dataItems ? options2.dataItems[index2] : null;
    var category = valueOrDefault$1(options2.categories[index2], "");
    labelContext.dataItem = dataItem;
    var text = this.axisLabelText(category, labelOptions, labelContext);
    return new AxisLabel(category, text, index2, dataItem, labelOptions);
  };
  CategoryAxis2.prototype.shouldRenderNote = function shouldRenderNote(value2) {
    var range = this.limitedRangeIndices();
    return Math.floor(range.min) <= value2 && value2 <= Math.ceil(range.max);
  };
  CategoryAxis2.prototype.noteSlot = function noteSlot(value2) {
    var options2 = this.options;
    var index2 = value2 - Math.floor(options2.min || 0);
    return this.getSlot(index2);
  };
  CategoryAxis2.prototype.arrangeNotes = function arrangeNotes() {
    Axis2.prototype.arrangeNotes.call(this);
    this.hideOutOfRangeNotes();
  };
  CategoryAxis2.prototype.hideOutOfRangeNotes = function hideOutOfRangeNotes() {
    var ref2 = this;
    var notes2 = ref2.notes;
    var box = ref2.box;
    if (notes2 && notes2.length) {
      var valueAxis = this.options.vertical ? Y$7 : X$4;
      var start = box[valueAxis + 1];
      var end = box[valueAxis + 2];
      for (var idx = 0; idx < notes2.length; idx++) {
        var note2 = notes2[idx];
        if (note2.box && (end < note2.box[valueAxis + 1] || note2.box[valueAxis + 2] < start)) {
          note2.hide();
        }
      }
    }
  };
  CategoryAxis2.prototype.pan = function pan(delta) {
    var range = this.limitedRangeIndices(true);
    var ref2 = this.scaleOptions();
    var scale = ref2.scale;
    var offset2 = round$1(delta / scale, DEFAULT_PRECISION);
    var totalRange = this.totalRange();
    var min2 = range.min + offset2;
    var max2 = range.max + offset2;
    return this.limitRange(min2, max2, 0, totalRange.max, offset2);
  };
  CategoryAxis2.prototype.pointsRange = function pointsRange(start, end) {
    var ref2 = this.options;
    var reverse = ref2.reverse;
    var vertical = ref2.vertical;
    var valueAxis = vertical ? Y$7 : X$4;
    var range = this.limitedRangeIndices(true);
    var ref$1 = this.scaleOptions();
    var scale = ref$1.scale;
    var box = ref$1.box;
    var lineStart = box[valueAxis + (reverse ? 2 : 1)];
    var diffStart = start[valueAxis] - lineStart;
    var diffEnd = end[valueAxis] - lineStart;
    var min2 = range.min + diffStart / scale;
    var max2 = range.min + diffEnd / scale;
    var rangeMin = Math.min(min2, max2);
    var rangeMax = Math.max(min2, max2);
    if (rangeMax - rangeMin >= MIN_CATEGORY_POINTS_RANGE) {
      return {
        min: rangeMin,
        max: rangeMax
      };
    }
  };
  CategoryAxis2.prototype.valueRange = function valueRange3() {
    return this.range();
  };
  CategoryAxis2.prototype.totalIndex = function totalIndex3(value2) {
    var options2 = this.options;
    var index2 = this._categoriesMap ? this._categoriesMap.get(value2) : indexOf(value2, options2.srcCategories);
    return index2;
  };
  CategoryAxis2.prototype.currentRangeIndices = function currentRangeIndices() {
    var options2 = this.options;
    var min2 = 0;
    if (isNumber(options2.min)) {
      min2 = Math.floor(options2.min);
    }
    var max2;
    if (isNumber(options2.max)) {
      max2 = options2.justified ? Math.floor(options2.max) : Math.ceil(options2.max) - 1;
    } else {
      max2 = this.totalCount() - 1;
    }
    return {
      min: min2,
      max: max2
    };
  };
  CategoryAxis2.prototype.limitedRangeIndices = function limitedRangeIndices(totalLimit) {
    var options2 = this.options;
    var min2 = isNumber(options2.min) ? options2.min : 0;
    var max2;
    if (isNumber(options2.max)) {
      max2 = options2.max;
    } else if (isNumber(options2.min)) {
      max2 = min2 + options2.categories.length;
    } else {
      max2 = this.totalRange().max || 1;
    }
    if (totalLimit) {
      var totalRange = this.totalRange();
      min2 = limitValue(min2, 0, totalRange.max);
      max2 = limitValue(max2, 0, totalRange.max);
    }
    return {
      min: min2,
      max: max2
    };
  };
  CategoryAxis2.prototype.totalRangeIndices = function totalRangeIndices() {
    return {
      min: 0,
      max: this.totalRange().max || 1
    };
  };
  CategoryAxis2.prototype.indexCategories = function indexCategories() {
    if (!this._categoriesMap) {
      var map3 = this._categoriesMap = new HashMap();
      var srcCategories = this.options.srcCategories;
      for (var idx = 0; idx < srcCategories.length; idx++) {
        map3.set(srcCategories[idx], idx);
      }
    }
  };
  CategoryAxis2.prototype.totalCount = function totalCount3() {
    return Math.max(this.options.srcCategories.length, this._seriesMax || 0);
  };
  return CategoryAxis2;
}(Axis);
setDefaultOptions(CategoryAxis, {
  type: "category",
  vertical: false,
  majorGridLines: {
    visible: false,
    width: 1,
    color: BLACK$1
  },
  labels: {
    zIndex: 1
  },
  justified: false,
  _deferLabels: true
});
var COORDINATE_LIMIT = 3e5;
var DateLabelFormats = {
  milliseconds: "HH:mm:ss.fff",
  seconds: "HH:mm:ss",
  minutes: "HH:mm",
  hours: "HH:mm",
  days: "M/d",
  weeks: "M/d",
  months: "MMM 'yy",
  years: "yyyy"
};
var ZERO_THRESHOLD = 0.2;
var AUTO$1 = "auto";
var BASE_UNITS = [
  MILLISECONDS,
  SECONDS,
  MINUTES,
  HOURS,
  DAYS,
  WEEKS,
  MONTHS,
  YEARS
];
var FIT = "fit";
function categoryRange(categories, clearCache) {
  if (clearCache) {
    categories._range = void 0;
  }
  var range = categories._range;
  if (!range) {
    range = categories._range = sparseArrayLimits(categories);
    range.min = toDate(range.min);
    range.max = toDate(range.max);
  }
  return range;
}
var EmptyDateRange = function EmptyDateRange2(options2) {
  this.options = options2;
};
EmptyDateRange.prototype.displayIndices = function displayIndices() {
  return {
    min: 0,
    max: 1
  };
};
EmptyDateRange.prototype.displayRange = function displayRange() {
  return {};
};
EmptyDateRange.prototype.total = function total() {
  return {};
};
EmptyDateRange.prototype.valueRange = function valueRange() {
  return {};
};
EmptyDateRange.prototype.valueIndex = function valueIndex() {
  return -1;
};
EmptyDateRange.prototype.values = function values4() {
  return [];
};
EmptyDateRange.prototype.totalIndex = function totalIndex() {
  return -1;
};
EmptyDateRange.prototype.valuesCount = function valuesCount() {
  return 0;
};
EmptyDateRange.prototype.totalCount = function totalCount() {
  return 0;
};
EmptyDateRange.prototype.dateAt = function dateAt() {
  return null;
};
var DateRange = function DateRange2(start, end, options2) {
  this.options = options2;
  options2.baseUnitStep = options2.baseUnitStep || 1;
  var roundToBaseUnit = options2.roundToBaseUnit;
  var justified = options2.justified;
  this.start = addDuration(start, 0, options2.baseUnit, options2.weekStartDay);
  var lowerEnd = this.roundToTotalStep(end);
  var expandEnd = !justified && dateEquals(end, lowerEnd) && !options2.justifyEnd;
  this.end = this.roundToTotalStep(end, !justified, expandEnd ? 1 : 0);
  var min2 = options2.min || start;
  this.valueStart = this.roundToTotalStep(min2);
  this.displayStart = roundToBaseUnit ? this.valueStart : min2;
  var max2 = options2.max;
  if (!max2) {
    this.valueEnd = lowerEnd;
    this.displayEnd = roundToBaseUnit || expandEnd ? this.end : end;
  } else {
    var next = !justified && dateEquals(max2, this.roundToTotalStep(max2)) ? -1 : 0;
    this.valueEnd = this.roundToTotalStep(max2, false, next);
    this.displayEnd = roundToBaseUnit ? this.roundToTotalStep(max2, !justified) : options2.max;
  }
  if (this.valueEnd < this.valueStart) {
    this.valueEnd = this.valueStart;
  }
  if (this.displayEnd <= this.displayStart) {
    this.displayEnd = this.roundToTotalStep(this.displayStart, false, 1);
  }
};
DateRange.prototype.displayRange = function displayRange2() {
  return {
    min: this.displayStart,
    max: this.displayEnd
  };
};
DateRange.prototype.displayIndices = function displayIndices2() {
  if (!this._indices) {
    var options2 = this.options;
    var baseUnit = options2.baseUnit;
    var baseUnitStep = options2.baseUnitStep;
    var minIdx = dateIndex(this.displayStart, this.valueStart, baseUnit, baseUnitStep);
    var maxIdx = dateIndex(this.displayEnd, this.valueStart, baseUnit, baseUnitStep);
    this._indices = { min: minIdx, max: maxIdx };
  }
  return this._indices;
};
DateRange.prototype.total = function total2() {
  return {
    min: this.start,
    max: this.end
  };
};
DateRange.prototype.totalCount = function totalCount2() {
  var last2 = this.totalIndex(this.end);
  return last2 + (this.options.justified ? 1 : 0);
};
DateRange.prototype.valueRange = function valueRange2() {
  return {
    min: this.valueStart,
    max: this.valueEnd
  };
};
DateRange.prototype.valueIndex = function valueIndex2(value2) {
  var options2 = this.options;
  return Math.floor(dateIndex(value2, this.valueStart, options2.baseUnit, options2.baseUnitStep));
};
DateRange.prototype.totalIndex = function totalIndex2(value2) {
  var options2 = this.options;
  return Math.floor(dateIndex(value2, this.start, options2.baseUnit, options2.baseUnitStep));
};
DateRange.prototype.dateIndex = function dateIndex$1(value2) {
  var options2 = this.options;
  return dateIndex(value2, this.valueStart, options2.baseUnit, options2.baseUnitStep);
};
DateRange.prototype.valuesCount = function valuesCount2() {
  var maxIdx = this.valueIndex(this.valueEnd);
  return maxIdx + 1;
};
DateRange.prototype.values = function values5() {
  var values6 = this._values;
  if (!values6) {
    var options2 = this.options;
    var range = this.valueRange();
    this._values = values6 = [];
    for (var date = range.min; date <= range.max; ) {
      values6.push(date);
      date = addDuration(date, options2.baseUnitStep, options2.baseUnit, options2.weekStartDay);
    }
  }
  return values6;
};
DateRange.prototype.dateAt = function dateAt2(index2, total3) {
  var options2 = this.options;
  return addDuration(total3 ? this.start : this.valueStart, options2.baseUnitStep * index2, options2.baseUnit, options2.weekStartDay);
};
DateRange.prototype.roundToTotalStep = function roundToTotalStep(value2, upper, next) {
  var ref2 = this.options;
  var baseUnit = ref2.baseUnit;
  var baseUnitStep = ref2.baseUnitStep;
  var weekStartDay = ref2.weekStartDay;
  var start = this.start;
  var step = dateIndex(value2, start, baseUnit, baseUnitStep);
  var roundedStep = upper ? Math.ceil(step) : Math.floor(step);
  if (next) {
    roundedStep += next;
  }
  return addDuration(start, roundedStep * baseUnitStep, baseUnit, weekStartDay);
};
function autoBaseUnit(options2, startUnit, startStep) {
  var categoryLimits = categoryRange(options2.categories);
  var span = (options2.max || categoryLimits.max) - (options2.min || categoryLimits.min);
  var autoBaseUnitSteps = options2.autoBaseUnitSteps;
  var maxDateGroups = options2.maxDateGroups;
  var autoUnit = options2.baseUnit === FIT;
  var autoUnitIx = startUnit ? BASE_UNITS.indexOf(startUnit) : 0;
  var baseUnit = autoUnit ? BASE_UNITS[autoUnitIx++] : options2.baseUnit;
  var units = span / TIME_PER_UNIT[baseUnit];
  var totalUnits = units;
  var unitSteps, step, nextStep;
  while (!step || units >= maxDateGroups) {
    unitSteps = unitSteps || autoBaseUnitSteps[baseUnit].slice(0);
    do {
      nextStep = unitSteps.shift();
    } while (nextStep && startUnit === baseUnit && nextStep < startStep);
    if (nextStep) {
      step = nextStep;
      units = totalUnits / step;
    } else if (baseUnit === last(BASE_UNITS)) {
      step = Math.ceil(totalUnits / maxDateGroups);
      break;
    } else if (autoUnit) {
      baseUnit = BASE_UNITS[autoUnitIx++] || last(BASE_UNITS);
      totalUnits = span / TIME_PER_UNIT[baseUnit];
      unitSteps = null;
    } else {
      if (units > maxDateGroups) {
        step = Math.ceil(totalUnits / maxDateGroups);
      }
      break;
    }
  }
  options2.baseUnitStep = step;
  options2.baseUnit = baseUnit;
}
function defaultBaseUnit(options2) {
  var categories = options2.categories;
  var count = defined(categories) ? categories.length : 0;
  var minDiff = MAX_VALUE;
  var lastCategory, unit2;
  for (var categoryIx = 0; categoryIx < count; categoryIx++) {
    var category = categories[categoryIx];
    if (category && lastCategory) {
      var diff = Math.abs(absoluteDateDiff(category, lastCategory));
      if (diff !== 0) {
        minDiff = Math.min(minDiff, diff);
        if (minDiff >= TIME_PER_YEAR) {
          unit2 = YEARS;
        } else if (minDiff >= TIME_PER_MONTH - TIME_PER_DAY * 3) {
          unit2 = MONTHS;
        } else if (minDiff >= TIME_PER_WEEK) {
          unit2 = WEEKS;
        } else if (minDiff >= TIME_PER_DAY) {
          unit2 = DAYS;
        } else if (minDiff >= TIME_PER_HOUR) {
          unit2 = HOURS;
        } else if (minDiff >= TIME_PER_MINUTE) {
          unit2 = MINUTES;
        } else {
          unit2 = SECONDS;
        }
      }
    }
    lastCategory = category;
  }
  options2.baseUnit = unit2 || DAYS;
}
function initUnit(options2) {
  var baseUnit = (options2.baseUnit || "").toLowerCase();
  var useDefault = baseUnit !== FIT && !inArray(baseUnit, BASE_UNITS);
  if (useDefault) {
    defaultBaseUnit(options2);
  }
  if (baseUnit === FIT || options2.baseUnitStep === AUTO$1) {
    autoBaseUnit(options2);
  }
  return options2;
}
var DateCategoryAxis = function(CategoryAxis2) {
  function DateCategoryAxis2() {
    CategoryAxis2.apply(this, arguments);
  }
  if (CategoryAxis2)
    DateCategoryAxis2.__proto__ = CategoryAxis2;
  DateCategoryAxis2.prototype = Object.create(CategoryAxis2 && CategoryAxis2.prototype);
  DateCategoryAxis2.prototype.constructor = DateCategoryAxis2;
  DateCategoryAxis2.prototype.clone = function clone3() {
    var copy = new DateCategoryAxis2(Object.assign({}, this.options), this.chartService);
    copy.createLabels();
    return copy;
  };
  DateCategoryAxis2.prototype.categoriesHash = function categoriesHash() {
    var start = this.dataRange.total().min;
    return this.options.baseUnit + this.options.baseUnitStep + start;
  };
  DateCategoryAxis2.prototype.initUserOptions = function initUserOptions(options2) {
    return options2;
  };
  DateCategoryAxis2.prototype.initFields = function initFields() {
    CategoryAxis2.prototype.initFields.call(this);
    var chartService = this.chartService;
    var intlService = chartService.intl;
    var options2 = this.options;
    var categories = options2.categories || [];
    if (!categories._parsed) {
      categories = parseDates(intlService, categories);
      categories._parsed = true;
    }
    options2 = deepExtend({
      roundToBaseUnit: true
    }, options2, {
      categories,
      min: parseDate(intlService, options2.min),
      max: parseDate(intlService, options2.max),
      weekStartDay: firstDay(options2, intlService)
    });
    if (chartService.panning && chartService.isPannable(options2.vertical ? Y$7 : X$4)) {
      options2.roundToBaseUnit = false;
    }
    options2.userSetBaseUnit = options2.userSetBaseUnit || options2.baseUnit;
    options2.userSetBaseUnitStep = options2.userSetBaseUnitStep || options2.baseUnitStep;
    this.options = options2;
    options2.srcCategories = categories;
    if (categories.length > 0) {
      var range = categoryRange(categories, true);
      var maxDivisions = options2.maxDivisions;
      var safeOptions = initUnit(options2);
      var forecast = options2._forecast;
      if (forecast) {
        if (forecast.before > 0) {
          range.min = addDuration(range.min, -forecast.before, safeOptions.baseUnit, safeOptions.weekStartDay);
        }
        if (forecast.after > 0) {
          range.max = addDuration(range.max, forecast.after, safeOptions.baseUnit, safeOptions.weekStartDay);
        }
      }
      this.dataRange = new DateRange(range.min, range.max, safeOptions);
      if (maxDivisions) {
        var dataRange = this.dataRange.displayRange();
        var divisionOptions = Object.assign({}, options2, {
          justified: true,
          roundToBaseUnit: false,
          baseUnit: "fit",
          min: dataRange.min,
          max: dataRange.max,
          maxDateGroups: maxDivisions
        });
        var dataRangeOptions = this.dataRange.options;
        autoBaseUnit(divisionOptions, dataRangeOptions.baseUnit, dataRangeOptions.baseUnitStep);
        this.divisionRange = new DateRange(range.min, range.max, divisionOptions);
      } else {
        this.divisionRange = this.dataRange;
      }
    } else {
      options2.baseUnit = options2.baseUnit || DAYS;
      this.dataRange = this.divisionRange = new EmptyDateRange(options2);
    }
    this.rangeLabels = [];
  };
  DateCategoryAxis2.prototype.tickIndices = function tickIndices(stepSize) {
    var ref2 = this;
    var dataRange = ref2.dataRange;
    var divisionRange = ref2.divisionRange;
    var valuesCount3 = divisionRange.valuesCount();
    if (!this.options.maxDivisions || !valuesCount3) {
      return CategoryAxis2.prototype.tickIndices.call(this, stepSize);
    }
    var indices = [];
    var values6 = divisionRange.values();
    var offset2 = 0;
    if (!this.options.justified) {
      values6 = values6.concat(divisionRange.dateAt(valuesCount3));
      offset2 = 0.5;
    }
    for (var idx = 0; idx < values6.length; idx++) {
      indices.push(dataRange.dateIndex(values6[idx]) + offset2);
      if (stepSize !== 1 && idx >= 1) {
        var last2 = indices.length - 1;
        indices.splice(idx, 0, indices[last2 - 1] + (indices[last2] - indices[last2 - 1]) * stepSize);
      }
    }
    return indices;
  };
  DateCategoryAxis2.prototype.shouldRenderNote = function shouldRenderNote(value2) {
    var range = this.range();
    var categories = this.options.categories || [];
    return dateComparer(value2, range.min) >= 0 && dateComparer(value2, range.max) <= 0 && categories.length;
  };
  DateCategoryAxis2.prototype.parseNoteValue = function parseNoteValue(value2) {
    return parseDate(this.chartService.intl, value2);
  };
  DateCategoryAxis2.prototype.noteSlot = function noteSlot(value2) {
    return this.getSlot(value2);
  };
  DateCategoryAxis2.prototype.translateRange = function translateRange(delta) {
    var options2 = this.options;
    var baseUnit = options2.baseUnit;
    var weekStartDay = options2.weekStartDay;
    var vertical = options2.vertical;
    var lineBox = this.lineBox();
    var size = vertical ? lineBox.height() : lineBox.width();
    var range = this.range();
    var scale = size / (range.max - range.min);
    var offset2 = round$1(delta / scale, DEFAULT_PRECISION);
    if (range.min && range.max) {
      var from = addTicks(options2.min || range.min, offset2);
      var to = addTicks(options2.max || range.max, offset2);
      range = {
        min: addDuration(from, 0, baseUnit, weekStartDay),
        max: addDuration(to, 0, baseUnit, weekStartDay)
      };
    }
    return range;
  };
  DateCategoryAxis2.prototype.labelsRange = function labelsRange() {
    return {
      min: this.options.labels.skip,
      max: this.divisionRange.valuesCount()
    };
  };
  DateCategoryAxis2.prototype.pan = function pan(delta) {
    if (this.isEmpty()) {
      return null;
    }
    var options2 = this.options;
    var lineBox = this.lineBox();
    var size = options2.vertical ? lineBox.height() : lineBox.width();
    var ref2 = this.dataRange.displayRange();
    var min2 = ref2.min;
    var max2 = ref2.max;
    var totalLimits = this.dataRange.total();
    var scale = size / (max2 - min2);
    var offset2 = round$1(delta / scale, DEFAULT_PRECISION) * (options2.reverse ? -1 : 1);
    var from = addTicks(min2, offset2);
    var to = addTicks(max2, offset2);
    var panRange = this.limitRange(toTime(from), toTime(to), toTime(totalLimits.min), toTime(totalLimits.max), offset2);
    if (panRange) {
      panRange.min = toDate(panRange.min);
      panRange.max = toDate(panRange.max);
      panRange.baseUnit = options2.baseUnit;
      panRange.baseUnitStep = options2.baseUnitStep || 1;
      panRange.userSetBaseUnit = options2.userSetBaseUnit;
      panRange.userSetBaseUnitStep = options2.userSetBaseUnitStep;
      return panRange;
    }
  };
  DateCategoryAxis2.prototype.pointsRange = function pointsRange(start, end) {
    if (this.isEmpty()) {
      return null;
    }
    var pointsRange2 = CategoryAxis2.prototype.pointsRange.call(this, start, end);
    var datesRange = this.dataRange.displayRange();
    var indicesRange = this.dataRange.displayIndices();
    var scale = dateDiff(datesRange.max, datesRange.min) / (indicesRange.max - indicesRange.min);
    var options2 = this.options;
    var min2 = addTicks(datesRange.min, pointsRange2.min * scale);
    var max2 = addTicks(datesRange.min, pointsRange2.max * scale);
    return {
      min: min2,
      max: max2,
      baseUnit: options2.userSetBaseUnit || options2.baseUnit,
      baseUnitStep: options2.userSetBaseUnitStep || options2.baseUnitStep
    };
  };
  DateCategoryAxis2.prototype.scaleRange = function scaleRange(scale, cursor) {
    if (this.isEmpty()) {
      return {};
    }
    var options2 = this.options;
    var fit2 = options2.userSetBaseUnit === FIT;
    var totalLimits = this.dataRange.total();
    var ref2 = this.dataRange.displayRange();
    var rangeMin = ref2.min;
    var rangeMax = ref2.max;
    var position2 = Math.abs(this.pointOffset(cursor));
    var range = rangeMax - rangeMin;
    var delta = this.scaleToDelta(scale, range);
    var minDelta = Math.round(position2 * delta);
    var maxDelta = Math.round((1 - position2) * delta);
    var ref$1 = this.dataRange.options;
    var baseUnit = ref$1.baseUnit;
    var min2 = new Date(rangeMin.getTime() + minDelta);
    var max2 = new Date(rangeMax.getTime() - maxDelta);
    if (fit2) {
      var autoBaseUnitSteps = options2.autoBaseUnitSteps;
      var maxDateGroups = options2.maxDateGroups;
      var maxDiff = last(autoBaseUnitSteps[baseUnit]) * maxDateGroups * TIME_PER_UNIT[baseUnit];
      var rangeDiff = dateDiff(rangeMax, rangeMin);
      var diff = dateDiff(max2, min2);
      var baseUnitIndex = BASE_UNITS.indexOf(baseUnit);
      var autoBaseUnitStep, ticks;
      if (diff < TIME_PER_UNIT[baseUnit] && baseUnit !== MILLISECONDS) {
        baseUnit = BASE_UNITS[baseUnitIndex - 1];
        autoBaseUnitStep = last(autoBaseUnitSteps[baseUnit]);
        ticks = (rangeDiff - (maxDateGroups - 1) * autoBaseUnitStep * TIME_PER_UNIT[baseUnit]) / 2;
        min2 = addTicks(rangeMin, ticks);
        max2 = addTicks(rangeMax, -ticks);
      } else if (diff > maxDiff && baseUnit !== YEARS) {
        var stepIndex = 0;
        do {
          baseUnitIndex++;
          baseUnit = BASE_UNITS[baseUnitIndex];
          stepIndex = 0;
          ticks = 2 * TIME_PER_UNIT[baseUnit];
          do {
            autoBaseUnitStep = autoBaseUnitSteps[baseUnit][stepIndex];
            stepIndex++;
          } while (stepIndex < autoBaseUnitSteps[baseUnit].length && ticks * autoBaseUnitStep < rangeDiff);
        } while (baseUnit !== YEARS && ticks * autoBaseUnitStep < rangeDiff);
        ticks = (ticks * autoBaseUnitStep - rangeDiff) / 2;
        if (ticks > 0) {
          min2 = addTicks(rangeMin, -ticks);
          max2 = addTicks(rangeMax, ticks);
          min2 = addTicks(min2, limitValue(max2, totalLimits.min, totalLimits.max) - max2);
          max2 = addTicks(max2, limitValue(min2, totalLimits.min, totalLimits.max) - min2);
        }
      }
    }
    if (min2 && max2 && dateDiff(max2, min2) > 0) {
      return {
        min: min2,
        max: max2,
        baseUnit: options2.userSetBaseUnit || options2.baseUnit,
        baseUnitStep: options2.userSetBaseUnitStep || options2.baseUnitStep
      };
    }
  };
  DateCategoryAxis2.prototype.zoomRange = function zoomRange(scale, cursor) {
    var totalLimits = this.dataRange.total();
    var range = this.scaleRange(scale, cursor);
    if (range) {
      if (range.min < totalLimits.min) {
        range.min = totalLimits.min;
      }
      if (range.max > totalLimits.max) {
        range.max = totalLimits.max;
      }
    }
    return range;
  };
  DateCategoryAxis2.prototype.range = function range() {
    return this.dataRange.displayRange();
  };
  DateCategoryAxis2.prototype.createLabels = function createLabels() {
    CategoryAxis2.prototype.createLabels.call(this);
    this.createRangeLabels();
  };
  DateCategoryAxis2.prototype.clearLabels = function clearLabels() {
    CategoryAxis2.prototype.clearLabels.call(this);
    this.rangeLabels = [];
  };
  DateCategoryAxis2.prototype.arrangeLabels = function arrangeLabels() {
    this.arrangeRangeLabels();
    CategoryAxis2.prototype.arrangeLabels.call(this);
  };
  DateCategoryAxis2.prototype.arrangeRangeLabels = function arrangeRangeLabels() {
    var ref2 = this;
    var options2 = ref2.options;
    var rangeLabels = ref2.rangeLabels;
    if (rangeLabels.length === 0) {
      return;
    }
    var lineBox = this.lineBox();
    var vertical = options2.vertical;
    var mirror = options2.rangeLabels.mirror || options2.labels.mirror;
    var firstLabel = rangeLabels[0];
    if (firstLabel) {
      var position2 = vertical ? lineBox.y1 - firstLabel.box.height() / 2 : lineBox.x1;
      this.positionLabel(firstLabel, mirror, position2);
    }
    var lastLabel = rangeLabels[1];
    if (lastLabel) {
      var position$12 = vertical ? lineBox.y2 - lastLabel.box.height() / 2 : lineBox.x2;
      this.positionLabel(lastLabel, mirror, position$12);
    }
  };
  DateCategoryAxis2.prototype.autoRotateLabels = function autoRotateLabels() {
    CategoryAxis2.prototype.autoRotateLabels.call(this);
    this.autoRotateRangeLabels();
  };
  DateCategoryAxis2.prototype.hideOutOfRangeLabels = function hideOutOfRangeLabels() {
    CategoryAxis2.prototype.hideOutOfRangeLabels.call(this);
    this.hideOverlappingLabels();
  };
  DateCategoryAxis2.prototype.hideOverlappingLabels = function hideOverlappingLabels() {
    var ref2 = this;
    var rangeLabels = ref2.rangeLabels;
    var labels = ref2.labels;
    if (rangeLabels.length === 0) {
      return;
    }
    function clip(rangeLabel, label) {
      if (!label.options.visible || label.box.overlaps(rangeLabel.box)) {
        label.options.visible = false;
        return true;
      }
      return false;
    }
    var firstRangeLabel = rangeLabels[0];
    if (firstRangeLabel && firstRangeLabel.options.visible) {
      for (var i16 = 0; i16 < labels.length; i16++) {
        var overlaps = clip(firstRangeLabel, labels[i16]);
        if (!overlaps) {
          break;
        }
      }
    }
    var lastRangeLabel = rangeLabels[1];
    if (lastRangeLabel && lastRangeLabel.options.visible) {
      for (var i$12 = labels.length - 1; i$12 > 0; --i$12) {
        var overlaps$1 = clip(lastRangeLabel, labels[i$12]);
        if (!overlaps$1) {
          break;
        }
      }
    }
  };
  DateCategoryAxis2.prototype.contentBox = function contentBox() {
    var box = CategoryAxis2.prototype.contentBox.call(this);
    var rangeLabels = this.rangeLabels;
    for (var i16 = 0; i16 < rangeLabels.length; i16++) {
      var label = rangeLabels[i16];
      if (label.options.visible) {
        box.wrap(label.box);
      }
    }
    return box;
  };
  DateCategoryAxis2.prototype.createAxisLabel = function createAxisLabel(index2, labelOptions, labelContext) {
    if (labelContext === void 0)
      labelContext = {};
    var options2 = this.options;
    var dataItem = options2.dataItems && !options2.maxDivisions ? options2.dataItems[index2] : null;
    var date = this.divisionRange.dateAt(index2);
    var unitFormat = labelOptions.dateFormats[this.divisionRange.options.baseUnit];
    labelOptions.format = labelOptions.format || unitFormat;
    labelContext.dataItem = dataItem;
    var text = this.axisLabelText(date, labelOptions, labelContext);
    if (text) {
      return new AxisLabel(date, text, index2, dataItem, labelOptions);
    }
  };
  DateCategoryAxis2.prototype.createRangeLabels = function createRangeLabels() {
    var this$1$1 = this;
    var ref2 = this.divisionRange;
    var displayStart = ref2.displayStart;
    var displayEnd = ref2.displayEnd;
    var options2 = this.options;
    var labelOptions = Object.assign({}, options2.labels, options2.rangeLabels, {
      align: CENTER,
      zIndex: options2.zIndex
    });
    if (labelOptions.visible !== true) {
      return;
    }
    this.normalizeLabelRotation(labelOptions);
    labelOptions.alignRotation = CENTER;
    if (labelOptions.rotation === "auto") {
      labelOptions.rotation = 0;
      options2.autoRotateRangeLabels = true;
    }
    var unitFormat = labelOptions.dateFormats[this.divisionRange.options.baseUnit];
    labelOptions.format = labelOptions.format || unitFormat;
    var createLabel = function(index2, date, text) {
      if (text) {
        var label = new AxisLabel(date, text, index2, null, labelOptions);
        this$1$1.append(label);
        this$1$1.rangeLabels.push(label);
      }
    };
    var startText = this.axisLabelText(displayStart, labelOptions, { index: 0, count: 2 });
    createLabel(0, displayStart, startText);
    var endText = this.axisLabelText(displayEnd, labelOptions, { index: 1, count: 2 });
    createLabel(1, displayEnd, endText);
  };
  DateCategoryAxis2.prototype.autoRotateRangeLabels = function autoRotateRangeLabels() {
    var this$1$1 = this;
    var labels = this.rangeLabels;
    if (!this.options.autoRotateRangeLabels || this.options.vertical || labels.length !== 2) {
      return;
    }
    var rotateLabel = function(label, tickPositions2, index2) {
      var width = Math.abs(tickPositions2[index2 + 1] - tickPositions2[index2]) * 2;
      var angle = this$1$1.autoRotateLabelAngle(label.box, width);
      if (angle !== 0) {
        label.options.rotation = angle;
        label.reflow(new Box());
      }
    };
    var tickPositions = this.getMajorTickPositions();
    rotateLabel(labels[0], tickPositions, 0);
    rotateLabel(labels[1], tickPositions, tickPositions.length - 2);
  };
  DateCategoryAxis2.prototype.categoryIndex = function categoryIndex(value2) {
    return this.dataRange.valueIndex(value2);
  };
  DateCategoryAxis2.prototype.slot = function slot(from, to, limit) {
    var dateRange = this.dataRange;
    var start = from;
    var end = to;
    if (start instanceof Date) {
      start = dateRange.dateIndex(start);
    }
    if (end instanceof Date) {
      end = dateRange.dateIndex(end);
    }
    var slot2 = this.getSlot(start, end, limit);
    if (slot2) {
      return slot2.toRect();
    }
  };
  DateCategoryAxis2.prototype.getSlot = function getSlot(a9, b2, limit) {
    var start = a9;
    var end = b2;
    if (typeof start === OBJECT$1) {
      start = this.categoryIndex(start);
    }
    if (typeof end === OBJECT$1) {
      end = this.categoryIndex(end);
    }
    return CategoryAxis2.prototype.getSlot.call(this, start, end, limit);
  };
  DateCategoryAxis2.prototype.valueRange = function valueRange3() {
    var options2 = this.options;
    var range = categoryRange(options2.srcCategories);
    return {
      min: toDate(range.min),
      max: toDate(range.max)
    };
  };
  DateCategoryAxis2.prototype.categoryAt = function categoryAt(index2, total3) {
    return this.dataRange.dateAt(index2, total3);
  };
  DateCategoryAxis2.prototype.categoriesCount = function categoriesCount2() {
    return this.dataRange.valuesCount();
  };
  DateCategoryAxis2.prototype.rangeIndices = function rangeIndices() {
    return this.dataRange.displayIndices();
  };
  DateCategoryAxis2.prototype.labelsBetweenTicks = function labelsBetweenTicks() {
    return !this.divisionRange.options.justified;
  };
  DateCategoryAxis2.prototype.prepareUserOptions = function prepareUserOptions() {
    if (this.isEmpty()) {
      return;
    }
    this.options.categories = this.dataRange.values();
  };
  DateCategoryAxis2.prototype.getCategory = function getCategory(point2) {
    var index2 = this.pointCategoryIndex(point2);
    if (index2 === null) {
      return null;
    }
    return this.dataRange.dateAt(index2);
  };
  DateCategoryAxis2.prototype.totalIndex = function totalIndex3(value2) {
    return this.dataRange.totalIndex(value2);
  };
  DateCategoryAxis2.prototype.currentRangeIndices = function currentRangeIndices() {
    var range = this.dataRange.valueRange();
    return {
      min: this.dataRange.totalIndex(range.min),
      max: this.dataRange.totalIndex(range.max)
    };
  };
  DateCategoryAxis2.prototype.totalRange = function totalRange() {
    return this.dataRange.total();
  };
  DateCategoryAxis2.prototype.totalRangeIndices = function totalRangeIndices() {
    var range = this.dataRange.total();
    return {
      min: this.dataRange.totalIndex(range.min),
      max: this.dataRange.totalIndex(range.max)
    };
  };
  DateCategoryAxis2.prototype.totalCount = function totalCount3() {
    return this.dataRange.totalCount();
  };
  DateCategoryAxis2.prototype.isEmpty = function isEmpty2() {
    return !this.options.srcCategories.length;
  };
  DateCategoryAxis2.prototype.roundedRange = function roundedRange() {
    if (this.options.roundToBaseUnit !== false || this.isEmpty()) {
      return this.range();
    }
    var options2 = this.options;
    var datesRange = categoryRange(options2.srcCategories);
    var dateRange = new DateRange(datesRange.min, datesRange.max, Object.assign({}, options2, {
      justified: false,
      roundToBaseUnit: true,
      justifyEnd: false
    }));
    return dateRange.displayRange();
  };
  return DateCategoryAxis2;
}(CategoryAxis);
setDefaultOptions(DateCategoryAxis, {
  type: DATE,
  labels: {
    dateFormats: DateLabelFormats
  },
  rangeLabels: {
    visible: false
  },
  autoBaseUnitSteps: {
    milliseconds: [1, 10, 100],
    seconds: [1, 2, 5, 15, 30],
    minutes: [1, 2, 5, 15, 30],
    hours: [1, 2, 3],
    days: [1, 2, 3],
    weeks: [1, 2],
    months: [1, 2, 3, 6],
    years: [1, 2, 3, 5, 10, 25, 50]
  },
  maxDateGroups: 10
});
function autoAxisMin$1(min2, max2, narrow) {
  if (!min2 && !max2) {
    return 0;
  }
  var axisMin;
  if (min2 >= 0 && max2 >= 0) {
    var minValue = min2 === max2 ? 0 : min2;
    var diff = (max2 - minValue) / max2;
    if (narrow === false || !narrow && diff > ZERO_THRESHOLD) {
      return 0;
    }
    axisMin = Math.max(0, minValue - (max2 - minValue) / 2);
  } else {
    axisMin = min2;
  }
  return axisMin;
}
function autoAxisMax$1(min2, max2, narrow) {
  if (!min2 && !max2) {
    return 1;
  }
  var axisMax;
  if (min2 <= 0 && max2 <= 0) {
    var maxValue = min2 === max2 ? 0 : max2;
    var diff = Math.abs((maxValue - min2) / maxValue);
    if (narrow === false || !narrow && diff > ZERO_THRESHOLD) {
      return 0;
    }
    axisMax = Math.min(0, maxValue - (min2 - maxValue) / 2);
  } else {
    axisMax = max2;
  }
  return axisMax;
}
function floor(value2, step) {
  return round$1(Math.floor(value2 / step) * step, DEFAULT_PRECISION);
}
function ceil(value2, step) {
  return round$1(Math.ceil(value2 / step) * step, DEFAULT_PRECISION);
}
function limitCoordinate(value2) {
  return Math.max(Math.min(value2, COORDINATE_LIMIT), -COORDINATE_LIMIT);
}
var MIN_VALUE_RANGE$2 = Math.pow(10, -DEFAULT_PRECISION + 1);
var NumericAxis = function(Axis2) {
  function NumericAxis2(seriesMin, seriesMax, options2, chartService) {
    Axis2.call(this, Object.assign({}, options2, {
      seriesMin,
      seriesMax
    }), chartService);
  }
  if (Axis2)
    NumericAxis2.__proto__ = Axis2;
  NumericAxis2.prototype = Object.create(Axis2 && Axis2.prototype);
  NumericAxis2.prototype.constructor = NumericAxis2;
  NumericAxis2.prototype.initUserOptions = function initUserOptions(options2) {
    var autoOptions = autoAxisOptions(options2.seriesMin, options2.seriesMax, options2);
    this.totalOptions = totalAxisOptions(autoOptions, options2);
    return axisOptions(autoOptions, options2);
  };
  NumericAxis2.prototype.initFields = function initFields() {
    this.totalMin = this.totalOptions.min;
    this.totalMax = this.totalOptions.max;
    this.totalMajorUnit = this.totalOptions.majorUnit;
    this.seriesMin = this.options.seriesMin;
    this.seriesMax = this.options.seriesMax;
  };
  NumericAxis2.prototype.clone = function clone3() {
    return new NumericAxis2(
      this.seriesMin,
      this.seriesMax,
      Object.assign({}, this.options),
      this.chartService
    );
  };
  NumericAxis2.prototype.startValue = function startValue() {
    return 0;
  };
  NumericAxis2.prototype.range = function range() {
    var options2 = this.options;
    return { min: options2.min, max: options2.max };
  };
  NumericAxis2.prototype.getDivisions = function getDivisions(stepValue) {
    if (stepValue === 0) {
      return 1;
    }
    var options2 = this.options;
    var range = options2.max - options2.min;
    return Math.floor(round$1(range / stepValue, COORD_PRECISION)) + 1;
  };
  NumericAxis2.prototype.getTickPositions = function getTickPositions(unit2, skipUnit) {
    var options2 = this.options;
    var ref2 = this.lineInfo();
    var axisDir = ref2.axisDir;
    var axisOrigin = ref2.axisOrigin;
    var lineBox = ref2.lineBox;
    var lineSize = ref2.lineSize;
    var range = options2.max - options2.min;
    var scale = lineSize / range;
    var step = unit2 * scale;
    var divisions = this.getDivisions(unit2);
    var positions = [];
    var pos = lineBox[axisOrigin];
    var skipStep = 0;
    if (skipUnit) {
      skipStep = skipUnit / unit2;
    }
    for (var idx = 0; idx < divisions; idx++) {
      if (idx % skipStep !== 0) {
        positions.push(round$1(pos, COORD_PRECISION));
      }
      pos = pos + step * axisDir;
    }
    return positions;
  };
  NumericAxis2.prototype.getMajorTickPositions = function getMajorTickPositions() {
    return this.getTickPositions(this.options.majorUnit);
  };
  NumericAxis2.prototype.getMinorTickPositions = function getMinorTickPositions() {
    return this.getTickPositions(this.options.minorUnit);
  };
  NumericAxis2.prototype.getSlot = function getSlot(a9, b2, limit) {
    if (limit === void 0)
      limit = false;
    var options2 = this.options;
    var ref2 = this.lineInfo();
    var axis = ref2.axis;
    var axisDir = ref2.axisDir;
    var lineBox = ref2.lineBox;
    var lineSize = ref2.lineSize;
    var lineStart = ref2.lineStart;
    var step = axisDir * (lineSize / (options2.max - options2.min));
    var start = valueOrDefault$1(a9, b2 || 0);
    var end = valueOrDefault$1(b2, a9 || 0);
    if (limit) {
      start = limitValue(start, options2.min, options2.max);
      end = limitValue(end, options2.min, options2.max);
    }
    var p1 = Math.min(start, end) - options2.min;
    var p22 = Math.max(start, end) - options2.min;
    var slotBox = new Box(lineBox.x1, lineBox.y1, lineBox.x1, lineBox.y1);
    slotBox[axis + 1] = limitCoordinate(lineStart + step * (axisDir > 0 ? p1 : p22));
    slotBox[axis + 2] = limitCoordinate(lineStart + step * (axisDir > 0 ? p22 : p1));
    return slotBox;
  };
  NumericAxis2.prototype.getValue = function getValue(point2) {
    var options2 = this.options;
    var max2 = Number(options2.max);
    var min2 = Number(options2.min);
    var offset2 = this.pointOffset(point2);
    var valueOffset = offset2 * (max2 - min2);
    if (offset2 < 0 || offset2 > 1) {
      return null;
    }
    var value2 = min2 + valueOffset;
    return round$1(value2, DEFAULT_PRECISION);
  };
  NumericAxis2.prototype.translateRange = function translateRange(delta) {
    var options2 = this.options;
    var vertical = options2.vertical;
    var reverse = options2.reverse;
    var max2 = options2.max;
    var min2 = options2.min;
    var ref2 = this.lineInfo();
    var lineSize = ref2.lineSize;
    var range = max2 - min2;
    var scale = lineSize / range;
    var offset2 = round$1(delta / scale, DEFAULT_PRECISION);
    if ((vertical || reverse) && !(vertical && reverse)) {
      offset2 = -offset2;
    }
    return {
      min: min2 + offset2,
      max: max2 + offset2,
      offset: offset2
    };
  };
  NumericAxis2.prototype.labelsCount = function labelsCount() {
    return this.getDivisions(this.options.majorUnit);
  };
  NumericAxis2.prototype.createAxisLabel = function createAxisLabel(index2, labelOptions, labelContext) {
    var options2 = this.options;
    var value2 = round$1(options2.min + index2 * options2.majorUnit, DEFAULT_PRECISION);
    var text = this.axisLabelText(value2, labelOptions, labelContext);
    return new AxisLabel(value2, text, index2, null, labelOptions);
  };
  NumericAxis2.prototype.shouldRenderNote = function shouldRenderNote(value2) {
    var range = this.range();
    return range.min <= value2 && value2 <= range.max;
  };
  NumericAxis2.prototype.pan = function pan(delta) {
    var range = this.translateRange(delta);
    return this.limitRange(range.min, range.max, this.totalMin, this.totalMax, range.offset);
  };
  NumericAxis2.prototype.pointsRange = function pointsRange(start, end) {
    var startValue = this.getValue(start);
    var endValue = this.getValue(end);
    var min2 = Math.min(startValue, endValue);
    var max2 = Math.max(startValue, endValue);
    if (this.isValidRange(min2, max2)) {
      return {
        min: min2,
        max: max2
      };
    }
  };
  NumericAxis2.prototype.scaleRange = function scaleRange(scale, cursor) {
    var position2 = Math.abs(this.pointOffset(cursor));
    var range = this.options.max - this.options.min;
    var delta = this.scaleToDelta(scale, range);
    var minDelta = position2 * delta;
    var maxDelta = (1 - position2) * delta;
    var min2 = round$1(this.options.min + minDelta, DEFAULT_PRECISION);
    var max2 = round$1(this.options.max - maxDelta, DEFAULT_PRECISION);
    if (max2 - min2 < MIN_VALUE_RANGE$2) {
      max2 = min2 + MIN_VALUE_RANGE$2;
    }
    return {
      min: min2,
      max: max2
    };
  };
  NumericAxis2.prototype.zoomRange = function zoomRange(scale, cursor) {
    var ref2 = this;
    var totalMin = ref2.totalMin;
    var totalMax = ref2.totalMax;
    var range = this.scaleRange(scale, cursor);
    return {
      min: limitValue(range.min, totalMin, totalMax),
      max: limitValue(range.max, totalMin, totalMax),
      narrowRange: false
    };
  };
  NumericAxis2.prototype.isValidRange = function isValidRange(min2, max2) {
    return max2 - min2 > MIN_VALUE_RANGE$2;
  };
  return NumericAxis2;
}(Axis);
function autoAxisOptions(seriesMin, seriesMax, options2) {
  var narrowRange = options2.narrowRange;
  var autoMin = autoAxisMin$1(seriesMin, seriesMax, narrowRange);
  var autoMax = autoAxisMax$1(seriesMin, seriesMax, narrowRange);
  var majorUnit = autoMajorUnit(autoMin, autoMax);
  var autoOptions = {
    majorUnit
  };
  if (options2.roundToMajorUnit !== false) {
    if (autoMin < 0 && remainderClose(autoMin, majorUnit, 1 / 3)) {
      autoMin -= majorUnit;
    }
    if (autoMax > 0 && remainderClose(autoMax, majorUnit, 1 / 3)) {
      autoMax += majorUnit;
    }
  }
  autoOptions.min = floor(autoMin, majorUnit);
  autoOptions.max = ceil(autoMax, majorUnit);
  return autoOptions;
}
function totalAxisOptions(autoOptions, options2) {
  return {
    min: defined(options2.min) ? Math.min(autoOptions.min, options2.min) : autoOptions.min,
    max: defined(options2.max) ? Math.max(autoOptions.max, options2.max) : autoOptions.max,
    majorUnit: autoOptions.majorUnit
  };
}
function clearNullValues(options2, fields) {
  for (var idx = 0; idx < fields.length; idx++) {
    var field = fields[idx];
    if (options2[field] === null) {
      options2[field] = void 0;
    }
  }
}
function axisOptions(autoOptions, userOptions) {
  var options2 = userOptions;
  var userSetMin, userSetMax;
  if (userOptions) {
    clearNullValues(userOptions, ["min", "max"]);
    userSetMin = defined(userOptions.min);
    userSetMax = defined(userOptions.max);
    var userSetLimits = userSetMin || userSetMax;
    if (userSetLimits) {
      if (userOptions.min === userOptions.max) {
        if (userOptions.min > 0) {
          userOptions.min = 0;
        } else {
          userOptions.max = 1;
        }
      }
    }
    if (userOptions.majorUnit) {
      autoOptions.min = floor(autoOptions.min, userOptions.majorUnit);
      autoOptions.max = ceil(autoOptions.max, userOptions.majorUnit);
    } else if (userSetLimits) {
      options2 = deepExtend(autoOptions, userOptions);
      autoOptions.majorUnit = autoMajorUnit(options2.min, options2.max);
    }
  }
  autoOptions.minorUnit = (options2.majorUnit || autoOptions.majorUnit) / 5;
  var result = deepExtend(autoOptions, options2);
  if (result.min >= result.max) {
    if (userSetMin && !userSetMax) {
      result.max = result.min + result.majorUnit;
    } else if (!userSetMin && userSetMax) {
      result.min = result.max - result.majorUnit;
    }
  }
  return result;
}
function remainderClose(value2, divisor, ratio) {
  var remainder = round$1(Math.abs(value2 % divisor), DEFAULT_PRECISION);
  var threshold = divisor * (1 - ratio);
  return remainder === 0 || remainder > threshold;
}
setDefaultOptions(NumericAxis, {
  type: "numeric",
  min: 0,
  max: 1,
  vertical: true,
  majorGridLines: {
    visible: true,
    width: 1,
    color: BLACK$1
  },
  labels: {
    format: "#.####################"
  },
  zIndex: 1
});
var MIN_VALUE_RANGE$1 = 1e3;
var DateValueAxis = function(Axis2) {
  function DateValueAxis2(seriesMin, seriesMax, axisOptions2, chartService) {
    var min2 = toDate(seriesMin);
    var max2 = toDate(seriesMax);
    var intlService = chartService.intl;
    var options2 = axisOptions2 || {};
    options2 = deepExtend(options2 || {}, {
      min: parseDate(intlService, options2.min),
      max: parseDate(intlService, options2.max),
      axisCrossingValue: parseDates(intlService, options2.axisCrossingValues || options2.axisCrossingValue),
      weekStartDay: firstDay(options2, intlService)
    });
    options2 = applyDefaults(min2, max2, options2);
    Axis2.call(this, options2, chartService);
    this.intlService = intlService;
    this.seriesMin = min2;
    this.seriesMax = max2;
    var weekStartDay = options2.weekStartDay || 0;
    this.totalMin = toTime(floorDate(toTime(min2) - 1, options2.baseUnit, weekStartDay));
    this.totalMax = toTime(ceilDate(toTime(max2) + 1, options2.baseUnit, weekStartDay));
  }
  if (Axis2)
    DateValueAxis2.__proto__ = Axis2;
  DateValueAxis2.prototype = Object.create(Axis2 && Axis2.prototype);
  DateValueAxis2.prototype.constructor = DateValueAxis2;
  DateValueAxis2.prototype.clone = function clone3() {
    return new DateValueAxis2(this.seriesMin, this.seriesMax, Object.assign({}, this.options), this.chartService);
  };
  DateValueAxis2.prototype.range = function range() {
    var options2 = this.options;
    return { min: options2.min, max: options2.max };
  };
  DateValueAxis2.prototype.getDivisions = function getDivisions(stepValue) {
    var options2 = this.options;
    return Math.floor(
      duration(options2.min, options2.max, options2.baseUnit) / stepValue + 1
    );
  };
  DateValueAxis2.prototype.getTickPositions = function getTickPositions(step) {
    var options2 = this.options;
    var ref2 = this.lineInfo();
    var dir = ref2.axisDir;
    var lineSize = ref2.lineSize;
    var start = ref2.lineStart;
    var divisions = this.getDivisions(step);
    var timeRange = dateDiff(options2.max, options2.min);
    var scale = lineSize / timeRange;
    var weekStartDay = options2.weekStartDay || 0;
    var positions = [start];
    for (var i16 = 1; i16 < divisions; i16++) {
      var date = addDuration(options2.min, i16 * step, options2.baseUnit, weekStartDay);
      var pos = start + dateDiff(date, options2.min) * scale * dir;
      positions.push(round$1(pos, COORD_PRECISION));
    }
    return positions;
  };
  DateValueAxis2.prototype.getMajorTickPositions = function getMajorTickPositions() {
    return this.getTickPositions(this.options.majorUnit);
  };
  DateValueAxis2.prototype.getMinorTickPositions = function getMinorTickPositions() {
    return this.getTickPositions(this.options.minorUnit);
  };
  DateValueAxis2.prototype.getSlot = function getSlot(a9, b2, limit) {
    return NumericAxis.prototype.getSlot.call(
      this,
      parseDate(this.intlService, a9),
      parseDate(this.intlService, b2),
      limit
    );
  };
  DateValueAxis2.prototype.getValue = function getValue(point2) {
    var value2 = NumericAxis.prototype.getValue.call(this, point2);
    return value2 !== null ? toDate(value2) : null;
  };
  DateValueAxis2.prototype.labelsCount = function labelsCount() {
    return this.getDivisions(this.options.majorUnit);
  };
  DateValueAxis2.prototype.createAxisLabel = function createAxisLabel(index2, labelOptions, labelContext) {
    var options2 = this.options;
    var offset2 = index2 * options2.majorUnit;
    var weekStartDay = options2.weekStartDay || 0;
    var date = options2.min;
    if (offset2 > 0) {
      date = addDuration(date, offset2, options2.baseUnit, weekStartDay);
    }
    var unitFormat = labelOptions.dateFormats[options2.baseUnit];
    labelOptions.format = labelOptions.format || unitFormat;
    var text = this.axisLabelText(date, labelOptions, labelContext);
    return new AxisLabel(date, text, index2, null, labelOptions);
  };
  DateValueAxis2.prototype.translateRange = function translateRange(delta) {
    var options2 = this.options;
    var lineBox = this.lineBox();
    var vertical = options2.vertical;
    var reverse = options2.reverse;
    var size = vertical ? lineBox.height() : lineBox.width();
    var range = this.range();
    var scale = size / dateDiff(range.max, range.min);
    var offset2 = round$1(delta / scale, DEFAULT_PRECISION);
    if ((vertical || reverse) && !(vertical && reverse)) {
      offset2 = -offset2;
    }
    var from = addTicks(options2.min, offset2);
    var to = addTicks(options2.max, offset2);
    return {
      min: from,
      max: to,
      offset: offset2
    };
  };
  DateValueAxis2.prototype.shouldRenderNote = function shouldRenderNote(value2) {
    var range = this.range();
    return dateComparer(value2, range.min) >= 0 && dateComparer(value2, range.max) <= 0;
  };
  DateValueAxis2.prototype.pan = function pan(delta) {
    var range = this.translateRange(delta, true);
    var limittedRange = this.limitRange(toTime(range.min), toTime(range.max), this.totalMin, this.totalMax, range.offset);
    if (limittedRange) {
      return {
        min: toDate(limittedRange.min),
        max: toDate(limittedRange.max)
      };
    }
  };
  DateValueAxis2.prototype.pointsRange = function pointsRange(start, end) {
    var startValue = this.getValue(start);
    var endValue = this.getValue(end);
    var min2 = Math.min(startValue, endValue);
    var max2 = Math.max(startValue, endValue);
    return {
      min: toDate(min2),
      max: toDate(max2)
    };
  };
  DateValueAxis2.prototype.scaleRange = function scaleRange(scale, cursor) {
    var position2 = Math.abs(this.pointOffset(cursor));
    var range = this.options.max - this.options.min;
    var delta = this.scaleToDelta(scale, range);
    var minDelta = position2 * delta;
    var maxDelta = (1 - position2) * delta;
    var min2 = toDate(toTime(this.options.min) + minDelta);
    var max2 = toDate(toTime(this.options.max) - maxDelta);
    if (max2 - min2 < MIN_VALUE_RANGE$1) {
      max2 = toDate(toTime(min2) + MIN_VALUE_RANGE$1);
    }
    return {
      min: min2,
      max: max2
    };
  };
  DateValueAxis2.prototype.zoomRange = function zoomRange(scale, cursor) {
    var range = this.scaleRange(scale, cursor);
    var min2 = toDate(limitValue(toTime(range.min), this.totalMin, this.totalMax));
    var max2 = toDate(limitValue(toTime(range.max), this.totalMin, this.totalMax));
    return {
      min: min2,
      max: max2
    };
  };
  return DateValueAxis2;
}(Axis);
function timeUnits(delta) {
  var unit2 = HOURS;
  if (delta >= TIME_PER_YEAR) {
    unit2 = YEARS;
  } else if (delta >= TIME_PER_MONTH) {
    unit2 = MONTHS;
  } else if (delta >= TIME_PER_WEEK) {
    unit2 = WEEKS;
  } else if (delta >= TIME_PER_DAY) {
    unit2 = DAYS;
  }
  return unit2;
}
function applyDefaults(seriesMin, seriesMax, options2) {
  var min2 = options2.min || seriesMin;
  var max2 = options2.max || seriesMax;
  var baseUnit = options2.baseUnit || (max2 && min2 ? timeUnits(absoluteDateDiff(max2, min2)) : HOURS);
  var baseUnitTime = TIME_PER_UNIT[baseUnit];
  var weekStartDay = options2.weekStartDay || 0;
  var autoMin = floorDate(toTime(min2) - 1, baseUnit, weekStartDay) || toDate(max2);
  var autoMax = ceilDate(toTime(max2) + 1, baseUnit, weekStartDay);
  var userMajorUnit = options2.majorUnit ? options2.majorUnit : void 0;
  var majorUnit = userMajorUnit || ceil(
    autoMajorUnit(autoMin.getTime(), autoMax.getTime()),
    baseUnitTime
  ) / baseUnitTime;
  var actualUnits = duration(autoMin, autoMax, baseUnit);
  var totalUnits = ceil(actualUnits, majorUnit);
  var unitsToAdd = totalUnits - actualUnits;
  var head = Math.floor(unitsToAdd / 2);
  var tail = unitsToAdd - head;
  if (!options2.baseUnit) {
    delete options2.baseUnit;
  }
  options2.baseUnit = options2.baseUnit || baseUnit;
  options2.min = options2.min || addDuration(autoMin, -head, baseUnit, weekStartDay);
  options2.max = options2.max || addDuration(autoMax, tail, baseUnit, weekStartDay);
  options2.minorUnit = options2.minorUnit || majorUnit / 5;
  options2.majorUnit = majorUnit;
  return options2;
}
setDefaultOptions(DateValueAxis, {
  type: DATE,
  majorGridLines: {
    visible: true,
    width: 1,
    color: BLACK$1
  },
  labels: {
    dateFormats: DateLabelFormats
  }
});
var DEFAULT_MAJOR_UNIT = 10;
var MIN_VALUE_RANGE = 1e-6;
var LogarithmicAxis = function(Axis2) {
  function LogarithmicAxis2(seriesMin, seriesMax, options2, chartService) {
    var axisOptions2 = deepExtend({ majorUnit: DEFAULT_MAJOR_UNIT, min: seriesMin, max: seriesMax }, options2);
    var base = axisOptions2.majorUnit;
    var autoMax = autoAxisMax(seriesMax, base);
    var autoMin = autoAxisMin(seriesMin, seriesMax, axisOptions2);
    var range = initRange(autoMin, autoMax, axisOptions2, options2);
    axisOptions2.max = range.max;
    axisOptions2.min = range.min;
    axisOptions2.minorUnit = options2.minorUnit || round$1(base - 1, DEFAULT_PRECISION);
    Axis2.call(this, axisOptions2, chartService);
    this.totalMin = defined(options2.min) ? Math.min(autoMin, options2.min) : autoMin;
    this.totalMax = defined(options2.max) ? Math.max(autoMax, options2.max) : autoMax;
    this.logMin = round$1(log$1(range.min, base), DEFAULT_PRECISION);
    this.logMax = round$1(log$1(range.max, base), DEFAULT_PRECISION);
    this.seriesMin = seriesMin;
    this.seriesMax = seriesMax;
    this.createLabels();
  }
  if (Axis2)
    LogarithmicAxis2.__proto__ = Axis2;
  LogarithmicAxis2.prototype = Object.create(Axis2 && Axis2.prototype);
  LogarithmicAxis2.prototype.constructor = LogarithmicAxis2;
  LogarithmicAxis2.prototype.clone = function clone3() {
    return new LogarithmicAxis2(
      this.seriesMin,
      this.seriesMax,
      Object.assign({}, this.options),
      this.chartService
    );
  };
  LogarithmicAxis2.prototype.startValue = function startValue() {
    return this.options.min;
  };
  LogarithmicAxis2.prototype.getSlot = function getSlot(a9, b2, limit) {
    var ref2 = this;
    var options2 = ref2.options;
    var logMin = ref2.logMin;
    var logMax = ref2.logMax;
    var base = options2.majorUnit;
    var min2 = options2.min;
    var max2 = options2.max;
    var ref$1 = this.lineInfo();
    var axis = ref$1.axis;
    var axisDir = ref$1.axisDir;
    var lineBox = ref$1.lineBox;
    var lineSize = ref$1.lineSize;
    var lineStart = ref$1.lineStart;
    var step = axisDir * (lineSize / (logMax - logMin));
    var start = valueOrDefault$1(a9, b2 || 1);
    var end = valueOrDefault$1(b2, a9 || 1);
    if (start <= 0 || end <= 0) {
      return null;
    }
    if (limit) {
      start = limitValue(start, min2, max2);
      end = limitValue(end, min2, max2);
    }
    start = log$1(start, base);
    end = log$1(end, base);
    var p1 = Math.min(start, end) - logMin;
    var p22 = Math.max(start, end) - logMin;
    var slotBox = new Box(lineBox.x1, lineBox.y1, lineBox.x1, lineBox.y1);
    slotBox[axis + 1] = limitCoordinate(lineStart + step * (axisDir > 0 ? p1 : p22));
    slotBox[axis + 2] = limitCoordinate(lineStart + step * (axisDir > 0 ? p22 : p1));
    return slotBox;
  };
  LogarithmicAxis2.prototype.getValue = function getValue(point2) {
    var ref2 = this;
    var options2 = ref2.options;
    var logMin = ref2.logMin;
    var logMax = ref2.logMax;
    var base = options2.majorUnit;
    var ref$1 = this.lineInfo();
    var axis = ref$1.axis;
    var axisDir = ref$1.axisDir;
    var lineStart = ref$1.lineStart;
    var lineSize = ref$1.lineSize;
    var step = (logMax - logMin) / lineSize;
    var offset2 = axisDir * (point2[axis] - lineStart);
    var valueOffset = offset2 * step;
    if (offset2 < 0 || offset2 > lineSize) {
      return null;
    }
    var value2 = logMin + valueOffset;
    return round$1(Math.pow(base, value2), DEFAULT_PRECISION);
  };
  LogarithmicAxis2.prototype.range = function range() {
    var options2 = this.options;
    return { min: options2.min, max: options2.max };
  };
  LogarithmicAxis2.prototype.translateRange = function translateRange(delta) {
    var ref2 = this;
    var options2 = ref2.options;
    var logMin = ref2.logMin;
    var logMax = ref2.logMax;
    var reverse = options2.reverse;
    var vertical = options2.vertical;
    var base = options2.majorUnit;
    var lineBox = this.lineBox();
    var size = vertical ? lineBox.height() : lineBox.width();
    var scale = size / (logMax - logMin);
    var offset2 = round$1(delta / scale, DEFAULT_PRECISION);
    if ((vertical || reverse) && !(vertical && reverse)) {
      offset2 = -offset2;
    }
    return {
      min: Math.pow(base, logMin + offset2),
      max: Math.pow(base, logMax + offset2),
      offset: offset2
    };
  };
  LogarithmicAxis2.prototype.labelsCount = function labelsCount() {
    var floorMax = Math.floor(this.logMax);
    var count = Math.floor(floorMax - this.logMin) + 1;
    return count;
  };
  LogarithmicAxis2.prototype.getMajorTickPositions = function getMajorTickPositions() {
    var ticks = [];
    this.traverseMajorTicksPositions(function(position2) {
      ticks.push(position2);
    }, { step: 1, skip: 0 });
    return ticks;
  };
  LogarithmicAxis2.prototype.createTicks = function createTicks(lineGroup) {
    var options2 = this.options;
    var majorTicks = options2.majorTicks;
    var minorTicks = options2.minorTicks;
    var vertical = options2.vertical;
    var mirror = options2.labels.mirror;
    var lineBox = this.lineBox();
    var ticks = [];
    var tickLineOptions = {
      // TODO
      // _alignLines: options._alignLines,
      vertical
    };
    function render(tickPosition, tickOptions) {
      tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;
      tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;
      tickLineOptions.position = tickPosition;
      lineGroup.append(createAxisTick(tickLineOptions, tickOptions));
    }
    if (majorTicks.visible) {
      this.traverseMajorTicksPositions(render, majorTicks);
    }
    if (minorTicks.visible) {
      this.traverseMinorTicksPositions(render, minorTicks);
    }
    return ticks;
  };
  LogarithmicAxis2.prototype.createGridLines = function createGridLines(altAxis) {
    var options2 = this.options;
    var minorGridLines = options2.minorGridLines;
    var majorGridLines = options2.majorGridLines;
    var vertical = options2.vertical;
    var lineBox = altAxis.lineBox();
    var lineOptions = {
      lineStart: lineBox[vertical ? "x1" : "y1"],
      lineEnd: lineBox[vertical ? "x2" : "y2"],
      vertical
    };
    var majorTicks = [];
    var container = this.gridLinesVisual();
    function render(tickPosition, gridLine) {
      if (!inArray(tickPosition, majorTicks)) {
        lineOptions.position = tickPosition;
        container.append(createAxisGridLine(lineOptions, gridLine));
        majorTicks.push(tickPosition);
      }
    }
    if (majorGridLines.visible) {
      this.traverseMajorTicksPositions(render, majorGridLines);
    }
    if (minorGridLines.visible) {
      this.traverseMinorTicksPositions(render, minorGridLines);
    }
    return container.children;
  };
  LogarithmicAxis2.prototype.traverseMajorTicksPositions = function traverseMajorTicksPositions(callback, tickOptions) {
    var ref2 = this.lineInfo();
    var lineStart = ref2.lineStart;
    var step = ref2.step;
    var ref$1 = this;
    var logMin = ref$1.logMin;
    var logMax = ref$1.logMax;
    for (var power = Math.ceil(logMin) + tickOptions.skip; power <= logMax; power += tickOptions.step) {
      var position2 = round$1(lineStart + step * (power - logMin), DEFAULT_PRECISION);
      callback(position2, tickOptions);
    }
  };
  LogarithmicAxis2.prototype.traverseMinorTicksPositions = function traverseMinorTicksPositions(callback, tickOptions) {
    var this$1$1 = this;
    var ref2 = this.options;
    var min2 = ref2.min;
    var max2 = ref2.max;
    var minorUnit = ref2.minorUnit;
    var base = ref2.majorUnit;
    var ref$1 = this.lineInfo();
    var lineStart = ref$1.lineStart;
    var step = ref$1.step;
    var ref$2 = this;
    var logMin = ref$2.logMin;
    var logMax = ref$2.logMax;
    var start = Math.floor(logMin);
    for (var power = start; power < logMax; power++) {
      var minorOptions = this$1$1._minorIntervalOptions(power);
      for (var idx = tickOptions.skip; idx < minorUnit; idx += tickOptions.step) {
        var value2 = minorOptions.value + idx * minorOptions.minorStep;
        if (value2 > max2) {
          break;
        }
        if (value2 >= min2) {
          var position2 = round$1(lineStart + step * (log$1(value2, base) - logMin), DEFAULT_PRECISION);
          callback(position2, tickOptions);
        }
      }
    }
  };
  LogarithmicAxis2.prototype.createAxisLabel = function createAxisLabel(index2, labelOptions, labelContext) {
    var power = Math.ceil(this.logMin + index2);
    var value2 = Math.pow(this.options.majorUnit, power);
    var text = this.axisLabelText(value2, labelOptions, labelContext);
    return new AxisLabel(value2, text, index2, null, labelOptions);
  };
  LogarithmicAxis2.prototype.shouldRenderNote = function shouldRenderNote(value2) {
    var range = this.range();
    return range.min <= value2 && value2 <= range.max;
  };
  LogarithmicAxis2.prototype.pan = function pan(delta) {
    var range = this.translateRange(delta);
    return this.limitRange(range.min, range.max, this.totalMin, this.totalMax, range.offset);
  };
  LogarithmicAxis2.prototype.pointsRange = function pointsRange(start, end) {
    var startValue = this.getValue(start);
    var endValue = this.getValue(end);
    var min2 = Math.min(startValue, endValue);
    var max2 = Math.max(startValue, endValue);
    return {
      min: min2,
      max: max2
    };
  };
  LogarithmicAxis2.prototype.scaleRange = function scaleRange(scale, cursor) {
    var ref2 = this.options;
    var base = ref2.majorUnit;
    var logMin = log$1(this.options.min, base);
    var logMax = log$1(this.options.max, base);
    var position2 = Math.abs(this.pointOffset(cursor));
    var range = logMax - logMin;
    var delta = this.scaleToDelta(scale, range);
    var min2 = Math.pow(base, logMin + position2 * delta);
    var max2 = Math.pow(base, logMax - (1 - position2) * delta);
    if (max2 - min2 < MIN_VALUE_RANGE) {
      max2 = min2 + MIN_VALUE_RANGE;
    }
    return {
      min: min2,
      max: max2
    };
  };
  LogarithmicAxis2.prototype.zoomRange = function zoomRange(scale, cursor) {
    var range = this.scaleRange(scale, cursor);
    var ref2 = this;
    var totalMin = ref2.totalMin;
    var totalMax = ref2.totalMax;
    return {
      min: limitValue(range.min, totalMin, totalMax),
      max: limitValue(range.max, totalMin, totalMax)
    };
  };
  LogarithmicAxis2.prototype._minorIntervalOptions = function _minorIntervalOptions(power) {
    var ref2 = this.options;
    var minorUnit = ref2.minorUnit;
    var base = ref2.majorUnit;
    var value2 = Math.pow(base, power);
    var nextValue = Math.pow(base, power + 1);
    var difference = nextValue - value2;
    var minorStep = difference / minorUnit;
    return {
      value: value2,
      minorStep
    };
  };
  LogarithmicAxis2.prototype.lineInfo = function lineInfo() {
    var info = Axis2.prototype.lineInfo.call(this);
    info.step = info.axisDir * (info.lineSize / (this.logMax - this.logMin));
    return info;
  };
  return LogarithmicAxis2;
}(Axis);
function initRange(autoMin, autoMax, axisOptions2, options2) {
  var min2 = axisOptions2.min;
  var max2 = axisOptions2.max;
  if (defined(axisOptions2.axisCrossingValue) && axisOptions2.axisCrossingValue <= 0) {
    throwNegativeValuesError();
  }
  if (!defined(options2.max)) {
    max2 = autoMax;
  } else if (options2.max <= 0) {
    throwNegativeValuesError();
  }
  if (!defined(options2.min)) {
    min2 = autoMin;
  } else if (options2.min <= 0) {
    throwNegativeValuesError();
  }
  return {
    min: min2,
    max: max2
  };
}
function autoAxisMin(min2, max2, options2) {
  var base = options2.majorUnit;
  var autoMin = min2;
  if (min2 <= 0) {
    autoMin = max2 <= 1 ? Math.pow(base, -2) : 1;
  } else if (!options2.narrowRange) {
    autoMin = Math.pow(base, Math.floor(log$1(min2, base)));
  }
  return autoMin;
}
function autoAxisMax(max2, base) {
  var logMaxRemainder = round$1(log$1(max2, base), DEFAULT_PRECISION) % 1;
  var autoMax;
  if (max2 <= 0) {
    autoMax = base;
  } else if (logMaxRemainder !== 0 && (logMaxRemainder < 0.3 || logMaxRemainder > 0.9)) {
    autoMax = Math.pow(base, log$1(max2, base) + 0.2);
  } else {
    autoMax = Math.pow(base, Math.ceil(log$1(max2, base)));
  }
  return autoMax;
}
function throwNegativeValuesError() {
  throw new Error("Non positive values cannot be used for a logarithmic axis");
}
function log$1(x3, base) {
  return Math.log(x3) / Math.log(base);
}
setDefaultOptions(LogarithmicAxis, {
  type: "log",
  majorUnit: DEFAULT_MAJOR_UNIT,
  minorUnit: 1,
  axisCrossingValue: 1,
  vertical: true,
  majorGridLines: {
    visible: true,
    width: 1,
    color: BLACK$1
  },
  zIndex: 1,
  _deferLabels: true
});
var GridLinesMixin = {
  createGridLines: function(altAxis) {
    var options2 = this.options;
    var radius = Math.abs(this.box.center().y - altAxis.lineBox().y1);
    var gridLines = [];
    var skipMajor = false;
    var majorAngles, minorAngles;
    if (options2.majorGridLines.visible) {
      majorAngles = this.majorGridLineAngles(altAxis);
      skipMajor = true;
      gridLines = this.renderMajorGridLines(
        majorAngles,
        radius,
        options2.majorGridLines
      );
    }
    if (options2.minorGridLines.visible) {
      minorAngles = this.minorGridLineAngles(altAxis, skipMajor);
      append(gridLines, this.renderMinorGridLines(
        minorAngles,
        radius,
        options2.minorGridLines,
        altAxis,
        skipMajor
      ));
    }
    return gridLines;
  },
  renderMajorGridLines: function(angles, radius, options2) {
    return this.renderGridLines(angles, radius, options2);
  },
  renderMinorGridLines: function(angles, radius, options2, altAxis, skipMajor) {
    var radiusCallback = this.radiusCallback && this.radiusCallback(radius, altAxis, skipMajor);
    return this.renderGridLines(angles, radius, options2, radiusCallback);
  },
  renderGridLines: function(angles, radius, options2, radiusCallback) {
    var style2 = {
      stroke: {
        width: options2.width,
        color: options2.color,
        dashType: options2.dashType
      }
    };
    var center = this.box.center();
    var circle = new geomCircle([center.x, center.y], radius);
    var container = this.gridLinesVisual();
    for (var i16 = 0; i16 < angles.length; i16++) {
      var line = new Path$7(style2);
      if (radiusCallback) {
        circle.radius = radiusCallback(angles[i16]);
      }
      line.moveTo(circle.center).lineTo(circle.pointAt(angles[i16] + 180));
      container.append(line);
    }
    return container.children;
  },
  gridLineAngles: function(altAxis, size, skip, step, skipAngles) {
    var this$1$1 = this;
    var divs = this.intervals(size, skip, step, skipAngles);
    var options2 = altAxis.options;
    var altAxisVisible = options2.visible && (options2.line || {}).visible !== false;
    return map(divs, function(d8) {
      var alpha = this$1$1.intervalAngle(d8);
      if (!altAxisVisible || alpha !== 90) {
        return alpha;
      }
    });
  }
};
var RadarCategoryAxis = function(CategoryAxis2) {
  function RadarCategoryAxis2() {
    CategoryAxis2.apply(this, arguments);
  }
  if (CategoryAxis2)
    RadarCategoryAxis2.__proto__ = CategoryAxis2;
  RadarCategoryAxis2.prototype = Object.create(CategoryAxis2 && CategoryAxis2.prototype);
  RadarCategoryAxis2.prototype.constructor = RadarCategoryAxis2;
  RadarCategoryAxis2.prototype.range = function range() {
    return { min: 0, max: this.options.categories.length };
  };
  RadarCategoryAxis2.prototype.reflow = function reflow(box) {
    this.box = box;
    this.reflowLabels();
  };
  RadarCategoryAxis2.prototype.lineBox = function lineBox() {
    return this.box;
  };
  RadarCategoryAxis2.prototype.reflowLabels = function reflowLabels() {
    var this$1$1 = this;
    var ref2 = this;
    var labels = ref2.labels;
    var labelOptions = ref2.options.labels;
    var skip = labelOptions.skip || 0;
    var step = labelOptions.step || 1;
    var measureBox = new Box();
    for (var i16 = 0; i16 < labels.length; i16++) {
      labels[i16].reflow(measureBox);
      var labelBox = labels[i16].box;
      labels[i16].reflow(this$1$1.getSlot(skip + i16 * step).adjacentBox(
        0,
        labelBox.width(),
        labelBox.height()
      ));
    }
  };
  RadarCategoryAxis2.prototype.intervals = function intervals(size, skipOption, stepOption, skipAngles) {
    if (skipAngles === void 0)
      skipAngles = false;
    var options2 = this.options;
    var categories = options2.categories.length;
    var divCount = categories / size || 1;
    var divAngle = 360 / divCount;
    var skip = skipOption || 0;
    var step = stepOption || 1;
    var divs = [];
    var angle = 0;
    for (var i16 = skip; i16 < divCount; i16 += step) {
      if (options2.reverse) {
        angle = 360 - i16 * divAngle;
      } else {
        angle = i16 * divAngle;
      }
      angle = round$1(angle, COORD_PRECISION) % 360;
      if (!(skipAngles && inArray(angle, skipAngles))) {
        divs.push(angle);
      }
    }
    return divs;
  };
  RadarCategoryAxis2.prototype.majorIntervals = function majorIntervals() {
    return this.intervals(1);
  };
  RadarCategoryAxis2.prototype.minorIntervals = function minorIntervals() {
    return this.intervals(0.5);
  };
  RadarCategoryAxis2.prototype.intervalAngle = function intervalAngle(interval) {
    return (360 + interval + this.options.startAngle) % 360;
  };
  RadarCategoryAxis2.prototype.majorAngles = function majorAngles() {
    var this$1$1 = this;
    return map(this.majorIntervals(), function(interval) {
      return this$1$1.intervalAngle(interval);
    });
  };
  RadarCategoryAxis2.prototype.createLine = function createLine() {
    return [];
  };
  RadarCategoryAxis2.prototype.majorGridLineAngles = function majorGridLineAngles(altAxis) {
    var majorGridLines = this.options.majorGridLines;
    return this.gridLineAngles(altAxis, 1, majorGridLines.skip, majorGridLines.step);
  };
  RadarCategoryAxis2.prototype.minorGridLineAngles = function minorGridLineAngles(altAxis, skipMajor) {
    var ref2 = this.options;
    var minorGridLines = ref2.minorGridLines;
    var majorGridLines = ref2.majorGridLines;
    var majorGridLineAngles = skipMajor ? this.intervals(1, majorGridLines.skip, majorGridLines.step) : null;
    return this.gridLineAngles(altAxis, 0.5, minorGridLines.skip, minorGridLines.step, majorGridLineAngles);
  };
  RadarCategoryAxis2.prototype.radiusCallback = function radiusCallback(radius, altAxis, skipMajor) {
    if (altAxis.options.type !== ARC) {
      var minorAngle = rad(360 / (this.options.categories.length * 2));
      var minorRadius = Math.cos(minorAngle) * radius;
      var majorAngles = this.majorAngles();
      var radiusCallback2 = function(angle) {
        if (!skipMajor && inArray(angle, majorAngles)) {
          return radius;
        }
        return minorRadius;
      };
      return radiusCallback2;
    }
  };
  RadarCategoryAxis2.prototype.createPlotBands = function createPlotBands() {
    var this$1$1 = this;
    var plotBands = this.options.plotBands || [];
    var group2 = this._plotbandGroup = new Group$9({
      zIndex: -1
    });
    for (var i16 = 0; i16 < plotBands.length; i16++) {
      var band = plotBands[i16];
      var slot = this$1$1.plotBandSlot(band);
      var singleSlot = this$1$1.getSlot(band.from);
      var head = band.from - Math.floor(band.from);
      slot.startAngle += head * singleSlot.angle;
      var tail = Math.ceil(band.to) - band.to;
      slot.angle -= (tail + head) * singleSlot.angle;
      var ring = ShapeBuilder.current.createRing(slot, {
        fill: {
          color: band.color,
          opacity: band.opacity
        },
        stroke: {
          opacity: band.opacity
        }
      });
      group2.append(ring);
    }
    this.appendVisual(group2);
  };
  RadarCategoryAxis2.prototype.plotBandSlot = function plotBandSlot(band) {
    return this.getSlot(band.from, band.to - 1);
  };
  RadarCategoryAxis2.prototype.getSlot = function getSlot(from, to) {
    var options2 = this.options;
    var justified = options2.justified;
    var box = this.box;
    var divs = this.majorAngles();
    var totalDivs = divs.length;
    var slotAngle = 360 / totalDivs;
    var fromValue = from;
    if (options2.reverse && !justified) {
      fromValue = (fromValue + 1) % totalDivs;
    }
    fromValue = limitValue(Math.floor(fromValue), 0, totalDivs - 1);
    var slotStart = divs[fromValue];
    if (justified) {
      slotStart = slotStart - slotAngle / 2;
      if (slotStart < 0) {
        slotStart += 360;
      }
    }
    var toValue = limitValue(Math.ceil(to || fromValue), fromValue, totalDivs - 1);
    var slots = toValue - fromValue + 1;
    var angle = slotAngle * slots;
    return new Ring(box.center(), 0, box.height() / 2, slotStart, angle);
  };
  RadarCategoryAxis2.prototype.slot = function slot(from, to) {
    var slot2 = this.getSlot(from, to);
    var startAngle = slot2.startAngle + 180;
    var endAngle = startAngle + slot2.angle;
    return new GeometryArc([slot2.center.x, slot2.center.y], {
      startAngle,
      endAngle,
      radiusX: slot2.radius,
      radiusY: slot2.radius
    });
  };
  RadarCategoryAxis2.prototype.pointCategoryIndex = function pointCategoryIndex(point2) {
    var this$1$1 = this;
    var length = this.options.categories.length;
    var index2 = null;
    for (var i16 = 0; i16 < length; i16++) {
      var slot = this$1$1.getSlot(i16);
      if (slot.containsPoint(point2)) {
        index2 = i16;
        break;
      }
    }
    return index2;
  };
  return RadarCategoryAxis2;
}(CategoryAxis);
setDefaultOptions(RadarCategoryAxis, {
  startAngle: 90,
  labels: {
    margin: getSpacing(10)
  },
  majorGridLines: {
    visible: true
  },
  justified: true
});
deepExtend(RadarCategoryAxis.prototype, GridLinesMixin);
var PolarAxis = function(Axis2) {
  function PolarAxis2(options2, chartService) {
    Axis2.call(this, options2, chartService);
    var instanceOptions = this.options;
    instanceOptions.minorUnit = instanceOptions.minorUnit || instanceOptions.majorUnit / 2;
  }
  if (Axis2)
    PolarAxis2.__proto__ = Axis2;
  PolarAxis2.prototype = Object.create(Axis2 && Axis2.prototype);
  PolarAxis2.prototype.constructor = PolarAxis2;
  PolarAxis2.prototype.getDivisions = function getDivisions(stepValue) {
    return NumericAxis.prototype.getDivisions.call(this, stepValue) - 1;
  };
  PolarAxis2.prototype.reflow = function reflow(box) {
    this.box = box;
    this.reflowLabels();
  };
  PolarAxis2.prototype.reflowLabels = function reflowLabels() {
    var this$1$1 = this;
    var ref2 = this;
    var options2 = ref2.options;
    var labels = ref2.labels;
    var labelOptions = ref2.options.labels;
    var skip = labelOptions.skip || 0;
    var step = labelOptions.step || 1;
    var measureBox = new Box();
    var divs = this.intervals(options2.majorUnit, skip, step);
    for (var i16 = 0; i16 < labels.length; i16++) {
      labels[i16].reflow(measureBox);
      var labelBox = labels[i16].box;
      labels[i16].reflow(this$1$1.getSlot(divs[i16]).adjacentBox(0, labelBox.width(), labelBox.height()));
    }
  };
  PolarAxis2.prototype.lineBox = function lineBox() {
    return this.box;
  };
  PolarAxis2.prototype.intervals = function intervals(size, skipOption, stepOption, skipAngles) {
    if (skipAngles === void 0)
      skipAngles = false;
    var min2 = this.options.min;
    var divisions = this.getDivisions(size);
    var divs = [];
    var skip = skipOption || 0;
    var step = stepOption || 1;
    for (var i16 = skip; i16 < divisions; i16 += step) {
      var current2 = (360 + min2 + i16 * size) % 360;
      if (!(skipAngles && inArray(current2, skipAngles))) {
        divs.push(current2);
      }
    }
    return divs;
  };
  PolarAxis2.prototype.majorIntervals = function majorIntervals() {
    return this.intervals(this.options.majorUnit);
  };
  PolarAxis2.prototype.minorIntervals = function minorIntervals() {
    return this.intervals(this.options.minorUnit);
  };
  PolarAxis2.prototype.intervalAngle = function intervalAngle(i16) {
    return (540 - i16 - this.options.startAngle) % 360;
  };
  PolarAxis2.prototype.createLine = function createLine() {
    return [];
  };
  PolarAxis2.prototype.majorGridLineAngles = function majorGridLineAngles(altAxis) {
    var majorGridLines = this.options.majorGridLines;
    return this.gridLineAngles(altAxis, this.options.majorUnit, majorGridLines.skip, majorGridLines.step);
  };
  PolarAxis2.prototype.minorGridLineAngles = function minorGridLineAngles(altAxis, skipMajor) {
    var options2 = this.options;
    var minorGridLines = options2.minorGridLines;
    var majorGridLines = options2.majorGridLines;
    var majorGridLineAngles = skipMajor ? this.intervals(options2.majorUnit, majorGridLines.skip, majorGridLines.step) : null;
    return this.gridLineAngles(altAxis, options2.minorUnit, minorGridLines.skip, minorGridLines.step, majorGridLineAngles);
  };
  PolarAxis2.prototype.plotBandSlot = function plotBandSlot(band) {
    return this.getSlot(band.from, band.to);
  };
  PolarAxis2.prototype.getSlot = function getSlot(a9, b2) {
    var ref2 = this;
    var options2 = ref2.options;
    var box = ref2.box;
    var startAngle = options2.startAngle;
    var start = limitValue(a9, options2.min, options2.max);
    var end = limitValue(b2 || start, start, options2.max);
    if (options2.reverse) {
      start *= -1;
      end *= -1;
    }
    start = (540 - start - startAngle) % 360;
    end = (540 - end - startAngle) % 360;
    if (end < start) {
      var tmp = start;
      start = end;
      end = tmp;
    }
    return new Ring(box.center(), 0, box.height() / 2, start, end - start);
  };
  PolarAxis2.prototype.slot = function slot(from, to) {
    if (to === void 0)
      to = from;
    var options2 = this.options;
    var start = 360 - options2.startAngle;
    var slot2 = this.getSlot(from, to);
    var min2 = Math.min(from, to);
    var max2 = Math.max(from, to);
    var startAngle, endAngle;
    if (options2.reverse) {
      startAngle = min2;
      endAngle = max2;
    } else {
      startAngle = 360 - max2;
      endAngle = 360 - min2;
    }
    startAngle = (startAngle + start) % 360;
    endAngle = (endAngle + start) % 360;
    return new GeometryArc([slot2.center.x, slot2.center.y], {
      startAngle,
      endAngle,
      radiusX: slot2.radius,
      radiusY: slot2.radius
    });
  };
  PolarAxis2.prototype.getValue = function getValue(point2) {
    var options2 = this.options;
    var center = this.box.center();
    var dx = point2.x - center.x;
    var dy = point2.y - center.y;
    var theta = Math.round(deg(Math.atan2(dy, dx)));
    var start = options2.startAngle;
    if (!options2.reverse) {
      theta *= -1;
      start *= -1;
    }
    return (theta + start + 360) % 360;
  };
  PolarAxis2.prototype.valueRange = function valueRange3() {
    return {
      min: 0,
      max: Math.PI * 2
    };
  };
  return PolarAxis2;
}(Axis);
setDefaultOptions(PolarAxis, {
  type: "polar",
  startAngle: 0,
  reverse: false,
  majorUnit: 60,
  min: 0,
  max: 360,
  labels: {
    margin: getSpacing(10)
  },
  majorGridLines: {
    color: BLACK$1,
    visible: true,
    width: 1
  },
  minorGridLines: {
    color: "#aaa"
  }
});
deepExtend(PolarAxis.prototype, GridLinesMixin, {
  createPlotBands: RadarCategoryAxis.prototype.createPlotBands,
  majorAngles: RadarCategoryAxis.prototype.majorAngles,
  range: NumericAxis.prototype.range,
  labelsCount: NumericAxis.prototype.labelsCount,
  createAxisLabel: NumericAxis.prototype.createAxisLabel
});
var RadarNumericAxisMixin = {
  options: {
    majorGridLines: {
      visible: true
    }
  },
  createPlotBands: function() {
    var this$1$1 = this;
    var ref2 = this.options;
    var type = ref2.majorGridLines.type;
    var plotBands = ref2.plotBands;
    if (plotBands === void 0)
      plotBands = [];
    var altAxis = this.plotArea.polarAxis;
    var majorAngles = altAxis.majorAngles();
    var center = altAxis.box.center();
    var group2 = this._plotbandGroup = new Group$9({
      zIndex: -1
    });
    for (var i16 = 0; i16 < plotBands.length; i16++) {
      var band = plotBands[i16];
      var bandStyle = {
        fill: {
          color: band.color,
          opacity: band.opacity
        },
        stroke: {
          opacity: band.opacity
        }
      };
      var slot = this$1$1.getSlot(band.from, band.to, true);
      var ring = new Ring(center, center.y - slot.y2, center.y - slot.y1, 0, 360);
      var shape = void 0;
      if (type === ARC) {
        shape = ShapeBuilder.current.createRing(ring, bandStyle);
      } else {
        shape = Path$7.fromPoints(this$1$1.plotBandPoints(ring, majorAngles), bandStyle).close();
      }
      group2.append(shape);
    }
    this.appendVisual(group2);
  },
  plotBandPoints: function(ring, angles) {
    var innerPoints = [];
    var outerPoints = [];
    var center = [ring.center.x, ring.center.y];
    var innerCircle = new geomCircle(center, ring.innerRadius);
    var outerCircle = new geomCircle(center, ring.radius);
    for (var i16 = 0; i16 < angles.length; i16++) {
      innerPoints.push(innerCircle.pointAt(angles[i16] + 180));
      outerPoints.push(outerCircle.pointAt(angles[i16] + 180));
    }
    innerPoints.reverse();
    innerPoints.push(innerPoints[0]);
    outerPoints.push(outerPoints[0]);
    return outerPoints.concat(innerPoints);
  },
  createGridLines: function(altAxis) {
    var options2 = this.options;
    var majorTicks = this.radarMajorGridLinePositions();
    var majorAngles = altAxis.majorAngles();
    var center = altAxis.box.center();
    var gridLines = [];
    if (options2.majorGridLines.visible) {
      gridLines = this.renderGridLines(
        center,
        majorTicks,
        majorAngles,
        options2.majorGridLines
      );
    }
    if (options2.minorGridLines.visible) {
      var minorTicks = this.radarMinorGridLinePositions();
      append(gridLines, this.renderGridLines(
        center,
        minorTicks,
        majorAngles,
        options2.minorGridLines
      ));
    }
    return gridLines;
  },
  renderGridLines: function(center, ticks, angles, options2) {
    var style2 = {
      stroke: {
        width: options2.width,
        color: options2.color,
        dashType: options2.dashType
      }
    };
    var skip = options2.skip;
    if (skip === void 0)
      skip = 0;
    var step = options2.step;
    if (step === void 0)
      step = 0;
    var container = this.gridLinesVisual();
    for (var tickIx = skip; tickIx < ticks.length; tickIx += step) {
      var tickRadius = center.y - ticks[tickIx];
      if (tickRadius > 0) {
        var circle = new geomCircle([center.x, center.y], tickRadius);
        if (options2.type === ARC) {
          container.append(new Circle$3(circle, style2));
        } else {
          var line = new Path$7(style2);
          for (var angleIx = 0; angleIx < angles.length; angleIx++) {
            line.lineTo(circle.pointAt(angles[angleIx] + 180));
          }
          line.close();
          container.append(line);
        }
      }
    }
    return container.children;
  },
  getValue: function(point2) {
    var lineBox = this.lineBox();
    var altAxis = this.plotArea.polarAxis;
    var majorAngles = altAxis.majorAngles();
    var center = altAxis.box.center();
    var radius = point2.distanceTo(center);
    var distance = radius;
    if (this.options.majorGridLines.type !== ARC && majorAngles.length > 1) {
      var dx = point2.x - center.x;
      var dy = point2.y - center.y;
      var theta = (deg(Math.atan2(dy, dx)) + 540) % 360;
      majorAngles.sort(function(a9, b2) {
        return angularDistance(a9, theta) - angularDistance(b2, theta);
      });
      var midAngle = angularDistance(majorAngles[0], majorAngles[1]) / 2;
      var alpha = angularDistance(theta, majorAngles[0]);
      var gamma = 90 - midAngle;
      var beta = 180 - alpha - gamma;
      distance = radius * (Math.sin(rad(beta)) / Math.sin(rad(gamma)));
    }
    return this.axisType().prototype.getValue.call(
      this,
      new Point$5(lineBox.x1, lineBox.y2 - distance)
    );
  }
};
function angularDistance(a9, b2) {
  return 180 - Math.abs(Math.abs(a9 - b2) - 180);
}
var RadarNumericAxis = function(NumericAxis2) {
  function RadarNumericAxis2() {
    NumericAxis2.apply(this, arguments);
  }
  if (NumericAxis2)
    RadarNumericAxis2.__proto__ = NumericAxis2;
  RadarNumericAxis2.prototype = Object.create(NumericAxis2 && NumericAxis2.prototype);
  RadarNumericAxis2.prototype.constructor = RadarNumericAxis2;
  RadarNumericAxis2.prototype.radarMajorGridLinePositions = function radarMajorGridLinePositions() {
    return this.getTickPositions(this.options.majorUnit);
  };
  RadarNumericAxis2.prototype.radarMinorGridLinePositions = function radarMinorGridLinePositions() {
    var options2 = this.options;
    var minorSkipStep = 0;
    if (options2.majorGridLines.visible) {
      minorSkipStep = options2.majorUnit;
    }
    return this.getTickPositions(options2.minorUnit, minorSkipStep);
  };
  RadarNumericAxis2.prototype.axisType = function axisType() {
    return NumericAxis2;
  };
  return RadarNumericAxis2;
}(NumericAxis);
deepExtend(RadarNumericAxis.prototype, RadarNumericAxisMixin);
var RadarLogarithmicAxis = function(LogarithmicAxis2) {
  function RadarLogarithmicAxis2() {
    LogarithmicAxis2.apply(this, arguments);
  }
  if (LogarithmicAxis2)
    RadarLogarithmicAxis2.__proto__ = LogarithmicAxis2;
  RadarLogarithmicAxis2.prototype = Object.create(LogarithmicAxis2 && LogarithmicAxis2.prototype);
  RadarLogarithmicAxis2.prototype.constructor = RadarLogarithmicAxis2;
  RadarLogarithmicAxis2.prototype.radarMajorGridLinePositions = function radarMajorGridLinePositions() {
    var positions = [];
    this.traverseMajorTicksPositions(function(position2) {
      positions.push(position2);
    }, this.options.majorGridLines);
    return positions;
  };
  RadarLogarithmicAxis2.prototype.radarMinorGridLinePositions = function radarMinorGridLinePositions() {
    var positions = [];
    this.traverseMinorTicksPositions(function(position2) {
      positions.push(position2);
    }, this.options.minorGridLines);
    return positions;
  };
  RadarLogarithmicAxis2.prototype.axisType = function axisType() {
    return LogarithmicAxis2;
  };
  return RadarLogarithmicAxis2;
}(LogarithmicAxis);
deepExtend(RadarLogarithmicAxis.prototype, RadarNumericAxisMixin);
var WEIGHT = 0.333;
var EXTREMUM_ALLOWED_DEVIATION = 0.01;
var CurveProcessor = function(Class3) {
  function CurveProcessor2(closed) {
    Class3.call(this);
    this.closed = closed;
  }
  if (Class3)
    CurveProcessor2.__proto__ = Class3;
  CurveProcessor2.prototype = Object.create(Class3 && Class3.prototype);
  CurveProcessor2.prototype.constructor = CurveProcessor2;
  CurveProcessor2.prototype.process = function process(dataPoints) {
    var this$1$1 = this;
    var points2 = dataPoints.slice(0);
    var segments = [];
    var closed = this.closed;
    var length = points2.length;
    if (length > 2) {
      this.removeDuplicates(0, points2);
      length = points2.length;
    }
    if (length < 2 || length === 2 && points2[0].equals(points2[1])) {
      return segments;
    }
    var p0 = points2[0];
    var p1 = points2[1];
    var p22 = points2[2];
    segments.push(new Segment$1(p0));
    while (p0.equals(points2[length - 1])) {
      closed = true;
      points2.pop();
      length--;
    }
    if (length === 2) {
      var tangent = this.tangent(p0, p1, X$4, Y$7);
      last(segments).controlOut(
        this.firstControlPoint(tangent, p0, p1, X$4, Y$7)
      );
      segments.push(new Segment$1(
        p1,
        this.secondControlPoint(tangent, p0, p1, X$4, Y$7)
      ));
      return segments;
    }
    var initialControlPoint, lastControlPoint;
    if (closed) {
      p0 = points2[length - 1];
      p1 = points2[0];
      p22 = points2[1];
      var controlPoints = this.controlPoints(p0, p1, p22);
      initialControlPoint = controlPoints[1];
      lastControlPoint = controlPoints[0];
    } else {
      var tangent$1 = this.tangent(p0, p1, X$4, Y$7);
      initialControlPoint = this.firstControlPoint(tangent$1, p0, p1, X$4, Y$7);
    }
    var cp0 = initialControlPoint;
    for (var idx = 0; idx <= length - 3; idx++) {
      this$1$1.removeDuplicates(idx, points2);
      length = points2.length;
      if (idx + 3 <= length) {
        p0 = points2[idx];
        p1 = points2[idx + 1];
        p22 = points2[idx + 2];
        var controlPoints$1 = this$1$1.controlPoints(p0, p1, p22);
        last(segments).controlOut(cp0);
        cp0 = controlPoints$1[1];
        var cp1 = controlPoints$1[0];
        segments.push(new Segment$1(p1, cp1));
      }
    }
    if (closed) {
      p0 = points2[length - 2];
      p1 = points2[length - 1];
      p22 = points2[0];
      var controlPoints$2 = this.controlPoints(p0, p1, p22);
      last(segments).controlOut(cp0);
      segments.push(new Segment$1(
        p1,
        controlPoints$2[0]
      ));
      last(segments).controlOut(controlPoints$2[1]);
      segments.push(new Segment$1(
        p22,
        lastControlPoint
      ));
    } else {
      var tangent$2 = this.tangent(p1, p22, X$4, Y$7);
      last(segments).controlOut(cp0);
      segments.push(new Segment$1(
        p22,
        this.secondControlPoint(tangent$2, p1, p22, X$4, Y$7)
      ));
    }
    return segments;
  };
  CurveProcessor2.prototype.removeDuplicates = function removeDuplicates2(idx, points2) {
    while (points2[idx + 1] && (points2[idx].equals(points2[idx + 1]) || points2[idx + 1].equals(points2[idx + 2]))) {
      points2.splice(idx + 1, 1);
    }
  };
  CurveProcessor2.prototype.invertAxis = function invertAxis2(p0, p1, p22) {
    var invertAxis3 = false;
    if (p0.x === p1.x) {
      invertAxis3 = true;
    } else if (p1.x === p22.x) {
      if (p1.y < p22.y && p0.y <= p1.y || p22.y < p1.y && p1.y <= p0.y) {
        invertAxis3 = true;
      }
    } else {
      var fn = this.lineFunction(p0, p1);
      var y22 = this.calculateFunction(fn, p22.x);
      if (!(p0.y <= p1.y && p22.y <= y22) && !(p1.y <= p0.y && p22.y >= y22)) {
        invertAxis3 = true;
      }
    }
    return invertAxis3;
  };
  CurveProcessor2.prototype.isLine = function isLine2(p0, p1, p22) {
    var fn = this.lineFunction(p0, p1);
    var y22 = this.calculateFunction(fn, p22.x);
    return p0.x === p1.x && p1.x === p22.x || round$1(y22, 1) === round$1(p22.y, 1);
  };
  CurveProcessor2.prototype.lineFunction = function lineFunction2(p1, p22) {
    var a9 = (p22.y - p1.y) / (p22.x - p1.x);
    var b2 = p1.y - a9 * p1.x;
    return [b2, a9];
  };
  CurveProcessor2.prototype.controlPoints = function controlPoints(p0, p1, p22) {
    var xField = X$4;
    var yField = Y$7;
    var restrict = false;
    var switchOrientation = false;
    var tangent;
    if (this.isLine(p0, p1, p22)) {
      tangent = this.tangent(p0, p1, X$4, Y$7);
    } else {
      var monotonic = {
        x: this.isMonotonicByField(p0, p1, p22, X$4),
        y: this.isMonotonicByField(p0, p1, p22, Y$7)
      };
      if (monotonic.x && monotonic.y) {
        tangent = this.tangent(p0, p22, X$4, Y$7);
        restrict = true;
      } else {
        if (this.invertAxis(p0, p1, p22)) {
          xField = Y$7;
          yField = X$4;
        }
        if (monotonic[xField]) {
          tangent = 0;
        } else {
          var sign;
          if (p22[yField] < p0[yField] && p0[yField] <= p1[yField] || p0[yField] < p22[yField] && p1[yField] <= p0[yField]) {
            sign = numberSign((p22[yField] - p0[yField]) * (p1[xField] - p0[xField]));
          } else {
            sign = -numberSign((p22[xField] - p0[xField]) * (p1[yField] - p0[yField]));
          }
          tangent = EXTREMUM_ALLOWED_DEVIATION * sign;
          switchOrientation = true;
        }
      }
    }
    var secondControlPoint2 = this.secondControlPoint(tangent, p0, p1, xField, yField);
    if (switchOrientation) {
      var oldXField = xField;
      xField = yField;
      yField = oldXField;
    }
    var firstControlPoint2 = this.firstControlPoint(tangent, p1, p22, xField, yField);
    if (restrict) {
      this.restrictControlPoint(p0, p1, secondControlPoint2, tangent);
      this.restrictControlPoint(p1, p22, firstControlPoint2, tangent);
    }
    return [secondControlPoint2, firstControlPoint2];
  };
  CurveProcessor2.prototype.restrictControlPoint = function restrictControlPoint2(p1, p22, cp, tangent) {
    if (p1.y < p22.y) {
      if (p22.y < cp.y) {
        cp.x = p1.x + (p22.y - p1.y) / tangent;
        cp.y = p22.y;
      } else if (cp.y < p1.y) {
        cp.x = p22.x - (p22.y - p1.y) / tangent;
        cp.y = p1.y;
      }
    } else {
      if (cp.y < p22.y) {
        cp.x = p1.x - (p1.y - p22.y) / tangent;
        cp.y = p22.y;
      } else if (p1.y < cp.y) {
        cp.x = p22.x + (p1.y - p22.y) / tangent;
        cp.y = p1.y;
      }
    }
  };
  CurveProcessor2.prototype.tangent = function tangent(p0, p1, xField, yField) {
    var x3 = p1[xField] - p0[xField];
    var y4 = p1[yField] - p0[yField];
    var tangent2;
    if (x3 === 0) {
      tangent2 = 0;
    } else {
      tangent2 = y4 / x3;
    }
    return tangent2;
  };
  CurveProcessor2.prototype.isMonotonicByField = function isMonotonicByField2(p0, p1, p22, field) {
    return p22[field] > p1[field] && p1[field] > p0[field] || p22[field] < p1[field] && p1[field] < p0[field];
  };
  CurveProcessor2.prototype.firstControlPoint = function firstControlPoint2(tangent, p0, p32, xField, yField) {
    var t1 = p0[xField];
    var t22 = p32[xField];
    var distance = (t22 - t1) * WEIGHT;
    return this.point(t1 + distance, p0[yField] + distance * tangent, xField, yField);
  };
  CurveProcessor2.prototype.secondControlPoint = function secondControlPoint2(tangent, p0, p32, xField, yField) {
    var t1 = p0[xField];
    var t22 = p32[xField];
    var distance = (t22 - t1) * WEIGHT;
    return this.point(t22 - distance, p32[yField] - distance * tangent, xField, yField);
  };
  CurveProcessor2.prototype.point = function point2(xValue, yValue, xField, yField) {
    var controlPoint = new Point$7();
    controlPoint[xField] = xValue;
    controlPoint[yField] = yValue;
    return controlPoint;
  };
  CurveProcessor2.prototype.calculateFunction = function calculateFunction2(fn, x3) {
    var length = fn.length;
    var result = 0;
    for (var i16 = 0; i16 < length; i16++) {
      result += Math.pow(x3, i16) * fn[i16];
    }
    return result;
  };
  return CurveProcessor2;
}(Class$1);
function numberSign(value2) {
  return value2 <= 0 ? -1 : 1;
}
var ChartAxis = function(Class3) {
  function ChartAxis2(axis) {
    Class3.call(this);
    this._axis = axis;
    this.options = axis.options;
  }
  if (Class3)
    ChartAxis2.__proto__ = Class3;
  ChartAxis2.prototype = Object.create(Class3 && Class3.prototype);
  ChartAxis2.prototype.constructor = ChartAxis2;
  ChartAxis2.prototype.value = function value2(point2) {
    var axis = this._axis;
    var value3 = axis.getCategory ? axis.getCategory(point2) : axis.getValue(point2);
    return value3;
  };
  ChartAxis2.prototype.slot = function slot(from, to, limit) {
    if (limit === void 0)
      limit = true;
    return this._axis.slot(from, to, limit);
  };
  ChartAxis2.prototype.range = function range() {
    return this._axis.range();
  };
  ChartAxis2.prototype.valueRange = function valueRange3() {
    return this._axis.valueRange();
  };
  return ChartAxis2;
}(Class$1);
function findAxisByName(name2, axes) {
  for (var idx = 0; idx < axes.length; idx++) {
    if (axes[idx].options.name === name2) {
      axes[idx].prepareUserOptions();
      return new ChartAxis(axes[idx]);
    }
  }
}
var ChartPane = function ChartPane2(pane) {
  this.visual = pane.visual;
  this.chartsVisual = pane.chartContainer.visual;
  this._pane = pane;
};
ChartPane.prototype.findAxisByName = function findAxisByName$1(name2) {
  return findAxisByName(name2, this._pane.axes);
};
var ChartPlotArea = function(Class3) {
  function ChartPlotArea2(plotArea) {
    Class3.call(this);
    this._plotArea = plotArea;
    this.visual = plotArea.visual;
    this.backgroundVisual = plotArea._bgVisual;
  }
  if (Class3)
    ChartPlotArea2.__proto__ = Class3;
  ChartPlotArea2.prototype = Object.create(Class3 && Class3.prototype);
  ChartPlotArea2.prototype.constructor = ChartPlotArea2;
  return ChartPlotArea2;
}(Class$1);
function countNumbers(values6) {
  var length = values6.length;
  var count = 0;
  for (var i16 = 0; i16 < length; i16++) {
    var num = values6[i16];
    if (isNumber(num)) {
      count++;
    }
  }
  return count;
}
var Aggregates = {
  min: function(values6) {
    var length = values6.length;
    var min2 = MAX_VALUE;
    for (var i16 = 0; i16 < length; i16++) {
      var value2 = values6[i16];
      if (isNumber(value2)) {
        min2 = Math.min(min2, value2);
      }
    }
    return min2 === MAX_VALUE ? values6[0] : min2;
  },
  max: function(values6) {
    var length = values6.length;
    var max2 = MIN_VALUE;
    for (var i16 = 0; i16 < length; i16++) {
      var value2 = values6[i16];
      if (isNumber(value2)) {
        max2 = Math.max(max2, value2);
      }
    }
    return max2 === MIN_VALUE ? values6[0] : max2;
  },
  sum: function(values6) {
    var length = values6.length;
    var sum2 = 0;
    for (var i16 = 0; i16 < length; i16++) {
      var value2 = values6[i16];
      if (isNumber(value2)) {
        sum2 += value2;
      }
    }
    return sum2;
  },
  sumOrNull: function(values6) {
    var result = null;
    if (countNumbers(values6)) {
      result = Aggregates.sum(values6);
    }
    return result;
  },
  count: function(values6) {
    var length = values6.length;
    var count = 0;
    for (var i16 = 0; i16 < length; i16++) {
      var value2 = values6[i16];
      if (value2 !== null && defined(value2)) {
        count++;
      }
    }
    return count;
  },
  avg: function(values6) {
    var count = countNumbers(values6);
    var result = values6[0];
    if (count > 0) {
      result = Aggregates.sum(values6) / count;
    }
    return result;
  },
  first: function(values6) {
    var length = values6.length;
    for (var i16 = 0; i16 < length; i16++) {
      var value2 = values6[i16];
      if (value2 !== null && defined(value2)) {
        return value2;
      }
    }
    return values6[0];
  }
};
function getField(field, row) {
  if (row === null) {
    return row;
  }
  var get3 = getter$1(field);
  return get3(row);
}
var SeriesBinder = function(Class3) {
  function SeriesBinder2() {
    Class3.call(this);
    this._valueFields = {};
    this._otherFields = {};
    this._nullValue = {};
    this._undefinedValue = {};
  }
  if (Class3)
    SeriesBinder2.__proto__ = Class3;
  SeriesBinder2.prototype = Object.create(Class3 && Class3.prototype);
  SeriesBinder2.prototype.constructor = SeriesBinder2;
  SeriesBinder2.prototype.register = function register4(seriesTypes, valueFields, otherFields) {
    var this$1$1 = this;
    if (valueFields === void 0)
      valueFields = [VALUE];
    if (otherFields === void 0)
      otherFields = {};
    for (var i16 = 0; i16 < seriesTypes.length; i16++) {
      var type = seriesTypes[i16];
      this$1$1._valueFields[type] = valueFields;
      this$1$1._otherFields[type] = otherFields;
      this$1$1._nullValue[type] = this$1$1._makeValue(valueFields, null);
      this$1$1._undefinedValue[type] = this$1$1._makeValue(valueFields, void 0);
    }
  };
  SeriesBinder2.prototype.canonicalFields = function canonicalFields(series) {
    return this.valueFields(series).concat(this.otherFields(series));
  };
  SeriesBinder2.prototype.valueFields = function valueFields(series) {
    return this._valueFields[series.type] || [VALUE];
  };
  SeriesBinder2.prototype.otherFields = function otherFields(series) {
    return this._otherFields[series.type] || [VALUE];
  };
  SeriesBinder2.prototype.bindPoint = function bindPoint(series, pointIx, item) {
    var data2 = series.data;
    var pointData = defined(item) ? item : data2[pointIx];
    var result = { valueFields: { value: pointData } };
    var valueFields = this.valueFields(series);
    var otherFields = this._otherFields[series.type];
    var fields, value2;
    if (pointData === null) {
      value2 = this._nullValue[series.type];
    } else if (!defined(pointData)) {
      value2 = this._undefinedValue[series.type];
    } else if (Array.isArray(pointData)) {
      var fieldData = pointData.slice(valueFields.length);
      value2 = this._bindFromArray(pointData, valueFields);
      fields = this._bindFromArray(fieldData, otherFields);
    } else if (typeof pointData === "object") {
      var srcValueFields = this.sourceFields(series, valueFields);
      var srcPointFields = this.sourceFields(series, otherFields);
      value2 = this._bindFromObject(pointData, valueFields, srcValueFields);
      fields = this._bindFromObject(pointData, otherFields, srcPointFields);
    }
    if (defined(value2)) {
      if (valueFields.length === 1) {
        result.valueFields.value = value2[valueFields[0]];
      } else {
        result.valueFields = value2;
      }
    }
    result.fields = fields || {};
    return result;
  };
  SeriesBinder2.prototype._makeValue = function _makeValue(fields, initialValue) {
    var value2 = {};
    var length = fields.length;
    for (var i16 = 0; i16 < length; i16++) {
      var fieldName = fields[i16];
      value2[fieldName] = initialValue;
    }
    return value2;
  };
  SeriesBinder2.prototype._bindFromArray = function _bindFromArray(array, fields) {
    var value2 = {};
    if (fields) {
      var length = Math.min(fields.length, array.length);
      for (var i16 = 0; i16 < length; i16++) {
        value2[fields[i16]] = array[i16];
      }
    }
    return value2;
  };
  SeriesBinder2.prototype._bindFromObject = function _bindFromObject(object, fields, srcFields) {
    if (srcFields === void 0)
      srcFields = fields;
    var value2 = {};
    if (fields) {
      var length = fields.length;
      for (var i16 = 0; i16 < length; i16++) {
        var fieldName = fields[i16];
        var srcFieldName = srcFields[i16];
        if (srcFieldName !== null) {
          value2[fieldName] = getField(srcFieldName, object);
        }
      }
    }
    return value2;
  };
  SeriesBinder2.prototype.sourceFields = function sourceFields(series, canonicalFields) {
    var sourceFields2 = [];
    if (canonicalFields) {
      var length = canonicalFields.length;
      for (var i16 = 0; i16 < length; i16++) {
        var fieldName = canonicalFields[i16];
        var sourceFieldName = fieldName === VALUE ? "field" : fieldName + "Field";
        sourceFields2.push(series[sourceFieldName] !== null ? series[sourceFieldName] || fieldName : null);
      }
    }
    return sourceFields2;
  };
  return SeriesBinder2;
}(Class$1);
SeriesBinder.current = new SeriesBinder();
var STD_ERR = "stderr";
var STD_DEV = "stddev";
var percentRegex = /percent(?:\w*)\((\d+)\)/;
var standardDeviationRegex = new RegExp("^" + STD_DEV + "(?:\\((\\d+(?:\\.\\d+)?)\\))?$");
var ErrorRangeCalculator = function(Class3) {
  function ErrorRangeCalculator2(errorValue, series, field) {
    Class3.call(this);
    this.initGlobalRanges(errorValue, series, field);
  }
  if (Class3)
    ErrorRangeCalculator2.__proto__ = Class3;
  ErrorRangeCalculator2.prototype = Object.create(Class3 && Class3.prototype);
  ErrorRangeCalculator2.prototype.constructor = ErrorRangeCalculator2;
  ErrorRangeCalculator2.prototype.initGlobalRanges = function initGlobalRanges(errorValue, series, field) {
    var data2 = series.data;
    var deviationMatch = standardDeviationRegex.exec(errorValue);
    if (deviationMatch) {
      this.valueGetter = this.createValueGetter(series, field);
      var average = this.getAverage(data2);
      var deviation = this.getStandardDeviation(data2, average, false);
      var multiple = deviationMatch[1] ? parseFloat(deviationMatch[1]) : 1;
      var errorRange = { low: average.value - deviation * multiple, high: average.value + deviation * multiple };
      this.globalRange = function() {
        return errorRange;
      };
    } else if (errorValue.indexOf && errorValue.indexOf(STD_ERR) >= 0) {
      this.valueGetter = this.createValueGetter(series, field);
      var standardError = this.getStandardError(data2, this.getAverage(data2));
      this.globalRange = function(value2) {
        return { low: value2 - standardError, high: value2 + standardError };
      };
    }
  };
  ErrorRangeCalculator2.prototype.createValueGetter = function createValueGetter(series, field) {
    var data2 = series.data;
    var binder = SeriesBinder.current;
    var valueFields = binder.valueFields(series);
    var item = defined(data2[0]) ? data2[0] : {};
    var valueGetter2;
    if (isArray$1(item)) {
      var index2 = field ? valueFields.indexOf(field) : 0;
      valueGetter2 = getter$1("[" + index2 + "]");
    } else if (isNumber(item)) {
      valueGetter2 = getter$1();
    } else if (typeof item === OBJECT$1) {
      var srcValueFields = binder.sourceFields(series, valueFields);
      valueGetter2 = getter$1(srcValueFields[valueFields.indexOf(field)]);
    }
    return valueGetter2;
  };
  ErrorRangeCalculator2.prototype.getErrorRange = function getErrorRange(pointValue, errorValue) {
    var low, high, value2;
    if (!defined(errorValue)) {
      return null;
    }
    if (this.globalRange) {
      return this.globalRange(pointValue);
    }
    if (isArray$1(errorValue)) {
      low = pointValue - errorValue[0];
      high = pointValue + errorValue[1];
    } else if (isNumber(value2 = parseFloat(errorValue))) {
      low = pointValue - value2;
      high = pointValue + value2;
    } else if (value2 = percentRegex.exec(errorValue)) {
      var percentValue = pointValue * (parseFloat(value2[1]) / 100);
      low = pointValue - Math.abs(percentValue);
      high = pointValue + Math.abs(percentValue);
    } else {
      throw new Error("Invalid ErrorBar value: " + errorValue);
    }
    return { low, high };
  };
  ErrorRangeCalculator2.prototype.getStandardError = function getStandardError(data2, average) {
    return this.getStandardDeviation(data2, average, true) / Math.sqrt(average.count);
  };
  ErrorRangeCalculator2.prototype.getStandardDeviation = function getStandardDeviation(data2, average, isSample) {
    var this$1$1 = this;
    var length = data2.length;
    var total3 = isSample ? average.count - 1 : average.count;
    var squareDifferenceSum = 0;
    for (var idx = 0; idx < length; idx++) {
      var value2 = this$1$1.valueGetter(data2[idx]);
      if (isNumber(value2)) {
        squareDifferenceSum += Math.pow(value2 - average.value, 2);
      }
    }
    return Math.sqrt(squareDifferenceSum / total3);
  };
  ErrorRangeCalculator2.prototype.getAverage = function getAverage(data2) {
    var this$1$1 = this;
    var length = data2.length;
    var sum2 = 0;
    var count = 0;
    for (var idx = 0; idx < length; idx++) {
      var value2 = this$1$1.valueGetter(data2[idx]);
      if (isNumber(value2)) {
        sum2 += value2;
        count++;
      }
    }
    return {
      value: sum2 / count,
      count
    };
  };
  return ErrorRangeCalculator2;
}(Class$1);
var browser = support$2.browser || {};
var INITIAL_ANIMATION_DURATION = 600;
var FADEIN = "fadeIn";
var BORDER_BRIGHTNESS = 0.8;
var TOOLTIP_OFFSET = 5;
var START_SCALE = browser.msie ? 1e-3 : 0;
var ERROR_LOW_FIELD = "errorLow";
var ERROR_HIGH_FIELD = "errorHigh";
var X_ERROR_LOW_FIELD = "xErrorLow";
var X_ERROR_HIGH_FIELD = "xErrorHigh";
var Y_ERROR_LOW_FIELD = "yErrorLow";
var Y_ERROR_HIGH_FIELD = "yErrorHigh";
var LINE_MARKER_SIZE = 8;
var ZERO = "zero";
var INTERPOLATE = "interpolate";
var GAP = "gap";
var ABOVE = "above";
var BELOW = "below";
var SMOOTH = "smooth";
var STEP = "step";
var AREA = "area";
var BAR = "bar";
var BOX_PLOT = "boxPlot";
var BUBBLE = "bubble";
var BULLET = "bullet";
var CANDLESTICK = "candlestick";
var COLUMN = "column";
var DONUT = "donut";
var FUNNEL = "funnel";
var PYRAMID = "pyramid";
var HEATMAP = "heatmap";
var HORIZONTAL_WATERFALL = "horizontalWaterfall";
var LINE = "line";
var OHLC = "ohlc";
var PIE = "pie";
var POLAR_AREA = "polarArea";
var POLAR_LINE = "polarLine";
var POLAR_SCATTER = "polarScatter";
var RADAR_AREA = "radarArea";
var RADAR_COLUMN = "radarColumn";
var RADAR_LINE = "radarLine";
var RANGE_AREA = "rangeArea";
var RANGE_BAR = "rangeBar";
var RANGE_COLUMN = "rangeColumn";
var SCATTER = "scatter";
var SCATTER_LINE = "scatterLine";
var VERTICAL_AREA = "verticalArea";
var VERTICAL_BOX_PLOT = "verticalBoxPlot";
var VERTICAL_BULLET = "verticalBullet";
var VERTICAL_LINE = "verticalLine";
var VERTICAL_RANGE_AREA = "verticalRangeArea";
var WATERFALL = "waterfall";
var EQUALLY_SPACED_SERIES = [
  BAR,
  COLUMN,
  OHLC,
  CANDLESTICK,
  BOX_PLOT,
  VERTICAL_BOX_PLOT,
  BULLET,
  RANGE_COLUMN,
  RANGE_BAR,
  WATERFALL,
  HORIZONTAL_WATERFALL
];
var TRENDLINE_EXPONENTIAL = "exponentialTrendline";
var TRENDLINE_LINEAR = "linearTrendline";
var TRENDLINE_LOGARITHMIC = "logarithmicTrendline";
var TRENDLINE_MOVING_AVERAGE = "movingAverageTrendline";
var TRENDLINE_POLYNOMIAL = "polynomialTrendline";
var TRENDLINE_POWER = "powerTrendline";
var TRENDLINE_SERIES = [
  TRENDLINE_EXPONENTIAL,
  TRENDLINE_LINEAR,
  TRENDLINE_LOGARITHMIC,
  TRENDLINE_MOVING_AVERAGE,
  TRENDLINE_POLYNOMIAL,
  TRENDLINE_POWER
];
var LEGEND_ITEM_CLICK = "legendItemClick";
var LEGEND_ITEM_HOVER = "legendItemHover";
var LEGEND_ITEM_LEAVE = "legendItemLeave";
var SERIES_CLICK = "seriesClick";
var SERIES_HOVER = "seriesHover";
var SERIES_OVER = "seriesOver";
var SERIES_LEAVE = "seriesLeave";
var PLOT_AREA_CLICK = "plotAreaClick";
var PLOT_AREA_HOVER = "plotAreaHover";
var PLOT_AREA_LEAVE = "plotAreaLeave";
var DRAG = "drag";
var DRAG_END = "dragEnd";
var DRAG_START = "dragStart";
var ZOOM_START = "zoomStart";
var ZOOM = "zoom";
var ZOOM_END = "zoomEnd";
var SELECT_START = "selectStart";
var SELECT = "select";
var SELECT_END = "selectEnd";
var RENDER = "render";
var SHOW_TOOLTIP$1 = "showTooltip";
var HIDE_TOOLTIP$1 = "hideTooltip";
var PANE_RENDER = "paneRender";
var CHART_POINT_ROLE = "graphics-symbol";
var CHART_POINT_CLASSNAME = "k-chart-point";
var CHART_POINT_ROLE_DESCRIPTION = "Point";
var LEGEND_ITEM_ROLE = "checkbox";
var LEGEND_ITEM_CLASSNAME = "k-chart-legend-item";
var LEGEND_ITEM_ARIA_ROLE_DESCRIPTION = "Legend item";
var LOGARITHMIC = "log";
var CATEGORY = "category";
var INSIDE_END = "insideEnd";
var INSIDE_BASE = "insideBase";
var OUTSIDE_END = "outsideEnd";
var MOUSEWHEEL$1 = "wheel";
var MOUSEWHEEL_DELAY = 150;
var MOUSEWHEEL_ZOOM_RATE = 0.3;
var DRILLDOWN = "drilldown";
var DRILLDOWN_FIELD = "drilldown";
var MIN_MOVING_AVERAGE_PERIOD = 2;
var DEFAULT_ERROR_BAR_WIDTH = 4;
var ErrorBarBase = function(ChartElement2) {
  function ErrorBarBase2(low, high, isVertical, chart, series, options2) {
    ChartElement2.call(this, options2);
    this.low = low;
    this.high = high;
    this.isVertical = isVertical;
    this.chart = chart;
    this.series = series;
  }
  if (ChartElement2)
    ErrorBarBase2.__proto__ = ChartElement2;
  ErrorBarBase2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  ErrorBarBase2.prototype.constructor = ErrorBarBase2;
  ErrorBarBase2.prototype.reflow = function reflow(targetBox) {
    var endCaps = this.options.endCaps;
    var isVertical = this.isVertical;
    var axis = this.getAxis();
    var valueBox = axis.getSlot(this.low, this.high);
    var centerBox = targetBox.center();
    var capsWidth = this.getCapsWidth(targetBox, isVertical);
    var capValue = isVertical ? centerBox.x : centerBox.y;
    var capStart = capValue - capsWidth;
    var capEnd = capValue + capsWidth;
    var linePoints;
    if (isVertical) {
      linePoints = [
        new Point$5(centerBox.x, valueBox.y1),
        new Point$5(centerBox.x, valueBox.y2)
      ];
      if (endCaps) {
        linePoints.push(
          new Point$5(capStart, valueBox.y1),
          new Point$5(capEnd, valueBox.y1),
          new Point$5(capStart, valueBox.y2),
          new Point$5(capEnd, valueBox.y2)
        );
      }
      this.box = new Box(capStart, valueBox.y1, capEnd, valueBox.y2);
    } else {
      linePoints = [
        new Point$5(valueBox.x1, centerBox.y),
        new Point$5(valueBox.x2, centerBox.y)
      ];
      if (endCaps) {
        linePoints.push(
          new Point$5(valueBox.x1, capStart),
          new Point$5(valueBox.x1, capEnd),
          new Point$5(valueBox.x2, capStart),
          new Point$5(valueBox.x2, capEnd)
        );
      }
      this.box = new Box(valueBox.x1, capStart, valueBox.x2, capEnd);
    }
    this.linePoints = linePoints;
  };
  ErrorBarBase2.prototype.getCapsWidth = function getCapsWidth(box, isVertical) {
    var boxSize = isVertical ? box.width() : box.height();
    var capsWidth = Math.min(Math.floor(boxSize / 2), DEFAULT_ERROR_BAR_WIDTH) || DEFAULT_ERROR_BAR_WIDTH;
    return capsWidth;
  };
  ErrorBarBase2.prototype.createVisual = function createVisual() {
    var this$1$1 = this;
    var options2 = this.options;
    var visual = options2.visual;
    if (visual) {
      this.visual = visual({
        low: this.low,
        high: this.high,
        rect: this.box.toRect(),
        sender: this.getSender(),
        options: {
          endCaps: options2.endCaps,
          color: options2.color,
          line: options2.line
        },
        createVisual: function() {
          this$1$1.createDefaultVisual();
          var defaultVisual = this$1$1.visual;
          delete this$1$1.visual;
          return defaultVisual;
        }
      });
    } else {
      this.createDefaultVisual();
    }
  };
  ErrorBarBase2.prototype.createDefaultVisual = function createDefaultVisual() {
    var this$1$1 = this;
    var ref2 = this;
    var options2 = ref2.options;
    var linePoints = ref2.linePoints;
    var lineOptions = {
      stroke: {
        color: options2.color,
        width: options2.line.width,
        dashType: options2.line.dashType
      }
    };
    ChartElement2.prototype.createVisual.call(this);
    for (var idx = 0; idx < linePoints.length; idx += 2) {
      var line = new Path$7(lineOptions).moveTo(linePoints[idx].x, linePoints[idx].y).lineTo(linePoints[idx + 1].x, linePoints[idx + 1].y);
      alignPathToPixel(line);
      this$1$1.visual.append(line);
    }
  };
  return ErrorBarBase2;
}(ChartElement);
setDefaultOptions(ErrorBarBase, {
  animation: {
    type: FADEIN,
    delay: INITIAL_ANIMATION_DURATION
  },
  endCaps: true,
  line: {
    width: 2
  },
  zIndex: 1
});
var CategoricalErrorBar = function(ErrorBarBase2) {
  function CategoricalErrorBar2() {
    ErrorBarBase2.apply(this, arguments);
  }
  if (ErrorBarBase2)
    CategoricalErrorBar2.__proto__ = ErrorBarBase2;
  CategoricalErrorBar2.prototype = Object.create(ErrorBarBase2 && ErrorBarBase2.prototype);
  CategoricalErrorBar2.prototype.constructor = CategoricalErrorBar2;
  CategoricalErrorBar2.prototype.getAxis = function getAxis() {
    var axis = this.chart.seriesValueAxis(this.series);
    return axis;
  };
  return CategoricalErrorBar2;
}(ErrorBarBase);
function anyHasZIndex(elements) {
  for (var idx = 0; idx < elements.length; idx++) {
    if (defined(elements[idx].zIndex)) {
      return true;
    }
  }
}
function appendIfNotNull(array, element) {
  if (element !== null) {
    array.push(element);
  }
}
function areNumbers(values6) {
  return countNumbers(values6) === values6.length;
}
function segmentVisible(series, fields, index2) {
  var visible = fields.visible;
  if (defined(visible)) {
    return visible;
  }
  var pointVisibility = series.pointVisibility;
  if (pointVisibility) {
    return pointVisibility[index2];
  }
}
function bindSegments(series) {
  var data2 = series.data;
  var points2 = [];
  var sum2 = 0;
  var count = 0;
  for (var idx = 0; idx < data2.length; idx++) {
    var pointData = SeriesBinder.current.bindPoint(series, idx);
    var value2 = pointData.valueFields.value;
    if (isString$2(value2)) {
      value2 = parseFloat(value2);
    }
    if (isNumber(value2)) {
      pointData.visible = segmentVisible(series, pointData.fields, idx) !== false;
      pointData.value = Math.abs(value2);
      points2.push(pointData);
      if (pointData.visible) {
        sum2 += pointData.value;
      }
      if (value2 !== 0) {
        count++;
      }
    } else {
      points2.push(null);
    }
  }
  return {
    total: sum2,
    points: points2,
    count
  };
}
function categoriesCount(series) {
  var seriesCount = series.length;
  var categories = 0;
  for (var i16 = 0; i16 < seriesCount; i16++) {
    categories = Math.max(categories, series[i16].data.length);
  }
  return categories;
}
function equalsIgnoreCase(a9, b2) {
  if (a9 && b2) {
    return a9.toLowerCase() === b2.toLowerCase();
  }
  return a9 === b2;
}
var MAX_EXPAND_DEPTH = 5;
function evalOptions(options2, context2, state, dryRun) {
  if (state === void 0)
    state = {};
  if (dryRun === void 0)
    dryRun = false;
  var defaults = state.defaults = state.defaults || {};
  var depth = state.depth = state.depth || 0;
  var needsEval = false;
  state.excluded = state.excluded || [];
  if (depth > MAX_EXPAND_DEPTH) {
    return null;
  }
  for (var property in options2) {
    if (!inArray(property, state.excluded) && hasOwnProperty(options2, property)) {
      var propValue = options2[property];
      if (isFunction$1(propValue)) {
        needsEval = true;
        if (!dryRun) {
          options2[property] = valueOrDefault$1(propValue(context2), defaults[property]);
        }
      } else if (isObject(propValue)) {
        if (!dryRun) {
          state.defaults = defaults[property];
        }
        state.depth++;
        needsEval = evalOptions(propValue, context2, state, dryRun) || needsEval;
        state.depth--;
      }
    }
  }
  return needsEval;
}
function filterSeriesByType(series, types) {
  var result = [];
  var seriesTypes = [].concat(types);
  for (var idx = 0; idx < series.length; idx++) {
    var currentSeries = series[idx];
    if (inArray(currentSeries.type, seriesTypes)) {
      result.push(currentSeries);
    }
  }
  return result;
}
var dateCache = /* @__PURE__ */ new WeakMap();
function parseDateCategory(category, row, intlService) {
  if (row === null || typeof row !== "object") {
    return parseDate(intlService, category);
  }
  var date = dateCache.get(row);
  if (!date) {
    date = parseDate(intlService, category);
    dateCache.set(row, date);
  }
  return date;
}
function hasGradientOverlay(options2) {
  var overlay = options2.overlay;
  return overlay && overlay.gradient && overlay.gradient !== "none";
}
function hasValue$1(value2) {
  return defined(value2) && value2 !== null;
}
function isDateAxis(axisOptions2, sampleCategory) {
  var type = axisOptions2.type;
  var dateCategory = sampleCategory instanceof Date;
  return !type && dateCategory || equalsIgnoreCase(type, DATE);
}
function singleItemOrArray(array) {
  return array.length === 1 ? array[0] : array;
}
var AREA_REGEX = /area/i;
function seriesMissingValues(series) {
  if (series.missingValues) {
    return series.missingValues;
  }
  return AREA_REGEX.test(series.type) || series.stack ? ZERO : INTERPOLATE;
}
function hasValue(series, item) {
  var fields = SeriesBinder.current.bindPoint(series, null, item);
  var valueFields = fields.valueFields;
  for (var field in valueFields) {
    if (convertableToNumber(valueFields[field])) {
      return true;
    }
  }
}
function findNext(ref2) {
  var start = ref2.start;
  var dir = ref2.dir;
  var min2 = ref2.min;
  var max2 = ref2.max;
  var getter2 = ref2.getter;
  var hasItem = ref2.hasItem;
  var series = ref2.series;
  var pointHasValue, outPoint;
  var idx = start;
  do {
    idx += dir;
    if (hasItem(idx)) {
      outPoint = getter2(idx);
      pointHasValue = hasValue(series, outPoint.item);
    }
  } while (min2 <= idx && idx <= max2 && !pointHasValue);
  if (pointHasValue) {
    return outPoint;
  }
}
function createOutOfRangePoints(series, range, count, getter2, hasItem) {
  var min2 = range.min;
  var max2 = range.max;
  var hasMinPoint = min2 > 0 && min2 < count;
  var hasMaxPoint = max2 + 1 < count;
  if (hasMinPoint || hasMaxPoint) {
    var missingValues = seriesMissingValues(series);
    var minPoint, maxPoint;
    if (missingValues !== INTERPOLATE) {
      if (hasMinPoint) {
        minPoint = getter2(min2 - 1);
      }
      if (hasMaxPoint) {
        maxPoint = getter2(max2 + 1);
      }
    } else {
      var outPoint, pointHasValue;
      if (hasMinPoint) {
        outPoint = getter2(min2 - 1);
        pointHasValue = hasValue(series, outPoint.item);
        if (!pointHasValue) {
          minPoint = findNext({
            start: min2,
            dir: -1,
            min: 0,
            max: count - 1,
            getter: getter2,
            hasItem,
            series
          });
        } else {
          minPoint = outPoint;
        }
      }
      if (hasMaxPoint) {
        outPoint = getter2(max2 + 1);
        pointHasValue = hasValue(series, outPoint.item);
        if (!pointHasValue) {
          maxPoint = findNext({
            start: max2,
            dir: 1,
            min: 0,
            max: count - 1,
            getter: getter2,
            hasItem,
            series
          });
        } else {
          maxPoint = outPoint;
        }
      }
    }
    if (minPoint) {
      series._outOfRangeMinPoint = minPoint;
    }
    if (maxPoint) {
      series._outOfRangeMaxPoint = maxPoint;
    }
  }
}
var CategoricalChart = function(ChartElement2) {
  function CategoricalChart2(plotArea, options2) {
    ChartElement2.call(this, options2);
    this.plotArea = plotArea;
    this.chartService = plotArea.chartService;
    this.categoryAxis = plotArea.seriesCategoryAxis(options2.series[0]);
    this.valueAxisRanges = {};
    this.points = [];
    this.categoryPoints = [];
    this.seriesPoints = [];
    this.seriesOptions = [];
    this._evalSeries = [];
    this.render();
  }
  if (ChartElement2)
    CategoricalChart2.__proto__ = ChartElement2;
  CategoricalChart2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  CategoricalChart2.prototype.constructor = CategoricalChart2;
  CategoricalChart2.prototype.render = function render() {
    this.traverseDataPoints(this.addValue.bind(this));
  };
  CategoricalChart2.prototype.pointOptions = function pointOptions(series, seriesIx) {
    var options2 = this.seriesOptions[seriesIx];
    if (!options2) {
      var defaults = this.pointType().prototype.defaults;
      this.seriesOptions[seriesIx] = options2 = deepExtend({}, defaults, {
        vertical: !this.options.invertAxes
      }, series);
    }
    return options2;
  };
  CategoricalChart2.prototype.plotValue = function plotValue(point2) {
    if (!point2) {
      return 0;
    }
    if (this.options.isStacked100 && isNumber(point2.value)) {
      var categoryIx = point2.categoryIx;
      var categoryPoints = this.categoryPoints[categoryIx];
      var otherValues = [];
      var categorySum = 0;
      for (var i16 = 0; i16 < categoryPoints.length; i16++) {
        var other = categoryPoints[i16];
        if (other) {
          var stack = point2.series.stack;
          var otherStack = other.series.stack;
          if (stack && otherStack && stack.group !== otherStack.group) {
            continue;
          }
          if (isNumber(other.value)) {
            categorySum += Math.abs(other.value);
            otherValues.push(Math.abs(other.value));
          }
        }
      }
      if (categorySum > 0) {
        return point2.value / categorySum;
      }
    }
    return point2.value;
  };
  CategoricalChart2.prototype.plotRange = function plotRange(point2, startValue) {
    var this$1$1 = this;
    if (startValue === void 0)
      startValue = 0;
    var categoryPoints = this.categoryPoints[point2.categoryIx];
    if (this.options.isStacked) {
      var plotValue = this.plotValue(point2);
      var positive = plotValue >= 0;
      var prevValue = startValue;
      var isStackedBar = false;
      var stack = defined(point2.series.stack) ? point2.series.stack : this.options.defaultStack;
      var isNonGroupStack = function(stack2) {
        return stack2 === true || typeof stack2 === OBJECT$1 && !stack2.group;
      };
      if (stack) {
        for (var i16 = 0; i16 < categoryPoints.length; i16++) {
          var other = categoryPoints[i16];
          if (point2 === other) {
            break;
          }
          var otherStack = defined(other.series.stack) ? other.series.stack : this$1$1.options.defaultStack;
          if (!otherStack) {
            continue;
          }
          if (typeof stack === STRING$1 && stack !== otherStack) {
            continue;
          }
          if (isNonGroupStack(stack) && !isNonGroupStack(otherStack)) {
            continue;
          }
          if (stack.group && stack.group !== otherStack.group) {
            continue;
          }
          var otherValue = this$1$1.plotValue(other);
          if (otherValue >= 0 && positive || otherValue < 0 && !positive) {
            if (startValue === 0 || otherValue !== 0) {
              prevValue += otherValue;
              plotValue += otherValue;
              isStackedBar = true;
              if (this$1$1.options.isStacked100) {
                plotValue = Math.min(plotValue, 1);
              }
            }
          }
        }
      }
      if (isStackedBar) {
        prevValue -= startValue;
      }
      return [prevValue, plotValue];
    }
    var series = point2.series;
    var valueAxis = this.seriesValueAxis(series);
    var axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);
    return [axisCrossingValue, convertableToNumber(point2.value) ? point2.value : axisCrossingValue];
  };
  CategoricalChart2.prototype.stackLimits = function stackLimits(axisName, stackName) {
    var this$1$1 = this;
    var min2 = MAX_VALUE;
    var max2 = MIN_VALUE;
    for (var i16 = 0; i16 < this.categoryPoints.length; i16++) {
      var categoryPoints = this$1$1.categoryPoints[i16];
      if (!categoryPoints) {
        continue;
      }
      for (var pIx = 0; pIx < categoryPoints.length; pIx++) {
        var point2 = categoryPoints[pIx];
        if (point2) {
          if (point2.series.stack === stackName || point2.series.axis === axisName) {
            var to = this$1$1.plotRange(point2, 0)[1];
            if (defined(to) && isFinite(to)) {
              max2 = Math.max(max2, to);
              min2 = Math.min(min2, to);
            }
          }
        }
      }
    }
    return { min: min2, max: max2 };
  };
  CategoricalChart2.prototype.updateStackRange = function updateStackRange() {
    var this$1$1 = this;
    var ref2 = this.options;
    var isStacked = ref2.isStacked;
    var chartSeries = ref2.series;
    var limitsCache = {};
    if (isStacked) {
      for (var i16 = 0; i16 < chartSeries.length; i16++) {
        var series = chartSeries[i16];
        var axisName = series.axis;
        var key = axisName + series.stack;
        var limits = limitsCache[key];
        if (!limits) {
          limits = this$1$1.stackLimits(axisName, series.stack);
          var errorTotals = this$1$1.errorTotals;
          if (errorTotals) {
            if (errorTotals.negative.length) {
              limits.min = Math.min(limits.min, sparseArrayLimits(errorTotals.negative).min);
            }
            if (errorTotals.positive.length) {
              limits.max = Math.max(limits.max, sparseArrayLimits(errorTotals.positive).max);
            }
          }
          if (limits.min !== MAX_VALUE || limits.max !== MIN_VALUE) {
            limitsCache[key] = limits;
          } else {
            limits = null;
          }
        }
        if (limits) {
          this$1$1.valueAxisRanges[axisName] = limits;
        }
      }
    }
  };
  CategoricalChart2.prototype.addErrorBar = function addErrorBar(point2, data2, categoryIx) {
    var value2 = point2.value;
    var series = point2.series;
    var seriesIx = point2.seriesIx;
    var errorBars = point2.options.errorBars;
    var lowValue = data2.fields[ERROR_LOW_FIELD];
    var highValue = data2.fields[ERROR_HIGH_FIELD];
    var errorRange;
    if (isNumber(lowValue) && isNumber(highValue)) {
      errorRange = { low: lowValue, high: highValue };
    } else if (errorBars && defined(errorBars.value)) {
      this.seriesErrorRanges = this.seriesErrorRanges || [];
      this.seriesErrorRanges[seriesIx] = this.seriesErrorRanges[seriesIx] || new ErrorRangeCalculator(errorBars.value, series, VALUE);
      errorRange = this.seriesErrorRanges[seriesIx].getErrorRange(value2, errorBars.value);
    }
    if (errorRange) {
      point2.low = errorRange.low;
      point2.high = errorRange.high;
      this.addPointErrorBar(point2, categoryIx);
    }
  };
  CategoricalChart2.prototype.addPointErrorBar = function addPointErrorBar(point2, categoryIx) {
    var isVertical = !this.options.invertAxes;
    var options2 = point2.options.errorBars;
    var series = point2.series;
    var low = point2.low;
    var high = point2.high;
    if (this.options.isStacked) {
      var stackedErrorRange = this.stackedErrorRange(point2, categoryIx);
      low = stackedErrorRange.low;
      high = stackedErrorRange.high;
    } else {
      var fields = { categoryIx, series };
      this.updateRange({ value: low }, fields);
      this.updateRange({ value: high }, fields);
    }
    var errorBar = new CategoricalErrorBar(low, high, isVertical, this, series, options2);
    point2.errorBars = [errorBar];
    point2.append(errorBar);
  };
  CategoricalChart2.prototype.stackedErrorRange = function stackedErrorRange(point2, categoryIx) {
    var plotValue = this.plotRange(point2, 0)[1] - point2.value;
    var low = point2.low + plotValue;
    var high = point2.high + plotValue;
    this.errorTotals = this.errorTotals || { positive: [], negative: [] };
    if (low < 0) {
      this.errorTotals.negative[categoryIx] = Math.min(this.errorTotals.negative[categoryIx] || 0, low);
    }
    if (high > 0) {
      this.errorTotals.positive[categoryIx] = Math.max(this.errorTotals.positive[categoryIx] || 0, high);
    }
    return { low, high };
  };
  CategoricalChart2.prototype.addValue = function addValue(data2, fields) {
    var categoryIx = fields.categoryIx;
    var series = fields.series;
    var seriesIx = fields.seriesIx;
    var categoryPoints = this.categoryPoints[categoryIx];
    if (!categoryPoints) {
      this.categoryPoints[categoryIx] = categoryPoints = [];
    }
    var seriesPoints = this.seriesPoints[seriesIx];
    if (!seriesPoints) {
      this.seriesPoints[seriesIx] = seriesPoints = [];
    }
    var point2 = this.createPoint(data2, fields);
    if (point2) {
      Object.assign(point2, fields);
      point2.owner = this;
      point2.noteText = data2.fields.noteText;
      if (!defined(point2.dataItem)) {
        point2.dataItem = series.data[categoryIx];
      }
      this.addErrorBar(point2, data2, categoryIx);
    }
    this.points.push(point2);
    seriesPoints.push(point2);
    categoryPoints.push(point2);
    this.updateRange(data2.valueFields, fields);
  };
  CategoricalChart2.prototype.evalPointOptions = function evalPointOptions(options2, value2, fields) {
    var categoryIx = fields.categoryIx;
    var category = fields.category;
    var series = fields.series;
    var seriesIx = fields.seriesIx;
    var state = {
      defaults: series._defaults,
      excluded: [
        "data",
        "aggregate",
        "_events",
        "tooltip",
        "content",
        "template",
        "visual",
        "toggle",
        "_outOfRangeMinPoint",
        "_outOfRangeMaxPoint",
        "drilldownSeriesFactory",
        "ariaTemplate",
        "ariaContent"
      ]
    };
    var doEval = this._evalSeries[seriesIx];
    if (!defined(doEval)) {
      this._evalSeries[seriesIx] = doEval = evalOptions(options2, {}, state, true);
    }
    var pointOptions = options2;
    if (doEval) {
      pointOptions = deepExtend({}, pointOptions);
      evalOptions(pointOptions, {
        value: value2,
        category,
        index: categoryIx,
        series,
        dataItem: series.data[categoryIx]
      }, state);
    }
    return pointOptions;
  };
  CategoricalChart2.prototype.updateRange = function updateRange(data2, fields) {
    var axisName = fields.series.axis;
    var value2 = data2.value;
    var axisRange = this.valueAxisRanges[axisName];
    if (isFinite(value2) && value2 !== null) {
      axisRange = this.valueAxisRanges[axisName] = axisRange || { min: MAX_VALUE, max: MIN_VALUE };
      axisRange.min = Math.min(axisRange.min, value2);
      axisRange.max = Math.max(axisRange.max, value2);
    }
  };
  CategoricalChart2.prototype.seriesValueAxis = function seriesValueAxis(series) {
    var plotArea = this.plotArea;
    var axisName = series.axis;
    var axis = axisName ? plotArea.namedValueAxes[axisName] : plotArea.valueAxis;
    if (!axis) {
      throw new Error("Unable to locate value axis with name " + axisName);
    }
    return axis;
  };
  CategoricalChart2.prototype.reflow = function reflow(targetBox) {
    var this$1$1 = this;
    var categorySlots = this.categorySlots = [];
    var chartPoints = this.points;
    var categoryAxis = this.categoryAxis;
    var pointIx = 0;
    this.traverseDataPoints(function(data2, fields) {
      var categoryIx = fields.categoryIx;
      var currentSeries = fields.series;
      var valueAxis = this$1$1.seriesValueAxis(currentSeries);
      var point2 = chartPoints[pointIx++];
      var categorySlot = categorySlots[categoryIx];
      if (!categorySlot) {
        categorySlots[categoryIx] = categorySlot = this$1$1.categorySlot(categoryAxis, categoryIx, valueAxis);
      }
      if (point2) {
        var plotRange = this$1$1.plotRange(point2, valueAxis.startValue());
        var valueSlot = this$1$1.valueSlot(valueAxis, plotRange);
        if (valueSlot) {
          var pointSlot = this$1$1.pointSlot(categorySlot, valueSlot);
          point2.aboveAxis = this$1$1.aboveAxis(point2, valueAxis);
          point2.stackValue = plotRange[1];
          if (this$1$1.options.isStacked100) {
            point2.percentage = this$1$1.plotValue(point2);
          }
          this$1$1.reflowPoint(point2, pointSlot);
        } else {
          point2.visible = false;
        }
      }
    });
    this.reflowCategories(categorySlots);
    if (!this.options.clip && this.options.limitPoints && this.points.length) {
      this.limitPoints();
    }
    this.box = targetBox;
  };
  CategoricalChart2.prototype.valueSlot = function valueSlot(valueAxis, plotRange) {
    return valueAxis.getSlot(plotRange[0], plotRange[1], !this.options.clip);
  };
  CategoricalChart2.prototype.limitPoints = function limitPoints() {
    var this$1$1 = this;
    var categoryPoints = this.categoryPoints;
    var points2 = categoryPoints[0].concat(last(categoryPoints));
    for (var idx = 0; idx < points2.length; idx++) {
      if (points2[idx]) {
        this$1$1.limitPoint(points2[idx]);
      }
    }
  };
  CategoricalChart2.prototype.limitPoint = function limitPoint(point2) {
    var limitedSlot = this.categoryAxis.limitSlot(point2.box);
    if (!limitedSlot.equals(point2.box)) {
      point2.reflow(limitedSlot);
    }
  };
  CategoricalChart2.prototype.aboveAxis = function aboveAxis(point2, valueAxis) {
    var axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);
    var value2 = point2.value;
    return valueAxis.options.reverse ? value2 < axisCrossingValue : value2 >= axisCrossingValue;
  };
  CategoricalChart2.prototype.categoryAxisCrossingValue = function categoryAxisCrossingValue(valueAxis) {
    var categoryAxis = this.categoryAxis;
    var options2 = valueAxis.options;
    var crossingValues = [].concat(
      options2.axisCrossingValues || options2.axisCrossingValue
    );
    return crossingValues[categoryAxis.axisIndex || 0] || 0;
  };
  CategoricalChart2.prototype.reflowPoint = function reflowPoint(point2, pointSlot) {
    point2.reflow(pointSlot);
  };
  CategoricalChart2.prototype.reflowCategories = function reflowCategories() {
  };
  CategoricalChart2.prototype.pointSlot = function pointSlot(categorySlot, valueSlot) {
    var options2 = this.options;
    var invertAxes = options2.invertAxes;
    var slotX = invertAxes ? valueSlot : categorySlot;
    var slotY = invertAxes ? categorySlot : valueSlot;
    return new Box(slotX.x1, slotY.y1, slotX.x2, slotY.y2);
  };
  CategoricalChart2.prototype.categorySlot = function categorySlot(categoryAxis, categoryIx) {
    return categoryAxis.getSlot(categoryIx);
  };
  CategoricalChart2.prototype.traverseDataPoints = function traverseDataPoints(callback) {
    var this$1$1 = this;
    var series = this.options.series;
    var count = categoriesCount(series);
    var seriesCount = series.length;
    for (var seriesIx = 0; seriesIx < seriesCount; seriesIx++) {
      this$1$1._outOfRangeCallback(series[seriesIx], "_outOfRangeMinPoint", seriesIx, callback);
    }
    for (var categoryIx = 0; categoryIx < count; categoryIx++) {
      for (var seriesIx$1 = 0; seriesIx$1 < seriesCount; seriesIx$1++) {
        var currentSeries = series[seriesIx$1];
        var currentCategory = this$1$1.categoryAxis.categoryAt(categoryIx);
        var pointData = this$1$1.plotArea.bindPoint(currentSeries, categoryIx);
        callback(pointData, {
          category: currentCategory,
          categoryIx,
          categoriesCount: count,
          series: currentSeries,
          seriesIx: seriesIx$1
        });
      }
    }
    for (var seriesIx$2 = 0; seriesIx$2 < seriesCount; seriesIx$2++) {
      this$1$1._outOfRangeCallback(series[seriesIx$2], "_outOfRangeMaxPoint", seriesIx$2, callback);
    }
  };
  CategoricalChart2.prototype._outOfRangeCallback = function _outOfRangeCallback(series, field, seriesIx, callback) {
    var outOfRangePoint = series[field];
    if (outOfRangePoint) {
      var categoryIx = outOfRangePoint.categoryIx;
      var pointData = this.plotArea.bindPoint(series, categoryIx, outOfRangePoint.item);
      callback(pointData, {
        category: outOfRangePoint.category,
        categoryIx,
        series,
        seriesIx,
        dataItem: outOfRangePoint.item
      });
    }
  };
  CategoricalChart2.prototype.formatPointValue = function formatPointValue(point2, format2) {
    if (point2.value === null) {
      return "";
    }
    return this.chartService.format.auto(format2, point2.value);
  };
  CategoricalChart2.prototype.pointValue = function pointValue(data2) {
    return data2.valueFields.value;
  };
  return CategoricalChart2;
}(ChartElement);
setDefaultOptions(CategoricalChart, {
  series: [],
  invertAxes: false,
  isStacked: false,
  clip: true,
  limitPoints: true
});
var PointEventsMixin = {
  click: function(chart, e3) {
    return chart.trigger(
      SERIES_CLICK,
      this.eventArgs(e3)
    );
  },
  hover: function(chart, e3) {
    return chart.trigger(
      SERIES_HOVER,
      this.eventArgs(e3)
    );
  },
  over: function(chart, e3) {
    return chart.trigger(
      SERIES_OVER,
      this.eventArgs(e3)
    );
  },
  out: function(chart, e3) {
    return chart.trigger(
      SERIES_LEAVE,
      this.eventArgs(e3)
    );
  },
  eventArgs: function(e3) {
    return {
      value: this.value,
      percentage: this.percentage,
      stackValue: this.stackValue,
      category: this.category,
      series: this.series,
      dataItem: this.dataItem,
      runningTotal: this.runningTotal,
      total: this.total,
      element: eventElement(e3),
      originalEvent: e3,
      point: this
    };
  }
};
var NoteMixin = {
  createNote: function() {
    var options2 = this.options.notes;
    var text = this.noteText || options2.label.text;
    if (options2.visible !== false && defined(text) && text !== null) {
      this.note = new Note({
        value: this.value,
        text,
        dataItem: this.dataItem,
        category: this.category,
        series: this.series
      }, this.options.notes, this.owner.chartService);
      this.append(this.note);
    }
  }
};
var LinePoint = function(ChartElement2) {
  function LinePoint2(value2, options2) {
    ChartElement2.call(this);
    this.value = value2;
    this.options = options2;
    this.aboveAxis = valueOrDefault$1(this.options.aboveAxis, true);
    this.tooltipTracking = true;
    this._id = guid();
  }
  if (ChartElement2)
    LinePoint2.__proto__ = ChartElement2;
  LinePoint2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  LinePoint2.prototype.constructor = LinePoint2;
  LinePoint2.prototype.render = function render() {
    var ref2 = this.options;
    var markers = ref2.markers;
    if (this._rendered) {
      return;
    }
    this._rendered = true;
    if (markers.visible && markers.size) {
      this.marker = this.createMarker();
      this.append(this.marker);
    }
    this.createLabel();
    this.createNote();
    if (this.errorBar) {
      this.append(this.errorBar);
    }
  };
  LinePoint2.prototype.createLabel = function createLabel() {
    var options2 = this.options;
    var labels = options2.labels;
    if (labels.visible) {
      this.label = this.createLabelElement(labels);
      this.append(this.label);
    }
  };
  LinePoint2.prototype.createLabelElement = function createLabelElement(options2) {
    return new TextBox(
      this.getLabelText(options2),
      deepExtend({
        align: CENTER,
        vAlign: CENTER,
        margin: {
          left: 5,
          right: 5
        },
        zIndex: valueOrDefault$1(options2.zIndex, this.series.zIndex)
      }, options2),
      this.pointData()
    );
  };
  LinePoint2.prototype.getLabelText = function getLabelText(options2) {
    var labelTemplate = getTemplate$1(options2);
    if (labelTemplate) {
      return labelTemplate(this.pointData());
    } else if (options2.format) {
      return this.formatValue(options2.format);
    }
    return this.value;
  };
  LinePoint2.prototype.getAriaLabelText = function getAriaLabelText2() {
    var labels = this.options.labels;
    var ariaTemplate = getTemplate(labels);
    if (ariaTemplate) {
      return ariaTemplate(this.pointData());
    }
    return this.getLabelText(labels);
  };
  LinePoint2.prototype.markerBorder = function markerBorder() {
    var options2 = this.options.markers;
    var background = options2.background;
    var border = deepExtend({ color: this.color }, options2.border);
    if (!defined(border.color)) {
      border.color = new m$e(background).brightness(BORDER_BRIGHTNESS).toHex();
    }
    return border;
  };
  LinePoint2.prototype.createVisual = function createVisual() {
  };
  LinePoint2.prototype.createMarker = function createMarker() {
    var options2 = this.options.markers;
    var marker = new ShapeElement({
      type: options2.type,
      width: options2.size,
      height: options2.size,
      rotation: options2.rotation,
      background: options2.background,
      border: this.markerBorder(),
      opacity: options2.opacity,
      zIndex: valueOrDefault$1(options2.zIndex, this.series.zIndex),
      animation: options2.animation,
      visual: options2.visual,
      accessibilityOptions: deepExtend({
        ariaLabel: this.getAriaLabelText(this.options.labels)
      }, this.options.accessibility)
    }, {
      dataItem: this.dataItem,
      value: this.value,
      series: this.series,
      category: this.category
    });
    return marker;
  };
  LinePoint2.prototype.markerBox = function markerBox() {
    if (!this.marker) {
      this.marker = this.createMarker();
      this.marker.reflow(this._childBox);
    }
    return this.marker.box;
  };
  LinePoint2.prototype.reflow = function reflow(targetBox) {
    var this$1$1 = this;
    var ref2 = this;
    var options2 = ref2.options;
    var aboveAxis = ref2.aboveAxis;
    var vertical = options2.vertical;
    this.render();
    this.box = targetBox;
    var childBox = targetBox.clone();
    if (vertical) {
      if (aboveAxis) {
        childBox.y1 -= childBox.height();
      } else {
        childBox.y2 += childBox.height();
      }
    } else {
      if (aboveAxis) {
        childBox.x1 += childBox.width();
      } else {
        childBox.x2 -= childBox.width();
      }
    }
    this._childBox = childBox;
    if (this.marker) {
      this.marker.reflow(childBox);
    }
    this.reflowLabel(childBox);
    if (this.errorBars) {
      for (var i16 = 0; i16 < this.errorBars.length; i16++) {
        this$1$1.errorBars[i16].reflow(childBox);
      }
    }
    if (this.note) {
      var noteTargetBox = this.markerBox();
      if (!(options2.markers.visible && options2.markers.size)) {
        var center = noteTargetBox.center();
        noteTargetBox = new Box(center.x, center.y, center.x, center.y);
      }
      this.note.reflow(noteTargetBox);
    }
  };
  LinePoint2.prototype.reflowLabel = function reflowLabel(box) {
    var ref2 = this;
    var options2 = ref2.options;
    var label = ref2.label;
    var anchor = options2.labels.position;
    if (label) {
      anchor = anchor === ABOVE ? TOP : anchor;
      anchor = anchor === BELOW ? BOTTOM : anchor;
      label.reflow(box);
      label.box.alignTo(this.markerBox(), anchor);
      label.reflow(label.box);
    }
  };
  LinePoint2.prototype.createHighlight = function createHighlight() {
    var markers = this.options.highlight.markers;
    var defaultColor = this.markerBorder().color;
    var options2 = this.options.markers;
    var size = options2.size + (options2.border.width || 0) + (markers.border.width || 0);
    var shadow = new ShapeElement({
      type: options2.type,
      width: size,
      height: size,
      rotation: options2.rotation,
      background: markers.color || defaultColor,
      border: {
        color: markers.border.color,
        width: markers.border.width,
        opacity: valueOrDefault$1(markers.border.opacity, 1)
      },
      opacity: valueOrDefault$1(markers.opacity, 1)
    });
    shadow.reflow(this._childBox);
    return shadow.getElement();
  };
  LinePoint2.prototype.highlightVisual = function highlightVisual() {
    return (this.marker || {}).visual;
  };
  LinePoint2.prototype.highlightVisualArgs = function highlightVisualArgs() {
    var marker = this.marker;
    var visual, rect;
    if (marker) {
      rect = marker.paddingBox.toRect();
      visual = marker.visual;
    } else {
      var size = this.options.markers.size;
      var halfSize = size / 2;
      var center = this.box.center();
      rect = new Rect$1([center.x - halfSize, center.y - halfSize], [size, size]);
    }
    return {
      options: this.options,
      rect,
      visual
    };
  };
  LinePoint2.prototype.createFocusHighlight = function createFocusHighlight() {
    var markerOptions = this.options.markers;
    var highlightOptions2 = this.options.accessibility.highlight;
    var size = markerOptions.size + (markerOptions.border.width || 0);
    var highlight = new ShapeElement({
      type: markerOptions.type,
      width: size,
      height: size,
      rotation: markerOptions.rotation,
      background: highlightOptions2.color,
      border: highlightOptions2.border,
      opacity: highlightOptions2.opacity,
      padding: highlightOptions2.border.width / 2,
      zIndex: highlightOptions2.zIndex
    });
    highlight.reflow(this._childBox);
    return highlight.getElement();
  };
  LinePoint2.prototype.tooltipAnchor = function tooltipAnchor() {
    var markerBox = this.markerBox();
    var clipBox = this.owner.pane.clipBox();
    var showTooltip = !clipBox || clipBox.overlaps(markerBox);
    if (showTooltip) {
      var x3 = markerBox.x2 + TOOLTIP_OFFSET;
      var horizontalAlign = LEFT;
      var y4, verticalAlign;
      if (this.aboveAxis) {
        y4 = markerBox.y1;
        verticalAlign = BOTTOM;
      } else {
        y4 = markerBox.y2;
        verticalAlign = TOP;
      }
      return {
        point: new Point$5(x3, y4),
        align: {
          horizontal: horizontalAlign,
          vertical: verticalAlign
        }
      };
    }
  };
  LinePoint2.prototype.formatValue = function formatValue(format2) {
    return this.owner.formatPointValue(this, format2);
  };
  LinePoint2.prototype.overlapsBox = function overlapsBox(box) {
    var markerBox = this.markerBox();
    return markerBox.overlaps(box);
  };
  LinePoint2.prototype.unclipElements = function unclipElements() {
    if (this.label) {
      this.label.options.noclip = true;
    }
    if (this.note) {
      this.note.options.noclip = true;
    }
  };
  LinePoint2.prototype.pointData = function pointData() {
    return {
      dataItem: this.dataItem,
      category: this.category,
      value: this.value,
      percentage: this.percentage,
      stackValue: this.stackValue,
      series: this.series
    };
  };
  LinePoint2.prototype.focusVisual = function focusVisual2() {
    if (this.marker) {
      if (this.marker.visual) {
        this.marker.visual.options.set("id", this._id);
      }
      this.toggleFocusHighlight(true);
    }
  };
  LinePoint2.prototype.clearFocusFromVisual = function clearFocusFromVisual2() {
    if (this.marker) {
      if (this.marker.visual) {
        this.marker.visual.options.set("id", "");
      }
      this.toggleFocusHighlight(false);
    }
  };
  LinePoint2.prototype.getIndex = function getIndex() {
    return defined(this.categoryIx) ? this.categoryIx : this.pointIx;
  };
  return LinePoint2;
}(ChartElement);
LinePoint.prototype.defaults = {
  vertical: true,
  markers: {
    visible: true,
    background: WHITE$1,
    size: LINE_MARKER_SIZE,
    type: CIRCLE,
    border: {
      width: 2
    },
    opacity: 1
  },
  labels: {
    visible: false,
    position: ABOVE,
    margin: getSpacing(3),
    padding: getSpacing(4),
    animation: {
      type: FADEIN,
      delay: INITIAL_ANIMATION_DURATION
    }
  },
  notes: {
    label: {}
  },
  highlight: {
    markers: {
      border: {
        color: "#fff",
        width: 2
      }
    },
    zIndex: HIGHLIGHT_ZINDEX
  },
  errorBars: {
    line: {
      width: 1
    }
  },
  accessibility: {
    tabIndex: 0,
    role: CHART_POINT_ROLE,
    className: CHART_POINT_CLASSNAME,
    ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION
  }
};
deepExtend(LinePoint.prototype, PointEventsMixin);
deepExtend(LinePoint.prototype, NoteMixin);
var LineSegment = function(ChartElement2) {
  function LineSegment2(linePoints, series, seriesIx) {
    ChartElement2.call(this);
    this.linePoints = linePoints;
    this.series = series;
    this.seriesIx = seriesIx;
  }
  if (ChartElement2)
    LineSegment2.__proto__ = ChartElement2;
  LineSegment2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  LineSegment2.prototype.constructor = LineSegment2;
  LineSegment2.prototype.points = function points2() {
    return this.toGeometryPoints(this.linePoints);
  };
  LineSegment2.prototype.toGeometryPoints = function toGeometryPoints(points2) {
    var result = [];
    for (var i16 = 0, length = points2.length; i16 < length; i16++) {
      if (points2[i16] && points2[i16].visible !== false) {
        result.push(points2[i16]._childBox.toRect().center());
      }
    }
    return result;
  };
  LineSegment2.prototype.createVisual = function createVisual() {
    var this$1$1 = this;
    var customVisual = this.series.visual;
    if (customVisual) {
      this.visual = customVisual({
        points: this.toGeometryPoints(this.linePoints),
        series: this.series,
        sender: this.getSender(),
        createVisual: function() {
          this$1$1.segmentVisual();
          return this$1$1.visual;
        }
      });
      if (this.visual && !defined(this.visual.options.zIndex)) {
        this.visual.options.zIndex = this.series.zIndex;
      }
    } else {
      this.segmentVisual();
    }
  };
  LineSegment2.prototype.segmentVisual = function segmentVisual() {
    var ref2 = this;
    var options2 = ref2.options;
    var series = ref2.series;
    var color = series.color;
    var defaults = series._defaults;
    if (isFunction$1(color) && defaults) {
      color = defaults.color;
    }
    var line = Path$7.fromPoints(this.points(), {
      stroke: {
        color,
        width: series.width,
        opacity: series.opacity,
        dashType: series.dashType
      },
      zIndex: series.zIndex
    });
    if (options2.closed) {
      line.close();
    }
    this.visual = line;
  };
  LineSegment2.prototype.aliasFor = function aliasFor(e3, coords) {
    return this.parent.getNearestPoint(coords.x, coords.y, this.seriesIx);
  };
  return LineSegment2;
}(ChartElement);
setDefaultOptions(LineSegment, {
  closed: false
});
var StepLineMixin = {
  calculateStepPoints: function(points2) {
    var categoryAxis = this.parent.plotArea.seriesCategoryAxis(this.series);
    var ref2 = categoryAxis.options;
    var justified = ref2.justified;
    var vertical = ref2.vertical;
    var reverse = ref2.reverse;
    var stepAxis = vertical ? X$4 : Y$7;
    var axis = vertical ? Y$7 : X$4;
    var stepDir = reverse ? 2 : 1;
    var dir = stepDir;
    var previousPoint = toGeometryPoint(points2[0], stepAxis, stepDir, axis, dir);
    var result = [previousPoint];
    for (var idx = 1; idx < points2.length; idx++) {
      var point2 = toGeometryPoint(points2[idx], stepAxis, stepDir, axis, dir);
      if (previousPoint[stepAxis] !== point2[stepAxis]) {
        var stepPoint = new Point$7();
        stepPoint[stepAxis] = previousPoint[stepAxis];
        stepPoint[axis] = point2[axis];
        result.push(stepPoint, point2);
      }
      previousPoint = point2;
    }
    if (!justified) {
      result.push(toGeometryPoint(last(points2), stepAxis, stepDir, axis, reverse ? 1 : 2));
    } else if (previousPoint !== last(result)) {
      result.push(previousPoint);
    }
    return result;
  }
};
function toGeometryPoint(lintPoint, stepAxis, stepDir, axis, dir) {
  var box = lintPoint.box;
  var result = new Point$7();
  result[stepAxis] = box[stepAxis + stepDir];
  result[axis] = box[axis + dir];
  return result;
}
var StepLineSegment = function(LineSegment2) {
  function StepLineSegment2() {
    LineSegment2.apply(this, arguments);
  }
  if (LineSegment2)
    StepLineSegment2.__proto__ = LineSegment2;
  StepLineSegment2.prototype = Object.create(LineSegment2 && LineSegment2.prototype);
  StepLineSegment2.prototype.constructor = StepLineSegment2;
  StepLineSegment2.prototype.points = function points2() {
    return this.calculateStepPoints(this.linePoints);
  };
  return StepLineSegment2;
}(LineSegment);
deepExtend(StepLineSegment.prototype, StepLineMixin);
var SplineSegment = function(LineSegment2) {
  function SplineSegment2() {
    LineSegment2.apply(this, arguments);
  }
  if (LineSegment2)
    SplineSegment2.__proto__ = LineSegment2;
  SplineSegment2.prototype = Object.create(LineSegment2 && LineSegment2.prototype);
  SplineSegment2.prototype.constructor = SplineSegment2;
  SplineSegment2.prototype.segmentVisual = function segmentVisual() {
    var series = this.series;
    var defaults = series._defaults;
    var color = series.color;
    if (isFunction$1(color) && defaults) {
      color = defaults.color;
    }
    var curveProcessor = new CurveProcessor(this.options.closed);
    var segments = curveProcessor.process(this.points());
    var curve = new Path$7({
      stroke: {
        color,
        width: series.width,
        opacity: series.opacity,
        dashType: series.dashType
      },
      zIndex: series.zIndex
    });
    curve.segments.push.apply(curve.segments, segments);
    this.visual = curve;
  };
  return SplineSegment2;
}(LineSegment);
var LineChartMixin = {
  renderSegments: function() {
    var this$1$1 = this;
    var ref2 = this;
    var options2 = ref2.options;
    var seriesPoints = ref2.seriesPoints;
    var series = options2.series;
    var seriesCount = seriesPoints.length;
    var lastSegment;
    this._segments = [];
    for (var seriesIx = 0; seriesIx < seriesCount; seriesIx++) {
      var currentSeries = series[seriesIx];
      var sortedPoints = this$1$1.sortPoints(seriesPoints[seriesIx]);
      var pointCount = sortedPoints.length;
      var linePoints = [];
      for (var pointIx = 0; pointIx < pointCount; pointIx++) {
        var point2 = sortedPoints[pointIx];
        if (point2) {
          linePoints.push(point2);
        } else if (this$1$1.seriesMissingValues(currentSeries) !== INTERPOLATE) {
          if (linePoints.length > 1) {
            lastSegment = this$1$1.createSegment(
              linePoints,
              currentSeries,
              seriesIx,
              lastSegment
            );
            this$1$1._addSegment(lastSegment);
          }
          linePoints = [];
        }
      }
      if (linePoints.length > 1) {
        lastSegment = this$1$1.createSegment(
          linePoints,
          currentSeries,
          seriesIx,
          lastSegment
        );
        this$1$1._addSegment(lastSegment);
      }
    }
    this.children.unshift.apply(this.children, this._segments);
  },
  _addSegment: function(segment) {
    this._segments.push(segment);
    segment.parent = this;
  },
  sortPoints: function(points2) {
    return points2;
  },
  seriesMissingValues: function(series) {
    var missingValues = series.missingValues;
    var assumeZero = !missingValues && this.options.isStacked;
    return assumeZero ? ZERO : missingValues || INTERPOLATE;
  },
  getNearestPoint: function(x3, y4, seriesIx) {
    var target = new Point$5(x3, y4);
    var allPoints = this.seriesPoints[seriesIx];
    var nearestPointDistance = MAX_VALUE;
    var nearestPoint;
    for (var i16 = 0; i16 < allPoints.length; i16++) {
      var point2 = allPoints[i16];
      if (point2 && defined(point2.value) && point2.value !== null && point2.visible !== false) {
        var pointBox = point2.box;
        var pointDistance = pointBox.center().distanceTo(target);
        if (pointDistance < nearestPointDistance) {
          nearestPoint = point2;
          nearestPointDistance = pointDistance;
        }
      }
    }
    return nearestPoint;
  }
};
var ClipAnimation = function(superclass) {
  function ClipAnimation2() {
    superclass.apply(this, arguments);
  }
  if (superclass)
    ClipAnimation2.__proto__ = superclass;
  ClipAnimation2.prototype = Object.create(superclass && superclass.prototype);
  ClipAnimation2.prototype.constructor = ClipAnimation2;
  ClipAnimation2.prototype.setup = function setup() {
    this._setEnd(this.options.box.x1);
  };
  ClipAnimation2.prototype.step = function step(pos) {
    var box = this.options.box;
    this._setEnd(interpolateValue(box.x1, box.x2, pos));
  };
  ClipAnimation2.prototype._setEnd = function _setEnd(x3) {
    var element = this.element;
    var segments = element.segments;
    var topRight = segments[1].anchor();
    var bottomRight = segments[2].anchor();
    element.suspend();
    topRight.setX(x3);
    element.resume();
    bottomRight.setX(x3);
  };
  return ClipAnimation2;
}(Animation$2);
setDefaultOptions(ClipAnimation, {
  duration: INITIAL_ANIMATION_DURATION
});
AnimationFactory$1.current.register("clip", ClipAnimation);
var ClipAnimationMixin = {
  createAnimation: function() {
    var root = this.getRoot();
    if (root && (root.options || {}).transitions !== false) {
      var box = root.size();
      var clipPath = Path$7.fromRect(box.toRect());
      this.visual.clip(clipPath);
      this.animation = new ClipAnimation(clipPath, {
        box
      });
      if (anyHasZIndex(this.options.series)) {
        this._setChildrenAnimation(clipPath);
      }
    }
  },
  _setChildrenAnimation: function(clipPath) {
    var points2 = this.animationPoints();
    for (var idx = 0; idx < points2.length; idx++) {
      var point2 = points2[idx];
      if (point2 && point2.visual && defined(point2.visual.options.zIndex)) {
        point2.visual.clip(clipPath);
      }
    }
  }
};
var LineChart = function(CategoricalChart2) {
  function LineChart2() {
    CategoricalChart2.apply(this, arguments);
  }
  if (CategoricalChart2)
    LineChart2.__proto__ = CategoricalChart2;
  LineChart2.prototype = Object.create(CategoricalChart2 && CategoricalChart2.prototype);
  LineChart2.prototype.constructor = LineChart2;
  LineChart2.prototype.render = function render() {
    CategoricalChart2.prototype.render.call(this);
    this.updateStackRange();
    this.renderSegments();
  };
  LineChart2.prototype.pointType = function pointType() {
    return LinePoint;
  };
  LineChart2.prototype.createPoint = function createPoint(data2, fields) {
    var series = fields.series;
    var seriesIx = fields.seriesIx;
    var missingValues = this.seriesMissingValues(series);
    var value2 = data2.valueFields.value;
    if (!defined(value2) || value2 === null) {
      if (missingValues === ZERO) {
        value2 = 0;
      } else {
        return null;
      }
    }
    var pointOptions = this.pointOptions(series, seriesIx);
    pointOptions = this.evalPointOptions(pointOptions, value2, fields);
    var color = data2.fields.color || series.color;
    if (isFunction$1(series.color)) {
      color = pointOptions.color;
    }
    var point2 = new LinePoint(value2, pointOptions);
    point2.color = color;
    this.append(point2);
    return point2;
  };
  LineChart2.prototype.plotRange = function plotRange(point2) {
    var this$1$1 = this;
    var plotValue = this.plotValue(point2);
    if (this.options.isStacked) {
      var categoryIx = point2.categoryIx;
      var categoryPoints = this.categoryPoints[categoryIx];
      for (var i16 = 0; i16 < categoryPoints.length; i16++) {
        var other = categoryPoints[i16];
        if (point2 === other) {
          break;
        }
        plotValue += this$1$1.plotValue(other);
        if (this$1$1.options.isStacked100) {
          plotValue = Math.min(plotValue, 1);
        }
      }
    }
    return [plotValue, plotValue];
  };
  LineChart2.prototype.createSegment = function createSegment(linePoints, currentSeries, seriesIx) {
    var style2 = currentSeries.style;
    var pointType;
    if (style2 === STEP) {
      pointType = StepLineSegment;
    } else if (style2 === SMOOTH) {
      pointType = SplineSegment;
    } else {
      pointType = LineSegment;
    }
    return new pointType(linePoints, currentSeries, seriesIx);
  };
  LineChart2.prototype.animationPoints = function animationPoints() {
    var points2 = this.points;
    var result = [];
    for (var idx = 0; idx < points2.length; idx++) {
      result.push((points2[idx] || {}).marker);
    }
    return result.concat(this._segments);
  };
  LineChart2.prototype.supportsPointInactiveOpacity = function supportsPointInactiveOpacity() {
    return false;
  };
  return LineChart2;
}(CategoricalChart);
deepExtend(LineChart.prototype, LineChartMixin, ClipAnimationMixin);
var AreaSegment = function(LineSegment2) {
  function AreaSegment2(linePoints, currentSeries, seriesIx, prevSegment, stackPoints) {
    LineSegment2.call(this, linePoints, currentSeries, seriesIx);
    this.prevSegment = prevSegment;
    this.stackPoints = stackPoints;
  }
  if (LineSegment2)
    AreaSegment2.__proto__ = LineSegment2;
  AreaSegment2.prototype = Object.create(LineSegment2 && LineSegment2.prototype);
  AreaSegment2.prototype.constructor = AreaSegment2;
  AreaSegment2.prototype.createVisual = function createVisual() {
    var series = this.series;
    var defaults = series._defaults;
    var lineOptions = series.line || {};
    var color = series.color;
    if (isFunction$1(color) && defaults) {
      color = defaults.color;
    }
    this.visual = new Group$9({
      zIndex: series.zIndex
    });
    this.createFill({
      fill: {
        color,
        opacity: series.opacity
      },
      stroke: null
    });
    if (lineOptions.width > 0 && lineOptions.visible !== false) {
      this.createStroke({
        stroke: deepExtend({
          color,
          opacity: series.opacity,
          lineCap: "butt"
        }, lineOptions)
      });
    }
  };
  AreaSegment2.prototype.strokeSegments = function strokeSegments() {
    var segments = this._strokeSegments;
    if (!segments) {
      segments = this._strokeSegments = this.createStrokeSegments();
    }
    return segments;
  };
  AreaSegment2.prototype.createStrokeSegments = function createStrokeSegments() {
    return this.segmentsFromPoints(this.points());
  };
  AreaSegment2.prototype.stackSegments = function stackSegments() {
    if (this.prevSegment) {
      return this.prevSegment.createStackSegments(this.stackPoints);
    }
    return this.createStackSegments(this.stackPoints);
  };
  AreaSegment2.prototype.createStackSegments = function createStackSegments(stackPoints) {
    return this.segmentsFromPoints(this.toGeometryPoints(stackPoints)).reverse();
  };
  AreaSegment2.prototype.segmentsFromPoints = function segmentsFromPoints(points2) {
    return points2.map(function(point2) {
      return new Segment$1(point2);
    });
  };
  AreaSegment2.prototype.createStroke = function createStroke(style2) {
    var stroke = new Path$7(style2);
    stroke.segments.push.apply(stroke.segments, this.strokeSegments());
    this.visual.append(stroke);
  };
  AreaSegment2.prototype.hasStackSegment = function hasStackSegment() {
    return this.prevSegment || this.stackPoints && this.stackPoints.length;
  };
  AreaSegment2.prototype.createFill = function createFill(style2) {
    var strokeSegments = this.strokeSegments();
    var fillSegments = strokeSegments.slice(0);
    var hasStackSegments = this.hasStackSegment();
    if (hasStackSegments) {
      var stackSegments = this.stackSegments();
      append(fillSegments, stackSegments);
    }
    var fill = new Path$7(style2);
    fill.segments.push.apply(fill.segments, fillSegments);
    if (!hasStackSegments && strokeSegments.length > 1) {
      this.fillToAxes(fill);
    }
    this.visual.append(fill);
  };
  AreaSegment2.prototype.fillToAxes = function fillToAxes(fillPath) {
    var chart = this.parent;
    var invertAxes = chart.options.invertAxes;
    var valueAxis = chart.seriesValueAxis(this.series);
    var crossingValue = chart.categoryAxisCrossingValue(valueAxis);
    var endSlot = valueAxis.getSlot(crossingValue, crossingValue, true);
    var segments = this.strokeSegments();
    var firstPoint = segments[0].anchor();
    var lastPoint = last(segments).anchor();
    var end = invertAxes ? endSlot.x1 : endSlot.y1;
    if (invertAxes) {
      fillPath.lineTo(end, lastPoint.y).lineTo(end, firstPoint.y);
    } else {
      fillPath.lineTo(lastPoint.x, end).lineTo(firstPoint.x, end);
    }
  };
  return AreaSegment2;
}(LineSegment);
var StepAreaSegment = function(AreaSegment2) {
  function StepAreaSegment2() {
    AreaSegment2.apply(this, arguments);
  }
  if (AreaSegment2)
    StepAreaSegment2.__proto__ = AreaSegment2;
  StepAreaSegment2.prototype = Object.create(AreaSegment2 && AreaSegment2.prototype);
  StepAreaSegment2.prototype.constructor = StepAreaSegment2;
  StepAreaSegment2.prototype.createStrokeSegments = function createStrokeSegments() {
    return this.segmentsFromPoints(this.calculateStepPoints(this.linePoints));
  };
  StepAreaSegment2.prototype.createStackSegments = function createStackSegments(stackPoints) {
    return this.segmentsFromPoints(this.calculateStepPoints(stackPoints)).reverse();
  };
  return StepAreaSegment2;
}(AreaSegment);
deepExtend(StepAreaSegment.prototype, StepLineMixin);
var SplineAreaSegment = function(AreaSegment2) {
  function SplineAreaSegment2() {
    AreaSegment2.apply(this, arguments);
  }
  if (AreaSegment2)
    SplineAreaSegment2.__proto__ = AreaSegment2;
  SplineAreaSegment2.prototype = Object.create(AreaSegment2 && AreaSegment2.prototype);
  SplineAreaSegment2.prototype.constructor = SplineAreaSegment2;
  SplineAreaSegment2.prototype.createStrokeSegments = function createStrokeSegments() {
    var curveProcessor = new CurveProcessor(this.options.closed);
    var linePoints = this.points();
    return curveProcessor.process(linePoints);
  };
  SplineAreaSegment2.prototype.createStackSegments = function createStackSegments() {
    var strokeSegments = this.strokeSegments();
    var stackSegments = [];
    for (var idx = strokeSegments.length - 1; idx >= 0; idx--) {
      var segment = strokeSegments[idx];
      stackSegments.push(new Segment$1(
        segment.anchor(),
        segment.controlOut(),
        segment.controlIn()
      ));
    }
    return stackSegments;
  };
  return SplineAreaSegment2;
}(AreaSegment);
var AreaChart = function(LineChart2) {
  function AreaChart2() {
    LineChart2.apply(this, arguments);
  }
  if (LineChart2)
    AreaChart2.__proto__ = LineChart2;
  AreaChart2.prototype = Object.create(LineChart2 && LineChart2.prototype);
  AreaChart2.prototype.constructor = AreaChart2;
  AreaChart2.prototype.createSegment = function createSegment(linePoints, currentSeries, seriesIx, prevSegment) {
    var isStacked = this.options.isStacked;
    var style2 = (currentSeries.line || {}).style;
    var previousSegment;
    var stackPoints;
    if (isStacked && seriesIx > 0 && prevSegment) {
      var missingValues = this.seriesMissingValues(currentSeries);
      if (missingValues !== "gap") {
        stackPoints = prevSegment.linePoints;
        previousSegment = prevSegment;
      } else {
        stackPoints = this._gapStackPoints(linePoints, seriesIx, style2);
      }
    }
    var pointType;
    if (style2 === STEP) {
      pointType = StepAreaSegment;
    } else if (style2 === SMOOTH) {
      pointType = SplineAreaSegment;
    } else {
      pointType = AreaSegment;
    }
    return new pointType(linePoints, currentSeries, seriesIx, previousSegment, stackPoints);
  };
  AreaChart2.prototype.reflow = function reflow(targetBox) {
    var this$1$1 = this;
    LineChart2.prototype.reflow.call(this, targetBox);
    var stackPoints = this._stackPoints;
    if (stackPoints) {
      for (var idx = 0; idx < stackPoints.length; idx++) {
        var stackPoint = stackPoints[idx];
        var pointSlot = this$1$1.categoryAxis.getSlot(stackPoint.categoryIx);
        stackPoint.reflow(pointSlot);
      }
    }
  };
  AreaChart2.prototype._gapStackPoints = function _gapStackPoints(linePoints, seriesIx, style2) {
    var this$1$1 = this;
    var seriesPoints = this.seriesPoints;
    var startIdx = linePoints[0].categoryIx;
    var length = linePoints.length;
    if (startIdx < 0) {
      startIdx = 0;
      length--;
    }
    var endIdx = startIdx + length;
    var pointOffset = this.seriesOptions[0]._outOfRangeMinPoint ? 1 : 0;
    var stackPoints = [];
    this._stackPoints = this._stackPoints || [];
    for (var categoryIx = startIdx; categoryIx < endIdx; categoryIx++) {
      var pointIx = categoryIx + pointOffset;
      var currentSeriesIx = seriesIx;
      var point2 = void 0;
      do {
        currentSeriesIx--;
        point2 = seriesPoints[currentSeriesIx][pointIx];
      } while (currentSeriesIx > 0 && !point2);
      if (point2) {
        if (style2 !== STEP && categoryIx > startIdx && !seriesPoints[currentSeriesIx][pointIx - 1]) {
          stackPoints.push(this$1$1._previousSegmentPoint(categoryIx, pointIx, pointIx - 1, currentSeriesIx));
        }
        stackPoints.push(point2);
        if (style2 !== STEP && categoryIx + 1 < endIdx && !seriesPoints[currentSeriesIx][pointIx + 1]) {
          stackPoints.push(this$1$1._previousSegmentPoint(categoryIx, pointIx, pointIx + 1, currentSeriesIx));
        }
      } else {
        var gapStackPoint = this$1$1._createGapStackPoint(categoryIx);
        this$1$1._stackPoints.push(gapStackPoint);
        stackPoints.push(gapStackPoint);
      }
    }
    return stackPoints;
  };
  AreaChart2.prototype._previousSegmentPoint = function _previousSegmentPoint(categoryIx, pointIx, segmentIx, seriesIdx) {
    var seriesPoints = this.seriesPoints;
    var index2 = seriesIdx;
    var point2;
    while (index2 > 0 && !point2) {
      index2--;
      point2 = seriesPoints[index2][segmentIx];
    }
    if (!point2) {
      point2 = this._createGapStackPoint(categoryIx);
      this._stackPoints.push(point2);
    } else {
      point2 = seriesPoints[index2][pointIx];
    }
    return point2;
  };
  AreaChart2.prototype._createGapStackPoint = function _createGapStackPoint(categoryIx) {
    var options2 = this.pointOptions({}, 0);
    var point2 = new LinePoint(0, options2);
    point2.categoryIx = categoryIx;
    point2.series = {};
    return point2;
  };
  AreaChart2.prototype.seriesMissingValues = function seriesMissingValues2(series) {
    return series.missingValues || ZERO;
  };
  AreaChart2.prototype.supportsPointInactiveOpacity = function supportsPointInactiveOpacity() {
    return false;
  };
  return AreaChart2;
}(LineChart);
var AxisGroupRangeTracker = function(Class3) {
  function AxisGroupRangeTracker2() {
    Class3.call(this);
    this.axisRanges = {};
  }
  if (Class3)
    AxisGroupRangeTracker2.__proto__ = Class3;
  AxisGroupRangeTracker2.prototype = Object.create(Class3 && Class3.prototype);
  AxisGroupRangeTracker2.prototype.constructor = AxisGroupRangeTracker2;
  AxisGroupRangeTracker2.prototype.update = function update(chartAxisRanges) {
    var axisRanges2 = this.axisRanges;
    for (var axisName in chartAxisRanges) {
      var chartRange = chartAxisRanges[axisName];
      var range = axisRanges2[axisName];
      axisRanges2[axisName] = range = range || { min: MAX_VALUE, max: MIN_VALUE };
      range.min = Math.min(range.min, chartRange.min);
      range.max = Math.max(range.max, chartRange.max);
    }
  };
  AxisGroupRangeTracker2.prototype.reset = function reset(axisName) {
    this.axisRanges[axisName] = void 0;
  };
  AxisGroupRangeTracker2.prototype.query = function query(axisName) {
    return this.axisRanges[axisName];
  };
  return AxisGroupRangeTracker2;
}(Class$1);
var BarLabel = function(ChartElement2) {
  function BarLabel2(content, options2, pointData) {
    ChartElement2.call(this, options2);
    this.textBox = new TextBox(content, this.options, pointData);
    this.append(this.textBox);
  }
  if (ChartElement2)
    BarLabel2.__proto__ = ChartElement2;
  BarLabel2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  BarLabel2.prototype.constructor = BarLabel2;
  BarLabel2.prototype.createVisual = function createVisual() {
    this.textBox.options.noclip = this.options.noclip;
  };
  BarLabel2.prototype.reflow = function reflow(targetBox) {
    var options2 = this.options;
    var vertical = options2.vertical;
    var aboveAxis = options2.aboveAxis;
    var text = this.children[0];
    var textOptions = text.options;
    var box = text.box;
    var padding = text.options.padding;
    var labelBox = targetBox;
    textOptions.align = vertical ? CENTER : LEFT;
    textOptions.vAlign = vertical ? TOP : CENTER;
    if (options2.position === INSIDE_END) {
      if (vertical) {
        textOptions.vAlign = TOP;
        if (!aboveAxis && box.height() < targetBox.height()) {
          textOptions.vAlign = BOTTOM;
        }
      } else {
        textOptions.align = aboveAxis ? RIGHT : LEFT;
      }
    } else if (options2.position === CENTER) {
      textOptions.vAlign = CENTER;
      textOptions.align = CENTER;
    } else if (options2.position === INSIDE_BASE) {
      if (vertical) {
        textOptions.vAlign = aboveAxis ? BOTTOM : TOP;
      } else {
        textOptions.align = aboveAxis ? LEFT : RIGHT;
      }
    } else if (options2.position === OUTSIDE_END) {
      if (vertical) {
        if (aboveAxis) {
          labelBox = new Box(
            targetBox.x1,
            targetBox.y1 - box.height(),
            targetBox.x2,
            targetBox.y1
          );
        } else {
          labelBox = new Box(
            targetBox.x1,
            targetBox.y2,
            targetBox.x2,
            targetBox.y2 + box.height()
          );
        }
      } else {
        textOptions.align = CENTER;
        if (aboveAxis) {
          labelBox = new Box(
            targetBox.x2,
            targetBox.y1,
            targetBox.x2 + box.width(),
            targetBox.y2
          );
        } else {
          labelBox = new Box(
            targetBox.x1 - box.width(),
            targetBox.y1,
            targetBox.x1,
            targetBox.y2
          );
        }
      }
    }
    if (!options2.rotation) {
      if (vertical) {
        padding.left = padding.right = (labelBox.width() - text.contentBox.width()) / 2;
      } else {
        padding.top = padding.bottom = (labelBox.height() - text.contentBox.height()) / 2;
      }
    }
    text.reflow(labelBox);
  };
  BarLabel2.prototype.alignToClipBox = function alignToClipBox(clipBox) {
    var vertical = this.options.vertical;
    var field = vertical ? Y$7 : X$4;
    var start = field + "1";
    var end = field + "2";
    var text = this.children[0];
    var parentBox = this.parent.box;
    if (parentBox[start] < clipBox[start] || clipBox[end] < parentBox[end]) {
      var targetBox = text.paddingBox.clone();
      targetBox[start] = Math.max(parentBox[start], clipBox[start]);
      targetBox[end] = Math.min(parentBox[end], clipBox[end]);
      this.reflow(targetBox);
    }
  };
  return BarLabel2;
}(ChartElement);
setDefaultOptions(BarLabel, {
  position: OUTSIDE_END,
  margin: getSpacing(3),
  padding: getSpacing(4),
  color: BLACK$1,
  background: "",
  border: {
    width: 1,
    color: ""
  },
  aboveAxis: true,
  vertical: false,
  animation: {
    type: FADEIN,
    delay: INITIAL_ANIMATION_DURATION
  },
  zIndex: 2
});
var AccessibilityAttributesMixin = {
  addAccessibilityAttributesToVisual: function() {
    this._id = this._id || guid();
    var accessibilityOptions = deepExtend({
      ariaLabel: this.getAriaLabelText()
    }, this.options.accessibility);
    addAccessibilityAttributesToVisual(this.visual, accessibilityOptions);
  },
  getAriaLabelText: function getAriaLabelText() {
    var labels = this.options.labels;
    var ariaTemplate = getTemplate(labels);
    if (ariaTemplate) {
      return ariaTemplate(this.pointData());
    }
    return this.getLabelText(labels);
  },
  focusVisual: function focusVisual() {
    this.visual.options.set("id", this._id);
    this.toggleFocusHighlight(true);
  },
  clearFocusFromVisual: function clearFocusFromVisual() {
    this.visual.options.set("id", "");
    this.toggleFocusHighlight(false);
  }
};
var BAR_ALIGN_MIN_WIDTH = 6;
var Bar = function(ChartElement2) {
  function Bar2(value2, options2) {
    ChartElement2.call(this);
    this.options = options2;
    this.color = options2.color || WHITE$1;
    this.aboveAxis = valueOrDefault$1(this.options.aboveAxis, true);
    this.value = value2;
  }
  if (ChartElement2)
    Bar2.__proto__ = ChartElement2;
  Bar2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  Bar2.prototype.constructor = Bar2;
  Bar2.prototype.render = function render() {
    if (this._rendered) {
      return;
    }
    this._rendered = true;
    this.createLabel();
    this.createNote();
    if (this.errorBar) {
      this.append(this.errorBar);
    }
  };
  Bar2.prototype.createLabel = function createLabel() {
    var options2 = this.options;
    var labels = options2.labels;
    if (labels.visible) {
      this.label = this.createLabelElement(labels);
      this.append(this.label);
    }
  };
  Bar2.prototype.createLabelElement = function createLabelElement(options2) {
    return new BarLabel(
      this.getLabelText(options2),
      deepExtend(
        {
          vertical: this.options.vertical
        },
        options2
      ),
      this.pointData()
    );
  };
  Bar2.prototype.getLabelText = function getLabelText(options2) {
    var labelTemplate = getTemplate$1(options2);
    if (labelTemplate) {
      return labelTemplate(this.pointData());
    }
    return this.formatValue(options2.format);
  };
  Bar2.prototype.formatValue = function formatValue(format2) {
    return this.owner.formatPointValue(this, format2);
  };
  Bar2.prototype.reflow = function reflow(targetBox) {
    var this$1$1 = this;
    this.render();
    var label = this.label;
    this.box = targetBox;
    if (label) {
      label.options.aboveAxis = this.aboveAxis;
      label.reflow(targetBox);
    }
    if (this.note) {
      this.note.reflow(targetBox);
    }
    if (this.errorBars) {
      for (var i16 = 0; i16 < this.errorBars.length; i16++) {
        this$1$1.errorBars[i16].reflow(targetBox);
      }
    }
  };
  Bar2.prototype.createVisual = function createVisual() {
    var this$1$1 = this;
    var ref2 = this;
    var box = ref2.box;
    var options2 = ref2.options;
    var customVisual = options2.visual;
    if (this.visible !== false) {
      ChartElement2.prototype.createVisual.call(this);
      this.addAccessibilityAttributesToVisual();
      if (customVisual) {
        var visual = this.rectVisual = customVisual({
          category: this.category,
          dataItem: this.dataItem,
          value: this.value,
          sender: this.getSender(),
          series: this.series,
          percentage: this.percentage,
          stackValue: this.stackValue,
          runningTotal: this.runningTotal,
          total: this.total,
          rect: box.toRect(),
          createVisual: function() {
            var group2 = new Group$9();
            this$1$1.createRect(group2);
            return group2;
          },
          options: options2
        });
        if (visual) {
          this.visual.append(visual);
        }
      } else if (box.width() > 0 && box.height() > 0) {
        this.createRect(this.visual);
      }
    }
  };
  Bar2.prototype.createRect = function createRect(visual) {
    var options2 = this.options;
    var border = options2.border;
    var strokeOpacity = defined(border.opacity) ? border.opacity : options2.opacity;
    var rect = this.box.toRect();
    rect.size.width = Math.round(rect.size.width);
    var path = this.rectVisual = Path$7.fromRect(rect, {
      fill: {
        color: this.color,
        opacity: options2.opacity
      },
      stroke: {
        color: this.getBorderColor(),
        width: border.width,
        opacity: strokeOpacity,
        dashType: border.dashType
      }
    });
    var width = this.box.width();
    var height = this.box.height();
    var size = options2.vertical ? width : height;
    if (size > BAR_ALIGN_MIN_WIDTH) {
      alignPathToPixel(path);
      if (width < 1 || height < 1) {
        path.options.stroke.lineJoin = "round";
      }
    }
    visual.append(path);
    if (hasGradientOverlay(options2)) {
      var overlay = this.createGradientOverlay(path, { baseColor: this.color }, deepExtend({
        end: !options2.vertical ? [0, 1] : void 0
      }, options2.overlay));
      visual.append(overlay);
    }
  };
  Bar2.prototype.createHighlight = function createHighlight(style2) {
    var highlight = Path$7.fromRect(this.box.toRect(), style2);
    return alignPathToPixel(highlight);
  };
  Bar2.prototype.highlightVisual = function highlightVisual() {
    return this.rectVisual;
  };
  Bar2.prototype.highlightVisualArgs = function highlightVisualArgs() {
    return {
      options: this.options,
      rect: this.box.toRect(),
      visual: this.rectVisual
    };
  };
  Bar2.prototype.createFocusHighlight = function createFocusHighlight(style2) {
    var borderWidth = this.options.accessibility.highlight.border.width;
    var highlight = Path$7.fromRect(this.box.pad(borderWidth / 2).toRect(), style2);
    return alignPathToPixel(highlight);
  };
  Bar2.prototype.getBorderColor = function getBorderColor() {
    var color = this.color;
    var border = this.options.border;
    var brightness = border._brightness || BORDER_BRIGHTNESS;
    var borderColor = border.color;
    if (!defined(borderColor)) {
      borderColor = new m$e(color).brightness(brightness).toHex();
    }
    return borderColor;
  };
  Bar2.prototype.tooltipAnchor = function tooltipAnchor() {
    var ref2 = this;
    var options2 = ref2.options;
    var box = ref2.box;
    var aboveAxis = ref2.aboveAxis;
    var clipBox = this.owner.pane.clipBox() || box;
    var horizontalAlign = LEFT;
    var verticalAlign = TOP;
    var x3, y4;
    if (options2.vertical) {
      x3 = Math.min(box.x2, clipBox.x2) + TOOLTIP_OFFSET;
      if (aboveAxis) {
        y4 = Math.max(box.y1, clipBox.y1);
      } else {
        y4 = Math.min(box.y2, clipBox.y2);
        verticalAlign = BOTTOM;
      }
    } else {
      var x1 = Math.max(box.x1, clipBox.x1);
      var x22 = Math.min(box.x2, clipBox.x2);
      if (options2.isStacked) {
        verticalAlign = BOTTOM;
        if (aboveAxis) {
          horizontalAlign = RIGHT;
          x3 = x22;
        } else {
          x3 = x1;
        }
        y4 = Math.max(box.y1, clipBox.y1) - TOOLTIP_OFFSET;
      } else {
        if (aboveAxis) {
          x3 = x22 + TOOLTIP_OFFSET;
        } else {
          x3 = x1 - TOOLTIP_OFFSET;
          horizontalAlign = RIGHT;
        }
        y4 = Math.max(box.y1, clipBox.y1);
      }
    }
    return {
      point: new Point$5(x3, y4),
      align: {
        horizontal: horizontalAlign,
        vertical: verticalAlign
      }
    };
  };
  Bar2.prototype.overlapsBox = function overlapsBox(box) {
    return this.box.overlaps(box);
  };
  Bar2.prototype.pointData = function pointData() {
    return {
      dataItem: this.dataItem,
      category: this.category,
      value: this.value,
      percentage: this.percentage,
      stackValue: this.stackValue,
      runningTotal: this.runningTotal,
      total: this.total,
      series: this.series
    };
  };
  Bar2.prototype.getIndex = function getIndex() {
    return this.categoryIx;
  };
  return Bar2;
}(ChartElement);
deepExtend(Bar.prototype, PointEventsMixin);
deepExtend(Bar.prototype, NoteMixin);
deepExtend(Bar.prototype, AccessibilityAttributesMixin);
Bar.prototype.defaults = {
  border: {
    width: 1
  },
  vertical: true,
  overlay: {
    gradient: "glass"
  },
  labels: {
    visible: false,
    format: "{0}"
  },
  opacity: 1,
  notes: {
    label: {}
  },
  accessibility: {
    role: CHART_POINT_ROLE,
    className: CHART_POINT_CLASSNAME,
    ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION
  }
};
function forEach(elements, callback) {
  elements.forEach(callback);
}
function forEachReverse(elements, callback) {
  var length = elements.length;
  for (var idx = length - 1; idx >= 0; idx--) {
    callback(elements[idx], idx - length - 1);
  }
}
var ClusterLayout = function(ChartElement2) {
  function ClusterLayout2(options2) {
    ChartElement2.call(this, options2);
    this.forEach = options2.rtl ? forEachReverse : forEach;
  }
  if (ChartElement2)
    ClusterLayout2.__proto__ = ChartElement2;
  ClusterLayout2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  ClusterLayout2.prototype.constructor = ClusterLayout2;
  ClusterLayout2.prototype.reflow = function reflow(box) {
    var ref2 = this.options;
    var vertical = ref2.vertical;
    var gap = ref2.gap;
    var spacing = ref2.spacing;
    var children = this.children;
    var count = children.length;
    var axis = vertical ? Y$7 : X$4;
    var slots = count + gap + spacing * (count - 1);
    var slotSize = (vertical ? box.height() : box.width()) / slots;
    var position2 = box[axis + 1] + slotSize * (gap / 2);
    this.forEach(children, function(child, idx) {
      var childBox = (child.box || box).clone();
      childBox[axis + 1] = position2;
      childBox[axis + 2] = position2 + slotSize;
      child.reflow(childBox);
      if (idx < count - 1) {
        position2 += slotSize * spacing;
      }
      position2 += slotSize;
    });
  };
  return ClusterLayout2;
}(ChartElement);
setDefaultOptions(ClusterLayout, {
  vertical: false,
  gap: 0,
  spacing: 0
});
var StackWrap = function(ChartElement2) {
  function StackWrap2() {
    ChartElement2.apply(this, arguments);
  }
  if (ChartElement2)
    StackWrap2.__proto__ = ChartElement2;
  StackWrap2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  StackWrap2.prototype.constructor = StackWrap2;
  StackWrap2.prototype.reflow = function reflow(targetBox) {
    var this$1$1 = this;
    var positionAxis = this.options.vertical ? X$4 : Y$7;
    var children = this.children;
    var childrenCount = children.length;
    var box = this.box = new Box();
    for (var i16 = 0; i16 < childrenCount; i16++) {
      var currentChild = children[i16];
      if (currentChild.visible !== false) {
        var childBox = currentChild.box.clone();
        childBox.snapTo(targetBox, positionAxis);
        if (i16 === 0) {
          box = this$1$1.box = childBox.clone();
        }
        currentChild.reflow(childBox);
        box.wrap(childBox);
      }
    }
  };
  return StackWrap2;
}(ChartElement);
setDefaultOptions(StackWrap, {
  vertical: true
});
var BarChart = function(CategoricalChart2) {
  function BarChart2() {
    CategoricalChart2.apply(this, arguments);
  }
  if (CategoricalChart2)
    BarChart2.__proto__ = CategoricalChart2;
  BarChart2.prototype = Object.create(CategoricalChart2 && CategoricalChart2.prototype);
  BarChart2.prototype.constructor = BarChart2;
  BarChart2.prototype.render = function render() {
    CategoricalChart2.prototype.render.call(this);
    this.updateStackRange();
  };
  BarChart2.prototype.pointType = function pointType() {
    return Bar;
  };
  BarChart2.prototype.clusterType = function clusterType() {
    return ClusterLayout;
  };
  BarChart2.prototype.stackType = function stackType() {
    return StackWrap;
  };
  BarChart2.prototype.stackLimits = function stackLimits(axisName, stackName) {
    var limits = CategoricalChart2.prototype.stackLimits.call(this, axisName, stackName);
    return limits;
  };
  BarChart2.prototype.createPoint = function createPoint(data2, fields) {
    var categoryIx = fields.categoryIx;
    var series = fields.series;
    var seriesIx = fields.seriesIx;
    var ref2 = this;
    var options2 = ref2.options;
    var children = ref2.children;
    var stackOrDefault = defined(series.stack) ? series.stack : options2.defaultStack;
    var value2 = this.pointValue(data2);
    var pointOptions = this.pointOptions(series, seriesIx);
    var labelOptions = pointOptions.labels;
    if (stackOrDefault) {
      if (labelOptions.position === OUTSIDE_END) {
        labelOptions.position = INSIDE_END;
      }
    }
    pointOptions.isStacked = stackOrDefault;
    var color = data2.fields.color || series.color;
    if (value2 < 0 && pointOptions.negativeColor) {
      color = pointOptions.negativeColor;
    }
    pointOptions = this.evalPointOptions(pointOptions, value2, fields);
    if (isFunction$1(series.color)) {
      color = pointOptions.color;
    }
    var pointType = this.pointType();
    var point2 = new pointType(value2, pointOptions);
    point2.color = color;
    var cluster = children[categoryIx];
    if (!cluster) {
      var clusterType = this.clusterType();
      cluster = new clusterType({
        vertical: options2.invertAxes,
        gap: options2.gap,
        spacing: options2.spacing,
        rtl: !options2.invertAxes && (this.chartService || {}).rtl
      });
      this.append(cluster);
    }
    if (options2.isStacked) {
      var stackWrap = this.getStackWrap(stackOrDefault, cluster);
      stackWrap.append(point2);
    } else {
      cluster.append(point2);
    }
    return point2;
  };
  BarChart2.prototype.getStackWrap = function getStackWrap(stack, cluster) {
    var stackGroup = typeof stack === OBJECT$1 ? stack.group || true : stack;
    var wraps = cluster.children;
    var stackWrap;
    if (typeof stackGroup === STRING$1 || stackGroup === true) {
      for (var i16 = 0; i16 < wraps.length; i16++) {
        if (wraps[i16]._stackGroup === stackGroup) {
          stackWrap = wraps[i16];
          break;
        }
      }
    }
    if (!stackWrap) {
      var stackType = this.stackType();
      stackWrap = new stackType({
        vertical: !this.options.invertAxes
      });
      stackWrap._stackGroup = stackGroup;
      cluster.append(stackWrap);
    }
    return stackWrap;
  };
  BarChart2.prototype.categorySlot = function categorySlot(categoryAxis, categoryIx, valueAxis) {
    var options2 = this.options;
    var categorySlot2 = categoryAxis.getSlot(categoryIx);
    var startValue = valueAxis.startValue();
    if (options2.isStacked) {
      var zeroSlot = valueAxis.getSlot(startValue, startValue, true);
      var stackAxis = options2.invertAxes ? X$4 : Y$7;
      categorySlot2[stackAxis + 1] = categorySlot2[stackAxis + 2] = zeroSlot[stackAxis + 1];
    }
    return categorySlot2;
  };
  BarChart2.prototype.reflowCategories = function reflowCategories(categorySlots) {
    var children = this.children;
    var childrenLength = children.length;
    for (var i16 = 0; i16 < childrenLength; i16++) {
      children[i16].reflow(categorySlots[i16]);
    }
  };
  BarChart2.prototype.createAnimation = function createAnimation() {
    this._setAnimationOptions();
    CategoricalChart2.prototype.createAnimation.call(this);
    if (anyHasZIndex(this.options.series)) {
      this._setChildrenAnimation();
    }
  };
  BarChart2.prototype._setChildrenAnimation = function _setChildrenAnimation() {
    var this$1$1 = this;
    var points2 = this.points;
    for (var idx = 0; idx < points2.length; idx++) {
      var point2 = points2[idx];
      var pointVisual = point2.visual;
      if (pointVisual && defined(pointVisual.options.zIndex)) {
        point2.options.animation = this$1$1.options.animation;
        point2.createAnimation();
      }
    }
  };
  BarChart2.prototype._setAnimationOptions = function _setAnimationOptions() {
    var options2 = this.options;
    var animation = options2.animation || {};
    var origin;
    if (options2.isStacked) {
      var valueAxis = this.seriesValueAxis(options2.series[0]);
      origin = valueAxis.getSlot(valueAxis.startValue());
    } else {
      origin = this.categoryAxis.getSlot(0);
    }
    animation.origin = new Point$7(origin.x1, origin.y1);
    animation.vertical = !options2.invertAxes;
  };
  return BarChart2;
}(CategoricalChart);
setDefaultOptions(BarChart, {
  animation: {
    type: BAR
  }
});
var Candlestick = function(ChartElement2) {
  function Candlestick2(value2, options2) {
    ChartElement2.call(this, options2);
    this.value = value2;
  }
  if (ChartElement2)
    Candlestick2.__proto__ = ChartElement2;
  Candlestick2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  Candlestick2.prototype.constructor = Candlestick2;
  Candlestick2.prototype.getLabelText = function getLabelText(options2) {
    return this.formatValue(options2.format);
  };
  Candlestick2.prototype.reflow = function reflow(box) {
    var ref2 = this;
    var options2 = ref2.options;
    var value2 = ref2.value;
    var chart = ref2.owner;
    var valueAxis = chart.seriesValueAxis(options2);
    var ocSlot = valueAxis.getSlot(value2.open, value2.close);
    var lhSlot = valueAxis.getSlot(value2.low, value2.high);
    ocSlot.x1 = lhSlot.x1 = box.x1;
    ocSlot.x2 = lhSlot.x2 = box.x2;
    this.realBody = ocSlot;
    var mid = lhSlot.center().x;
    var points2 = [];
    points2.push([[mid, lhSlot.y1], [mid, ocSlot.y1]]);
    points2.push([[mid, ocSlot.y2], [mid, lhSlot.y2]]);
    this.lines = points2;
    this.box = lhSlot.clone().wrap(ocSlot);
    if (!this._rendered) {
      this._rendered = true;
      this.createNote();
    }
    this.reflowNote();
  };
  Candlestick2.prototype.reflowNote = function reflowNote() {
    if (this.note) {
      this.note.reflow(this.box);
    }
  };
  Candlestick2.prototype.createVisual = function createVisual() {
    ChartElement2.prototype.createVisual.call(this);
    this.addAccessibilityAttributesToVisual();
    this._mainVisual = this.mainVisual(this.options);
    this.visual.append(
      this._mainVisual
    );
    this.createOverlay();
  };
  Candlestick2.prototype.mainVisual = function mainVisual(options2) {
    var group2 = new Group$9();
    this.createBody(group2, options2);
    this.createLines(group2, options2);
    return group2;
  };
  Candlestick2.prototype.createBody = function createBody(container, options2) {
    var body = Path$7.fromRect(this.realBody.toRect(), {
      fill: {
        color: this.color,
        opacity: options2.opacity
      },
      stroke: null
    });
    if (options2.border.width > 0) {
      body.options.set("stroke", {
        color: this.getBorderColor(),
        width: options2.border.width,
        dashType: options2.border.dashType,
        opacity: valueOrDefault$1(options2.border.opacity, options2.opacity)
      });
    }
    alignPathToPixel(body);
    container.append(body);
    if (hasGradientOverlay(options2)) {
      container.append(this.createGradientOverlay(body, { baseColor: this.color }, deepExtend({
        end: !options2.vertical ? [0, 1] : void 0
      }, options2.overlay)));
    }
  };
  Candlestick2.prototype.createLines = function createLines(container, options2) {
    this.drawLines(container, options2, this.lines, options2.line);
  };
  Candlestick2.prototype.drawLines = function drawLines(container, options2, lines, lineOptions) {
    if (!lines) {
      return;
    }
    var lineStyle = {
      stroke: {
        color: lineOptions.color || this.color,
        opacity: valueOrDefault$1(lineOptions.opacity, options2.opacity),
        width: lineOptions.width,
        dashType: lineOptions.dashType,
        lineCap: "butt"
      }
    };
    for (var i16 = 0; i16 < lines.length; i16++) {
      var line = Path$7.fromPoints(lines[i16], lineStyle);
      alignPathToPixel(line);
      container.append(line);
    }
  };
  Candlestick2.prototype.getBorderColor = function getBorderColor() {
    var border = this.options.border;
    var borderColor = border.color;
    if (!defined(borderColor)) {
      borderColor = new m$e(this.color).brightness(border._brightness).toHex();
    }
    return borderColor;
  };
  Candlestick2.prototype.createOverlay = function createOverlay() {
    var overlay = Path$7.fromRect(this.box.toRect(), {
      fill: {
        color: WHITE$1,
        opacity: 0
      },
      stroke: null
    });
    this.visual.append(overlay);
  };
  Candlestick2.prototype.createHighlight = function createHighlight() {
    var highlight = this.options.highlight;
    var normalColor = this.color;
    this.color = highlight.color || this.color;
    var overlay = this.mainVisual(
      deepExtend({}, this.options, {
        line: {
          color: this.getBorderColor()
        }
      }, highlight)
    );
    this.color = normalColor;
    return overlay;
  };
  Candlestick2.prototype.highlightVisual = function highlightVisual() {
    return this._mainVisual;
  };
  Candlestick2.prototype.highlightVisualArgs = function highlightVisualArgs() {
    return {
      options: this.options,
      rect: this.box.toRect(),
      visual: this._mainVisual
    };
  };
  Candlestick2.prototype.tooltipAnchor = function tooltipAnchor() {
    var box = this.box;
    var clipBox = this.owner.pane.clipBox() || box;
    return {
      point: new Point$5(box.x2 + TOOLTIP_OFFSET, Math.max(box.y1, clipBox.y1) + TOOLTIP_OFFSET),
      align: {
        horizontal: LEFT,
        vertical: TOP
      }
    };
  };
  Candlestick2.prototype.formatValue = function formatValue(format2) {
    return this.owner.formatPointValue(this, format2);
  };
  Candlestick2.prototype.overlapsBox = function overlapsBox(box) {
    return this.box.overlaps(box);
  };
  Candlestick2.prototype.pointData = function pointData() {
    return {
      dataItem: this.dataItem,
      value: this.value,
      meanPoints: this.meanPoints,
      medianPoints: this.medianPoints,
      whiskerPoints: this.whiskerPoints,
      stackValue: this.stackValue,
      series: this.series
    };
  };
  Candlestick2.prototype.getIndex = function getIndex() {
    return this.categoryIx;
  };
  return Candlestick2;
}(ChartElement);
Candlestick.prototype.createFocusHighlight = Bar.prototype.createFocusHighlight;
setDefaultOptions(Candlestick, {
  vertical: true,
  border: {
    _brightness: 0.8
  },
  line: {
    width: 2
  },
  overlay: {
    gradient: "glass"
  },
  tooltip: {
    format: "<table><tr><th colspan='2'>{4:d}</th></tr><tr><td>Open:</td><td>{0:C}</td></tr><tr><td>High:</td><td>{1:C}</td></tr><tr><td>Low:</td><td>{2:C}</td></tr><tr><td>Close:</td><td>{3:C}</td></tr></table>"
  },
  labels: {
    format: ""
  },
  highlight: {
    opacity: 1,
    border: {
      width: 1,
      opacity: 1
    },
    line: {
      width: 1,
      opacity: 1
    }
  },
  notes: {
    visible: true,
    label: {}
  },
  accessibility: {
    role: CHART_POINT_ROLE,
    className: CHART_POINT_CLASSNAME,
    ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION
  }
});
deepExtend(Candlestick.prototype, PointEventsMixin);
deepExtend(Candlestick.prototype, NoteMixin);
deepExtend(Candlestick.prototype, AccessibilityAttributesMixin);
var CandlestickChart = function(CategoricalChart2) {
  function CandlestickChart2() {
    CategoricalChart2.apply(this, arguments);
  }
  if (CategoricalChart2)
    CandlestickChart2.__proto__ = CategoricalChart2;
  CandlestickChart2.prototype = Object.create(CategoricalChart2 && CategoricalChart2.prototype);
  CandlestickChart2.prototype.constructor = CandlestickChart2;
  CandlestickChart2.prototype.reflowCategories = function reflowCategories(categorySlots) {
    var children = this.children;
    var childrenLength = children.length;
    for (var i16 = 0; i16 < childrenLength; i16++) {
      children[i16].reflow(categorySlots[i16]);
    }
  };
  CandlestickChart2.prototype.addValue = function addValue(data2, fields) {
    var categoryIx = fields.categoryIx;
    var category = fields.category;
    var series = fields.series;
    var seriesIx = fields.seriesIx;
    var ref2 = this;
    var children = ref2.children;
    var options2 = ref2.options;
    var value2 = data2.valueFields;
    var valueParts = this.splitValue(value2);
    var hasValue2 = areNumbers(valueParts);
    var dataItem = series.data[categoryIx];
    var categoryPoints = this.categoryPoints[categoryIx];
    var point2;
    if (!categoryPoints) {
      this.categoryPoints[categoryIx] = categoryPoints = [];
    }
    if (hasValue2) {
      point2 = this.createPoint(data2, fields);
    }
    var cluster = children[categoryIx];
    if (!cluster) {
      cluster = new ClusterLayout({
        vertical: options2.invertAxes,
        gap: options2.gap,
        spacing: options2.spacing,
        rtl: !options2.invertAxes && (this.chartService || {}).rtl
      });
      this.append(cluster);
    }
    if (point2) {
      this.updateRange(value2, fields);
      cluster.append(point2);
      point2.categoryIx = categoryIx;
      point2.category = category;
      point2.series = series;
      point2.seriesIx = seriesIx;
      point2.owner = this;
      point2.dataItem = dataItem;
      point2.noteText = data2.fields.noteText;
    }
    this.points.push(point2);
    categoryPoints.push(point2);
  };
  CandlestickChart2.prototype.pointType = function pointType() {
    return Candlestick;
  };
  CandlestickChart2.prototype.createPoint = function createPoint(data2, fields) {
    var series = fields.series;
    var pointType = this.pointType();
    var value2 = data2.valueFields;
    var pointOptions = deepExtend({}, series);
    var color = data2.fields.color || series.color;
    pointOptions = this.evalPointOptions(pointOptions, value2, fields);
    if (series.type === CANDLESTICK || series.type === OHLC) {
      if (value2.open > value2.close) {
        color = data2.fields.downColor || series.downColor || series.color;
      }
    }
    if (isFunction$1(series.color)) {
      color = pointOptions.color;
    }
    pointOptions.vertical = !this.options.invertAxes;
    var point2 = new pointType(value2, pointOptions);
    point2.color = color;
    return point2;
  };
  CandlestickChart2.prototype.splitValue = function splitValue(value2) {
    return [value2.low, value2.open, value2.close, value2.high];
  };
  CandlestickChart2.prototype.updateRange = function updateRange(value2, fields) {
    var axisName = fields.series.axis;
    var parts = this.splitValue(value2);
    var axisRange = this.valueAxisRanges[axisName] || { min: MAX_VALUE, max: MIN_VALUE };
    this.valueAxisRanges[axisName] = {
      min: Math.min.apply(Math, parts.concat([axisRange.min])),
      max: Math.max.apply(Math, parts.concat([axisRange.max]))
    };
  };
  CandlestickChart2.prototype.formatPointValue = function formatPointValue(point2, format2) {
    var value2 = point2.value;
    return this.chartService.format.auto(
      format2,
      value2.open,
      value2.high,
      value2.low,
      value2.close,
      point2.category
    );
  };
  CandlestickChart2.prototype.animationPoints = function animationPoints() {
    return this.points;
  };
  return CandlestickChart2;
}(CategoricalChart);
deepExtend(CandlestickChart.prototype, ClipAnimationMixin);
var BoxPlot = function(Candlestick2) {
  function BoxPlot2(value2, options2) {
    Candlestick2.call(this, value2, options2);
    this.createNote();
  }
  if (Candlestick2)
    BoxPlot2.__proto__ = Candlestick2;
  BoxPlot2.prototype = Object.create(Candlestick2 && Candlestick2.prototype);
  BoxPlot2.prototype.constructor = BoxPlot2;
  BoxPlot2.prototype.reflow = function reflow(box) {
    var ref2 = this;
    var options2 = ref2.options;
    var value2 = ref2.value;
    var chart = ref2.owner;
    var valueAxis = chart.seriesValueAxis(options2);
    var whiskerSlot, boxSlot;
    this.boxSlot = boxSlot = valueAxis.getSlot(value2.q1, value2.q3);
    this.realBody = boxSlot;
    this.reflowBoxSlot(box);
    this.whiskerSlot = whiskerSlot = valueAxis.getSlot(value2.lower, value2.upper);
    this.reflowWhiskerSlot(box);
    var medianSlot = valueAxis.getSlot(value2.median);
    if (value2.mean) {
      var meanSlot = valueAxis.getSlot(value2.mean);
      this.meanPoints = this.calcMeanPoints(box, meanSlot);
    }
    this.whiskerPoints = this.calcWhiskerPoints(boxSlot, whiskerSlot);
    this.medianPoints = this.calcMedianPoints(box, medianSlot);
    this.box = whiskerSlot.clone().wrap(boxSlot);
    this.reflowNote();
  };
  BoxPlot2.prototype.reflowBoxSlot = function reflowBoxSlot(box) {
    this.boxSlot.x1 = box.x1;
    this.boxSlot.x2 = box.x2;
  };
  BoxPlot2.prototype.reflowWhiskerSlot = function reflowWhiskerSlot(box) {
    this.whiskerSlot.x1 = box.x1;
    this.whiskerSlot.x2 = box.x2;
  };
  BoxPlot2.prototype.calcMeanPoints = function calcMeanPoints(box, meanSlot) {
    return [
      [[box.x1, meanSlot.y1], [box.x2, meanSlot.y1]]
    ];
  };
  BoxPlot2.prototype.calcWhiskerPoints = function calcWhiskerPoints(boxSlot, whiskerSlot) {
    var mid = whiskerSlot.center().x;
    return [[
      [mid - 5, whiskerSlot.y1],
      [mid + 5, whiskerSlot.y1],
      [mid, whiskerSlot.y1],
      [mid, boxSlot.y1]
    ], [
      [mid - 5, whiskerSlot.y2],
      [mid + 5, whiskerSlot.y2],
      [mid, whiskerSlot.y2],
      [mid, boxSlot.y2]
    ]];
  };
  BoxPlot2.prototype.calcMedianPoints = function calcMedianPoints(box, medianSlot) {
    return [
      [[box.x1, medianSlot.y1], [box.x2, medianSlot.y1]]
    ];
  };
  BoxPlot2.prototype.renderOutliers = function renderOutliers(options2) {
    var this$1$1 = this;
    var value2 = this.value;
    var outliers = value2.outliers || [];
    var outerFence = Math.abs(value2.q3 - value2.q1) * 3;
    var elements = [];
    var markers = options2.markers || {};
    for (var i16 = 0; i16 < outliers.length; i16++) {
      var outlierValue = outliers[i16];
      if (outlierValue < value2.q3 + outerFence && outlierValue > value2.q1 - outerFence) {
        markers = options2.outliers;
      } else {
        markers = options2.extremes;
      }
      var markersBorder = deepExtend({}, markers.border);
      if (!defined(markersBorder.color)) {
        if (defined(this$1$1.color)) {
          markersBorder.color = this$1$1.color;
        } else {
          markersBorder.color = new m$e(markers.background).brightness(BORDER_BRIGHTNESS).toHex();
        }
      }
      var shape = new ShapeElement({
        type: markers.type,
        width: markers.size,
        height: markers.size,
        rotation: markers.rotation,
        background: markers.background,
        border: markersBorder,
        opacity: markers.opacity
      });
      shape.value = outlierValue;
      elements.push(shape);
    }
    this.reflowOutliers(elements);
    return elements;
  };
  BoxPlot2.prototype.reflowOutliers = function reflowOutliers(outliers) {
    var this$1$1 = this;
    var valueAxis = this.owner.seriesValueAxis(this.options);
    var center = this.box.center();
    for (var i16 = 0; i16 < outliers.length; i16++) {
      var outlierValue = outliers[i16].value;
      var markerBox = valueAxis.getSlot(outlierValue);
      if (this$1$1.options.vertical) {
        markerBox.move(center.x);
      } else {
        markerBox.move(void 0, center.y);
      }
      this$1$1.box = this$1$1.box.wrap(markerBox);
      outliers[i16].reflow(markerBox);
    }
  };
  BoxPlot2.prototype.mainVisual = function mainVisual(options2) {
    var group2 = Candlestick2.prototype.mainVisual.call(this, options2);
    var outliers = this.renderOutliers(options2);
    for (var i16 = 0; i16 < outliers.length; i16++) {
      var element = outliers[i16].getElement();
      if (element) {
        group2.append(element);
      }
    }
    return group2;
  };
  BoxPlot2.prototype.createLines = function createLines(container, options2) {
    this.drawLines(container, options2, this.whiskerPoints, options2.whiskers);
    this.drawLines(container, options2, this.medianPoints, options2.median);
    this.drawLines(container, options2, this.meanPoints, options2.mean);
  };
  BoxPlot2.prototype.getBorderColor = function getBorderColor() {
    if ((this.options.border || {}).color) {
      return this.options.border.color;
    }
    if (this.color) {
      return this.color;
    }
    return Candlestick2.prototype.getBorderColor.call(this);
  };
  return BoxPlot2;
}(Candlestick);
setDefaultOptions(BoxPlot, {
  border: {
    _brightness: 0.8
  },
  line: {
    width: 2
  },
  median: {
    color: "#f6f6f6"
  },
  mean: {
    width: 2,
    dashType: "dash",
    color: "#f6f6f6"
  },
  overlay: {
    gradient: "glass"
  },
  tooltip: {
    format: "<table><tr><th colspan='2'>{6:d}</th></tr><tr><td>Lower:</td><td>{0:C}</td></tr><tr><td>Q1:</td><td>{1:C}</td></tr><tr><td>Median:</td><td>{2:C}</td></tr><tr><td>Mean:</td><td>{5:C}</td></tr><tr><td>Q3:</td><td>{3:C}</td></tr><tr><td>Upper:</td><td>{4:C}</td></tr></table>"
  },
  highlight: {
    opacity: 1,
    border: {
      width: 1,
      opacity: 1
    },
    line: {
      width: 1,
      opacity: 1
    }
  },
  notes: {
    visible: true,
    label: {}
  },
  outliers: {
    visible: true,
    size: LINE_MARKER_SIZE,
    type: CROSS,
    background: WHITE$1,
    border: {
      width: 2,
      opacity: 1
    },
    opacity: 0
  },
  extremes: {
    visible: true,
    size: LINE_MARKER_SIZE,
    type: CIRCLE,
    background: WHITE$1,
    border: {
      width: 2,
      opacity: 1
    },
    opacity: 0
  }
});
deepExtend(BoxPlot.prototype, PointEventsMixin);
var VerticalBoxPlot = function(BoxPlot2) {
  function VerticalBoxPlot2() {
    BoxPlot2.apply(this, arguments);
  }
  if (BoxPlot2)
    VerticalBoxPlot2.__proto__ = BoxPlot2;
  VerticalBoxPlot2.prototype = Object.create(BoxPlot2 && BoxPlot2.prototype);
  VerticalBoxPlot2.prototype.constructor = VerticalBoxPlot2;
  VerticalBoxPlot2.prototype.reflowBoxSlot = function reflowBoxSlot(box) {
    this.boxSlot.y1 = box.y1;
    this.boxSlot.y2 = box.y2;
  };
  VerticalBoxPlot2.prototype.reflowWhiskerSlot = function reflowWhiskerSlot(box) {
    this.whiskerSlot.y1 = box.y1;
    this.whiskerSlot.y2 = box.y2;
  };
  VerticalBoxPlot2.prototype.calcMeanPoints = function calcMeanPoints(box, meanSlot) {
    return [
      [[meanSlot.x1, box.y1], [meanSlot.x1, box.y2]]
    ];
  };
  VerticalBoxPlot2.prototype.calcWhiskerPoints = function calcWhiskerPoints(boxSlot, whiskerSlot) {
    var mid = whiskerSlot.center().y;
    return [[
      [whiskerSlot.x1, mid - 5],
      [whiskerSlot.x1, mid + 5],
      [whiskerSlot.x1, mid],
      [boxSlot.x1, mid]
    ], [
      [whiskerSlot.x2, mid - 5],
      [whiskerSlot.x2, mid + 5],
      [whiskerSlot.x2, mid],
      [boxSlot.x2, mid]
    ]];
  };
  VerticalBoxPlot2.prototype.calcMedianPoints = function calcMedianPoints(box, medianSlot) {
    return [
      [[medianSlot.x1, box.y1], [medianSlot.x1, box.y2]]
    ];
  };
  return VerticalBoxPlot2;
}(BoxPlot);
var BoxPlotChart = function(CandlestickChart2) {
  function BoxPlotChart2() {
    CandlestickChart2.apply(this, arguments);
  }
  if (CandlestickChart2)
    BoxPlotChart2.__proto__ = CandlestickChart2;
  BoxPlotChart2.prototype = Object.create(CandlestickChart2 && CandlestickChart2.prototype);
  BoxPlotChart2.prototype.constructor = BoxPlotChart2;
  BoxPlotChart2.prototype.addValue = function addValue(data2, fields) {
    var categoryIx = fields.categoryIx;
    var category = fields.category;
    var series = fields.series;
    var seriesIx = fields.seriesIx;
    var ref2 = this;
    var children = ref2.children;
    var options2 = ref2.options;
    var value2 = data2.valueFields;
    var valueParts = this.splitValue(value2);
    var hasValue2 = areNumbers(valueParts);
    var dataItem = series.data[categoryIx];
    var categoryPoints = this.categoryPoints[categoryIx];
    var point2;
    if (!categoryPoints) {
      this.categoryPoints[categoryIx] = categoryPoints = [];
    }
    if (hasValue2) {
      point2 = this.createPoint(data2, fields);
    }
    var cluster = children[categoryIx];
    if (!cluster) {
      cluster = new ClusterLayout({
        vertical: options2.invertAxes,
        gap: options2.gap,
        spacing: options2.spacing,
        rtl: !options2.invertAxes && (this.chartService || {}).rtl
      });
      this.append(cluster);
    }
    if (point2) {
      this.updateRange(value2, fields);
      cluster.append(point2);
      point2.categoryIx = categoryIx;
      point2.category = category;
      point2.series = series;
      point2.seriesIx = seriesIx;
      point2.owner = this;
      point2.dataItem = dataItem;
    }
    this.points.push(point2);
    categoryPoints.push(point2);
  };
  BoxPlotChart2.prototype.pointType = function pointType() {
    if (this.options.invertAxes) {
      return VerticalBoxPlot;
    }
    return BoxPlot;
  };
  BoxPlotChart2.prototype.splitValue = function splitValue(value2) {
    return [
      value2.lower,
      value2.q1,
      value2.median,
      value2.q3,
      value2.upper
    ];
  };
  BoxPlotChart2.prototype.updateRange = function updateRange(value2, fields) {
    var axisName = fields.series.axis;
    var parts = this.splitValue(value2).concat(this.filterOutliers(value2.outliers));
    if (defined(value2.mean)) {
      parts = parts.concat(value2.mean);
    }
    var axisRange = this.valueAxisRanges[axisName] || { min: MAX_VALUE, max: MIN_VALUE };
    this.valueAxisRanges[axisName] = {
      min: Math.min.apply(Math, parts.concat([axisRange.min])),
      max: Math.max.apply(Math, parts.concat([axisRange.max]))
    };
  };
  BoxPlotChart2.prototype.formatPointValue = function formatPointValue(point2, format2) {
    var value2 = point2.value;
    return this.chartService.format.auto(
      format2,
      value2.lower,
      value2.q1,
      value2.median,
      value2.q3,
      value2.upper,
      value2.mean,
      point2.category
    );
  };
  BoxPlotChart2.prototype.filterOutliers = function filterOutliers(items) {
    var length = (items || []).length;
    var result = [];
    for (var i16 = 0; i16 < length; i16++) {
      var item = items[i16];
      if (defined(item) && item !== null) {
        result.push(item);
      }
    }
    return result;
  };
  BoxPlotChart2.prototype.supportsPointInactiveOpacity = function supportsPointInactiveOpacity() {
    return false;
  };
  return BoxPlotChart2;
}(CandlestickChart);
var ScatterErrorBar = function(ErrorBarBase2) {
  function ScatterErrorBar2() {
    ErrorBarBase2.apply(this, arguments);
  }
  if (ErrorBarBase2)
    ScatterErrorBar2.__proto__ = ErrorBarBase2;
  ScatterErrorBar2.prototype = Object.create(ErrorBarBase2 && ErrorBarBase2.prototype);
  ScatterErrorBar2.prototype.constructor = ScatterErrorBar2;
  ScatterErrorBar2.prototype.getAxis = function getAxis() {
    var axes = this.chart.seriesAxes(this.series);
    var axis = this.isVertical ? axes.y : axes.x;
    return axis;
  };
  return ScatterErrorBar2;
}(ErrorBarBase);
var ScatterChart = function(ChartElement2) {
  function ScatterChart2(plotArea, options2) {
    ChartElement2.call(this, options2);
    this.plotArea = plotArea;
    this.chartService = plotArea.chartService;
    this._initFields();
    this.render();
  }
  if (ChartElement2)
    ScatterChart2.__proto__ = ChartElement2;
  ScatterChart2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  ScatterChart2.prototype.constructor = ScatterChart2;
  ScatterChart2.prototype._initFields = function _initFields() {
    this.xAxisRanges = {};
    this.yAxisRanges = {};
    this.points = [];
    this.seriesPoints = [];
    this.seriesOptions = [];
    this._evalSeries = [];
  };
  ScatterChart2.prototype.render = function render() {
    this.traverseDataPoints(this.addValue.bind(this));
  };
  ScatterChart2.prototype.addErrorBar = function addErrorBar(point2, field, fields) {
    var value2 = point2.value[field];
    var valueErrorField = field + "Value";
    var lowField = field + "ErrorLow";
    var highField = field + "ErrorHigh";
    var seriesIx = fields.seriesIx;
    var series = fields.series;
    var errorBars = point2.options.errorBars;
    var lowValue = fields[lowField];
    var highValue = fields[highField];
    if (isNumber(value2)) {
      var errorRange;
      if (isNumber(lowValue) && isNumber(highValue)) {
        errorRange = { low: lowValue, high: highValue };
      }
      if (errorBars && defined(errorBars[valueErrorField])) {
        this.seriesErrorRanges = this.seriesErrorRanges || { x: [], y: [] };
        this.seriesErrorRanges[field][seriesIx] = this.seriesErrorRanges[field][seriesIx] || new ErrorRangeCalculator(errorBars[valueErrorField], series, field);
        errorRange = this.seriesErrorRanges[field][seriesIx].getErrorRange(value2, errorBars[valueErrorField]);
      }
      if (errorRange) {
        this.addPointErrorBar(errorRange, point2, field);
      }
    }
  };
  ScatterChart2.prototype.addPointErrorBar = function addPointErrorBar(errorRange, point2, field) {
    var low = errorRange.low;
    var high = errorRange.high;
    var series = point2.series;
    var options2 = point2.options.errorBars;
    var isVertical = field === Y$7;
    var item = {};
    point2[field + "Low"] = low;
    point2[field + "High"] = high;
    point2.errorBars = point2.errorBars || [];
    var errorBar = new ScatterErrorBar(low, high, isVertical, this, series, options2);
    point2.errorBars.push(errorBar);
    point2.append(errorBar);
    item[field] = low;
    this.updateRange(item, series);
    item[field] = high;
    this.updateRange(item, series);
  };
  ScatterChart2.prototype.addValue = function addValue(value2, fields) {
    var x3 = value2.x;
    var y4 = value2.y;
    var seriesIx = fields.seriesIx;
    var series = this.options.series[seriesIx];
    var missingValues = this.seriesMissingValues(series);
    var seriesPoints = this.seriesPoints[seriesIx];
    var pointValue = value2;
    if (!(hasValue$1(x3) && hasValue$1(y4))) {
      pointValue = this.createMissingValue(pointValue, missingValues);
    }
    var point2;
    if (pointValue) {
      point2 = this.createPoint(pointValue, fields);
      if (point2) {
        Object.assign(point2, fields);
        this.addErrorBar(point2, X$4, fields);
        this.addErrorBar(point2, Y$7, fields);
      }
      this.updateRange(pointValue, fields.series);
    }
    this.points.push(point2);
    seriesPoints.push(point2);
  };
  ScatterChart2.prototype.seriesMissingValues = function seriesMissingValues2(series) {
    return series.missingValues;
  };
  ScatterChart2.prototype.createMissingValue = function createMissingValue() {
  };
  ScatterChart2.prototype.updateRange = function updateRange(value2, series) {
    var intlService = this.chartService.intl;
    var xAxisName = series.xAxis;
    var yAxisName = series.yAxis;
    var x3 = value2.x;
    var y4 = value2.y;
    var xAxisRange = this.xAxisRanges[xAxisName];
    var yAxisRange = this.yAxisRanges[yAxisName];
    if (hasValue$1(x3)) {
      xAxisRange = this.xAxisRanges[xAxisName] = xAxisRange || { min: MAX_VALUE, max: MIN_VALUE };
      if (isString$2(x3)) {
        x3 = parseDate(intlService, x3);
      }
      xAxisRange.min = Math.min(xAxisRange.min, x3);
      xAxisRange.max = Math.max(xAxisRange.max, x3);
    }
    if (hasValue$1(y4)) {
      yAxisRange = this.yAxisRanges[yAxisName] = yAxisRange || { min: MAX_VALUE, max: MIN_VALUE };
      if (isString$2(y4)) {
        y4 = parseDate(intlService, y4);
      }
      yAxisRange.min = Math.min(yAxisRange.min, y4);
      yAxisRange.max = Math.max(yAxisRange.max, y4);
    }
  };
  ScatterChart2.prototype.evalPointOptions = function evalPointOptions(options2, value2, fields) {
    var series = fields.series;
    var seriesIx = fields.seriesIx;
    var state = {
      defaults: series._defaults,
      excluded: [
        "data",
        "tooltip",
        "content",
        "template",
        "visual",
        "toggle",
        "_outOfRangeMinPoint",
        "_outOfRangeMaxPoint",
        "drilldownSeriesFactory",
        "ariaTemplate",
        "ariaContent"
      ]
    };
    var doEval = this._evalSeries[seriesIx];
    if (!defined(doEval)) {
      this._evalSeries[seriesIx] = doEval = evalOptions(options2, {}, state, true);
    }
    var pointOptions = options2;
    if (doEval) {
      pointOptions = deepExtend({}, options2);
      evalOptions(pointOptions, {
        value: value2,
        series,
        dataItem: fields.dataItem
      }, state);
    }
    return pointOptions;
  };
  ScatterChart2.prototype.pointType = function pointType() {
    return LinePoint;
  };
  ScatterChart2.prototype.pointOptions = function pointOptions(series, seriesIx) {
    var options2 = this.seriesOptions[seriesIx];
    if (!options2) {
      var defaults = this.pointType().prototype.defaults;
      this.seriesOptions[seriesIx] = options2 = deepExtend({}, defaults, {
        markers: {
          opacity: series.opacity
        },
        tooltip: {
          format: this.options.tooltip.format
        },
        labels: {
          format: this.options.labels.format
        }
      }, series);
    }
    return options2;
  };
  ScatterChart2.prototype.createPoint = function createPoint(value2, fields) {
    var series = fields.series;
    var pointOptions = this.pointOptions(series, fields.seriesIx);
    var color = fields.color || series.color;
    pointOptions = this.evalPointOptions(pointOptions, value2, fields);
    if (isFunction$1(series.color)) {
      color = pointOptions.color;
    }
    var point2 = new LinePoint(value2, pointOptions);
    point2.color = color;
    this.append(point2);
    return point2;
  };
  ScatterChart2.prototype.seriesAxes = function seriesAxes(series) {
    var xAxisName = series.xAxis;
    var yAxisName = series.yAxis;
    var plotArea = this.plotArea;
    var xAxis = xAxisName ? plotArea.namedXAxes[xAxisName] : plotArea.axisX;
    var yAxis = yAxisName ? plotArea.namedYAxes[yAxisName] : plotArea.axisY;
    if (!xAxis) {
      throw new Error("Unable to locate X axis with name " + xAxisName);
    }
    if (!yAxis) {
      throw new Error("Unable to locate Y axis with name " + yAxisName);
    }
    return {
      x: xAxis,
      y: yAxis
    };
  };
  ScatterChart2.prototype.reflow = function reflow(targetBox) {
    var this$1$1 = this;
    var chartPoints = this.points;
    var limit = !this.options.clip;
    var pointIx = 0;
    this.traverseDataPoints(function(value2, fields) {
      var point2 = chartPoints[pointIx++];
      var seriesAxes = this$1$1.seriesAxes(fields.series);
      var slotX = seriesAxes.x.getSlot(value2.x, value2.x, limit);
      var slotY = seriesAxes.y.getSlot(value2.y, value2.y, limit);
      if (point2) {
        if (slotX && slotY) {
          var pointSlot = this$1$1.pointSlot(slotX, slotY);
          point2.reflow(pointSlot);
        } else {
          point2.visible = false;
        }
      }
    });
    this.box = targetBox;
  };
  ScatterChart2.prototype.pointSlot = function pointSlot(slotX, slotY) {
    return new Box(slotX.x1, slotY.y1, slotX.x2, slotY.y2);
  };
  ScatterChart2.prototype.traverseDataPoints = function traverseDataPoints(callback) {
    var this$1$1 = this;
    var ref2 = this;
    var series = ref2.options.series;
    var seriesPoints = ref2.seriesPoints;
    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {
      var currentSeries = series[seriesIx];
      var currentSeriesPoints = seriesPoints[seriesIx];
      if (!currentSeriesPoints) {
        seriesPoints[seriesIx] = [];
      }
      for (var pointIx = 0; pointIx < currentSeries.data.length; pointIx++) {
        var ref$1 = this$1$1.plotArea.bindPoint(currentSeries, pointIx);
        var value2 = ref$1.valueFields;
        var fields = ref$1.fields;
        callback(value2, deepExtend({
          pointIx,
          series: currentSeries,
          seriesIx,
          dataItem: currentSeries.data[pointIx],
          owner: this$1$1
        }, fields));
      }
    }
  };
  ScatterChart2.prototype.formatPointValue = function formatPointValue(point2, format2) {
    var value2 = point2.value;
    return this.chartService.format.auto(format2, value2.x, value2.y);
  };
  ScatterChart2.prototype.animationPoints = function animationPoints() {
    var points2 = this.points;
    var result = [];
    for (var idx = 0; idx < points2.length; idx++) {
      result.push((points2[idx] || {}).marker);
    }
    return result;
  };
  return ScatterChart2;
}(ChartElement);
setDefaultOptions(ScatterChart, {
  series: [],
  tooltip: {
    format: "{0}, {1}"
  },
  labels: {
    format: "{0}, {1}"
  },
  clip: true
});
deepExtend(ScatterChart.prototype, ClipAnimationMixin);
var Bubble = function(LinePoint2) {
  function Bubble2(value2, options2) {
    LinePoint2.call(this, value2, options2);
    this.category = value2.category;
  }
  if (LinePoint2)
    Bubble2.__proto__ = LinePoint2;
  Bubble2.prototype = Object.create(LinePoint2 && LinePoint2.prototype);
  Bubble2.prototype.constructor = Bubble2;
  Bubble2.prototype.createHighlight = function createHighlight() {
    var highlight = this.options.highlight;
    var border = highlight.border;
    var markers = this.options.markers;
    var center = this.box.center();
    var radius = (markers.size + markers.border.width + border.width) / 2;
    var highlightGroup = new Group$9();
    var shadow = new Circle$3(new geomCircle([center.x, center.y + radius / 5 + border.width / 2], radius + border.width / 2), {
      stroke: {
        color: "none"
      },
      fill: this.createGradient({
        gradient: "bubbleShadow",
        color: markers.background,
        stops: [{
          offset: 0,
          color: markers.background,
          opacity: 0.3
        }, {
          offset: 1,
          color: markers.background,
          opacity: 0
        }]
      })
    });
    var overlay = new Circle$3(new geomCircle([center.x, center.y], radius), {
      stroke: {
        color: border.color || new m$e(markers.background).brightness(BORDER_BRIGHTNESS).toHex(),
        width: border.width,
        opacity: border.opacity
      },
      fill: {
        color: markers.background,
        opacity: highlight.opacity
      }
    });
    highlightGroup.append(shadow, overlay);
    return highlightGroup;
  };
  Bubble2.prototype.createFocusHighlight = function createFocusHighlight(style2) {
    var highlightOptions2 = this.options.accessibility.highlight;
    var markers = this.options.markers;
    var center = this.box.center();
    var radius = (markers.size + markers.border.width) / 2 + highlightOptions2.border.width / 2;
    var highlight = new Circle$3(new geomCircle([center.x, center.y], radius), style2);
    return highlight;
  };
  return Bubble2;
}(LinePoint);
Bubble.prototype.defaults = deepExtend({}, Bubble.prototype.defaults, {
  labels: {
    position: CENTER
  },
  highlight: {
    opacity: 1,
    border: {
      color: "#fff",
      width: 2,
      opacity: 1
    }
  }
});
Bubble.prototype.defaults.highlight.zIndex = void 0;
var BubbleChart = function(ScatterChart2) {
  function BubbleChart2() {
    ScatterChart2.apply(this, arguments);
  }
  if (ScatterChart2)
    BubbleChart2.__proto__ = ScatterChart2;
  BubbleChart2.prototype = Object.create(ScatterChart2 && ScatterChart2.prototype);
  BubbleChart2.prototype.constructor = BubbleChart2;
  BubbleChart2.prototype._initFields = function _initFields() {
    this._maxSize = MIN_VALUE;
    ScatterChart2.prototype._initFields.call(this);
  };
  BubbleChart2.prototype.addValue = function addValue(value2, fields) {
    if (value2.size !== null && (value2.size > 0 || value2.size < 0 && fields.series.negativeValues.visible)) {
      this._maxSize = Math.max(this._maxSize, Math.abs(value2.size));
      ScatterChart2.prototype.addValue.call(this, value2, fields);
    } else {
      this.points.push(null);
      this.seriesPoints[fields.seriesIx].push(null);
    }
  };
  BubbleChart2.prototype.reflow = function reflow(box) {
    this.updateBubblesSize(box);
    ScatterChart2.prototype.reflow.call(this, box);
  };
  BubbleChart2.prototype.pointType = function pointType() {
    return Bubble;
  };
  BubbleChart2.prototype.createPoint = function createPoint(value2, fields) {
    var series = fields.series;
    var pointsCount = series.data.length;
    var delay = fields.pointIx * (INITIAL_ANIMATION_DURATION / pointsCount);
    var animationOptions = {
      delay,
      duration: INITIAL_ANIMATION_DURATION - delay,
      type: BUBBLE
    };
    var color = fields.color || series.color;
    if (value2.size < 0 && series.negativeValues.visible) {
      color = valueOrDefault$1(
        series.negativeValues.color,
        color
      );
    }
    var pointOptions = deepExtend({
      labels: {
        animation: {
          delay,
          duration: INITIAL_ANIMATION_DURATION - delay
        }
      }
    }, this.pointOptions(series, fields.seriesIx), {
      markers: {
        type: CIRCLE,
        border: series.border,
        opacity: series.opacity,
        animation: animationOptions
      }
    });
    pointOptions = this.evalPointOptions(pointOptions, value2, fields);
    if (isFunction$1(series.color)) {
      color = pointOptions.color;
    }
    pointOptions.markers.background = color;
    var point2 = new Bubble(value2, pointOptions);
    point2.color = color;
    this.append(point2);
    return point2;
  };
  BubbleChart2.prototype.updateBubblesSize = function updateBubblesSize(box) {
    var this$1$1 = this;
    var ref2 = this;
    var series = ref2.options.series;
    var boxSize = Math.min(box.width(), box.height());
    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {
      var currentSeries = series[seriesIx];
      var seriesPoints = this$1$1.seriesPoints[seriesIx];
      var minSize = currentSeries.minSize || Math.max(boxSize * 0.02, 10);
      var maxSize = currentSeries.maxSize || boxSize * 0.2;
      var minR = minSize / 2;
      var maxR = maxSize / 2;
      var minArea = Math.PI * minR * minR;
      var maxArea = Math.PI * maxR * maxR;
      var areaRange = maxArea - minArea;
      var areaRatio = areaRange / this$1$1._maxSize;
      for (var pointIx = 0; pointIx < seriesPoints.length; pointIx++) {
        var point2 = seriesPoints[pointIx];
        if (point2) {
          var area = Math.abs(point2.value.size) * areaRatio;
          var radius = Math.sqrt((minArea + area) / Math.PI);
          var baseZIndex = valueOrDefault$1(point2.options.zIndex, 0);
          var zIndex2 = baseZIndex + (1 - radius / maxR);
          deepExtend(point2.options, {
            zIndex: zIndex2,
            markers: {
              size: radius * 2,
              zIndex: zIndex2
            },
            labels: {
              zIndex: zIndex2 + 1
            }
          });
        }
      }
    }
  };
  BubbleChart2.prototype.formatPointValue = function formatPointValue(point2, format2) {
    var value2 = point2.value;
    return this.chartService.format.auto(format2, value2.x, value2.y, value2.size, point2.category);
  };
  BubbleChart2.prototype.createAnimation = function createAnimation() {
  };
  BubbleChart2.prototype.createVisual = function createVisual() {
  };
  return BubbleChart2;
}(ScatterChart);
setDefaultOptions(BubbleChart, {
  tooltip: {
    format: "{3}"
  },
  labels: {
    format: "{3}"
  }
});
var Target = function(ShapeElement2) {
  function Target2() {
    ShapeElement2.apply(this, arguments);
  }
  if (ShapeElement2)
    Target2.__proto__ = ShapeElement2;
  Target2.prototype = Object.create(ShapeElement2 && ShapeElement2.prototype);
  Target2.prototype.constructor = Target2;
  return Target2;
}(ShapeElement);
deepExtend(Target.prototype, PointEventsMixin);
var Bullet = function(ChartElement2) {
  function Bullet2(value2, options2) {
    ChartElement2.call(this, options2);
    this.aboveAxis = this.options.aboveAxis;
    this.color = options2.color || WHITE$1;
    this.value = value2;
  }
  if (ChartElement2)
    Bullet2.__proto__ = ChartElement2;
  Bullet2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  Bullet2.prototype.constructor = Bullet2;
  Bullet2.prototype.render = function render() {
    var options2 = this.options;
    if (!this._rendered) {
      this._rendered = true;
      if (defined(this.value.target)) {
        this.target = new Target({
          type: options2.target.shape,
          background: options2.target.color || this.color,
          opacity: options2.opacity,
          zIndex: options2.zIndex,
          border: options2.target.border,
          vAlign: TOP,
          align: RIGHT
        });
        this.target.value = this.value;
        this.target.dataItem = this.dataItem;
        this.target.series = this.series;
        this.append(this.target);
      }
      this.createLabel();
      this.createNote();
    }
  };
  Bullet2.prototype.createLabel = function createLabel() {
    var options2 = this.options;
    var labels = options2.labels;
    if (labels.visible) {
      this.label = this.createLabelElement(labels);
      this.append(this.label);
    }
  };
  Bullet2.prototype.createLabelElement = function createLabelElement(options2) {
    return new BarLabel(
      this.getLabelText(options2),
      options2,
      this.pointData()
    );
  };
  Bullet2.prototype.getLabelText = function getLabelText(options2) {
    var labelTemplate = getTemplate$1(options2);
    if (labelTemplate) {
      return labelTemplate(this.pointData());
    }
    return this.formatValue(options2.format);
  };
  Bullet2.prototype.reflow = function reflow(box) {
    this.render();
    var ref2 = this;
    var options2 = ref2.options;
    var target = ref2.target;
    var chart = ref2.owner;
    var invertAxes = options2.invertAxes;
    var valueAxis = chart.seriesValueAxis(this.options);
    var categorySlot = chart.categorySlot(chart.categoryAxis, options2.categoryIx, valueAxis);
    var targetValueSlot = valueAxis.getSlot(this.value.target);
    var targetSlotX = invertAxes ? targetValueSlot : categorySlot;
    var targetSlotY = invertAxes ? categorySlot : targetValueSlot;
    if (target) {
      var targetSlot = new Box(
        targetSlotX.x1,
        targetSlotY.y1,
        targetSlotX.x2,
        targetSlotY.y2
      );
      target.options.height = invertAxes ? targetSlot.height() : options2.target.line.width;
      target.options.width = invertAxes ? options2.target.line.width : targetSlot.width();
      target.reflow(targetSlot);
    }
    var label = this.label;
    if (label) {
      label.options.aboveAxis = this.aboveAxis;
      label.reflow(box);
    }
    if (this.note) {
      this.note.reflow(box);
    }
    this.box = box;
  };
  Bullet2.prototype.createVisual = function createVisual() {
    ChartElement2.prototype.createVisual.call(this);
    this.addAccessibilityAttributesToVisual();
    var options2 = this.options;
    var body = Path$7.fromRect(this.box.toRect(), {
      fill: {
        color: this.color,
        opacity: options2.opacity
      },
      stroke: null
    });
    if (options2.border.width > 0) {
      body.options.set("stroke", {
        color: options2.border.color || this.color,
        width: options2.border.width,
        dashType: options2.border.dashType,
        opacity: valueOrDefault$1(options2.border.opacity, options2.opacity)
      });
    }
    this.bodyVisual = body;
    alignPathToPixel(body);
    this.visual.append(body);
  };
  Bullet2.prototype.createAnimation = function createAnimation() {
    if (this.bodyVisual) {
      this.animation = Animation$2.create(
        this.bodyVisual,
        this.options.animation
      );
    }
  };
  Bullet2.prototype.createHighlight = function createHighlight(style2) {
    return Path$7.fromRect(this.box.toRect(), style2);
  };
  Bullet2.prototype.highlightVisual = function highlightVisual() {
    return this.bodyVisual;
  };
  Bullet2.prototype.highlightVisualArgs = function highlightVisualArgs() {
    return {
      rect: this.box.toRect(),
      visual: this.bodyVisual,
      options: this.options
    };
  };
  Bullet2.prototype.formatValue = function formatValue(format2) {
    return this.owner.formatPointValue(this, format2);
  };
  Bullet2.prototype.pointData = function pointData() {
    return {
      dataItem: this.dataItem,
      category: this.category,
      value: this.value,
      series: this.series
    };
  };
  Bullet2.prototype.overlapsBox = function overlapsBox(box) {
    return this.box.overlaps(box);
  };
  Bullet2.prototype.getIndex = function getIndex() {
    return this.categoryIx;
  };
  return Bullet2;
}(ChartElement);
Bullet.prototype.tooltipAnchor = Bar.prototype.tooltipAnchor;
Bullet.prototype.createFocusHighlight = Bar.prototype.createFocusHighlight;
setDefaultOptions(Bullet, {
  border: {
    width: 1
  },
  vertical: false,
  opacity: 1,
  target: {
    shape: "",
    border: {
      width: 0,
      color: "green"
    },
    line: {
      width: 2
    }
  },
  labels: {
    visible: false
  },
  tooltip: {
    format: "Current: {0}<br />Target: {1}"
  },
  notes: {
    label: {}
  },
  accessibility: {
    role: CHART_POINT_ROLE,
    className: CHART_POINT_CLASSNAME,
    ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION
  }
});
deepExtend(Bullet.prototype, PointEventsMixin);
deepExtend(Bullet.prototype, NoteMixin);
deepExtend(Bullet.prototype, AccessibilityAttributesMixin);
var BulletChart = function(CategoricalChart2) {
  function BulletChart2(plotArea, options2) {
    wrapData(options2);
    CategoricalChart2.call(this, plotArea, options2);
  }
  if (CategoricalChart2)
    BulletChart2.__proto__ = CategoricalChart2;
  BulletChart2.prototype = Object.create(CategoricalChart2 && CategoricalChart2.prototype);
  BulletChart2.prototype.constructor = BulletChart2;
  BulletChart2.prototype.reflowCategories = function reflowCategories(categorySlots) {
    var children = this.children;
    var childrenLength = children.length;
    for (var i16 = 0; i16 < childrenLength; i16++) {
      children[i16].reflow(categorySlots[i16]);
    }
  };
  BulletChart2.prototype.plotRange = function plotRange(point2) {
    var series = point2.series;
    var valueAxis = this.seriesValueAxis(series);
    var axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);
    return [axisCrossingValue, point2.value.current || axisCrossingValue];
  };
  BulletChart2.prototype.createPoint = function createPoint(data2, fields) {
    var categoryIx = fields.categoryIx;
    var series = fields.series;
    var ref2 = this;
    var options2 = ref2.options;
    var children = ref2.children;
    var value2 = data2.valueFields;
    var bulletOptions = deepExtend({
      vertical: !options2.invertAxes,
      overlay: series.overlay,
      categoryIx,
      invertAxes: options2.invertAxes
    }, series);
    var color = data2.fields.color || series.color;
    bulletOptions = this.evalPointOptions(bulletOptions, value2, fields);
    if (isFunction$1(series.color)) {
      color = bulletOptions.color;
    }
    var bullet = new Bullet(value2, bulletOptions);
    bullet.color = color;
    var cluster = children[categoryIx];
    if (!cluster) {
      cluster = new ClusterLayout({
        vertical: options2.invertAxes,
        gap: options2.gap,
        spacing: options2.spacing,
        rtl: !options2.invertAxes && (this.chartService || {}).rtl
      });
      this.append(cluster);
    }
    cluster.append(bullet);
    return bullet;
  };
  BulletChart2.prototype.updateRange = function updateRange(value2, fields) {
    var current2 = value2.current;
    var target = value2.target;
    var axisName = fields.series.axis;
    var axisRange = this.valueAxisRanges[axisName];
    if (defined(current2) && !isNaN(current2) && defined(target && !isNaN(target))) {
      axisRange = this.valueAxisRanges[axisName] = axisRange || { min: MAX_VALUE, max: MIN_VALUE };
      axisRange.min = Math.min(axisRange.min, current2, target);
      axisRange.max = Math.max(axisRange.max, current2, target);
    }
  };
  BulletChart2.prototype.formatPointValue = function formatPointValue(point2, format2) {
    return this.chartService.format.auto(format2, point2.value.current, point2.value.target);
  };
  BulletChart2.prototype.pointValue = function pointValue(data2) {
    return data2.valueFields.current;
  };
  BulletChart2.prototype.aboveAxis = function aboveAxis(point2) {
    var value2 = point2.value.current;
    return value2 > 0;
  };
  BulletChart2.prototype.createAnimation = function createAnimation() {
    var this$1$1 = this;
    var points2 = this.points;
    this._setAnimationOptions();
    for (var idx = 0; idx < points2.length; idx++) {
      var point2 = points2[idx];
      point2.options.animation = this$1$1.options.animation;
      point2.createAnimation();
    }
  };
  return BulletChart2;
}(CategoricalChart);
BulletChart.prototype._setAnimationOptions = BarChart.prototype._setAnimationOptions;
setDefaultOptions(BulletChart, {
  animation: {
    type: BAR
  }
});
function wrapData(options2) {
  var series = options2.series;
  for (var i16 = 0; i16 < series.length; i16++) {
    var seriesItem = series[i16];
    var data2 = seriesItem.data;
    if (data2 && !isArray$1(data2[0]) && !isObject(data2[0])) {
      seriesItem.data = [data2];
    }
  }
}
var BaseTooltip = function(Class3) {
  function BaseTooltip2(chartService, options2) {
    Class3.call(this);
    this.chartService = chartService;
    this.options = deepExtend({}, this.options, options2);
  }
  if (Class3)
    BaseTooltip2.__proto__ = Class3;
  BaseTooltip2.prototype = Object.create(Class3 && Class3.prototype);
  BaseTooltip2.prototype.constructor = BaseTooltip2;
  BaseTooltip2.prototype.getStyle = function getStyle(options2, point2) {
    var background = options2.background;
    var border = options2.border.color;
    if (point2) {
      var pointColor = point2.color || point2.options.color;
      background = valueOrDefault$1(background, pointColor);
      border = valueOrDefault$1(border, pointColor);
    }
    var padding = getSpacing(options2.padding || {}, "auto");
    return {
      backgroundColor: background,
      borderColor: border,
      font: options2.font,
      color: options2.color,
      opacity: options2.opacity,
      borderWidth: styleValue(options2.border.width),
      paddingTop: styleValue(padding.top),
      paddingBottom: styleValue(padding.bottom),
      paddingLeft: styleValue(padding.left),
      paddingRight: styleValue(padding.right)
    };
  };
  BaseTooltip2.prototype.show = function show2(options2, tooltipOptions, point2) {
    options2.format = tooltipOptions.format;
    var style2 = this.getStyle(tooltipOptions, point2);
    options2.style = style2;
    var background = new m$e(style2.backgroundColor);
    if (!defined(tooltipOptions.color) && !background.isDark()) {
      options2.className = "k-chart-tooltip-inverse";
    }
    this.chartService.notify(SHOW_TOOLTIP$1, options2);
    this.visible = true;
  };
  BaseTooltip2.prototype.hide = function hide2() {
    if (this.chartService) {
      this.chartService.notify(HIDE_TOOLTIP$1);
    }
    this.visible = false;
  };
  BaseTooltip2.prototype.destroy = function destroy2() {
    delete this.chartService;
  };
  return BaseTooltip2;
}(Class$1);
setDefaultOptions(BaseTooltip, {
  border: {
    width: 1
  },
  opacity: 1
});
var CrosshairTooltip = function(BaseTooltip2) {
  function CrosshairTooltip2(chartService, crosshair, options2) {
    BaseTooltip2.call(this, chartService, options2);
    this.crosshair = crosshair;
    this.formatService = chartService.format;
    this.initAxisName();
  }
  if (BaseTooltip2)
    CrosshairTooltip2.__proto__ = BaseTooltip2;
  CrosshairTooltip2.prototype = Object.create(BaseTooltip2 && BaseTooltip2.prototype);
  CrosshairTooltip2.prototype.constructor = CrosshairTooltip2;
  CrosshairTooltip2.prototype.initAxisName = function initAxisName() {
    var axis = this.crosshair.axis;
    var plotArea = axis.plotArea;
    var name2;
    if (plotArea.categoryAxis) {
      name2 = axis.getCategory ? "categoryAxis" : "valueAxis";
    } else {
      name2 = axis.options.vertical ? "yAxis" : "xAxis";
    }
    this.axisName = name2;
  };
  CrosshairTooltip2.prototype.showAt = function showAt(point2) {
    var ref2 = this;
    var axis = ref2.crosshair.axis;
    var options2 = ref2.options;
    var value2 = axis[options2.stickyMode ? "getCategory" : "getValue"](point2);
    var formattedValue = value2;
    if (options2.format) {
      formattedValue = this.formatService.auto(options2.format, value2);
    } else if (axis.options.type === DATE) {
      formattedValue = this.formatService.auto(axis.options.labels.dateFormats[axis.options.baseUnit], value2);
    }
    this.show({
      point: point2,
      anchor: this.getAnchor(),
      crosshair: this.crosshair,
      value: formattedValue,
      axisName: this.axisName,
      axisIndex: this.crosshair.axis.axisIndex
    }, this.options);
  };
  CrosshairTooltip2.prototype.hide = function hide2() {
    this.chartService.notify(HIDE_TOOLTIP$1, {
      crosshair: this.crosshair,
      axisName: this.axisName,
      axisIndex: this.crosshair.axis.axisIndex
    });
  };
  CrosshairTooltip2.prototype.getAnchor = function getAnchor() {
    var ref2 = this;
    var crosshair = ref2.crosshair;
    var ref_options = ref2.options;
    var position2 = ref_options.position;
    var padding = ref_options.padding;
    var vertical = !crosshair.axis.options.vertical;
    var lineBox = crosshair.line.bbox();
    var horizontalAlign, verticalAlign, point2;
    if (vertical) {
      horizontalAlign = CENTER;
      if (position2 === BOTTOM) {
        verticalAlign = TOP;
        point2 = lineBox.bottomLeft().translate(0, padding);
      } else {
        verticalAlign = BOTTOM;
        point2 = lineBox.topLeft().translate(0, -padding);
      }
    } else {
      verticalAlign = CENTER;
      if (position2 === LEFT) {
        horizontalAlign = RIGHT;
        point2 = lineBox.topLeft().translate(-padding, 0);
      } else {
        horizontalAlign = LEFT;
        point2 = lineBox.topRight().translate(padding, 0);
      }
    }
    return {
      point: point2,
      align: {
        horizontal: horizontalAlign,
        vertical: verticalAlign
      }
    };
  };
  return CrosshairTooltip2;
}(BaseTooltip);
setDefaultOptions(CrosshairTooltip, {
  padding: 10
});
var Crosshair = function(ChartElement2) {
  function Crosshair2(chartService, axis, options2) {
    ChartElement2.call(this, options2);
    this.axis = axis;
    this.stickyMode = axis instanceof CategoryAxis;
    var tooltipOptions = this.options.tooltip;
    if (tooltipOptions.visible) {
      this.tooltip = new CrosshairTooltip(
        chartService,
        this,
        deepExtend({}, tooltipOptions, { stickyMode: this.stickyMode })
      );
    }
  }
  if (ChartElement2)
    Crosshair2.__proto__ = ChartElement2;
  Crosshair2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  Crosshair2.prototype.constructor = Crosshair2;
  Crosshair2.prototype.showAt = function showAt(point2) {
    this.point = point2;
    this.moveLine();
    this.line.visible(true);
    if (this.tooltip) {
      this.tooltip.showAt(point2);
    }
  };
  Crosshair2.prototype.hide = function hide2() {
    this.line.visible(false);
    if (this.tooltip) {
      this.tooltip.hide();
    }
  };
  Crosshair2.prototype.moveLine = function moveLine() {
    var ref2 = this;
    var axis = ref2.axis;
    var point2 = ref2.point;
    var vertical = axis.options.vertical;
    var box = this.getBox();
    var dim = vertical ? Y$7 : X$4;
    var lineStart = new Point$7(box.x1, box.y1);
    var lineEnd;
    if (vertical) {
      lineEnd = new Point$7(box.x2, box.y1);
    } else {
      lineEnd = new Point$7(box.x1, box.y2);
    }
    if (point2) {
      if (this.stickyMode) {
        var slot = axis.getSlot(axis.pointCategoryIndex(point2));
        lineStart[dim] = lineEnd[dim] = slot.center()[dim];
      } else {
        lineStart[dim] = lineEnd[dim] = point2[dim];
      }
    }
    this.box = box;
    this.line.moveTo(lineStart).lineTo(lineEnd);
  };
  Crosshair2.prototype.getBox = function getBox() {
    var axis = this.axis;
    var axes = axis.pane.axes;
    var length = axes.length;
    var vertical = axis.options.vertical;
    var box = axis.lineBox().clone();
    var dim = vertical ? X$4 : Y$7;
    var axisLineBox;
    for (var i16 = 0; i16 < length; i16++) {
      var currentAxis = axes[i16];
      if (currentAxis.options.vertical !== vertical) {
        if (!axisLineBox) {
          axisLineBox = currentAxis.lineBox().clone();
        } else {
          axisLineBox.wrap(currentAxis.lineBox());
        }
      }
    }
    box[dim + 1] = axisLineBox[dim + 1];
    box[dim + 2] = axisLineBox[dim + 2];
    return box;
  };
  Crosshair2.prototype.createVisual = function createVisual() {
    ChartElement2.prototype.createVisual.call(this);
    var options2 = this.options;
    this.line = new Path$7({
      stroke: {
        color: options2.color,
        width: options2.width,
        opacity: options2.opacity,
        dashType: options2.dashType
      },
      visible: false
    });
    this.moveLine();
    this.visual.append(this.line);
  };
  Crosshair2.prototype.destroy = function destroy2() {
    if (this.tooltip) {
      this.tooltip.destroy();
    }
    ChartElement2.prototype.destroy.call(this);
  };
  return Crosshair2;
}(ChartElement);
setDefaultOptions(Crosshair, {
  color: BLACK$1,
  width: 2,
  zIndex: -1,
  tooltip: {
    visible: false
  }
});
var ChartContainer = function(ChartElement2) {
  function ChartContainer2(options2, pane) {
    ChartElement2.call(this, options2);
    this.pane = pane;
  }
  if (ChartElement2)
    ChartContainer2.__proto__ = ChartElement2;
  ChartContainer2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  ChartContainer2.prototype.constructor = ChartContainer2;
  ChartContainer2.prototype.shouldClip = function shouldClip() {
    var children = this.children;
    var length = children.length;
    for (var i16 = 0; i16 < length; i16++) {
      if (children[i16].options.clip === true) {
        return true;
      }
    }
    return false;
  };
  ChartContainer2.prototype._clipBox = function _clipBox() {
    return this.pane.chartsBox();
  };
  ChartContainer2.prototype.createVisual = function createVisual() {
    this.visual = new Group$9({
      zIndex: 0
    });
    if (this.shouldClip()) {
      var clipBox = this.clipBox = this._clipBox();
      var clipRect = clipBox.toRect();
      var clipPath = Path$7.fromRect(clipRect);
      alignPathToPixel(clipPath);
      this.visual.clip(clipPath);
      this.unclipLabels();
    }
  };
  ChartContainer2.prototype.stackRoot = function stackRoot() {
    return this;
  };
  ChartContainer2.prototype.unclipLabels = function unclipLabels() {
    var ref2 = this;
    var charts = ref2.children;
    var clipBox = ref2.clipBox;
    for (var i16 = 0; i16 < charts.length; i16++) {
      var points2 = charts[i16].points || {};
      var length = points2.length;
      for (var j2 = 0; j2 < length; j2++) {
        var point2 = points2[j2];
        if (point2 && point2.visible !== false && point2.overlapsBox && point2.overlapsBox(clipBox)) {
          if (point2.unclipElements) {
            point2.unclipElements();
          } else {
            var label = point2.label;
            var note2 = point2.note;
            if (label && label.options.visible) {
              if (label.alignToClipBox) {
                label.alignToClipBox(clipBox);
              }
              label.options.noclip = true;
            }
            if (note2 && note2.options.visible) {
              note2.options.noclip = true;
            }
          }
        }
      }
    }
  };
  ChartContainer2.prototype.destroy = function destroy2() {
    ChartElement2.prototype.destroy.call(this);
    delete this.parent;
  };
  return ChartContainer2;
}(ChartElement);
ChartContainer.prototype.isStackRoot = true;
var Pane$1 = function(BoxElement2) {
  function Pane2(options2) {
    BoxElement2.call(this, options2);
    this.id = paneID();
    this.createTitle();
    this.content = new ChartElement();
    this.chartContainer = new ChartContainer({}, this);
    this.append(this.content);
    this.axes = [];
    this.charts = [];
  }
  if (BoxElement2)
    Pane2.__proto__ = BoxElement2;
  Pane2.prototype = Object.create(BoxElement2 && BoxElement2.prototype);
  Pane2.prototype.constructor = Pane2;
  Pane2.prototype.createTitle = function createTitle() {
    var titleOptions = this.options.title;
    if (isObject(titleOptions)) {
      titleOptions = deepExtend({}, titleOptions, {
        align: titleOptions.position,
        position: TOP
      });
    }
    this.title = Title$1.buildTitle(titleOptions, Pane2.prototype.options.title);
    if (this.title) {
      this.append(this.title);
    }
  };
  Pane2.prototype.appendAxis = function appendAxis(axis) {
    this.content.append(axis);
    this.axes.push(axis);
    axis.pane = this;
  };
  Pane2.prototype.appendAxisAt = function appendAxisAt(axis, pos) {
    this.content.append(axis);
    this.axes.splice(pos, 0, axis);
    axis.pane = this;
  };
  Pane2.prototype.appendChart = function appendChart(chart) {
    if (this.chartContainer.parent !== this.content) {
      this.content.append(this.chartContainer);
    }
    this.charts.push(chart);
    this.chartContainer.append(chart);
    chart.pane = this;
  };
  Pane2.prototype.empty = function empty2() {
    var this$1$1 = this;
    var plotArea = this.parent;
    if (plotArea) {
      for (var i16 = 0; i16 < this.axes.length; i16++) {
        plotArea.removeAxis(this$1$1.axes[i16]);
      }
      for (var i$12 = 0; i$12 < this.charts.length; i$12++) {
        plotArea.removeChart(this$1$1.charts[i$12]);
      }
    }
    this.axes = [];
    this.charts = [];
    this.content.destroy();
    this.content.children = [];
    this.chartContainer.children = [];
  };
  Pane2.prototype.reflow = function reflow(targetBox) {
    var content;
    if (last(this.children) === this.content) {
      content = this.children.pop();
    }
    BoxElement2.prototype.reflow.call(this, targetBox);
    if (content) {
      this.children.push(content);
    }
    if (this.title) {
      this.contentBox.y1 += this.title.box.height();
    }
  };
  Pane2.prototype.visualStyle = function visualStyle() {
    var style2 = BoxElement2.prototype.visualStyle.call(this);
    style2.zIndex = -10;
    return style2;
  };
  Pane2.prototype.renderComplete = function renderComplete() {
    if (this.options.visible) {
      this.createGridLines();
    }
  };
  Pane2.prototype.stackRoot = function stackRoot() {
    return this;
  };
  Pane2.prototype.clipRoot = function clipRoot() {
    return this;
  };
  Pane2.prototype.createGridLines = function createGridLines() {
    var axes = this.axes;
    var allAxes = axes.concat(this.parent.axes);
    var vGridLines = [];
    var hGridLines = [];
    for (var i16 = 0; i16 < axes.length; i16++) {
      var axis = axes[i16];
      var vertical = axis.options.vertical;
      var gridLines = vertical ? vGridLines : hGridLines;
      for (var j2 = 0; j2 < allAxes.length; j2++) {
        if (gridLines.length === 0) {
          var altAxis = allAxes[j2];
          if (vertical !== altAxis.options.vertical) {
            append(gridLines, axis.createGridLines(altAxis));
          }
        }
      }
    }
  };
  Pane2.prototype.refresh = function refresh() {
    this.visual.clear();
    this.content.parent = null;
    this.content.createGradient = this.createGradient.bind(this);
    this.content.renderVisual();
    this.content.parent = this;
    if (this.title) {
      this.visual.append(this.title.visual);
    }
    this.visual.append(this.content.visual);
    this.renderComplete();
    this.notifyRender();
  };
  Pane2.prototype.chartsBox = function chartsBox() {
    var axes = this.axes;
    var length = axes.length;
    var chartsBox2 = new Box();
    for (var idx = 0; idx < length; idx++) {
      var axis = axes[idx];
      var axisValueField = axis.options.vertical ? Y$7 : X$4;
      var lineBox = axis.lineBox();
      chartsBox2[axisValueField + 1] = lineBox[axisValueField + 1];
      chartsBox2[axisValueField + 2] = lineBox[axisValueField + 2];
    }
    if (chartsBox2.x2 === 0) {
      var allAxes = this.parent.axes;
      var length$1 = allAxes.length;
      for (var idx$1 = 0; idx$1 < length$1; idx$1++) {
        var axis$1 = allAxes[idx$1];
        if (!axis$1.options.vertical) {
          var lineBox$1 = axis$1.lineBox();
          chartsBox2.x1 = lineBox$1.x1;
          chartsBox2.x2 = lineBox$1.x2;
        }
      }
    }
    return chartsBox2;
  };
  Pane2.prototype.clipBox = function clipBox() {
    return this.chartContainer.clipBox;
  };
  Pane2.prototype.notifyRender = function notifyRender() {
    var service = this.getService();
    if (service) {
      service.notify(PANE_RENDER, {
        pane: new ChartPane(this),
        index: this.paneIndex,
        name: this.options.name
      });
    }
  };
  return Pane2;
}(BoxElement);
var ID = 1;
function paneID() {
  return "pane" + ID++;
}
Pane$1.prototype.isStackRoot = true;
setDefaultOptions(Pane$1, {
  zIndex: -1,
  shrinkToFit: true,
  title: {
    align: LEFT
  },
  visible: true
});
var PlotAreaBase = function(ChartElement2) {
  function PlotAreaBase2(series, options2, chartService) {
    ChartElement2.call(this, options2);
    this.initFields(series, options2);
    this.series = series;
    this.initSeries();
    this.charts = [];
    this.options.legend = this.options.legend || {};
    this.options.legend.data = [];
    this.axes = [];
    this.crosshairs = [];
    this.chartService = chartService;
    this.originalOptions = options2;
    this.originalSeries = series;
    this._bindCache = /* @__PURE__ */ new WeakMap();
    this.createPanes();
    this.render();
    this.createCrosshairs();
  }
  if (ChartElement2)
    PlotAreaBase2.__proto__ = ChartElement2;
  PlotAreaBase2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  PlotAreaBase2.prototype.constructor = PlotAreaBase2;
  PlotAreaBase2.prototype.initFields = function initFields() {
  };
  PlotAreaBase2.prototype.initSeries = function initSeries() {
    var series = this.series;
    for (var i16 = 0; i16 < series.length; i16++) {
      series[i16].index = i16;
    }
  };
  PlotAreaBase2.prototype.bindPoint = function bindPoint(series, pointIx, item) {
    var cached = this._bindCache.get(series);
    if (!cached) {
      cached = [];
      this._bindCache.set(series, cached);
    }
    var data2 = cached[pointIx];
    if (!data2) {
      data2 = cached[pointIx] = SeriesBinder.current.bindPoint(series, pointIx, item);
    }
    return data2;
  };
  PlotAreaBase2.prototype.createPanes = function createPanes() {
    var this$1$1 = this;
    var titleOptions = this.options.title || {};
    var paneDefaults = this.options.paneDefaults;
    var paneOptions = this.options.panes || [];
    var panesLength = Math.max(paneOptions.length, 1);
    var panes = [];
    var defaults = deepExtend({
      title: {
        color: titleOptions.color
      }
    }, paneDefaults);
    for (var i16 = 0; i16 < panesLength; i16++) {
      var options2 = deepExtend({}, defaults, paneOptions[i16]);
      if (isString$2(options2.title)) {
        options2.title = deepExtend({ text: options2.title }, defaults.title);
      }
      var currentPane = new Pane$1(options2);
      currentPane.paneIndex = i16;
      panes.push(currentPane);
      this$1$1.append(currentPane);
    }
    this.panes = panes;
  };
  PlotAreaBase2.prototype.crosshairOptions = function crosshairOptions(axis) {
    return axis.options.crosshair;
  };
  PlotAreaBase2.prototype.createCrosshairs = function createCrosshairs(panes) {
    var this$1$1 = this;
    if (panes === void 0)
      panes = this.panes;
    for (var i16 = 0; i16 < panes.length; i16++) {
      var pane = panes[i16];
      for (var j2 = 0; j2 < pane.axes.length; j2++) {
        var axis = pane.axes[j2];
        var options2 = this$1$1.crosshairOptions(axis);
        if (options2 && options2.visible) {
          var currentCrosshair = new Crosshair(this$1$1.chartService, axis, options2);
          this$1$1.crosshairs.push(currentCrosshair);
          pane.content.append(currentCrosshair);
        }
      }
    }
  };
  PlotAreaBase2.prototype.removeCrosshairs = function removeCrosshairs(pane) {
    var crosshairs = this.crosshairs;
    var axes = pane.axes;
    for (var i16 = crosshairs.length - 1; i16 >= 0; i16--) {
      for (var j2 = 0; j2 < axes.length; j2++) {
        if (crosshairs[i16].axis === axes[j2]) {
          crosshairs.splice(i16, 1);
          break;
        }
      }
    }
  };
  PlotAreaBase2.prototype.hideCrosshairs = function hideCrosshairs() {
    var crosshairs = this.crosshairs;
    for (var idx = 0; idx < crosshairs.length; idx++) {
      crosshairs[idx].hide();
    }
  };
  PlotAreaBase2.prototype.findPane = function findPane(name2) {
    var panes = this.panes;
    var matchingPane;
    for (var i16 = 0; i16 < panes.length; i16++) {
      if (panes[i16].options.name === name2) {
        matchingPane = panes[i16];
        break;
      }
    }
    return matchingPane || panes[0];
  };
  PlotAreaBase2.prototype.findPointPane = function findPointPane(point2) {
    var panes = this.panes;
    var matchingPane;
    for (var i16 = 0; i16 < panes.length; i16++) {
      if (panes[i16].box.containsPoint(point2)) {
        matchingPane = panes[i16];
        break;
      }
    }
    return matchingPane;
  };
  PlotAreaBase2.prototype.appendAxis = function appendAxis(axis) {
    var pane = this.findPane(axis.options.pane);
    pane.appendAxis(axis);
    this.axes.push(axis);
    axis.plotArea = this;
  };
  PlotAreaBase2.prototype.removeAxis = function removeAxis(axisToRemove) {
    var this$1$1 = this;
    var filteredAxes = [];
    for (var i16 = 0; i16 < this.axes.length; i16++) {
      var axis = this$1$1.axes[i16];
      if (axisToRemove !== axis) {
        filteredAxes.push(axis);
      } else {
        axis.destroy();
      }
    }
    this.axes = filteredAxes;
  };
  PlotAreaBase2.prototype.appendChart = function appendChart(chart, pane) {
    this.charts.push(chart);
    if (pane) {
      pane.appendChart(chart);
    } else {
      this.append(chart);
    }
  };
  PlotAreaBase2.prototype.removeChart = function removeChart(chartToRemove) {
    var this$1$1 = this;
    var filteredCharts = [];
    for (var i16 = 0; i16 < this.charts.length; i16++) {
      var chart = this$1$1.charts[i16];
      if (chart !== chartToRemove) {
        filteredCharts.push(chart);
      } else {
        chart.destroy();
      }
    }
    this.charts = filteredCharts;
  };
  PlotAreaBase2.prototype.addToLegend = function addToLegend(series) {
    var count = series.length;
    var legend2 = this.options.legend;
    var labels = legend2.labels || {};
    var inactiveItems = legend2.inactiveItems || {};
    var inactiveItemsLabels = inactiveItems.labels || {};
    var data2 = [];
    for (var i16 = 0; i16 < count; i16++) {
      var currentSeries = series[i16];
      var seriesVisible = currentSeries.visible !== false;
      if (currentSeries.visibleInLegend === false) {
        continue;
      }
      var text = currentSeries.name;
      var labelTemplate = seriesVisible ? getTemplate$1(labels) : getTemplate$1(inactiveItemsLabels) || getTemplate$1(labels);
      if (labelTemplate) {
        text = labelTemplate({
          text: hasValue$1(text) ? text : "",
          series: currentSeries
        });
      }
      var defaults = currentSeries._defaults;
      var color = currentSeries.color;
      if (isFunction$1(color) && defaults) {
        color = defaults.color;
      }
      var itemLabelOptions = void 0, markerColor = void 0;
      if (seriesVisible) {
        itemLabelOptions = {};
        markerColor = color;
      } else {
        itemLabelOptions = {
          color: inactiveItemsLabels.color,
          font: inactiveItemsLabels.font
        };
        markerColor = inactiveItems.markers.color;
      }
      if (hasValue$1(text) && text !== "") {
        data2.push({
          text,
          labels: itemLabelOptions,
          markerColor,
          series: currentSeries,
          active: seriesVisible
        });
      }
    }
    append(legend2.data, data2);
  };
  PlotAreaBase2.prototype.groupAxes = function groupAxes(panes) {
    var xAxes = [];
    var yAxes = [];
    for (var paneIx = 0; paneIx < panes.length; paneIx++) {
      var paneAxes = panes[paneIx].axes;
      for (var axisIx = 0; axisIx < paneAxes.length; axisIx++) {
        var axis = paneAxes[axisIx];
        if (axis.options.vertical) {
          yAxes.push(axis);
        } else {
          xAxes.push(axis);
        }
      }
    }
    return { x: xAxes, y: yAxes, any: xAxes.concat(yAxes) };
  };
  PlotAreaBase2.prototype.groupSeriesByPane = function groupSeriesByPane() {
    var this$1$1 = this;
    var series = this.series;
    var seriesByPane = {};
    for (var i16 = 0; i16 < series.length; i16++) {
      var currentSeries = series[i16];
      var pane = this$1$1.seriesPaneName(currentSeries);
      if (seriesByPane[pane]) {
        seriesByPane[pane].push(currentSeries);
      } else {
        seriesByPane[pane] = [currentSeries];
      }
    }
    return seriesByPane;
  };
  PlotAreaBase2.prototype.filterVisibleSeries = function filterVisibleSeries(series) {
    var result = [];
    for (var i16 = 0; i16 < series.length; i16++) {
      var currentSeries = series[i16];
      if (currentSeries.visible !== false) {
        result.push(currentSeries);
      }
    }
    return result;
  };
  PlotAreaBase2.prototype.reflow = function reflow(targetBox) {
    var options2 = this.options.plotArea;
    var panes = this.panes;
    var margin = getSpacing(options2.margin);
    this.box = targetBox.clone().unpad(margin);
    this.reflowPanes();
    this.detachLabels();
    this.reflowAxes(panes);
    this.reflowCharts(panes);
  };
  PlotAreaBase2.prototype.redraw = function redraw(panes) {
    var this$1$1 = this;
    var panesArray = [].concat(panes);
    this.initSeries();
    var root = this.getRoot();
    if (root) {
      root.cleanGradients();
    }
    for (var i16 = 0; i16 < panesArray.length; i16++) {
      this$1$1.removeCrosshairs(panesArray[i16]);
      panesArray[i16].empty();
    }
    this._bindCache = /* @__PURE__ */ new WeakMap();
    this.render(panesArray);
    this.detachLabels();
    this.reflowAxes(this.panes);
    this.reflowCharts(panesArray);
    this.createCrosshairs(panesArray);
    for (var i$12 = 0; i$12 < panesArray.length; i$12++) {
      panesArray[i$12].refresh();
    }
  };
  PlotAreaBase2.prototype.axisCrossingValues = function axisCrossingValues(axis, crossingAxes) {
    var options2 = axis.options;
    var crossingValues = [].concat(
      options2.axisCrossingValues || options2.axisCrossingValue
    );
    var valuesToAdd = crossingAxes.length - crossingValues.length;
    var defaultValue = crossingValues[0] || 0;
    for (var i16 = 0; i16 < valuesToAdd; i16++) {
      crossingValues.push(defaultValue);
    }
    return crossingValues;
  };
  PlotAreaBase2.prototype.alignAxisTo = function alignAxisTo(axis, targetAxis, crossingValue, targetCrossingValue) {
    var slot = axis.getSlot(crossingValue, crossingValue, true);
    var slotEdge = axis.options.reverse ? 2 : 1;
    var targetSlot = targetAxis.getSlot(targetCrossingValue, targetCrossingValue, true);
    var targetEdge = targetAxis.options.reverse ? 2 : 1;
    var axisBox = axis.box.translate(
      targetSlot[X$4 + targetEdge] - slot[X$4 + slotEdge],
      targetSlot[Y$7 + targetEdge] - slot[Y$7 + slotEdge]
    );
    if (axis.pane !== targetAxis.pane) {
      axisBox.translate(0, axis.pane.box.y1 - targetAxis.pane.box.y1);
    }
    axis.reflow(axisBox);
  };
  PlotAreaBase2.prototype.alignAxes = function alignAxes(xAxes, yAxes) {
    var this$1$1 = this;
    var xAnchor = xAxes[0];
    var yAnchor = yAxes[0];
    var xAnchorCrossings = this.axisCrossingValues(xAnchor, yAxes);
    var yAnchorCrossings = this.axisCrossingValues(yAnchor, xAxes);
    var leftAnchors = {};
    var rightAnchors = {};
    var topAnchors = {};
    var bottomAnchors = {};
    for (var i16 = 0; i16 < yAxes.length; i16++) {
      var axis = yAxes[i16];
      var pane = axis.pane;
      var paneId = pane.id;
      var visible = axis.options.visible !== false;
      var anchor = paneAnchor(xAxes, pane) || xAnchor;
      var anchorCrossings = xAnchorCrossings;
      if (anchor !== xAnchor) {
        anchorCrossings = this$1$1.axisCrossingValues(anchor, yAxes);
      }
      this$1$1.alignAxisTo(axis, anchor, yAnchorCrossings[i16], anchorCrossings[i16]);
      if (axis.options._overlap) {
        continue;
      }
      if (round$1(axis.lineBox().x1) === round$1(anchor.lineBox().x1)) {
        if (leftAnchors[paneId]) {
          axis.reflow(
            axis.box.alignTo(leftAnchors[paneId].box, LEFT).translate(-axis.options.margin, 0)
          );
        }
        if (visible) {
          leftAnchors[paneId] = axis;
        }
      }
      if (round$1(axis.lineBox().x2) === round$1(anchor.lineBox().x2)) {
        if (!axis._mirrored) {
          axis.options.labels.mirror = !axis.options.labels.mirror;
          axis._mirrored = true;
        }
        this$1$1.alignAxisTo(axis, anchor, yAnchorCrossings[i16], anchorCrossings[i16]);
        if (rightAnchors[paneId]) {
          axis.reflow(
            axis.box.alignTo(rightAnchors[paneId].box, RIGHT).translate(axis.options.margin, 0)
          );
        }
        if (visible) {
          rightAnchors[paneId] = axis;
        }
      }
      var paneYAnchor = paneAnchor(yAxes, pane) || yAnchor;
      if (paneYAnchor !== axis) {
        axis.alignTo(paneYAnchor);
        axis.reflow(axis.box);
      }
    }
    for (var i$12 = 0; i$12 < xAxes.length; i$12++) {
      var axis$1 = xAxes[i$12];
      var pane$1 = axis$1.pane;
      var paneId$1 = pane$1.id;
      var visible$1 = axis$1.options.visible !== false;
      var anchor$1 = paneAnchor(yAxes, pane$1) || yAnchor;
      var anchorCrossings$1 = yAnchorCrossings;
      if (anchor$1 !== yAnchor) {
        anchorCrossings$1 = this$1$1.axisCrossingValues(anchor$1, xAxes);
      }
      this$1$1.alignAxisTo(axis$1, anchor$1, xAnchorCrossings[i$12], anchorCrossings$1[i$12]);
      if (axis$1.options._overlap) {
        continue;
      }
      if (round$1(axis$1.lineBox().y1) === round$1(anchor$1.lineBox().y1)) {
        if (!axis$1._mirrored) {
          axis$1.options.labels.mirror = !axis$1.options.labels.mirror;
          axis$1._mirrored = true;
        }
        this$1$1.alignAxisTo(axis$1, anchor$1, xAnchorCrossings[i$12], anchorCrossings$1[i$12]);
        if (topAnchors[paneId$1]) {
          axis$1.reflow(
            axis$1.box.alignTo(topAnchors[paneId$1].box, TOP).translate(0, -axis$1.options.margin)
          );
        }
        if (visible$1) {
          topAnchors[paneId$1] = axis$1;
        }
      }
      if (round$1(axis$1.lineBox().y2, COORD_PRECISION) === round$1(anchor$1.lineBox().y2, COORD_PRECISION)) {
        if (bottomAnchors[paneId$1]) {
          axis$1.reflow(
            axis$1.box.alignTo(bottomAnchors[paneId$1].box, BOTTOM).translate(0, axis$1.options.margin)
          );
        }
        if (visible$1) {
          bottomAnchors[paneId$1] = axis$1;
        }
      }
      if (i$12 !== 0) {
        axis$1.alignTo(xAnchor);
        axis$1.reflow(axis$1.box);
      }
    }
  };
  PlotAreaBase2.prototype.shrinkAxisWidth = function shrinkAxisWidth(panes) {
    var axes = this.groupAxes(panes).any;
    var axisBox = axisGroupBox(axes);
    var overflowX = 0;
    for (var i16 = 0; i16 < panes.length; i16++) {
      var currentPane = panes[i16];
      if (currentPane.axes.length > 0) {
        overflowX = Math.max(
          overflowX,
          axisBox.width() - currentPane.contentBox.width()
        );
      }
    }
    if (overflowX !== 0) {
      for (var i$12 = 0; i$12 < axes.length; i$12++) {
        var currentAxis = axes[i$12];
        if (!currentAxis.options.vertical) {
          currentAxis.reflow(currentAxis.box.shrink(overflowX, 0));
        }
      }
    }
  };
  PlotAreaBase2.prototype.shrinkAxisHeight = function shrinkAxisHeight(panes) {
    var shrinked;
    for (var i16 = 0; i16 < panes.length; i16++) {
      var currentPane = panes[i16];
      var axes = currentPane.axes;
      var overflowY = Math.max(0, axisGroupBox(axes).height() - currentPane.contentBox.height());
      if (overflowY !== 0) {
        for (var j2 = 0; j2 < axes.length; j2++) {
          var currentAxis = axes[j2];
          if (currentAxis.options.vertical) {
            currentAxis.reflow(
              currentAxis.box.shrink(0, overflowY)
            );
          }
        }
        shrinked = true;
      }
    }
    return shrinked;
  };
  PlotAreaBase2.prototype.fitAxes = function fitAxes(panes) {
    var axes = this.groupAxes(panes).any;
    var offsetX = 0;
    for (var i16 = 0; i16 < panes.length; i16++) {
      var currentPane = panes[i16];
      var paneAxes = currentPane.axes;
      var paneBox = currentPane.contentBox;
      if (paneAxes.length > 0) {
        var axisBox = axisGroupBox(paneAxes);
        var offsetY = Math.max(paneBox.y1 - axisBox.y1, paneBox.y2 - axisBox.y2);
        offsetX = Math.max(offsetX, paneBox.x1 - axisBox.x1);
        for (var j2 = 0; j2 < paneAxes.length; j2++) {
          var currentAxis = paneAxes[j2];
          currentAxis.reflow(
            currentAxis.box.translate(0, offsetY)
          );
        }
      }
    }
    for (var i$12 = 0; i$12 < axes.length; i$12++) {
      var currentAxis$1 = axes[i$12];
      currentAxis$1.reflow(
        currentAxis$1.box.translate(offsetX, 0)
      );
    }
  };
  PlotAreaBase2.prototype.reflowAxes = function reflowAxes(panes) {
    var this$1$1 = this;
    var axes = this.groupAxes(panes);
    for (var i16 = 0; i16 < panes.length; i16++) {
      this$1$1.reflowPaneAxes(panes[i16]);
    }
    if (axes.x.length > 0 && axes.y.length > 0) {
      this.alignAxes(axes.x, axes.y);
      this.shrinkAxisWidth(panes);
      this.autoRotateAxisLabels(axes);
      this.alignAxes(axes.x, axes.y);
      if (this.shrinkAxisWidth(panes)) {
        this.alignAxes(axes.x, axes.y);
      }
      this.shrinkAxisHeight(panes);
      this.alignAxes(axes.x, axes.y);
      if (this.shrinkAxisHeight(panes)) {
        this.alignAxes(axes.x, axes.y);
      }
      this.fitAxes(panes);
    }
  };
  PlotAreaBase2.prototype.autoRotateAxisLabels = function autoRotateAxisLabels(groupedAxes) {
    var this$1$1 = this;
    var ref2 = this;
    var panes = ref2.panes;
    var axes = allPaneAxes(panes);
    var rotated;
    for (var idx = 0; idx < axes.length; idx++) {
      var axis = axes[idx];
      if (axis.autoRotateLabels()) {
        rotated = true;
      }
    }
    if (rotated) {
      for (var idx$1 = 0; idx$1 < panes.length; idx$1++) {
        this$1$1.reflowPaneAxes(panes[idx$1]);
      }
      if (groupedAxes.x.length > 0 && groupedAxes.y.length > 0) {
        this.alignAxes(groupedAxes.x, groupedAxes.y);
        this.shrinkAxisWidth(panes);
      }
    }
  };
  PlotAreaBase2.prototype.reflowPaneAxes = function reflowPaneAxes(pane) {
    var axes = pane.axes;
    var length = axes.length;
    if (length > 0) {
      for (var i16 = 0; i16 < length; i16++) {
        axes[i16].reflow(pane.contentBox);
      }
    }
  };
  PlotAreaBase2.prototype.reflowCharts = function reflowCharts(panes) {
    var charts = this.charts;
    var count = charts.length;
    var box = this.box;
    for (var i16 = 0; i16 < count; i16++) {
      var chartPane = charts[i16].pane;
      if (!chartPane || inArray(chartPane, panes)) {
        charts[i16].reflow(box);
      }
    }
  };
  PlotAreaBase2.prototype.reflowPanes = function reflowPanes() {
    var ref2 = this;
    var box = ref2.box;
    var panes = ref2.panes;
    var panesLength = panes.length;
    var remainingHeight = box.height();
    var autoHeightPanes = 0;
    var top = box.y1;
    for (var i16 = 0; i16 < panesLength; i16++) {
      var currentPane = panes[i16];
      var height = currentPane.options.height;
      currentPane.options.width = box.width();
      if (!currentPane.options.height) {
        autoHeightPanes++;
      } else {
        if (height.indexOf && height.indexOf("%")) {
          var percents = parseInt(height, 10) / 100;
          currentPane.options.height = percents * box.height();
        }
        currentPane.reflow(box.clone());
        remainingHeight -= currentPane.options.height;
      }
    }
    for (var i$12 = 0; i$12 < panesLength; i$12++) {
      var currentPane$1 = panes[i$12];
      if (!currentPane$1.options.height) {
        currentPane$1.options.height = remainingHeight / autoHeightPanes;
      }
    }
    for (var i$22 = 0; i$22 < panesLength; i$22++) {
      var currentPane$2 = panes[i$22];
      var paneBox = box.clone().move(box.x1, top);
      currentPane$2.reflow(paneBox);
      top += currentPane$2.options.height;
    }
  };
  PlotAreaBase2.prototype.backgroundBox = function backgroundBox() {
    var axes = this.axes;
    var axesCount = axes.length;
    var box;
    for (var i16 = 0; i16 < axesCount; i16++) {
      var axisA = axes[i16];
      for (var j2 = 0; j2 < axesCount; j2++) {
        var axisB = axes[j2];
        if (axisA.options.vertical !== axisB.options.vertical) {
          var lineBox = axisA.lineBox().clone().wrap(axisB.lineBox());
          if (!box) {
            box = lineBox;
          } else {
            box = box.wrap(lineBox);
          }
        }
      }
    }
    return box || this.box;
  };
  PlotAreaBase2.prototype.chartsBoxes = function chartsBoxes() {
    var panes = this.panes;
    var boxes = [];
    for (var idx = 0; idx < panes.length; idx++) {
      boxes.push(panes[idx].chartsBox());
    }
    return boxes;
  };
  PlotAreaBase2.prototype.addBackgroundPaths = function addBackgroundPaths(multipath) {
    var boxes = this.chartsBoxes();
    for (var idx = 0; idx < boxes.length; idx++) {
      multipath.paths.push(Path$7.fromRect(boxes[idx].toRect()));
    }
  };
  PlotAreaBase2.prototype.backgroundContainsPoint = function backgroundContainsPoint(point2) {
    var boxes = this.chartsBoxes();
    for (var idx = 0; idx < boxes.length; idx++) {
      if (boxes[idx].containsPoint(point2)) {
        return true;
      }
    }
  };
  PlotAreaBase2.prototype.createVisual = function createVisual() {
    ChartElement2.prototype.createVisual.call(this);
    var options2 = this.options.plotArea;
    var opacity = options2.opacity;
    var background = options2.background;
    var border = options2.border;
    if (border === void 0)
      border = {};
    if (isTransparent(background)) {
      background = WHITE$1;
      opacity = 0;
    }
    var bg2 = this._bgVisual = new MultiPath({
      fill: {
        color: background,
        opacity
      },
      stroke: {
        color: border.width ? border.color : "",
        width: border.width,
        dashType: border.dashType
      },
      zIndex: -1
    });
    this.addBackgroundPaths(bg2);
    this.appendVisual(bg2);
  };
  PlotAreaBase2.prototype.pointsByCategoryIndex = function pointsByCategoryIndex(categoryIndex) {
    var charts = this.charts;
    var result = [];
    if (categoryIndex !== null) {
      for (var i16 = 0; i16 < charts.length; i16++) {
        var chart = charts[i16];
        if (chart.pane.options.name === "_navigator") {
          continue;
        }
        var points2 = charts[i16].categoryPoints[categoryIndex];
        if (points2 && points2.length) {
          for (var j2 = 0; j2 < points2.length; j2++) {
            var point2 = points2[j2];
            if (point2 && defined(point2.value) && point2.value !== null) {
              result.push(point2);
            }
          }
        }
      }
    }
    return result;
  };
  PlotAreaBase2.prototype.pointsBySeriesIndex = function pointsBySeriesIndex(seriesIndex) {
    return this.filterPoints(function(point2) {
      return point2.series.index === seriesIndex;
    });
  };
  PlotAreaBase2.prototype.pointsByPointIndex = function pointsByPointIndex(pointIndex) {
    return this.filterPoints(function(point2) {
      return point2.getIndex() === pointIndex;
    });
  };
  PlotAreaBase2.prototype.pointsBySeriesName = function pointsBySeriesName(name2) {
    return this.filterPoints(function(point2) {
      return point2.series.name === name2;
    });
  };
  PlotAreaBase2.prototype.filterPoints = function filterPoints(callback) {
    var charts = this.charts;
    var result = [];
    for (var i16 = 0; i16 < charts.length; i16++) {
      var chart = charts[i16];
      var points2 = chart.points;
      for (var j2 = 0; j2 < points2.length; j2++) {
        var point2 = points2[j2];
        if (point2 && point2.visible !== false && callback(point2)) {
          result.push(point2);
        }
      }
    }
    return result;
  };
  PlotAreaBase2.prototype.findPoint = function findPoint(callback) {
    var charts = this.charts;
    for (var i16 = 0; i16 < charts.length; i16++) {
      var chart = charts[i16];
      var points2 = chart.points;
      for (var j2 = 0; j2 < points2.length; j2++) {
        var point2 = points2[j2];
        if (point2 && point2.visible !== false && callback(point2)) {
          return point2;
        }
      }
    }
  };
  PlotAreaBase2.prototype.paneByPoint = function paneByPoint(point2) {
    var panes = this.panes;
    for (var i16 = 0; i16 < panes.length; i16++) {
      var pane = panes[i16];
      if (pane.box.containsPoint(point2)) {
        return pane;
      }
    }
  };
  PlotAreaBase2.prototype.detachLabels = function detachLabels() {
    var axes = this.groupAxes(this.panes);
    var xAxes = axes.x;
    var yAxes = axes.y;
    this.detachAxisGroupLabels(yAxes, xAxes);
    this.detachAxisGroupLabels(xAxes, yAxes);
  };
  PlotAreaBase2.prototype.detachAxisGroupLabels = function detachAxisGroupLabels(axes, crossingAxes) {
    var this$1$1 = this;
    var labelAxisCount = 0;
    for (var i16 = 0; i16 < axes.length; i16++) {
      var axis = axes[i16];
      var pane = axis.pane;
      var anchor = paneAnchor(crossingAxes, pane) || crossingAxes[0];
      var axisIndex = i16 + labelAxisCount;
      var labelAxis = this$1$1.createLabelAxis(axis, axisIndex, anchor);
      if (labelAxis) {
        labelAxisCount++;
        var pos = pane.axes.indexOf(axis) + labelAxisCount;
        pane.appendAxisAt(labelAxis, pos);
      }
    }
  };
  PlotAreaBase2.prototype.createLabelAxis = function createLabelAxis(axis, axisIndex, anchor) {
    var labelOptions = axis.options.labels;
    var position2 = labelOptions.position;
    var onAxis = position2 !== END$1 && position2 !== START$1;
    var visible = labelOptions.visible;
    if (onAxis || visible === false) {
      return null;
    }
    var allAxes = this.groupAxes(this.panes);
    var crossingAxes = anchor.options.vertical ? allAxes.x : allAxes.y;
    var anchorCrossings = this.axisCrossingValues(anchor, crossingAxes);
    var end = position2 === END$1;
    var range = anchor.range();
    var edge = end ? range.max : range.min;
    var crossingValue = limitValue(anchorCrossings[axisIndex], range.min, range.max);
    if (crossingValue - edge === 0) {
      return null;
    }
    anchorCrossings.splice(axisIndex + 1, 0, edge);
    anchor.options.axisCrossingValues = anchorCrossings;
    var labelAxis = axis.clone();
    axis.clear();
    labelAxis.options.name = void 0;
    labelAxis.options.line.visible = false;
    labelAxis.options.crosshair = void 0;
    labelAxis.options.notes = void 0;
    labelAxis.options.plotBands = void 0;
    return labelAxis;
  };
  PlotAreaBase2.prototype.isTrendline = function isTrendline(series) {
    return series && inArray(series.type, TRENDLINE_SERIES);
  };
  PlotAreaBase2.prototype.trendlineFactory = function trendlineFactory2() {
  };
  PlotAreaBase2.prototype.createTrendlineSeries = function createTrendlineSeries() {
    var this$1$1 = this;
    var modifiedSeries = [];
    this.series = this.series.map(function(series) {
      if (!this$1$1.isTrendline(series)) {
        return series;
      }
      var forSeries = this$1$1.seriesByName(series.for);
      if (!forSeries) {
        throw new Error('Invalid Configuration: Unable to locate linked series "' + series.for + '" for trendline "' + series.name + '".');
      }
      var valueFields = SeriesBinder.current.valueFields(forSeries);
      var field = last(valueFields);
      var trendlineSeries = this$1$1.trendlineFactory(Object.assign({}, { field }, series), forSeries);
      if (trendlineSeries) {
        if (forSeries.visible === false) {
          trendlineSeries.visible = false;
        }
        if (trendlineSeries.color === INHERIT) {
          trendlineSeries.color = forSeries.color;
        }
        modifiedSeries.push(trendlineSeries);
      }
      return trendlineSeries;
    }).filter(function(series) {
      return series !== null;
    });
    return modifiedSeries;
  };
  PlotAreaBase2.prototype.seriesByName = function seriesByName(name2) {
    return this.series.find(function(series) {
      return series.name === name2;
    });
  };
  PlotAreaBase2.prototype.getFirstPoint = function getFirstPoint() {
    return this.pointsBySeriesIndex(0)[0];
  };
  PlotAreaBase2.prototype.getPointBelow = function getPointBelow(point2) {
    return this._getNextPoint(point2, this._pointsByVertical, 1);
  };
  PlotAreaBase2.prototype.getPointAbove = function getPointAbove(point2) {
    return this._getNextPoint(point2, this._pointsByVertical, -1);
  };
  PlotAreaBase2.prototype.getPointToTheRight = function getPointToTheRight(point2) {
    return this._getNextPoint(point2, this._pointsByHorizontal, 1);
  };
  PlotAreaBase2.prototype.getPointToTheLeft = function getPointToTheLeft(point2) {
    return this._getNextPoint(point2, this._pointsByHorizontal, -1);
  };
  PlotAreaBase2.prototype._getNextPoint = function _getNextPoint(point2, getPointsFunc, increment) {
    var this$1$1 = this;
    var points2 = getPointsFunc.call(this, point2);
    var pointIndex = points2.indexOf(point2);
    var nextIndex = pointIndex + increment;
    var loopPoints = function(direction) {
      var result;
      var offset2 = 0;
      do {
        offset2 += direction;
        result = getPointsFunc.call(this$1$1, point2, offset2);
      } while (result.length === 0);
      return result;
    };
    if (nextIndex < 0) {
      points2 = loopPoints(-1);
      return points2.at(-1);
    } else if (nextIndex >= points2.length) {
      points2 = loopPoints(1);
      return points2.at(0);
    }
    return points2[nextIndex];
  };
  PlotAreaBase2.prototype._pointsByVertical = function _pointsByVertical(basePoint) {
    return this.pointsByPointIndex(basePoint.getIndex());
  };
  PlotAreaBase2.prototype._pointsByHorizontal = function _pointsByHorizontal(basePoint, offset2) {
    if (offset2 === void 0)
      offset2 = 0;
    var index2 = cycleIndex(basePoint.series.index + offset2, this.series.length);
    return this.pointsBySeriesIndex(index2);
  };
  return PlotAreaBase2;
}(ChartElement);
function isSingleAxis(axis) {
  return !axis.pane.axes.some(
    function(a9) {
      return a9.options.vertical === axis.options.vertical && a9 !== axis && a9.options.visible !== false;
    }
  );
}
function axisGroupBox(axes) {
  var length = axes.length;
  var box;
  for (var i16 = 0; i16 < length; i16++) {
    var axis = axes[i16];
    var visible = axis.options.visible !== false;
    if (visible || isSingleAxis(axis)) {
      var axisBox = visible ? axis.contentBox() : axis.lineBox();
      if (!box) {
        box = axisBox.clone();
      } else {
        box.wrap(axisBox);
      }
    }
  }
  return box || new Box();
}
function paneAnchor(axes, pane) {
  for (var i16 = 0; i16 < axes.length; i16++) {
    var anchor = axes[i16];
    if (anchor && anchor.pane === pane) {
      return anchor;
    }
  }
}
function isTransparent(color) {
  return color === "" || color === null || color === "none" || color === "transparent" || !defined(color);
}
var allPaneAxes = function(panes) {
  return panes.reduce(function(acc, pane) {
    return acc.concat(pane.axes);
  }, []);
};
setDefaultOptions(PlotAreaBase, {
  series: [],
  plotArea: {
    margin: {}
  },
  background: "",
  border: {
    color: BLACK$1,
    width: 0
  },
  paneDefaults: {
    title: {}
  },
  legend: {
    inactiveItems: {
      labels: {
        color: "#919191"
      },
      markers: {
        color: "#919191"
      }
    }
  }
});
var PlotAreaEventsMixin = {
  hover: function(chart, e3) {
    this._dispatchEvent(chart, e3, PLOT_AREA_HOVER);
  },
  click: function(chart, e3) {
    this._dispatchEvent(chart, e3, PLOT_AREA_CLICK);
  }
};
var SeriesAggregator = function(Class3) {
  function SeriesAggregator2(series, binder, defaultAggregates) {
    Class3.call(this);
    var canonicalFields = binder.canonicalFields(series);
    var valueFields = binder.valueFields(series);
    var sourceFields = binder.sourceFields(series, canonicalFields);
    var seriesFields = this._seriesFields = [];
    var defaults = defaultAggregates.query(series.type);
    var rootAggregate = series.aggregate || defaults;
    this._series = series;
    this._binder = binder;
    for (var i16 = 0; i16 < canonicalFields.length; i16++) {
      var field = canonicalFields[i16];
      var fieldAggregate = void 0;
      if (isObject(rootAggregate)) {
        fieldAggregate = rootAggregate[field];
      } else if (i16 === 0 || inArray(field, valueFields)) {
        fieldAggregate = rootAggregate;
      } else {
        break;
      }
      if (fieldAggregate) {
        seriesFields.push({
          canonicalName: field,
          name: sourceFields[i16],
          transform: isFunction$1(fieldAggregate) ? fieldAggregate : Aggregates[fieldAggregate]
        });
      }
    }
  }
  if (Class3)
    SeriesAggregator2.__proto__ = Class3;
  SeriesAggregator2.prototype = Object.create(Class3 && Class3.prototype);
  SeriesAggregator2.prototype.constructor = SeriesAggregator2;
  SeriesAggregator2.prototype.aggregatePoints = function aggregatePoints(srcPoints, group2) {
    var this$1$1 = this;
    var ref2 = this;
    var series = ref2._series;
    var seriesFields = ref2._seriesFields;
    var data2 = this._bindPoints(srcPoints || []);
    var firstDataItem = data2.dataItems[0];
    var result = {};
    if (firstDataItem && !isNumber(firstDataItem) && !isArray$1(firstDataItem)) {
      var fn = function() {
      };
      fn.prototype = firstDataItem;
      result = new fn();
    }
    for (var i16 = 0; i16 < seriesFields.length; i16++) {
      var field = seriesFields[i16];
      var srcValues = this$1$1._bindField(data2.values, field.canonicalName);
      var value2 = field.transform(srcValues, series, data2.dataItems, group2);
      if (value2 !== null && isObject(value2) && !defined(value2.length) && !(value2 instanceof Date)) {
        result = value2;
        break;
      } else {
        if (defined(value2)) {
          setValue(field.name, result, value2);
        }
      }
    }
    return result;
  };
  SeriesAggregator2.prototype._bindPoints = function _bindPoints(points2) {
    var ref2 = this;
    var binder = ref2._binder;
    var series = ref2._series;
    var values6 = [];
    var dataItems = [];
    for (var i16 = 0; i16 < points2.length; i16++) {
      var pointIx = points2[i16];
      values6.push(binder.bindPoint(series, pointIx));
      dataItems.push(series.data[pointIx]);
    }
    return {
      values: values6,
      dataItems
    };
  };
  SeriesAggregator2.prototype._bindField = function _bindField(data2, field) {
    var values6 = [];
    var count = data2.length;
    for (var i16 = 0; i16 < count; i16++) {
      var item = data2[i16];
      var valueFields = item.valueFields;
      var value2 = void 0;
      if (defined(valueFields[field])) {
        value2 = valueFields[field];
      } else {
        value2 = item.fields[field];
      }
      values6.push(value2);
    }
    return values6;
  };
  return SeriesAggregator2;
}(Class$1);
function setValue(fieldName, target, value2) {
  var parentObj = target;
  var field = fieldName;
  if (fieldName.indexOf(".") > -1) {
    var parts = fieldName.split(".");
    while (parts.length > 1) {
      field = parts.shift();
      if (!defined(parentObj[field])) {
        parentObj[field] = {};
      }
      parentObj = parentObj[field];
    }
    field = parts.shift();
  }
  parentObj[field] = value2;
}
var DefaultAggregates = function(Class3) {
  function DefaultAggregates2() {
    Class3.call(this);
    this._defaults = {};
  }
  if (Class3)
    DefaultAggregates2.__proto__ = Class3;
  DefaultAggregates2.prototype = Object.create(Class3 && Class3.prototype);
  DefaultAggregates2.prototype.constructor = DefaultAggregates2;
  DefaultAggregates2.prototype.register = function register4(seriesTypes, aggregates2) {
    var this$1$1 = this;
    for (var i16 = 0; i16 < seriesTypes.length; i16++) {
      this$1$1._defaults[seriesTypes[i16]] = aggregates2;
    }
  };
  DefaultAggregates2.prototype.query = function query(seriesType) {
    return this._defaults[seriesType];
  };
  return DefaultAggregates2;
}(Class$1);
DefaultAggregates.current = new DefaultAggregates();
var RangeBar = function(Bar2) {
  function RangeBar2() {
    Bar2.apply(this, arguments);
  }
  if (Bar2)
    RangeBar2.__proto__ = Bar2;
  RangeBar2.prototype = Object.create(Bar2 && Bar2.prototype);
  RangeBar2.prototype.constructor = RangeBar2;
  RangeBar2.prototype.createLabel = function createLabel() {
    var labels = this.options.labels;
    var fromOptions = deepExtend({}, labels, labels.from);
    var toOptions = deepExtend({}, labels, labels.to);
    if (fromOptions.visible) {
      this.labelFrom = this.createLabelElement(fromOptions);
      this.append(this.labelFrom);
    }
    if (toOptions.visible) {
      this.labelTo = this.createLabelElement(toOptions);
      this.append(this.labelTo);
    }
  };
  RangeBar2.prototype.reflow = function reflow(targetBox) {
    this.render();
    var ref2 = this;
    var labelFrom = ref2.labelFrom;
    var labelTo = ref2.labelTo;
    var value2 = ref2.value;
    this.box = targetBox;
    if (labelFrom) {
      labelFrom.options.aboveAxis = value2.from > value2.to;
      labelFrom.reflow(targetBox);
    }
    if (labelTo) {
      labelTo.options.aboveAxis = value2.to > value2.from;
      labelTo.reflow(targetBox);
    }
    if (this.note) {
      this.note.reflow(targetBox);
    }
  };
  return RangeBar2;
}(Bar);
RangeBar.prototype.defaults = deepExtend({}, RangeBar.prototype.defaults, {
  labels: {
    format: "{0} - {1}"
  },
  tooltip: {
    format: "{1}"
  }
});
var RangeBarChart = function(BarChart2) {
  function RangeBarChart2() {
    BarChart2.apply(this, arguments);
  }
  if (BarChart2)
    RangeBarChart2.__proto__ = BarChart2;
  RangeBarChart2.prototype = Object.create(BarChart2 && BarChart2.prototype);
  RangeBarChart2.prototype.constructor = RangeBarChart2;
  RangeBarChart2.prototype.pointType = function pointType() {
    return RangeBar;
  };
  RangeBarChart2.prototype.pointValue = function pointValue(data2) {
    return data2.valueFields;
  };
  RangeBarChart2.prototype.formatPointValue = function formatPointValue(point2, format2) {
    if (point2.value.from === null && point2.value.to === null) {
      return "";
    }
    return this.chartService.format.auto(format2, point2.value.from, point2.value.to);
  };
  RangeBarChart2.prototype.plotRange = function plotRange(point2) {
    if (!point2) {
      return 0;
    }
    return [point2.value.from, point2.value.to];
  };
  RangeBarChart2.prototype.updateRange = function updateRange(value2, fields) {
    var axisName = fields.series.axis;
    var from = value2.from;
    var to = value2.to;
    var axisRange = this.valueAxisRanges[axisName];
    if (value2 !== null && isNumber(from) && isNumber(to)) {
      axisRange = this.valueAxisRanges[axisName] = axisRange || { min: MAX_VALUE, max: MIN_VALUE };
      axisRange.min = Math.min(axisRange.min, from);
      axisRange.max = Math.max(axisRange.max, from);
      axisRange.min = Math.min(axisRange.min, to);
      axisRange.max = Math.max(axisRange.max, to);
    }
  };
  RangeBarChart2.prototype.aboveAxis = function aboveAxis(point2) {
    var value2 = point2.value;
    return value2.from < value2.to;
  };
  return RangeBarChart2;
}(BarChart);
RangeBarChart.prototype.plotLimits = CategoricalChart.prototype.plotLimits;
var RangeLinePoint = function(LinePoint2) {
  function RangeLinePoint2() {
    LinePoint2.apply(this, arguments);
  }
  if (LinePoint2)
    RangeLinePoint2.__proto__ = LinePoint2;
  RangeLinePoint2.prototype = Object.create(LinePoint2 && LinePoint2.prototype);
  RangeLinePoint2.prototype.constructor = RangeLinePoint2;
  RangeLinePoint2.prototype.aliasFor = function aliasFor() {
    return this.parent;
  };
  return RangeLinePoint2;
}(LinePoint);
var AUTO = "auto";
var DEFAULT_FROM_FORMAT = "{0}";
var DEFAULT_TO_FORMAT = "{1}";
var RangeAreaPoint = function(ChartElement2) {
  function RangeAreaPoint2(value2, options2) {
    ChartElement2.call(this);
    this.value = value2;
    this.options = options2;
    this.aboveAxis = valueOrDefault$1(this.options.aboveAxis, true);
    this.tooltipTracking = true;
    this._id = guid();
    this.initLabelsFormat();
  }
  if (ChartElement2)
    RangeAreaPoint2.__proto__ = ChartElement2;
  RangeAreaPoint2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  RangeAreaPoint2.prototype.constructor = RangeAreaPoint2;
  RangeAreaPoint2.prototype.render = function render() {
    if (this._rendered) {
      return;
    }
    this._rendered = true;
    var ref2 = this.options;
    var markers = ref2.markers;
    var labels = ref2.labels;
    var value2 = this.value;
    var fromPoint = this.fromPoint = new RangeLinePoint(value2, deepExtend({}, this.options, {
      labels: labels.from,
      markers: markers.from
    }));
    var toPoint = this.toPoint = new RangeLinePoint(value2, deepExtend({}, this.options, {
      labels: labels.to,
      markers: markers.to
    }));
    this.copyFields(fromPoint);
    this.copyFields(toPoint);
    this.append(fromPoint);
    this.append(toPoint);
  };
  RangeAreaPoint2.prototype.reflow = function reflow(targetBox) {
    this.render();
    var fromBox = targetBox.from;
    var toBox = targetBox.to;
    this.positionLabels(fromBox, toBox);
    this.fromPoint.reflow(fromBox);
    this.toPoint.reflow(toBox);
    this.box = this.fromPoint.markerBox().clone().wrap(this.toPoint.markerBox());
  };
  RangeAreaPoint2.prototype.createHighlight = function createHighlight() {
    var group2 = new Group$9();
    group2.append(this.fromPoint.createHighlight());
    group2.append(this.toPoint.createHighlight());
    return group2;
  };
  RangeAreaPoint2.prototype.highlightVisual = function highlightVisual() {
    return this.visual;
  };
  RangeAreaPoint2.prototype.highlightVisualArgs = function highlightVisualArgs() {
    return {
      options: this.options,
      from: this.fromPoint.highlightVisualArgs(),
      to: this.toPoint.highlightVisualArgs()
    };
  };
  RangeAreaPoint2.prototype.createFocusHighlight = function createFocusHighlight() {
    var group2 = new Group$9();
    group2.append(this.fromPoint.createFocusHighlight());
    group2.append(this.toPoint.createFocusHighlight());
    return group2;
  };
  RangeAreaPoint2.prototype.tooltipAnchor = function tooltipAnchor() {
    var clipBox = this.owner.pane.clipBox();
    var showTooltip = !clipBox || clipBox.overlaps(this.box);
    if (showTooltip) {
      var box = this.box;
      var center = box.center();
      var horizontalAlign = LEFT;
      var x3, y4, verticalAlign;
      if (this.options.vertical) {
        x3 = center.x;
        y4 = box.y1 - TOOLTIP_OFFSET;
        verticalAlign = BOTTOM;
      } else {
        x3 = box.x2 + TOOLTIP_OFFSET;
        y4 = center.y;
        verticalAlign = CENTER;
      }
      return {
        point: new Point$5(x3, y4),
        align: {
          horizontal: horizontalAlign,
          vertical: verticalAlign
        }
      };
    }
  };
  RangeAreaPoint2.prototype.formatValue = function formatValue(format2) {
    return this.owner.formatPointValue(this, format2);
  };
  RangeAreaPoint2.prototype.overlapsBox = function overlapsBox(box) {
    return this.box.overlaps(box);
  };
  RangeAreaPoint2.prototype.unclipElements = function unclipElements() {
    this.fromPoint.unclipElements();
    this.toPoint.unclipElements();
  };
  RangeAreaPoint2.prototype.initLabelsFormat = function initLabelsFormat() {
    var labels = this.options.labels;
    if (!labels.format) {
      if (!labels.from || !labels.from.format) {
        labels.from = Object.assign({}, labels.from, {
          format: DEFAULT_FROM_FORMAT
        });
      }
      if (!labels.to || !labels.to.format) {
        labels.to = Object.assign({}, labels.to, {
          format: DEFAULT_TO_FORMAT
        });
      }
    }
  };
  RangeAreaPoint2.prototype.positionLabels = function positionLabels(fromBox, toBox) {
    var ref2 = this.options;
    var labels = ref2.labels;
    var vertical = ref2.vertical;
    if (labels.position === AUTO) {
      var fromLabelPosition, toLabelPosition;
      if (vertical) {
        if (toBox.y1 <= fromBox.y1) {
          toLabelPosition = ABOVE;
          fromLabelPosition = BELOW;
        } else {
          toLabelPosition = BELOW;
          fromLabelPosition = ABOVE;
        }
      } else {
        if (toBox.x1 <= fromBox.x1) {
          toLabelPosition = LEFT;
          fromLabelPosition = RIGHT;
        } else {
          toLabelPosition = RIGHT;
          fromLabelPosition = LEFT;
        }
      }
      if (!labels.from || !labels.from.position) {
        this.fromPoint.options.labels.position = fromLabelPosition;
      }
      if (!labels.to || !labels.to.position) {
        this.toPoint.options.labels.position = toLabelPosition;
      }
    }
  };
  RangeAreaPoint2.prototype.copyFields = function copyFields(point2) {
    point2.dataItem = this.dataItem;
    point2.category = this.category;
    point2.series = this.series;
    point2.color = this.color;
    point2.owner = this.owner;
  };
  RangeAreaPoint2.prototype.focusVisual = function focusVisual2() {
    this.fromPoint.focusVisual();
  };
  RangeAreaPoint2.prototype.clearFocusFromVisual = function clearFocusFromVisual2() {
    this.toPoint.clearFocusFromVisual();
  };
  RangeAreaPoint2.prototype.getIndex = function getIndex() {
    return this.categoryIx;
  };
  return RangeAreaPoint2;
}(ChartElement);
deepExtend(RangeAreaPoint.prototype, PointEventsMixin);
deepExtend(RangeAreaPoint.prototype, NoteMixin);
RangeAreaPoint.prototype.defaults = {
  markers: {
    visible: false,
    background: WHITE$1,
    size: LINE_MARKER_SIZE,
    type: CIRCLE,
    border: {
      width: 2
    },
    opacity: 1
  },
  labels: {
    visible: false,
    margin: getSpacing(3),
    padding: getSpacing(4),
    animation: {
      type: FADEIN,
      delay: INITIAL_ANIMATION_DURATION
    },
    position: AUTO
  },
  notes: {
    label: {}
  },
  highlight: {
    markers: {
      border: {
        color: WHITE$1,
        width: 2
      }
    },
    zIndex: HIGHLIGHT_ZINDEX
  },
  tooltip: {
    format: "{0} - {1}"
  },
  accessibility: {
    role: CHART_POINT_ROLE,
    className: CHART_POINT_CLASSNAME,
    ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION
  }
};
var RangeAreaSegment = function(AreaSegment2) {
  function RangeAreaSegment2() {
    AreaSegment2.apply(this, arguments);
  }
  if (AreaSegment2)
    RangeAreaSegment2.__proto__ = AreaSegment2;
  RangeAreaSegment2.prototype = Object.create(AreaSegment2 && AreaSegment2.prototype);
  RangeAreaSegment2.prototype.constructor = RangeAreaSegment2;
  RangeAreaSegment2.prototype.createStrokeSegments = function createStrokeSegments() {
    return this.segmentsFromPoints(this.toGeometryPoints(this.toPoints()));
  };
  RangeAreaSegment2.prototype.stackSegments = function stackSegments() {
    var fromSegments = this.fromSegments;
    if (!this.fromSegments) {
      fromSegments = this.fromSegments = this.segmentsFromPoints(this.toGeometryPoints(this.fromPoints().reverse()));
    }
    return fromSegments;
  };
  RangeAreaSegment2.prototype.createStroke = function createStroke(style2) {
    var toPath = new Path$7(style2);
    var fromPath = new Path$7(style2);
    toPath.segments.push.apply(toPath.segments, this.strokeSegments());
    fromPath.segments.push.apply(fromPath.segments, this.stackSegments());
    this.visual.append(toPath);
    this.visual.append(fromPath);
  };
  RangeAreaSegment2.prototype.hasStackSegment = function hasStackSegment() {
    return true;
  };
  RangeAreaSegment2.prototype.fromPoints = function fromPoints() {
    return this.linePoints.map(function(point2) {
      return point2.fromPoint;
    });
  };
  RangeAreaSegment2.prototype.toPoints = function toPoints() {
    return this.linePoints.map(function(point2) {
      return point2.toPoint;
    });
  };
  return RangeAreaSegment2;
}(AreaSegment);
var SplineRangeAreaSegment = function(RangeAreaSegment2) {
  function SplineRangeAreaSegment2() {
    RangeAreaSegment2.apply(this, arguments);
  }
  if (RangeAreaSegment2)
    SplineRangeAreaSegment2.__proto__ = RangeAreaSegment2;
  SplineRangeAreaSegment2.prototype = Object.create(RangeAreaSegment2 && RangeAreaSegment2.prototype);
  SplineRangeAreaSegment2.prototype.constructor = SplineRangeAreaSegment2;
  SplineRangeAreaSegment2.prototype.createStrokeSegments = function createStrokeSegments() {
    return this.createCurveSegments(this.toPoints());
  };
  SplineRangeAreaSegment2.prototype.stackSegments = function stackSegments() {
    var fromSegments = this.fromSegments;
    if (!this.fromSegments) {
      fromSegments = this.fromSegments = this.createCurveSegments(this.fromPoints().reverse());
    }
    return fromSegments;
  };
  SplineRangeAreaSegment2.prototype.createCurveSegments = function createCurveSegments(points2) {
    var curveProcessor = new CurveProcessor();
    return curveProcessor.process(this.toGeometryPoints(points2));
  };
  return SplineRangeAreaSegment2;
}(RangeAreaSegment);
var StepRangeAreaSegment = function(RangeAreaSegment2) {
  function StepRangeAreaSegment2() {
    RangeAreaSegment2.apply(this, arguments);
  }
  if (RangeAreaSegment2)
    StepRangeAreaSegment2.__proto__ = RangeAreaSegment2;
  StepRangeAreaSegment2.prototype = Object.create(RangeAreaSegment2 && RangeAreaSegment2.prototype);
  StepRangeAreaSegment2.prototype.constructor = StepRangeAreaSegment2;
  StepRangeAreaSegment2.prototype.createStrokeSegments = function createStrokeSegments() {
    return this.segmentsFromPoints(this.calculateStepPoints(this.toPoints()));
  };
  StepRangeAreaSegment2.prototype.stackSegments = function stackSegments() {
    var fromSegments = this.fromSegments;
    if (!this.fromSegments) {
      fromSegments = this.fromSegments = this.segmentsFromPoints(this.calculateStepPoints(this.fromPoints()));
      fromSegments.reverse();
    }
    return fromSegments;
  };
  return StepRangeAreaSegment2;
}(RangeAreaSegment);
deepExtend(StepRangeAreaSegment.prototype, StepLineMixin);
var RangeAreaChart = function(CategoricalChart2) {
  function RangeAreaChart2() {
    CategoricalChart2.apply(this, arguments);
  }
  if (CategoricalChart2)
    RangeAreaChart2.__proto__ = CategoricalChart2;
  RangeAreaChart2.prototype = Object.create(CategoricalChart2 && CategoricalChart2.prototype);
  RangeAreaChart2.prototype.constructor = RangeAreaChart2;
  RangeAreaChart2.prototype.render = function render() {
    CategoricalChart2.prototype.render.call(this);
    this.renderSegments();
  };
  RangeAreaChart2.prototype.pointType = function pointType() {
    return RangeAreaPoint;
  };
  RangeAreaChart2.prototype.createPoint = function createPoint(data2, fields) {
    var series = fields.series;
    var seriesIx = fields.seriesIx;
    var value2 = data2.valueFields;
    if (!hasValue$1(value2.from) && !hasValue$1(value2.to)) {
      if (this.seriesMissingValues(series) === ZERO) {
        value2 = {
          from: 0,
          to: 0
        };
      } else {
        return null;
      }
    }
    var pointOptions = this.pointOptions(series, seriesIx);
    pointOptions = this.evalPointOptions(pointOptions, value2, fields);
    var color = data2.fields.color || series.color;
    if (isFunction$1(series.color)) {
      color = pointOptions.color;
    }
    var point2 = new RangeAreaPoint(value2, pointOptions);
    point2.color = color;
    this.append(point2);
    return point2;
  };
  RangeAreaChart2.prototype.createSegment = function createSegment(linePoints, currentSeries, seriesIx) {
    var style2 = (currentSeries.line || {}).style;
    var segmentType2;
    if (style2 === "smooth") {
      segmentType2 = SplineRangeAreaSegment;
    } else if (style2 === "step") {
      segmentType2 = StepRangeAreaSegment;
    } else {
      segmentType2 = RangeAreaSegment;
    }
    return new segmentType2(linePoints, currentSeries, seriesIx);
  };
  RangeAreaChart2.prototype.plotRange = function plotRange(point2, startValue) {
    if (!point2) {
      return [startValue, startValue];
    }
    return [point2.value.from, point2.value.to];
  };
  RangeAreaChart2.prototype.valueSlot = function valueSlot(valueAxis, plotRange) {
    var fromSlot = valueAxis.getSlot(plotRange[0], plotRange[0], !this.options.clip);
    var toSlot = valueAxis.getSlot(plotRange[1], plotRange[1], !this.options.clip);
    if (fromSlot && toSlot) {
      return {
        from: fromSlot,
        to: toSlot
      };
    }
  };
  RangeAreaChart2.prototype.pointSlot = function pointSlot(categorySlot, valueSlot) {
    var from = valueSlot.from;
    var to = valueSlot.to;
    var fromSlot, toSlot;
    if (this.options.invertAxes) {
      fromSlot = new Box(from.x1, categorySlot.y1, from.x2, categorySlot.y2);
      toSlot = new Box(to.x1, categorySlot.y1, to.x2, categorySlot.y2);
    } else {
      fromSlot = new Box(categorySlot.x1, from.y1, categorySlot.x2, from.y2);
      toSlot = new Box(categorySlot.x1, to.y1, categorySlot.x2, to.y2);
    }
    return {
      from: fromSlot,
      to: toSlot
    };
  };
  RangeAreaChart2.prototype.addValue = function addValue(data2, fields) {
    var valueFields = data2.valueFields;
    if (!isNumber(valueFields.from)) {
      valueFields.from = valueFields.to;
    }
    if (!isNumber(valueFields.to)) {
      valueFields.to = valueFields.from;
    }
    CategoricalChart2.prototype.addValue.call(this, data2, fields);
  };
  RangeAreaChart2.prototype.updateRange = function updateRange(value2, fields) {
    if (value2 !== null && isNumber(value2.from) && isNumber(value2.to)) {
      var axisName = fields.series.axis;
      var axisRange = this.valueAxisRanges[axisName] = this.valueAxisRanges[axisName] || { min: MAX_VALUE, max: MIN_VALUE };
      var from = value2.from;
      var to = value2.to;
      axisRange.min = Math.min(axisRange.min, from, to);
      axisRange.max = Math.max(axisRange.max, from, to);
    }
  };
  RangeAreaChart2.prototype.formatPointValue = function formatPointValue(point2, format2) {
    var value2 = point2.value;
    return this.chartService.format.auto(format2, value2.from, value2.to);
  };
  RangeAreaChart2.prototype.animationPoints = function animationPoints() {
    var points2 = this.points;
    var result = [];
    for (var idx = 0; idx < points2.length; idx++) {
      var point2 = points2[idx];
      if (point2) {
        result.push((point2.fromPoint || {}).marker);
        result.push((point2.toPoint || {}).marker);
      }
    }
    return result.concat(this._segments);
  };
  return RangeAreaChart2;
}(CategoricalChart);
deepExtend(RangeAreaChart.prototype, LineChartMixin, ClipAnimationMixin);
var OHLCPoint = function(Candlestick2) {
  function OHLCPoint2() {
    Candlestick2.apply(this, arguments);
  }
  if (Candlestick2)
    OHLCPoint2.__proto__ = Candlestick2;
  OHLCPoint2.prototype = Object.create(Candlestick2 && Candlestick2.prototype);
  OHLCPoint2.prototype.constructor = OHLCPoint2;
  OHLCPoint2.prototype.reflow = function reflow(box) {
    var ref2 = this;
    var options2 = ref2.options;
    var value2 = ref2.value;
    var chart = ref2.owner;
    var valueAxis = chart.seriesValueAxis(options2);
    var oPoints = [];
    var cPoints = [];
    var lhPoints = [];
    var lhSlot = valueAxis.getSlot(value2.low, value2.high);
    var oSlot = valueAxis.getSlot(value2.open, value2.open);
    var cSlot = valueAxis.getSlot(value2.close, value2.close);
    oSlot.x1 = cSlot.x1 = lhSlot.x1 = box.x1;
    oSlot.x2 = cSlot.x2 = lhSlot.x2 = box.x2;
    var mid = lhSlot.center().x;
    oPoints.push([oSlot.x1, oSlot.y1]);
    oPoints.push([mid, oSlot.y1]);
    cPoints.push([mid, cSlot.y1]);
    cPoints.push([cSlot.x2, cSlot.y1]);
    lhPoints.push([mid, lhSlot.y1]);
    lhPoints.push([mid, lhSlot.y2]);
    this.lines = [
      oPoints,
      cPoints,
      lhPoints
    ];
    this.box = lhSlot.clone().wrap(oSlot.clone().wrap(cSlot));
    this.reflowNote();
  };
  OHLCPoint2.prototype.createBody = function createBody() {
  };
  return OHLCPoint2;
}(Candlestick);
var OHLCChart = function(CandlestickChart2) {
  function OHLCChart2() {
    CandlestickChart2.apply(this, arguments);
  }
  if (CandlestickChart2)
    OHLCChart2.__proto__ = CandlestickChart2;
  OHLCChart2.prototype = Object.create(CandlestickChart2 && CandlestickChart2.prototype);
  OHLCChart2.prototype.constructor = OHLCChart2;
  OHLCChart2.prototype.pointType = function pointType() {
    return OHLCPoint;
  };
  return OHLCChart2;
}(CandlestickChart);
var WaterfallSegment = function(ChartElement2) {
  function WaterfallSegment2(from, to, series) {
    ChartElement2.call(this);
    this.from = from;
    this.to = to;
    this.series = series;
  }
  if (ChartElement2)
    WaterfallSegment2.__proto__ = ChartElement2;
  WaterfallSegment2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  WaterfallSegment2.prototype.constructor = WaterfallSegment2;
  WaterfallSegment2.prototype.linePoints = function linePoints() {
    var from = this.from;
    var ref2 = this;
    var fromBox = ref2.from.box;
    var toBox = ref2.to.box;
    var points2 = [];
    if (from.isVertical) {
      var y4 = from.aboveAxis ? fromBox.y1 : fromBox.y2;
      points2.push(
        [fromBox.x1, y4],
        [toBox.x2, y4]
      );
    } else {
      var x3 = from.aboveAxis ? fromBox.x2 : fromBox.x1;
      points2.push(
        [x3, fromBox.y1],
        [x3, toBox.y2]
      );
    }
    return points2;
  };
  WaterfallSegment2.prototype.createVisual = function createVisual() {
    ChartElement2.prototype.createVisual.call(this);
    var line = this.series.line || {};
    var path = Path$7.fromPoints(this.linePoints(), {
      stroke: {
        color: line.color,
        width: line.width,
        opacity: line.opacity,
        dashType: line.dashType
      }
    });
    alignPathToPixel(path);
    this.visual.append(path);
  };
  return WaterfallSegment2;
}(ChartElement);
setDefaultOptions(WaterfallSegment, {
  animation: {
    type: FADEIN,
    delay: INITIAL_ANIMATION_DURATION
  }
});
var WaterfallChart = function(BarChart2) {
  function WaterfallChart2() {
    BarChart2.apply(this, arguments);
  }
  if (BarChart2)
    WaterfallChart2.__proto__ = BarChart2;
  WaterfallChart2.prototype = Object.create(BarChart2 && BarChart2.prototype);
  WaterfallChart2.prototype.constructor = WaterfallChart2;
  WaterfallChart2.prototype.render = function render() {
    BarChart2.prototype.render.call(this);
    this.createSegments();
  };
  WaterfallChart2.prototype.traverseDataPoints = function traverseDataPoints(callback) {
    var this$1$1 = this;
    var series = this.options.series;
    var totalCategories = categoriesCount(series);
    var isVertical = !this.options.invertAxes;
    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {
      var currentSeries = series[seriesIx];
      var total3 = 0;
      var runningTotal = 0;
      for (var categoryIx = 0; categoryIx < totalCategories; categoryIx++) {
        var data2 = SeriesBinder.current.bindPoint(currentSeries, categoryIx);
        var value2 = data2.valueFields.value;
        var summary = data2.fields.summary;
        var from = total3;
        var to = void 0;
        if (summary) {
          if (summary.toLowerCase() === "total") {
            data2.valueFields.value = total3;
            from = 0;
            to = total3;
          } else {
            data2.valueFields.value = runningTotal;
            to = from - runningTotal;
            runningTotal = 0;
          }
        } else if (isNumber(value2)) {
          runningTotal += value2;
          total3 += value2;
          to = total3;
        }
        callback(data2, {
          category: this$1$1.categoryAxis.categoryAt(categoryIx),
          categoryIx,
          series: currentSeries,
          seriesIx,
          total: total3,
          runningTotal,
          from,
          to,
          isVertical
        });
      }
    }
  };
  WaterfallChart2.prototype.updateRange = function updateRange(value2, fields) {
    BarChart2.prototype.updateRange.call(this, { value: fields.to }, fields);
  };
  WaterfallChart2.prototype.aboveAxis = function aboveAxis(point2) {
    return point2.value >= 0;
  };
  WaterfallChart2.prototype.plotRange = function plotRange(point2) {
    return [point2.from, point2.to];
  };
  WaterfallChart2.prototype.createSegments = function createSegments() {
    var this$1$1 = this;
    var series = this.options.series;
    var seriesPoints = this.seriesPoints;
    var segments = this.segments = [];
    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {
      var currentSeries = series[seriesIx];
      var points2 = seriesPoints[seriesIx];
      if (points2) {
        var prevPoint = void 0;
        for (var pointIx = 0; pointIx < points2.length; pointIx++) {
          var point2 = points2[pointIx];
          if (point2 && prevPoint) {
            var segment = new WaterfallSegment(prevPoint, point2, currentSeries);
            segments.push(segment);
            this$1$1.append(segment);
          }
          prevPoint = point2;
        }
      }
    }
  };
  return WaterfallChart2;
}(BarChart);
function trendlineFactory(registry2, type, context2) {
  var impl = registry2[String(type)];
  if (impl) {
    return impl(context2);
  }
  return null;
}
function calculateSlope(sourceValues, valueGetter2) {
  var x3 = 0;
  var y4 = 0;
  var x22 = 0;
  var xy = 0;
  var count = 0;
  var slope, intercept;
  var xMin = Number.MAX_VALUE;
  var xMax = Number.MIN_VALUE;
  for (var i16 = 0; i16 < sourceValues.length; i16++) {
    var value2 = sourceValues[i16];
    var ref2 = valueGetter2(value2);
    var xValue = ref2.xValue;
    var yValue = ref2.yValue;
    if (isFinite(xValue) && xValue !== null && isFinite(yValue) && yValue !== null) {
      xMin = Math.min(xValue, xMin);
      xMax = Math.max(xValue, xMax);
      count++;
      x3 += xValue;
      y4 += yValue;
      x22 += Math.pow(xValue, 2);
      xy += xValue * yValue;
    }
  }
  if (count > 0) {
    slope = (count * xy - x3 * y4) / (count * x22 - Math.pow(x3, 2));
    intercept = (y4 - slope * x3) / count;
  }
  return { slope, intercept, count, xMin, xMax };
}
var checkAllPositive = function(sourceValues, fieldName) {
  return sourceValues.every(function(ref2) {
    var valueFields = ref2.valueFields;
    return !hasValue$1(valueFields[fieldName]) || valueFields[fieldName] > 0;
  });
};
function getTrendlineData(valueMapper, categoryAxis) {
  var data2 = [];
  var totalRange = categoryAxis.totalRangeIndices();
  var currentRange = categoryAxis.currentRangeIndices();
  var range = {
    min: Math.floor(Math.max(currentRange.min - 1, totalRange.min)),
    max: Math.ceil(Math.min(currentRange.max + 2, totalRange.max))
  };
  for (var i16 = range.min; i16 < range.max; i16++) {
    var x3 = i16 + 1;
    data2[i16] = {
      category: categoryAxis.categoryAt(i16, true),
      value: valueMapper(x3)
    };
  }
  return data2;
}
function exponentialTrendline(context2) {
  var options2 = context2.options;
  var categoryAxis = context2.categoryAxis;
  var seriesValues = context2.seriesValues;
  var data2 = getData$b({ seriesValues, categoryAxis, options: options2 });
  if (data2) {
    return Object.assign(
      {},
      options2,
      {
        type: "line",
        data: data2,
        categoryField: "category",
        field: "value"
      }
    );
  }
  return null;
}
var valueGetter$8 = function(fieldName) {
  return function(ref2) {
    var categoryIx = ref2.categoryIx;
    var valueFields = ref2.valueFields;
    return { xValue: categoryIx + 1, yValue: Math.log(valueFields[fieldName]) };
  };
};
function getData$b(ref2) {
  var seriesValues = ref2.seriesValues;
  var categoryAxis = ref2.categoryAxis;
  var options2 = ref2.options;
  var sourceValues = seriesValues();
  if (!checkAllPositive(sourceValues, options2.field)) {
    return null;
  }
  var ref$1 = calculateSlope(sourceValues, valueGetter$8(options2.field));
  var slope = ref$1.slope;
  var intercept = ref$1.intercept;
  var count = ref$1.count;
  if (count > 0) {
    var a9 = Math.exp(intercept);
    var b2 = slope;
    return getTrendlineData(function(x3) {
      return a9 * Math.exp(b2 * x3);
    }, categoryAxis);
  }
  return null;
}
function linearTrendline(context2) {
  var options2 = context2.options;
  var categoryAxis = context2.categoryAxis;
  var seriesValues = context2.seriesValues;
  var data2 = getData$a({ seriesValues, categoryAxis, options: options2 });
  if (data2) {
    return Object.assign(
      {},
      options2,
      {
        type: "line",
        data: data2,
        categoryField: "category",
        field: "value"
      }
    );
  }
  return null;
}
var valueGetter$7 = function(fieldName) {
  return function(ref2) {
    var categoryIx = ref2.categoryIx;
    var valueFields = ref2.valueFields;
    return { xValue: categoryIx + 1, yValue: valueFields[fieldName] };
  };
};
function getData$a(ref2) {
  var seriesValues = ref2.seriesValues;
  var categoryAxis = ref2.categoryAxis;
  var options2 = ref2.options;
  var ref$1 = calculateSlope(seriesValues(), valueGetter$7(options2.field));
  var slope = ref$1.slope;
  var intercept = ref$1.intercept;
  var count = ref$1.count;
  if (count > 0) {
    return getTrendlineData(function(x3) {
      return slope * x3 + intercept;
    }, categoryAxis);
  }
  return null;
}
function logarithmicTrendline(context2) {
  var options2 = context2.options;
  var categoryAxis = context2.categoryAxis;
  var seriesValues = context2.seriesValues;
  var data2 = getData$9({ seriesValues, categoryAxis, options: options2 });
  if (data2) {
    return Object.assign(
      {},
      options2,
      {
        type: "line",
        data: data2,
        categoryField: "category",
        field: "value"
      }
    );
  }
  return null;
}
var valueGetter$6 = function(fieldName) {
  return function(ref2) {
    var categoryIx = ref2.categoryIx;
    var valueFields = ref2.valueFields;
    return { xValue: Math.log(categoryIx + 1), yValue: valueFields[fieldName] };
  };
};
function getData$9(ref2) {
  var seriesValues = ref2.seriesValues;
  var categoryAxis = ref2.categoryAxis;
  var options2 = ref2.options;
  var ref$1 = calculateSlope(seriesValues(), valueGetter$6(options2.field));
  var slope = ref$1.slope;
  var intercept = ref$1.intercept;
  var count = ref$1.count;
  if (count > 0) {
    var a9 = slope;
    var b2 = intercept;
    return getTrendlineData(function(x3) {
      return a9 * Math.log(x3) + b2;
    }, categoryAxis);
  }
  return null;
}
function calculateMovingAverage(sourceValues, valueGetter2, period) {
  var averagePoints = [];
  var values6 = [];
  var start = Math.max(MIN_MOVING_AVERAGE_PERIOD, period) - 1;
  var end = 0;
  var sum2 = 0;
  for (var i16 = 0; i16 < sourceValues.length; i16++) {
    var value2 = sourceValues[i16];
    var ref2 = valueGetter2(value2);
    var xValue = ref2.xValue;
    var yValue = ref2.yValue;
    if (isFinite(yValue) && yValue !== null) {
      values6.push(yValue);
      sum2 += yValue;
      end = Math.max(i16, end);
    } else {
      values6.push(null);
    }
    if (i16 >= start) {
      var count = values6.filter(function(value3) {
        return value3 !== null;
      }).length;
      var lastValue = values6.shift() || 0;
      if (count > 0) {
        var average = sum2 / count;
        averagePoints.push([xValue, average]);
        sum2 -= lastValue;
        continue;
      }
    }
    averagePoints.push([xValue, null]);
  }
  return averagePoints.slice(0, end + 1);
}
function movingAverageTrendline(context2) {
  var options2 = context2.options;
  var data2 = getData$8(context2);
  if (data2) {
    return Object.assign(
      {},
      options2,
      {
        type: "line",
        data: data2,
        categoryField: "category",
        field: "value"
      }
    );
  }
  return null;
}
var valueGetter$5 = function(fieldName) {
  return function(ref2) {
    var categoryIx = ref2.categoryIx;
    var valueFields = ref2.valueFields;
    return { xValue: categoryIx, yValue: valueFields[fieldName] };
  };
};
function calculatePoints(ref2) {
  var options2 = ref2.options;
  var categoryAxis = ref2.categoryAxis;
  var seriesValues = ref2.seriesValues;
  var period = (options2.trendline || {}).period || MIN_MOVING_AVERAGE_PERIOD;
  var totalRange = categoryAxis.totalRangeIndices();
  var currentRange = categoryAxis.currentRangeIndices();
  var range = {
    min: Math.floor(Math.max(currentRange.min - period, totalRange.min)),
    max: Math.ceil(Math.min(currentRange.max + period + 2, totalRange.max))
  };
  return calculateMovingAverage(seriesValues(range), valueGetter$5(options2.field), period);
}
function getData$8(context2) {
  var categoryAxis = context2.categoryAxis;
  var points2 = calculatePoints(context2);
  var data2 = [];
  points2.forEach(function(ref2) {
    var categoryIx = ref2[0];
    var value2 = ref2[1];
    data2[categoryIx] = {
      category: categoryAxis.categoryAt(categoryIx, true),
      value: value2
    };
  });
  if (data2.length > 0) {
    return data2;
  }
  return null;
}
var MIN_ORDER = 1;
var MAX_ORDER = 6;
function calculatePolynomial(sourceValues, valueGetter2, order) {
  var k3 = Math.min(Math.max(order || MIN_ORDER, MIN_ORDER), MAX_ORDER) + 1;
  var X2 = new Matrix();
  var Y2 = new Matrix();
  var count = 0;
  var xMin = Number.MAX_VALUE;
  var xMax = Number.MIN_VALUE;
  var valueMapper = function(x3) {
    return x3;
  };
  var coefficients = [];
  for (var i16 = 0; i16 < sourceValues.length; i16++) {
    var value2 = sourceValues[i16];
    var ref2 = valueGetter2(value2);
    var xValue = ref2.xValue;
    var yValue = ref2.yValue;
    if (isFinite(xValue) && xValue !== null && isFinite(yValue) && yValue !== null) {
      xMin = Math.min(xValue, xMin);
      xMax = Math.max(xValue, xMax);
      count++;
      Y2.set(i16, 0, yValue);
      X2.set(i16, 0, 1);
      X2.set(i16, 1, xValue);
      for (var pow2 = 2; pow2 <= k3; pow2++) {
        X2.set(i16, pow2, Math.pow(X2.get(i16, 1), pow2));
      }
    } else {
      X2.set(i16, 0, 0);
    }
  }
  X2.width = Math.min(k3, count);
  if (count > 0) {
    coefficients = linearRegression(X2, Y2);
    valueMapper = function(x3) {
      return coefficients.reduce(function(y4, a9, n10) {
        return y4 + a9 * Math.pow(x3, n10);
      }, 0);
    };
  }
  return {
    coefficients,
    count,
    valueMapper,
    xMin,
    xMax
  };
}
function linearRegression(X2, Y2) {
  var Xt = X2.transpose();
  var B2 = Xt.multiply(X2).inverse().multiply(Xt).multiply(Y2);
  var coefficients = [];
  for (var i16 = 0; i16 < B2.height; i16++) {
    coefficients.push(B2.get(i16, 0));
  }
  return coefficients;
}
function polynomialTrendline(context2) {
  var options2 = context2.options;
  var categoryAxis = context2.categoryAxis;
  var seriesValues = context2.seriesValues;
  var data2 = getData$7({ seriesValues, categoryAxis, options: options2 });
  if (data2) {
    return Object.assign(
      {},
      options2,
      {
        type: "line",
        data: data2,
        categoryField: "category",
        field: "value"
      }
    );
  }
  return null;
}
var valueGetter$4 = function(fieldName) {
  return function(ref2) {
    var categoryIx = ref2.categoryIx;
    var valueFields = ref2.valueFields;
    return { xValue: categoryIx + 1, yValue: valueFields[fieldName] };
  };
};
function getData$7(ref2) {
  var seriesValues = ref2.seriesValues;
  var categoryAxis = ref2.categoryAxis;
  var options2 = ref2.options;
  var order = (options2.trendline || {}).order;
  var ref$1 = calculatePolynomial(seriesValues(), valueGetter$4(options2.field), order);
  var count = ref$1.count;
  var valueMapper = ref$1.valueMapper;
  if (count > 0) {
    return getTrendlineData(function(x3) {
      return valueMapper(x3);
    }, categoryAxis);
  }
  return null;
}
function powerTrendline(context2) {
  var options2 = context2.options;
  var categoryAxis = context2.categoryAxis;
  var seriesValues = context2.seriesValues;
  var data2 = getData$6({ seriesValues, categoryAxis, options: options2 });
  if (data2) {
    return Object.assign(
      {},
      options2,
      {
        type: "line",
        data: data2,
        categoryField: "category",
        field: "value"
      }
    );
  }
  return null;
}
var valueGetter$3 = function(fieldName) {
  return function(ref2) {
    var categoryIx = ref2.categoryIx;
    var valueFields = ref2.valueFields;
    return { xValue: Math.log(categoryIx + 1), yValue: Math.log(valueFields[fieldName]) };
  };
};
function getData$6(ref2) {
  var seriesValues = ref2.seriesValues;
  var categoryAxis = ref2.categoryAxis;
  var options2 = ref2.options;
  var sourceValues = seriesValues();
  if (!checkAllPositive(sourceValues, options2.field)) {
    return null;
  }
  var ref$1 = calculateSlope(sourceValues, valueGetter$3(options2.field));
  var slope = ref$1.slope;
  var intercept = ref$1.intercept;
  var count = ref$1.count;
  if (count > 0) {
    var a9 = Math.exp(intercept);
    var b2 = slope;
    return getTrendlineData(function(x3) {
      return a9 * Math.pow(x3, b2);
    }, categoryAxis);
  }
  return null;
}
var registry = {};
registry[TRENDLINE_EXPONENTIAL] = exponentialTrendline;
registry[TRENDLINE_LINEAR] = linearTrendline;
registry[TRENDLINE_LOGARITHMIC] = logarithmicTrendline;
registry[TRENDLINE_MOVING_AVERAGE] = movingAverageTrendline;
registry[TRENDLINE_POLYNOMIAL] = polynomialTrendline;
registry[TRENDLINE_POWER] = powerTrendline;
var AREA_SERIES = [AREA, VERTICAL_AREA, RANGE_AREA, VERTICAL_RANGE_AREA];
var OUT_OF_RANGE_SERIES = [LINE, VERTICAL_LINE].concat(AREA_SERIES);
var CategoricalPlotArea = function(PlotAreaBase2) {
  function CategoricalPlotArea2() {
    PlotAreaBase2.apply(this, arguments);
  }
  if (PlotAreaBase2)
    CategoricalPlotArea2.__proto__ = PlotAreaBase2;
  CategoricalPlotArea2.prototype = Object.create(PlotAreaBase2 && PlotAreaBase2.prototype);
  CategoricalPlotArea2.prototype.constructor = CategoricalPlotArea2;
  CategoricalPlotArea2.prototype.initFields = function initFields(series) {
    var this$1$1 = this;
    this.namedCategoryAxes = {};
    this.namedValueAxes = {};
    this.valueAxisRangeTracker = new AxisGroupRangeTracker();
    this._seriesPointsCache = {};
    this._currentPointsCache = {};
    if (series.length > 0) {
      this.invertAxes = inArray(
        series[0].type,
        [
          BAR,
          BULLET,
          VERTICAL_LINE,
          VERTICAL_AREA,
          VERTICAL_RANGE_AREA,
          RANGE_BAR,
          HORIZONTAL_WATERFALL,
          VERTICAL_BOX_PLOT
        ]
      );
      for (var i16 = 0; i16 < series.length; i16++) {
        var stack = series[i16].stack;
        if (stack && stack.type === "100%") {
          this$1$1.stack100 = true;
          break;
        }
      }
    }
  };
  CategoricalPlotArea2.prototype.render = function render(panes) {
    if (panes === void 0)
      panes = this.panes;
    this.series = [].concat(this.originalSeries);
    this.createCategoryAxes(panes);
    this.aggregateCategories(panes);
    this.createTrendlineSeries(panes);
    this.createCategoryAxesLabels(panes);
    this.createCharts(panes);
    this.createValueAxes(panes);
  };
  CategoricalPlotArea2.prototype.removeAxis = function removeAxis(axis) {
    var axisName = axis.options.name;
    PlotAreaBase2.prototype.removeAxis.call(this, axis);
    if (axis instanceof CategoryAxis) {
      delete this.namedCategoryAxes[axisName];
    } else {
      this.valueAxisRangeTracker.reset(axisName);
      delete this.namedValueAxes[axisName];
    }
    if (axis === this.categoryAxis) {
      delete this.categoryAxis;
    }
    if (axis === this.valueAxis) {
      delete this.valueAxis;
    }
  };
  CategoricalPlotArea2.prototype.trendlineFactory = function trendlineFactory$1(options2, series) {
    var categoryAxis = this.seriesCategoryAxis(options2);
    var seriesValues = this.seriesValues.bind(this, series.index);
    var trendline = trendlineFactory(registry, options2.type, {
      options: options2,
      categoryAxis,
      seriesValues
    });
    if (trendline) {
      trendline.categoryAxis = series.categoryAxis;
      trendline.valueAxis = series.valueAxis;
      return this.filterSeries(trendline, categoryAxis);
    }
    return trendline;
  };
  CategoricalPlotArea2.prototype.trendlineAggregateForecast = function trendlineAggregateForecast() {
    return this.series.map(function(series) {
      return (series.trendline || {}).forecast;
    }).filter(function(forecast) {
      return forecast !== void 0;
    }).reduce(function(result, forecast) {
      return {
        before: Math.max(result.before, forecast.before || 0),
        after: Math.max(result.after, forecast.after || 0)
      };
    }, { before: 0, after: 0 });
  };
  CategoricalPlotArea2.prototype.seriesValues = function seriesValues(seriesIx, range) {
    var this$1$1 = this;
    var result = [];
    var series = this.srcSeries[seriesIx];
    var categoryAxis = this.seriesCategoryAxis(series);
    var dateAxis = equalsIgnoreCase(categoryAxis.options.type, DATE);
    if (dateAxis) {
      this._seriesPointsCache = {};
      this._currentPointsCache = {};
      categoryAxis.options.dataItems = [];
      series = this.aggregateSeries(series, categoryAxis, categoryAxis.totalRangeIndices());
    }
    var min2 = range ? range.min : 0;
    var max2 = range ? range.max : series.data.length;
    for (var categoryIx = min2; categoryIx < max2; categoryIx++) {
      var data2 = this$1$1.bindPoint(series, categoryIx);
      result.push({ categoryIx, category: data2.fields.category, valueFields: data2.valueFields });
    }
    return result;
  };
  CategoricalPlotArea2.prototype.createCharts = function createCharts(panes) {
    var this$1$1 = this;
    var seriesByPane = this.groupSeriesByPane();
    for (var i16 = 0; i16 < panes.length; i16++) {
      var pane = panes[i16];
      var paneSeries = seriesByPane[pane.options.name || "default"] || [];
      this$1$1.addToLegend(paneSeries);
      var visibleSeries = this$1$1.filterVisibleSeries(paneSeries);
      if (!visibleSeries) {
        continue;
      }
      var groups = this$1$1.groupSeriesByCategoryAxis(visibleSeries);
      for (var groupIx = 0; groupIx < groups.length; groupIx++) {
        this$1$1.createChartGroup(groups[groupIx], pane);
      }
    }
  };
  CategoricalPlotArea2.prototype.createChartGroup = function createChartGroup(series, pane) {
    this.createAreaChart(
      filterSeriesByType(series, [AREA, VERTICAL_AREA]),
      pane
    );
    this.createRangeAreaChart(
      filterSeriesByType(series, [RANGE_AREA, VERTICAL_RANGE_AREA]),
      pane
    );
    this.createBarChart(
      filterSeriesByType(series, [COLUMN, BAR]),
      pane
    );
    this.createRangeBarChart(
      filterSeriesByType(series, [RANGE_COLUMN, RANGE_BAR]),
      pane
    );
    this.createBulletChart(
      filterSeriesByType(series, [BULLET, VERTICAL_BULLET]),
      pane
    );
    this.createCandlestickChart(
      filterSeriesByType(series, CANDLESTICK),
      pane
    );
    this.createBoxPlotChart(
      filterSeriesByType(series, [BOX_PLOT, VERTICAL_BOX_PLOT]),
      pane
    );
    this.createOHLCChart(
      filterSeriesByType(series, OHLC),
      pane
    );
    this.createWaterfallChart(
      filterSeriesByType(series, [WATERFALL, HORIZONTAL_WATERFALL]),
      pane
    );
    this.createLineChart(
      filterSeriesByType(series, [LINE, VERTICAL_LINE]),
      pane
    );
  };
  CategoricalPlotArea2.prototype.aggregateCategories = function aggregateCategories(panes) {
    var this$1$1 = this;
    var series = [].concat(this.series);
    var processedSeries = [];
    this._currentPointsCache = {};
    this._seriesPointsCache = this._seriesPointsCache || {};
    for (var i16 = 0; i16 < series.length; i16++) {
      var currentSeries = series[i16];
      if (!this$1$1.isTrendline(currentSeries)) {
        var categoryAxis = this$1$1.seriesCategoryAxis(currentSeries);
        var axisPane = this$1$1.findPane(categoryAxis.options.pane);
        var dateAxis = equalsIgnoreCase(categoryAxis.options.type, DATE);
        if ((dateAxis || currentSeries.categoryField) && inArray(axisPane, panes)) {
          currentSeries = this$1$1.aggregateSeries(currentSeries, categoryAxis, categoryAxis.currentRangeIndices());
        } else {
          currentSeries = this$1$1.filterSeries(currentSeries, categoryAxis);
        }
      }
      processedSeries.push(currentSeries);
    }
    this._seriesPointsCache = this._currentPointsCache;
    this._currentPointsCache = null;
    this.srcSeries = series;
    this.series = processedSeries;
  };
  CategoricalPlotArea2.prototype.filterSeries = function filterSeries(series, categoryAxis) {
    var dataLength = (series.data || {}).length;
    categoryAxis._seriesMax = Math.max(categoryAxis._seriesMax || 0, dataLength);
    if (!(defined(categoryAxis.options.min) || defined(categoryAxis.options.max))) {
      return series;
    }
    var range = categoryAxis.currentRangeIndices();
    var outOfRangePoints = inArray(series.type, OUT_OF_RANGE_SERIES);
    var currentSeries = deepExtend({}, series);
    currentSeries.data = (currentSeries.data || []).slice(range.min, range.max + 1);
    if (outOfRangePoints) {
      createOutOfRangePoints(currentSeries, range, dataLength, function(idx) {
        return {
          item: series.data[idx],
          category: categoryAxis.categoryAt(idx, true),
          categoryIx: idx - range.min
        };
      }, function(idx) {
        return defined(series.data[idx]);
      });
    }
    return currentSeries;
  };
  CategoricalPlotArea2.prototype.clearSeriesPointsCache = function clearSeriesPointsCache() {
    this._seriesPointsCache = {};
  };
  CategoricalPlotArea2.prototype.seriesSourcePoints = function seriesSourcePoints(series, categoryAxis) {
    var this$1$1 = this;
    var key = series.index + ";" + categoryAxis.categoriesHash();
    if (this._seriesPointsCache && this._seriesPointsCache[key]) {
      this._currentPointsCache[key] = this._seriesPointsCache[key];
      return this._seriesPointsCache[key];
    }
    var axisOptions2 = categoryAxis.options;
    var srcCategories = axisOptions2.srcCategories;
    var dateAxis = equalsIgnoreCase(axisOptions2.type, DATE);
    var srcData = series.data;
    var result = [];
    if (!dateAxis) {
      categoryAxis.indexCategories();
    }
    for (var idx = 0; idx < srcData.length; idx++) {
      var category = SeriesBinder.current.bindPoint(series, idx).fields.category;
      if (dateAxis) {
        category = parseDateCategory(category, srcData[idx], this$1$1.chartService.intl);
      }
      if (!defined(category)) {
        category = srcCategories[idx];
      }
      if (defined(category) && category !== null) {
        var categoryIx = categoryAxis.totalIndex(category);
        result[categoryIx] = result[categoryIx] || { items: [], category };
        result[categoryIx].items.push(idx);
      }
    }
    this._currentPointsCache[key] = result;
    return result;
  };
  CategoricalPlotArea2.prototype.aggregateSeries = function aggregateSeries(series, categoryAxis, range) {
    var srcData = series.data;
    if (!srcData.length) {
      return series;
    }
    var srcPoints = this.seriesSourcePoints(series, categoryAxis);
    var result = deepExtend({}, series);
    var aggregator = new SeriesAggregator(deepExtend({}, series), SeriesBinder.current, DefaultAggregates.current);
    var data2 = result.data = [];
    var dataItems = categoryAxis.options.dataItems || [];
    var categoryItem = function(idx2) {
      var categoryIdx = idx2 - range.min;
      var point3 = srcPoints[idx2];
      if (!point3) {
        point3 = srcPoints[idx2] = {};
      }
      point3.categoryIx = categoryIdx;
      if (!point3.item) {
        var category = categoryAxis.categoryAt(idx2, true);
        point3.category = category;
        point3.item = aggregator.aggregatePoints(point3.items, category);
      }
      return point3;
    };
    for (var idx = range.min; idx <= range.max; idx++) {
      var point2 = categoryItem(idx);
      data2[point2.categoryIx] = point2.item;
      if (point2.items && point2.items.length) {
        dataItems[point2.categoryIx] = point2.item;
      }
    }
    if (inArray(result.type, OUT_OF_RANGE_SERIES)) {
      createOutOfRangePoints(result, range, categoryAxis.totalCount(), categoryItem, function(idx2) {
        return srcPoints[idx2];
      });
    }
    categoryAxis.options.dataItems = dataItems;
    return result;
  };
  CategoricalPlotArea2.prototype.appendChart = function appendChart(chart, pane) {
    var series = chart.options.series;
    var categoryAxis = this.seriesCategoryAxis(series[0]);
    var categories = categoryAxis.options.categories;
    var categoriesToAdd = Math.max(0, categoriesCount(series) - categories.length);
    if (categoriesToAdd > 0) {
      categories = categoryAxis.options.categories = categoryAxis.options.categories.slice(0);
      while (categoriesToAdd--) {
        categories.push("");
      }
    }
    this.valueAxisRangeTracker.update(chart.valueAxisRanges);
    PlotAreaBase2.prototype.appendChart.call(this, chart, pane);
  };
  CategoricalPlotArea2.prototype.seriesPaneName = function seriesPaneName(series) {
    var options2 = this.options;
    var axisName = series.axis;
    var axisOptions2 = [].concat(options2.valueAxis);
    var axis = grep(axisOptions2, function(a9) {
      return a9.name === axisName;
    })[0];
    var panes = options2.panes || [{}];
    var defaultPaneName = (panes[0] || {}).name || "default";
    var paneName = (axis || {}).pane || defaultPaneName;
    return paneName;
  };
  CategoricalPlotArea2.prototype.seriesCategoryAxis = function seriesCategoryAxis(series) {
    var axisName = series.categoryAxis;
    var axis = axisName ? this.namedCategoryAxes[axisName] : this.categoryAxis;
    if (!axis) {
      throw new Error("Unable to locate category axis with name " + axisName);
    }
    return axis;
  };
  CategoricalPlotArea2.prototype.stackableChartOptions = function stackableChartOptions(series, pane) {
    var anyStackedSeries = series.some(function(s10) {
      return s10.stack;
    });
    var isStacked100 = series.some(function(s10) {
      return s10.stack && s10.stack.type === "100%";
    });
    var clip = pane.options.clip;
    return {
      defaultStack: series[0].stack,
      isStacked: anyStackedSeries,
      isStacked100,
      clip
    };
  };
  CategoricalPlotArea2.prototype.groupSeriesByCategoryAxis = function groupSeriesByCategoryAxis(series) {
    var categoryAxes = [];
    var unique = {};
    for (var idx = 0; idx < series.length; idx++) {
      var name2 = series[idx].categoryAxis || "$$default$$";
      if (!hasOwnProperty(unique, name2)) {
        unique[name2] = true;
        categoryAxes.push(name2);
      }
    }
    var groups = [];
    for (var axisIx = 0; axisIx < categoryAxes.length; axisIx++) {
      var axis = categoryAxes[axisIx];
      var axisSeries = groupSeries(series, axis, axisIx);
      if (axisSeries.length === 0) {
        continue;
      }
      groups.push(axisSeries);
    }
    return groups;
  };
  CategoricalPlotArea2.prototype.createBarChart = function createBarChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var firstSeries = series[0];
    var barChart = new BarChart(this, Object.assign({
      series,
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      spacing: firstSeries.spacing
    }, this.stackableChartOptions(series, pane)));
    this.appendChart(barChart, pane);
  };
  CategoricalPlotArea2.prototype.createRangeBarChart = function createRangeBarChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var firstSeries = series[0];
    var rangeColumnChart = new RangeBarChart(this, {
      series,
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      spacing: firstSeries.spacing
    });
    this.appendChart(rangeColumnChart, pane);
  };
  CategoricalPlotArea2.prototype.createBulletChart = function createBulletChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var firstSeries = series[0];
    var bulletChart = new BulletChart(this, {
      series,
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      spacing: firstSeries.spacing,
      clip: pane.options.clip
    });
    this.appendChart(bulletChart, pane);
  };
  CategoricalPlotArea2.prototype.createLineChart = function createLineChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var lineChart = new LineChart(this, Object.assign({
      invertAxes: this.invertAxes,
      series
    }, this.stackableChartOptions(series, pane)));
    this.appendChart(lineChart, pane);
  };
  CategoricalPlotArea2.prototype.createAreaChart = function createAreaChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var areaChart = new AreaChart(this, Object.assign({
      invertAxes: this.invertAxes,
      series
    }, this.stackableChartOptions(series, pane)));
    this.appendChart(areaChart, pane);
  };
  CategoricalPlotArea2.prototype.createRangeAreaChart = function createRangeAreaChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var rangeAreaChart = new RangeAreaChart(this, {
      invertAxes: this.invertAxes,
      series,
      clip: pane.options.clip
    });
    this.appendChart(rangeAreaChart, pane);
  };
  CategoricalPlotArea2.prototype.createOHLCChart = function createOHLCChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var firstSeries = series[0];
    var chart = new OHLCChart(this, {
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      series,
      spacing: firstSeries.spacing,
      clip: pane.options.clip
    });
    this.appendChart(chart, pane);
  };
  CategoricalPlotArea2.prototype.createCandlestickChart = function createCandlestickChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var firstSeries = series[0];
    var chart = new CandlestickChart(this, {
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      series,
      spacing: firstSeries.spacing,
      clip: pane.options.clip
    });
    this.appendChart(chart, pane);
  };
  CategoricalPlotArea2.prototype.createBoxPlotChart = function createBoxPlotChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var firstSeries = series[0];
    var chart = new BoxPlotChart(this, {
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      series,
      spacing: firstSeries.spacing,
      clip: pane.options.clip
    });
    this.appendChart(chart, pane);
  };
  CategoricalPlotArea2.prototype.createWaterfallChart = function createWaterfallChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var firstSeries = series[0];
    var waterfallChart = new WaterfallChart(this, {
      series,
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      spacing: firstSeries.spacing
    });
    this.appendChart(waterfallChart, pane);
  };
  CategoricalPlotArea2.prototype.axisRequiresRounding = function axisRequiresRounding(categoryAxisName, categoryAxisIndex) {
    var this$1$1 = this;
    var centeredSeries = filterSeriesByType(this.series, EQUALLY_SPACED_SERIES);
    for (var seriesIx = 0; seriesIx < this.series.length; seriesIx++) {
      var currentSeries = this$1$1.series[seriesIx];
      if (inArray(currentSeries.type, AREA_SERIES)) {
        var line = currentSeries.line;
        if (line && line.style === STEP) {
          centeredSeries.push(currentSeries);
        }
      }
    }
    for (var seriesIx$1 = 0; seriesIx$1 < centeredSeries.length; seriesIx$1++) {
      var seriesAxis = centeredSeries[seriesIx$1].categoryAxis || "";
      if (seriesAxis === categoryAxisName || !seriesAxis && categoryAxisIndex === 0) {
        return true;
      }
    }
  };
  CategoricalPlotArea2.prototype.aggregatedAxis = function aggregatedAxis(categoryAxisName, categoryAxisIndex) {
    var series = this.series;
    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {
      var seriesAxis = series[seriesIx].categoryAxis || "";
      if ((seriesAxis === categoryAxisName || !seriesAxis && categoryAxisIndex === 0) && series[seriesIx].categoryField) {
        return true;
      }
    }
  };
  CategoricalPlotArea2.prototype.createCategoryAxesLabels = function createCategoryAxesLabels() {
    var axes = this.axes;
    for (var i16 = 0; i16 < axes.length; i16++) {
      if (axes[i16] instanceof CategoryAxis) {
        axes[i16].createLabels();
      }
    }
  };
  CategoricalPlotArea2.prototype.createCategoryAxes = function createCategoryAxes(panes) {
    var this$1$1 = this;
    var invertAxes = this.invertAxes;
    var definitions = [].concat(this.options.categoryAxis);
    var axes = [];
    for (var i16 = 0; i16 < definitions.length; i16++) {
      var axisOptions2 = definitions[i16];
      var axisPane = this$1$1.findPane(axisOptions2.pane);
      if (inArray(axisPane, panes)) {
        var name2 = axisOptions2.name;
        var categories = axisOptions2.categories;
        if (categories === void 0)
          categories = [];
        axisOptions2 = deepExtend({
          vertical: invertAxes,
          reverse: !invertAxes && this$1$1.chartService.rtl,
          axisCrossingValue: invertAxes ? MAX_VALUE : 0
        }, axisOptions2);
        if (!defined(axisOptions2.justified)) {
          axisOptions2.justified = this$1$1.isJustified();
        }
        if (this$1$1.axisRequiresRounding(name2, i16)) {
          axisOptions2.justified = false;
        }
        var categoryAxis = void 0;
        if (isDateAxis(axisOptions2, categories[0])) {
          axisOptions2._forecast = this$1$1.trendlineAggregateForecast();
          categoryAxis = new DateCategoryAxis(axisOptions2, this$1$1.chartService);
        } else {
          categoryAxis = new CategoryAxis(axisOptions2, this$1$1.chartService);
        }
        definitions[i16].categories = categoryAxis.options.srcCategories;
        if (name2) {
          if (this$1$1.namedCategoryAxes[name2]) {
            throw new Error("Category axis with name " + name2 + " is already defined");
          }
          this$1$1.namedCategoryAxes[name2] = categoryAxis;
        }
        categoryAxis.axisIndex = i16;
        axes.push(categoryAxis);
        this$1$1.appendAxis(categoryAxis);
      }
    }
    var primaryAxis = this.categoryAxis || axes[0];
    this.categoryAxis = primaryAxis;
    if (invertAxes) {
      this.axisY = primaryAxis;
    } else {
      this.axisX = primaryAxis;
    }
  };
  CategoricalPlotArea2.prototype.isJustified = function isJustified() {
    var series = this.series;
    for (var i16 = 0; i16 < series.length; i16++) {
      var currentSeries = series[i16];
      if (!inArray(currentSeries.type, AREA_SERIES)) {
        return false;
      }
    }
    return true;
  };
  CategoricalPlotArea2.prototype.createValueAxes = function createValueAxes(panes) {
    var this$1$1 = this;
    var tracker = this.valueAxisRangeTracker;
    var defaultRange = tracker.query();
    var definitions = [].concat(this.options.valueAxis);
    var invertAxes = this.invertAxes;
    var baseOptions = { vertical: !invertAxes, reverse: invertAxes && this.chartService.rtl };
    var axes = [];
    if (this.stack100) {
      baseOptions.roundToMajorUnit = false;
      baseOptions.labels = { format: "P0" };
    }
    for (var i16 = 0; i16 < definitions.length; i16++) {
      var axisOptions2 = definitions[i16];
      var axisPane = this$1$1.findPane(axisOptions2.pane);
      if (inArray(axisPane, panes)) {
        var name2 = axisOptions2.name;
        var defaultAxisRange = equalsIgnoreCase(axisOptions2.type, LOGARITHMIC) ? { min: 0.1, max: 1 } : { min: 0, max: 1 };
        var range = tracker.query(name2) || defaultRange || defaultAxisRange;
        if (i16 === 0 && range && defaultRange) {
          range.min = Math.min(range.min, defaultRange.min);
          range.max = Math.max(range.max, defaultRange.max);
        }
        var axisType = void 0;
        if (equalsIgnoreCase(axisOptions2.type, LOGARITHMIC)) {
          axisType = LogarithmicAxis;
        } else {
          axisType = NumericAxis;
        }
        var valueAxis = new axisType(
          range.min,
          range.max,
          deepExtend({}, baseOptions, axisOptions2),
          this$1$1.chartService
        );
        if (name2) {
          if (this$1$1.namedValueAxes[name2]) {
            throw new Error("Value axis with name " + name2 + " is already defined");
          }
          this$1$1.namedValueAxes[name2] = valueAxis;
        }
        valueAxis.axisIndex = i16;
        axes.push(valueAxis);
        this$1$1.appendAxis(valueAxis);
      }
    }
    var primaryAxis = this.valueAxis || axes[0];
    this.valueAxis = primaryAxis;
    if (invertAxes) {
      this.axisX = primaryAxis;
    } else {
      this.axisY = primaryAxis;
    }
  };
  CategoricalPlotArea2.prototype._dispatchEvent = function _dispatchEvent(chart, e3, eventType) {
    var coords = chart._eventCoordinates(e3);
    var point2 = new Point$5(coords.x, coords.y);
    var pane = this.pointPane(point2);
    var categories = [];
    var values6 = [];
    if (!pane) {
      return;
    }
    var allAxes = pane.axes;
    for (var i16 = 0; i16 < allAxes.length; i16++) {
      var axis = allAxes[i16];
      if (axis.getValue) {
        appendIfNotNull(values6, axis.getValue(point2));
      } else {
        appendIfNotNull(categories, axis.getCategory(point2));
      }
    }
    if (categories.length === 0) {
      appendIfNotNull(categories, this.categoryAxis.getCategory(point2));
    }
    if (categories.length > 0 && values6.length > 0) {
      chart.trigger(eventType, {
        element: eventElement(e3),
        originalEvent: e3,
        category: singleItemOrArray(categories),
        value: singleItemOrArray(values6)
      });
    }
  };
  CategoricalPlotArea2.prototype.pointPane = function pointPane(point2) {
    var panes = this.panes;
    for (var i16 = 0; i16 < panes.length; i16++) {
      var currentPane = panes[i16];
      if (currentPane.contentBox.containsPoint(point2)) {
        return currentPane;
      }
    }
  };
  CategoricalPlotArea2.prototype.updateAxisOptions = function updateAxisOptions$12(axis, options2) {
    updateAxisOptions$2(this.options, axis, options2);
    updateAxisOptions$2(this.originalOptions, axis, options2);
  };
  CategoricalPlotArea2.prototype._pointsByVertical = function _pointsByVertical(basePoint, offset2) {
    if (offset2 === void 0)
      offset2 = 0;
    if (this.invertAxes) {
      return this._siblingsBySeriesIndex(basePoint.series.index, offset2);
    }
    return this._siblingsByPointIndex(basePoint.getIndex());
  };
  CategoricalPlotArea2.prototype._pointsByHorizontal = function _pointsByHorizontal(basePoint, offset2) {
    if (offset2 === void 0)
      offset2 = 0;
    if (this.invertAxes) {
      return this._siblingsByPointIndex(basePoint.getIndex());
    }
    var siblings2 = this._siblingsBySeriesIndex(basePoint.series.index, offset2);
    if (this.chartService.rtl) {
      return siblings2.reverse();
    }
    return siblings2;
  };
  CategoricalPlotArea2.prototype._siblingsByPointIndex = function _siblingsByPointIndex(pointIndex) {
    var this$1$1 = this;
    var charts = this.charts;
    var result = [];
    for (var i16 = 0; i16 < charts.length; i16++) {
      var chart = charts[i16];
      if (chart.pane && chart.pane.options.name === "_navigator") {
        continue;
      }
      var chartPoints = chart.points.filter(
        function(point2) {
          return point2 && point2.visible !== false && point2.getIndex() === pointIndex;
        }
      );
      result.push.apply(result, chartPoints.sort(this$1$1._getSeriesCompareFn(chartPoints[0])));
    }
    return result;
  };
  CategoricalPlotArea2.prototype._siblingsBySeriesIndex = function _siblingsBySeriesIndex(seriesIndex, offset2) {
    var index2 = cycleIndex(seriesIndex + offset2, this.series.length);
    return this.pointsBySeriesIndex(index2);
  };
  CategoricalPlotArea2.prototype._getSeriesCompareFn = function _getSeriesCompareFn(point2) {
    var isStacked = this._isInStackedSeries(point2);
    if (isStacked && this.invertAxes || !isStacked && !this.invertAxes) {
      return function(a9, b2) {
        return a9.box.center().x - b2.box.center().x;
      };
    }
    return function(a9, b2) {
      return a9.box.center().y - b2.box.center().y;
    };
  };
  CategoricalPlotArea2.prototype._isInStackedSeries = function _isInStackedSeries(point2) {
    var sortableSeries = inArray(
      point2.series.type,
      [AREA, VERTICAL_AREA, RANGE_AREA, VERTICAL_RANGE_AREA, LINE, VERTICAL_LINE, RADAR_LINE, RADAR_AREA]
    );
    var stackableSeries = inArray(point2.series.type, [COLUMN, BAR]);
    return sortableSeries || stackableSeries && point2.options.isStacked;
  };
  return CategoricalPlotArea2;
}(PlotAreaBase);
function updateAxisOptions$2(targetOptions, axis, options2) {
  var axesOptions = axis instanceof CategoryAxis ? [].concat(targetOptions.categoryAxis) : [].concat(targetOptions.valueAxis);
  deepExtend(axesOptions[axis.axisIndex], options2);
}
function groupSeries(series, axis, axisIx) {
  return grep(series, function(s10) {
    return axisIx === 0 && !s10.categoryAxis || s10.categoryAxis === axis;
  });
}
setDefaultOptions(CategoricalPlotArea, {
  categoryAxis: {},
  valueAxis: {}
});
deepExtend(CategoricalPlotArea.prototype, PlotAreaEventsMixin);
var Highlight = function(Class3) {
  function Highlight2() {
    Class3.call(this);
    this._points = [];
  }
  if (Class3)
    Highlight2.__proto__ = Class3;
  Highlight2.prototype = Object.create(Class3 && Class3.prototype);
  Highlight2.prototype.constructor = Highlight2;
  Highlight2.prototype.destroy = function destroy2() {
    this._points = [];
  };
  Highlight2.prototype.show = function show2(points2, opacity) {
    var this$1$1 = this;
    var arrayPoints = [].concat(points2);
    this.hide();
    for (var i16 = 0; i16 < arrayPoints.length; i16++) {
      var point2 = arrayPoints[i16];
      if (point2 && point2.toggleHighlight && point2.hasHighlight()) {
        this$1$1.togglePointHighlight(point2, true, opacity);
        this$1$1._points.push(point2);
      }
    }
  };
  Highlight2.prototype.togglePointHighlight = function togglePointHighlight(point2, show2, opacity) {
    var toggleHandler = (point2.options.highlight || {}).toggle;
    if (toggleHandler) {
      var eventArgs = {
        category: point2.category,
        series: point2.series,
        dataItem: point2.dataItem,
        value: point2.value,
        stackValue: point2.stackValue,
        preventDefault,
        visual: point2.highlightVisual(),
        show: show2
      };
      toggleHandler(eventArgs);
      if (!eventArgs._defaultPrevented) {
        point2.toggleHighlight(show2, opacity);
      }
    } else {
      point2.toggleHighlight(show2, opacity);
    }
  };
  Highlight2.prototype.hide = function hide2() {
    var this$1$1 = this;
    var points2 = this._points;
    while (points2.length) {
      this$1$1.togglePointHighlight(points2.pop(), false);
    }
  };
  Highlight2.prototype.isHighlighted = function isHighlighted(element) {
    var points2 = this._points;
    for (var i16 = 0; i16 < points2.length; i16++) {
      var point2 = points2[i16];
      if (element === point2) {
        return true;
      }
    }
    return false;
  };
  return Highlight2;
}(Class$1);
function preventDefault() {
  this._defaultPrevented = true;
}
function acceptKey(e3, mouseKey) {
  var key = (mouseKey || "").toLowerCase();
  var event = e3.event;
  var accept = key === "none" && !(event.ctrlKey || event.shiftKey || event.altKey) || event[key + "Key"];
  return accept;
}
function toChartAxisRanges(axisRanges2) {
  var ranges = {};
  for (var idx = 0; idx < axisRanges2.length; idx++) {
    var axisRange = axisRanges2[idx];
    if (axisRange.axis.options.name) {
      ranges[axisRange.axis.options.name] = {
        min: axisRange.range.min,
        max: axisRange.range.max
      };
    }
  }
  return ranges;
}
var Pannable = function(Class3) {
  function Pannable2(plotArea, options2) {
    Class3.call(this);
    this.plotArea = plotArea;
    this.options = deepExtend({}, this.options, options2);
  }
  if (Class3)
    Pannable2.__proto__ = Class3;
  Pannable2.prototype = Object.create(Class3 && Class3.prototype);
  Pannable2.prototype.constructor = Pannable2;
  Pannable2.prototype.start = function start(e3) {
    this._active = acceptKey(e3, this.options.key);
    return this._active;
  };
  Pannable2.prototype.move = function move(e3) {
    if (this._active) {
      var axisRanges2 = this.axisRanges = this._panAxes(e3, X$4).concat(this._panAxes(e3, Y$7));
      if (axisRanges2.length) {
        this.axisRanges = axisRanges2;
        return toChartAxisRanges(axisRanges2);
      }
    }
  };
  Pannable2.prototype.end = function end() {
    var active = this._active;
    this._active = false;
    return active;
  };
  Pannable2.prototype.pan = function pan() {
    var ref2 = this;
    var plotArea = ref2.plotArea;
    var axisRanges2 = ref2.axisRanges;
    if (axisRanges2.length) {
      for (var idx = 0; idx < axisRanges2.length; idx++) {
        var range = axisRanges2[idx];
        plotArea.updateAxisOptions(range.axis, range.range);
      }
      plotArea.redraw(plotArea.panes);
    }
  };
  Pannable2.prototype.destroy = function destroy2() {
    delete this.plotArea;
  };
  Pannable2.prototype._panAxes = function _panAxes(e3, position2) {
    var plotArea = this.plotArea;
    var delta = -e3[position2].delta;
    var lock = (this.options.lock || "").toLowerCase();
    var updatedAxes = [];
    if (delta !== 0 && (lock || "").toLowerCase() !== position2) {
      var axes = plotArea.axes;
      for (var idx = 0; idx < axes.length; idx++) {
        var axis = axes[idx];
        if (position2 === X$4 && !axis.options.vertical || position2 === Y$7 && axis.options.vertical) {
          var range = axis.pan(delta);
          if (range) {
            range.limitRange = true;
            updatedAxes.push({
              axis,
              range
            });
          }
        }
      }
    }
    return updatedAxes;
  };
  return Pannable2;
}(Class$1);
Pannable.prototype.options = {
  key: "none",
  lock: "none"
};
var ZoomSelection = function(Class3) {
  function ZoomSelection2(chart, options2) {
    Class3.call(this);
    this.chart = chart;
    this.options = deepExtend({}, this.options, options2);
    this.createElement();
  }
  if (Class3)
    ZoomSelection2.__proto__ = Class3;
  ZoomSelection2.prototype = Object.create(Class3 && Class3.prototype);
  ZoomSelection2.prototype.constructor = ZoomSelection2;
  ZoomSelection2.prototype.createElement = function createElement() {
    var marquee = this._marquee = document.createElement("div");
    marquee.className = "k-marquee";
    var marqueeColor = document.createElement("div");
    marqueeColor.className = "k-marquee-color";
    marquee.appendChild(marqueeColor);
  };
  ZoomSelection2.prototype.removeElement = function removeElement() {
    if (this._marquee.parentNode) {
      this._marquee.parentNode.removeChild(this._marquee);
    }
  };
  ZoomSelection2.prototype.setStyles = function setStyles(styles) {
    elementStyles(this._marquee, styles);
  };
  ZoomSelection2.prototype.start = function start(e3) {
    if (acceptKey(e3, this.options.key)) {
      var chart = this.chart;
      var point2 = chart._eventCoordinates(e3);
      var zoomPane = this._zoomPane = chart._plotArea.paneByPoint(point2);
      var clipBox = zoomPane ? zoomPane.chartsBox().clone() : null;
      if (zoomPane && clipBox) {
        var offset2 = this._elementOffset();
        clipBox.translate(offset2.left, offset2.top);
        this._zoomPaneClipBox = clipBox;
        document.body.appendChild(this._marquee);
        this.setStyles({
          left: e3.pageX + 1,
          top: e3.pageY + 1,
          width: 0,
          height: 0
        });
        return true;
      }
    }
    return false;
  };
  ZoomSelection2.prototype._elementOffset = function _elementOffset() {
    var chartElement = this.chart.element;
    var ref2 = elementStyles(chartElement, ["paddingLeft", "paddingTop"]);
    var paddingLeft = ref2.paddingLeft;
    var paddingTop = ref2.paddingTop;
    var offset2 = elementOffset(chartElement);
    return {
      left: paddingLeft + offset2.left,
      top: paddingTop + offset2.top
    };
  };
  ZoomSelection2.prototype.move = function move(e3) {
    var zoomPane = this._zoomPane;
    if (zoomPane) {
      this.setStyles(this._selectionPosition(e3));
    }
  };
  ZoomSelection2.prototype.end = function end(e3) {
    var zoomPane = this._zoomPane;
    if (zoomPane) {
      var elementOffset2 = this._elementOffset();
      var selectionPosition = this._selectionPosition(e3);
      selectionPosition.left -= elementOffset2.left;
      selectionPosition.top -= elementOffset2.top;
      var start = { x: selectionPosition.left, y: selectionPosition.top };
      var end2 = { x: selectionPosition.left + selectionPosition.width, y: selectionPosition.top + selectionPosition.height };
      this._updateAxisRanges(start, end2);
      this.removeElement();
      delete this._zoomPane;
      return toChartAxisRanges(this.axisRanges);
    }
  };
  ZoomSelection2.prototype.zoom = function zoom() {
    var axisRanges2 = this.axisRanges;
    if (axisRanges2 && axisRanges2.length) {
      var plotArea = this.chart._plotArea;
      for (var idx = 0; idx < axisRanges2.length; idx++) {
        var axisRange = axisRanges2[idx];
        plotArea.updateAxisOptions(axisRange.axis, axisRange.range);
      }
      plotArea.redraw(plotArea.panes);
    }
  };
  ZoomSelection2.prototype.destroy = function destroy2() {
    this.removeElement();
    delete this._marquee;
    delete this.chart;
  };
  ZoomSelection2.prototype._updateAxisRanges = function _updateAxisRanges(start, end) {
    var lock = (this.options.lock || "").toLowerCase();
    var axisRanges2 = [];
    var axes = this._zoomPane.axes;
    for (var idx = 0; idx < axes.length; idx++) {
      var axis = axes[idx];
      var vertical = axis.options.vertical;
      if (!(lock === X$4 && !vertical) && !(lock === Y$7 && vertical) && defined(axis.axisIndex)) {
        var range = axis.pointsRange(start, end);
        if (range) {
          axisRanges2.push({
            axis,
            range
          });
        }
      }
    }
    this.axisRanges = axisRanges2;
  };
  ZoomSelection2.prototype._selectionPosition = function _selectionPosition(e3) {
    var clipBox = this._zoomPaneClipBox;
    var startLocation = {
      x: e3.x.startLocation,
      y: e3.y.startLocation
    };
    var pageX = e3.x.location;
    var pageY = e3.y.location;
    var lock = (this.options.lock || "").toLowerCase();
    var left = Math.min(startLocation.x, pageX);
    var top = Math.min(startLocation.y, pageY);
    var width = Math.abs(startLocation.x - pageX);
    var height = Math.abs(startLocation.y - pageY);
    if (lock === X$4) {
      left = clipBox.x1;
      width = clipBox.width();
    }
    if (lock === Y$7) {
      top = clipBox.y1;
      height = clipBox.height();
    }
    if (pageX > clipBox.x2) {
      width = clipBox.x2 - startLocation.x;
    }
    if (pageX < clipBox.x1) {
      width = startLocation.x - clipBox.x1;
    }
    if (pageY > clipBox.y2) {
      height = clipBox.y2 - startLocation.y;
    }
    if (pageY < clipBox.y1) {
      height = startLocation.y - clipBox.y1;
    }
    return {
      left: Math.max(left, clipBox.x1),
      top: Math.max(top, clipBox.y1),
      width,
      height
    };
  };
  return ZoomSelection2;
}(Class$1);
ZoomSelection.prototype.options = {
  key: "shift",
  lock: "none"
};
var MIN_RATE = 0.01;
var MAX_RATE = 0.9;
var DEFAULT_RATE = 0.3;
var MousewheelZoom = function(Class3) {
  function MousewheelZoom2(chart, options2) {
    Class3.call(this);
    this.chart = chart;
    this.options = deepExtend({
      rate: DEFAULT_RATE
    }, this.options, options2);
  }
  if (Class3)
    MousewheelZoom2.__proto__ = Class3;
  MousewheelZoom2.prototype = Object.create(Class3 && Class3.prototype);
  MousewheelZoom2.prototype.constructor = MousewheelZoom2;
  MousewheelZoom2.prototype.updateRanges = function updateRanges(delta, coords) {
    var this$1$1 = this;
    var lock = (this.options.lock || "").toLowerCase();
    var axisRanges2 = [];
    var axes = this.chart._plotArea.axes;
    for (var idx = 0; idx < axes.length; idx++) {
      var axis = axes[idx];
      var vertical = axis.options.vertical;
      if (!(lock === X$4 && !vertical) && !(lock === Y$7 && vertical) && axis.zoomRange) {
        var rate = limitValue(this$1$1.options.rate, MIN_RATE, MAX_RATE);
        var range = axis.zoomRange(-delta * rate, coords);
        if (range) {
          axisRanges2.push({
            axis,
            range
          });
        }
      }
    }
    this.axisRanges = axisRanges2;
    return toChartAxisRanges(axisRanges2);
  };
  MousewheelZoom2.prototype.zoom = function zoom() {
    var axisRanges2 = this.axisRanges;
    var plotArea = this.chart._plotArea;
    if (axisRanges2 && axisRanges2.length && plotArea.updateAxisOptions) {
      for (var idx = 0; idx < axisRanges2.length; idx++) {
        var axisRange = axisRanges2[idx];
        plotArea.updateAxisOptions(axisRange.axis, axisRange.range);
      }
      plotArea.redraw(plotArea.panes);
    }
  };
  MousewheelZoom2.prototype.destroy = function destroy2() {
    delete this.chart;
  };
  return MousewheelZoom2;
}(Class$1);
var alignItems = function(rtl) {
  return rtl ? END$1 : START$1;
};
var LegendLayout = function(ChartElement2) {
  function LegendLayout2(options2, chartService) {
    ChartElement2.call(this, options2);
    this.chartService = chartService;
  }
  if (ChartElement2)
    LegendLayout2.__proto__ = ChartElement2;
  LegendLayout2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  LegendLayout2.prototype.constructor = LegendLayout2;
  LegendLayout2.prototype.render = function render() {
    var ref2 = this;
    var children = ref2.children;
    var options2 = ref2.options;
    var vertical = options2.vertical;
    this.visual = new Layout$1(null, {
      spacing: vertical ? 0 : options2.spacing,
      lineSpacing: vertical ? options2.spacing : 0,
      orientation: vertical ? VERTICAL : HORIZONTAL,
      reverse: options2.rtl,
      alignItems: vertical ? alignItems(options2.rtl) : CENTER
    });
    for (var idx = 0; idx < children.length; idx++) {
      var legendItem = children[idx];
      legendItem.reflow(new Box());
      legendItem.renderVisual();
    }
  };
  LegendLayout2.prototype.reflow = function reflow(box) {
    this.visual.rect(box.toRect());
    this.visual.reflow();
    var bbox = this.visual.clippedBBox();
    if (bbox) {
      this.box = rectToBox(bbox);
    } else {
      this.box = new Box();
    }
  };
  LegendLayout2.prototype.renderVisual = function renderVisual() {
    this.addVisual();
  };
  LegendLayout2.prototype.createVisual = function createVisual() {
  };
  return LegendLayout2;
}(ChartElement);
var DEFAULT_MARKER_SIZE = 10;
var DEFAULT_MARKER_BORDER_WIDTH = 2;
var LegendItemMarker = function(ShapeElement2) {
  function LegendItemMarker2() {
    ShapeElement2.apply(this, arguments);
  }
  if (ShapeElement2)
    LegendItemMarker2.__proto__ = ShapeElement2;
  LegendItemMarker2.prototype = Object.create(ShapeElement2 && ShapeElement2.prototype);
  LegendItemMarker2.prototype.constructor = LegendItemMarker2;
  LegendItemMarker2.prototype.visualStyle = function visualStyle() {
    var options2 = this.markerOptions();
    var border = options2.border;
    return {
      stroke: {
        width: border.width,
        color: border.color,
        opacity: valueOrDefault$1(border.opacity, options2.opacity),
        dashType: border.dashType
      },
      fill: {
        color: options2.background,
        opacity: options2.opacity
      },
      cursor: options2.cursor
    };
  };
  LegendItemMarker2.prototype.markerOptions = function markerOptions() {
    return this.options;
  };
  LegendItemMarker2.prototype.markerHighlightOptions = function markerHighlightOptions() {
    var options2 = this.markerOptions();
    var borderWidth = options2.highlight.border.width;
    return deepExtend(
      {},
      options2,
      { background: options2.border.color },
      options2.highlight,
      options2.type === CROSS ? {
        background: options2.highlight.border.color,
        border: { color: options2.highlight.background, width: borderWidth / 2 },
        width: options2.width,
        height: options2.height,
        margin: { top: 0, left: 0 }
      } : {}
    );
  };
  LegendItemMarker2.prototype.createHighlight = function createHighlight() {
    var highlight = new ShapeElement2(this.markerHighlightOptions());
    var box = this.paddingBox.clone();
    highlight.reflow(box.pad(highlight.options.border.width));
    this.highlight = [highlight.getElement()];
    return this.highlight;
  };
  return LegendItemMarker2;
}(ShapeElement);
setDefaultOptions(LegendItemMarker, {
  border: {
    width: DEFAULT_MARKER_BORDER_WIDTH
  },
  width: DEFAULT_MARKER_SIZE - DEFAULT_MARKER_BORDER_WIDTH,
  height: DEFAULT_MARKER_SIZE - DEFAULT_MARKER_BORDER_WIDTH,
  background: WHITE$1,
  margin: {
    top: -1,
    left: -1
  },
  vAlign: TOP,
  align: LEFT,
  highlight: {
    width: DEFAULT_MARKER_SIZE,
    height: DEFAULT_MARKER_SIZE,
    border: {
      color: WHITE$1,
      width: DEFAULT_MARKER_BORDER_WIDTH
    }
  }
});
var MarkerLineArea = function(ShapeElement2) {
  function MarkerLineArea2() {
    ShapeElement2.apply(this, arguments);
  }
  if (ShapeElement2)
    MarkerLineArea2.__proto__ = ShapeElement2;
  MarkerLineArea2.prototype = Object.create(ShapeElement2 && ShapeElement2.prototype);
  MarkerLineArea2.prototype.constructor = MarkerLineArea2;
  MarkerLineArea2.prototype.getElement = function getElement() {
    var group2 = new Group$9();
    var element = new MultiPath(this.visualStyle());
    var ref2 = this;
    var box = ref2.paddingBox;
    var halfHeight = box.height() / 2;
    element.moveTo(box.x1, box.y1 + halfHeight).lineTo(box.x1, box.y2).lineTo(box.x2, box.y2);
    group2.append(element);
    return group2;
  };
  return MarkerLineArea2;
}(ShapeElement);
setDefaultOptions(MarkerLineArea, {
  width: 15,
  height: 15,
  align: RIGHT,
  vAlign: BOTTOM,
  margin: {
    right: -2,
    bottom: 2
  }
});
var LegendItemLine = function(ShapeElement2) {
  function LegendItemLine2() {
    ShapeElement2.apply(this, arguments);
  }
  if (ShapeElement2)
    LegendItemLine2.__proto__ = ShapeElement2;
  LegendItemLine2.prototype = Object.create(ShapeElement2 && ShapeElement2.prototype);
  LegendItemLine2.prototype.constructor = LegendItemLine2;
  LegendItemLine2.prototype.getElement = function getElement() {
    var group2 = new Group$9();
    var element = new MultiPath({
      stroke: {
        color: this.options.border.color,
        opacity: this.options.opacity,
        width: this.options.height,
        dashType: this.options.dashType
      }
    });
    var box = this.paddingBox;
    var centerY = box.center().y;
    element.moveTo(box.x1, centerY).lineTo(box.x2, centerY);
    group2.append(element);
    return group2;
  };
  LegendItemLine2.prototype.createHighlight = function createHighlight() {
    this.highlight = [this.createHighlightLine(), this.createHighlightMarker()];
    return this.highlight;
  };
  LegendItemLine2.prototype.createHighlightLine = function createHighlightLine() {
    var options2 = deepExtend({}, {
      border: {
        color: this.options.border.color,
        opacity: this.options.border.opacity,
        dashType: this.options.border.dashType
      }
    }, this.options.highlight);
    var highlightLine = new MarkerLineArea(options2);
    highlightLine.reflow(this.parent.paddingBox.clone());
    this.highlightLine = highlightLine.getElement();
    return this.highlightLine;
  };
  LegendItemLine2.prototype.createHighlightMarker = function createHighlightMarker() {
    var options2 = deepExtend({}, {
      background: this.options.background
    }, this.options.highlight.markers);
    var highlightMarker = new ShapeElement2(options2);
    var paddingBox = this.parent.paddingBox;
    var borderWidth = options2.border.width;
    var box = this.parent.box.clone();
    box.pad({
      left: borderWidth - paddingBox.x1,
      top: borderWidth - paddingBox.y1
    });
    highlightMarker.reflow(box);
    this.highlightMarker = highlightMarker.getElement();
    return this.highlightMarker;
  };
  return LegendItemLine2;
}(ShapeElement);
setDefaultOptions(LegendItemLine, {
  border: {
    width: 0
  },
  type: RECT,
  align: LEFT,
  vAlign: CENTER,
  highlight: {
    border: {
      width: DEFAULT_MARKER_BORDER_WIDTH
    },
    markers: {
      type: CIRCLE,
      width: DEFAULT_MARKER_SIZE,
      height: DEFAULT_MARKER_SIZE,
      border: {
        width: DEFAULT_MARKER_BORDER_WIDTH,
        color: WHITE$1
      },
      align: LEFT,
      vAlign: TOP
    }
  }
});
var LegendItemSquare = function(ShapeElement2) {
  function LegendItemSquare2() {
    ShapeElement2.apply(this, arguments);
  }
  if (ShapeElement2)
    LegendItemSquare2.__proto__ = ShapeElement2;
  LegendItemSquare2.prototype = Object.create(ShapeElement2 && ShapeElement2.prototype);
  LegendItemSquare2.prototype.constructor = LegendItemSquare2;
  LegendItemSquare2.prototype.createHighlight = function createHighlight() {
    var options2 = deepExtend({}, {
      background: this.options.background
    }, this.options.highlight.markers);
    var highlight = new ShapeElement2(options2);
    var box = this.paddingBox.clone();
    var targetBox = this.parent.box.clone();
    box.align(targetBox, X$4, LEFT);
    box.align(targetBox, Y$7, TOP);
    highlight.reflow(box);
    this.highlight = [highlight.getElement()];
    return this.highlight;
  };
  return LegendItemSquare2;
}(ShapeElement);
setDefaultOptions(LegendItemSquare, {
  highlight: {
    markers: {
      type: CIRCLE,
      width: DEFAULT_MARKER_SIZE,
      height: DEFAULT_MARKER_SIZE,
      border: {
        width: DEFAULT_MARKER_BORDER_WIDTH,
        color: WHITE$1
      },
      margin: {
        top: -3,
        left: -3
      }
    }
  }
});
var LegendItem = function(BoxElement2) {
  function LegendItem2(options2) {
    BoxElement2.call(this, options2);
    this.createContainer();
    if (!options2.rtl) {
      this.createMarker();
      this.createLabel();
    } else {
      this.createLabel();
      this.createMarker();
    }
    this._id = guid();
    this.options.accessibility.ariaChecked = options2.active;
  }
  if (BoxElement2)
    LegendItem2.__proto__ = BoxElement2;
  LegendItem2.prototype = Object.create(BoxElement2 && BoxElement2.prototype);
  LegendItem2.prototype.constructor = LegendItem2;
  LegendItem2.prototype.createContainer = function createContainer() {
    this.container = new FloatElement({ vertical: false, wrap: false, align: CENTER, spacing: this.options.spacing });
    this.append(this.container);
  };
  LegendItem2.prototype.createMarker = function createMarker() {
    this.markerWrap = new BoxElement2({ vertical: false, shrinkToFit: true, wrap: false, margin: 1, width: 22, height: 22 });
    this.container.append(this.markerWrap);
    this.createMarkerArea();
    if (this.options.markers.visible) {
      this._marker = this._createMarker();
      this.markerWrap.append(this._marker);
    }
  };
  LegendItem2.prototype.createMarkerArea = function createMarkerArea() {
    var options2 = this.options;
    var markerColor = options2.markerColor;
    var line = options2.line;
    if (line === void 0)
      line = {};
    var lineOptions = {
      border: {
        color: line.color || markerColor,
        opacity: line.opacity,
        dashType: line.dashType
      }
    };
    return this._createLine(lineOptions) || this._createMarkerLine(lineOptions, line) || this._createSquare();
  };
  LegendItem2.prototype.markerOptions = function markerOptions() {
    var options2 = this.options;
    var markers = options2.markers;
    if (markers === void 0)
      markers = {};
    var markerColor = options2.markerColor;
    var border = markers.border;
    if (border === void 0)
      border = {};
    markers.zIndex = void 0;
    return deepExtend({}, markers, {
      border: { color: border.color || markerColor },
      highlight: options2.highlight.markers
    });
  };
  LegendItem2.prototype._highlightOptions = function _highlightOptions() {
    var options2 = this.options;
    return deepExtend(
      { markers: { type: options2.markers.type } },
      options2.highlight
    );
  };
  LegendItem2.prototype._createLine = function _createLine(lineOptions) {
    var options2 = this.options;
    if (options2.type === LINE && !options2.markers.visible) {
      this._line = new LegendItemLine(deepExtend({}, {
        background: options2.markerColor,
        highlight: this._highlightOptions()
      }, lineOptions, options2.line));
      this.markerWrap.append(this._line);
    }
    return this._line;
  };
  LegendItem2.prototype._createMarkerLine = function _createMarkerLine(lineOptions, line) {
    var options2 = this.options;
    if (options2.type === LINE) {
      this._markerLineArea = new MarkerLineArea(deepExtend({}, {
        border: {
          width: line.height
        }
      }, lineOptions));
      this.markerWrap.append(this._markerLineArea);
    }
    return this._markerLineArea;
  };
  LegendItem2.prototype._createSquare = function _createSquare() {
    var options2 = this.options;
    if (options2.type === AREA) {
      this._square = new LegendItemSquare(Object.assign(
        {},
        {
          border: options2.border,
          vAlign: options2.markers.visible ? BOTTOM : CENTER,
          highlight: this._highlightOptions()
        },
        options2.area,
        { background: options2.area.background || options2.markerColor }
      ));
      this.markerWrap.append(this._square);
    }
    return this._square;
  };
  LegendItem2.prototype._createMarker = function _createMarker() {
    return new LegendItemMarker(this.markerOptions());
  };
  LegendItem2.prototype._highlightMarkers = function _highlightMarkers() {
    if (this.options.active) {
      this._toggleHighlight(true);
    }
  };
  LegendItem2.prototype._restoreMarkers = function _restoreMarkers() {
    this._toggleHighlight(false);
  };
  LegendItem2.prototype._toggleHighlight = function _toggleHighlight(show2) {
    var this$1$1 = this;
    if (!this.options.highlight.visible) {
      return;
    }
    var element = this._marker || this._square || this._line;
    if (element && element === this._line) {
      this._line.visual.visible(!show2);
    }
    if (element) {
      var highlight = element.highlight;
      if (!highlight) {
        highlight = element.createHighlight();
        highlight.forEach(function(h3) {
          return h3 && this$1$1.markerWrap.appendVisual(h3);
        });
      }
      highlight.forEach(function(h3) {
        return h3 && h3.visible(show2);
      });
    }
  };
  LegendItem2.prototype.createLabel = function createLabel() {
    var options2 = this.options;
    var labelOptions = deepExtend({}, options2.labels);
    this.container.append(new TextBox(options2.text, labelOptions));
  };
  LegendItem2.prototype.getAriaLabelText = function getAriaLabelText2() {
    return this.options.text;
  };
  LegendItem2.prototype.focusVisual = function focusVisual2() {
    this.visual.options.set("id", this._id);
    this.toggleFocusHighlight(true);
    this._highlightMarkers();
  };
  LegendItem2.prototype.clearFocusFromVisual = function clearFocusFromVisual2() {
    this.visual.options.set("id", "");
    this.toggleFocusHighlight(false);
    this._restoreMarkers();
  };
  LegendItem2.prototype.renderComplete = function renderComplete() {
    BoxElement2.prototype.renderComplete.call(this);
    var cursor = this.options.cursor || {};
    var eventSink = this._itemOverlay = Path$7.fromRect(this.container.box.toRect(), {
      fill: {
        color: WHITE$1,
        opacity: 0
      },
      stroke: null,
      cursor: cursor.style || cursor
    });
    this.appendVisual(eventSink);
  };
  LegendItem2.prototype.click = function click(widget, e3) {
    var args = this.eventArgs(e3);
    if (!widget.trigger(LEGEND_ITEM_CLICK, args) && e3 && e3.type === "contextmenu") {
      e3.preventDefault();
    }
  };
  LegendItem2.prototype.over = function over(widget, e3) {
    var args = this.eventArgs(e3);
    if (!widget.trigger(LEGEND_ITEM_HOVER, args)) {
      widget._legendItemHover(args.seriesIndex, args.pointIndex);
      this._highlightMarkers();
    }
    return true;
  };
  LegendItem2.prototype.out = function out(widget, e3) {
    widget._unsetActivePoint();
    this._restoreMarkers();
    widget.trigger(LEGEND_ITEM_LEAVE, this.eventArgs(e3));
  };
  LegendItem2.prototype.eventArgs = function eventArgs(e3) {
    var options2 = this.options;
    return {
      element: eventElement(e3),
      text: options2.text,
      series: options2.series,
      seriesIndex: options2.series.index,
      pointIndex: options2.pointIndex
    };
  };
  LegendItem2.prototype.createVisual = function createVisual() {
    BoxElement2.prototype.createVisual.call(this);
    var options2 = this.options;
    if (this.options.visible) {
      var accessibilityOptions = deepExtend({
        ariaLabel: options2.accessibility.ariaLabel !== void 0 ? options2.accessibility.ariaLabel : options2.text
      }, options2.accessibility);
      addAccessibilityAttributesToVisual(this.visual, accessibilityOptions);
    }
  };
  LegendItem2.prototype.renderVisual = function renderVisual() {
    var this$1$1 = this;
    var options2 = this.options;
    var customVisual = options2.visual;
    if (customVisual) {
      this.visual = customVisual({
        active: options2.active,
        series: options2.series,
        sender: this.getSender(),
        pointIndex: options2.pointIndex,
        options: {
          type: options2.type,
          // Passing the markerColor as a background option for backwards compatibility.
          // Example in jq docs - https://docs.telerik.com/kendo-ui/api/javascript/dataviz/ui/chart/configuration/legend.item#legenditemvisual
          markers: deepExtend({ background: this.options.markerColor }, this.markerOptions()),
          labels: options2.labels
        },
        createVisual: function() {
          this$1$1.createVisual();
          this$1$1.renderChildren();
          this$1$1.renderComplete();
          var defaultVisual = this$1$1.visual;
          delete this$1$1.visual;
          return defaultVisual;
        }
      });
      this._marker = this._markerLineArea = this._square = this._line = null;
      this.addVisual();
    } else {
      BoxElement2.prototype.renderVisual.call(this);
    }
  };
  LegendItem2.prototype.createFocusHighlight = function createFocusHighlight(style2) {
    var borderWidth = style2.stroke.width;
    return Path$7.fromRect(this.container.box.pad(borderWidth / 2).toRect(), style2);
  };
  return LegendItem2;
}(BoxElement);
setDefaultOptions(LegendItem, {
  accessibility: {
    role: LEGEND_ITEM_ROLE,
    className: LEGEND_ITEM_CLASSNAME,
    ariaRoleDescription: LEGEND_ITEM_ARIA_ROLE_DESCRIPTION
  },
  markers: {},
  highlight: {
    visible: true,
    markers: {}
  }
});
var CUSTOM = "custom";
var Legend$1 = function(ChartElement2) {
  function Legend2(options2, chartService) {
    if (chartService === void 0)
      chartService = {};
    ChartElement2.call(this, options2);
    this.chartService = chartService;
    if (!inArray(this.options.position, [TOP, RIGHT, BOTTOM, LEFT, CUSTOM])) {
      this.options.position = RIGHT;
    }
    this.createContainers();
    this.createLegendTitle(options2.title);
    this.createItems();
  }
  if (ChartElement2)
    Legend2.__proto__ = ChartElement2;
  Legend2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  Legend2.prototype.constructor = Legend2;
  Legend2.prototype.createContainers = function createContainers() {
    var options2 = this.options;
    var position2 = options2.position;
    var userAlign = options2.align;
    var align2 = position2;
    var vAlign = CENTER;
    if (position2 === CUSTOM) {
      align2 = LEFT;
    } else if (inArray(position2, [TOP, BOTTOM])) {
      if (userAlign === START$1) {
        align2 = LEFT;
      } else if (userAlign === END$1) {
        align2 = RIGHT;
      } else {
        align2 = CENTER;
      }
      vAlign = position2;
    } else if (userAlign) {
      if (userAlign === START$1) {
        vAlign = TOP;
      } else if (userAlign === END$1) {
        vAlign = BOTTOM;
      }
    }
    this.container = new BoxElement({
      margin: options2.margin,
      padding: options2.padding,
      background: options2.background,
      border: options2.border,
      vAlign,
      align: align2,
      zIndex: options2.zIndex,
      shrinkToFit: true
    });
    if (this.hasTitle()) {
      this.itemsContainer = new BoxElement({
        vAlign,
        align: align2,
        zIndex: options2.zIndex,
        shrinkToFit: true
      });
    } else {
      this.itemsContainer = this.container;
    }
    this.append(this.container);
  };
  Legend2.prototype.createItems = function createItems() {
    var chartService = this.getService();
    var options2 = this.options;
    var vertical = this.isVertical();
    var innerElement = new LegendLayout({
      vertical,
      spacing: options2.spacing,
      rtl: chartService.rtl
    }, chartService);
    var data2 = options2.data;
    if (options2.reverse) {
      data2 = data2.slice(0).reverse();
    }
    var count = data2.length;
    for (var i16 = 0; i16 < count; i16++) {
      var dataItem = data2[i16];
      var ref2 = dataItem.series || {};
      var markers = ref2.markers;
      if (markers === void 0)
        markers = {};
      var dashType = ref2.dashType;
      var legendItem = ref2.legendItem;
      var opacity = ref2.opacity;
      var markersOptions = deepExtend({ visible: markers.visible !== false, type: CIRCLE }, markers);
      delete markersOptions.size;
      var itemOptions = deepExtend(
        {},
        {
          markers: markersOptions,
          labels: options2.labels,
          rtl: chartService.rtl,
          line: Object.assign(
            {},
            { dashType },
            options2.line
          ),
          area: Object.assign(
            {},
            { opacity },
            options2.area
          ),
          opacity,
          accessibility: options2.accessibility
        },
        options2.item,
        legendItem,
        dataItem,
        { markers: options2.markers }
      );
      innerElement.append(new LegendItem(itemOptions));
    }
    innerElement.render();
    this.itemsContainer.append(innerElement);
  };
  Legend2.prototype.isVertical = function isVertical() {
    var ref2 = this.options;
    var orientation = ref2.orientation;
    var position2 = ref2.position;
    var vertical = position2 === CUSTOM && orientation !== HORIZONTAL || (defined(orientation) ? orientation !== HORIZONTAL : inArray(position2, [LEFT, RIGHT]));
    return vertical;
  };
  Legend2.prototype.hasItems = function hasItems() {
    return this.container.children[0].children.length > 0;
  };
  Legend2.prototype.getItems = function getItems() {
    return this.itemsContainer.children[0].children;
  };
  Legend2.prototype.reflow = function reflow(targetBox) {
    var options2 = this.options;
    var legendBox = targetBox.clone();
    if (!this.hasItems()) {
      this.box = legendBox;
      return;
    }
    if (options2.position === CUSTOM) {
      this.containerCustomReflow(legendBox);
      this.box = legendBox;
    } else {
      this.containerReflow(legendBox);
    }
    if (this.hasTitle()) {
      this.title.reflow(new Box(this.container.box.x1, this.title.box.y1, this.container.box.x2, this.title.box.y2));
    }
  };
  Legend2.prototype.containerReflow = function containerReflow(targetBox) {
    var ref2 = this;
    var options2 = ref2.options;
    var container = ref2.container;
    var position2 = options2.position;
    var width = options2.width;
    var height = options2.height;
    var pos = position2 === TOP || position2 === BOTTOM ? X$4 : Y$7;
    var vertical = this.isVertical();
    var alignTarget = targetBox.clone();
    var containerBox = targetBox.clone();
    if (position2 === LEFT || position2 === RIGHT) {
      containerBox.y1 = alignTarget.y1 = 0;
    }
    if (vertical && height) {
      containerBox.y2 = containerBox.y1 + height;
      containerBox.align(alignTarget, Y$7, container.options.vAlign);
    } else if (!vertical && width) {
      containerBox.x2 = containerBox.x1 + width;
      containerBox.align(alignTarget, X$4, container.options.align);
    }
    container.reflow(containerBox);
    containerBox = container.box;
    var box = containerBox.clone();
    if (options2.offsetX || options2.offsetY) {
      containerBox.translate(options2.offsetX, options2.offsetY);
      container.reflow(containerBox);
    }
    box[pos + 1] = targetBox[pos + 1];
    box[pos + 2] = targetBox[pos + 2];
    this.box = box;
  };
  Legend2.prototype.containerCustomReflow = function containerCustomReflow(targetBox) {
    var ref2 = this;
    var options2 = ref2.options;
    var container = ref2.container;
    var offsetX = options2.offsetX;
    var offsetY = options2.offsetY;
    var width = options2.width;
    var height = options2.height;
    var vertical = this.isVertical();
    var containerBox = targetBox.clone();
    if (vertical && height) {
      containerBox.y2 = containerBox.y1 + height;
    } else if (!vertical && width) {
      containerBox.x2 = containerBox.x1 + width;
    }
    container.reflow(containerBox);
    containerBox = container.box;
    container.reflow(new Box(
      offsetX,
      offsetY,
      offsetX + containerBox.width(),
      offsetY + containerBox.height()
    ));
  };
  Legend2.prototype.renderVisual = function renderVisual() {
    if (this.hasItems()) {
      ChartElement2.prototype.renderVisual.call(this);
    }
  };
  Legend2.prototype.createLegendTitle = function createLegendTitle(title2) {
    var titleOptions = deepExtend({}, {
      color: BLACK$1,
      position: TOP,
      align: CENTER
    }, title2);
    var text = titleOptions.text;
    if (!title2 || title2.visible === false || !title2.text) {
      return;
    }
    if (defined(titleOptions) && titleOptions.visible) {
      var labelTemplate = getTemplate$1(titleOptions);
      if (labelTemplate) {
        text = labelTemplate({ text });
      } else if (titleOptions.format) {
        text = this.chartService.format.auto(titleOptions.format, text);
      }
    }
    this.title = new TextBox(text, titleOptions);
    this.createTitleLayout();
    this.appendTitleLayoutContent();
  };
  Legend2.prototype.createTitleLayout = function createTitleLayout() {
    this.layout = new FloatElement({
      vertical: true,
      wrap: false
    });
    this.container.append(this.layout);
  };
  Legend2.prototype.hasTitle = function hasTitle() {
    return Boolean(this.options.title && this.options.title.visible !== false && this.options.title.text);
  };
  Legend2.prototype.appendTitleLayoutContent = function appendTitleLayoutContent() {
    var options2 = this.options;
    if (options2.title.position === BOTTOM) {
      this.layout.append(this.itemsContainer);
      this.layout.append(this.title);
    } else {
      this.layout.append(this.title);
      this.layout.append(this.itemsContainer);
    }
  };
  return Legend2;
}(ChartElement);
setDefaultOptions(Legend$1, {
  position: RIGHT,
  data: [],
  offsetX: 0,
  offsetY: 0,
  margin: getSpacing(2),
  padding: getSpacing(5),
  border: {
    color: BLACK$1,
    width: 0
  },
  item: {
    cursor: POINTER,
    spacing: 6
  },
  spacing: 6,
  background: "",
  zIndex: 1,
  markers: {},
  line: {
    width: 20,
    height: 2,
    cursor: POINTER,
    opacity: 1
  },
  area: {
    type: SQUARE,
    align: RIGHT,
    width: 15,
    height: 15
  }
});
var PlotAreaFactory = function(Class3) {
  function PlotAreaFactory2() {
    Class3.call(this);
    this._registry = [];
  }
  if (Class3)
    PlotAreaFactory2.__proto__ = Class3;
  PlotAreaFactory2.prototype = Object.create(Class3 && Class3.prototype);
  PlotAreaFactory2.prototype.constructor = PlotAreaFactory2;
  PlotAreaFactory2.prototype.register = function register4(type, seriesTypes) {
    this._registry.push({
      type,
      seriesTypes
    });
  };
  PlotAreaFactory2.prototype.create = function create2(srcSeries, options2, chartService) {
    var registry2 = this._registry;
    var match2 = registry2[0];
    var series;
    for (var idx = 0; idx < registry2.length; idx++) {
      var entry = registry2[idx];
      series = filterSeriesByType(srcSeries, entry.seriesTypes);
      var trendlines = filterSeriesByType(srcSeries, TRENDLINE_SERIES);
      if (series.length - trendlines.length > 0) {
        match2 = entry;
        break;
      }
    }
    return new match2.type(series, options2, chartService);
  };
  return PlotAreaFactory2;
}(Class$1);
PlotAreaFactory.current = new PlotAreaFactory();
var ZOOM_ACCELERATION$1 = 3;
var SELECTOR_HEIGHT_ADJUST = 0.1;
function createDiv$1(classNames2) {
  var element = document.createElement("div");
  if (classNames2) {
    element.className = classNames2;
  }
  return element;
}
function closestHandle(element) {
  var current2 = element;
  while (current2 && !hasClasses(current2, "k-handle")) {
    current2 = current2.parentNode;
  }
  return current2;
}
var Selection = function(Class3) {
  function Selection2(chart, categoryAxis, options2, observer) {
    Class3.call(this);
    var chartElement = chart.element;
    this.options = deepExtend({}, this.options, options2);
    this.chart = chart;
    this.observer = observer;
    this.chartElement = chartElement;
    this.categoryAxis = categoryAxis;
    this._dateAxis = this.categoryAxis instanceof DateCategoryAxis;
    this.initOptions();
    this.visible = this.options.visible && chartElement.offsetHeight;
    if (this.visible) {
      this.createElements();
      this.set(this._index(this.options.from), this._index(this.options.to));
      this.bindEvents();
    }
  }
  if (Class3)
    Selection2.__proto__ = Class3;
  Selection2.prototype = Object.create(Class3 && Class3.prototype);
  Selection2.prototype.constructor = Selection2;
  Selection2.prototype.onPane = function onPane(pane) {
    return this.categoryAxis.pane === pane;
  };
  Selection2.prototype.createElements = function createElements() {
    var options2 = this.options;
    var wrapper2 = this.wrapper = createDiv$1("k-selector k-pointer-events-none");
    elementStyles(wrapper2, {
      top: options2.offset.top,
      left: options2.offset.left,
      width: options2.width,
      height: options2.height,
      direction: "ltr"
    });
    var selection = this.selection = createDiv$1("k-selection k-pointer-events-none");
    this.leftMask = createDiv$1("k-mask k-pointer-events-none");
    this.rightMask = createDiv$1("k-mask k-pointer-events-none");
    wrapper2.appendChild(this.leftMask);
    wrapper2.appendChild(this.rightMask);
    wrapper2.appendChild(selection);
    var body = this.body = createDiv$1("k-selection-bg k-pointer-events-none");
    selection.appendChild(body);
    var leftHandle = this.leftHandle = createDiv$1("k-handle k-left-handle k-pointer-events-auto");
    var rightHandle = this.rightHandle = createDiv$1("k-handle k-right-handle k-pointer-events-auto");
    leftHandle.appendChild(createDiv$1());
    rightHandle.appendChild(createDiv$1());
    selection.appendChild(leftHandle);
    selection.appendChild(rightHandle);
    this.chartElement.appendChild(wrapper2);
    var selectionStyles = elementStyles(selection, ["borderLeftWidth", "borderRightWidth", "height"]);
    var leftHandleHeight = elementStyles(leftHandle, "height").height;
    var rightHandleHeight = elementStyles(rightHandle, "height").height;
    options2.selection = {
      border: {
        left: selectionStyles.borderLeftWidth,
        right: selectionStyles.borderRightWidth
      }
    };
    elementStyles(leftHandle, {
      top: (selectionStyles.height - leftHandleHeight) / 2
    });
    elementStyles(rightHandle, {
      top: (selectionStyles.height - rightHandleHeight) / 2
    });
    wrapper2.style.cssText = wrapper2.style.cssText;
  };
  Selection2.prototype.bindEvents = function bindEvents$12() {
    var obj;
    if (this.options.mousewheel !== false) {
      this._mousewheelHandler = this._mousewheel.bind(this);
      bindEvents(this.chartElement, (obj = {}, obj[MOUSEWHEEL$1] = this._mousewheelHandler, obj));
    }
    this._domEvents = DomEventsBuilder.create(this.chartElement, {
      stopPropagation: true,
      // applicable for the jQuery UserEvents
      start: this._start.bind(this),
      move: this._move.bind(this),
      end: this._end.bind(this),
      tap: this._tap.bind(this),
      press: this._press.bind(this),
      gesturestart: this._gesturestart.bind(this),
      gesturechange: this._gesturechange.bind(this),
      gestureend: this._gestureend.bind(this)
    });
  };
  Selection2.prototype.initOptions = function initOptions() {
    var ref2 = this;
    var options2 = ref2.options;
    var categoryAxis = ref2.categoryAxis;
    var box = categoryAxis.pane.chartsBox();
    var intlService = this.chart.chartService.intl;
    if (this._dateAxis) {
      deepExtend(options2, {
        min: parseDate(intlService, options2.min),
        max: parseDate(intlService, options2.max),
        from: parseDate(intlService, options2.from),
        to: parseDate(intlService, options2.to)
      });
    }
    var ref$1 = elementStyles(this.chartElement, ["paddingLeft", "paddingTop"]);
    var paddingLeft = ref$1.paddingLeft;
    var paddingTop = ref$1.paddingTop;
    this.options = deepExtend({}, {
      width: box.width(),
      height: box.height() + SELECTOR_HEIGHT_ADJUST,
      //workaround for sub-pixel hover on the paths in chrome
      padding: {
        left: paddingLeft,
        top: paddingTop
      },
      offset: {
        left: box.x1 + paddingLeft,
        top: box.y1 + paddingTop
      },
      from: options2.min,
      to: options2.max
    }, options2);
  };
  Selection2.prototype.destroy = function destroy2() {
    var obj;
    if (this._domEvents) {
      this._domEvents.destroy();
      delete this._domEvents;
    }
    clearTimeout(this._mwTimeout);
    this._state = null;
    if (this.wrapper) {
      if (this._mousewheelHandler) {
        unbindEvents(this.chartElement, (obj = {}, obj[MOUSEWHEEL$1] = this._mousewheelHandler, obj));
        this._mousewheelHandler = null;
      }
      this.chartElement.removeChild(this.wrapper);
      this.wrapper = null;
    }
  };
  Selection2.prototype._rangeEventArgs = function _rangeEventArgs(range) {
    return {
      axis: this.categoryAxis.options,
      from: this._value(range.from),
      to: this._value(range.to)
    };
  };
  Selection2.prototype._pointInPane = function _pointInPane(x3, y4) {
    var paneBox = this.categoryAxis.pane.box;
    var modelCoords = this.chart._toModelCoordinates(x3, y4);
    return paneBox.containsPoint(modelCoords);
  };
  Selection2.prototype._start = function _start(e3) {
    var options2 = this.options;
    var target = eventElement(e3);
    if (this._state || !target) {
      return;
    }
    var coords = eventCoordinates(e3);
    var inPane = this._pointInPane(coords.x, coords.y);
    if (!inPane) {
      return;
    }
    var handle = closestHandle(target);
    var bodyRect = this.body.getBoundingClientRect();
    var inBody = !handle && coords.x >= bodyRect.x && coords.x <= bodyRect.x + bodyRect.width && coords.y >= bodyRect.y && coords.y <= bodyRect.y + bodyRect.height;
    this.chart._unsetActivePoint();
    this._state = {
      moveTarget: handle,
      startLocation: e3.x ? e3.x.location : 0,
      inBody,
      range: {
        from: this._index(options2.from),
        to: this._index(options2.to)
      }
    };
    var args = this._rangeEventArgs({
      from: this._index(options2.from),
      to: this._index(options2.to)
    });
    if (this.trigger(SELECT_START, args)) {
      this._state = null;
    }
  };
  Selection2.prototype._press = function _press(e3) {
    var handle;
    if (this._state) {
      handle = this._state.moveTarget;
    } else {
      handle = closestHandle(eventElement(e3));
    }
    if (handle) {
      addClass2(handle, "k-handle-active");
    }
  };
  Selection2.prototype._move = function _move(e3) {
    if (!this._state) {
      return;
    }
    var ref2 = this;
    var state = ref2._state;
    var options2 = ref2.options;
    var categoryAxis = ref2.categoryAxis;
    var range = state.range;
    var target = state.moveTarget;
    var reverse = categoryAxis.options.reverse;
    var from = this._index(options2.from);
    var to = this._index(options2.to);
    var min2 = this._index(options2.min);
    var max2 = this._index(options2.max);
    var delta = state.startLocation - e3.x.location;
    var oldRange = { from: range.from, to: range.to };
    var span = range.to - range.from;
    var scale = elementStyles(this.wrapper, "width").width / (categoryAxis.categoriesCount() - 1);
    var offset2 = Math.round(delta / scale) * (reverse ? -1 : 1);
    if (!target && !state.inBody) {
      return;
    }
    var leftHandle = target && hasClasses(target, "k-left-handle");
    var rightHandle = target && hasClasses(target, "k-right-handle");
    if (state.inBody) {
      range.from = Math.min(
        Math.max(min2, from - offset2),
        max2 - span
      );
      range.to = Math.min(
        range.from + span,
        max2
      );
    } else if (leftHandle && !reverse || rightHandle && reverse) {
      range.from = Math.min(
        Math.max(min2, from - offset2),
        max2 - 1
      );
      range.to = Math.max(range.from + 1, range.to);
    } else if (leftHandle && reverse || rightHandle && !reverse) {
      range.to = Math.min(
        Math.max(min2 + 1, to - offset2),
        max2
      );
      range.from = Math.min(range.to - 1, range.from);
    }
    if (range.from !== oldRange.from || range.to !== oldRange.to) {
      this.move(range.from, range.to);
      this.trigger(SELECT, this._rangeEventArgs(range));
    }
  };
  Selection2.prototype._end = function _end() {
    if (this._state) {
      var moveTarget = this._state.moveTarget;
      if (moveTarget) {
        removeClass2(moveTarget, "k-handle-active");
      }
      var range = this._state.range;
      this.set(range.from, range.to);
      this.trigger(SELECT_END, this._rangeEventArgs(range));
      delete this._state;
    }
  };
  Selection2.prototype._tap = function _tap(e3) {
    var ref2 = this;
    var options2 = ref2.options;
    var categoryAxis = ref2.categoryAxis;
    var coords = this.chart._eventCoordinates(e3);
    var categoryIx = categoryAxis.pointCategoryIndex(new Point$5(coords.x, categoryAxis.box.y1));
    var from = this._index(options2.from);
    var to = this._index(options2.to);
    var min2 = this._index(options2.min);
    var max2 = this._index(options2.max);
    var span = to - from;
    var mid = from + span / 2;
    var range = {};
    var rightClick = e3.event.which === 3;
    var offset2 = Math.round(mid - categoryIx);
    if (this._state || rightClick) {
      return;
    }
    this.chart._unsetActivePoint();
    if (!categoryAxis.options.justified) {
      offset2--;
    }
    range.from = Math.min(
      Math.max(min2, from - offset2),
      max2 - span
    );
    range.to = Math.min(range.from + span, max2);
    this._start(e3);
    if (this._state) {
      this._state.range = range;
      this.trigger(SELECT, this._rangeEventArgs(range));
      this._end();
    }
  };
  Selection2.prototype._mousewheel = function _mousewheel(e3) {
    var this$1$1 = this;
    var delta = mousewheelDelta(e3);
    this._start(e3);
    if (this._state) {
      var range = this._state.range;
      e3.preventDefault();
      e3.stopPropagation();
      if (Math.abs(delta) > 1) {
        delta *= ZOOM_ACCELERATION$1;
      }
      if (this.options.mousewheel.reverse) {
        delta *= -1;
      }
      if (this.expand(delta)) {
        this.trigger(SELECT, {
          axis: this.categoryAxis.options,
          delta,
          originalEvent: e3,
          from: this._value(range.from),
          to: this._value(range.to)
        });
      }
      if (this._mwTimeout) {
        clearTimeout(this._mwTimeout);
      }
      this._mwTimeout = setTimeout(function() {
        this$1$1._end();
      }, MOUSEWHEEL_DELAY);
    }
  };
  Selection2.prototype._gesturestart = function _gesturestart(e3) {
    var options2 = this.options;
    var touch = e3.touches[0];
    var inPane = this._pointInPane(touch.pageX, touch.pageY);
    if (!inPane) {
      return;
    }
    this._state = {
      range: {
        from: this._index(options2.from),
        to: this._index(options2.to)
      }
    };
    var args = this._rangeEventArgs(this._state.range);
    if (this.trigger(SELECT_START, args)) {
      this._state = null;
    } else {
      e3.preventDefault();
    }
  };
  Selection2.prototype._gestureend = function _gestureend() {
    if (this._state) {
      this.trigger(SELECT_END, this._rangeEventArgs(this._state.range));
      delete this._state;
    }
  };
  Selection2.prototype._gesturechange = function _gesturechange(e3) {
    if (!this._state) {
      return;
    }
    var ref2 = this;
    var chart = ref2.chart;
    var state = ref2._state;
    var options2 = ref2.options;
    var categoryAxis = ref2.categoryAxis;
    var range = state.range;
    var p0 = chart._toModelCoordinates(e3.touches[0].x.location).x;
    var p1 = chart._toModelCoordinates(e3.touches[1].x.location).x;
    var left = Math.min(p0, p1);
    var right = Math.max(p0, p1);
    e3.preventDefault();
    range.from = categoryAxis.pointCategoryIndex(new Point$5(left)) || options2.min;
    range.to = categoryAxis.pointCategoryIndex(new Point$5(right)) || options2.max;
    this.move(range.from, range.to);
    this.trigger(SELECT, this._rangeEventArgs(range));
  };
  Selection2.prototype._index = function _index(value2) {
    var index2 = value2;
    if (value2 instanceof Date) {
      index2 = this.categoryAxis.categoryIndex(value2);
    }
    return index2;
  };
  Selection2.prototype._value = function _value(index2) {
    var value2 = index2;
    if (this._dateAxis) {
      value2 = this.categoryAxis.categoryAt(index2);
      if (value2 > this.options.max) {
        value2 = this.options.max;
      }
    }
    return value2;
  };
  Selection2.prototype._slot = function _slot(value2) {
    var categoryAxis = this.categoryAxis;
    var index2 = this._index(value2);
    return categoryAxis.getSlot(index2, index2, true);
  };
  Selection2.prototype.move = function move(from, to) {
    var options2 = this.options;
    var reverse = this.categoryAxis.options.reverse;
    var offset2 = options2.offset;
    var padding = options2.padding;
    var border = options2.selection.border;
    var left = reverse ? to : from;
    var right = reverse ? from : to;
    var edge = "x" + (reverse ? 2 : 1);
    var box = this._slot(left);
    var leftMaskWidth = round$1(box[edge] - offset2.left + padding.left);
    elementStyles(this.leftMask, {
      width: leftMaskWidth
    });
    elementStyles(this.selection, {
      left: leftMaskWidth
    });
    box = this._slot(right);
    var rightMaskWidth = round$1(options2.width - (box[edge] - offset2.left + padding.left));
    elementStyles(this.rightMask, {
      width: rightMaskWidth
    });
    var distance = options2.width - rightMaskWidth;
    if (distance !== options2.width) {
      distance += border.right;
    }
    elementStyles(this.rightMask, {
      left: distance
    });
    elementStyles(this.selection, {
      width: Math.max(options2.width - (leftMaskWidth + rightMaskWidth) - border.right, 0)
    });
  };
  Selection2.prototype.set = function set4(from, to) {
    var options2 = this.options;
    var min2 = this._index(options2.min);
    var max2 = this._index(options2.max);
    var fromValue = limitValue(this._index(from), min2, max2);
    var toValue = limitValue(this._index(to), fromValue + 1, max2);
    if (options2.visible) {
      this.move(fromValue, toValue);
    }
    options2.from = this._value(fromValue);
    options2.to = this._value(toValue);
  };
  Selection2.prototype.expand = function expand(delta) {
    var options2 = this.options;
    var min2 = this._index(options2.min);
    var max2 = this._index(options2.max);
    var zDir = options2.mousewheel.zoom;
    var from = this._index(options2.from);
    var to = this._index(options2.to);
    var range = { from, to };
    var oldRange = deepExtend({}, range);
    if (this._state) {
      range = this._state.range;
    }
    if (zDir !== RIGHT) {
      range.from = limitValue(
        limitValue(from - delta, 0, to - 1),
        min2,
        max2
      );
    }
    if (zDir !== LEFT) {
      range.to = limitValue(
        limitValue(to + delta, range.from + 1, max2),
        min2,
        max2
      );
    }
    if (range.from !== oldRange.from || range.to !== oldRange.to) {
      this.set(range.from, range.to);
      return true;
    }
  };
  Selection2.prototype.zoom = function zoom(delta, coords) {
    var options2 = this.options;
    var min2 = this._index(options2.min);
    var max2 = this._index(options2.max);
    var from = this._index(options2.from);
    var to = this._index(options2.to);
    var range = { from, to };
    var oldRange = deepExtend({}, range);
    var ref2 = this.categoryAxis.options;
    var reverse = ref2.reverse;
    var origin = X$4 + (reverse ? "2" : "1");
    var lineBox = this.categoryAxis.lineBox();
    var relative = Math.abs(lineBox[origin] - coords[X$4]);
    var size = lineBox.width();
    var position2 = round$1(relative / size, 2);
    var minDelta = round$1(position2 * delta);
    var maxDelta = round$1((1 - position2) * delta);
    if (this._state) {
      range = this._state.range;
    }
    range.from = limitValue(
      limitValue(from - minDelta, 0, to - 1),
      min2,
      max2
    );
    range.to = limitValue(
      limitValue(to + maxDelta, range.from + 1, max2),
      min2,
      max2
    );
    if (range.from !== oldRange.from || range.to !== oldRange.to) {
      this.set(range.from, range.to);
      return true;
    }
  };
  Selection2.prototype.trigger = function trigger2(name2, args) {
    return (this.observer || this.chart).trigger(name2, args);
  };
  return Selection2;
}(Class$1);
setDefaultOptions(Selection, {
  visible: true,
  mousewheel: {
    zoom: "both"
  },
  min: MIN_VALUE,
  max: MAX_VALUE
});
var Tooltip$1 = function(BaseTooltip2) {
  function Tooltip2() {
    BaseTooltip2.apply(this, arguments);
  }
  if (BaseTooltip2)
    Tooltip2.__proto__ = BaseTooltip2;
  Tooltip2.prototype = Object.create(BaseTooltip2 && BaseTooltip2.prototype);
  Tooltip2.prototype.constructor = Tooltip2;
  Tooltip2.prototype.show = function show2(point2) {
    if (!point2 || !point2.tooltipAnchor || this._current && this._current === point2) {
      return;
    }
    var options2 = deepExtend({}, this.options, point2.options.tooltip);
    var anchor = point2.tooltipAnchor();
    if (anchor) {
      this._current = point2;
      BaseTooltip2.prototype.show.call(this, {
        point: point2,
        anchor
      }, options2, point2);
    } else {
      this.hide();
    }
  };
  Tooltip2.prototype.hide = function hide2() {
    delete this._current;
    BaseTooltip2.prototype.hide.call(this);
  };
  return Tooltip2;
}(BaseTooltip);
var SharedTooltip$1 = function(BaseTooltip2) {
  function SharedTooltip2(plotArea, options2) {
    BaseTooltip2.call(this, plotArea.chartService, options2);
    this.plotArea = plotArea;
    this.formatService = plotArea.chartService.format;
  }
  if (BaseTooltip2)
    SharedTooltip2.__proto__ = BaseTooltip2;
  SharedTooltip2.prototype = Object.create(BaseTooltip2 && BaseTooltip2.prototype);
  SharedTooltip2.prototype.constructor = SharedTooltip2;
  SharedTooltip2.prototype.showAt = function showAt(points2, coords) {
    var tooltipPoints = grep(points2, function(point3) {
      var tooltip = point3.series.tooltip;
      var excluded = tooltip && tooltip.visible === false;
      return !excluded;
    });
    if (tooltipPoints.length > 0) {
      var point2 = tooltipPoints[0];
      var slot = this.plotArea.categoryAxis.getSlot(point2.categoryIx);
      var anchor = coords ? this._slotAnchor(coords, slot) : this._defaultAnchor(point2, slot);
      this.show({
        anchor,
        shared: true,
        points: points2,
        category: point2.category,
        categoryText: this.formatService.auto(this.options.categoryFormat, point2.category),
        series: this.plotArea.series
      }, this.options);
    }
  };
  SharedTooltip2.prototype._slotAnchor = function _slotAnchor(point2, slot) {
    var axis = this.plotArea.categoryAxis;
    var align2 = {
      horizontal: "left",
      vertical: "center"
    };
    if (!axis.options.vertical) {
      point2.x = slot.center().x;
    }
    return {
      point: point2,
      align: align2
    };
  };
  SharedTooltip2.prototype._defaultAnchor = function _defaultAnchor(point2, slot) {
    var box = point2.owner.pane.chartsBox();
    var vertical = this.plotArea.categoryAxis.options.vertical;
    var center = box.center();
    var slotCenter = slot.center();
    var align2 = {
      horizontal: "center",
      vertical: "center"
    };
    var centerPoint;
    if (vertical) {
      centerPoint = new Point$5(center.x, slotCenter.y);
    } else {
      centerPoint = new Point$5(slotCenter.x, center.y);
    }
    return {
      point: centerPoint,
      align: align2
    };
  };
  return SharedTooltip2;
}(BaseTooltip);
setDefaultOptions(SharedTooltip$1, {
  categoryFormat: "{0:d}"
});
var BarChartAnimation = function(superclass) {
  function BarChartAnimation2() {
    superclass.apply(this, arguments);
  }
  if (superclass)
    BarChartAnimation2.__proto__ = superclass;
  BarChartAnimation2.prototype = Object.create(superclass && superclass.prototype);
  BarChartAnimation2.prototype.constructor = BarChartAnimation2;
  BarChartAnimation2.prototype.setup = function setup() {
    var ref2 = this;
    var element = ref2.element;
    var options2 = ref2.options;
    var bbox = element.bbox();
    if (bbox) {
      this.origin = options2.origin;
      var axis = options2.vertical ? Y$7 : X$4;
      var fromScale = this.fromScale = new Point$7(1, 1);
      fromScale[axis] = START_SCALE;
      element.transform(
        transform().scale(fromScale.x, fromScale.y)
      );
    } else {
      this.abort();
    }
  };
  BarChartAnimation2.prototype.step = function step(pos) {
    var scaleX = interpolateValue(this.fromScale.x, 1, pos);
    var scaleY = interpolateValue(this.fromScale.y, 1, pos);
    this.element.transform(
      transform().scale(scaleX, scaleY, this.origin)
    );
  };
  BarChartAnimation2.prototype.abort = function abort() {
    superclass.prototype.abort.call(this);
    this.element.transform(null);
  };
  return BarChartAnimation2;
}(Animation$2);
setDefaultOptions(BarChartAnimation, {
  duration: INITIAL_ANIMATION_DURATION
});
AnimationFactory$1.current.register(BAR, BarChartAnimation);
var BubbleAnimation = function(superclass) {
  function BubbleAnimation2() {
    superclass.apply(this, arguments);
  }
  if (superclass)
    BubbleAnimation2.__proto__ = superclass;
  BubbleAnimation2.prototype = Object.create(superclass && superclass.prototype);
  BubbleAnimation2.prototype.constructor = BubbleAnimation2;
  BubbleAnimation2.prototype.setup = function setup() {
    var center = this.center = this.element.bbox().center();
    this.element.transform(
      transform().scale(START_SCALE, START_SCALE, center)
    );
  };
  BubbleAnimation2.prototype.step = function step(pos) {
    this.element.transform(
      transform().scale(pos, pos, this.center)
    );
  };
  return BubbleAnimation2;
}(Animation$2);
setDefaultOptions(BubbleAnimation, {
  easing: "easeOutElastic"
});
AnimationFactory$1.current.register(BUBBLE, BubbleAnimation);
var FadeInAnimation = function(superclass) {
  function FadeInAnimation2() {
    superclass.apply(this, arguments);
  }
  if (superclass)
    FadeInAnimation2.__proto__ = superclass;
  FadeInAnimation2.prototype = Object.create(superclass && superclass.prototype);
  FadeInAnimation2.prototype.constructor = FadeInAnimation2;
  FadeInAnimation2.prototype.setup = function setup() {
    this.fadeTo = this.element.opacity();
    this.element.opacity(0);
  };
  FadeInAnimation2.prototype.step = function step(pos) {
    this.element.opacity(pos * this.fadeTo);
  };
  return FadeInAnimation2;
}(Animation$2);
setDefaultOptions(FadeInAnimation, {
  duration: 200,
  easing: "linear"
});
AnimationFactory$1.current.register(FADEIN, FadeInAnimation);
var PieAnimation = function(superclass) {
  function PieAnimation2() {
    superclass.apply(this, arguments);
  }
  if (superclass)
    PieAnimation2.__proto__ = superclass;
  PieAnimation2.prototype = Object.create(superclass && superclass.prototype);
  PieAnimation2.prototype.constructor = PieAnimation2;
  PieAnimation2.prototype.setup = function setup() {
    this.element.transform(
      transform().scale(START_SCALE, START_SCALE, this.options.center)
    );
  };
  PieAnimation2.prototype.step = function step(pos) {
    this.element.transform(
      transform().scale(pos, pos, this.options.center)
    );
  };
  return PieAnimation2;
}(Animation$2);
setDefaultOptions(PieAnimation, {
  easing: "easeOutElastic",
  duration: INITIAL_ANIMATION_DURATION
});
AnimationFactory$1.current.register(PIE, PieAnimation);
var ScatterLineChart = function(ScatterChart2) {
  function ScatterLineChart2() {
    ScatterChart2.apply(this, arguments);
  }
  if (ScatterChart2)
    ScatterLineChart2.__proto__ = ScatterChart2;
  ScatterLineChart2.prototype = Object.create(ScatterChart2 && ScatterChart2.prototype);
  ScatterLineChart2.prototype.constructor = ScatterLineChart2;
  ScatterLineChart2.prototype.render = function render() {
    ScatterChart2.prototype.render.call(this);
    this.renderSegments();
  };
  ScatterLineChart2.prototype.createSegment = function createSegment(linePoints, currentSeries, seriesIx) {
    var style2 = currentSeries.style;
    var pointType;
    if (style2 === SMOOTH) {
      pointType = SplineSegment;
    } else {
      pointType = LineSegment;
    }
    return new pointType(linePoints, currentSeries, seriesIx);
  };
  ScatterLineChart2.prototype.animationPoints = function animationPoints() {
    var points2 = ScatterChart2.prototype.animationPoints.call(this);
    return points2.concat(this._segments);
  };
  ScatterLineChart2.prototype.createMissingValue = function createMissingValue(value2, missingValues) {
    if (missingValues === ZERO) {
      var missingValue = {
        x: value2.x,
        y: value2.y
      };
      if (!hasValue$1(missingValue.x)) {
        missingValue.x = 0;
      }
      if (!hasValue$1(missingValue.y)) {
        missingValue.y = 0;
      }
      return missingValue;
    }
  };
  return ScatterLineChart2;
}(ScatterChart);
deepExtend(ScatterLineChart.prototype, LineChartMixin);
function getScatterTrendlineData(valueMapper, range, options2) {
  var data2 = [];
  var xMin = range.xMin;
  var xMax = range.xMax;
  var forecast = (options2 || {}).forecast;
  if (forecast) {
    if (forecast.before > 0) {
      xMin -= forecast.before;
    }
    if (forecast.after > 0) {
      xMax += forecast.after;
    }
  }
  var samplingInterval = (options2 || {}).samplingInterval;
  var delta = valueOrDefault$1(samplingInterval, autoMajorUnit(xMin, xMax) / 10);
  if (samplingInterval <= 0) {
    delta = xMax - xMin;
  }
  for (var x3 = xMin; x3 <= xMax; x3 += delta) {
    data2.push([
      x3,
      valueMapper(x3)
    ]);
  }
  return data2;
}
function scatterExponentialTrendline(context2) {
  var options2 = context2.options;
  var seriesValues = context2.seriesValues;
  var data2 = getData$5({ seriesValues, options: options2 });
  if (data2) {
    return Object.assign(
      {},
      options2,
      {
        type: "scatterLine",
        data: data2
      }
    );
  }
  return null;
}
var valueGetter$2 = function(fieldName) {
  return function(ref2) {
    var valueFields = ref2.valueFields;
    return { xValue: valueFields.x, yValue: Math.log(valueFields[fieldName]) };
  };
};
function getData$5(ref2) {
  var seriesValues = ref2.seriesValues;
  var options2 = ref2.options;
  var sourceValues = seriesValues();
  if (!checkAllPositive(sourceValues, options2.field)) {
    return null;
  }
  var ref$1 = calculateSlope(sourceValues, valueGetter$2(options2.field));
  var slope = ref$1.slope;
  var intercept = ref$1.intercept;
  var count = ref$1.count;
  var xMin = ref$1.xMin;
  var xMax = ref$1.xMax;
  var range = { xMin, xMax };
  if (count > 0) {
    var a9 = Math.exp(intercept);
    var b2 = slope;
    return getScatterTrendlineData(function(x3) {
      return a9 * Math.exp(b2 * x3);
    }, range, options2.trendline);
  }
  return null;
}
var scatterValueGetter = function(fieldName) {
  return function(ref2) {
    var valueFields = ref2.valueFields;
    return { xValue: valueFields.x, yValue: valueFields[fieldName] };
  };
};
function scatterLinearTrendline(context2) {
  var options2 = context2.options;
  var seriesValues = context2.seriesValues;
  var data2 = getData$4({ seriesValues, options: options2 });
  if (data2) {
    return Object.assign(
      {},
      options2,
      {
        type: "scatterLine",
        data: data2
      }
    );
  }
  return null;
}
function getData$4(ref2) {
  var seriesValues = ref2.seriesValues;
  var options2 = ref2.options;
  var ref$1 = calculateSlope(seriesValues(), scatterValueGetter(options2.field));
  var slope = ref$1.slope;
  var intercept = ref$1.intercept;
  var count = ref$1.count;
  var xMin = ref$1.xMin;
  var xMax = ref$1.xMax;
  var range = { xMin, xMax };
  if (count > 0) {
    return getScatterTrendlineData(function(x3) {
      return slope * x3 + intercept;
    }, range, options2.trendline);
  }
  return null;
}
function xValueLimits(sourceValues, valueGetter2) {
  var xMin = Number.MAX_VALUE;
  var xMax = Number.MIN_VALUE;
  for (var i16 = 0; i16 < sourceValues.length; i16++) {
    var value2 = sourceValues[i16];
    var ref2 = valueGetter2(value2);
    var xValue = ref2.xValue;
    var yValue = ref2.yValue;
    if (isFinite(xValue) && xValue !== null && isFinite(yValue) && yValue !== null) {
      xMin = Math.min(xValue, xMin);
      xMax = Math.max(xValue, xMax);
    }
  }
  return { xMin, xMax };
}
function scatterLogarithmicTrendline(context2) {
  var options2 = context2.options;
  var seriesValues = context2.seriesValues;
  var data2 = getData$3({ seriesValues, options: options2 });
  if (data2) {
    return Object.assign(
      {},
      options2,
      {
        type: "scatterLine",
        data: data2
      }
    );
  }
  return null;
}
var valueGetter$1 = function(fieldName) {
  return function(ref2) {
    var valueFields = ref2.valueFields;
    return { xValue: valueFields.x, yValue: valueFields[fieldName] };
  };
};
var logValueGetter = function(fieldName) {
  return function(ref2) {
    var valueFields = ref2.valueFields;
    return { xValue: Math.log(valueFields.x), yValue: valueFields[fieldName] };
  };
};
function getData$3(ref2) {
  var seriesValues = ref2.seriesValues;
  var options2 = ref2.options;
  var sourceValues = seriesValues();
  if (!checkAllPositive(sourceValues, "x")) {
    return null;
  }
  var ref$1 = calculateSlope(sourceValues, logValueGetter(options2.field));
  var slope = ref$1.slope;
  var intercept = ref$1.intercept;
  var count = ref$1.count;
  var range = xValueLimits(sourceValues, valueGetter$1(options2.field));
  if (count > 0) {
    var a9 = slope;
    var b2 = intercept;
    return getScatterTrendlineData(function(x3) {
      return a9 * Math.log(x3) + b2;
    }, range, options2.trendline);
  }
  return null;
}
function scatterMovingAverageTrendline(context2) {
  var options2 = context2.options;
  var data2 = getData$2(context2);
  if (data2) {
    return Object.assign(
      {},
      options2,
      {
        type: "scatterLine",
        data: data2
      }
    );
  }
  return null;
}
function getData$2(ref2) {
  var options2 = ref2.options;
  var seriesValues = ref2.seriesValues;
  var period = (options2.trendline || {}).period || MIN_MOVING_AVERAGE_PERIOD;
  var range = { before: period, after: period };
  var data2 = calculateMovingAverage(seriesValues(range), scatterValueGetter(options2.field), period);
  if (data2.length > 0) {
    return data2;
  }
  return null;
}
function scatterPolynomialTrendline(context2) {
  var options2 = context2.options;
  var seriesValues = context2.seriesValues;
  var data2 = getData$1({ seriesValues, options: options2 });
  if (data2) {
    return Object.assign(
      {},
      options2,
      {
        type: "scatterLine",
        data: data2
      }
    );
  }
  return null;
}
function getData$1(ref2) {
  var seriesValues = ref2.seriesValues;
  var options2 = ref2.options;
  var order = (options2.trendline || {}).order;
  var valueGetter2 = scatterValueGetter(options2.field);
  var ref$1 = calculatePolynomial(seriesValues(), valueGetter2, order);
  var count = ref$1.count;
  var valueMapper = ref$1.valueMapper;
  var xMin = ref$1.xMin;
  var xMax = ref$1.xMax;
  var range = { xMin, xMax };
  if (count > 0) {
    return getScatterTrendlineData(valueMapper, range, options2.trendline);
  }
  return null;
}
function scatterPowerTrendline(context2) {
  var options2 = context2.options;
  var seriesValues = context2.seriesValues;
  var data2 = getData({ seriesValues, options: options2 });
  if (data2) {
    return Object.assign(
      {},
      options2,
      {
        type: "scatterLine",
        data: data2
      }
    );
  }
  return null;
}
var valueGetter = function(fieldName) {
  return function(ref2) {
    var valueFields = ref2.valueFields;
    return { xValue: Math.log(valueFields.x), yValue: Math.log(valueFields[fieldName]) };
  };
};
function getData(ref2) {
  var seriesValues = ref2.seriesValues;
  var options2 = ref2.options;
  var sourceValues = seriesValues();
  if (!checkAllPositive(sourceValues, "x")) {
    return null;
  }
  var ref$1 = calculateSlope(sourceValues, valueGetter(options2.field));
  var slope = ref$1.slope;
  var intercept = ref$1.intercept;
  var count = ref$1.count;
  var range = xValueLimits(sourceValues, scatterValueGetter(options2.field));
  if (count > 0) {
    var a9 = Math.exp(intercept);
    var b2 = slope;
    return getScatterTrendlineData(function(x3) {
      return a9 * Math.pow(x3, b2);
    }, range, options2.trendline);
  }
  return null;
}
var scatterRegistry = {};
scatterRegistry[TRENDLINE_EXPONENTIAL] = scatterExponentialTrendline;
scatterRegistry[TRENDLINE_LINEAR] = scatterLinearTrendline;
scatterRegistry[TRENDLINE_LOGARITHMIC] = scatterLogarithmicTrendline;
scatterRegistry[TRENDLINE_MOVING_AVERAGE] = scatterMovingAverageTrendline;
scatterRegistry[TRENDLINE_POLYNOMIAL] = scatterPolynomialTrendline;
scatterRegistry[TRENDLINE_POWER] = scatterPowerTrendline;
var XYPlotArea = function(PlotAreaBase2) {
  function XYPlotArea2() {
    PlotAreaBase2.apply(this, arguments);
  }
  if (PlotAreaBase2)
    XYPlotArea2.__proto__ = PlotAreaBase2;
  XYPlotArea2.prototype = Object.create(PlotAreaBase2 && PlotAreaBase2.prototype);
  XYPlotArea2.prototype.constructor = XYPlotArea2;
  XYPlotArea2.prototype.initFields = function initFields() {
    this.namedXAxes = {};
    this.namedYAxes = {};
    this.xAxisRangeTracker = new AxisGroupRangeTracker();
    this.yAxisRangeTracker = new AxisGroupRangeTracker();
  };
  XYPlotArea2.prototype.render = function render(panes) {
    var this$1$1 = this;
    if (panes === void 0)
      panes = this.panes;
    this.series = [].concat(this.originalSeries);
    this.createTrendlineSeries();
    var seriesByPane = this.groupSeriesByPane();
    for (var i16 = 0; i16 < panes.length; i16++) {
      var pane = panes[i16];
      var paneSeries = seriesByPane[pane.options.name || "default"] || [];
      this$1$1.addToLegend(paneSeries);
      var filteredSeries = this$1$1.filterVisibleSeries(paneSeries);
      if (!filteredSeries) {
        continue;
      }
      this$1$1.createScatterChart(
        filterSeriesByType(filteredSeries, SCATTER),
        pane
      );
      this$1$1.createScatterLineChart(
        filterSeriesByType(filteredSeries, SCATTER_LINE),
        pane
      );
      this$1$1.createBubbleChart(
        filterSeriesByType(filteredSeries, BUBBLE),
        pane
      );
    }
    this.createAxes(panes);
  };
  XYPlotArea2.prototype.appendChart = function appendChart(chart, pane) {
    this.xAxisRangeTracker.update(chart.xAxisRanges);
    this.yAxisRangeTracker.update(chart.yAxisRanges);
    PlotAreaBase2.prototype.appendChart.call(this, chart, pane);
  };
  XYPlotArea2.prototype.removeAxis = function removeAxis(axis) {
    var axisName = axis.options.name;
    PlotAreaBase2.prototype.removeAxis.call(this, axis);
    if (axis.options.vertical) {
      this.yAxisRangeTracker.reset(axisName);
      delete this.namedYAxes[axisName];
    } else {
      this.xAxisRangeTracker.reset(axisName);
      delete this.namedXAxes[axisName];
    }
    if (axis === this.axisX) {
      delete this.axisX;
    }
    if (axis === this.axisY) {
      delete this.axisY;
    }
  };
  XYPlotArea2.prototype.seriesPaneName = function seriesPaneName(series) {
    var options2 = this.options;
    var xAxisName = series.xAxis;
    var xAxisOptions = [].concat(options2.xAxis);
    var xAxis = grep(xAxisOptions, function(a9) {
      return a9.name === xAxisName;
    })[0];
    var yAxisName = series.yAxis;
    var yAxisOptions = [].concat(options2.yAxis);
    var yAxis = grep(yAxisOptions, function(a9) {
      return a9.name === yAxisName;
    })[0];
    var panes = options2.panes || [{}];
    var defaultPaneName = panes[0].name || "default";
    var paneName = (xAxis || {}).pane || (yAxis || {}).pane || defaultPaneName;
    return paneName;
  };
  XYPlotArea2.prototype.createScatterChart = function createScatterChart(series, pane) {
    if (series.length > 0) {
      this.appendChart(
        new ScatterChart(this, { series, clip: pane.options.clip }),
        pane
      );
    }
  };
  XYPlotArea2.prototype.createScatterLineChart = function createScatterLineChart(series, pane) {
    if (series.length > 0) {
      this.appendChart(
        new ScatterLineChart(this, { series, clip: pane.options.clip }),
        pane
      );
    }
  };
  XYPlotArea2.prototype.createBubbleChart = function createBubbleChart(series, pane) {
    if (series.length > 0) {
      this.appendChart(
        new BubbleChart(this, { series, clip: pane.options.clip }),
        pane
      );
    }
  };
  XYPlotArea2.prototype.createXYAxis = function createXYAxis(options2, vertical, axisIndex) {
    var axisName = options2.name;
    var namedAxes = vertical ? this.namedYAxes : this.namedXAxes;
    var tracker = vertical ? this.yAxisRangeTracker : this.xAxisRangeTracker;
    var axisOptions2 = deepExtend({ reverse: !vertical && this.chartService.rtl }, options2, { vertical });
    var isLog = equalsIgnoreCase(axisOptions2.type, LOGARITHMIC);
    var defaultRange = tracker.query();
    var defaultAxisRange = isLog ? { min: 0.1, max: 1 } : { min: 0, max: 1 };
    var range = tracker.query(axisName) || defaultRange || defaultAxisRange;
    var typeSamples = [axisOptions2.min, axisOptions2.max];
    var series = this.series;
    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {
      var currentSeries = series[seriesIx];
      var seriesAxisName = currentSeries[vertical ? "yAxis" : "xAxis"];
      if (seriesAxisName === axisOptions2.name || axisIndex === 0 && !seriesAxisName) {
        var firstPointValue = SeriesBinder.current.bindPoint(currentSeries, 0).valueFields;
        typeSamples.push(firstPointValue[vertical ? "y" : "x"]);
        break;
      }
    }
    if (axisIndex === 0 && defaultRange) {
      range.min = Math.min(range.min, defaultRange.min);
      range.max = Math.max(range.max, defaultRange.max);
    }
    var inferredDate;
    for (var i16 = 0; i16 < typeSamples.length; i16++) {
      if (typeSamples[i16] instanceof Date) {
        inferredDate = true;
        break;
      }
    }
    var axisType;
    if (equalsIgnoreCase(axisOptions2.type, DATE) || !axisOptions2.type && inferredDate) {
      axisType = DateValueAxis;
    } else if (isLog) {
      axisType = LogarithmicAxis;
    } else {
      axisType = NumericAxis;
    }
    var axis = new axisType(range.min, range.max, axisOptions2, this.chartService);
    axis.axisIndex = axisIndex;
    if (axisName) {
      if (namedAxes[axisName]) {
        throw new Error((vertical ? "Y" : "X") + " axis with name " + axisName + " is already defined");
      }
      namedAxes[axisName] = axis;
    }
    this.appendAxis(axis);
    return axis;
  };
  XYPlotArea2.prototype.createAxes = function createAxes(panes) {
    var this$1$1 = this;
    var options2 = this.options;
    var xAxesOptions = [].concat(options2.xAxis);
    var xAxes = [];
    var yAxesOptions = [].concat(options2.yAxis);
    var yAxes = [];
    for (var idx = 0; idx < xAxesOptions.length; idx++) {
      var axisPane = this$1$1.findPane(xAxesOptions[idx].pane);
      if (inArray(axisPane, panes)) {
        xAxes.push(this$1$1.createXYAxis(xAxesOptions[idx], false, idx));
      }
    }
    for (var idx$1 = 0; idx$1 < yAxesOptions.length; idx$1++) {
      var axisPane$1 = this$1$1.findPane(yAxesOptions[idx$1].pane);
      if (inArray(axisPane$1, panes)) {
        yAxes.push(this$1$1.createXYAxis(yAxesOptions[idx$1], true, idx$1));
      }
    }
    this.axisX = this.axisX || xAxes[0];
    this.axisY = this.axisY || yAxes[0];
  };
  XYPlotArea2.prototype._dispatchEvent = function _dispatchEvent(chart, e3, eventType) {
    var coords = chart._eventCoordinates(e3);
    var point2 = new Point$5(coords.x, coords.y);
    var allAxes = this.axes;
    var length = allAxes.length;
    var xValues = [];
    var yValues = [];
    for (var i16 = 0; i16 < length; i16++) {
      var axis = allAxes[i16];
      var values6 = axis.options.vertical ? yValues : xValues;
      var currentValue = axis.getValue(point2);
      if (currentValue !== null) {
        values6.push(currentValue);
      }
    }
    if (xValues.length > 0 && yValues.length > 0) {
      chart.trigger(eventType, {
        element: eventElement(e3),
        originalEvent: e3,
        x: singleItemOrArray(xValues),
        y: singleItemOrArray(yValues)
      });
    }
  };
  XYPlotArea2.prototype.updateAxisOptions = function updateAxisOptions$1$1(axis, options2) {
    var vertical = axis.options.vertical;
    var axes = this.groupAxes(this.panes);
    var index2 = (vertical ? axes.y : axes.x).indexOf(axis);
    updateAxisOptions$1(this.options, index2, vertical, options2);
    updateAxisOptions$1(this.originalOptions, index2, vertical, options2);
  };
  XYPlotArea2.prototype.trendlineFactory = function trendlineFactory$1(options2, series) {
    var seriesValues = this.seriesValues.bind(this, series.index);
    var trendline = trendlineFactory(scatterRegistry, options2.type, {
      options: options2,
      seriesValues
    });
    if (trendline) {
      trendline.xAxis = series.xAxis;
      trendline.yAxis = series.yAxis;
    }
    return trendline;
  };
  XYPlotArea2.prototype.seriesValues = function seriesValues(seriesIx) {
    var this$1$1 = this;
    var result = [];
    var currentSeries = this.series[seriesIx];
    for (var pointIx = 0; pointIx < currentSeries.data.length; pointIx++) {
      var data2 = this$1$1.bindPoint(currentSeries, pointIx);
      result.push({ pointIx, valueFields: data2.valueFields });
    }
    return result;
  };
  return XYPlotArea2;
}(PlotAreaBase);
function updateAxisOptions$1(targetOptions, axisIndex, vertical, options2) {
  var axisOptions2 = [].concat(vertical ? targetOptions.yAxis : targetOptions.xAxis)[axisIndex];
  deepExtend(axisOptions2, options2);
}
setDefaultOptions(XYPlotArea, {
  xAxis: {},
  yAxis: {}
});
deepExtend(XYPlotArea.prototype, PlotAreaEventsMixin);
var PieSegment = function(ChartElement2) {
  function PieSegment2(value2, sector, options2) {
    ChartElement2.call(this, options2);
    this.value = value2;
    this.sector = sector;
  }
  if (ChartElement2)
    PieSegment2.__proto__ = ChartElement2;
  PieSegment2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  PieSegment2.prototype.constructor = PieSegment2;
  PieSegment2.prototype.render = function render() {
    if (this._rendered || this.visible === false) {
      return;
    }
    this._rendered = true;
    this.createLabel();
  };
  PieSegment2.prototype.createLabel = function createLabel() {
    var labels = this.options.labels;
    var chartService = this.owner.chartService;
    var labelText = this.getLabelText(labels);
    if (labels.visible && (labelText || labelText === 0)) {
      if (labels.position === CENTER || labels.position === INSIDE_END) {
        if (!labels.color) {
          labels.color = autoTextColor(this.options.color);
        }
        if (!labels.background) {
          labels.background = this.options.color;
        }
      } else {
        var themeLabels = chartService.theme.seriesDefaults.labels;
        labels.color = labels.color || themeLabels.color;
        labels.background = labels.background || themeLabels.background;
      }
      this.label = new TextBox(labelText, deepExtend({}, labels, {
        align: CENTER,
        vAlign: "",
        animation: {
          type: FADEIN,
          delay: this.animationDelay
        }
      }), this.pointData());
      this.append(this.label);
    }
  };
  PieSegment2.prototype.getLabelText = function getLabelText(options2) {
    var labelTemplate = getTemplate$1(options2);
    if (labelTemplate) {
      return labelTemplate(this.pointData());
    }
    return this.owner.chartService.format.auto(options2.format, this.value);
  };
  PieSegment2.prototype.reflow = function reflow(targetBox) {
    this.render();
    this.box = targetBox;
    this.reflowLabel();
  };
  PieSegment2.prototype.reflowLabel = function reflowLabel() {
    var ref2 = this;
    var labelsOptions = ref2.options.labels;
    var label = ref2.label;
    var sector = this.sector.clone();
    var labelsDistance = labelsOptions.distance;
    var angle = sector.middle();
    if (label) {
      var labelHeight = label.box.height();
      var labelWidth = label.box.width();
      var lp;
      if (labelsOptions.position === CENTER) {
        sector.radius = Math.abs((sector.radius - labelHeight) / 2) + labelHeight;
        lp = sector.point(angle);
        label.reflow(new Box(lp.x, lp.y - labelHeight / 2, lp.x, lp.y));
      } else if (labelsOptions.position === INSIDE_END) {
        sector.radius = sector.radius - labelHeight / 2;
        lp = sector.point(angle);
        label.reflow(new Box(lp.x, lp.y - labelHeight / 2, lp.x, lp.y));
      } else {
        var x1;
        lp = sector.clone().expand(labelsDistance).point(angle);
        if (lp.x >= sector.center.x) {
          x1 = lp.x + labelWidth;
          label.orientation = RIGHT;
        } else {
          x1 = lp.x - labelWidth;
          label.orientation = LEFT;
        }
        label.reflow(new Box(x1, lp.y - labelHeight, lp.x, lp.y));
      }
    }
  };
  PieSegment2.prototype.createVisual = function createVisual() {
    var this$1$1 = this;
    var ref2 = this;
    var sector = ref2.sector;
    var options2 = ref2.options;
    ChartElement2.prototype.createVisual.call(this);
    this.addAccessibilityAttributesToVisual();
    if (this.value) {
      if (options2.visual) {
        var startAngle = (sector.startAngle + 180) % 360;
        var visual = options2.visual({
          category: this.category,
          dataItem: this.dataItem,
          value: this.value,
          series: this.series,
          percentage: this.percentage,
          center: new Point$7(sector.center.x, sector.center.y),
          radius: sector.radius,
          innerRadius: sector.innerRadius,
          startAngle,
          endAngle: startAngle + sector.angle,
          options: options2,
          sender: this.getSender(),
          createVisual: function() {
            var group2 = new Group$9();
            this$1$1.createSegmentVisual(group2);
            return group2;
          }
        });
        if (visual) {
          this.visual.append(visual);
        }
      } else {
        this.createSegmentVisual(this.visual);
      }
    }
  };
  PieSegment2.prototype.createSegmentVisual = function createSegmentVisual(group2) {
    var ref2 = this;
    var sector = ref2.sector;
    var options2 = ref2.options;
    var borderOptions = options2.border || {};
    var border = borderOptions.width > 0 ? {
      stroke: {
        color: borderOptions.color,
        width: borderOptions.width,
        opacity: borderOptions.opacity,
        dashType: borderOptions.dashType
      }
    } : {};
    var color = options2.color;
    var fill = {
      color,
      opacity: options2.opacity
    };
    var visual = this.createSegment(sector, deepExtend({
      fill,
      stroke: {
        opacity: options2.opacity
      },
      zIndex: options2.zIndex
    }, border));
    group2.append(visual);
    if (hasGradientOverlay(options2)) {
      group2.append(this.createGradientOverlay(visual, {
        baseColor: color,
        fallbackFill: fill
      }, deepExtend({
        center: [sector.center.x, sector.center.y],
        innerRadius: sector.innerRadius,
        radius: sector.radius,
        userSpace: true
      }, options2.overlay)));
    }
  };
  PieSegment2.prototype.createSegment = function createSegment(sector, options2) {
    if (options2.singleSegment) {
      return new Circle$3(new geomCircle(new Point$7(sector.center.x, sector.center.y), sector.radius), options2);
    }
    return ShapeBuilder.current.createRing(sector, options2);
  };
  PieSegment2.prototype.createAnimation = function createAnimation() {
    var ref2 = this;
    var options2 = ref2.options;
    var center = ref2.sector.center;
    deepExtend(options2, {
      animation: {
        center: [center.x, center.y],
        delay: this.animationDelay
      }
    });
    ChartElement2.prototype.createAnimation.call(this);
  };
  PieSegment2.prototype.createHighlight = function createHighlight(options2) {
    var highlight = this.options.highlight || {};
    var border = highlight.border || {};
    return this.createSegment(this.sector, deepExtend({}, options2, {
      fill: {
        color: highlight.color,
        opacity: highlight.opacity
      },
      stroke: {
        opacity: border.opacity,
        width: border.width,
        color: border.color
      }
    }));
  };
  PieSegment2.prototype.highlightVisual = function highlightVisual() {
    return this.visual.children[0];
  };
  PieSegment2.prototype.highlightVisualArgs = function highlightVisualArgs() {
    var sector = this.sector;
    return {
      options: this.options,
      radius: sector.radius,
      innerRadius: sector.innerRadius,
      center: new Point$7(sector.center.x, sector.center.y),
      startAngle: sector.startAngle,
      endAngle: sector.angle + sector.startAngle,
      visual: this.visual
    };
  };
  PieSegment2.prototype.createFocusHighlight = function createFocusHighlight(style2) {
    var borderWidth = this.options.accessibility.highlight.border.width;
    var result = this.createSegment(this.sector, deepExtend({}, style2, {
      stroke: {
        width: borderWidth * 2
      }
    }));
    var clipPath = new MultiPath();
    clipPath.paths.push(Path$7.fromRect(result.bbox()));
    clipPath.paths.push(this.createSegment(this.sector, {}));
    result.clip(clipPath);
    return result;
  };
  PieSegment2.prototype.tooltipAnchor = function tooltipAnchor() {
    var sector = this.sector.clone().expand(TOOLTIP_OFFSET);
    var midAndle = sector.middle();
    var midPoint = sector.point(midAndle);
    return {
      point: midPoint,
      align: tooltipAlignment(midAndle + 180)
    };
  };
  PieSegment2.prototype.formatValue = function formatValue(format2) {
    return this.owner.formatPointValue(this, format2);
  };
  PieSegment2.prototype.pointData = function pointData() {
    return {
      dataItem: this.dataItem,
      category: this.category,
      value: this.value,
      series: this.series,
      percentage: this.percentage
    };
  };
  PieSegment2.prototype.getIndex = function getIndex() {
    return this.index;
  };
  return PieSegment2;
}(ChartElement);
var RAD_30 = round$1(rad(30), DEFAULT_PRECISION);
var RAD_60 = round$1(rad(60), DEFAULT_PRECISION);
function tooltipAlignment(angle) {
  var radians = rad(angle);
  var sine = round$1(Math.sin(radians), DEFAULT_PRECISION);
  var cosine = round$1(Math.cos(radians), DEFAULT_PRECISION);
  var horizontal;
  if (Math.abs(sine) > RAD_60) {
    horizontal = CENTER;
  } else if (cosine < 0) {
    horizontal = RIGHT;
  } else {
    horizontal = LEFT;
  }
  var vertical;
  if (Math.abs(sine) < RAD_30) {
    vertical = CENTER;
  } else if (sine < 0) {
    vertical = BOTTOM;
  } else {
    vertical = TOP;
  }
  return {
    horizontal,
    vertical
  };
}
setDefaultOptions(PieSegment, {
  color: WHITE$1,
  overlay: {
    gradient: "roundedBevel"
  },
  border: {
    width: 0.5
  },
  labels: {
    visible: false,
    distance: 35,
    font: DEFAULT_FONT$1,
    margin: getSpacing(0.5),
    align: CIRCLE,
    zIndex: 1,
    position: OUTSIDE_END
  },
  animation: {
    type: PIE
  },
  highlight: {
    visible: true,
    border: {
      width: 1
    }
  },
  visible: true,
  accessibility: {
    role: CHART_POINT_ROLE,
    className: CHART_POINT_CLASSNAME,
    ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION
  }
});
deepExtend(PieSegment.prototype, PointEventsMixin);
deepExtend(PieSegment.prototype, AccessibilityAttributesMixin);
var PieChartMixin = {
  createLegendItem: function(value2, point2, options2) {
    var legendOptions = this.options.legend || {};
    var labelsOptions = legendOptions.labels || {};
    var inactiveItems = legendOptions.inactiveItems || {};
    var inactiveItemsLabels = inactiveItems.labels || {};
    if (options2 && options2.visibleInLegend !== false) {
      var pointVisible = options2.visible !== false;
      var labelTemplate = pointVisible ? getTemplate$1(labelsOptions) : getTemplate$1(inactiveItemsLabels) || getTemplate$1(labelsOptions);
      var text = options2.category;
      if (labelTemplate) {
        text = labelTemplate({
          text,
          series: options2.series,
          dataItem: options2.dataItem,
          percentage: options2.percentage,
          value: value2
        });
      }
      var itemLabelOptions, markerColor;
      if (pointVisible) {
        itemLabelOptions = {};
        markerColor = point2.color;
      } else {
        itemLabelOptions = {
          color: inactiveItemsLabels.color,
          font: inactiveItemsLabels.font
        };
        markerColor = (inactiveItems.markers || {}).color;
      }
      if (hasValue$1(text) && text !== "") {
        this.legendItems.push({
          active: pointVisible,
          pointIndex: options2.index,
          text,
          series: options2.series,
          markerColor,
          labels: itemLabelOptions
        });
      }
    }
  }
};
var PIE_SECTOR_ANIM_DELAY = 70;
var PieChart = function(ChartElement2) {
  function PieChart2(plotArea, options2) {
    ChartElement2.call(this, options2);
    this.plotArea = plotArea;
    this.chartService = plotArea.chartService;
    this.points = [];
    this.legendItems = [];
    this.render();
  }
  if (ChartElement2)
    PieChart2.__proto__ = ChartElement2;
  PieChart2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  PieChart2.prototype.constructor = PieChart2;
  PieChart2.prototype.render = function render() {
    this.traverseDataPoints(this.addValue.bind(this));
  };
  PieChart2.prototype.traverseDataPoints = function traverseDataPoints(callback) {
    var this$1$1 = this;
    var ref2 = this;
    var options2 = ref2.options;
    var seriesColors = ref2.plotArea.options.seriesColors;
    if (seriesColors === void 0)
      seriesColors = [];
    var colorsCount = seriesColors.length;
    var series = options2.series;
    var seriesCount = series.length;
    for (var seriesIx = 0; seriesIx < seriesCount; seriesIx++) {
      var currentSeries = series[seriesIx];
      var data2 = currentSeries.data;
      var ref$1 = bindSegments(currentSeries);
      var total3 = ref$1.total;
      var points2 = ref$1.points;
      var count = ref$1.count;
      var anglePerValue = 360 / total3;
      var constantAngle = void 0;
      if (!isFinite(anglePerValue)) {
        constantAngle = 360 / count;
      }
      var currentAngle = void 0;
      if (defined(currentSeries.startAngle)) {
        currentAngle = currentSeries.startAngle;
      } else {
        currentAngle = options2.startAngle;
      }
      if (seriesIx !== seriesCount - 1) {
        if (currentSeries.labels.position === OUTSIDE_END) {
          currentSeries.labels.position = CENTER;
        }
      }
      for (var i16 = 0; i16 < points2.length; i16++) {
        var pointData = points2[i16];
        if (!pointData) {
          continue;
        }
        var fields = pointData.fields;
        var value2 = pointData.value;
        var visible = pointData.visible;
        var angle = value2 !== 0 ? constantAngle || value2 * anglePerValue : 0;
        var explode = data2.length !== 1 && Boolean(fields.explode);
        if (!isFunction$1(currentSeries.color)) {
          currentSeries.color = fields.color || seriesColors[i16 % colorsCount];
        }
        callback(value2, new Ring(null, 0, 0, currentAngle, angle), {
          owner: this$1$1,
          category: defined(fields.category) ? fields.category : "",
          index: i16,
          series: currentSeries,
          seriesIx,
          dataItem: data2[i16],
          percentage: total3 !== 0 ? value2 / total3 : 0,
          explode,
          visibleInLegend: fields.visibleInLegend,
          visible,
          zIndex: seriesCount - seriesIx,
          animationDelay: this$1$1.animationDelay(i16, seriesIx, seriesCount)
        });
        if (visible !== false) {
          currentAngle += angle;
        }
      }
    }
  };
  PieChart2.prototype.evalSegmentOptions = function evalSegmentOptions(options2, value2, fields) {
    var series = fields.series;
    evalOptions(options2, {
      value: value2,
      series,
      dataItem: fields.dataItem,
      category: fields.category,
      percentage: fields.percentage
    }, { defaults: series._defaults, excluded: [
      "data",
      "content",
      "template",
      "visual",
      "toggle",
      "ariaTemplate",
      "ariaContent"
    ] });
  };
  PieChart2.prototype.addValue = function addValue(value2, sector, fields) {
    var segmentOptions = deepExtend({}, fields.series, { index: fields.index });
    this.evalSegmentOptions(segmentOptions, value2, fields);
    this.createLegendItem(value2, segmentOptions, fields);
    if (fields.visible === false) {
      return;
    }
    var segment = new PieSegment(value2, sector, segmentOptions);
    Object.assign(segment, fields);
    this.append(segment);
    this.points.push(segment);
  };
  PieChart2.prototype.reflow = function reflow(targetBox) {
    var ref2 = this;
    var options2 = ref2.options;
    var points2 = ref2.points;
    var seriesConfigs = ref2.seriesConfigs;
    if (seriesConfigs === void 0)
      seriesConfigs = [];
    var count = points2.length;
    var box = targetBox.clone();
    var space = 5;
    var minWidth = Math.min(box.width(), box.height());
    var halfMinWidth = minWidth / 2;
    var defaultPadding = minWidth - minWidth * 0.85;
    var newBox = new Box(box.x1, box.y1, box.x1 + minWidth, box.y1 + minWidth);
    var newBoxCenter = newBox.center();
    var boxCenter = box.center();
    var seriesCount = options2.series.length;
    var leftSideLabels = [];
    var rightSideLabels = [];
    var padding = valueOrDefault$1(options2.padding, defaultPadding);
    this.targetBox = targetBox;
    padding = padding > halfMinWidth - space ? halfMinWidth - space : padding;
    newBox.translate(boxCenter.x - newBoxCenter.x, boxCenter.y - newBoxCenter.y);
    var radius = halfMinWidth - padding;
    var center = new Point$5(
      radius + newBox.x1 + padding,
      radius + newBox.y1 + padding
    );
    for (var i16 = 0; i16 < count; i16++) {
      var segment = points2[i16];
      var sector = segment.sector;
      var seriesIndex = segment.seriesIx;
      sector.radius = radius;
      sector.center = center;
      if (seriesConfigs.length) {
        var seriesConfig = seriesConfigs[seriesIndex];
        sector.innerRadius = seriesConfig.innerRadius;
        sector.radius = seriesConfig.radius;
      }
      if (seriesIndex === seriesCount - 1 && segment.explode) {
        sector.center = sector.clone().setRadius(sector.radius * 0.15).point(sector.middle());
      }
      segment.reflow(newBox);
      var label = segment.label;
      if (label) {
        if (label.options.position === OUTSIDE_END) {
          if (seriesIndex === seriesCount - 1) {
            if (label.orientation === RIGHT) {
              rightSideLabels.push(label);
            } else {
              leftSideLabels.push(label);
            }
          }
        }
      }
    }
    if (leftSideLabels.length > 0) {
      leftSideLabels.sort(this.labelComparator(true));
      this.leftLabelsReflow(leftSideLabels);
    }
    if (rightSideLabels.length > 0) {
      rightSideLabels.sort(this.labelComparator(false));
      this.rightLabelsReflow(rightSideLabels);
    }
    this.box = newBox;
  };
  PieChart2.prototype.leftLabelsReflow = function leftLabelsReflow(labels) {
    var distances = this.distanceBetweenLabels(labels);
    this.distributeLabels(distances, labels);
  };
  PieChart2.prototype.rightLabelsReflow = function rightLabelsReflow(labels) {
    var distances = this.distanceBetweenLabels(labels);
    this.distributeLabels(distances, labels);
  };
  PieChart2.prototype.distanceBetweenLabels = function distanceBetweenLabels(labels) {
    var segment = last(this.points);
    var sector = segment.sector;
    var count = labels.length - 1;
    var lr = sector.radius + segment.options.labels.distance;
    var distances = [];
    var firstBox = labels[0].box;
    var distance = round$1(firstBox.y1 - (sector.center.y - lr - firstBox.height() - firstBox.height() / 2));
    distances.push(distance);
    for (var i16 = 0; i16 < count; i16++) {
      var secondBox = labels[i16 + 1].box;
      firstBox = labels[i16].box;
      distance = round$1(secondBox.y1 - firstBox.y2);
      distances.push(distance);
    }
    distance = round$1(sector.center.y + lr - labels[count].box.y2 - labels[count].box.height() / 2);
    distances.push(distance);
    return distances;
  };
  PieChart2.prototype.distributeLabels = function distributeLabels(distances, labels) {
    var this$1$1 = this;
    var count = distances.length;
    var left, right, remaining;
    for (var i16 = 0; i16 < count; i16++) {
      remaining = -distances[i16];
      left = right = i16;
      while (remaining > 0 && (left >= 0 || right < count)) {
        remaining = this$1$1._takeDistance(distances, i16, --left, remaining);
        remaining = this$1$1._takeDistance(distances, i16, ++right, remaining);
      }
    }
    this.reflowLabels(distances, labels);
  };
  PieChart2.prototype._takeDistance = function _takeDistance(distances, anchor, position2, amount) {
    var result = amount;
    if (distances[position2] > 0) {
      var available = Math.min(distances[position2], result);
      result -= available;
      distances[position2] -= available;
      distances[anchor] += available;
    }
    return result;
  };
  PieChart2.prototype.reflowLabels = function reflowLabels(distances, labels) {
    var this$1$1 = this;
    var segment = last(this.points);
    var sector = segment.sector;
    var labelOptions = segment.options.labels;
    var labelsCount = labels.length;
    var labelDistance = labelOptions.distance;
    var boxY = sector.center.y - (sector.radius + labelDistance) - labels[0].box.height();
    var boxX;
    distances[0] += 2;
    for (var i16 = 0; i16 < labelsCount; i16++) {
      var label = labels[i16];
      var box = label.box;
      boxY += distances[i16];
      boxX = this$1$1.hAlignLabel(
        box.x2,
        sector.clone().expand(labelDistance),
        boxY,
        boxY + box.height(),
        label.orientation === RIGHT
      );
      if (label.orientation === RIGHT) {
        if (labelOptions.align !== CIRCLE) {
          boxX = sector.radius + sector.center.x + labelDistance;
        }
        label.reflow(new Box(boxX + box.width(), boxY, boxX, boxY));
      } else {
        if (labelOptions.align !== CIRCLE) {
          boxX = sector.center.x - sector.radius - labelDistance;
        }
        label.reflow(new Box(boxX - box.width(), boxY, boxX, boxY));
      }
      boxY += box.height();
    }
  };
  PieChart2.prototype.createVisual = function createVisual() {
    var this$1$1 = this;
    var ref2 = this;
    var connectors = ref2.options.connectors;
    var points2 = ref2.points;
    var count = points2.length;
    var space = 4;
    ChartElement2.prototype.createVisual.call(this);
    this._connectorLines = [];
    for (var i16 = 0; i16 < count; i16++) {
      var segment = points2[i16];
      var sector = segment.sector;
      var label = segment.label;
      var angle = sector.middle();
      var connectorsColor = (segment.options.connectors || {}).color || connectors.color;
      if (label) {
        var connectorLine = new Path$7({
          stroke: {
            color: connectorsColor,
            width: connectors.width
          },
          animation: {
            type: FADEIN,
            delay: segment.animationDelay
          }
        });
        if (label.options.position === OUTSIDE_END) {
          var box = label.box;
          var centerPoint = sector.center;
          var start = sector.point(angle);
          var middle = new Point$5(box.x1, box.center().y);
          var sr = void 0, end = void 0, crossing = void 0;
          start = sector.clone().expand(connectors.padding).point(angle);
          connectorLine.moveTo(start.x, start.y);
          if (label.orientation === RIGHT) {
            end = new Point$5(box.x1 - connectors.padding, box.center().y);
            crossing = intersection(centerPoint, start, middle, end);
            middle = new Point$5(end.x - space, end.y);
            crossing = crossing || middle;
            crossing.x = Math.min(crossing.x, middle.x);
            if (this$1$1.pointInCircle(crossing, sector.center, sector.radius + space) || crossing.x < sector.center.x) {
              sr = sector.center.x + sector.radius + space;
              if (segment.options.labels.align !== COLUMN) {
                if (sr < middle.x) {
                  connectorLine.lineTo(sr, start.y);
                } else {
                  connectorLine.lineTo(start.x + space * 2, start.y);
                }
              } else {
                connectorLine.lineTo(sr, start.y);
              }
              connectorLine.lineTo(middle.x, end.y);
            } else {
              crossing.y = end.y;
              connectorLine.lineTo(crossing.x, crossing.y);
            }
          } else {
            end = new Point$5(box.x2 + connectors.padding, box.center().y);
            crossing = intersection(centerPoint, start, middle, end);
            middle = new Point$5(end.x + space, end.y);
            crossing = crossing || middle;
            crossing.x = Math.max(crossing.x, middle.x);
            if (this$1$1.pointInCircle(crossing, sector.center, sector.radius + space) || crossing.x > sector.center.x) {
              sr = sector.center.x - sector.radius - space;
              if (segment.options.labels.align !== COLUMN) {
                if (sr > middle.x) {
                  connectorLine.lineTo(sr, start.y);
                } else {
                  connectorLine.lineTo(start.x - space * 2, start.y);
                }
              } else {
                connectorLine.lineTo(sr, start.y);
              }
              connectorLine.lineTo(middle.x, end.y);
            } else {
              crossing.y = end.y;
              connectorLine.lineTo(crossing.x, crossing.y);
            }
          }
          connectorLine.lineTo(end.x, end.y);
          this$1$1._connectorLines.push(connectorLine);
          this$1$1.visual.append(connectorLine);
        }
      }
    }
  };
  PieChart2.prototype.renderVisual = function renderVisual() {
    ChartElement2.prototype.renderVisual.call(this);
    if (find(this.options.series, function(options2) {
      return options2.autoFit;
    })) {
      var targetBox = this.targetBox;
      var pieCenter = this.box.center();
      var bbox = this.visual.bbox();
      if (!bbox) {
        return;
      }
      var bboxBottom = bbox.bottomRight();
      var scale = Math.min(
        (pieCenter.y - targetBox.y1) / (pieCenter.y - bbox.origin.y),
        (targetBox.y2 - pieCenter.y) / (bboxBottom.y - pieCenter.y),
        (pieCenter.x - targetBox.x1) / (pieCenter.x - bbox.origin.x),
        (targetBox.x2 - pieCenter.x) / (bboxBottom.x - pieCenter.x)
      );
      if (scale < 1) {
        this.visual.transform(transform().scale(scale, scale, [pieCenter.x, pieCenter.y]));
      }
    }
  };
  PieChart2.prototype.labelComparator = function labelComparator(reverse) {
    var reverseValue = reverse ? -1 : 1;
    return function(a9, b2) {
      var first = (a9.parent.sector.middle() + 270) % 360;
      var second = (b2.parent.sector.middle() + 270) % 360;
      return (first - second) * reverseValue;
    };
  };
  PieChart2.prototype.hAlignLabel = function hAlignLabel(originalX, sector, y1, y22, direction) {
    var radius = sector.radius;
    var sector_center = sector.center;
    var cx = sector_center.x;
    var cy = sector_center.y;
    var t6 = Math.min(Math.abs(cy - y1), Math.abs(cy - y22));
    if (t6 > radius) {
      return originalX;
    }
    return cx + Math.sqrt(radius * radius - t6 * t6) * (direction ? 1 : -1);
  };
  PieChart2.prototype.pointInCircle = function pointInCircle(point2, center, radius) {
    return Math.pow(center.x - point2.x, 2) + Math.pow(center.y - point2.y, 2) < Math.pow(radius, 2);
  };
  PieChart2.prototype.formatPointValue = function formatPointValue(point2, format2) {
    return this.chartService.format.auto(format2, point2.value);
  };
  PieChart2.prototype.animationDelay = function animationDelay(categoryIndex) {
    return categoryIndex * PIE_SECTOR_ANIM_DELAY;
  };
  PieChart2.prototype.stackRoot = function stackRoot() {
    return this;
  };
  return PieChart2;
}(ChartElement);
function intersection(a1, a22, b1, b2) {
  var uat = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x);
  var ub2 = (b2.y - b1.y) * (a22.x - a1.x) - (b2.x - b1.x) * (a22.y - a1.y);
  var result;
  if (ub2 !== 0) {
    var ua2 = uat / ub2;
    result = new Point$5(
      a1.x + ua2 * (a22.x - a1.x),
      a1.y + ua2 * (a22.y - a1.y)
    );
  }
  return result;
}
setDefaultOptions(PieChart, {
  startAngle: 90,
  connectors: {
    width: 2,
    color: "#939393",
    padding: 8
  },
  inactiveItems: {
    markers: {},
    labels: {}
  }
});
deepExtend(PieChart.prototype, PieChartMixin);
PieChart.prototype.isStackRoot = true;
var PiePlotArea = function(PlotAreaBase2) {
  function PiePlotArea2() {
    PlotAreaBase2.apply(this, arguments);
  }
  if (PlotAreaBase2)
    PiePlotArea2.__proto__ = PlotAreaBase2;
  PiePlotArea2.prototype = Object.create(PlotAreaBase2 && PlotAreaBase2.prototype);
  PiePlotArea2.prototype.constructor = PiePlotArea2;
  PiePlotArea2.prototype.render = function render() {
    this.createPieChart(this.series);
  };
  PiePlotArea2.prototype.createPieChart = function createPieChart(series) {
    var firstSeries = series[0];
    var pieChart = new PieChart(this, {
      series,
      padding: firstSeries.padding,
      startAngle: firstSeries.startAngle,
      connectors: firstSeries.connectors,
      legend: this.options.legend
    });
    this.appendChart(pieChart);
  };
  PiePlotArea2.prototype.appendChart = function appendChart(chart, pane) {
    PlotAreaBase2.prototype.appendChart.call(this, chart, pane);
    append(this.options.legend.data, chart.legendItems);
  };
  PiePlotArea2.prototype.getPointBelow = function getPointBelow(point2) {
    return this.getPointToTheRight(point2);
  };
  PiePlotArea2.prototype.getPointAbove = function getPointAbove(point2) {
    return this.getPointToTheLeft(point2);
  };
  return PiePlotArea2;
}(PlotAreaBase);
var DonutSegment = function(PieSegment2) {
  function DonutSegment2() {
    PieSegment2.apply(this, arguments);
  }
  if (PieSegment2)
    DonutSegment2.__proto__ = PieSegment2;
  DonutSegment2.prototype = Object.create(PieSegment2 && PieSegment2.prototype);
  DonutSegment2.prototype.constructor = DonutSegment2;
  DonutSegment2.prototype.reflowLabel = function reflowLabel() {
    var ref2 = this;
    var labelsOptions = ref2.options.labels;
    var label = ref2.label;
    var sector = this.sector.clone();
    var angle = sector.middle();
    if (label) {
      var labelHeight = label.box.height();
      if (labelsOptions.position === CENTER) {
        sector.radius -= (sector.radius - sector.innerRadius) / 2;
        var lp = sector.point(angle);
        label.reflow(new Box(lp.x, lp.y - labelHeight / 2, lp.x, lp.y));
      } else {
        PieSegment2.prototype.reflowLabel.call(this);
      }
    }
  };
  DonutSegment2.prototype.createSegment = function createSegment(sector, options2) {
    return ShapeBuilder.current.createRing(sector, options2);
  };
  return DonutSegment2;
}(PieSegment);
setDefaultOptions(DonutSegment, {
  overlay: {
    gradient: "roundedGlass"
  },
  labels: {
    position: CENTER
  },
  animation: {
    type: PIE
  }
});
deepExtend(DonutSegment.prototype, PointEventsMixin);
var DONUT_SECTOR_ANIM_DELAY = 50;
var DonutChart = function(PieChart2) {
  function DonutChart2() {
    PieChart2.apply(this, arguments);
  }
  if (PieChart2)
    DonutChart2.__proto__ = PieChart2;
  DonutChart2.prototype = Object.create(PieChart2 && PieChart2.prototype);
  DonutChart2.prototype.constructor = DonutChart2;
  DonutChart2.prototype.addValue = function addValue(value2, sector, fields) {
    var segmentOptions = deepExtend({}, fields.series, { index: fields.index });
    this.evalSegmentOptions(segmentOptions, value2, fields);
    this.createLegendItem(value2, segmentOptions, fields);
    if (fields.visible === false) {
      return;
    }
    var segment = new DonutSegment(value2, sector, segmentOptions);
    Object.assign(segment, fields);
    this.append(segment);
    this.points.push(segment);
  };
  DonutChart2.prototype.reflow = function reflow(targetBox) {
    var this$1$1 = this;
    var options2 = this.options;
    var box = targetBox.clone();
    var space = 5;
    var minWidth = Math.min(box.width(), box.height());
    var halfMinWidth = minWidth / 2;
    var defaultPadding = minWidth - minWidth * 0.85;
    var series = options2.series;
    var seriesCount = series.length;
    var padding = valueOrDefault$1(options2.padding, defaultPadding);
    padding = padding > halfMinWidth - space ? halfMinWidth - space : padding;
    var totalSize = halfMinWidth - padding;
    var seriesWithoutSize = 0;
    var holeSize;
    for (var i16 = 0; i16 < seriesCount; i16++) {
      var currentSeries = series[i16];
      if (i16 === 0) {
        if (defined(currentSeries.holeSize)) {
          holeSize = currentSeries.holeSize;
          totalSize -= currentSeries.holeSize;
        }
      }
      if (defined(currentSeries.size)) {
        totalSize -= currentSeries.size;
      } else {
        seriesWithoutSize++;
      }
      if (defined(currentSeries.margin) && i16 !== seriesCount - 1) {
        totalSize -= currentSeries.margin;
      }
    }
    if (!defined(holeSize)) {
      var currentSize = (halfMinWidth - padding) / (seriesCount + 0.75);
      holeSize = currentSize * 0.75;
      totalSize -= holeSize;
    }
    var innerRadius = holeSize;
    var margin = 0;
    var size, radius;
    this.seriesConfigs = [];
    for (var i$12 = 0; i$12 < seriesCount; i$12++) {
      var currentSeries$1 = series[i$12];
      size = valueOrDefault$1(currentSeries$1.size, totalSize / seriesWithoutSize);
      innerRadius += margin;
      radius = innerRadius + size;
      this$1$1.seriesConfigs.push({ innerRadius, radius });
      margin = currentSeries$1.margin || 0;
      innerRadius = radius;
    }
    PieChart2.prototype.reflow.call(this, targetBox);
  };
  DonutChart2.prototype.animationDelay = function animationDelay(categoryIndex, seriesIndex, seriesCount) {
    return categoryIndex * DONUT_SECTOR_ANIM_DELAY + INITIAL_ANIMATION_DURATION * (seriesIndex + 1) / (seriesCount + 1);
  };
  return DonutChart2;
}(PieChart);
setDefaultOptions(DonutChart, {
  startAngle: 90,
  connectors: {
    width: 2,
    color: "#939393",
    padding: 8
  }
});
var DonutPlotArea = function(PiePlotArea2) {
  function DonutPlotArea2() {
    PiePlotArea2.apply(this, arguments);
  }
  if (PiePlotArea2)
    DonutPlotArea2.__proto__ = PiePlotArea2;
  DonutPlotArea2.prototype = Object.create(PiePlotArea2 && PiePlotArea2.prototype);
  DonutPlotArea2.prototype.constructor = DonutPlotArea2;
  DonutPlotArea2.prototype.render = function render() {
    this.createDonutChart(this.series);
  };
  DonutPlotArea2.prototype.createDonutChart = function createDonutChart(series) {
    var firstSeries = series[0];
    var donutChart = new DonutChart(this, {
      series,
      padding: firstSeries.padding,
      connectors: firstSeries.connectors,
      legend: this.options.legend
    });
    this.appendChart(donutChart);
  };
  DonutPlotArea2.prototype.getPointBelow = function getPointBelow(point2) {
    return this._getNextPoint(point2, this._pointsByVertical, -1);
  };
  DonutPlotArea2.prototype.getPointAbove = function getPointAbove(point2) {
    return this._getNextPoint(point2, this._pointsByVertical, 1);
  };
  return DonutPlotArea2;
}(PiePlotArea);
var DEFAULT_PADDING = 0.15;
var PolarPlotAreaBase = function(PlotAreaBase2) {
  function PolarPlotAreaBase2() {
    PlotAreaBase2.apply(this, arguments);
  }
  if (PlotAreaBase2)
    PolarPlotAreaBase2.__proto__ = PlotAreaBase2;
  PolarPlotAreaBase2.prototype = Object.create(PlotAreaBase2 && PlotAreaBase2.prototype);
  PolarPlotAreaBase2.prototype.constructor = PolarPlotAreaBase2;
  PolarPlotAreaBase2.prototype.initFields = function initFields() {
    this.valueAxisRangeTracker = new AxisGroupRangeTracker();
  };
  PolarPlotAreaBase2.prototype.render = function render() {
    this.addToLegend(this.series);
    this.createPolarAxis();
    this.createCharts();
    this.createValueAxis();
  };
  PolarPlotAreaBase2.prototype.alignAxes = function alignAxes() {
    var axis = this.valueAxis;
    var range = axis.range();
    var crossingValue = axis.options.reverse ? range.max : range.min;
    var slot = axis.getSlot(crossingValue);
    var center = this.polarAxis.getSlot(0).center;
    var axisBox = axis.box.translate(
      center.x - slot.x1,
      center.y - slot.y1
    );
    axis.reflow(axisBox);
  };
  PolarPlotAreaBase2.prototype.createValueAxis = function createValueAxis() {
    var tracker = this.valueAxisRangeTracker;
    var defaultRange = tracker.query();
    var axisOptions2 = this.valueAxisOptions({
      roundToMajorUnit: false,
      zIndex: -1
    });
    var axisType, axisDefaultRange;
    if (axisOptions2.type === LOGARITHMIC) {
      axisType = RadarLogarithmicAxis;
      axisDefaultRange = { min: 0.1, max: 1 };
    } else {
      axisType = RadarNumericAxis;
      axisDefaultRange = { min: 0, max: 1 };
    }
    var range = tracker.query(name) || defaultRange || axisDefaultRange;
    if (range && defaultRange) {
      range.min = Math.min(range.min, defaultRange.min);
      range.max = Math.max(range.max, defaultRange.max);
    }
    var valueAxis = new axisType(
      range.min,
      range.max,
      axisOptions2,
      this.chartService
    );
    this.valueAxis = valueAxis;
    this.appendAxis(valueAxis);
  };
  PolarPlotAreaBase2.prototype.reflowAxes = function reflowAxes() {
    var ref2 = this;
    var options2 = ref2.options.plotArea;
    var valueAxis = ref2.valueAxis;
    var polarAxis = ref2.polarAxis;
    var box = ref2.box;
    var defaultPadding = Math.min(box.width(), box.height()) * DEFAULT_PADDING;
    var padding = getSpacing(options2.padding || {}, defaultPadding);
    var paddingBox = box.clone().unpad(padding);
    var axisBox = paddingBox.clone();
    axisBox.y2 = axisBox.y1 + Math.min(axisBox.width(), axisBox.height());
    axisBox.align(paddingBox, Y$7, CENTER);
    var valueAxisBox = axisBox.clone().shrink(0, axisBox.height() / 2);
    polarAxis.reflow(axisBox);
    valueAxis.reflow(valueAxisBox);
    var heightDiff = valueAxis.lineBox().height() - valueAxis.box.height();
    valueAxis.reflow(valueAxis.box.unpad({ top: heightDiff }));
    this.axisBox = axisBox;
    this.alignAxes(axisBox);
  };
  PolarPlotAreaBase2.prototype.backgroundBox = function backgroundBox() {
    return this.box;
  };
  PolarPlotAreaBase2.prototype.detachLabels = function detachLabels() {
  };
  return PolarPlotAreaBase2;
}(PlotAreaBase);
var PolarScatterChart = function(ScatterChart2) {
  function PolarScatterChart2() {
    ScatterChart2.apply(this, arguments);
  }
  if (ScatterChart2)
    PolarScatterChart2.__proto__ = ScatterChart2;
  PolarScatterChart2.prototype = Object.create(ScatterChart2 && ScatterChart2.prototype);
  PolarScatterChart2.prototype.constructor = PolarScatterChart2;
  PolarScatterChart2.prototype.pointSlot = function pointSlot(slotX, slotY) {
    var valueRadius = slotX.center.y - slotY.y1;
    var slot = Point$5.onCircle(slotX.center, slotX.startAngle, valueRadius);
    return new Box(slot.x, slot.y, slot.x, slot.y);
  };
  return PolarScatterChart2;
}(ScatterChart);
setDefaultOptions(PolarScatterChart, {
  clip: false
});
var PolarLineChart = function(ScatterLineChart2) {
  function PolarLineChart2() {
    ScatterLineChart2.apply(this, arguments);
  }
  if (ScatterLineChart2)
    PolarLineChart2.__proto__ = ScatterLineChart2;
  PolarLineChart2.prototype = Object.create(ScatterLineChart2 && ScatterLineChart2.prototype);
  PolarLineChart2.prototype.constructor = PolarLineChart2;
  return PolarLineChart2;
}(ScatterLineChart);
PolarLineChart.prototype.pointSlot = PolarScatterChart.prototype.pointSlot;
setDefaultOptions(PolarLineChart, {
  clip: false
});
var SplinePolarAreaSegment = function(SplineAreaSegment2) {
  function SplinePolarAreaSegment2() {
    SplineAreaSegment2.apply(this, arguments);
  }
  if (SplineAreaSegment2)
    SplinePolarAreaSegment2.__proto__ = SplineAreaSegment2;
  SplinePolarAreaSegment2.prototype = Object.create(SplineAreaSegment2 && SplineAreaSegment2.prototype);
  SplinePolarAreaSegment2.prototype.constructor = SplinePolarAreaSegment2;
  SplinePolarAreaSegment2.prototype.fillToAxes = function fillToAxes(fillPath) {
    var center = this._polarAxisCenter();
    fillPath.lineTo(center.x, center.y);
  };
  SplinePolarAreaSegment2.prototype._polarAxisCenter = function _polarAxisCenter() {
    var polarAxis = this.parent.plotArea.polarAxis;
    var center = polarAxis.box.center();
    return center;
  };
  SplinePolarAreaSegment2.prototype.strokeSegments = function strokeSegments() {
    var segments = this._strokeSegments;
    if (!segments) {
      var center = this._polarAxisCenter();
      var curveProcessor = new CurveProcessor(false);
      var linePoints = this.points();
      linePoints.push(center);
      segments = this._strokeSegments = curveProcessor.process(linePoints);
      segments.pop();
    }
    return segments;
  };
  return SplinePolarAreaSegment2;
}(SplineAreaSegment);
var PolarAreaSegment = function(AreaSegment2) {
  function PolarAreaSegment2() {
    AreaSegment2.apply(this, arguments);
  }
  if (AreaSegment2)
    PolarAreaSegment2.__proto__ = AreaSegment2;
  PolarAreaSegment2.prototype = Object.create(AreaSegment2 && AreaSegment2.prototype);
  PolarAreaSegment2.prototype.constructor = PolarAreaSegment2;
  PolarAreaSegment2.prototype.fillToAxes = function fillToAxes(fillPath) {
    var polarAxis = this.parent.plotArea.polarAxis;
    var center = polarAxis.box.center();
    var centerSegment = new Segment$1([center.x, center.y]);
    fillPath.segments.unshift(centerSegment);
    fillPath.segments.push(centerSegment);
  };
  return PolarAreaSegment2;
}(AreaSegment);
var PolarAreaChart = function(PolarLineChart2) {
  function PolarAreaChart2() {
    PolarLineChart2.apply(this, arguments);
  }
  if (PolarLineChart2)
    PolarAreaChart2.__proto__ = PolarLineChart2;
  PolarAreaChart2.prototype = Object.create(PolarLineChart2 && PolarLineChart2.prototype);
  PolarAreaChart2.prototype.constructor = PolarAreaChart2;
  PolarAreaChart2.prototype.createSegment = function createSegment(linePoints, currentSeries, seriesIx) {
    var style2 = (currentSeries.line || {}).style;
    var segment;
    if (style2 === SMOOTH) {
      segment = new SplinePolarAreaSegment(linePoints, currentSeries, seriesIx);
    } else {
      segment = new PolarAreaSegment(linePoints, currentSeries, seriesIx);
    }
    return segment;
  };
  PolarAreaChart2.prototype.createMissingValue = function createMissingValue(value2, missingValues) {
    var missingValue;
    if (hasValue$1(value2.x) && missingValues !== INTERPOLATE) {
      missingValue = {
        x: value2.x,
        y: value2.y
      };
      if (missingValues === ZERO) {
        missingValue.y = 0;
      }
    }
    return missingValue;
  };
  PolarAreaChart2.prototype.seriesMissingValues = function seriesMissingValues2(series) {
    return series.missingValues || ZERO;
  };
  PolarAreaChart2.prototype._hasMissingValuesGap = function _hasMissingValuesGap() {
    var this$1$1 = this;
    var series = this.options.series;
    for (var idx = 0; idx < series.length; idx++) {
      if (this$1$1.seriesMissingValues(series[idx]) === GAP) {
        return true;
      }
    }
  };
  PolarAreaChart2.prototype.sortPoints = function sortPoints(points2) {
    var this$1$1 = this;
    points2.sort(xComparer);
    if (this._hasMissingValuesGap()) {
      for (var idx = 0; idx < points2.length; idx++) {
        var point2 = points2[idx];
        if (point2) {
          var value2 = point2.value;
          if (!hasValue$1(value2.y) && this$1$1.seriesMissingValues(point2.series) === GAP) {
            delete points2[idx];
          }
        }
      }
    }
    return points2;
  };
  return PolarAreaChart2;
}(PolarLineChart);
function xComparer(a9, b2) {
  return a9.value.x - b2.value.x;
}
var PolarPlotArea = function(PolarPlotAreaBase2) {
  function PolarPlotArea2() {
    PolarPlotAreaBase2.apply(this, arguments);
  }
  if (PolarPlotAreaBase2)
    PolarPlotArea2.__proto__ = PolarPlotAreaBase2;
  PolarPlotArea2.prototype = Object.create(PolarPlotAreaBase2 && PolarPlotAreaBase2.prototype);
  PolarPlotArea2.prototype.constructor = PolarPlotArea2;
  PolarPlotArea2.prototype.createPolarAxis = function createPolarAxis() {
    var polarAxis = new PolarAxis(this.options.xAxis, this.chartService);
    this.polarAxis = polarAxis;
    this.axisX = polarAxis;
    this.appendAxis(polarAxis);
  };
  PolarPlotArea2.prototype.render = function render() {
    this.series = [].concat(this.originalSeries);
    this.createTrendlineSeries();
    PolarPlotAreaBase2.prototype.render.call(this);
  };
  PolarPlotArea2.prototype.valueAxisOptions = function valueAxisOptions(defaults) {
    return deepExtend(defaults, {
      majorGridLines: { type: ARC },
      minorGridLines: { type: ARC }
    }, this.options.yAxis);
  };
  PolarPlotArea2.prototype.createValueAxis = function createValueAxis() {
    PolarPlotAreaBase2.prototype.createValueAxis.call(this);
    this.axisY = this.valueAxis;
  };
  PolarPlotArea2.prototype.trendlineFactory = function trendlineFactory2(options2, series) {
    var trendline = XYPlotArea.prototype.trendlineFactory.call(this, options2, series);
    if (trendline) {
      trendline.type = POLAR_LINE;
    }
    return trendline;
  };
  PolarPlotArea2.prototype.appendChart = function appendChart(chart, pane) {
    this.valueAxisRangeTracker.update(chart.yAxisRanges);
    PlotAreaBase.prototype.appendChart.call(this, chart, pane);
  };
  PolarPlotArea2.prototype.createCharts = function createCharts() {
    var series = this.filterVisibleSeries(this.series);
    var pane = this.panes[0];
    this.createLineChart(
      filterSeriesByType(series, [POLAR_LINE]),
      pane
    );
    this.createScatterChart(
      filterSeriesByType(series, [POLAR_SCATTER]),
      pane
    );
    this.createAreaChart(
      filterSeriesByType(series, [POLAR_AREA]),
      pane
    );
  };
  PolarPlotArea2.prototype.createLineChart = function createLineChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var lineChart = new PolarLineChart(this, { series });
    this.appendChart(lineChart, pane);
  };
  PolarPlotArea2.prototype.createScatterChart = function createScatterChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var scatterChart = new PolarScatterChart(this, { series });
    this.appendChart(scatterChart, pane);
  };
  PolarPlotArea2.prototype.createAreaChart = function createAreaChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var areaChart = new PolarAreaChart(this, { series });
    this.appendChart(areaChart, pane);
  };
  PolarPlotArea2.prototype._dispatchEvent = function _dispatchEvent(chart, e3, eventType) {
    var coords = chart._eventCoordinates(e3);
    var point2 = new Point$5(coords.x, coords.y);
    var xValue = this.axisX.getValue(point2);
    var yValue = this.axisY.getValue(point2);
    if (xValue !== null && yValue !== null) {
      chart.trigger(eventType, {
        element: eventElement(e3),
        x: xValue,
        y: yValue
      });
    }
  };
  PolarPlotArea2.prototype.createCrosshairs = function createCrosshairs() {
  };
  return PolarPlotArea2;
}(PolarPlotAreaBase);
setDefaultOptions(PolarPlotArea, {
  xAxis: {},
  yAxis: {}
});
deepExtend(PolarPlotArea.prototype, PlotAreaEventsMixin, {
  seriesValues: XYPlotArea.prototype.seriesValues
});
function groupBySeriesIx(segments) {
  var seriesSegments = [];
  for (var idx = 0; idx < segments.length; idx++) {
    var segment = segments[idx];
    seriesSegments[segment.seriesIx] = seriesSegments[segment.seriesIx] || [];
    seriesSegments[segment.seriesIx].push(segment);
  }
  return seriesSegments;
}
var RadarLineChart = function(LineChart2) {
  function RadarLineChart2() {
    LineChart2.apply(this, arguments);
  }
  if (LineChart2)
    RadarLineChart2.__proto__ = LineChart2;
  RadarLineChart2.prototype = Object.create(LineChart2 && LineChart2.prototype);
  RadarLineChart2.prototype.constructor = RadarLineChart2;
  RadarLineChart2.prototype.pointSlot = function pointSlot(categorySlot, valueSlot) {
    var valueRadius = categorySlot.center.y - valueSlot.y1;
    var slot = Point$5.onCircle(categorySlot.center, categorySlot.middle(), valueRadius);
    return new Box(slot.x, slot.y, slot.x, slot.y);
  };
  RadarLineChart2.prototype.renderSegments = function renderSegments() {
    LineChart2.prototype.renderSegments.call(this);
    if (this._segments && this._segments.length > 1) {
      var seriesSegments = groupBySeriesIx(this._segments);
      for (var idx = 0; idx < seriesSegments.length; idx++) {
        var segments = seriesSegments[idx];
        if (segments && segments.length > 1) {
          var firstPoint = segments[0].linePoints[0];
          var lastSegment = last(segments);
          var lastPoint = last(lastSegment.linePoints);
          var isFirstDataPoint = firstPoint.categoryIx === 0;
          var isLastDataPoint = lastPoint.categoryIx === lastPoint.categoriesCount - 1;
          if (isFirstDataPoint && isLastDataPoint) {
            last(segments).linePoints.push(firstPoint);
          }
        }
      }
    }
  };
  RadarLineChart2.prototype.createSegment = function createSegment(linePoints, currentSeries, seriesIx) {
    var style2 = currentSeries.style;
    var pointType;
    if (style2 === SMOOTH) {
      pointType = SplineSegment;
    } else {
      pointType = LineSegment;
    }
    var segment = new pointType(linePoints, currentSeries, seriesIx);
    var missingValues = this.seriesMissingValues(currentSeries);
    if (linePoints.length === currentSeries.data.length || missingValues === INTERPOLATE) {
      segment.options.closed = true;
    }
    return segment;
  };
  return RadarLineChart2;
}(LineChart);
setDefaultOptions(RadarLineChart, {
  clip: false,
  limitPoints: false
});
var SplineRadarAreaSegment = function(SplineAreaSegment2) {
  function SplineRadarAreaSegment2() {
    SplineAreaSegment2.apply(this, arguments);
  }
  if (SplineAreaSegment2)
    SplineRadarAreaSegment2.__proto__ = SplineAreaSegment2;
  SplineRadarAreaSegment2.prototype = Object.create(SplineAreaSegment2 && SplineAreaSegment2.prototype);
  SplineRadarAreaSegment2.prototype.constructor = SplineRadarAreaSegment2;
  SplineRadarAreaSegment2.prototype.fillToAxes = function fillToAxes() {
  };
  return SplineRadarAreaSegment2;
}(SplineAreaSegment);
var RadarAreaSegment = function(AreaSegment2) {
  function RadarAreaSegment2() {
    AreaSegment2.apply(this, arguments);
  }
  if (AreaSegment2)
    RadarAreaSegment2.__proto__ = AreaSegment2;
  RadarAreaSegment2.prototype = Object.create(AreaSegment2 && AreaSegment2.prototype);
  RadarAreaSegment2.prototype.constructor = RadarAreaSegment2;
  RadarAreaSegment2.prototype.fillToAxes = function fillToAxes() {
  };
  return RadarAreaSegment2;
}(AreaSegment);
var RadarAreaChart = function(RadarLineChart2) {
  function RadarAreaChart2() {
    RadarLineChart2.apply(this, arguments);
  }
  if (RadarLineChart2)
    RadarAreaChart2.__proto__ = RadarLineChart2;
  RadarAreaChart2.prototype = Object.create(RadarLineChart2 && RadarLineChart2.prototype);
  RadarAreaChart2.prototype.constructor = RadarAreaChart2;
  RadarAreaChart2.prototype.createSegment = function createSegment(linePoints, currentSeries, seriesIx, prevSegment) {
    var isStacked = this.options.isStacked;
    var style2 = (currentSeries.line || {}).style;
    var previousSegment;
    var stackPoints;
    var segment;
    if (isStacked && seriesIx > 0 && prevSegment) {
      stackPoints = prevSegment.linePoints.slice(0);
      previousSegment = prevSegment;
    }
    if (style2 === SMOOTH) {
      segment = new SplineRadarAreaSegment(linePoints, currentSeries, seriesIx, previousSegment, stackPoints);
      segment.options.closed = true;
    } else {
      linePoints.push(linePoints[0]);
      segment = new RadarAreaSegment(linePoints, currentSeries, seriesIx, previousSegment, stackPoints);
    }
    return segment;
  };
  RadarAreaChart2.prototype.seriesMissingValues = function seriesMissingValues2(series) {
    return series.missingValues || ZERO;
  };
  return RadarAreaChart2;
}(RadarLineChart);
var RadarSegment = function(DonutSegment2) {
  function RadarSegment2(value2, options2) {
    DonutSegment2.call(this, value2, null, options2);
  }
  if (DonutSegment2)
    RadarSegment2.__proto__ = DonutSegment2;
  RadarSegment2.prototype = Object.create(DonutSegment2 && DonutSegment2.prototype);
  RadarSegment2.prototype.constructor = RadarSegment2;
  RadarSegment2.prototype.getIndex = function getIndex() {
    return this.categoryIx;
  };
  return RadarSegment2;
}(DonutSegment);
setDefaultOptions(RadarSegment, {
  overlay: {
    gradient: "none"
  },
  labels: {
    distance: 10
  }
});
var RadarClusterLayout = function(ChartElement2) {
  function RadarClusterLayout2(options2) {
    ChartElement2.call(this, options2);
    this.forEach = options2.rtl ? forEachReverse : forEach;
  }
  if (ChartElement2)
    RadarClusterLayout2.__proto__ = ChartElement2;
  RadarClusterLayout2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  RadarClusterLayout2.prototype.constructor = RadarClusterLayout2;
  RadarClusterLayout2.prototype.reflow = function reflow(sector) {
    var ref2 = this;
    var options2 = ref2.options;
    var children = ref2.children;
    var gap = options2.gap;
    var spacing = options2.spacing;
    var count = children.length;
    var slots = count + gap + spacing * (count - 1);
    var slotAngle = sector.angle / slots;
    var angle = sector.startAngle + slotAngle * (gap / 2);
    this.forEach(children, function(child) {
      var slotSector = sector.clone();
      slotSector.startAngle = angle;
      slotSector.angle = slotAngle;
      if (child.sector) {
        slotSector.radius = child.sector.radius;
      }
      child.reflow(slotSector);
      child.sector = slotSector;
      angle += slotAngle + slotAngle * spacing;
    });
  };
  return RadarClusterLayout2;
}(ChartElement);
setDefaultOptions(RadarClusterLayout, {
  gap: 1,
  spacing: 0
});
var RadarStackLayout = function(ChartElement2) {
  function RadarStackLayout2() {
    ChartElement2.apply(this, arguments);
  }
  if (ChartElement2)
    RadarStackLayout2.__proto__ = ChartElement2;
  RadarStackLayout2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  RadarStackLayout2.prototype.constructor = RadarStackLayout2;
  RadarStackLayout2.prototype.reflow = function reflow(sector) {
    var ref2 = this;
    var reverse = ref2.options.reverse;
    var children = ref2.children;
    var childrenCount = children.length;
    var first = reverse ? childrenCount - 1 : 0;
    var step = reverse ? -1 : 1;
    this.box = new Box();
    for (var i16 = first; i16 >= 0 && i16 < childrenCount; i16 += step) {
      var childSector = children[i16].sector;
      childSector.startAngle = sector.startAngle;
      childSector.angle = sector.angle;
    }
  };
  return RadarStackLayout2;
}(ChartElement);
var RadarBarChart = function(BarChart2) {
  function RadarBarChart2() {
    BarChart2.apply(this, arguments);
  }
  if (BarChart2)
    RadarBarChart2.__proto__ = BarChart2;
  RadarBarChart2.prototype = Object.create(BarChart2 && BarChart2.prototype);
  RadarBarChart2.prototype.constructor = RadarBarChart2;
  RadarBarChart2.prototype.pointType = function pointType() {
    return RadarSegment;
  };
  RadarBarChart2.prototype.clusterType = function clusterType() {
    return RadarClusterLayout;
  };
  RadarBarChart2.prototype.stackType = function stackType() {
    return RadarStackLayout;
  };
  RadarBarChart2.prototype.categorySlot = function categorySlot(categoryAxis, categoryIx) {
    return categoryAxis.getSlot(categoryIx);
  };
  RadarBarChart2.prototype.pointSlot = function pointSlot(categorySlot, valueSlot) {
    var slot = categorySlot.clone();
    var y4 = categorySlot.center.y;
    slot.radius = y4 - valueSlot.y1;
    slot.innerRadius = y4 - valueSlot.y2;
    return slot;
  };
  RadarBarChart2.prototype.reflowPoint = function reflowPoint(point2, pointSlot) {
    point2.sector = pointSlot;
    point2.reflow();
  };
  RadarBarChart2.prototype.createAnimation = function createAnimation() {
    this.options.animation.center = this.box.toRect().center();
    BarChart2.prototype.createAnimation.call(this);
  };
  return RadarBarChart2;
}(BarChart);
RadarBarChart.prototype.reflow = CategoricalChart.prototype.reflow;
setDefaultOptions(RadarBarChart, {
  clip: false,
  limitPoints: false,
  animation: {
    type: "pie"
  }
});
var RadarPlotArea = function(PolarPlotAreaBase2) {
  function RadarPlotArea2() {
    PolarPlotAreaBase2.apply(this, arguments);
  }
  if (PolarPlotAreaBase2)
    RadarPlotArea2.__proto__ = PolarPlotAreaBase2;
  RadarPlotArea2.prototype = Object.create(PolarPlotAreaBase2 && PolarPlotAreaBase2.prototype);
  RadarPlotArea2.prototype.constructor = RadarPlotArea2;
  RadarPlotArea2.prototype.createPolarAxis = function createPolarAxis() {
    var categoryAxis = new RadarCategoryAxis(this.options.categoryAxis, this.chartService);
    this.polarAxis = categoryAxis;
    this.categoryAxis = categoryAxis;
    this.appendAxis(categoryAxis);
    this.aggregateCategories();
    this.createTrendlineSeries();
    this.createCategoryAxesLabels();
  };
  RadarPlotArea2.prototype.valueAxisOptions = function valueAxisOptions(defaults) {
    if (this._hasBarCharts) {
      deepExtend(defaults, {
        majorGridLines: { type: ARC },
        minorGridLines: { type: ARC }
      });
    }
    if (this._isStacked100) {
      deepExtend(defaults, {
        roundToMajorUnit: false,
        labels: { format: "P0" }
      });
    }
    return deepExtend(defaults, this.options.valueAxis);
  };
  RadarPlotArea2.prototype.aggregateCategories = function aggregateCategories() {
    CategoricalPlotArea.prototype.aggregateCategories.call(this, this.panes);
  };
  RadarPlotArea2.prototype.createCategoryAxesLabels = function createCategoryAxesLabels() {
    CategoricalPlotArea.prototype.createCategoryAxesLabels.call(this, this.panes);
  };
  RadarPlotArea2.prototype.filterSeries = function filterSeries(currentSeries) {
    return currentSeries;
  };
  RadarPlotArea2.prototype.trendlineFactory = function trendlineFactory2(options2, series) {
    var trendline = CategoricalPlotArea.prototype.trendlineFactory.call(this, options2, series);
    if (trendline) {
      trendline.type = RADAR_LINE;
    }
    return trendline;
  };
  RadarPlotArea2.prototype.createCharts = function createCharts() {
    var series = this.filterVisibleSeries(this.series);
    var pane = this.panes[0];
    this.createAreaChart(
      filterSeriesByType(series, [RADAR_AREA]),
      pane
    );
    this.createLineChart(
      filterSeriesByType(series, [RADAR_LINE]),
      pane
    );
    this.createBarChart(
      filterSeriesByType(series, [RADAR_COLUMN]),
      pane
    );
  };
  RadarPlotArea2.prototype.chartOptions = function chartOptions(series) {
    var options2 = { series };
    var firstSeries = series[0];
    if (firstSeries) {
      var filteredSeries = this.filterVisibleSeries(series);
      var stack = firstSeries.stack;
      options2.isStacked = stack && filteredSeries.length > 1;
      options2.isStacked100 = stack && stack.type === "100%" && filteredSeries.length > 1;
      if (options2.isStacked100) {
        this._isStacked100 = true;
      }
    }
    return options2;
  };
  RadarPlotArea2.prototype.createAreaChart = function createAreaChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var areaChart = new RadarAreaChart(this, this.chartOptions(series));
    this.appendChart(areaChart, pane);
  };
  RadarPlotArea2.prototype.createLineChart = function createLineChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var lineChart = new RadarLineChart(this, this.chartOptions(series));
    this.appendChart(lineChart, pane);
  };
  RadarPlotArea2.prototype.createBarChart = function createBarChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var firstSeries = series[0];
    var options2 = this.chartOptions(series);
    var filteredSeries = this.filterVisibleSeries(series);
    var anyStackedSeries = filteredSeries.some(function(s10) {
      return s10.stack;
    });
    var isStacked100 = filteredSeries.some(function(s10) {
      return s10.stack && s10.stack.type === "100%";
    });
    options2.gap = firstSeries.gap;
    options2.spacing = firstSeries.spacing;
    options2.defaultStack = firstSeries.stack && filteredSeries.length > 1;
    options2.isStacked = anyStackedSeries && filteredSeries.length > 1;
    options2.isStacked100 = isStacked100 && filteredSeries.length > 1;
    var barChart = new RadarBarChart(this, options2);
    this.appendChart(barChart, pane);
    this._hasBarCharts = true;
  };
  RadarPlotArea2.prototype.seriesCategoryAxis = function seriesCategoryAxis() {
    return this.categoryAxis;
  };
  RadarPlotArea2.prototype._dispatchEvent = function _dispatchEvent(chart, e3, eventType) {
    var coords = chart._eventCoordinates(e3);
    var point2 = new Point$5(coords.x, coords.y);
    var category = this.categoryAxis.getCategory(point2);
    var value2 = this.valueAxis.getValue(point2);
    if (category !== null && value2 !== null) {
      chart.trigger(eventType, {
        element: eventElement(e3),
        category,
        value: value2
      });
    }
  };
  RadarPlotArea2.prototype.createCrosshairs = function createCrosshairs() {
  };
  RadarPlotArea2.prototype._pointsByVertical = function _pointsByVertical(basePoint) {
    return PolarPlotAreaBase2.prototype._pointsByVertical.call(this, basePoint).sort(this._getSeriesCompareFn());
  };
  RadarPlotArea2.prototype._getSeriesCompareFn = function _getSeriesCompareFn() {
    return function(a9, b2) {
      return b2.value - a9.value;
    };
  };
  return RadarPlotArea2;
}(PolarPlotAreaBase);
deepExtend(RadarPlotArea.prototype, PlotAreaEventsMixin, {
  appendChart: CategoricalPlotArea.prototype.appendChart,
  aggregateSeries: CategoricalPlotArea.prototype.aggregateSeries,
  seriesSourcePoints: CategoricalPlotArea.prototype.seriesSourcePoints,
  seriesValues: CategoricalPlotArea.prototype.seriesValues
});
setDefaultOptions(RadarPlotArea, {
  categoryAxis: {
    categories: []
  },
  valueAxis: {}
});
var FunnelSegment = function(ChartElement2) {
  function FunnelSegment2(value2, options2, segmentOptions) {
    ChartElement2.call(this, options2);
    this.value = value2;
    this.options.index = segmentOptions.index;
  }
  if (ChartElement2)
    FunnelSegment2.__proto__ = ChartElement2;
  FunnelSegment2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  FunnelSegment2.prototype.constructor = FunnelSegment2;
  FunnelSegment2.prototype.getLabelText = function getLabelText(options2) {
    var labelTemplate = getTemplate$1(options2);
    if (labelTemplate) {
      return labelTemplate(this.pointData());
    } else if (options2.format) {
      return this.formatValue(options2.format);
    }
    return this.value;
  };
  FunnelSegment2.prototype.reflow = function reflow(chartBox) {
    var points2 = this.points;
    var label = this.children[0];
    var x1 = Math.min(points2[0].x, points2[3].x);
    var x22 = Math.max(points2[1].x, points2[2].x);
    this.box = new Box(x1, points2[0].y, x22, points2[2].y);
    if (label) {
      label.reflow(new Box(chartBox.x1, points2[0].y, chartBox.x2, points2[2].y));
    }
  };
  FunnelSegment2.prototype.createVisual = function createVisual() {
    var this$1$1 = this;
    var options2 = this.options;
    var visual;
    ChartElement2.prototype.createVisual.call(this);
    this.addAccessibilityAttributesToVisual();
    if (options2.visual) {
      visual = options2.visual({
        category: this.category,
        dataItem: this.dataItem,
        value: this.value,
        series: this.series,
        percentage: this.percentage,
        points: this.points,
        options: options2,
        sender: this.getSender(),
        createVisual: function() {
          return this$1$1.createPath();
        }
      });
    } else {
      visual = this.createPath();
    }
    if (visual) {
      this.visual.append(visual);
    }
  };
  FunnelSegment2.prototype.createPath = function createPath() {
    var options2 = this.options;
    var border = options2.border;
    var path = Path$7.fromPoints(this.points, {
      fill: {
        color: options2.color,
        opacity: options2.opacity
      },
      stroke: {
        color: border.color,
        opacity: border.opacity,
        width: border.width
      }
    }).close();
    return path;
  };
  FunnelSegment2.prototype.createHighlight = function createHighlight(style2) {
    return Path$7.fromPoints(this.points, style2);
  };
  FunnelSegment2.prototype.highlightVisual = function highlightVisual() {
    return this.visual.children[0];
  };
  FunnelSegment2.prototype.highlightVisualArgs = function highlightVisualArgs() {
    var path = Path$7.fromPoints(this.points).close();
    return {
      options: this.options,
      path
    };
  };
  FunnelSegment2.prototype.createFocusHighlight = function createFocusHighlight(style2) {
    var borderWidth = this.options.accessibility.highlight.border.width;
    var result = Path$7.fromPoints(this.points, deepExtend({}, style2, {
      stroke: {
        width: borderWidth * 2
      }
    })).close();
    var clipPath = new MultiPath();
    clipPath.paths.push(Path$7.fromRect(this.box.clone().pad(borderWidth).toRect()));
    clipPath.paths.push(Path$7.fromPoints(this.points));
    result.clip(clipPath);
    return result;
  };
  FunnelSegment2.prototype.tooltipAnchor = function tooltipAnchor() {
    var box = this.box;
    return {
      point: new Point$5(box.center().x, box.y1),
      align: {
        horizontal: "center",
        vertical: "top"
      }
    };
  };
  FunnelSegment2.prototype.formatValue = function formatValue(format2) {
    var point2 = this;
    return point2.owner.formatPointValue(point2, format2);
  };
  FunnelSegment2.prototype.pointData = function pointData() {
    return {
      dataItem: this.dataItem,
      category: this.category,
      value: this.value,
      series: this.series,
      percentage: this.percentage
    };
  };
  FunnelSegment2.prototype.getIndex = function getIndex() {
    return this.index;
  };
  return FunnelSegment2;
}(ChartElement);
setDefaultOptions(FunnelSegment, {
  color: WHITE$1,
  border: {
    width: 1
  },
  labels: {
    format: ""
  },
  accessibility: {
    role: CHART_POINT_ROLE,
    className: CHART_POINT_CLASSNAME,
    ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION
  }
});
deepExtend(FunnelSegment.prototype, PointEventsMixin);
deepExtend(FunnelSegment.prototype, AccessibilityAttributesMixin);
var FunnelChart = function(ChartElement2) {
  function FunnelChart2(plotArea, options2) {
    ChartElement2.call(this, options2);
    this.plotArea = plotArea;
    this.chartService = plotArea.chartService;
    this.points = [];
    this.labels = [];
    this.legendItems = [];
    this.render();
  }
  if (ChartElement2)
    FunnelChart2.__proto__ = ChartElement2;
  FunnelChart2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  FunnelChart2.prototype.constructor = FunnelChart2;
  FunnelChart2.prototype.formatPointValue = function formatPointValue(point2, format2) {
    return this.plotArea.chartService.format.auto(format2, point2.value);
  };
  FunnelChart2.prototype.render = function render() {
    var this$1$1 = this;
    var seriesIx = 0;
    var ref2 = this;
    var options2 = ref2.options;
    var seriesColors = ref2.plotArea.options.seriesColors;
    if (seriesColors === void 0)
      seriesColors = [];
    var series = options2.series[seriesIx];
    var data2 = series.data;
    if (!data2) {
      return;
    }
    var ref$1 = bindSegments(series);
    var total3 = ref$1.total;
    var points2 = ref$1.points;
    for (var i16 = 0; i16 < points2.length; i16++) {
      var pointData = points2[i16];
      if (!pointData) {
        continue;
      }
      var fields = pointData.fields;
      if (!isFunction$1(series.color)) {
        series.color = fields.color || seriesColors[i16 % seriesColors.length];
      }
      fields = deepExtend({
        index: i16,
        owner: this$1$1,
        series,
        seriesIx,
        dataItem: data2[i16],
        percentage: pointData.value / total3
      }, fields, { visible: pointData.visible });
      var value2 = pointData.valueFields.value;
      var segment = this$1$1.createSegment(value2, fields);
      var label = this$1$1.createLabel(value2, fields);
      if (segment && label) {
        segment.append(label);
      }
    }
  };
  FunnelChart2.prototype.evalSegmentOptions = function evalSegmentOptions(options2, value2, fields) {
    var series = fields.series;
    evalOptions(options2, {
      value: value2,
      series,
      dataItem: fields.dataItem,
      index: fields.index
    }, { defaults: series._defaults, excluded: [
      "data",
      "content",
      "template",
      "toggle",
      "visual",
      "ariaTemplate",
      "ariaContent"
    ] });
  };
  FunnelChart2.prototype.createSegment = function createSegment(value2, fields) {
    var seriesOptions = deepExtend({}, fields.series);
    this.evalSegmentOptions(seriesOptions, value2, fields);
    this.createLegendItem(value2, seriesOptions, fields);
    if (fields.visible !== false) {
      var segment = new FunnelSegment(value2, seriesOptions, fields);
      Object.assign(segment, fields);
      this.append(segment);
      this.points.push(segment);
      return segment;
    }
  };
  FunnelChart2.prototype.createLabel = function createLabel(value2, fields) {
    var series = fields.series;
    var dataItem = fields.dataItem;
    var labels = deepExtend({}, this.options.labels, series.labels);
    var text = value2;
    if (labels.visible) {
      var labelTemplate = getTemplate$1(labels);
      var data2 = {
        dataItem,
        value: value2,
        percentage: fields.percentage,
        category: fields.category,
        series
      };
      if (labelTemplate) {
        text = labelTemplate(data2);
      } else if (labels.format) {
        text = this.chartService.format.auto(labels.format, text);
      }
      if (!labels.color) {
        labels.color = autoTextColor(series.color);
        if (!labels.background) {
          labels.background = series.color;
        }
      }
      this.evalSegmentOptions(labels, value2, fields);
      var textBox = new TextBox(text, deepExtend({
        vAlign: labels.position
      }, labels), data2);
      this.labels.push(textBox);
      return textBox;
    }
  };
  FunnelChart2.prototype.labelPadding = function labelPadding() {
    var labels = this.labels;
    var padding = { left: 0, right: 0 };
    for (var i16 = 0; i16 < labels.length; i16++) {
      var label = labels[i16];
      var align2 = label.options.align;
      if (align2 !== CENTER) {
        var width = labels[i16].box.width();
        if (align2 === LEFT) {
          padding.left = Math.max(padding.left, width);
        } else {
          padding.right = Math.max(padding.right, width);
        }
      }
    }
    return padding;
  };
  FunnelChart2.prototype.dynamicSlopeReflow = function dynamicSlopeReflow(box, width, totalHeight) {
    var ref2 = this;
    var options2 = ref2.options;
    var segments = ref2.points;
    var count = segments.length;
    var firstSegment = segments[0];
    var maxSegment = firstSegment;
    for (var idx = 0; idx < segments.length; idx++) {
      if (segments[idx].percentage > maxSegment.percentage) {
        maxSegment = segments[idx];
      }
    }
    var lastUpperSide = firstSegment.percentage / maxSegment.percentage * width;
    var previousOffset = (width - lastUpperSide) / 2;
    var previousHeight = 0;
    for (var idx$1 = 0; idx$1 < count; idx$1++) {
      var percentage = segments[idx$1].percentage;
      var nextSegment = segments[idx$1 + 1];
      var nextPercentage = nextSegment ? nextSegment.percentage : percentage;
      var points2 = segments[idx$1].points = [];
      var height = options2.dynamicHeight ? totalHeight * percentage : totalHeight / count;
      var offset2 = void 0;
      if (!percentage) {
        offset2 = nextPercentage ? 0 : width / 2;
      } else {
        offset2 = (width - lastUpperSide * (nextPercentage / percentage)) / 2;
      }
      offset2 = limitValue(offset2, 0, width);
      points2.push(new Point$7(box.x1 + previousOffset, box.y1 + previousHeight));
      points2.push(new Point$7(box.x1 + width - previousOffset, box.y1 + previousHeight));
      points2.push(new Point$7(box.x1 + width - offset2, box.y1 + height + previousHeight));
      points2.push(new Point$7(box.x1 + offset2, box.y1 + height + previousHeight));
      previousOffset = offset2;
      previousHeight += height + options2.segmentSpacing;
      lastUpperSide = limitValue(width - 2 * offset2, 0, width);
    }
  };
  FunnelChart2.prototype.constantSlopeReflow = function constantSlopeReflow(box, width, totalHeight) {
    var ref2 = this;
    var options2 = ref2.options;
    var segments = ref2.points;
    var count = segments.length;
    var decreasingWidth = options2.neckRatio <= 1;
    var neckRatio = decreasingWidth ? options2.neckRatio * width : width;
    var previousOffset = decreasingWidth ? 0 : (width - width / options2.neckRatio) / 2;
    var topMostWidth = decreasingWidth ? width : width - previousOffset * 2;
    var finalNarrow = (topMostWidth - neckRatio) / 2;
    var previousHeight = 0;
    for (var idx = 0; idx < count; idx++) {
      var points2 = segments[idx].points = [];
      var percentage = segments[idx].percentage;
      var offset2 = options2.dynamicHeight ? finalNarrow * percentage : finalNarrow / count;
      var height = options2.dynamicHeight ? totalHeight * percentage : totalHeight / count;
      points2.push(new Point$7(box.x1 + previousOffset, box.y1 + previousHeight));
      points2.push(new Point$7(box.x1 + width - previousOffset, box.y1 + previousHeight));
      points2.push(new Point$7(box.x1 + width - previousOffset - offset2, box.y1 + height + previousHeight));
      points2.push(new Point$7(box.x1 + previousOffset + offset2, box.y1 + height + previousHeight));
      previousOffset += offset2;
      previousHeight += height + options2.segmentSpacing;
    }
  };
  FunnelChart2.prototype.reflow = function reflow(chartBox) {
    var points2 = this.points;
    var count = points2.length;
    if (!count) {
      return;
    }
    var options2 = this.options;
    var box = chartBox.clone().unpad(this.labelPadding());
    var totalHeight = box.height() - options2.segmentSpacing * (count - 1);
    var width = box.width();
    if (options2.dynamicSlope) {
      this.dynamicSlopeReflow(box, width, totalHeight);
    } else {
      this.constantSlopeReflow(box, width, totalHeight);
    }
    for (var idx = 0; idx < count; idx++) {
      points2[idx].reflow(chartBox);
    }
  };
  return FunnelChart2;
}(ChartElement);
setDefaultOptions(FunnelChart, {
  neckRatio: 0.3,
  width: 300,
  dynamicSlope: false,
  dynamicHeight: true,
  segmentSpacing: 0,
  labels: {
    visible: false,
    align: CENTER,
    position: CENTER,
    zIndex: 1
  }
});
deepExtend(FunnelChart.prototype, PieChartMixin);
var MAX_NECK_RATIO = 1e6;
var PyramidChart = function(FunnelChart2) {
  function PyramidChart2(plotArea, options2) {
    options2.dynamicSlope = false;
    options2.neckRatio = MAX_NECK_RATIO;
    FunnelChart2.call(this, plotArea, options2);
  }
  if (FunnelChart2)
    PyramidChart2.__proto__ = FunnelChart2;
  PyramidChart2.prototype = Object.create(FunnelChart2 && FunnelChart2.prototype);
  PyramidChart2.prototype.constructor = PyramidChart2;
  return PyramidChart2;
}(FunnelChart);
var FunnelPlotArea = function(PlotAreaBase2) {
  function FunnelPlotArea2() {
    PlotAreaBase2.apply(this, arguments);
  }
  if (PlotAreaBase2)
    FunnelPlotArea2.__proto__ = PlotAreaBase2;
  FunnelPlotArea2.prototype = Object.create(PlotAreaBase2 && PlotAreaBase2.prototype);
  FunnelPlotArea2.prototype.constructor = FunnelPlotArea2;
  FunnelPlotArea2.prototype.render = function render() {
    this.createChart(FunnelChart, filterSeriesByType(this.series, [FUNNEL]));
    this.createChart(PyramidChart, filterSeriesByType(this.series, [PYRAMID]));
  };
  FunnelPlotArea2.prototype.createChart = function createChart(chartType, series) {
    var firstSeries = series[0];
    if (!firstSeries) {
      return;
    }
    var chart = new chartType(this, {
      series,
      legend: this.options.legend,
      neckRatio: firstSeries.neckRatio,
      dynamicHeight: firstSeries.dynamicHeight,
      dynamicSlope: firstSeries.dynamicSlope,
      segmentSpacing: firstSeries.segmentSpacing,
      highlight: firstSeries.highlight
    });
    this.appendChart(chart);
  };
  FunnelPlotArea2.prototype.appendChart = function appendChart(chart, pane) {
    PlotAreaBase2.prototype.appendChart.call(this, chart, pane);
    append(this.options.legend.data, chart.legendItems);
  };
  FunnelPlotArea2.prototype._pointsByVertical = function _pointsByVertical(basePoint) {
    return this.pointsBySeriesIndex(basePoint.series.index);
  };
  FunnelPlotArea2.prototype.getPointToTheRight = function getPointToTheRight(point2) {
    return this.getPointBelow(point2);
  };
  FunnelPlotArea2.prototype.getPointToTheLeft = function getPointToTheLeft(point2) {
    return this.getPointAbove(point2);
  };
  return FunnelPlotArea2;
}(PlotAreaBase);
var colorScale = function(color, minLightnessOffset) {
  if (minLightnessOffset === void 0)
    minLightnessOffset = 0.05;
  var baseColor = parseColor(color);
  var offset2 = 1 - minLightnessOffset;
  return function(value2) {
    var hsl = baseColor.toHSL();
    var range = 100 - hsl.l;
    var point2 = offset2 - value2;
    hsl.l += Math.min(point2 * range, range);
    return hsl.toCss();
  };
};
var HeatmapPoint = function(ChartElement2) {
  function HeatmapPoint2(value2, options2) {
    ChartElement2.call(this);
    this.options = options2;
    this.color = options2.color || WHITE$1;
    this.value = value2;
  }
  if (ChartElement2)
    HeatmapPoint2.__proto__ = ChartElement2;
  HeatmapPoint2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  HeatmapPoint2.prototype.constructor = HeatmapPoint2;
  HeatmapPoint2.prototype.render = function render() {
    if (this._rendered) {
      return;
    }
    this._rendered = true;
    this.createMarker();
    this.createLabel();
    this.createNote();
  };
  HeatmapPoint2.prototype.createLabel = function createLabel() {
    var options2 = this.options;
    var labels = options2.labels;
    if (labels.visible) {
      this.label = this.createLabelElement(labels);
      this.append(this.label);
    }
  };
  HeatmapPoint2.prototype.createLabelElement = function createLabelElement(options2) {
    var labelColor = options2.color;
    if (!labelColor) {
      labelColor = autoTextColor(this.color);
    }
    return new TextBox(
      this.getLabelText(options2),
      deepExtend(
        {
          align: CENTER,
          vAlign: CENTER,
          margin: {
            left: 5,
            right: 5
          },
          zIndex: valueOrDefault$1(options2.zIndex, this.series.zIndex)
        },
        options2,
        {
          color: labelColor
        }
      ),
      this.pointData()
    );
  };
  HeatmapPoint2.prototype.getLabelText = function getLabelText(options2) {
    var labelTemplate = getTemplate$1(options2);
    if (labelTemplate) {
      return labelTemplate(this.pointData());
    }
    return this.formatValue(options2.format);
  };
  HeatmapPoint2.prototype.formatValue = function formatValue(format2) {
    return this.owner.formatPointValue(this, format2);
  };
  HeatmapPoint2.prototype.reflow = function reflow(targetBox) {
    this.render();
    var label = this.label;
    this.box = targetBox;
    if (label) {
      label.reflow(this.markerBox());
    }
    if (this.note) {
      this.note.reflow(targetBox);
    }
    this.marker.reflow(this.markerBox());
  };
  HeatmapPoint2.prototype.createVisual = function createVisual() {
    ChartElement2.prototype.createVisual.call(this);
    this.addAccessibilityAttributesToVisual();
  };
  HeatmapPoint2.prototype.markerBox = function markerBox() {
    var options2 = this.options;
    var markers = options2.markers;
    var border = markers.border;
    var rect = this.box.toRect();
    var type = valueOrDefault$1(markers.type, "rect");
    var isRoundRect = type === ROUNDED_RECT;
    var borderWidth = valueOrDefault$1(border.width, isRoundRect ? 1 : 0);
    var halfBorderWidth = Math.round(borderWidth / 2);
    if (markers.size) {
      var center = rect.center();
      rect.size.width = rect.size.height = markers.size;
      rect.origin.x = Math.round(center.x - rect.size.width / 2);
      rect.origin.y = Math.round(center.y - rect.size.height / 2);
    }
    rect.size.width -= borderWidth;
    rect.size.height -= borderWidth;
    rect.origin.y += halfBorderWidth + 0.5;
    rect.origin.x += halfBorderWidth + 0.5;
    return rectToBox(rect);
  };
  HeatmapPoint2.prototype.markerBorder = function markerBorder() {
    var options2 = this.options;
    var markers = options2.markers;
    var border = markers.border;
    var opacity = valueOrDefault$1(border.opacity, options2.opacity);
    return {
      color: border.color || this.color,
      width: border.width,
      opacity,
      dashType: border.dashType
    };
  };
  HeatmapPoint2.prototype.createMarker = function createMarker() {
    var options2 = this.options;
    var markerOptions = options2.markers;
    var marker = new ShapeElement({
      type: valueOrDefault$1(markerOptions.type, "rect"),
      width: markerOptions.size,
      height: markerOptions.size,
      rotation: markerOptions.rotation,
      background: this.color,
      border: this.markerBorder(),
      borderRadius: markerOptions.borderRadius,
      opacity: this.series.opacity || options2.opacity,
      zIndex: valueOrDefault$1(options2.zIndex, this.series.zIndex),
      animation: options2.animation,
      visual: options2.visual
    }, {
      dataItem: this.dataItem,
      value: this.value,
      series: this.series,
      category: this.category
    });
    this.marker = marker;
    this.append(marker);
  };
  HeatmapPoint2.prototype.createHighlight = function createHighlight(style2) {
    var options2 = this.options;
    var markerOptions = this.options.highlight.markers || this.options.markers;
    var highlight = new ShapeElement({
      type: valueOrDefault$1(markerOptions.type, "rect"),
      width: markerOptions.size,
      height: markerOptions.size,
      rotation: markerOptions.rotation,
      background: markerOptions.color || this.color,
      border: this.markerBorder(),
      borderRadius: markerOptions.borderRadius,
      opacity: this.series.opacity || options2.opacity,
      zIndex: valueOrDefault$1(options2.zIndex, this.series.zIndex)
    });
    highlight.reflow(this.markerBox());
    var visual = highlight.getElement();
    visual.options.fill = style2.fill;
    visual.options.stroke = style2.stroke;
    return visual;
  };
  HeatmapPoint2.prototype.highlightVisual = function highlightVisual() {
    return this.rectVisual;
  };
  HeatmapPoint2.prototype.highlightVisualArgs = function highlightVisualArgs() {
    return {
      options: this.options,
      rect: this.box.toRect(),
      visual: this.rectVisual
    };
  };
  HeatmapPoint2.prototype.createFocusHighlight = function createFocusHighlight() {
    var markerOptions = this.options.markers;
    var highlightOptions2 = this.options.accessibility.highlight;
    var highlight = new ShapeElement({
      type: valueOrDefault$1(markerOptions.type, "rect"),
      width: markerOptions.size,
      height: markerOptions.size,
      rotation: markerOptions.rotation,
      background: highlightOptions2.color,
      border: highlightOptions2.border,
      borderRadius: markerOptions.borderRadius,
      padding: highlightOptions2.border.width / 2,
      zIndex: highlightOptions2.zIndex
    });
    highlight.reflow(this.markerBox());
    return highlight.getElement();
  };
  HeatmapPoint2.prototype.tooltipAnchor = function tooltipAnchor() {
    var left = this.box.center().x;
    var top = this.box.y1 - TOOLTIP_OFFSET;
    return {
      point: new Point$5(left, top),
      align: {
        horizontal: CENTER,
        vertical: BOTTOM
      }
    };
  };
  HeatmapPoint2.prototype.overlapsBox = function overlapsBox(box) {
    return this.box.overlaps(box);
  };
  HeatmapPoint2.prototype.unclipElements = function unclipElements() {
  };
  HeatmapPoint2.prototype.pointData = function pointData() {
    return {
      x: this.value.x,
      y: this.value.y,
      value: this.value.value,
      dataItem: this.dataItem,
      series: this.series
    };
  };
  return HeatmapPoint2;
}(ChartElement);
deepExtend(HeatmapPoint.prototype, PointEventsMixin);
deepExtend(HeatmapPoint.prototype, NoteMixin);
deepExtend(HeatmapPoint.prototype, AccessibilityAttributesMixin);
HeatmapPoint.prototype.defaults = {
  markers: {
    type: "rect",
    borderRadius: 4,
    border: {
      color: "transparent"
    }
  },
  padding: { top: 1 },
  labels: {
    visible: false,
    padding: 3
  },
  opacity: 1,
  notes: {
    label: {}
  },
  accessibility: {
    role: CHART_POINT_ROLE,
    className: CHART_POINT_CLASSNAME,
    ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION
  }
};
var HeatmapChart = function(ChartElement2) {
  function HeatmapChart2(plotArea, options2) {
    ChartElement2.call(this, options2);
    this.plotArea = plotArea;
    this.chartService = plotArea.chartService;
    this._initFields();
    this.render();
  }
  if (ChartElement2)
    HeatmapChart2.__proto__ = ChartElement2;
  HeatmapChart2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  HeatmapChart2.prototype.constructor = HeatmapChart2;
  HeatmapChart2.prototype._initFields = function _initFields() {
    this.points = [];
    this.seriesOptions = [];
    this.valueRange = { min: MAX_VALUE, max: MIN_VALUE };
    this._evalSeries = [];
  };
  HeatmapChart2.prototype.render = function render() {
    this.setRange();
    this.traverseDataPoints(this.addValue.bind(this));
  };
  HeatmapChart2.prototype.setRange = function setRange() {
    var this$1$1 = this;
    var ref2 = this;
    var series = ref2.options.series;
    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {
      var currentSeries = series[seriesIx];
      for (var pointIx = 0; pointIx < currentSeries.data.length; pointIx++) {
        var ref$1 = this$1$1.plotArea.bindPoint(currentSeries, pointIx);
        var valueFields = ref$1.valueFields;
        if (defined(valueFields.value) && valueFields.value !== null) {
          this$1$1.valueRange.min = Math.min(this$1$1.valueRange.min, valueFields.value);
          this$1$1.valueRange.max = Math.max(this$1$1.valueRange.max, valueFields.value);
        }
      }
    }
  };
  HeatmapChart2.prototype.addValue = function addValue(value2, fields) {
    var point2;
    if (value2 && defined(value2.value) && value2.value !== null) {
      point2 = this.createPoint(value2, fields);
      if (point2) {
        Object.assign(point2, fields);
      }
    }
    this.points.push(point2);
  };
  HeatmapChart2.prototype.evalPointOptions = function evalPointOptions(options2, value2, fields) {
    var series = fields.series;
    var seriesIx = fields.seriesIx;
    var state = {
      defaults: series._defaults,
      excluded: [
        "data",
        "tooltip",
        "content",
        "template",
        "visual",
        "toggle",
        "drilldownSeriesFactory",
        "ariaTemplate",
        "ariaContent"
      ]
    };
    var doEval = this._evalSeries[seriesIx];
    if (!defined(doEval)) {
      this._evalSeries[seriesIx] = doEval = evalOptions(options2, {}, state, true);
    }
    var pointOptions = options2;
    if (doEval) {
      pointOptions = deepExtend({}, options2);
      evalOptions(pointOptions, {
        value: value2,
        series,
        dataItem: fields.dataItem,
        min: this.valueRange.min,
        max: this.valueRange.max
      }, state);
    }
    return pointOptions;
  };
  HeatmapChart2.prototype.pointType = function pointType() {
    return HeatmapPoint;
  };
  HeatmapChart2.prototype.pointOptions = function pointOptions(series, seriesIx) {
    var options2 = this.seriesOptions[seriesIx];
    if (!options2) {
      var defaults = this.pointType().prototype.defaults;
      this.seriesOptions[seriesIx] = options2 = deepExtend({}, defaults, {
        markers: {
          opacity: series.opacity
        },
        tooltip: {
          format: this.options.tooltip.format
        },
        labels: {
          format: this.options.labels.format
        }
      }, series);
    }
    return options2;
  };
  HeatmapChart2.prototype.createPoint = function createPoint(value2, fields) {
    var series = fields.series;
    var pointOptions = this.pointOptions(series, fields.seriesIx);
    var color = fields.color || series.color;
    pointOptions = this.evalPointOptions(pointOptions, value2, fields);
    if (isFunction$1(series.color)) {
      color = pointOptions.color;
    } else if (this.valueRange.max !== 0) {
      var scale = colorScale(color);
      color = scale(value2.value / this.valueRange.max);
    }
    var point2 = new HeatmapPoint(value2, pointOptions);
    point2.color = color;
    this.append(point2);
    return point2;
  };
  HeatmapChart2.prototype.seriesAxes = function seriesAxes(series) {
    var xAxisName = series.xAxis;
    var yAxisName = series.yAxis;
    var plotArea = this.plotArea;
    var xAxis = xAxisName ? plotArea.namedXAxes[xAxisName] : plotArea.axisX;
    var yAxis = yAxisName ? plotArea.namedYAxes[yAxisName] : plotArea.axisY;
    if (!xAxis) {
      throw new Error("Unable to locate X axis with name " + xAxisName);
    }
    if (!yAxis) {
      throw new Error("Unable to locate Y axis with name " + yAxisName);
    }
    return { xAxis, yAxis };
  };
  HeatmapChart2.prototype.reflow = function reflow(targetBox) {
    var this$1$1 = this;
    var chartPoints = this.points;
    var limit = !this.options.clip;
    var pointIx = 0;
    this.traverseDataPoints(function(value2, fields) {
      var point2 = chartPoints[pointIx++];
      var ref2 = this$1$1.seriesAxes(fields.series);
      var xAxis = ref2.xAxis;
      var yAxis = ref2.yAxis;
      var indexX = xAxis.categoryIndex(value2.x);
      var indexY = yAxis.categoryIndex(value2.y);
      var slotX = xAxis.getSlot(indexX, indexX, limit);
      var slotY = yAxis.getSlot(indexY, indexY, limit);
      if (point2) {
        if (slotX && slotY) {
          var pointSlot = this$1$1.pointSlot(slotX, slotY);
          point2.reflow(pointSlot);
        } else {
          point2.visible = false;
        }
      }
    });
    this.box = targetBox;
  };
  HeatmapChart2.prototype.pointSlot = function pointSlot(slotX, slotY) {
    return new Box(slotX.x1, slotY.y1, slotX.x2, slotY.y2);
  };
  HeatmapChart2.prototype.traverseDataPoints = function traverseDataPoints(callback) {
    var this$1$1 = this;
    var ref2 = this;
    var series = ref2.options.series;
    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {
      var currentSeries = series[seriesIx];
      var ref$1 = this$1$1.seriesAxes(currentSeries);
      var xAxis = ref$1.xAxis;
      var yAxis = ref$1.yAxis;
      var xRange = xAxis.currentRangeIndices();
      var yRange = yAxis.currentRangeIndices();
      for (var pointIx = 0; pointIx < currentSeries.data.length; pointIx++) {
        var ref$2 = this$1$1.plotArea.bindPoint(currentSeries, pointIx);
        var value2 = ref$2.valueFields;
        var fields = ref$2.fields;
        var xIndex = xAxis.totalIndex(value2.x);
        var yIndex = yAxis.totalIndex(value2.y);
        var xIn = xRange.min <= xIndex && xIndex <= xRange.max;
        var yIn = yRange.min <= yIndex && yIndex <= yRange.max;
        if (xIn && yIn) {
          callback(value2, deepExtend({
            pointIx,
            series: currentSeries,
            seriesIx,
            dataItem: currentSeries.data[pointIx],
            owner: this$1$1
          }, fields));
        }
      }
    }
  };
  HeatmapChart2.prototype.formatPointValue = function formatPointValue(point2, format2) {
    var value2 = point2.value;
    return this.chartService.format.auto(format2, value2.x, value2.y, value2.value);
  };
  HeatmapChart2.prototype.animationPoints = function animationPoints() {
    var points2 = this.points;
    var result = [];
    for (var idx = 0; idx < points2.length; idx++) {
      result.push((points2[idx] || {}).marker);
    }
    return result;
  };
  return HeatmapChart2;
}(ChartElement);
setDefaultOptions(HeatmapChart, {
  series: [],
  tooltip: {
    format: "{0}, {1}: {2}"
  },
  labels: {
    format: "{2}"
  },
  clip: true
});
var HeatmapPlotArea = function(PlotAreaBase2) {
  function HeatmapPlotArea2() {
    PlotAreaBase2.apply(this, arguments);
  }
  if (PlotAreaBase2)
    HeatmapPlotArea2.__proto__ = PlotAreaBase2;
  HeatmapPlotArea2.prototype = Object.create(PlotAreaBase2 && PlotAreaBase2.prototype);
  HeatmapPlotArea2.prototype.constructor = HeatmapPlotArea2;
  HeatmapPlotArea2.prototype.initFields = function initFields() {
    this.namedXAxes = {};
    this.namedYAxes = {};
  };
  HeatmapPlotArea2.prototype.render = function render(panes) {
    if (panes === void 0)
      panes = this.panes;
    this.bindCategories();
    this.createAxes(panes);
    this.createCharts(panes);
    this.createAxisLabels();
  };
  HeatmapPlotArea2.prototype.bindCategories = function bindCategories() {
    var this$1$1 = this;
    var series = this.srcSeries || this.series;
    for (var i16 = 0; i16 < series.length; i16++) {
      var currentSeries = series[i16];
      var data2 = currentSeries.data || [];
      var ref2 = this$1$1.seriesAxes(currentSeries);
      var xAxis = ref2.xAxis;
      var yAxis = ref2.yAxis;
      var xCategories = createHashSet(xAxis.categories || []);
      var yCategories = createHashSet(yAxis.categories || []);
      for (var pointIndex = 0; pointIndex < data2.length; pointIndex++) {
        var ref$1 = SeriesBinder.current.bindPoint(currentSeries, pointIndex).valueFields;
        var x3 = ref$1.x;
        var y4 = ref$1.y;
        if (!xCategories.has(x3)) {
          xCategories.add(x3);
        }
        if (!yCategories.has(y4)) {
          yCategories.add(y4);
        }
      }
      xAxis.categories = xCategories.values();
      yAxis.categories = yCategories.values();
    }
  };
  HeatmapPlotArea2.prototype.createCharts = function createCharts(panes) {
    var this$1$1 = this;
    var seriesByPane = this.groupSeriesByPane();
    for (var i16 = 0; i16 < panes.length; i16++) {
      var pane = panes[i16];
      var paneSeries = seriesByPane[pane.options.name || "default"] || [];
      this$1$1.addToLegend(paneSeries);
      var filteredSeries = this$1$1.filterVisibleSeries(paneSeries);
      if (!filteredSeries) {
        continue;
      }
      this$1$1.createHeatmapChart(
        filterSeriesByType(filteredSeries, [HEATMAP]),
        pane
      );
    }
  };
  HeatmapPlotArea2.prototype.createHeatmapChart = function createHeatmapChart(series, pane) {
    var chart = new HeatmapChart(this, {
      series
    });
    this.appendChart(chart, pane);
  };
  HeatmapPlotArea2.prototype.seriesPaneName = function seriesPaneName(series) {
    var options2 = this.options;
    var xAxisName = series.xAxis;
    var xAxisOptions = [].concat(options2.xAxis);
    var xAxis = grep(xAxisOptions, function(a9) {
      return a9.name === xAxisName;
    })[0];
    var yAxisName = series.yAxis;
    var yAxisOptions = [].concat(options2.yAxis);
    var yAxis = grep(yAxisOptions, function(a9) {
      return a9.name === yAxisName;
    })[0];
    var panes = options2.panes || [{}];
    var defaultPaneName = panes[0].name || "default";
    var paneName = (xAxis || {}).pane || (yAxis || {}).pane || defaultPaneName;
    return paneName;
  };
  HeatmapPlotArea2.prototype.seriesAxes = function seriesAxes(series) {
    var xAxis;
    var yAxis;
    var options2 = this.options;
    var xAxisOptions = [].concat(options2.xAxis);
    var xAxisName = series.xAxis;
    if (xAxisName) {
      xAxis = xAxisOptions.find(function(axis) {
        return axis.name === xAxisName;
      });
    } else {
      xAxis = xAxisOptions[0];
    }
    var yAxisOptions = [].concat(options2.yAxis);
    var yAxisName = series.yAxis;
    if (yAxisName) {
      yAxis = yAxisOptions.find(function(axis) {
        return axis.name === yAxisName;
      });
    } else {
      yAxis = yAxisOptions[0];
    }
    if (!xAxis) {
      throw new Error("Unable to locate X axis with name " + xAxisName);
    }
    if (!yAxis) {
      throw new Error("Unable to locate Y axis with name " + yAxisName);
    }
    return { xAxis, yAxis };
  };
  HeatmapPlotArea2.prototype.createAxisLabels = function createAxisLabels() {
    var axes = this.axes;
    for (var i16 = 0; i16 < axes.length; i16++) {
      axes[i16].createLabels();
    }
  };
  HeatmapPlotArea2.prototype.createXYAxis = function createXYAxis(options2, vertical, axisIndex) {
    var axisName = options2.name;
    var namedAxes = vertical ? this.namedYAxes : this.namedXAxes;
    var axisOptions2 = Object.assign({
      axisCrossingValue: 0
    }, options2, {
      vertical,
      reverse: vertical || this.chartService.rtl ? !options2.reverse : options2.reverse,
      justified: false
    });
    var firstCategory = axisOptions2.categories ? axisOptions2.categories[0] : null;
    var typeSamples = [axisOptions2.min, axisOptions2.max, firstCategory];
    var series = this.series;
    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {
      var currentSeries = series[seriesIx];
      var seriesAxisName = currentSeries[vertical ? "yAxis" : "xAxis"];
      if (seriesAxisName === axisOptions2.name || axisIndex === 0 && !seriesAxisName) {
        var firstPointValue = SeriesBinder.current.bindPoint(currentSeries, 0).valueFields;
        typeSamples.push(firstPointValue[vertical ? "y" : "x"]);
        break;
      }
    }
    var inferredDate;
    for (var i16 = 0; i16 < typeSamples.length; i16++) {
      if (typeSamples[i16] instanceof Date) {
        inferredDate = true;
        break;
      }
    }
    var axisType;
    if (equalsIgnoreCase(axisOptions2.type, DATE) || !axisOptions2.type && inferredDate) {
      axisType = DateCategoryAxis;
    } else {
      axisType = CategoryAxis;
    }
    var axis = new axisType(axisOptions2, this.chartService);
    axis.axisIndex = axisIndex;
    if (axisName) {
      if (namedAxes[axisName]) {
        throw new Error((vertical ? "Y" : "X") + " axis with name " + axisName + " is already defined");
      }
      namedAxes[axisName] = axis;
    }
    this.appendAxis(axis);
    axis.indexCategories();
    return axis;
  };
  HeatmapPlotArea2.prototype.createAxes = function createAxes(panes) {
    var this$1$1 = this;
    var options2 = this.options;
    var xAxesOptions = [].concat(options2.xAxis);
    var xAxes = [];
    var yAxesOptions = [].concat(options2.yAxis);
    var yAxes = [];
    for (var idx = 0; idx < xAxesOptions.length; idx++) {
      var axisPane = this$1$1.findPane(xAxesOptions[idx].pane);
      if (inArray(axisPane, panes)) {
        xAxes.push(this$1$1.createXYAxis(xAxesOptions[idx], false, idx));
      }
    }
    for (var idx$1 = 0; idx$1 < yAxesOptions.length; idx$1++) {
      var axisPane$1 = this$1$1.findPane(yAxesOptions[idx$1].pane);
      if (inArray(axisPane$1, panes)) {
        yAxes.push(this$1$1.createXYAxis(yAxesOptions[idx$1], true, idx$1));
      }
    }
    this.axisX = this.axisX || xAxes[0];
    this.axisY = this.axisY || yAxes[0];
  };
  HeatmapPlotArea2.prototype.removeAxis = function removeAxis(axis) {
    var axisName = axis.options.name;
    PlotAreaBase2.prototype.removeAxis.call(this, axis);
    if (axis.options.vertical) {
      delete this.namedYAxes[axisName];
    } else {
      delete this.namedXAxes[axisName];
    }
    if (axis === this.axisX) {
      delete this.axisX;
    }
    if (axis === this.axisY) {
      delete this.axisY;
    }
  };
  HeatmapPlotArea2.prototype._dispatchEvent = function _dispatchEvent(chart, e3, eventType) {
    var coords = chart._eventCoordinates(e3);
    var point2 = new Point$5(coords.x, coords.y);
    var allAxes = this.axes;
    var length = allAxes.length;
    var xValues = [];
    var yValues = [];
    for (var i16 = 0; i16 < length; i16++) {
      var axis = allAxes[i16];
      var values6 = axis.options.vertical ? yValues : xValues;
      appendIfNotNull(values6, axis.getCategory(point2));
    }
    if (xValues.length > 0 && yValues.length > 0) {
      chart.trigger(eventType, {
        element: eventElement(e3),
        originalEvent: e3,
        x: singleItemOrArray(xValues),
        y: singleItemOrArray(yValues)
      });
    }
  };
  HeatmapPlotArea2.prototype.updateAxisOptions = function updateAxisOptions$12(axis, options2) {
    var vertical = axis.options.vertical;
    var axes = this.groupAxes(this.panes);
    var index2 = (vertical ? axes.y : axes.x).indexOf(axis);
    updateAxisOptions(this.options, index2, vertical, options2);
    updateAxisOptions(this.originalOptions, index2, vertical, options2);
  };
  HeatmapPlotArea2.prototype.crosshairOptions = function crosshairOptions(axis) {
    return Object.assign({}, axis.options.crosshair, { zIndex: 0 });
  };
  HeatmapPlotArea2.prototype._pointsByVertical = function _pointsByVertical(basePoint, offset2) {
    var this$1$1 = this;
    if (offset2 === void 0)
      offset2 = 0;
    var normalizedOffset = this.axisX.options.reverse ? offset2 * -1 : offset2;
    var axisXItems = this.axisX.children;
    var xIndex = this._getPointAxisXIndex(basePoint) + normalizedOffset;
    xIndex = cycleIndex(xIndex, axisXItems.length);
    var targetXValue = axisXItems[xIndex].value;
    var points2 = this.filterPoints(function(point2) {
      return compareValues(point2.pointData().x, targetXValue);
    }).sort(function(a9, b2) {
      return this$1$1._getPointAxisYIndex(a9) - this$1$1._getPointAxisYIndex(b2);
    });
    if (this.axisY.options.reverse) {
      return points2.reverse();
    }
    return points2;
  };
  HeatmapPlotArea2.prototype._pointsByHorizontal = function _pointsByHorizontal(basePoint, offset2) {
    var this$1$1 = this;
    if (offset2 === void 0)
      offset2 = 0;
    var normalizedOffset = this.axisY.options.reverse ? offset2 * -1 : offset2;
    var axisYItems = this.axisY.children;
    var yIndex = this._getPointAxisYIndex(basePoint) + normalizedOffset;
    yIndex = cycleIndex(yIndex, axisYItems.length);
    var targetYValue = axisYItems[yIndex].value;
    var points2 = this.filterPoints(function(point2) {
      return compareValues(point2.pointData().y, targetYValue);
    }).sort(function(a9, b2) {
      return this$1$1._getPointAxisXIndex(a9) - this$1$1._getPointAxisXIndex(b2);
    });
    if (this.axisX.options.reverse) {
      return points2.reverse();
    }
    return points2;
  };
  HeatmapPlotArea2.prototype._getPointAxisXIndex = function _getPointAxisXIndex(point2) {
    return this._getPointAxisIndex(this.axisX, point2.pointData().x);
  };
  HeatmapPlotArea2.prototype._getPointAxisYIndex = function _getPointAxisYIndex(point2) {
    return this._getPointAxisIndex(this.axisY, point2.pointData().y);
  };
  HeatmapPlotArea2.prototype._getPointAxisIndex = function _getPointAxisIndex(axis, pointValue) {
    return axis.children.findIndex(function(axisItem) {
      return compareValues(pointValue, axisItem.value);
    });
  };
  return HeatmapPlotArea2;
}(PlotAreaBase);
function compareValues(a9, b2) {
  if (a9 instanceof Date && b2 instanceof Date) {
    return dateEquals(a9, b2);
  }
  return a9 === b2;
}
function updateAxisOptions(targetOptions, axisIndex, vertical, options2) {
  var axisOptions2 = [].concat(vertical ? targetOptions.yAxis : targetOptions.xAxis)[axisIndex];
  deepExtend(axisOptions2, options2);
}
setDefaultOptions(HeatmapPlotArea, {
  xAxis: {},
  yAxis: {}
});
deepExtend(HeatmapPlotArea.prototype, PlotAreaEventsMixin);
var COLOR = "color";
var FIRST = "first";
var FROM = "from";
var MAX = "max";
var MIN = "min";
var NOTE_TEXT = "noteText";
var SUMMARY_FIELD = "summary";
var TO = "to";
PlotAreaFactory.current.register(CategoricalPlotArea, [
  BAR,
  COLUMN,
  LINE,
  VERTICAL_LINE,
  AREA,
  VERTICAL_AREA,
  CANDLESTICK,
  OHLC,
  BULLET,
  VERTICAL_BULLET,
  BOX_PLOT,
  VERTICAL_BOX_PLOT,
  RANGE_COLUMN,
  RANGE_BAR,
  WATERFALL,
  HORIZONTAL_WATERFALL,
  RANGE_AREA,
  VERTICAL_RANGE_AREA
].concat(
  TRENDLINE_SERIES
));
PlotAreaFactory.current.register(XYPlotArea, [
  SCATTER,
  SCATTER_LINE,
  BUBBLE
].concat(
  TRENDLINE_SERIES
));
PlotAreaFactory.current.register(PiePlotArea, [PIE]);
PlotAreaFactory.current.register(DonutPlotArea, [DONUT]);
PlotAreaFactory.current.register(FunnelPlotArea, [FUNNEL, PYRAMID]);
PlotAreaFactory.current.register(PolarPlotArea, [
  POLAR_AREA,
  POLAR_LINE,
  POLAR_SCATTER
].concat(
  TRENDLINE_SERIES
));
PlotAreaFactory.current.register(RadarPlotArea, [
  RADAR_AREA,
  RADAR_COLUMN,
  RADAR_LINE
].concat(
  TRENDLINE_SERIES
));
PlotAreaFactory.current.register(HeatmapPlotArea, [HEATMAP]);
SeriesBinder.current.register(
  [BAR, COLUMN, LINE, VERTICAL_LINE, AREA, VERTICAL_AREA],
  [VALUE],
  [CATEGORY, COLOR, NOTE_TEXT, ERROR_LOW_FIELD, ERROR_HIGH_FIELD, DRILLDOWN_FIELD]
);
SeriesBinder.current.register(
  [RANGE_COLUMN, RANGE_BAR, RANGE_AREA, VERTICAL_RANGE_AREA],
  [FROM, TO],
  [CATEGORY, COLOR, NOTE_TEXT, DRILLDOWN_FIELD]
);
SeriesBinder.current.register(
  [WATERFALL, HORIZONTAL_WATERFALL],
  [VALUE],
  [CATEGORY, COLOR, NOTE_TEXT, SUMMARY_FIELD, DRILLDOWN_FIELD]
);
SeriesBinder.current.register([POLAR_AREA, POLAR_LINE, POLAR_SCATTER], [X$4, Y$7], [COLOR, DRILLDOWN_FIELD]);
SeriesBinder.current.register([RADAR_AREA, RADAR_COLUMN, RADAR_LINE], [VALUE], [CATEGORY, COLOR, DRILLDOWN_FIELD]);
SeriesBinder.current.register(
  [FUNNEL, PYRAMID],
  [VALUE],
  [CATEGORY, COLOR, "visibleInLegend", "visible", DRILLDOWN_FIELD]
);
DefaultAggregates.current.register(
  [BAR, COLUMN, LINE, VERTICAL_LINE, AREA, VERTICAL_AREA, WATERFALL, HORIZONTAL_WATERFALL],
  { value: MAX, color: FIRST, noteText: FIRST, errorLow: MIN, errorHigh: MAX }
);
DefaultAggregates.current.register(
  [RANGE_COLUMN, RANGE_BAR, RANGE_AREA, VERTICAL_RANGE_AREA],
  { from: MIN, to: MAX, color: FIRST, noteText: FIRST }
);
DefaultAggregates.current.register(
  [RADAR_AREA, RADAR_COLUMN, RADAR_LINE],
  { value: MAX, color: FIRST }
);
SeriesBinder.current.register(
  [SCATTER, SCATTER_LINE, BUBBLE],
  [X$4, Y$7],
  [COLOR, NOTE_TEXT, X_ERROR_LOW_FIELD, X_ERROR_HIGH_FIELD, Y_ERROR_LOW_FIELD, Y_ERROR_HIGH_FIELD]
);
SeriesBinder.current.register(
  [BUBBLE],
  [X$4, Y$7, "size"],
  [COLOR, CATEGORY, NOTE_TEXT]
);
SeriesBinder.current.register(
  [HEATMAP],
  [X$4, Y$7, VALUE],
  [COLOR, NOTE_TEXT]
);
SeriesBinder.current.register(
  [CANDLESTICK, OHLC],
  ["open", "high", "low", "close"],
  [CATEGORY, COLOR, "downColor", NOTE_TEXT]
);
DefaultAggregates.current.register(
  [CANDLESTICK, OHLC],
  {
    open: MAX,
    high: MAX,
    low: MIN,
    close: MAX,
    color: FIRST,
    downColor: FIRST,
    noteText: FIRST
  }
);
SeriesBinder.current.register(
  [BOX_PLOT, VERTICAL_BOX_PLOT],
  ["lower", "q1", "median", "q3", "upper", "mean", "outliers"],
  [CATEGORY, COLOR, NOTE_TEXT, DRILLDOWN_FIELD]
);
DefaultAggregates.current.register(
  [BOX_PLOT, VERTICAL_BOX_PLOT],
  {
    lower: MAX,
    q1: MAX,
    median: MAX,
    q3: MAX,
    upper: MAX,
    mean: MAX,
    outliers: FIRST,
    color: FIRST,
    noteText: FIRST
  }
);
SeriesBinder.current.register(
  [BULLET, VERTICAL_BULLET],
  ["current", "target"],
  [CATEGORY, COLOR, "visibleInLegend", NOTE_TEXT, DRILLDOWN_FIELD]
);
DefaultAggregates.current.register(
  [BULLET, VERTICAL_BULLET],
  { current: MAX, target: MAX, color: FIRST, noteText: FIRST }
);
SeriesBinder.current.register(
  [PIE, DONUT],
  [VALUE],
  [CATEGORY, COLOR, "explode", "visibleInLegend", "visible", DRILLDOWN_FIELD]
);
var AXIS_NAMES = [CATEGORY, VALUE, X$4, Y$7];
var MOUSEDOWN = "mousedown";
var MOUSEMOVE = "mousemove";
var CONTEXTMENU = "contextmenu";
var MOUSELEAVE = "mouseleave";
var KEYDOWN = "keydown";
var FOCUS = "focus";
var BLUR = "blur";
var MOUSEMOVE_DELAY = 20;
var Chart$1 = function(Class3) {
  function Chart2(element, userOptions, themeOptions, context2) {
    var this$1$1 = this;
    if (context2 === void 0)
      context2 = {};
    Class3.call(this);
    this.observers = [];
    this.addObserver(context2.observer);
    this.chartService = new ChartService(this, context2);
    this.chartService.theme = themeOptions;
    this._initElement(element);
    var options2 = deepExtend({}, this.options, userOptions);
    this._originalOptions = deepExtend({}, options2);
    this._theme = themeOptions;
    this._initTheme(options2, themeOptions);
    this._focusState = {};
    this._initHandlers();
    this._initSurface();
    this.bindCategories();
    FontLoader.preloadFonts(userOptions, function() {
      this$1$1.fontLoaded = true;
      if (!this$1$1._destroyed) {
        this$1$1.trigger("init");
        this$1$1._redraw();
        this$1$1._attachEvents();
      }
    });
  }
  if (Class3)
    Chart2.__proto__ = Class3;
  Chart2.prototype = Object.create(Class3 && Class3.prototype);
  Chart2.prototype.constructor = Chart2;
  Chart2.prototype._initElement = function _initElement(element) {
    this._setElementClass(element);
    element.style.position = "relative";
    element.tabIndex = element.getAttribute("tabindex") ? element.getAttribute("tabindex") : 0;
    element.setAttribute("role", "graphics-document document");
    while (element.firstChild) {
      element.removeChild(element.firstChild);
    }
    this.element = element;
  };
  Chart2.prototype._setElementClass = function _setElementClass(element) {
    addClass2(element, "k-chart");
  };
  Chart2.prototype._initTheme = function _initTheme(options2, themeOptions) {
    var seriesCopies = [];
    var series = options2.series || [];
    for (var i16 = 0; i16 < series.length; i16++) {
      seriesCopies.push(Object.assign({}, series[i16]));
    }
    options2.series = seriesCopies;
    resolveAxisAliases(options2);
    this.applyDefaults(options2, themeOptions);
    if (options2.seriesColors === null) {
      delete options2.seriesColors;
    }
    if (isString$2(options2.title)) {
      options2.title = { text: options2.title };
    }
    this.options = deepExtend({}, themeOptions, options2);
    this.applySeriesColors();
  };
  Chart2.prototype.getSize = function getSize() {
    var chartArea = this.options.chartArea || {};
    var width = chartArea.width ? parseInt(chartArea.width, 10) : Math.floor(this.element.offsetWidth);
    var height = chartArea.height ? parseInt(chartArea.height, 10) : Math.floor(this.element.offsetHeight);
    return {
      width,
      height
    };
  };
  Chart2.prototype.resize = function resize(force) {
    var size = this.getSize();
    var currentSize = this._size;
    var hasSize = size.width > 0 || size.height > 0;
    if (force || hasSize && (!currentSize || size.width !== currentSize.width || size.height !== currentSize.height)) {
      this._size = size;
      this._resize(size, force);
      this.trigger("resize", size);
    } else if (hasSize && this._selections && find(this._selections, function(s10) {
      return !s10.visible;
    })) {
      this._destroySelections();
      this._setupSelection();
    }
  };
  Chart2.prototype._resize = function _resize() {
    this._noTransitionsRedraw();
  };
  Chart2.prototype.redraw = function redraw(paneName) {
    this.applyDefaults(this.options);
    this.applySeriesColors();
    if (paneName) {
      var plotArea = this._model._plotArea;
      var pane = plotArea.findPane(paneName);
      plotArea.redraw(pane);
    } else {
      this._redraw();
    }
  };
  Chart2.prototype.getAxis = function getAxis(name2) {
    return findAxisByName(name2, this._plotArea.axes);
  };
  Chart2.prototype.findAxisByName = function findAxisByName2(name2) {
    return this.getAxis(name2);
  };
  Chart2.prototype.findPaneByName = function findPaneByName(name2) {
    var panes = this._plotArea.panes;
    for (var idx = 0; idx < panes.length; idx++) {
      if (panes[idx].options.name === name2) {
        return new ChartPane(panes[idx]);
      }
    }
  };
  Chart2.prototype.findPaneByIndex = function findPaneByIndex(idx) {
    var panes = this._plotArea.panes;
    if (panes[idx]) {
      return new ChartPane(panes[idx]);
    }
  };
  Chart2.prototype.plotArea = function plotArea() {
    return new ChartPlotArea(this._plotArea);
  };
  Chart2.prototype.toggleHighlight = function toggleHighlight(show2, filter) {
    var plotArea = this._plotArea;
    var firstSeries = (plotArea.srcSeries || plotArea.series || [])[0];
    var points2;
    if (isFunction$1(filter)) {
      points2 = plotArea.filterPoints(filter);
    } else {
      var seriesName, categoryName;
      if (isObject(filter)) {
        seriesName = filter.series;
        categoryName = filter.category;
      } else {
        seriesName = categoryName = filter;
      }
      if (firstSeries.type === DONUT) {
        points2 = pointByCategoryName(plotArea.pointsBySeriesName(seriesName), categoryName);
      } else if (inArray(firstSeries.type, [PIE, FUNNEL, PYRAMID])) {
        points2 = pointByCategoryName((plotArea.charts[0] || {}).points, categoryName);
      } else {
        points2 = plotArea.pointsBySeriesName(seriesName);
      }
    }
    if (points2) {
      this.togglePointsHighlight(show2, points2);
    }
  };
  Chart2.prototype.togglePointsHighlight = function togglePointsHighlight(show2, points2) {
    var highlight = this._highlight;
    for (var idx = 0; idx < points2.length; idx++) {
      highlight.togglePointHighlight(points2[idx], show2);
    }
  };
  Chart2.prototype.showTooltip = function showTooltip(filter) {
    var shared = this._sharedTooltip();
    var ref2 = this;
    var tooltip = ref2._tooltip;
    var plotArea = ref2._plotArea;
    var point2, categoryIndex;
    if (isFunction$1(filter)) {
      point2 = plotArea.findPoint(filter);
      if (point2 && shared) {
        categoryIndex = point2.categoryIx;
      }
    } else if (shared && defined(filter)) {
      categoryIndex = plotArea.categoryAxis.categoryIndex(filter);
    }
    if (shared) {
      if (categoryIndex >= 0) {
        var points2 = this._plotArea.pointsByCategoryIndex(categoryIndex);
        tooltip.showAt(points2);
      }
    } else if (point2) {
      tooltip.show(point2);
    }
  };
  Chart2.prototype.hideTooltip = function hideTooltip() {
    this._tooltip.hide();
  };
  Chart2.prototype._initSurface = function _initSurface() {
    var surface = this.surface;
    var wrap = this._surfaceWrap();
    var chartArea = this.options.chartArea || {};
    if (chartArea.width) {
      elementSize(wrap, { width: chartArea.width });
    }
    if (chartArea.height) {
      elementSize(wrap, { height: chartArea.height });
    }
    if (!surface || surface.options.type !== this.options.renderAs) {
      this._destroySurface();
      this.surface = Surface$2.create(wrap, {
        type: this.options.renderAs
      });
      this.surface.bind("mouseenter", this._surfaceMouseenterHandler);
      this.surface.bind("mouseleave", this._surfaceMouseleaveHandler);
    } else {
      this.surface.clear();
      this.surface.resize();
    }
    this.element._kendoExportVisual = this._kendoExportVisual.bind(this);
  };
  Chart2.prototype._surfaceWrap = function _surfaceWrap() {
    return this.element;
  };
  Chart2.prototype._redraw = function _redraw() {
    var model = this._getModel();
    this._size = {
      width: model.options.width,
      height: model.options.height
    };
    this._destroyView();
    this._setElementAccessibilityAttributes();
    this._model = model;
    this._plotArea = model._plotArea;
    this._legend = model._legend;
    model.renderVisual();
    if (this.options.transitions !== false) {
      model.traverse(function(element) {
        if (element.animation) {
          element.animation.setup();
        }
      });
    }
    this._initSurface();
    this.surface.draw(model.visual);
    if (this.options.transitions !== false) {
      model.traverse(function(element) {
        if (element.animation) {
          element.animation.play();
        }
      });
    }
    this._tooltip = this._createTooltip();
    this._highlight = new Highlight();
    this._setupSelection();
    this._createPannable();
    this._createZoomSelection();
    this._createMousewheelZoom();
    this.trigger(RENDER);
    triggerPaneRender(this._plotArea.panes);
    if (!this._navState) {
      this._cancelDomEvents();
    }
    this._redrawFocusHighlight();
  };
  Chart2.prototype._redrawFocusHighlight = function _redrawFocusHighlight() {
    var ref2 = this;
    var ref_focusState = ref2._focusState;
    var legendInFocus = ref_focusState.legendInFocus;
    var preserveHighlight = ref_focusState.preserveHighlight;
    if (legendInFocus && preserveHighlight) {
      this._focusElement(this._getFocusedLegendItem(), false);
      this._focusState.preserveHighlight = false;
    }
  };
  Chart2.prototype._setElementAccessibilityAttributes = function _setElementAccessibilityAttributes() {
    var titleOptions = this.options.title;
    var title2 = isString$2(titleOptions) ? titleOptions : titleOptions.description || titleOptions.text;
    if (title2) {
      this.element.setAttribute("aria-roledescription", title2);
    }
  };
  Chart2.prototype._kendoExportVisual = function _kendoExportVisual(size) {
    if (size && size.width && size.height) {
      var chartArea = this._originalOptions.chartArea || {};
      var exportOptions = {
        width: chartArea.width || size.width,
        height: chartArea.height || size.height
      };
      return this.exportVisual(exportOptions);
    }
    return this.exportVisual();
  };
  Chart2.prototype.exportVisual = function exportVisual(exportOptions) {
    var visual;
    if (exportOptions && (exportOptions.width || exportOptions.height || exportOptions.options)) {
      var currentOptions = this.options;
      var options2 = deepExtend({}, exportOptions.options, {
        chartArea: {
          width: exportOptions.width,
          height: exportOptions.height
        }
      });
      clearMissingValues(this._originalOptions, options2);
      this.options = deepExtend({}, this._originalOptions, options2);
      this._initTheme(this.options, this._theme);
      this.bindCategories();
      var model = this._getModel();
      model.renderVisual();
      triggerPaneRender(model._plotArea.panes);
      visual = model.visual;
      this.options = currentOptions;
    } else {
      visual = this.surface.exportVisual();
    }
    return visual;
  };
  Chart2.prototype._sharedTooltip = function _sharedTooltip() {
    return this._plotArea instanceof CategoricalPlotArea && this.options.tooltip && this.options.tooltip.shared;
  };
  Chart2.prototype._createPannable = function _createPannable() {
    var options2 = this.options;
    if (options2.pannable !== false) {
      this._pannable = new Pannable(this._plotArea, options2.pannable);
    }
  };
  Chart2.prototype._createZoomSelection = function _createZoomSelection() {
    var zoomable = this.options.zoomable;
    var selection = (zoomable || {}).selection;
    if (zoomable !== false && selection !== false) {
      this._zoomSelection = new ZoomSelection(this, selection);
    }
  };
  Chart2.prototype._createMousewheelZoom = function _createMousewheelZoom() {
    var zoomable = this.options.zoomable;
    var mousewheel = (zoomable || {}).mousewheel;
    if (zoomable !== false && mousewheel !== false) {
      this._mousewheelZoom = new MousewheelZoom(this, mousewheel);
    }
  };
  Chart2.prototype._toggleDragZoomEvents = function _toggleDragZoomEvents() {
    var pannable = this.options.pannable;
    var zoomable = this.options.zoomable;
    var selection = (zoomable || {}).selection;
    var mousewheel = (zoomable || {}).mousewheel;
    var allowDrag = !pannable && (zoomable === false || selection === false) && !this.requiresHandlers([DRAG_START, DRAG, DRAG_END]);
    var allowZoom = (zoomable === false || mousewheel === false) && !this.requiresHandlers([ZOOM_START, ZOOM, ZOOM_END]);
    var element = this.element;
    if (this._dragZoomEnabled && allowDrag && allowZoom) {
      element.style.touchAction = this._touchAction || "";
      this._dragZoomEnabled = false;
    } else if (!this._dragZoomEnabled && !(allowDrag && allowZoom)) {
      element.style.touchAction = "none";
      this._dragZoomEnabled = true;
    }
    this._toggleDomEvents(!allowDrag, !allowZoom);
  };
  Chart2.prototype._toggleDomEvents = function _toggleDomEvents(drag, zoom) {
    var domEvents = this.domEvents;
    if (!domEvents) {
      return;
    }
    if (domEvents.toggleDrag) {
      domEvents.toggleDrag(drag);
    }
    if (domEvents.toggleZoom) {
      domEvents.toggleZoom(zoom);
    }
  };
  Chart2.prototype._createTooltip = function _createTooltip() {
    var ref2 = this;
    var tooltipOptions = ref2.options.tooltip;
    var tooltip;
    if (this._sharedTooltip()) {
      tooltip = this._createSharedTooltip(tooltipOptions);
    } else {
      tooltip = new Tooltip$1(this.chartService, tooltipOptions);
    }
    return tooltip;
  };
  Chart2.prototype._createSharedTooltip = function _createSharedTooltip(options2) {
    return new SharedTooltip$1(this._plotArea, options2);
  };
  Chart2.prototype.applyDefaults = function applyDefaults2(options2, themeOptions) {
    applyAxisDefaults(options2, themeOptions);
    applySeriesDefaults(options2, themeOptions);
  };
  Chart2.prototype.applySeriesColors = function applySeriesColors() {
    var options2 = this.options;
    var series = options2.series;
    var colors = options2.seriesColors || [];
    for (var i16 = 0; i16 < series.length; i16++) {
      var currentSeries = series[i16];
      var seriesColor = colors[i16 % colors.length];
      var defaults = currentSeries._defaults;
      currentSeries.color = currentSeries.color || seriesColor;
      if (defaults) {
        defaults.color = defaults.color || seriesColor;
      }
    }
  };
  Chart2.prototype._getModel = function _getModel() {
    var options2 = this.options;
    var plotArea = this._createPlotArea();
    var model = new RootElement(this._modelOptions());
    model.chart = this;
    model._plotArea = plotArea;
    var title2 = Title$1.buildTitle(options2.title);
    var subtitle2 = Title$1.buildTitle(options2.subtitle, {
      align: options2.title.align,
      position: options2.title.position
    });
    model.append.apply(model, Title$1.orderTitles([title2, subtitle2]));
    if (options2.legend && options2.legend.visible) {
      var legend2 = new Legend$1(plotArea.options.legend, this.chartService);
      model.append(legend2);
      model._legend = legend2;
    }
    model.append(plotArea);
    model.reflow();
    return model;
  };
  Chart2.prototype._modelOptions = function _modelOptions() {
    var options2 = this.options;
    var size = this.getSize();
    return deepExtend({
      transitions: options2.transitions,
      width: size.width || DEFAULT_WIDTH$1,
      height: size.height || DEFAULT_HEIGHT$1
    }, options2.chartArea);
  };
  Chart2.prototype._createPlotArea = function _createPlotArea(skipSeries) {
    var options2 = this.options;
    var plotArea = PlotAreaFactory.current.create(skipSeries ? [] : options2.series, options2, this.chartService);
    return plotArea;
  };
  Chart2.prototype._setupSelection = function _setupSelection() {
    var this$1$1 = this;
    var ref2 = this;
    var axes = ref2._plotArea.axes;
    var selections = this._selections = [];
    for (var i16 = 0; i16 < axes.length; i16++) {
      var axis = axes[i16];
      var options2 = axis.options;
      if (axis instanceof CategoryAxis && options2.select && !options2.vertical) {
        var range = axis.range();
        var selection = new Selection(
          this$1$1,
          axis,
          deepExtend({ min: range.min, max: range.max }, options2.select)
        );
        selections.push(selection);
      }
    }
  };
  Chart2.prototype._selectStart = function _selectStart(e3) {
    return this.trigger(SELECT_START, e3);
  };
  Chart2.prototype._select = function _select(e3) {
    return this.trigger(SELECT, e3);
  };
  Chart2.prototype._selectEnd = function _selectEnd(e3) {
    return this.trigger(SELECT_END, e3);
  };
  Chart2.prototype._initHandlers = function _initHandlers() {
    this._clickHandler = this._click.bind(this);
    this._keydownHandler = this._keydown.bind(this);
    this._focusHandler = this._focus.bind(this);
    this._blurHandler = this._blur.bind(this);
    this._mousedownHandler = this._mousedown.bind(this);
    this._mousewheelHandler = this._mousewheel.bind(this);
    this._mouseleaveHandler = this._mouseleave.bind(this);
    this._surfaceMouseenterHandler = this._mouseover.bind(this);
    this._surfaceMouseleaveHandler = this._mouseout.bind(this);
    this._mousemove = throttle(
      this._mousemove.bind(this),
      MOUSEMOVE_DELAY
    );
  };
  Chart2.prototype.addObserver = function addObserver(observer) {
    if (observer) {
      this.observers.push(observer);
    }
  };
  Chart2.prototype.removeObserver = function removeObserver(observer) {
    var index2 = this.observers.indexOf(observer);
    if (index2 >= 0) {
      this.observers.splice(index2, 1);
    }
  };
  Chart2.prototype.requiresHandlers = function requiresHandlers2(eventNames) {
    var observers2 = this.observers;
    for (var idx = 0; idx < observers2.length; idx++) {
      if (observers2[idx].requiresHandlers(eventNames)) {
        return true;
      }
    }
  };
  Chart2.prototype.trigger = function trigger2(name2, args) {
    if (args === void 0)
      args = {};
    args.sender = this;
    if (name2 === SHOW_TOOLTIP$1) {
      args.anchor.point = this._toDocumentCoordinates(args.anchor.point);
    } else if (name2 === SERIES_OVER) {
      this._updateDrilldownPoint(args.point);
    } else if (name2 === SERIES_LEAVE) {
      this._resetDrilldownPoint();
    } else if (name2 === SERIES_CLICK) {
      this._focusPoint(args.point);
      this._startDrilldown(args.point);
    } else if (name2 === LEGEND_ITEM_CLICK) {
      this._focusLegendItem(args);
    }
    var observers2 = this.observers;
    var isDefaultPrevented2 = false;
    for (var idx = 0; idx < observers2.length; idx++) {
      if (observers2[idx].trigger(name2, args)) {
        isDefaultPrevented2 = true;
      }
    }
    return isDefaultPrevented2;
  };
  Chart2.prototype._attachEvents = function _attachEvents() {
    var obj, obj$1;
    var element = this.element;
    this._touchAction = element.style.touchAction;
    bindEvents(element, (obj = {}, obj[CONTEXTMENU] = this._clickHandler, obj[MOUSEWHEEL$1] = this._mousewheelHandler, obj[MOUSELEAVE] = this._mouseleaveHandler, obj[KEYDOWN] = this._keydownHandler, obj[MOUSEDOWN] = this._mousedownHandler, obj[FOCUS] = this._focusHandler, obj[BLUR] = this._blurHandler, obj));
    if (this._shouldAttachMouseMove()) {
      bindEvents(element, (obj$1 = {}, obj$1[MOUSEMOVE] = this._mousemove, obj$1));
    }
    this.domEvents = DomEventsBuilder.create(this.element, {
      start: this._start.bind(this),
      move: this._move.bind(this),
      end: this._end.bind(this),
      tap: this._tap.bind(this),
      gesturestart: this._gesturestart.bind(this),
      gesturechange: this._gesturechange.bind(this),
      gestureend: this._gestureend.bind(this)
    });
    this._toggleDragZoomEvents();
  };
  Chart2.prototype._mouseleave = function _mouseleave2(e3) {
    if (this._hoveredPoint) {
      this._hoveredPoint.out(this, e3);
      this._hoveredPoint = null;
    }
    if (this._plotAreaHovered) {
      this._plotAreaHovered = false;
      this.trigger(PLOT_AREA_LEAVE);
    }
    if (this._hasInactiveOpacity() && this._activeChartInstance) {
      this._applySeriesOpacity(this._activeChartInstance.children, null, true);
      this._updateSeriesOpacity(null, true);
    }
  };
  Chart2.prototype._cancelDomEvents = function _cancelDomEvents() {
    if (this.domEvents && this.domEvents.cancel) {
      this.domEvents.cancel();
    }
  };
  Chart2.prototype._gesturestart = function _gesturestart(e3) {
    if (this._mousewheelZoom && !this._stopChartHandlers(e3)) {
      this._gestureDistance = e3.distance;
      this._unsetActivePoint();
      this._clearFocusedElement();
      this.surface.suspendTracking();
    }
  };
  Chart2.prototype._gestureend = function _gestureend(e3) {
    if (this._zooming && !this._stopChartHandlers(e3)) {
      if (this.surface) {
        this.surface.resumeTracking();
      }
      this._zooming = false;
      this.trigger(ZOOM_END, {});
    }
  };
  Chart2.prototype._gesturechange = function _gesturechange(e3) {
    var mousewheelZoom = this._mousewheelZoom;
    if (mousewheelZoom && !this._stopChartHandlers(e3)) {
      e3.preventDefault();
      var previousGestureDistance = this._gestureDistance;
      var scaleDelta = -e3.distance / previousGestureDistance + 1;
      if (Math.abs(scaleDelta) >= 0.1) {
        scaleDelta = Math.round(scaleDelta * 10);
        this._gestureDistance = e3.distance;
        var args = { delta: scaleDelta, axisRanges: axisRanges(this._plotArea.axes), originalEvent: e3 };
        if (this._zooming || !this.trigger(ZOOM_START, args)) {
          var coords = this._eventCoordinates(e3);
          if (!this._zooming) {
            this._zooming = true;
          }
          var ranges = args.axisRanges = mousewheelZoom.updateRanges(scaleDelta, coords);
          if (ranges && !this.trigger(ZOOM, args)) {
            mousewheelZoom.zoom();
          }
        }
      }
    }
  };
  Chart2.prototype._mouseout = function _mouseout(e3) {
    if (e3.element) {
      var element = this._drawingChartElement(e3.element, e3);
      if (element && element.leave) {
        element.leave(this, e3.originalEvent);
      }
    }
  };
  Chart2.prototype._start = function _start(e3) {
    var coords = this._eventCoordinates(e3);
    if (this._stopChartHandlers(e3) || !this._plotArea.backgroundContainsPoint(coords)) {
      return;
    }
    if (this.requiresHandlers([DRAG_START, DRAG, DRAG_END])) {
      this._startNavigation(e3, coords, DRAG_START);
    }
    if (this._pannable && this._pannable.start(e3)) {
      this.surface.suspendTracking();
      this._unsetActivePoint();
      this._clearFocusedElement();
      this._suppressHover = true;
      this.chartService.panning = true;
    }
    if (this._zoomSelection) {
      if (this._zoomSelection.start(e3)) {
        this.trigger(ZOOM_START, { axisRanges: axisRanges(this._plotArea.axes), originalEvent: e3 });
      }
    }
  };
  Chart2.prototype._move = function _move(e3) {
    var ref2 = this;
    var state = ref2._navState;
    var pannable = ref2._pannable;
    if (this._stopChartHandlers(e3)) {
      return;
    }
    if (pannable) {
      var ranges = pannable.move(e3);
      if (ranges && !this.trigger(DRAG, { axisRanges: ranges, originalEvent: e3 })) {
        pannable.pan();
      }
    } else if (state) {
      var ranges$1 = {};
      var axes = state.axes;
      for (var i16 = 0; i16 < axes.length; i16++) {
        var currentAxis = axes[i16];
        var axisName = currentAxis.options.name;
        if (axisName) {
          var axis = currentAxis.options.vertical ? e3.y : e3.x;
          var delta = axis.startLocation - axis.location;
          if (delta !== 0) {
            ranges$1[currentAxis.options.name] = currentAxis.translateRange(delta);
          }
        }
      }
      state.axisRanges = ranges$1;
      this.trigger(DRAG, {
        axisRanges: ranges$1,
        originalEvent: e3
      });
    }
    if (this._zoomSelection) {
      this._zoomSelection.move(e3);
    }
  };
  Chart2.prototype._end = function _end(e3) {
    if (this._stopChartHandlers(e3)) {
      return;
    }
    var pannable = this._pannable;
    if (pannable && pannable.end(e3)) {
      this.surface.resumeTracking();
      this.trigger(DRAG_END, {
        axisRanges: axisRanges(this._plotArea.axes),
        originalEvent: e3
      });
      this._suppressHover = false;
      this.chartService.panning = false;
    } else {
      this._endNavigation(e3, DRAG_END);
    }
    if (this._zoomSelection) {
      var ranges = this._zoomSelection.end(e3);
      if (ranges && !this.trigger(ZOOM, { axisRanges: ranges, originalEvent: e3 })) {
        this._zoomSelection.zoom();
        this.trigger(ZOOM_END, { axisRanges: ranges, originalEvent: e3 });
      }
    }
  };
  Chart2.prototype._stopChartHandlers = function _stopChartHandlers(e3) {
    var selections = this._selections || [];
    if (!selections.length) {
      return false;
    }
    var coords = this._eventCoordinates(e3);
    var pane = this._plotArea.paneByPoint(coords);
    if (pane) {
      for (var idx = 0; idx < selections.length; idx++) {
        if (selections[idx].onPane(pane)) {
          return true;
        }
      }
    }
  };
  Chart2.prototype._mousewheelZoomRate = function _mousewheelZoomRate() {
    var zoomable = this.options.zoomable;
    var mousewheel = (zoomable || {}).mousewheel || {};
    return valueOrDefault$1(mousewheel.rate, MOUSEWHEEL_ZOOM_RATE);
  };
  Chart2.prototype._mousewheel = function _mousewheel(e3) {
    var this$1$1 = this;
    var delta = mousewheelDelta(e3);
    var mousewheelZoom = this._mousewheelZoom;
    var coords = this._eventCoordinates(e3);
    if (this._stopChartHandlers(e3) || !this._plotArea.backgroundContainsPoint(coords)) {
      return;
    }
    if (mousewheelZoom) {
      var args = { delta, axisRanges: axisRanges(this._plotArea.axes), originalEvent: e3 };
      if (this._zooming || !this.trigger(ZOOM_START, args)) {
        e3.preventDefault();
        if (!this._zooming) {
          this._unsetActivePoint();
          this._clearFocusedElement();
          this.surface.suspendTracking();
          this._zooming = true;
        }
        if (this._mwTimeout) {
          clearTimeout(this._mwTimeout);
        }
        args.axisRanges = mousewheelZoom.updateRanges(delta, coords);
        if (args.axisRanges && !this.trigger(ZOOM, args)) {
          mousewheelZoom.zoom();
        }
        this._mwTimeout = setTimeout(function() {
          this$1$1.trigger(ZOOM_END, args);
          this$1$1._zooming = false;
          if (this$1$1.surface) {
            this$1$1.surface.resumeTracking();
          }
        }, MOUSEWHEEL_DELAY);
      }
    } else {
      var state = this._navState;
      if (!state) {
        var prevented = this._startNavigation(e3, coords, ZOOM_START);
        if (!prevented) {
          state = this._navState;
        }
      }
      if (state) {
        var totalDelta = state.totalDelta || delta;
        state.totalDelta = totalDelta + delta;
        var axes = this._navState.axes;
        var ranges = {};
        for (var i16 = 0; i16 < axes.length; i16++) {
          var currentAxis = axes[i16];
          var axisName = currentAxis.options.name;
          if (axisName) {
            ranges[axisName] = currentAxis.scaleRange(-totalDelta * this$1$1._mousewheelZoomRate(), coords);
          }
        }
        this.trigger(ZOOM, {
          delta,
          axisRanges: ranges,
          originalEvent: e3
        });
        if (this._mwTimeout) {
          clearTimeout(this._mwTimeout);
        }
        this._mwTimeout = setTimeout(function() {
          this$1$1._endNavigation(e3, ZOOM_END);
        }, MOUSEWHEEL_DELAY);
      }
    }
  };
  Chart2.prototype._startNavigation = function _startNavigation(e3, coords, chartEvent) {
    var plotArea = this._model._plotArea;
    var pane = plotArea.findPointPane(coords);
    var axes = plotArea.axes.slice(0);
    if (!pane) {
      return;
    }
    var ranges = axisRanges(axes);
    var prevented = this.trigger(chartEvent, {
      axisRanges: ranges,
      originalEvent: e3
    });
    if (prevented) {
      this._cancelDomEvents();
    } else {
      this._suppressHover = true;
      this._unsetActivePoint();
      this._clearFocusedElement();
      this._navState = {
        axisRanges: ranges,
        pane,
        axes
      };
    }
  };
  Chart2.prototype._endNavigation = function _endNavigation(e3, chartEvent) {
    if (this._navState) {
      this.trigger(chartEvent, {
        axisRanges: this._navState.axisRanges,
        originalEvent: e3
      });
      this._suppressHover = false;
      this._navState = null;
    }
  };
  Chart2.prototype._getChartElement = function _getChartElement(e3, match2) {
    var element = this.surface.eventTarget(e3);
    if (element) {
      return this._drawingChartElement(element, e3, match2);
    }
  };
  Chart2.prototype._drawingChartElement = function _drawingChartElement(element, e3, match2) {
    var current2 = element;
    var chartElement;
    while (current2 && !chartElement) {
      chartElement = current2.chartElement;
      current2 = current2.parent;
    }
    if (chartElement) {
      if (chartElement.aliasFor) {
        chartElement = chartElement.aliasFor(e3, this._eventCoordinates(e3));
      }
      if (match2) {
        chartElement = chartElement.closest(match2);
        if (chartElement && chartElement.aliasFor) {
          chartElement = chartElement.aliasFor();
        }
      }
      return chartElement;
    }
  };
  Chart2.prototype._eventCoordinates = function _eventCoordinates(e3) {
    var coordinates = eventCoordinates(e3);
    return this._toModelCoordinates(coordinates.x, coordinates.y);
  };
  Chart2.prototype._elementPadding = function _elementPadding() {
    if (!this._padding) {
      var ref2 = elementStyles(this.element, ["paddingLeft", "paddingTop"]);
      var paddingLeft = ref2.paddingLeft;
      var paddingTop = ref2.paddingTop;
      this._padding = {
        top: paddingTop,
        left: paddingLeft
      };
    }
    return this._padding;
  };
  Chart2.prototype._toDocumentCoordinates = function _toDocumentCoordinates(point2) {
    var padding = this._elementPadding();
    var offset2 = elementOffset(this.element);
    return {
      left: round$1(point2.x + padding.left + offset2.left),
      top: round$1(point2.y + padding.top + offset2.top)
    };
  };
  Chart2.prototype._toModelCoordinates = function _toModelCoordinates(clientX, clientY) {
    var element = this.element;
    var offset2 = elementOffset(element);
    var padding = this._elementPadding();
    var inverseTransform = elementScale(element).invert();
    var point2 = new Point$7(
      clientX - offset2.left - padding.left,
      clientY - offset2.top - padding.top
    ).transform(inverseTransform);
    return new Point$5(point2.x, point2.y);
  };
  Chart2.prototype._tap = function _tap(e3) {
    var this$1$1 = this;
    var drawingElement = this.surface.eventTarget(e3);
    var element = this._drawingChartElement(drawingElement, e3);
    var sharedTooltip = this._sharedTooltip();
    if (!this._startHover(drawingElement, e3) && !sharedTooltip) {
      this._unsetActivePoint();
    }
    if (sharedTooltip) {
      this._trackSharedTooltip(this._eventCoordinates(e3), e3, true);
    }
    this._propagateClick(element, e3);
    this.handlingTap = true;
    setTimeout(function() {
      this$1$1.handlingTap = false;
    }, 0);
  };
  Chart2.prototype._click = function _click(e3) {
    var element = this._getChartElement(e3);
    this._propagateClick(element, e3);
  };
  Chart2.prototype._propagateClick = function _propagateClick(element, e3) {
    var this$1$1 = this;
    var current2 = element;
    while (current2) {
      if (current2.click) {
        current2.click(this$1$1, e3);
      }
      current2 = current2.parent;
    }
  };
  Chart2.prototype._isLegendBeforeChart = function _isLegendBeforeChart() {
    var ref2 = this;
    var legendPosition = ref2.options.legend.position;
    var legend2 = ref2._legend;
    return legend2 && legend2.hasItems() && (legendPosition === TOP || legendPosition === LEFT);
  };
  Chart2.prototype._focus = function _focus() {
    if (!this._preventInitialPointFocus) {
      if (this._isLegendBeforeChart()) {
        this._focusFirstLegendItem();
      } else {
        this._focusFirstPoint();
      }
    }
    this._preventInitialPointFocus = false;
  };
  Chart2.prototype._keydown = function _keydown(e3) {
    var ref2 = this;
    var ref_focusState = ref2._focusState;
    var legendInFocus = ref_focusState.legendInFocus;
    var focusedElement = ref_focusState.focusedElement;
    var legend2 = ref2._legend;
    if (e3.key === TAB) {
      this._clearFocusedElement();
      var isLegendBeforeChart = this._isLegendBeforeChart();
      if (legendInFocus && isLegendBeforeChart !== e3.shiftKey) {
        this._navigatePoints(e3);
      } else if (!legendInFocus && isLegendBeforeChart === e3.shiftKey && legend2.hasItems()) {
        this._navigateLegend(e3);
      }
    } else if (e3.key === ESCAPE) {
      if (focusedElement) {
        e3.stopPropagation();
      }
      if (this._tooltip && this._tooltip.visible) {
        this._hideTooltip();
      } else {
        this._blur();
      }
    } else if (e3.key === ENTER) {
      if (focusedElement) {
        this._focusState.preserveHighlight = true;
        this._propagateClick(focusedElement, e3);
        this._focusElement(focusedElement);
      }
    } else if (!legendInFocus) {
      this._navigatePoints(e3);
    } else {
      this._navigateLegend(e3);
    }
  };
  Chart2.prototype._navigatePoints = function _navigatePoints(e3) {
    var this$1$1 = this;
    var ref2 = this;
    var focusState = ref2._focusState;
    var plotArea = ref2._plotArea;
    focusState.legendInFocus = false;
    if (!focusState.focusedElement) {
      this._focusFirstPoint();
      e3.preventDefault();
      return;
    }
    var moveFocus = function(point2) {
      focusState.focusedPoint = point2;
      this$1$1._focusElement(focusState.focusedPoint);
      this$1$1._displayTooltip(point2);
      e3.preventDefault();
    };
    switch (e3.key) {
      case ARROW_RIGHT:
        moveFocus(plotArea.getPointToTheRight(focusState.focusedPoint));
        break;
      case ARROW_LEFT:
        moveFocus(plotArea.getPointToTheLeft(focusState.focusedPoint));
        break;
      case ARROW_DOWN:
        moveFocus(plotArea.getPointBelow(focusState.focusedPoint));
        break;
      case ARROW_UP:
        moveFocus(plotArea.getPointAbove(focusState.focusedPoint));
        break;
    }
  };
  Chart2.prototype._navigateLegend = function _navigateLegend(e3) {
    var this$1$1 = this;
    var ref2 = this;
    var focusState = ref2._focusState;
    var legend2 = ref2._legend;
    var rtl = ref2.chartService.rtl;
    focusState.legendInFocus = true;
    if (!focusState.focusedElement) {
      this._focusFirstLegendItem();
      e3.preventDefault();
      return;
    }
    var itemsLength = legend2.getItems().length;
    var moveFocus = function(cycleFunc) {
      focusState.focusedLegendItemIndex = cycleFunc(
        focusState.focusedLegendItemIndex,
        itemsLength
      );
      this$1$1._focusElement(this$1$1._getFocusedLegendItem());
      e3.preventDefault();
    };
    switch (e3.key) {
      case ARROW_UP:
      case ARROW_LEFT:
        moveFocus(rtl ? cycleUp : cycleDown);
        break;
      case ARROW_DOWN:
      case ARROW_RIGHT:
        moveFocus(rtl ? cycleDown : cycleUp);
        break;
    }
  };
  Chart2.prototype._focusFirstPoint = function _focusFirstPoint() {
    var point2 = this._focusState.focusedPoint = this._plotArea.getFirstPoint();
    if (point2) {
      this._focusElement(point2);
      this._displayTooltip(point2);
    }
  };
  Chart2.prototype._hasFocus = function _hasFocus() {
    return this.element.ownerDocument.activeElement === this.element;
  };
  Chart2.prototype._mousedown = function _mousedown() {
    if (!this._hasFocus()) {
      this._preventInitialPointFocus = true;
    }
  };
  Chart2.prototype._focusChart = function _focusChart() {
    if (!this._hasFocus()) {
      this._preventInitialPointFocus = true;
      this.element.focus();
    }
  };
  Chart2.prototype._focusPoint = function _focusPoint(point2) {
    this._focusState.focusedPoint = point2;
    this._focusChart();
    this._focusElement(point2, true);
  };
  Chart2.prototype._focusFirstLegendItem = function _focusFirstLegendItem() {
    var ref2 = this;
    var focusState = ref2._focusState;
    focusState.focusedLegendItemIndex = 0;
    this._focusElement(this._getFocusedLegendItem());
    focusState.legendInFocus = true;
    this._hideTooltip();
  };
  Chart2.prototype._focusLegendItem = function _focusLegendItem(args) {
    var ref2 = this;
    var focusState = ref2._focusState;
    focusState.focusedLegendItemIndex = this._legend.getItems().findIndex(function(x3) {
      return x3.options.series.index === args.seriesIndex && x3.options.pointIndex === args.pointIndex;
    });
    focusState.legendInFocus = true;
    this._focusChart();
    this._focusElement(this._getFocusedLegendItem(), true);
  };
  Chart2.prototype._getFocusedLegendItem = function _getFocusedLegendItem() {
    var ref2 = this;
    var focusState = ref2._focusState;
    var legend2 = ref2._legend;
    return legend2.getItems()[focusState.focusedLegendItemIndex];
  };
  Chart2.prototype._focusElement = function _focusElement(element, omitHighlight) {
    var ref2 = this;
    var focusState = ref2._focusState;
    this._clearFocusedElement();
    if (!element) {
      return;
    }
    focusState.focusedElement = element;
    this._setElementActiveDescendant(element);
    if (!omitHighlight) {
      element.focusVisual();
      if (focusState.legendInFocus) {
        var options2 = element.options;
        this._showSeriesInactiveOpacity(options2.series.index, options2.pointIndex);
      } else {
        this._showInactiveOpacity(element);
      }
    }
  };
  Chart2.prototype._clearFocusedElement = function _clearFocusedElement() {
    var ref2 = this;
    var focusState = ref2._focusState;
    if (!focusState) {
      return;
    }
    if (focusState.focusedElement) {
      focusState.focusedElement.clearFocusFromVisual();
      this._clearElementActiveDescendant();
    }
    focusState.focusedElement = null;
  };
  Chart2.prototype._setElementActiveDescendant = function _setElementActiveDescendant(element) {
    if (this.options.renderAs === "canvas") {
      this._pseudoFocusedElement = this._createPseudoFocusedElement(element);
      this.element.append(this._pseudoFocusedElement);
    }
    this.element.setAttribute(ARIA_ACTIVE_DESCENDANT, element._id);
  };
  Chart2.prototype._clearElementActiveDescendant = function _clearElementActiveDescendant() {
    if (this._pseudoFocusedElement) {
      this._pseudoFocusedElement.remove();
      this._pseudoFocusedElement = null;
    }
    this.element.removeAttribute(ARIA_ACTIVE_DESCENDANT);
  };
  Chart2.prototype._createPseudoFocusedElement = function _createPseudoFocusedElement(element) {
    var pseudoElement = document.createElement("div");
    var accessibilityOptions = element.options.accessibility;
    pseudoElement.id = element._id;
    pseudoElement.setAttribute("aria-label", element.getAriaLabelText());
    pseudoElement.setAttribute("role", accessibilityOptions.role);
    pseudoElement.setAttribute("aria-roledescription", accessibilityOptions.ariaRoleDescription);
    var checked = accessibilityOptions.ariaChecked;
    if (defined(checked)) {
      pseudoElement.setAttribute("aria-checked", checked);
    }
    return pseudoElement;
  };
  Chart2.prototype._blur = function _blur() {
    this._focusState.legendInFocus = false;
    this._clearFocusedElement();
    this._hideInactiveOpacity();
  };
  Chart2.prototype._startHover = function _startHover(element, e3) {
    if (this._suppressHover) {
      return false;
    }
    var point2 = this._drawingChartElement(element, e3, function(element2) {
      return (element2.hover || element2.over) && !(element2 instanceof PlotAreaBase);
    });
    var activePoint = this._activePoint;
    this._updateHoveredPoint(point2, e3);
    if (point2 && activePoint !== point2 && point2.hover) {
      this._activePoint = point2;
      if (!this._sharedTooltip() && !point2.hover(this, e3)) {
        this._displayTooltip(point2);
        this._showInactiveOpacity(point2);
      }
    }
    return point2;
  };
  Chart2.prototype._displayTooltip = function _displayTooltip(point2) {
    var tooltipOptions = deepExtend({}, this.options.tooltip, point2.options.tooltip);
    if (tooltipOptions.visible) {
      this._tooltip.show(point2);
    }
  };
  Chart2.prototype._hideTooltip = function _hideTooltip() {
    if (this._tooltip) {
      this._tooltip.hide();
    }
  };
  Chart2.prototype._displayInactiveOpacity = function _displayInactiveOpacity(activePoint, multipleSeries, highlightPoints) {
    var chartInstance = this._activeChartInstance = this._chartInstanceFromPoint(activePoint);
    if (!chartInstance) {
      return;
    }
    if (multipleSeries) {
      this._updateSeriesOpacity(activePoint);
      this._applySeriesOpacity(chartInstance.children, null, true);
      this._applySeriesOpacity(chartInstance.children, activePoint.series);
      this._highlight.show(highlightPoints || activePoint);
    } else {
      var inactivePoints;
      if (!chartInstance.supportsPointInactiveOpacity()) {
        this._highlight.show(activePoint);
        return;
      }
      inactivePoints = this._getInactivePoints(activePoint, chartInstance);
      if (inactivePoints && inactivePoints.length) {
        this._highlight.show(inactivePoints, 1 - this._getInactiveOpacityForSeries(activePoint.series));
      }
    }
  };
  Chart2.prototype._getInactivePoints = function _getInactivePoints(activePoint, chartInstance) {
    var allPoints = this._getAllPointsOfType(chartInstance, activePoint.constructor);
    return allPoints.filter(function(point2) {
      return point2 !== activePoint;
    });
  };
  Chart2.prototype._getAllPointsOfType = function _getAllPointsOfType(container, type) {
    var this$1$1 = this;
    var points2 = [];
    for (var i16 = 0; i16 < container.children.length; i16++) {
      var element = container.children[i16];
      if (element.constructor === type) {
        points2.push(element);
      } else if (element.children && element.children.length) {
        points2 = points2.concat(this$1$1._getAllPointsOfType(element, type));
      }
    }
    return points2;
  };
  Chart2.prototype._updateHoveredPoint = function _updateHoveredPoint(point2, e3) {
    var hoveredPoint = this._hoveredPoint;
    if (hoveredPoint && hoveredPoint !== point2) {
      hoveredPoint.out(this, e3);
      this._hoveredPoint = null;
    }
    if (point2 && hoveredPoint !== point2 && point2.over) {
      this._hoveredPoint = point2;
      point2.over(this, e3);
    }
  };
  Chart2.prototype._updateDrilldownPoint = function _updateDrilldownPoint(point2) {
    if (!point2 || !point2.series) {
      return;
    }
    var ref2 = SeriesBinder.current.bindPoint(point2.series, null, point2.dataItem);
    var fields = ref2.fields;
    if (fields.drilldown) {
      this._drilldownState = { cursor: this.element.style.cursor };
      this.element.style.cursor = "pointer";
    }
  };
  Chart2.prototype._resetDrilldownPoint = function _resetDrilldownPoint() {
    if (this._drilldownState) {
      this.element.style.cursor = this._drilldownState.cursor;
      this._drilldownState = null;
    }
  };
  Chart2.prototype._startDrilldown = function _startDrilldown(point2) {
    if (!point2 || !point2.series) {
      return;
    }
    var series = point2.series;
    var ref2 = SeriesBinder.current.bindPoint(series, null, point2.dataItem);
    var fields = ref2.fields;
    var value2 = fields.drilldown;
    if (value2) {
      var args = { series, point: point2, value: value2, sender: this };
      this.trigger(DRILLDOWN, args);
    }
  };
  Chart2.prototype._updateSeriesOpacity = function _updateSeriesOpacity(point2, resetOpacity) {
    var this$1$1 = this;
    var plotArea = this._plotArea;
    var length = plotArea.series.length;
    for (var i16 = 0; i16 < length; i16++) {
      var currSeries = plotArea.series[i16];
      var defaultOpacity = this$1$1._getDefaultOpacityForSeries(currSeries);
      var inactiveOpacity = this$1$1._getInactiveOpacityForSeries(currSeries);
      if (!resetOpacity && currSeries !== point2.series) {
        currSeries.defaultOpacity = defaultOpacity;
        currSeries.opacity = inactiveOpacity;
        if (currSeries.line) {
          currSeries.line.opacity = inactiveOpacity;
        }
      } else {
        currSeries.opacity = defaultOpacity;
        if (currSeries.line) {
          currSeries.line.opacity = defaultOpacity;
        }
      }
    }
  };
  Chart2.prototype._applySeriesOpacity = function _applySeriesOpacity(elements, activeSeries, reset, series) {
    var this$1$1 = this;
    for (var i16 = 0; i16 < elements.length; i16++) {
      var element = elements[i16];
      var currSeries = element.series || series;
      var shouldHighlight = currSeries && (currSeries.highlight || {}).visible;
      if (shouldHighlight && element.visual) {
        var opacity = series ? series.opacity : element.series.opacity;
        if (currSeries !== activeSeries || reset) {
          element.visual.opacity(reset ? 1 : opacity);
        }
      }
      if (element.children && element.children.length) {
        this$1$1._applySeriesOpacity(element.children, activeSeries, reset, element.series);
      }
    }
  };
  Chart2.prototype._chartInstanceFromPoint = function _chartInstanceFromPoint(point2) {
    var chartInstance = point2.parent;
    while (chartInstance && !chartInstance.plotArea) {
      chartInstance = chartInstance.parent;
    }
    return chartInstance;
  };
  Chart2.prototype._showInactiveOpacity = function _showInactiveOpacity(point2) {
    var multipleSeries = this._plotArea.series.length > 1;
    var hasInactiveOpacity = this._hasInactiveOpacity();
    if (hasInactiveOpacity) {
      this._displayInactiveOpacity(point2, multipleSeries);
    } else {
      this._highlight.show(point2);
    }
  };
  Chart2.prototype._hideInactiveOpacity = function _hideInactiveOpacity(point2) {
    var multipleSeries = this._plotArea.series.length > 1;
    var hasInactiveOpacity = this._hasInactiveOpacity();
    if (hasInactiveOpacity) {
      if (multipleSeries && this._activeChartInstance) {
        this._updateSeriesOpacity(point2, true);
        this._applySeriesOpacity(this._activeChartInstance.children, null, true);
        this._activeChartInstance = null;
      }
      this._highlight && this._highlight.hide();
      this._activePoint = null;
    }
  };
  Chart2.prototype._hasInactiveOpacity = function _hasInactiveOpacity() {
    var hasDefaultInactiveOpacity = this.options.seriesDefaults.highlight.inactiveOpacity !== void 0;
    var hasInactiveOpacity = this.options.series.filter(function(s10) {
      return s10.highlight.inactiveOpacity !== void 0;
    }).length > 0;
    return hasDefaultInactiveOpacity || hasInactiveOpacity;
  };
  Chart2.prototype._getInactiveOpacityForSeries = function _getInactiveOpacityForSeries(series) {
    var defaultInactiveOpacity = this.options.seriesDefaults.highlight.inactiveOpacity;
    var seriesInactiveOpacity = series.highlight.inactiveOpacity;
    return seriesInactiveOpacity || defaultInactiveOpacity || series.opacity || DEFAULT_SERIES_OPACITY;
  };
  Chart2.prototype._getDefaultOpacityForSeries = function _getDefaultOpacityForSeries(series) {
    return series.defaultOpacity || series.opacity || DEFAULT_SERIES_OPACITY;
  };
  Chart2.prototype._mouseover = function _mouseover(e3) {
    var obj;
    var point2 = this._startHover(e3.element, e3.originalEvent);
    if (point2 && point2.tooltipTracking && !this._mouseMoveTrackHandler && !this._sharedTooltip()) {
      this._mouseMoveTrackHandler = this._mouseMoveTracking.bind(this);
      bindEvents(document, (obj = {}, obj[MOUSEMOVE] = this._mouseMoveTrackHandler, obj));
    }
  };
  Chart2.prototype._mouseMoveTracking = function _mouseMoveTracking(e3) {
    var obj;
    var ref2 = this;
    var options2 = ref2.options;
    var tooltip = ref2._tooltip;
    var highlight = ref2._highlight;
    var point2 = ref2._activePoint;
    var coords = this._eventCoordinates(e3);
    if (this._plotArea.box.containsPoint(coords)) {
      if (point2 && point2.tooltipTracking && point2.series && point2.parent.getNearestPoint) {
        var seriesPoint = point2.parent.getNearestPoint(coords.x, coords.y, point2.seriesIx);
        if (seriesPoint && seriesPoint !== point2) {
          this._activePoint = seriesPoint;
          if (!seriesPoint.hover(this, e3)) {
            var tooltipOptions = deepExtend({}, options2.tooltip, seriesPoint.options.tooltip);
            if (tooltipOptions.visible) {
              tooltip.show(seriesPoint);
            }
            highlight.show(seriesPoint);
          }
        }
      }
    } else {
      unbindEvents(document, (obj = {}, obj[MOUSEMOVE] = this._mouseMoveTrackHandler, obj));
      this._unsetActivePoint();
      this._clearFocusedElement();
      this._mouseMoveTrackHandler = null;
      this._hideInactiveOpacity(point2);
    }
  };
  Chart2.prototype._mousemove = function _mousemove(e3) {
    var coords = this._eventCoordinates(e3);
    var plotArea = this._plotArea;
    this._trackCrosshairs(coords);
    if (plotArea.hover) {
      var overPlotArea = plotArea.backgroundContainsPoint(coords);
      if (overPlotArea) {
        this._plotAreaHovered = true;
        this._plotArea.hover(this, e3);
      } else if (this._plotAreaHovered && !overPlotArea) {
        this._plotAreaHovered = false;
        this.trigger(PLOT_AREA_LEAVE);
      }
    }
    if (this._sharedTooltip()) {
      this._trackSharedTooltip(coords, e3);
    }
  };
  Chart2.prototype._trackCrosshairs = function _trackCrosshairs(coords) {
    var crosshairs = this._plotArea.crosshairs;
    for (var i16 = 0; i16 < crosshairs.length; i16++) {
      var current2 = crosshairs[i16];
      if (current2.box.containsPoint(coords)) {
        current2.showAt(coords);
      } else {
        current2.hide();
      }
    }
  };
  Chart2.prototype._trackSharedTooltip = function _trackSharedTooltip(coords, e3, toggle) {
    if (this._suppressHover) {
      return;
    }
    var ref2 = this;
    var tooltipOptions = ref2.options.tooltip;
    var plotArea = ref2._plotArea;
    var categoryAxis = ref2._plotArea.categoryAxis;
    var tooltip = ref2._tooltip;
    var highlight = ref2._highlight;
    if (plotArea.backgroundContainsPoint(coords)) {
      var index2 = categoryAxis.pointCategoryIndex(coords);
      if (index2 !== this._tooltipCategoryIx || !this._sharedHighlight && toggle) {
        var points2 = plotArea.pointsByCategoryIndex(index2);
        var pointArgs = points2.map(function(point2) {
          return point2.eventArgs(e3);
        });
        var hoverArgs = pointArgs[0] || {};
        hoverArgs.categoryPoints = pointArgs;
        if (points2.length > 0 && !this.trigger(SERIES_HOVER, hoverArgs)) {
          if (tooltipOptions.visible) {
            tooltip.showAt(points2, coords);
          }
          highlight.show(points2);
          this._sharedHighlight = true;
        } else {
          tooltip.hide();
        }
        this._tooltipCategoryIx = index2;
      } else if (toggle && this._sharedHighlight) {
        highlight.hide();
        tooltip.hide();
        this._sharedHighlight = false;
      }
    } else if (this._sharedHighlight) {
      highlight.hide();
      tooltip.hide();
      this._tooltipCategoryIx = null;
      this._sharedHighlight = false;
    }
  };
  Chart2.prototype.hideElements = function hideElements(options2) {
    var plotArea = this._plotArea;
    this._mousemove.cancel();
    plotArea.hideCrosshairs();
    this._unsetActivePoint(options2);
  };
  Chart2.prototype._unsetActivePoint = function _unsetActivePoint(options2) {
    var ref2 = this;
    var highlight = ref2._highlight;
    this._activePoint = null;
    this._hoveredPoint = null;
    if (!options2 || !options2.keepTooltipOpen) {
      this._hideTooltip();
    }
    this._tooltipCategoryIx = null;
    this._sharedHighlight = false;
    if (highlight) {
      highlight.hide();
    }
  };
  Chart2.prototype._deferRedraw = function _deferRedraw() {
    this._redraw();
  };
  Chart2.prototype._clearRedrawTimeout = function _clearRedrawTimeout() {
    if (this._redrawTimeout) {
      clearInterval(this._redrawTimeout);
      this._redrawTimeout = null;
    }
  };
  Chart2.prototype.bindCategories = function bindCategories() {
    var this$1$1 = this;
    var options2 = this.options;
    var definitions = [].concat(options2.categoryAxis);
    for (var axisIx = 0; axisIx < definitions.length; axisIx++) {
      var axis = definitions[axisIx];
      if (axis.autoBind !== false) {
        this$1$1.bindCategoryAxisFromSeries(axis, axisIx);
      }
    }
  };
  Chart2.prototype.bindCategoryAxisFromSeries = function bindCategoryAxisFromSeries(axis, axisIx) {
    var this$1$1 = this;
    var uniqueCategories = /* @__PURE__ */ new Set();
    var seriesOnAxis = this.options.series.filter(function(series) {
      return series.categoryAxis === axis.name || !series.categoryAxis && axisIx === 0;
    });
    var hasCategoryBinding = seriesOnAxis.some(function(series) {
      return Boolean(series.categoryField);
    });
    var seriesWithData = seriesOnAxis.filter(function(series) {
      return series.data && series.data.length > 0;
    });
    var categorySamples = seriesWithData.map(function(series) {
      return SeriesBinder.current.bindPoint(series, 0).fields.category;
    });
    var dateAxis = categorySamples.reduce(function(result, firstCategory) {
      return result || isDateAxis(axis, firstCategory);
    }, false);
    var seriesWithBinding = seriesWithData.filter(function(series, seriesIx) {
      return series.categoryField || defined(categorySamples[seriesIx]);
    });
    seriesWithBinding.forEach(function(series) {
      return series.data.forEach(function(row, index2) {
        var category = SeriesBinder.current.bindPoint(series, index2).fields.category;
        if (dateAxis) {
          var date = parseDateCategory(category, row, this$1$1.chartService.intl);
          category = date ? date.getTime() : void 0;
        }
        uniqueCategories.add(category);
      });
    });
    if (uniqueCategories.size > 0) {
      var categories = Array.from(uniqueCategories.values());
      if (dateAxis) {
        categories = categories.sort().map(function(time) {
          return time && new Date(time);
        });
      }
      axis.categories = categories;
    } else if (hasCategoryBinding) {
      axis.categories = [];
    }
  };
  Chart2.prototype._isBindable = function _isBindable(series) {
    var valueFields = SeriesBinder.current.valueFields(series);
    var result = true;
    for (var i16 = 0; i16 < valueFields.length; i16++) {
      var field = valueFields[i16];
      if (field === VALUE) {
        field = "field";
      } else {
        field = field + "Field";
      }
      if (!defined(series[field])) {
        result = false;
        break;
      }
    }
    return result;
  };
  Chart2.prototype._noTransitionsRedraw = function _noTransitionsRedraw() {
    var options2 = this.options;
    var transitionsState;
    if (options2.transitions !== false) {
      options2.transitions = false;
      transitionsState = true;
    }
    this._redraw();
    if (transitionsState) {
      options2.transitions = true;
    }
  };
  Chart2.prototype._legendItemHover = function _legendItemHover(seriesIndex, pointIndex) {
    this._showSeriesInactiveOpacity(seriesIndex, pointIndex);
  };
  Chart2.prototype._showSeriesInactiveOpacity = function _showSeriesInactiveOpacity(seriesIndex, pointIndex) {
    var ref2 = this;
    var plotArea = ref2._plotArea;
    var highlight = ref2._highlight;
    var currentSeries = (plotArea.srcSeries || plotArea.series)[seriesIndex];
    var items;
    if (inArray(currentSeries.type, [PIE, DONUT, FUNNEL, PYRAMID])) {
      items = plotArea.findPoint(function(point3) {
        return point3.series.index === seriesIndex && point3.index === pointIndex;
      });
    } else {
      items = plotArea.pointsBySeriesIndex(seriesIndex);
    }
    if (this._hasInactiveOpacity() && currentSeries.visible && items) {
      var multipleSeries = plotArea.series.length > 1;
      var point2 = items.length ? items[0] : items;
      this._displayInactiveOpacity(point2, multipleSeries, items);
    } else {
      highlight.show(items);
    }
  };
  Chart2.prototype._shouldAttachMouseMove = function _shouldAttachMouseMove() {
    return this._plotArea.crosshairs.length || this._tooltip && this._sharedTooltip() || this.requiresHandlers([PLOT_AREA_HOVER, PLOT_AREA_LEAVE]);
  };
  Chart2.prototype.updateMouseMoveHandler = function updateMouseMoveHandler() {
    var obj, obj$1;
    unbindEvents(this.element, (obj = {}, obj[MOUSEMOVE] = this._mousemove, obj));
    if (this._shouldAttachMouseMove()) {
      bindEvents(this.element, (obj$1 = {}, obj$1[MOUSEMOVE] = this._mousemove, obj$1));
    }
  };
  Chart2.prototype.applyOptions = function applyOptions(options2, theme) {
    clearMissingValues(this._originalOptions, options2);
    this._originalOptions = deepExtend(this._originalOptions, options2);
    this.options = deepExtend({}, this._originalOptions);
    if (theme) {
      this._theme = theme;
      this.chartService.theme = theme;
    }
    this._initTheme(this.options, this._theme);
    this._toggleDragZoomEvents();
  };
  Chart2.prototype.setOptions = function setOptions(options2, theme) {
    this.applyOptions(options2, theme);
    this.bindCategories();
    this.redraw();
    this.updateMouseMoveHandler();
  };
  Chart2.prototype.setDirection = function setDirection(rtl) {
    this.chartService.rtl = Boolean(rtl);
    if (this.surface && this.surface.type === "svg") {
      this._destroySurface();
    }
  };
  Chart2.prototype.setIntlService = function setIntlService(intl) {
    this.chartService.intl = intl;
  };
  Chart2.prototype.noTransitionsRedraw = function noTransitionsRedraw() {
    this._noTransitionsRedraw();
  };
  Chart2.prototype.destroy = function destroy2() {
    var obj, obj$1;
    this._destroyed = true;
    unbindEvents(this.element, (obj = {}, obj[CONTEXTMENU] = this._clickHandler, obj[MOUSEWHEEL$1] = this._mousewheelHandler, obj[MOUSEMOVE] = this._mousemove, obj[MOUSELEAVE] = this._mouseleaveHandler, obj[KEYDOWN] = this._keydownHandler, obj[FOCUS] = this._focusHandler, obj[BLUR] = this._blurHandler, obj));
    if (this.domEvents) {
      this.domEvents.destroy();
      delete this.domEvents;
    }
    if (this._mouseMoveTrackHandler) {
      unbindEvents(document, (obj$1 = {}, obj$1[MOUSEMOVE] = this._mouseMoveTrackHandler, obj$1));
    }
    this._focusState = null;
    this._destroyView();
    this._destroySurface();
    this._clearRedrawTimeout();
  };
  Chart2.prototype._destroySurface = function _destroySurface() {
    var surface = this.surface;
    if (surface) {
      surface.unbind("mouseenter", this._surfaceMouseenterHandler);
      surface.unbind("mouseleave", this._surfaceMouseleaveHandler);
      surface.destroy();
      this.surface = null;
    }
  };
  Chart2.prototype._destroySelections = function _destroySelections() {
    var selections = this._selections;
    if (selections) {
      while (selections.length > 0) {
        selections.shift().destroy();
      }
    }
  };
  Chart2.prototype._destroyView = function _destroyView() {
    var model = this._model;
    if (model) {
      model.destroy();
      this._model = null;
    }
    this._unsetActivePoint();
    this._clearFocusedElement();
    this._resetDrilldownPoint();
    this._destroySelections();
    if (this._tooltip) {
      this._tooltip.destroy();
    }
    if (this._highlight) {
      this._highlight.destroy();
    }
    if (this._zoomSelection) {
      this._zoomSelection.destroy();
      delete this._zoomSelection;
    }
    if (this._pannable) {
      this._pannable.destroy();
      delete this._pannable;
    }
    if (this._mousewheelZoom) {
      this._mousewheelZoom.destroy();
      delete this._mousewheelZoom;
    }
  };
  return Chart2;
}(Class$1);
function resolveAxisAliases(options2) {
  var aliases = AXIS_NAMES;
  for (var idx = 0; idx < aliases.length; idx++) {
    var alias = aliases[idx] + "Axes";
    if (options2[alias]) {
      options2[aliases[idx] + "Axis"] = options2[alias];
      delete options2[alias];
    }
  }
}
function pointByCategoryName(points2, name2) {
  if (points2) {
    for (var idx = 0; idx < points2.length; idx++) {
      if (points2[idx].category === name2) {
        return [points2[idx]];
      }
    }
  }
}
function applyAxisDefaults(options2, themeOptions) {
  var themeAxisDefaults = (themeOptions || {}).axisDefaults || {};
  var axisName, axisDefaults2, axes;
  function mapAxisOptions(axisOptions2) {
    var axisColor = (axisOptions2 || {}).color || axisDefaults2.color;
    var result = deepExtend(
      {},
      themeAxisDefaults,
      themeAxisDefaults[axisName],
      axisDefaults2,
      axisDefaults2[axisName],
      {
        line: { color: axisColor },
        labels: { color: axisColor },
        title: { color: axisColor }
      },
      axisOptions2
    );
    delete result[axisName];
    return result;
  }
  for (var idx = 0; idx < AXIS_NAMES.length; idx++) {
    axisName = AXIS_NAMES[idx] + "Axis";
    axisDefaults2 = options2.axisDefaults || {};
    axes = [].concat(options2[axisName]);
    axes = axes.map(mapAxisOptions);
    options2[axisName] = axes.length > 1 ? axes : axes[0];
  }
}
function applySeriesDefaults(options2, themeOptions) {
  var series = options2.series;
  var seriesLength = series.length;
  var seriesDefaults2 = options2.seriesDefaults;
  var commonDefaults = deepExtend({}, options2.seriesDefaults);
  var themeSeriesDefaults = themeOptions ? deepExtend({}, themeOptions.seriesDefaults) : {};
  var commonThemeDefaults = deepExtend({}, themeSeriesDefaults);
  cleanupNestedSeriesDefaults(commonDefaults);
  cleanupNestedSeriesDefaults(commonThemeDefaults);
  for (var i16 = 0; i16 < seriesLength; i16++) {
    var seriesType = series[i16].type || options2.seriesDefaults.type;
    var baseOptions = deepExtend(
      { data: [] },
      commonThemeDefaults,
      themeSeriesDefaults[seriesType],
      { tooltip: options2.tooltip },
      commonDefaults,
      seriesDefaults2[seriesType]
    );
    series[i16]._defaults = baseOptions;
    series[i16] = deepExtend({}, baseOptions, series[i16]);
    series[i16].data = series[i16].data || [];
  }
}
function cleanupNestedSeriesDefaults(seriesDefaults2) {
  delete seriesDefaults2.bar;
  delete seriesDefaults2.column;
  delete seriesDefaults2.rangeColumn;
  delete seriesDefaults2.line;
  delete seriesDefaults2.verticalLine;
  delete seriesDefaults2.pie;
  delete seriesDefaults2.donut;
  delete seriesDefaults2.area;
  delete seriesDefaults2.verticalArea;
  delete seriesDefaults2.scatter;
  delete seriesDefaults2.scatterLine;
  delete seriesDefaults2.bubble;
  delete seriesDefaults2.candlestick;
  delete seriesDefaults2.ohlc;
  delete seriesDefaults2.boxPlot;
  delete seriesDefaults2.bullet;
  delete seriesDefaults2.verticalBullet;
  delete seriesDefaults2.polarArea;
  delete seriesDefaults2.polarLine;
  delete seriesDefaults2.radarArea;
  delete seriesDefaults2.radarLine;
  delete seriesDefaults2.waterfall;
}
function axisRanges(axes) {
  var ranges = {};
  for (var i16 = 0; i16 < axes.length; i16++) {
    var axis = axes[i16];
    var axisName = axis.options.name;
    if (axisName) {
      ranges[axisName] = axis.range();
    }
  }
  return ranges;
}
var DATA_FIELDS = ["data", "categories"];
function clearMissingValues(originalOptions, options2) {
  for (var field in options2) {
    if (!inArray(field, DATA_FIELDS) && hasOwnProperty(options2, field)) {
      var fieldValue = options2[field];
      var originalValue = originalOptions[field];
      if (defined(originalValue)) {
        var nullValue = fieldValue === null;
        if (nullValue || !defined(fieldValue)) {
          delete originalOptions[field];
          if (nullValue) {
            delete options2[field];
          }
        } else if (originalValue && isObject(fieldValue)) {
          if (isObject(originalValue)) {
            clearMissingValues(originalValue, fieldValue);
          }
        }
      }
    }
  }
}
function triggerPaneRender(panes) {
  for (var idx = 0; idx < panes.length; idx++) {
    panes[idx].notifyRender();
  }
}
setDefaultOptions(Chart$1, {
  renderAs: "",
  chartArea: {},
  legend: {
    visible: true,
    labels: {},
    accessibility: {
      highlight: {
        border: {
          opacity: 1,
          color: BLACK$1,
          width: 2
        }
      }
    }
  },
  categoryAxis: {},
  seriesDefaults: {
    type: COLUMN,
    data: [],
    highlight: {
      visible: true
    },
    labels: {},
    negativeValues: {
      visible: false
    },
    accessibility: {
      highlight: {
        border: {
          opacity: 1,
          width: 2
        },
        zIndex: 200
      }
    }
  },
  series: [],
  seriesColors: null,
  tooltip: {
    visible: false
  },
  transitions: true,
  valueAxis: {},
  plotArea: {},
  title: {},
  xAxis: {},
  yAxis: {},
  panes: [{}],
  pannable: false,
  zoomable: false
});
var TOP_OFFSET = -2;
var SharedTooltip = function(ChartSharedTooltip) {
  function SharedTooltip2() {
    ChartSharedTooltip.apply(this, arguments);
  }
  if (ChartSharedTooltip)
    SharedTooltip2.__proto__ = ChartSharedTooltip;
  SharedTooltip2.prototype = Object.create(ChartSharedTooltip && ChartSharedTooltip.prototype);
  SharedTooltip2.prototype.constructor = SharedTooltip2;
  SharedTooltip2.prototype._slotAnchor = function _slotAnchor(coords, slot) {
    var axis = this.plotArea.categoryAxis;
    var vertical = axis.options.vertical;
    var align2 = vertical ? {
      horizontal: "left",
      vertical: "center"
    } : {
      horizontal: "center",
      vertical: "bottom"
    };
    var point2;
    if (vertical) {
      point2 = new Point$5(this.plotArea.box.x2, slot.center().y);
    } else {
      point2 = new Point$5(slot.center().x, TOP_OFFSET);
    }
    return {
      point: point2,
      align: align2
    };
  };
  SharedTooltip2.prototype._defaultAnchor = function _defaultAnchor(point2, slot) {
    return this._slotAnchor({}, slot);
  };
  return SharedTooltip2;
}(SharedTooltip$1);
var DEAULT_BAR_WIDTH = 150;
var DEAULT_BULLET_WIDTH = 150;
var NO_CROSSHAIR = [BAR, BULLET];
function hide(children) {
  var state = [];
  for (var idx = 0; idx < children.length; idx++) {
    var child = children[idx];
    state[idx] = child.style.display;
    child.style.display = "none";
  }
  return state;
}
function show(children, state) {
  for (var idx = 0; idx < children.length; idx++) {
    children[idx].style.display = state[idx];
  }
}
function wrapNumber(value2) {
  return isNumber(value2) ? [value2] : value2;
}
var Sparkline = function(Chart2) {
  function Sparkline2() {
    Chart2.apply(this, arguments);
  }
  if (Chart2)
    Sparkline2.__proto__ = Chart2;
  Sparkline2.prototype = Object.create(Chart2 && Chart2.prototype);
  Sparkline2.prototype.constructor = Sparkline2;
  Sparkline2.prototype._setElementClass = function _setElementClass(element) {
    addClass2(element, "k-sparkline");
  };
  Sparkline2.prototype._initElement = function _initElement(element) {
    Chart2.prototype._initElement.call(this, element);
    this._initialWidth = Math.floor(elementSize(element).width);
  };
  Sparkline2.prototype._resize = function _resize() {
    var element = this.element;
    var state = hide(element.childNodes);
    this._initialWidth = Math.floor(elementSize(element).width);
    show(element.childNodes, state);
    Chart2.prototype._resize.call(this);
  };
  Sparkline2.prototype._modelOptions = function _modelOptions() {
    var chartOptions = this.options;
    var stage = this._surfaceWrap();
    var displayState = hide(stage.childNodes);
    var space = document.createElement("span");
    space.innerHTML = "&nbsp;";
    stage.appendChild(space);
    var options2 = deepExtend({
      width: this._autoWidth,
      height: elementSize(stage).height,
      transitions: chartOptions.transitions
    }, chartOptions.chartArea, {
      inline: true,
      align: false
    });
    elementSize(stage, {
      width: options2.width,
      height: options2.height
    });
    stage.removeChild(space);
    show(stage.childNodes, displayState);
    if (this.surface) {
      this.surface.resize();
    }
    return options2;
  };
  Sparkline2.prototype._surfaceWrap = function _surfaceWrap() {
    if (!this.stage) {
      var stage = this.stage = document.createElement("span");
      this.element.appendChild(stage);
    }
    return this.stage;
  };
  Sparkline2.prototype._createPlotArea = function _createPlotArea(skipSeries) {
    var plotArea = Chart2.prototype._createPlotArea.call(this, skipSeries);
    this._autoWidth = this._initialWidth || this._calculateWidth(plotArea);
    return plotArea;
  };
  Sparkline2.prototype._calculateWidth = function _calculateWidth(plotArea) {
    var options2 = this.options;
    var margin = getSpacing(options2.chartArea.margin);
    var charts = plotArea.charts;
    var stage = this._surfaceWrap();
    var total3 = 0;
    for (var i16 = 0; i16 < charts.length; i16++) {
      var currentChart = charts[i16];
      var firstSeries = (currentChart.options.series || [])[0];
      if (!firstSeries) {
        continue;
      }
      if (firstSeries.type === BAR) {
        return DEAULT_BAR_WIDTH;
      }
      if (firstSeries.type === BULLET) {
        return DEAULT_BULLET_WIDTH;
      }
      if (firstSeries.type === PIE) {
        return elementSize(stage).height;
      }
      var categoryAxis = currentChart.categoryAxis;
      if (categoryAxis) {
        var pointsCount = categoryAxis.categoriesCount() * (!currentChart.options.isStacked && inArray(firstSeries.type, [COLUMN, VERTICAL_BULLET]) ? currentChart.seriesOptions.length : 1);
        total3 = Math.max(total3, pointsCount);
      }
    }
    var size = total3 * options2.pointWidth;
    if (size > 0) {
      size += margin.left + margin.right;
    }
    return size;
  };
  Sparkline2.prototype._createSharedTooltip = function _createSharedTooltip(options2) {
    return new SharedTooltip(this._plotArea, options2);
  };
  Sparkline2.normalizeOptions = function normalizeOptions(userOptions) {
    var options2 = wrapNumber(userOptions);
    if (isArray$1(options2)) {
      options2 = { seriesDefaults: { data: options2 } };
    } else {
      options2 = deepExtend({}, options2);
    }
    if (!options2.series) {
      options2.series = [{ data: wrapNumber(options2.data) }];
    }
    deepExtend(options2, {
      seriesDefaults: {
        type: options2.type
      }
    });
    if (inArray(options2.series[0].type, NO_CROSSHAIR) || inArray(options2.seriesDefaults.type, NO_CROSSHAIR)) {
      options2 = deepExtend({}, {
        categoryAxis: {
          crosshair: {
            visible: false
          }
        }
      }, options2);
    }
    return options2;
  };
  return Sparkline2;
}(Chart$1);
setDefaultOptions(Sparkline, {
  chartArea: {
    margin: 2
  },
  axisDefaults: {
    visible: false,
    majorGridLines: {
      visible: false
    },
    valueAxis: {
      narrowRange: true
    }
  },
  seriesDefaults: {
    type: "line",
    area: {
      line: {
        width: 0.5
      }
    },
    bar: {
      stack: true
    },
    padding: 2,
    width: 0.5,
    overlay: {
      gradient: null
    },
    highlight: {
      visible: false
    },
    border: {
      width: 0
    },
    markers: {
      size: 2,
      visible: false
    }
  },
  tooltip: {
    visible: true,
    shared: true
  },
  categoryAxis: {
    crosshair: {
      visible: true,
      tooltip: {
        visible: false
      }
    }
  },
  legend: {
    visible: false
  },
  transitions: false,
  pointWidth: 5,
  panes: [{ clip: false }]
});
var FadeOutAnimation = function(superclass) {
  function FadeOutAnimation2() {
    superclass.apply(this, arguments);
  }
  if (superclass)
    FadeOutAnimation2.__proto__ = superclass;
  FadeOutAnimation2.prototype = Object.create(superclass && superclass.prototype);
  FadeOutAnimation2.prototype.constructor = FadeOutAnimation2;
  FadeOutAnimation2.prototype.setup = function setup() {
    this._initialOpacity = parseFloat(elementStyles(this.element, "opacity").opacity);
  };
  FadeOutAnimation2.prototype.step = function step(pos) {
    elementStyles(this.element, {
      opacity: String(interpolateValue(this._initialOpacity, 0, pos))
    });
  };
  FadeOutAnimation2.prototype.abort = function abort() {
    superclass.prototype.abort.call(this);
    elementStyles(this.element, {
      display: "none",
      opacity: String(this._initialOpacity)
    });
  };
  FadeOutAnimation2.prototype.cancel = function cancel() {
    superclass.prototype.abort.call(this);
    elementStyles(this.element, {
      opacity: String(this._initialOpacity)
    });
  };
  return FadeOutAnimation2;
}(Animation$2);
function createDiv(className, style2) {
  var div = document.createElement("div");
  div.className = className;
  if (style2) {
    div.style.cssText = style2;
  }
  return div;
}
var NavigatorHint = function(Class3) {
  function NavigatorHint2(container, chartService, options2) {
    Class3.call(this);
    this.options = deepExtend({}, this.options, options2);
    this.container = container;
    this.chartService = chartService;
    var padding = elementStyles(container, ["paddingLeft", "paddingTop"]);
    this.chartPadding = {
      top: padding.paddingTop,
      left: padding.paddingLeft
    };
    this.createElements();
    container.appendChild(this.element);
  }
  if (Class3)
    NavigatorHint2.__proto__ = Class3;
  NavigatorHint2.prototype = Object.create(Class3 && Class3.prototype);
  NavigatorHint2.prototype.constructor = NavigatorHint2;
  NavigatorHint2.prototype.createElements = function createElements() {
    var element = this.element = createDiv("k-navigator-hint", "display: none; position: absolute; top: 1px; left: 1px;");
    var tooltip = this.tooltip = createDiv("k-tooltip k-chart-tooltip");
    var scroll = this.scroll = createDiv("k-scroll");
    tooltip.innerHTML = "&nbsp;";
    element.appendChild(tooltip);
    element.appendChild(scroll);
  };
  NavigatorHint2.prototype.show = function show2(from, to, bbox) {
    var ref2 = this;
    var element = ref2.element;
    var options2 = ref2.options;
    var scroll = ref2.scroll;
    var tooltip = ref2.tooltip;
    var middle = toDate(toTime(from) + toTime(to - from) / 2);
    var scrollWidth = bbox.width() * 0.4;
    var minPos = bbox.center().x - scrollWidth;
    var maxPos = bbox.center().x;
    var posRange = maxPos - minPos;
    var range = options2.max - options2.min;
    var scale = posRange / range;
    var offset2 = middle - options2.min;
    var text = this.chartService.intl.format(options2.format, from, to);
    var template = getTemplate$1(options2);
    this.clearHideTimeout();
    if (!this._visible) {
      elementStyles(element, {
        visibility: "hidden",
        display: "block"
      });
      this._visible = true;
    }
    if (template) {
      text = template({
        from,
        to
      });
    }
    tooltip.innerHTML = text;
    elementStyles(tooltip, {
      left: bbox.center().x - tooltip.offsetWidth / 2,
      top: bbox.y1
    });
    var tooltipStyle = elementStyles(tooltip, ["marginTop", "borderTopWidth", "height"]);
    elementStyles(scroll, {
      width: scrollWidth,
      left: minPos + offset2 * scale,
      top: bbox.y1 + tooltipStyle.marginTop + tooltipStyle.borderTopWidth + tooltipStyle.height / 2
    });
    elementStyles(element, {
      visibility: "visible"
    });
  };
  NavigatorHint2.prototype.clearHideTimeout = function clearHideTimeout() {
    if (this._hideTimeout) {
      clearTimeout(this._hideTimeout);
    }
    if (this._hideAnimation) {
      this._hideAnimation.cancel();
    }
  };
  NavigatorHint2.prototype.hide = function hide2() {
    var this$1$1 = this;
    this.clearHideTimeout();
    this._hideTimeout = setTimeout(function() {
      this$1$1._visible = false;
      this$1$1._hideAnimation = new FadeOutAnimation(this$1$1.element);
      this$1$1._hideAnimation.setup();
      this$1$1._hideAnimation.play();
    }, this.options.hideDelay);
  };
  NavigatorHint2.prototype.destroy = function destroy2() {
    this.clearHideTimeout();
    if (this.container) {
      this.container.removeChild(this.element);
    }
    delete this.container;
    delete this.chartService;
    delete this.element;
    delete this.tooltip;
    delete this.scroll;
  };
  return NavigatorHint2;
}(Class$1);
setDefaultOptions(NavigatorHint, {
  format: "{0:d} - {1:d}",
  hideDelay: 500
});
var NAVIGATOR_PANE = "_navigator";
var NAVIGATOR_AXIS = NAVIGATOR_PANE;
var DEFAULT_PANE = "_default";
var ZOOM_ACCELERATION = 3;
var Navigator$1 = function(Class3) {
  function Navigator2(chart) {
    var obj;
    Class3.call(this);
    this.chart = chart;
    var options2 = this.options = deepExtend({}, this.options, chart.options.navigator);
    var select = options2.select;
    if (select) {
      select.from = this.parseDate(select.from);
      select.to = this.parseDate(select.to);
    }
    if (!defined(options2.hint.visible)) {
      options2.hint.visible = options2.visible;
    }
    this.chartObserver = new InstanceObserver(this, (obj = {}, obj[DRAG] = "_drag", obj[DRAG_END] = "_dragEnd", obj[ZOOM] = "_zoom", obj[ZOOM_END] = "_zoomEnd", obj));
    chart.addObserver(this.chartObserver);
  }
  if (Class3)
    Navigator2.__proto__ = Class3;
  Navigator2.prototype = Object.create(Class3 && Class3.prototype);
  Navigator2.prototype.constructor = Navigator2;
  Navigator2.prototype.parseDate = function parseDate$12(value2) {
    return parseDate(this.chart.chartService.intl, value2);
  };
  Navigator2.prototype.clean = function clean() {
    if (this.selection) {
      this.selection.destroy();
      this.selection = null;
    }
    if (this.hint) {
      this.hint.destroy();
      this.hint = null;
    }
  };
  Navigator2.prototype.destroy = function destroy2() {
    if (this.chart) {
      this.chart.removeObserver(this.chartObserver);
      delete this.chart;
    }
    this.clean();
  };
  Navigator2.prototype.redraw = function redraw() {
    this._redrawSelf();
    this.initSelection();
  };
  Navigator2.prototype.initSelection = function initSelection() {
    var ref2 = this;
    var chart = ref2.chart;
    var options2 = ref2.options;
    var axis = this.mainAxis();
    var ref$1 = axis.roundedRange();
    var min2 = ref$1.min;
    var max2 = ref$1.max;
    var ref$2 = options2.select;
    var from = ref$2.from;
    var to = ref$2.to;
    var mousewheel = ref$2.mousewheel;
    var axisClone = clone2(axis);
    if (axis.categoriesCount() === 0) {
      return;
    }
    this.clean();
    axisClone.box = axis.box;
    this.selection = new Selection(chart, axisClone, {
      min: min2,
      max: max2,
      from: from || min2,
      to: to || max2,
      mousewheel: valueOrDefault$1(mousewheel, { zoom: "left" }),
      visible: options2.visible
    }, new InstanceObserver(this, {
      selectStart: "_selectStart",
      select: "_select",
      selectEnd: "_selectEnd"
    }));
    if (options2.hint.visible) {
      this.hint = new NavigatorHint(chart.element, chart.chartService, {
        min: min2,
        max: max2,
        template: getTemplate$1(options2.hint),
        format: options2.hint.format
      });
    }
  };
  Navigator2.prototype.setRange = function setRange() {
    var plotArea = this.chart._createPlotArea(true);
    var axis = plotArea.namedCategoryAxes[NAVIGATOR_AXIS];
    var ref2 = axis.roundedRange();
    var min2 = ref2.min;
    var max2 = ref2.max;
    var select = this.options.select || {};
    var from = select.from || min2;
    if (from < min2) {
      from = min2;
    }
    var to = select.to || max2;
    if (to > max2) {
      to = max2;
    }
    this.options.select = deepExtend({}, select, {
      from,
      to
    });
    this.filterAxes();
  };
  Navigator2.prototype._redrawSelf = function _redrawSelf(silent) {
    var plotArea = this.chart._plotArea;
    if (plotArea) {
      plotArea.redraw(last(plotArea.panes), silent);
    }
  };
  Navigator2.prototype.redrawSlaves = function redrawSlaves() {
    var chart = this.chart;
    var plotArea = chart._plotArea;
    var slavePanes = plotArea.panes.filter(function(pane) {
      return pane.options.name !== NAVIGATOR_PANE;
    });
    plotArea.srcSeries = chart.options.series;
    plotArea.options.categoryAxis = chart.options.categoryAxis;
    plotArea.clearSeriesPointsCache();
    plotArea.redraw(slavePanes);
  };
  Navigator2.prototype._drag = function _drag(e3) {
    var ref2 = this;
    var chart = ref2.chart;
    var selection = ref2.selection;
    var coords = chart._eventCoordinates(e3.originalEvent);
    var navigatorAxis = this.mainAxis();
    var naviRange = navigatorAxis.roundedRange();
    var inNavigator = navigatorAxis.pane.box.containsPoint(coords);
    var axis = chart._plotArea.categoryAxis;
    var range = e3.axisRanges[axis.options.name];
    var select = this.options.select;
    var duration2;
    if (!range || inNavigator || !selection) {
      return;
    }
    if (select.from && select.to) {
      duration2 = toTime(select.to) - toTime(select.from);
    } else {
      duration2 = toTime(selection.options.to) - toTime(selection.options.from);
    }
    var from = toDate(limitValue(
      toTime(range.min),
      naviRange.min,
      toTime(naviRange.max) - duration2
    ));
    var to = toDate(limitValue(
      toTime(from) + duration2,
      toTime(naviRange.min) + duration2,
      naviRange.max
    ));
    this.options.select = { from, to };
    if (this.options.liveDrag) {
      this.filterAxes();
      this.redrawSlaves();
    }
    selection.set(from, to);
    this.showHint(from, to);
  };
  Navigator2.prototype._dragEnd = function _dragEnd() {
    this.filterAxes();
    this.filter();
    this.redrawSlaves();
    if (this.hint) {
      this.hint.hide();
    }
  };
  Navigator2.prototype.readSelection = function readSelection() {
    var ref2 = this;
    var ref_selection_options = ref2.selection.options;
    var from = ref_selection_options.from;
    var to = ref_selection_options.to;
    var select = ref2.options.select;
    select.from = from;
    select.to = to;
  };
  Navigator2.prototype.filterAxes = function filterAxes() {
    var ref2 = this;
    var select = ref2.options.select;
    if (select === void 0)
      select = {};
    var chart = ref2.chart;
    var allAxes = chart.options.categoryAxis;
    var from = select.from;
    var to = select.to;
    for (var idx = 0; idx < allAxes.length; idx++) {
      var axis = allAxes[idx];
      if (axis.pane !== NAVIGATOR_PANE) {
        axis.min = from;
        axis.max = to;
      }
    }
  };
  Navigator2.prototype.filter = function filter() {
    var ref2 = this;
    var chart = ref2.chart;
    var select = ref2.options.select;
    if (!chart.requiresHandlers(["navigatorFilter"])) {
      return;
    }
    var mainAxis = this.mainAxis();
    var args = {
      from: select.from,
      to: select.to
    };
    if (mainAxis.options.type !== "category") {
      var axisOptions2 = new DateCategoryAxis(deepExtend({
        baseUnit: "fit"
      }, chart.options.categoryAxis[0], {
        categories: [select.from, select.to]
      }), chart.chartService).options;
      args.from = addDuration(axisOptions2.min, -axisOptions2.baseUnitStep, axisOptions2.baseUnit);
      args.to = addDuration(axisOptions2.max, axisOptions2.baseUnitStep, axisOptions2.baseUnit);
    }
    this.chart.trigger("navigatorFilter", args);
  };
  Navigator2.prototype._zoom = function _zoom(e3) {
    var ref2 = this;
    var axis = ref2.chart._plotArea.categoryAxis;
    var selection = ref2.selection;
    var ref_options = ref2.options;
    var select = ref_options.select;
    var liveDrag = ref_options.liveDrag;
    var mainAxis = this.mainAxis();
    var delta = e3.delta;
    if (!selection) {
      return;
    }
    var fromIx = mainAxis.categoryIndex(selection.options.from);
    var toIx = mainAxis.categoryIndex(selection.options.to);
    var coords = this.chart._eventCoordinates(e3.originalEvent);
    e3.originalEvent.preventDefault();
    if (Math.abs(delta) > 1) {
      delta *= ZOOM_ACCELERATION;
    }
    if (toIx - fromIx > 1) {
      selection.zoom(delta, coords);
      this.readSelection();
    } else {
      axis.options.min = select.from;
      select.from = axis.scaleRange(-e3.delta * this.chart._mousewheelZoomRate(), coords).min;
    }
    if (liveDrag) {
      this.filterAxes();
      this.redrawSlaves();
    }
    selection.set(select.from, select.to);
    this.showHint(this.options.select.from, this.options.select.to);
  };
  Navigator2.prototype._zoomEnd = function _zoomEnd(e3) {
    this._dragEnd(e3);
  };
  Navigator2.prototype.showHint = function showHint(from, to) {
    var plotArea = this.chart._plotArea;
    if (this.hint) {
      this.hint.show(from, to, plotArea.backgroundBox());
    }
  };
  Navigator2.prototype._selectStart = function _selectStart(e3) {
    return this.chart._selectStart(e3);
  };
  Navigator2.prototype._select = function _select(e3) {
    this.showHint(e3.from, e3.to);
    return this.chart._select(e3);
  };
  Navigator2.prototype._selectEnd = function _selectEnd(e3) {
    if (this.hint) {
      this.hint.hide();
    }
    this.readSelection();
    this.filterAxes();
    this.filter();
    this.redrawSlaves();
    return this.chart._selectEnd(e3);
  };
  Navigator2.prototype.mainAxis = function mainAxis() {
    var plotArea = this.chart._plotArea;
    if (plotArea) {
      return plotArea.namedCategoryAxes[NAVIGATOR_AXIS];
    }
  };
  Navigator2.prototype.select = function select(from, to) {
    var select2 = this.options.select;
    if (from && to) {
      select2.from = this.parseDate(from);
      select2.to = this.parseDate(to);
      this.filterAxes();
      this.filter();
      this.redrawSlaves();
      this.selection.set(from, to);
    }
    return {
      from: select2.from,
      to: select2.to
    };
  };
  Navigator2.setup = function setup(options2, themeOptions) {
    if (options2 === void 0)
      options2 = {};
    if (themeOptions === void 0)
      themeOptions = {};
    if (options2.__navi) {
      return;
    }
    options2.__navi = true;
    var naviOptions = deepExtend({}, themeOptions.navigator, options2.navigator);
    var panes = options2.panes = [].concat(options2.panes);
    var paneOptions = deepExtend({}, naviOptions.pane, { name: NAVIGATOR_PANE });
    if (!naviOptions.visible) {
      paneOptions.visible = false;
      paneOptions.height = 0.1;
    }
    if (options2.navigator.position !== "top") {
      panes.push(paneOptions);
    } else {
      panes.unshift(paneOptions);
    }
    panes.forEach(function(pane) {
      pane.name = pane.name || DEFAULT_PANE;
    });
    Navigator2.attachAxes(options2, naviOptions);
    Navigator2.attachSeries(options2, naviOptions, themeOptions);
  };
  Navigator2.attachAxes = function attachAxes(options2, naviOptions) {
    var series = naviOptions.series || [];
    var categoryAxes = options2.categoryAxis = [].concat(options2.categoryAxis);
    var valueAxes = options2.valueAxis = [].concat(options2.valueAxis);
    var allAxes = categoryAxes.concat(valueAxes);
    allAxes.forEach(function(axis) {
      axis.pane = axis.pane || DEFAULT_PANE;
    });
    var equallySpacedSeries = filterSeriesByType(series, EQUALLY_SPACED_SERIES);
    var justifyAxis = equallySpacedSeries.length === 0;
    var base = deepExtend({
      type: "date",
      pane: NAVIGATOR_PANE,
      roundToBaseUnit: !justifyAxis,
      justified: justifyAxis,
      _collapse: false,
      majorTicks: { visible: true },
      tooltip: { visible: false },
      labels: { step: 1 },
      autoBind: naviOptions.autoBindElements,
      autoBaseUnitSteps: {
        minutes: [1],
        hours: [1, 2],
        days: [1, 2],
        weeks: [],
        months: [1],
        years: [1]
      }
    });
    var user = naviOptions.categoryAxis;
    categoryAxes.push(
      deepExtend({}, base, {
        maxDateGroups: 200
      }, user, {
        name: NAVIGATOR_AXIS,
        title: null,
        baseUnit: "fit",
        baseUnitStep: "auto",
        labels: { visible: false },
        majorTicks: { visible: false }
      }),
      deepExtend({}, base, user, {
        name: NAVIGATOR_AXIS + "_labels",
        maxDateGroups: 20,
        baseUnitStep: "auto",
        labels: { position: "" },
        plotBands: [],
        autoBaseUnitSteps: {
          minutes: []
        },
        _overlap: true
      }),
      deepExtend({}, base, user, {
        name: NAVIGATOR_AXIS + "_ticks",
        maxDateGroups: 200,
        majorTicks: {
          width: 0.5
        },
        plotBands: [],
        title: null,
        labels: { visible: false, mirror: true },
        _overlap: true
      })
    );
    valueAxes.push(deepExtend({
      name: NAVIGATOR_AXIS,
      pane: NAVIGATOR_PANE,
      majorGridLines: {
        visible: false
      },
      visible: false
    }, naviOptions.valueAxis));
  };
  Navigator2.attachSeries = function attachSeries(options2, naviOptions, themeOptions) {
    var series = options2.series = options2.series || [];
    var navigatorSeries = [].concat(naviOptions.series || []);
    var seriesColors = themeOptions.seriesColors;
    var defaults = naviOptions.seriesDefaults;
    for (var idx = 0; idx < navigatorSeries.length; idx++) {
      series.push(
        deepExtend({
          color: seriesColors[idx % seriesColors.length],
          categoryField: naviOptions.dateField,
          visibleInLegend: false,
          tooltip: {
            visible: false
          }
        }, defaults, navigatorSeries[idx], {
          axis: NAVIGATOR_AXIS,
          categoryAxis: NAVIGATOR_AXIS,
          autoBind: naviOptions.autoBindElements
        })
      );
    }
  };
  return Navigator2;
}(Class$1);
function ClonedObject() {
}
function clone2(obj) {
  ClonedObject.prototype = obj;
  return new ClonedObject();
}
var AUTO_CATEGORY_WIDTH = 28;
var StockChart = function(Chart2) {
  function StockChart2() {
    Chart2.apply(this, arguments);
  }
  if (Chart2)
    StockChart2.__proto__ = Chart2;
  StockChart2.prototype = Object.create(Chart2 && Chart2.prototype);
  StockChart2.prototype.constructor = StockChart2;
  StockChart2.prototype.applyDefaults = function applyDefaults2(options2, themeOptions) {
    var width = elementSize(this.element).width || DEFAULT_WIDTH$1;
    var theme = themeOptions;
    var stockDefaults = {
      seriesDefaults: {
        categoryField: options2.dateField
      },
      axisDefaults: {
        categoryAxis: {
          name: "default",
          majorGridLines: {
            visible: false
          },
          labels: {
            step: 2
          },
          majorTicks: {
            visible: false
          },
          maxDateGroups: Math.floor(width / AUTO_CATEGORY_WIDTH)
        }
      }
    };
    if (theme) {
      theme = deepExtend({}, theme, stockDefaults);
    }
    Navigator$1.setup(options2, theme);
    Chart2.prototype.applyDefaults.call(this, options2, theme);
  };
  StockChart2.prototype._setElementClass = function _setElementClass(element) {
    addClass2(element, "k-chart k-stockchart");
  };
  StockChart2.prototype.setOptions = function setOptions(options2) {
    this.destroyNavigator();
    Chart2.prototype.setOptions.call(this, options2);
  };
  StockChart2.prototype.noTransitionsRedraw = function noTransitionsRedraw() {
    var transitions = this.options.transitions;
    this.options.transitions = false;
    this._fullRedraw();
    this.options.transitions = transitions;
  };
  StockChart2.prototype._resize = function _resize() {
    this.noTransitionsRedraw();
  };
  StockChart2.prototype._redraw = function _redraw() {
    var navigator2 = this.navigator;
    if (!this._dirty() && navigator2 && navigator2.options.partialRedraw) {
      navigator2.redrawSlaves();
    } else {
      this._fullRedraw();
    }
  };
  StockChart2.prototype._dirty = function _dirty() {
    var options2 = this.options;
    var series = [].concat(options2.series, options2.navigator.series);
    var seriesCount = grep(series, function(s10) {
      return s10 && s10.visible;
    }).length;
    var dirty = this._seriesCount !== seriesCount;
    this._seriesCount = seriesCount;
    return dirty;
  };
  StockChart2.prototype._fullRedraw = function _fullRedraw() {
    var navigator2 = this.navigator;
    if (!navigator2) {
      navigator2 = this.navigator = new Navigator$1(this);
      this.trigger("navigatorCreated", { navigator: navigator2 });
    }
    navigator2.clean();
    navigator2.setRange();
    Chart2.prototype._redraw.call(this);
    navigator2.initSelection();
  };
  StockChart2.prototype._trackSharedTooltip = function _trackSharedTooltip(coords) {
    var plotArea = this._plotArea;
    var pane = plotArea.paneByPoint(coords);
    if (pane && pane.options.name === NAVIGATOR_PANE) {
      this._unsetActivePoint();
    } else {
      Chart2.prototype._trackSharedTooltip.call(this, coords);
    }
  };
  StockChart2.prototype.bindCategories = function bindCategories() {
    Chart2.prototype.bindCategories.call(this);
    this.copyNavigatorCategories();
  };
  StockChart2.prototype.copyNavigatorCategories = function copyNavigatorCategories() {
    var definitions = [].concat(this.options.categoryAxis);
    var categories;
    for (var axisIx = 0; axisIx < definitions.length; axisIx++) {
      var axis = definitions[axisIx];
      if (axis.name === NAVIGATOR_AXIS) {
        categories = axis.categories;
      } else if (categories && axis.pane === NAVIGATOR_PANE) {
        axis.categories = categories;
      }
    }
  };
  StockChart2.prototype.destroyNavigator = function destroyNavigator() {
    if (this.navigator) {
      this.navigator.destroy();
      this.navigator = null;
    }
  };
  StockChart2.prototype.destroy = function destroy2() {
    this.destroyNavigator();
    Chart2.prototype.destroy.call(this);
  };
  StockChart2.prototype._stopChartHandlers = function _stopChartHandlers(e3) {
    var coords = this._eventCoordinates(e3);
    var pane = this._plotArea.paneByPoint(coords);
    return Chart2.prototype._stopChartHandlers.call(this, e3) || pane && pane.options.name === NAVIGATOR_PANE;
  };
  StockChart2.prototype._toggleDragZoomEvents = function _toggleDragZoomEvents() {
    if (!this._dragZoomEnabled) {
      this.element.style.touchAction = "none";
      this._dragZoomEnabled = true;
    }
  };
  return StockChart2;
}(Chart$1);
setDefaultOptions(StockChart, {
  dateField: "date",
  axisDefaults: {
    categoryAxis: {
      type: "date",
      baseUnit: "fit",
      justified: true
    },
    valueAxis: {
      narrowRange: true,
      labels: {
        format: "C"
      }
    }
  },
  navigator: {
    select: {},
    seriesDefaults: {
      markers: {
        visible: false
      },
      tooltip: {
        visible: false
      },
      highlight: {
        visible: false
      },
      line: {
        width: 2
      }
    },
    hint: {},
    visible: true
  },
  tooltip: {
    visible: true
  },
  legend: {
    visible: false
  }
});
var ANGULAR_SPEED = 150;
var LINEAR_SPEED = 250;
var ARROW = "arrow";
var ARROW_POINTER = "arrowPointer";
var BAR_POINTER = "barPointer";
var DEFAULT_HEIGHT = 200;
var DEFAULT_LINE_WIDTH = 0.5;
var DEFAULT_WIDTH = 200;
var DEGREE = Math.PI / 180;
var INSIDE$1 = "inside";
var LINEAR = "linear";
var OUTSIDE = "outside";
var RADIAL_POINTER = "radialPointer";
var RADIAL_RANGE_POINTER = "radialRangePointer";
function pad(bbox, value2) {
  var origin = bbox.getOrigin();
  var size = bbox.getSize();
  var spacing = getSpacing(value2);
  bbox.setOrigin([origin.x - spacing.left, origin.y - spacing.top]);
  bbox.setSize([size.width + (spacing.left + spacing.right), size.height + (spacing.top + spacing.bottom)]);
  return bbox;
}
var Group$7 = Group$9;
var Path$6 = Path$7;
var Text$1 = Text$4;
function buildLabelElement(label, options2) {
  var labelBox = label.box;
  var textBox = label.children[0].box;
  var border = options2.border || {};
  var background = options2.background || "";
  var wrapper2 = Path$6.fromRect(new Rect$1([labelBox.x1, labelBox.y1], [labelBox.width(), labelBox.height()]), {
    stroke: {}
  });
  var text = new Text$1(label.text, new Point$7(textBox.x1, textBox.y1), {
    font: options2.font,
    fill: { color: options2.color }
  });
  var styleGeometry = pad(text.bbox().clone(), options2.padding);
  var styleBox = Path$6.fromRect(styleGeometry, {
    stroke: {
      color: border.width ? border.color : "",
      width: border.width,
      opacity: border.opacity,
      dashType: border.dashType,
      lineJoin: "round",
      lineCap: "round"
    },
    fill: {
      color: background
    }
  });
  var elements = new Group$7();
  elements.append(wrapper2);
  elements.append(styleBox);
  elements.append(text);
  return elements;
}
function getRange(range, min2, max2) {
  var from = defined(range.from) ? range.from : MIN_VALUE;
  var to = defined(range.to) ? range.to : MAX_VALUE;
  range.from = Math.max(Math.min(to, from), min2);
  range.to = Math.min(Math.max(to, from), max2);
  return range;
}
function unpad(bbox, value2) {
  var spacing = getSpacing(value2);
  spacing.left = -spacing.left;
  spacing.top = -spacing.top;
  spacing.right = -spacing.right;
  spacing.bottom = -spacing.bottom;
  return pad(bbox, spacing);
}
var DEFAULT_MARGIN = 5;
var Path$5 = Path$7;
var Surface = Surface$2;
var Gauge = function(Class3) {
  function Gauge2(element, userOptions, theme, context2) {
    if (context2 === void 0)
      context2 = {};
    Class3.call(this);
    this.element = element;
    this.theme = theme;
    this.contextService = new ChartService(this, context2);
    this._originalOptions = deepExtend({}, this.options, userOptions);
    this.options = deepExtend({}, this._originalOptions);
    this._initTheme(theme);
    this.redraw();
  }
  if (Class3)
    Gauge2.__proto__ = Class3;
  Gauge2.prototype = Object.create(Class3 && Class3.prototype);
  Gauge2.prototype.constructor = Gauge2;
  Gauge2.prototype.destroy = function destroy2() {
    if (this.surface) {
      this.surface.destroy();
      this.surface = null;
    }
    delete this.element;
    delete this.surfaceElement;
  };
  Gauge2.prototype.value = function value2(pointerValue) {
    var pointer = this.pointers[0];
    if (arguments.length === 0) {
      return pointer.value();
    }
    pointer.value(pointerValue);
    this._setValueOptions(pointerValue);
  };
  Gauge2.prototype._draw = function _draw() {
    var surface = this.surface;
    surface.clear();
    surface.draw(this._visuals);
  };
  Gauge2.prototype.exportVisual = function exportVisual() {
    return this._visuals;
  };
  Gauge2.prototype.allValues = function allValues(values6) {
    var pointers = this.pointers;
    var allValues2 = [];
    if (arguments.length === 0) {
      for (var i16 = 0; i16 < pointers.length; i16++) {
        allValues2.push(pointers[i16].value());
      }
      return allValues2;
    }
    if (isArray$1(values6)) {
      for (var i$12 = 0; i$12 < values6.length; i$12++) {
        if (isNumber(values6[i$12])) {
          pointers[i$12].value(values6[i$12]);
        }
      }
    }
    this._setValueOptions(values6);
  };
  Gauge2.prototype._setValueOptions = function _setValueOptions(values6) {
    var pointers = [].concat(this.options.pointer);
    var arrayValues = [].concat(values6);
    for (var i16 = 0; i16 < arrayValues.length; i16++) {
      pointers[i16].value = arrayValues[i16];
    }
  };
  Gauge2.prototype.resize = function resize() {
    this.noTransitionsRedraw();
  };
  Gauge2.prototype.noTransitionsRedraw = function noTransitionsRedraw() {
    var transitions = this.options.transitions;
    this._toggleTransitions(false);
    this.redraw();
    this._toggleTransitions(transitions);
  };
  Gauge2.prototype.redraw = function redraw() {
    var size = this._surfaceSize();
    var wrapper2 = new Rect$1([0, 0], [size.width, size.height]);
    this._initSurface();
    this.gaugeArea = this._createGaugeArea();
    this._createModel();
    var bbox = unpad(wrapper2.bbox(), this._gaugeAreaMargin);
    this.reflow(bbox);
  };
  Gauge2.prototype.setOptions = function setOptions(options2, theme) {
    this._originalOptions = deepExtend(this._originalOptions, options2);
    this.options = deepExtend({}, this._originalOptions);
    this._initTheme(theme);
    this.redraw();
  };
  Gauge2.prototype.setDirection = function setDirection(rtl) {
    this.contextService.rtl = Boolean(rtl);
    if (this.surface && this.surface.type === "svg") {
      this.surface.destroy();
      this.surface = null;
    }
  };
  Gauge2.prototype.setIntlService = function setIntlService(intl) {
    this.contextService.intl = intl;
  };
  Gauge2.prototype._initTheme = function _initTheme(theme) {
    var currentTheme = theme || this.theme || {};
    this.theme = currentTheme;
    this.options = deepExtend({}, currentTheme, this.options);
    var options2 = this.options;
    var pointer = options2.pointer;
    if (isArray$1(pointer)) {
      var pointers = [];
      for (var i16 = 0; i16 < pointer.length; i16++) {
        pointers.push(deepExtend({}, currentTheme.pointer, pointer[i16]));
      }
      options2.pointer = pointers;
    }
  };
  Gauge2.prototype._createGaugeArea = function _createGaugeArea() {
    var options2 = this.options.gaugeArea;
    var size = this.surface.size();
    var border = options2.border || {};
    var areaGeometry = new Rect$1([0, 0], [size.width, size.height]);
    this._gaugeAreaMargin = options2.margin || DEFAULT_MARGIN;
    if (border.width > 0) {
      areaGeometry = unpad(areaGeometry, border.width);
    }
    var gaugeArea = Path$5.fromRect(areaGeometry, {
      stroke: {
        color: border.width ? border.color : "",
        width: border.width,
        opacity: border.opacity,
        dashType: border.dashType,
        lineJoin: "round",
        lineCap: "round"
      },
      fill: {
        color: options2.background
      }
    });
    return gaugeArea;
  };
  Gauge2.prototype._initSurface = function _initSurface() {
    var ref2 = this;
    var options2 = ref2.options;
    var surface = ref2.surface;
    var element = this._surfaceElement();
    var size = this._surfaceSize();
    elementSize(element, size);
    if (!surface || surface.options.type !== options2.renderAs) {
      if (surface) {
        surface.destroy();
      }
      this.surface = Surface.create(element, {
        type: options2.renderAs
      });
    } else {
      this.surface.clear();
      this.surface.resize();
    }
  };
  Gauge2.prototype._surfaceSize = function _surfaceSize() {
    var options2 = this.options;
    var size = this._getSize();
    if (options2.gaugeArea) {
      deepExtend(size, options2.gaugeArea);
    }
    return size;
  };
  Gauge2.prototype._surfaceElement = function _surfaceElement() {
    if (!this.surfaceElement) {
      this.surfaceElement = document.createElement("div");
      this.element.appendChild(this.surfaceElement);
    }
    return this.surfaceElement;
  };
  Gauge2.prototype.getSize = function getSize() {
    return this._getSize();
  };
  Gauge2.prototype._getSize = function _getSize() {
    var element = this.element;
    var defaultSize = this._defaultSize();
    var width = element.offsetWidth;
    var height = element.offsetHeight;
    if (!width) {
      width = defaultSize.width;
    }
    if (!height) {
      height = defaultSize.height;
    }
    return { width, height };
  };
  Gauge2.prototype._defaultSize = function _defaultSize() {
    return {
      width: DEFAULT_WIDTH,
      height: DEFAULT_HEIGHT
    };
  };
  Gauge2.prototype._toggleTransitions = function _toggleTransitions(value2) {
    var this$1$1 = this;
    this.options.transitions = value2;
    for (var i16 = 0; i16 < this.pointers.length; i16++) {
      this$1$1.pointers[i16].options.animation.transitions = value2;
    }
  };
  return Gauge2;
}(Class$1);
setDefaultOptions(Gauge, {
  plotArea: {},
  theme: "default",
  renderAs: "",
  pointer: {},
  scale: {},
  gaugeArea: {}
});
var Path$4 = Path$7;
var Group$6 = Group$9;
var Point$4 = Point$7;
function renderAxisTick(tickRenderOptions, tickOptions) {
  var position2 = tickRenderOptions.position;
  var tickX = tickRenderOptions.tickX;
  var tickY = tickRenderOptions.tickY;
  var start, end;
  if (tickRenderOptions.vertical) {
    start = new Point$4(tickX, position2);
    end = new Point$4(tickX + tickOptions.size, position2);
  } else {
    start = new Point$4(position2, tickY);
    end = new Point$4(position2, tickY + tickOptions.size);
  }
  var tickPath = new Path$4({
    stroke: {
      color: tickOptions.color,
      width: tickOptions.width
    }
  }).moveTo(start).lineTo(end);
  return tickPath;
}
function renderTicks(tickGroup, tickPositions, tickRenderOptions, tickOptions) {
  var count = tickPositions.length;
  if (tickOptions.visible) {
    var mirror = tickRenderOptions.mirror;
    var lineBox = tickRenderOptions.lineBox;
    for (var i16 = tickOptions.skip; i16 < count; i16 += tickOptions.step) {
      if (i16 % tickOptions.skipUnit === 0) {
        continue;
      }
      tickRenderOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;
      tickRenderOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;
      tickRenderOptions.position = tickPositions[i16];
      tickGroup.append(renderAxisTick(tickRenderOptions, tickOptions));
    }
  }
}
var LinearScale = function(NumericAxis2) {
  function LinearScale2(options2, service) {
    var scaleOptions = options2 || {};
    if (!defined(scaleOptions.reverse) && scaleOptions.vertical === false && (service || {}).rtl) {
      scaleOptions = Object.assign({}, scaleOptions, {
        reverse: true
      });
    }
    NumericAxis2.call(this, 0, 1, scaleOptions, service);
    this.options.minorUnit = this.options.minorUnit || this.options.majorUnit / 10;
  }
  if (NumericAxis2)
    LinearScale2.__proto__ = NumericAxis2;
  LinearScale2.prototype = Object.create(NumericAxis2 && NumericAxis2.prototype);
  LinearScale2.prototype.constructor = LinearScale2;
  LinearScale2.prototype.initUserOptions = function initUserOptions(options2) {
    var scaleOptions = deepExtend({}, this.options, options2);
    scaleOptions = deepExtend({}, scaleOptions, { labels: { mirror: scaleOptions.mirror } });
    scaleOptions.majorUnit = scaleOptions.majorUnit || autoMajorUnit(scaleOptions.min, scaleOptions.max);
    return scaleOptions;
  };
  LinearScale2.prototype.initFields = function initFields() {
  };
  LinearScale2.prototype.render = function render() {
    var elements = this.elements = new Group$6();
    var labels = this.renderLabels();
    var scaleLine = this.renderLine();
    var scaleTicks = this.renderTicks();
    var ranges = this.renderRanges();
    elements.append(scaleLine, labels, scaleTicks, ranges);
    return elements;
  };
  LinearScale2.prototype.renderRanges = function renderRanges() {
    var this$1$1 = this;
    var options2 = this.options;
    var min2 = options2.min;
    var max2 = options2.max;
    var vertical = options2.vertical;
    var mirror = options2.labels.mirror;
    var ranges = options2.ranges || [];
    var elements = new Group$6();
    var count = ranges.length;
    var rangeSize = options2.rangeSize || options2.minorTicks.size / 2;
    for (var i16 = 0; i16 < count; i16++) {
      var range = getRange(ranges[i16], min2, max2);
      var slot = this$1$1.getSlot(range.from, range.to);
      var slotX = vertical ? this$1$1.lineBox() : slot;
      var slotY = vertical ? slot : this$1$1.lineBox();
      if (vertical) {
        slotX.x1 -= rangeSize * (mirror ? -1 : 1);
      } else {
        slotY.y2 += rangeSize * (mirror ? -1 : 1);
      }
      elements.append(Path$4.fromRect(new Rect$1([slotX.x1, slotY.y1], [slotX.x2 - slotX.x1, slotY.y2 - slotY.y1]), {
        fill: { color: range.color, opacity: range.opacity },
        stroke: {}
      }));
    }
    return elements;
  };
  LinearScale2.prototype.renderLabels = function renderLabels() {
    var ref2 = this;
    var labels = ref2.labels;
    var options2 = ref2.options;
    var elements = new Group$6();
    for (var i16 = 0; i16 < labels.length; i16++) {
      elements.append(buildLabelElement(labels[i16], options2.labels));
    }
    return elements;
  };
  LinearScale2.prototype.renderLine = function renderLine() {
    var line = this.options.line;
    var lineBox = this.lineBox();
    var elements = new Group$6();
    if (line.width > 0 && line.visible) {
      var linePath = new Path$4({
        stroke: {
          color: line.color,
          dashType: line.dashType,
          width: line.width
        }
      });
      linePath.moveTo(lineBox.x1, lineBox.y1).lineTo(lineBox.x2, lineBox.y2);
      elements.append(linePath);
    }
    return elements;
  };
  LinearScale2.prototype.renderTicks = function renderTicks$1() {
    var ticks = new Group$6();
    var options2 = this.options;
    var majorUnit = options2.majorTicks.visible ? options2.majorUnit : 0;
    var tickRenderOptions = {
      vertical: options2.vertical,
      mirror: options2.labels.mirror,
      lineBox: this.lineBox()
    };
    renderTicks(ticks, this.getMajorTickPositions(), tickRenderOptions, options2.majorTicks);
    renderTicks(ticks, this.getMinorTickPositions(), tickRenderOptions, deepExtend({}, {
      skipUnit: majorUnit / options2.minorUnit
    }, options2.minorTicks));
    return ticks;
  };
  return LinearScale2;
}(NumericAxis);
setDefaultOptions(LinearScale, {
  min: 0,
  max: 50,
  majorTicks: {
    size: 15,
    align: INSIDE$1,
    color: BLACK$1,
    width: DEFAULT_LINE_WIDTH,
    visible: true
  },
  minorTicks: {
    size: 10,
    align: INSIDE$1,
    color: BLACK$1,
    width: DEFAULT_LINE_WIDTH,
    visible: true
  },
  line: {
    width: DEFAULT_LINE_WIDTH
  },
  labels: {
    position: INSIDE$1,
    padding: 2
  },
  mirror: false,
  _alignLines: false
});
var Pointer = function(Class3) {
  function Pointer2(scale, userOptions) {
    Class3.call(this);
    var ref2 = scale.options;
    var min2 = ref2.min;
    var max2 = ref2.max;
    var options2 = this.options = deepExtend({}, this.options, userOptions);
    options2.fill = options2.color;
    this.scale = scale;
    if (defined(options2.value)) {
      options2.value = limitValue(options2.value, min2, max2);
    } else {
      options2.value = min2;
    }
  }
  if (Class3)
    Pointer2.__proto__ = Class3;
  Pointer2.prototype = Object.create(Class3 && Class3.prototype);
  Pointer2.prototype.constructor = Pointer2;
  Pointer2.prototype.value = function value2(newValue) {
    var options2 = this.options;
    var value3 = options2.value;
    if (arguments.length === 0) {
      return value3;
    }
    var ref2 = this.scale.options;
    var min2 = ref2.min;
    var max2 = ref2.max;
    options2._oldValue = defined(options2._oldValue) ? options2.value : min2;
    options2.value = limitValue(newValue, min2, max2);
    if (this.elements) {
      this.repaint();
    }
  };
  return Pointer2;
}(Class$1);
setDefaultOptions(Pointer, {
  color: BLACK$1
});
var LinearPointer = function(Pointer2) {
  function LinearPointer2(scale, options2) {
    Pointer2.call(this, scale, options2);
    this.options = deepExtend({
      track: {
        visible: defined(options2.track)
      }
    }, this.options);
  }
  if (Pointer2)
    LinearPointer2.__proto__ = Pointer2;
  LinearPointer2.prototype = Object.create(Pointer2 && Pointer2.prototype);
  LinearPointer2.prototype.constructor = LinearPointer2;
  LinearPointer2.prototype.reflow = function reflow() {
    var ref2 = this;
    var options2 = ref2.options;
    var scale = ref2.scale;
    var ref$1 = scale.options;
    var mirror = ref$1.mirror;
    var vertical = ref$1.vertical;
    var scaleLine = scale.lineBox();
    var trackSize = options2.track.size || options2.size;
    var pointerHalfSize = options2.size / 2;
    var margin = getSpacing(options2.margin);
    var space = vertical ? margin[mirror ? "left" : "right"] : margin[mirror ? "bottom" : "top"];
    var pointerBox, pointerRangeBox, trackBox;
    space = mirror ? -space : space;
    if (vertical) {
      trackBox = new Box(
        scaleLine.x1 + space,
        scaleLine.y1,
        scaleLine.x1 + space,
        scaleLine.y2
      );
      if (mirror) {
        trackBox.x1 -= trackSize;
      } else {
        trackBox.x2 += trackSize;
      }
      if (options2.shape !== BAR_POINTER) {
        pointerRangeBox = new Box(
          scaleLine.x2 + space,
          scaleLine.y1 - pointerHalfSize,
          scaleLine.x2 + space,
          scaleLine.y2 + pointerHalfSize
        );
        pointerBox = pointerRangeBox;
      }
    } else {
      trackBox = new Box(
        scaleLine.x1,
        scaleLine.y1 - space,
        scaleLine.x2,
        scaleLine.y1 - space
      );
      if (mirror) {
        trackBox.y2 += trackSize;
      } else {
        trackBox.y1 -= trackSize;
      }
      if (options2.shape !== BAR_POINTER) {
        pointerRangeBox = new Box(
          scaleLine.x1 - pointerHalfSize,
          scaleLine.y1 - space,
          scaleLine.x2 + pointerHalfSize,
          scaleLine.y1 - space
        );
        pointerBox = pointerRangeBox;
      }
    }
    this.trackBox = trackBox;
    this.pointerRangeBox = pointerRangeBox;
    this.box = pointerBox || trackBox.clone().pad(options2.border.width);
  };
  LinearPointer2.prototype.getElementOptions = function getElementOptions() {
    var options2 = this.options;
    return {
      fill: {
        color: options2.color,
        opacity: options2.opacity
      },
      stroke: defined(options2.border) ? {
        color: options2.border.width ? options2.border.color || options2.color : "",
        width: options2.border.width,
        dashType: options2.border.dashType,
        opacity: options2.opacity
      } : null
    };
  };
  LinearPointer2.prototype._margin = function _margin() {
    var ref2 = this;
    var scale = ref2.scale;
    var options2 = ref2.options;
    var ref$1 = scale.options;
    var mirror = ref$1.mirror;
    var vertical = ref$1.vertical;
    var margin = getSpacing(options2.margin);
    var space = vertical ? margin[mirror ? "left" : "right"] : margin[mirror ? "bottom" : "top"];
    return space;
  };
  return LinearPointer2;
}(Pointer);
setDefaultOptions(LinearPointer, {
  shape: BAR_POINTER,
  track: {
    border: {
      width: 1
    }
  },
  color: BLACK$1,
  border: {
    width: 1
  },
  opacity: 1,
  margin: getSpacing(3),
  animation: {
    type: BAR_POINTER
  },
  visible: true
});
var ArrowLinearPointerAnimation = function(superclass) {
  function ArrowLinearPointerAnimation2() {
    superclass.apply(this, arguments);
  }
  if (superclass)
    ArrowLinearPointerAnimation2.__proto__ = superclass;
  ArrowLinearPointerAnimation2.prototype = Object.create(superclass && superclass.prototype);
  ArrowLinearPointerAnimation2.prototype.constructor = ArrowLinearPointerAnimation2;
  ArrowLinearPointerAnimation2.prototype.setup = function setup() {
    var options2 = this.options;
    var margin = options2.margin;
    var from = options2.from;
    var to = options2.to;
    var vertical = options2.vertical;
    var axis = vertical ? "x1" : "y1";
    if (options2.mirror === vertical) {
      from[axis] -= margin;
      to[axis] -= margin;
    } else {
      from[axis] += margin;
      to[axis] += margin;
    }
    var fromScale = this.fromScale = new Point$7(from.x1, from.y1);
    var toScale = this.toScale = new Point$7(to.x1, to.y1);
    if (options2.duration !== 0) {
      options2.duration = Math.max(fromScale.distanceTo(toScale) / options2.duration * 1e3, 1);
    }
  };
  ArrowLinearPointerAnimation2.prototype.step = function step(pos) {
    var translateX = interpolateValue(this.fromScale.x, this.toScale.x, pos);
    var translateY = interpolateValue(this.fromScale.y, this.toScale.y, pos);
    this.element.transform(transform().translate(translateX, translateY));
  };
  return ArrowLinearPointerAnimation2;
}(Animation$2);
setDefaultOptions(ArrowLinearPointerAnimation, {
  easing: LINEAR,
  duration: LINEAR_SPEED
});
AnimationFactory$1.current.register(ARROW_POINTER, ArrowLinearPointerAnimation);
var Point$3 = Point$7;
var Path$3 = Path$7;
var ArrowLinearPointer = function(LinearPointer2) {
  function ArrowLinearPointer2(scale, options2) {
    LinearPointer2.call(this, scale, options2);
    if (!defined(this.options.size)) {
      this.options.size = this.scale.options.majorTicks.size * 0.6;
    }
  }
  if (LinearPointer2)
    ArrowLinearPointer2.__proto__ = LinearPointer2;
  ArrowLinearPointer2.prototype = Object.create(LinearPointer2 && LinearPointer2.prototype);
  ArrowLinearPointer2.prototype.constructor = ArrowLinearPointer2;
  ArrowLinearPointer2.prototype.pointerShape = function pointerShape() {
    var ref2 = this;
    var scale = ref2.scale;
    var size = ref2.options.size;
    var halfSize = size / 2;
    var sign = scale.options.mirror ? -1 : 1;
    var shape;
    if (scale.options.vertical) {
      shape = [
        new Point$3(0, 0 - halfSize),
        new Point$3(0 - sign * size, 0),
        new Point$3(0, 0 + halfSize)
      ];
    } else {
      shape = [
        new Point$3(0 - halfSize, 0),
        new Point$3(0, 0 + sign * size),
        new Point$3(0 + halfSize, 0)
      ];
    }
    return shape;
  };
  ArrowLinearPointer2.prototype.repaint = function repaint() {
    var ref2 = this;
    var scale = ref2.scale;
    var options2 = ref2.options;
    var animation = new ArrowLinearPointerAnimation(this.elements, deepExtend(options2.animation, {
      vertical: scale.options.vertical,
      mirror: scale.options.mirror,
      margin: this._margin(options2.margin),
      from: scale.getSlot(options2._oldValue),
      to: scale.getSlot(options2.value)
    }));
    if (options2.animation.transitions === false) {
      animation.options.duration = 0;
    }
    animation.setup();
    animation.play();
  };
  ArrowLinearPointer2.prototype.render = function render() {
    var ref2 = this;
    var scale = ref2.scale;
    var options2 = ref2.options;
    var elementOptions = this.getElementOptions();
    var shape = this.pointerShape(options2.value);
    options2.animation.type = ARROW_POINTER;
    var elements = new Path$3({
      stroke: elementOptions.stroke,
      fill: elementOptions.fill
    }).moveTo(shape[0]).lineTo(shape[1]).lineTo(shape[2]).close();
    var slot = scale.getSlot(options2.value);
    elements.transform(transform().translate(slot.x1, slot.y1));
    this.elements = elements;
    return elements;
  };
  return ArrowLinearPointer2;
}(LinearPointer);
var BarLinearPointerAnimation = function(superclass) {
  function BarLinearPointerAnimation2() {
    superclass.apply(this, arguments);
  }
  if (superclass)
    BarLinearPointerAnimation2.__proto__ = superclass;
  BarLinearPointerAnimation2.prototype = Object.create(superclass && superclass.prototype);
  BarLinearPointerAnimation2.prototype.constructor = BarLinearPointerAnimation2;
  BarLinearPointerAnimation2.prototype.setup = function setup() {
    var options2 = this.options;
    var axis = this.axis = options2.vertical ? Y$7 : X$4;
    var to = this.to = options2.newPoints[0][axis];
    var from = this.from = options2.oldPoints[0][axis];
    if (options2.duration !== 0) {
      options2.duration = Math.max(Math.abs(to - from) / options2.speed * 1e3, 1);
    }
    this._set(from);
  };
  BarLinearPointerAnimation2.prototype.step = function step(pos) {
    var value2 = interpolateValue(this.from, this.to, pos);
    this._set(value2);
  };
  BarLinearPointerAnimation2.prototype._set = function _set(value2) {
    var setter = "set" + this.axis.toUpperCase();
    var points2 = this.options.newPoints;
    points2[0][setter](value2);
    points2[1][setter](value2);
  };
  return BarLinearPointerAnimation2;
}(Animation$2);
setDefaultOptions(BarLinearPointerAnimation, {
  easing: LINEAR,
  speed: LINEAR_SPEED
});
AnimationFactory$1.current.register(BAR_POINTER, BarLinearPointerAnimation);
var Group$5 = Group$9;
var Path$2 = Path$7;
var BarLinearPointer = function(LinearPointer2) {
  function BarLinearPointer2(scale, options2) {
    LinearPointer2.call(this, scale, options2);
    if (!defined(this.options.size)) {
      this.options.size = this.scale.options.majorTicks.size * 0.3;
    }
  }
  if (LinearPointer2)
    BarLinearPointer2.__proto__ = LinearPointer2;
  BarLinearPointer2.prototype = Object.create(LinearPointer2 && LinearPointer2.prototype);
  BarLinearPointer2.prototype.constructor = BarLinearPointer2;
  BarLinearPointer2.prototype.pointerShape = function pointerShape(value2) {
    var ref2 = this;
    var scale = ref2.scale;
    var options2 = ref2.options;
    var ref$1 = scale.options;
    var mirror = ref$1.mirror;
    var vertical = ref$1.vertical;
    var dir = mirror === vertical ? -1 : 1;
    var size = options2.size * dir;
    var minSlot = scale.getSlot(scale.options.min);
    var slot = scale.getSlot(value2);
    var axis = vertical ? Y$7 : X$4;
    var sizeAxis = vertical ? X$4 : Y$7;
    var margin = this._margin() * dir;
    var p1 = new Point$7();
    p1[axis] = minSlot[axis + "1"];
    p1[sizeAxis] = minSlot[sizeAxis + "1"];
    var p22 = new Point$7();
    p22[axis] = slot[axis + "1"];
    p22[sizeAxis] = slot[sizeAxis + "1"];
    if (vertical) {
      p1.translate(margin, 0);
      p22.translate(margin, 0);
    } else {
      p1.translate(0, margin);
      p22.translate(0, margin);
    }
    var p32 = p22.clone();
    var p42 = p1.clone();
    if (vertical) {
      p32.translate(size, 0);
      p42.translate(size, 0);
    } else {
      p32.translate(0, size);
      p42.translate(0, size);
    }
    return [p1, p22, p32, p42];
  };
  BarLinearPointer2.prototype.repaint = function repaint() {
    var ref2 = this;
    var scale = ref2.scale;
    var options2 = ref2.options;
    var shape = this.pointerShape(options2.value);
    var pointerPath = this.pointerPath;
    var oldShape = this.pointerShape(options2._oldValue);
    pointerPath.moveTo(shape[0]).lineTo(shape[1]).lineTo(shape[2]).lineTo(shape[3]).close();
    var animation = new BarLinearPointerAnimation(pointerPath, deepExtend(options2.animation, {
      reverse: scale.options.reverse,
      vertical: scale.options.vertical,
      oldPoints: [oldShape[1], oldShape[2]],
      newPoints: [shape[1], shape[2]]
    }));
    if (options2.animation.transitions === false) {
      animation.options.duration = 0;
    }
    animation.setup();
    animation.play();
  };
  BarLinearPointer2.prototype.render = function render() {
    var group2 = new Group$5();
    var elementOptions = this.getElementOptions();
    if (this.options.track.visible) {
      group2.append(this.renderTrack());
    }
    var pointer = this.pointerPath = new Path$2({
      stroke: elementOptions.stroke,
      fill: elementOptions.fill
    });
    group2.append(pointer);
    this.elements = group2;
    return group2;
  };
  BarLinearPointer2.prototype.renderTrack = function renderTrack() {
    var trackOptions = this.options.track;
    var border = trackOptions.border || {};
    var trackBox = this.trackBox.clone().pad(border.width || 0);
    return new Path$2.fromRect(trackBox.toRect(), {
      fill: {
        color: trackOptions.color,
        opacity: trackOptions.opacity
      },
      stroke: {
        color: border.width ? border.color || trackOptions.color : "",
        width: border.width,
        dashType: border.dashType
      }
    });
  };
  return BarLinearPointer2;
}(LinearPointer);
var DEFAULT_MIN_WIDTH = 60;
var DEFAULT_MIN_HEIGHT = 60;
var Group$4 = Group$9;
var LinearGauge = function(Gauge2) {
  function LinearGauge2() {
    Gauge2.apply(this, arguments);
  }
  if (Gauge2)
    LinearGauge2.__proto__ = Gauge2;
  LinearGauge2.prototype = Object.create(Gauge2 && Gauge2.prototype);
  LinearGauge2.prototype.constructor = LinearGauge2;
  LinearGauge2.prototype.reflow = function reflow(bbox) {
    var pointers = this.pointers;
    var bboxX = bbox.origin.x;
    var bboxY = bbox.origin.y;
    var box = new Box(bboxX, bboxY, bboxX + bbox.width(), bboxY + bbox.height());
    this.scale.reflow(box);
    this._shrinkScaleWidth(box);
    for (var i16 = 0; i16 < pointers.length; i16++) {
      pointers[i16].reflow();
    }
    this.bbox = this._getBox(box);
    this._alignElements();
    this._shrinkElements();
    this._buildVisual();
    this._draw();
  };
  LinearGauge2.prototype._buildVisual = function _buildVisual() {
    var visuals = new Group$4();
    var scaleElements = this.scale.render();
    var pointers = this.pointers;
    visuals.append(this.gaugeArea);
    visuals.append(scaleElements);
    for (var i16 = 0; i16 < pointers.length; i16++) {
      var current2 = pointers[i16];
      visuals.append(current2.render());
      current2.value(current2.options.value);
    }
    this._visuals = visuals;
  };
  LinearGauge2.prototype._createModel = function _createModel() {
    var this$1$1 = this;
    var options2 = this.options;
    var scale = this.scale = new LinearScale(options2.scale, this.contextService);
    this.pointers = [];
    var pointers = options2.pointer;
    pointers = isArray$1(pointers) ? pointers : [pointers];
    for (var i16 = 0; i16 < pointers.length; i16++) {
      var currentOptions = deepExtend({}, pointers[i16], {
        animation: {
          transitions: options2.transitions
        }
      });
      var pointerType = currentOptions.shape === ARROW ? ArrowLinearPointer : BarLinearPointer;
      this$1$1.pointers.push(new pointerType(scale, currentOptions));
    }
  };
  LinearGauge2.prototype._defaultSize = function _defaultSize() {
    var vertical = this.options.scale.vertical;
    return {
      width: vertical ? DEFAULT_MIN_WIDTH : DEFAULT_WIDTH,
      height: vertical ? DEFAULT_HEIGHT : DEFAULT_MIN_HEIGHT
    };
  };
  LinearGauge2.prototype._getBox = function _getBox(box) {
    var ref2 = this;
    var scale = ref2.scale;
    var pointers = ref2.pointers;
    var boxCenter = box.center();
    var plotAreaBox = pointers[0].box.clone().wrap(scale.box);
    for (var i16 = 0; i16 < pointers.length; i16++) {
      plotAreaBox.wrap(pointers[i16].box.clone());
    }
    var size;
    if (scale.options.vertical) {
      size = plotAreaBox.width() / 2;
      plotAreaBox = new Box(
        boxCenter.x - size,
        box.y1,
        boxCenter.x + size,
        box.y2
      );
    } else {
      size = plotAreaBox.height() / 2;
      plotAreaBox = new Box(
        box.x1,
        boxCenter.y - size,
        box.x2,
        boxCenter.y + size
      );
    }
    return plotAreaBox;
  };
  LinearGauge2.prototype._alignElements = function _alignElements() {
    var this$1$1 = this;
    var ref2 = this;
    var scale = ref2.scale;
    var pointers = ref2.pointers;
    var scaleBox = scale.box;
    var box = pointers[0].box.clone().wrap(scale.box);
    var plotAreaBox = this.bbox;
    for (var i16 = 0; i16 < pointers.length; i16++) {
      box.wrap(pointers[i16].box.clone());
    }
    var diff;
    if (scale.options.vertical) {
      diff = plotAreaBox.center().x - box.center().x;
      scale.reflow(new Box(
        scaleBox.x1 + diff,
        plotAreaBox.y1,
        scaleBox.x2 + diff,
        plotAreaBox.y2
      ));
    } else {
      diff = plotAreaBox.center().y - box.center().y;
      scale.reflow(new Box(
        scaleBox.x1,
        scaleBox.y1 + diff,
        scaleBox.x2,
        scaleBox.y2 + diff
      ));
    }
    for (var i$12 = 0; i$12 < pointers.length; i$12++) {
      pointers[i$12].reflow(this$1$1.bbox);
    }
  };
  LinearGauge2.prototype._shrinkScaleWidth = function _shrinkScaleWidth(bbox) {
    var ref2 = this;
    var scale = ref2.scale;
    if (!scale.options.vertical) {
      var overflow = scale.contentBox().width() - bbox.width();
      if (overflow > 0) {
        scale.box.shrink(overflow, 0);
        scale.box.alignTo(bbox, "center");
        scale.reflow(scale.box);
      }
    }
  };
  LinearGauge2.prototype._shrinkElements = function _shrinkElements() {
    var this$1$1 = this;
    var ref2 = this;
    var scale = ref2.scale;
    var pointers = ref2.pointers;
    var scaleBox = scale.box.clone();
    var pos = scale.options.vertical ? "y" : "x";
    var pointerBox = pointers[0].box;
    for (var i16 = 0; i16 < pointers.length; i16++) {
      pointerBox.wrap(pointers[i16].box.clone());
    }
    scaleBox[pos + 1] += Math.max(scaleBox[pos + 1] - pointerBox[pos + 1], 0);
    scaleBox[pos + 2] -= Math.max(pointerBox[pos + 2] - scaleBox[pos + 2], 0);
    scale.reflow(scaleBox);
    for (var i$12 = 0; i$12 < pointers.length; i$12++) {
      pointers[i$12].reflow(this$1$1.bbox);
    }
  };
  return LinearGauge2;
}(Gauge);
setDefaultOptions(LinearGauge, {
  transitions: true,
  gaugeArea: {
    background: ""
  },
  scale: {
    vertical: true
  }
});
var GEO_ARC_ADJUST_ANGLE = 180;
var Arc = Arc$2;
var Path$1 = Path$7;
var Group$3 = Group$9;
function drawTicks(arc, tickAngles, unit2, tickOptions) {
  var ticks = new Group$3();
  var center = arc.center;
  var radius = arc.getRadiusX();
  if (tickOptions.visible) {
    for (var i16 = 0; i16 < tickAngles.length; i16++) {
      var tickStart = arc.pointAt(tickAngles[i16]);
      var tickEnd = new Point$7(center.x + radius - tickOptions.size, center.y).rotate(tickAngles[i16], center);
      ticks.append(new Path$1({
        stroke: {
          color: tickOptions.color,
          width: tickOptions.width
        }
      }).moveTo(tickStart).lineTo(tickEnd));
    }
  }
  return ticks;
}
function rangeSegment(from, to, color, opacity) {
  return { from, to, color, opacity };
}
var RadialScale = function(NumericAxis2) {
  function RadialScale2(options2, service) {
    NumericAxis2.call(this, 0, 1, options2, service);
  }
  if (NumericAxis2)
    RadialScale2.__proto__ = NumericAxis2;
  RadialScale2.prototype = Object.create(NumericAxis2 && NumericAxis2.prototype);
  RadialScale2.prototype.constructor = RadialScale2;
  RadialScale2.prototype.initUserOptions = function initUserOptions(options2) {
    var scaleOptions = deepExtend({}, this.options, options2);
    scaleOptions.majorUnit = scaleOptions.majorUnit || autoMajorUnit(scaleOptions.min, scaleOptions.max);
    scaleOptions.minorUnit = scaleOptions.minorUnit || scaleOptions.majorUnit / 10;
    return scaleOptions;
  };
  RadialScale2.prototype.initFields = function initFields() {
  };
  RadialScale2.prototype.render = function render(center, radius) {
    var arc = this.renderArc(center, radius);
    this.bbox = arc.bbox();
    this.labelElements = this.renderLabels();
    this.ticks = this.renderTicks();
    this.ranges = this.renderRanges();
  };
  RadialScale2.prototype.reflow = function reflow(bbox) {
    var center = bbox.center();
    var radius = Math.min(bbox.height(), bbox.width()) / 2;
    if (defined(this.bbox)) {
      this.bbox = this.arc.bbox();
      this.radius(this.arc.getRadiusX());
      this.repositionRanges();
      this.renderLabels();
    } else {
      return this.render(center, radius);
    }
  };
  RadialScale2.prototype.slotAngle = function slotAngle(value2) {
    var ref2 = this.options;
    var min2 = ref2.min;
    var max2 = ref2.max;
    var reverse = ref2.reverse;
    var startAngle = ref2.startAngle;
    var endAngle = ref2.endAngle;
    var angle = endAngle - startAngle;
    var result;
    if (reverse) {
      result = endAngle - (value2 - min2) / (max2 - min2) * angle;
    } else {
      result = (value2 - min2) / (max2 - min2) * angle + startAngle;
    }
    return result + GEO_ARC_ADJUST_ANGLE;
  };
  RadialScale2.prototype.hasRanges = function hasRanges() {
    var ranges = this.options.ranges;
    return ranges && ranges.length;
  };
  RadialScale2.prototype.ticksSize = function ticksSize() {
    var ref2 = this.options;
    var majorTicks = ref2.majorTicks;
    var minorTicks = ref2.minorTicks;
    var size = 0;
    if (majorTicks.visible) {
      size = majorTicks.size;
    }
    if (minorTicks.visible) {
      size = Math.max(minorTicks.size, size);
    }
    return size;
  };
  RadialScale2.prototype.labelsCount = function labelsCount() {
    var count = NumericAxis2.prototype.labelsCount.call(this);
    var options2 = this.options;
    var angle = options2.endAngle - options2.startAngle;
    if (angle >= 360 && options2.max % options2.majorUnit === 0) {
      count -= 1;
    }
    return count;
  };
  RadialScale2.prototype.renderLabels = function renderLabels() {
    var this$1$1 = this;
    var options2 = this.options;
    var arc = this.arc.clone();
    var radius = arc.getRadiusX();
    var tickAngles = this.tickAngles(arc, options2.majorUnit);
    var rangeSize = options2.rangeSize = options2.rangeSize || radius * 0.1;
    var labelsGroup = new Group$3();
    var rangeDistance = radius * 0.05;
    if (defined(options2.rangeDistance)) {
      rangeDistance = options2.rangeDistance;
    } else {
      options2.rangeDistance = rangeDistance;
    }
    var labelsOptions = options2.labels;
    var isInside = labelsOptions.position === INSIDE$1;
    var hasLabelElements = defined(this.labelElements);
    if (isInside) {
      radius -= this.ticksSize();
      if (this.hasRanges() && !hasLabelElements) {
        radius -= rangeSize + rangeDistance;
      }
      arc.setRadiusX(radius).setRadiusY(radius);
    }
    var labels = this.labels;
    var count = labels.length;
    var padding = getSpacing(labelsOptions.padding);
    var paddingWidth = (padding.left + padding.right) / 2;
    var paddingHeight = (padding.top + padding.bottom) / 2;
    for (var i16 = 0; i16 < count; i16++) {
      var label = labels[i16];
      var halfWidth = label.box.width() / 2;
      var halfHeight = label.box.height() / 2;
      var angle = tickAngles[i16];
      var labelAngle = (angle - GEO_ARC_ADJUST_ANGLE) * DEGREE;
      var lp = arc.pointAt(angle);
      var cx = lp.x + Math.cos(labelAngle) * (halfWidth + paddingWidth) * (isInside ? 1 : -1);
      var cy = lp.y + Math.sin(labelAngle) * (halfHeight + paddingHeight) * (isInside ? 1 : -1);
      label.reflow(new Box(cx - halfWidth, cy - halfHeight, cx + halfWidth, cy + halfHeight));
      var labelPos = new Point$7(label.box.x1, label.box.y1);
      var labelElement = void 0;
      if (!hasLabelElements) {
        labelElement = buildLabelElement(label, options2.labels);
        labelsGroup.append(labelElement);
      } else {
        labelElement = this$1$1.labelElements.children[i16];
        var prevLabelPos = labelElement.bbox().origin;
        var labelTransform = labelElement.transform() || transform();
        labelTransform.translate(labelPos.x - prevLabelPos.x, labelPos.y - prevLabelPos.y);
        labelElement.transform(labelTransform);
      }
      this$1$1.bbox = Rect$1.union(this$1$1.bbox, labelElement.bbox());
    }
    return labelsGroup;
  };
  RadialScale2.prototype.repositionRanges = function repositionRanges() {
    var ranges = this.ranges.children;
    if (ranges.length > 0) {
      var ref2 = this.options;
      var rangeDistance = ref2.rangeDistance;
      var rangeSize = ref2.rangeSize;
      var rangeRadius = this.getRangeRadius();
      if (this.options.labels.position === INSIDE$1) {
        rangeRadius += rangeSize + rangeDistance;
      }
      var newRadius = rangeRadius + rangeSize / 2;
      for (var i16 = 0; i16 < ranges.length; i16++) {
        ranges[i16]._geometry.setRadiusX(newRadius).setRadiusY(newRadius);
      }
      this.bbox = Rect$1.union(this.bbox, this.ranges.bbox());
    }
  };
  RadialScale2.prototype.renderRanges = function renderRanges() {
    var this$1$1 = this;
    var segments = this.rangeSegments();
    var segmentsCount = segments.length;
    var result = new Group$3();
    if (segmentsCount) {
      var ref2 = this.options;
      var rangeSize = ref2.rangeSize;
      var reverse = ref2.reverse;
      var rangeDistance = ref2.rangeDistance;
      var rangeRadius = this.getRangeRadius();
      this.radius(this.radius() - rangeSize - rangeDistance);
      for (var i16 = 0; i16 < segmentsCount; i16++) {
        var segment = segments[i16];
        var from = this$1$1.slotAngle(segment[reverse ? "to" : "from"]);
        var to = this$1$1.slotAngle(segment[!reverse ? "to" : "from"]);
        if (to - from !== 0) {
          result.append(this$1$1.createRange(from, to, rangeRadius, segment));
        }
      }
    }
    return result;
  };
  RadialScale2.prototype.createRange = function createRange(startAngle, endAngle, rangeRadius, options2) {
    var rangeSize = this.options.rangeSize;
    var rangeGeom = new GeometryArc(this.arc.center, {
      radiusX: rangeRadius + rangeSize / 2,
      radiusY: rangeRadius + rangeSize / 2,
      startAngle,
      endAngle
    });
    return new Arc(rangeGeom, {
      stroke: {
        width: rangeSize,
        color: options2.color,
        opacity: options2.opacity,
        lineCap: options2.lineCap
      }
    });
  };
  RadialScale2.prototype.rangeSegments = function rangeSegments() {
    var options2 = this.options;
    var ranges = options2.ranges || [];
    var count = ranges.length;
    var segments = [];
    if (count) {
      var min2 = options2.min;
      var max2 = options2.max;
      var defaultColor = options2.rangePlaceholderColor;
      segments.push(rangeSegment(min2, max2, defaultColor));
      for (var i16 = 0; i16 < count; i16++) {
        var range = getRange(ranges[i16], min2, max2);
        var segmentsCount = segments.length;
        for (var j2 = 0; j2 < segmentsCount; j2++) {
          var segment = segments[j2];
          if (segment.from <= range.from && range.from <= segment.to) {
            segments.push(rangeSegment(range.from, range.to, range.color, range.opacity));
            if (segment.from <= range.to && range.to <= segment.to) {
              segments.push(rangeSegment(range.to, segment.to, defaultColor, range.opacity));
            }
            segment.to = range.from;
            break;
          }
        }
      }
    }
    return segments;
  };
  RadialScale2.prototype.getRangeRadius = function getRangeRadius() {
    var ref2 = this;
    var arc = ref2.arc;
    var options2 = ref2.options;
    var rangeSize = options2.rangeSize;
    var rangeDistance = options2.rangeDistance;
    var majorTickSize = options2.majorTicks.size;
    var radius;
    if (options2.labels.position === OUTSIDE) {
      radius = arc.getRadiusX() - majorTickSize - rangeDistance - rangeSize;
    } else {
      radius = arc.getRadiusX() - rangeSize;
    }
    return radius;
  };
  RadialScale2.prototype.renderArc = function renderArc(center, radius) {
    var options2 = this.options;
    var arc = this.arc = new GeometryArc(center, {
      radiusX: radius,
      radiusY: radius,
      startAngle: options2.startAngle + GEO_ARC_ADJUST_ANGLE,
      endAngle: options2.endAngle + GEO_ARC_ADJUST_ANGLE
    });
    return arc;
  };
  RadialScale2.prototype.renderTicks = function renderTicks2() {
    var ref2 = this;
    var arc = ref2.arc;
    var options2 = ref2.options;
    var tickArc = arc.clone();
    this.majorTickAngles = this.tickAngles(arc, options2.majorUnit);
    this.majorTicks = drawTicks(tickArc, this.majorTickAngles, options2.majorUnit, options2.majorTicks);
    var allTicks = new Group$3();
    allTicks.append(this.majorTicks);
    var majorTickSize = options2.majorTicks.size;
    var minorTickSize = options2.minorTicks.size;
    this._tickDifference = majorTickSize - minorTickSize;
    if (options2.labels.position === OUTSIDE) {
      var radius = tickArc.getRadiusX();
      tickArc.setRadiusX(radius - majorTickSize + minorTickSize).setRadiusY(radius - majorTickSize + minorTickSize);
    }
    this.minorTickAngles = this.normalizeTickAngles(this.tickAngles(arc, options2.minorUnit));
    this.minorTicks = drawTicks(tickArc, this.minorTickAngles, options2.minorUnit, options2.minorTicks);
    allTicks.append(this.minorTicks);
    return allTicks;
  };
  RadialScale2.prototype.normalizeTickAngles = function normalizeTickAngles(angles) {
    var options2 = this.options;
    var skip = options2.majorUnit / options2.minorUnit;
    for (var i16 = angles.length - 1; i16 >= 0; i16--) {
      if (i16 % skip === 0) {
        angles.splice(i16, 1);
      }
    }
    return angles;
  };
  RadialScale2.prototype.tickAngles = function tickAngles(ring, stepValue) {
    var options2 = this.options;
    var reverse = options2.reverse;
    var range = options2.max - options2.min;
    var angle = ring.endAngle - ring.startAngle;
    var tickCount = range / stepValue;
    var pos = ring.startAngle;
    var step = angle / tickCount;
    if (reverse) {
      pos += angle;
      step = -step;
    }
    if (angle >= 360 && options2.max % stepValue === 0) {
      tickCount -= 1;
    }
    var positions = [];
    for (var i16 = 0; i16 < tickCount; i16++) {
      positions.push(round$1(pos, COORD_PRECISION));
      pos += step;
    }
    if (round$1(pos) <= ring.endAngle) {
      positions.push(pos);
    }
    return positions;
  };
  RadialScale2.prototype.radius = function radius(value2) {
    if (value2) {
      this.arc.setRadiusX(value2).setRadiusY(value2);
      this.repositionTicks(this.majorTicks.children, this.majorTickAngles);
      this.repositionTicks(this.minorTicks.children, this.minorTickAngles, true);
    } else {
      return this.arc.getRadiusX();
    }
  };
  RadialScale2.prototype.repositionTicks = function repositionTicks(ticks, tickAngles, minor) {
    var diff = minor ? this._tickDifference || 0 : 0;
    var tickArc = this.arc;
    var radius = tickArc.getRadiusX();
    if (minor && this.options.labels.position === OUTSIDE && diff !== 0) {
      tickArc = this.arc.clone();
      tickArc.setRadiusX(radius - diff).setRadiusY(radius - diff);
    }
    for (var i16 = 0; i16 < ticks.length; i16++) {
      var newPoint = tickArc.pointAt(tickAngles[i16]);
      var segments = ticks[i16].segments;
      var xDiff = newPoint.x - segments[0].anchor().x;
      var yDiff = newPoint.y - segments[0].anchor().y;
      ticks[i16].transform(new transform().translate(xDiff, yDiff));
    }
  };
  return RadialScale2;
}(NumericAxis);
setDefaultOptions(RadialScale, {
  min: 0,
  max: 100,
  majorTicks: {
    size: 15,
    align: INSIDE$1,
    color: BLACK$1,
    width: DEFAULT_LINE_WIDTH,
    visible: true
  },
  minorTicks: {
    size: 10,
    align: INSIDE$1,
    color: BLACK$1,
    width: DEFAULT_LINE_WIDTH,
    visible: true
  },
  startAngle: -30,
  endAngle: 210,
  labels: {
    position: INSIDE$1,
    padding: 2
  }
});
var RadialPointerAnimation = function(superclass) {
  function RadialPointerAnimation2(element, options2) {
    superclass.call(this, element, options2);
    var animationOptions = this.options;
    animationOptions.duration = Math.max(Math.abs(animationOptions.newAngle - animationOptions.oldAngle) / animationOptions.duration * 1e3, 1);
  }
  if (superclass)
    RadialPointerAnimation2.__proto__ = superclass;
  RadialPointerAnimation2.prototype = Object.create(superclass && superclass.prototype);
  RadialPointerAnimation2.prototype.constructor = RadialPointerAnimation2;
  RadialPointerAnimation2.prototype.step = function step(pos) {
    var options2 = this.options;
    var angle = interpolateValue(options2.oldAngle, options2.newAngle, pos);
    this.element.transform(transform().rotate(angle, options2.center));
  };
  return RadialPointerAnimation2;
}(Animation$2);
setDefaultOptions(RadialPointerAnimation, {
  easing: LINEAR,
  duration: ANGULAR_SPEED
});
AnimationFactory$1.current.register(RADIAL_POINTER, RadialPointerAnimation);
var CAP_SIZE = 0.05;
var Circle$1 = Circle$3;
var Group$2 = Group$9;
var Path = Path$7;
var RadialPointer = function(Pointer2) {
  function RadialPointer2() {
    Pointer2.apply(this, arguments);
  }
  if (Pointer2)
    RadialPointer2.__proto__ = Pointer2;
  RadialPointer2.prototype = Object.create(Pointer2 && Pointer2.prototype);
  RadialPointer2.prototype.constructor = RadialPointer2;
  RadialPointer2.prototype.setAngle = function setAngle(angle) {
    this.elements.transform(transform().rotate(angle, this.center));
  };
  RadialPointer2.prototype.repaint = function repaint() {
    var ref2 = this;
    var scale = ref2.scale;
    var options2 = ref2.options;
    var oldAngle = scale.slotAngle(options2._oldValue);
    var newAngle = scale.slotAngle(options2.value);
    if (options2.animation.transitions === false) {
      this.setAngle(newAngle);
    } else {
      new RadialPointerAnimation(this.elements, deepExtend(options2.animation, {
        oldAngle,
        newAngle
      })).play();
    }
  };
  RadialPointer2.prototype.render = function render() {
    var ref2 = this;
    var scale = ref2.scale;
    var options2 = ref2.options;
    var elements = new Group$2();
    if (options2.animation !== false) {
      deepExtend(options2.animation, {
        startAngle: 0,
        center: scale.arc.center,
        reverse: scale.options.reverse
      });
    }
    elements.append(this._renderNeedle(), this._renderCap());
    this.elements = elements;
    this.setAngle(DEGREE);
    return elements;
  };
  RadialPointer2.prototype.reflow = function reflow(arc) {
    var center = this.center = arc.center;
    var length = limitValue(this.options.length || 1, 0.1, 1.5);
    var radius = this.radius = arc.getRadiusX() * length;
    var capSize = this.capSize = Math.round(radius * this.options.cap.size);
    this.bbox = Rect$1.fromPoints(
      new Point$7(center.x - capSize, center.y - capSize),
      new Point$7(center.x + capSize, center.y + capSize)
    );
  };
  RadialPointer2.prototype._renderNeedle = function _renderNeedle() {
    var minorTickSize = this.scale.options.minorTicks.size;
    var center = this.center;
    var needleColor = this.options.color;
    var needlePath = new Path({
      fill: { color: needleColor },
      stroke: { color: needleColor, width: DEFAULT_LINE_WIDTH }
    });
    needlePath.moveTo(center.x + this.radius - minorTickSize, center.y).lineTo(center.x, center.y - this.capSize / 2).lineTo(center.x, center.y + this.capSize / 2).close();
    return needlePath;
  };
  RadialPointer2.prototype._renderCap = function _renderCap() {
    var options2 = this.options;
    var capColor = options2.cap.color || options2.color;
    var circle = new geomCircle(this.center, this.capSize);
    var cap = new Circle$1(circle, {
      fill: { color: capColor },
      stroke: { color: capColor }
    });
    return cap;
  };
  return RadialPointer2;
}(Pointer);
setDefaultOptions(RadialPointer, {
  cap: {
    size: CAP_SIZE
  },
  arrow: {
    width: 16,
    height: 14
  },
  animation: {
    type: RADIAL_POINTER,
    duration: ANGULAR_SPEED
  }
});
var Group$1 = Group$9;
var RadialGauge = function(Gauge2) {
  function RadialGauge2() {
    Gauge2.apply(this, arguments);
  }
  if (Gauge2)
    RadialGauge2.__proto__ = Gauge2;
  RadialGauge2.prototype = Object.create(Gauge2 && Gauge2.prototype);
  RadialGauge2.prototype.constructor = RadialGauge2;
  RadialGauge2.prototype.reflow = function reflow(bbox) {
    var this$1$1 = this;
    var pointers = this.pointers;
    this.scale.reflow(bbox);
    this._initialPlotArea = this.scale.bbox;
    for (var i16 = 0; i16 < pointers.length; i16++) {
      pointers[i16].reflow(this$1$1.scale.arc);
      this$1$1._initialPlotArea = Rect$1.union(this$1$1._initialPlotArea, pointers[i16].bbox);
    }
    this.fitScale(bbox);
    this.alignScale(bbox);
    this._buildVisual(this.gaugeArea, pointers, this.scale);
    this._draw();
  };
  RadialGauge2.prototype._buildVisual = function _buildVisual(gaugeArea, pointers, scale) {
    var visuals = this._visuals = new Group$1();
    visuals.append(gaugeArea);
    visuals.append(scale.ticks);
    visuals.append(scale.ranges);
    this._buildPointers(pointers);
    visuals.append(scale.labelElements);
  };
  RadialGauge2.prototype._buildPointers = function _buildPointers(pointers) {
    var this$1$1 = this;
    for (var i16 = 0; i16 < pointers.length; i16++) {
      var current2 = pointers[i16];
      current2.render();
      this$1$1._visuals.append(current2.elements);
      current2.value(current2.options.value);
    }
  };
  RadialGauge2.prototype.fitScale = function fitScale(bbox) {
    var this$1$1 = this;
    var arc = this.scale.arc;
    var plotAreaBox = this._initialPlotArea;
    var step = Math.abs(this.getDiff(plotAreaBox, bbox));
    var min2 = round$1(step, COORD_PRECISION);
    var max2 = round$1(-step, COORD_PRECISION);
    var minDiff, midDiff, maxDiff, mid, oldDiff;
    var staleFlag = 0;
    var i16 = 0;
    while (i16++ < 100) {
      staleFlag = oldDiff === maxDiff ? staleFlag + 1 : 0;
      if (staleFlag > 5) {
        break;
      }
      if (min2 !== mid) {
        minDiff = this$1$1.getPlotBox(min2, bbox, arc);
        if (0 <= minDiff && minDiff <= 2) {
          break;
        }
      }
      if (max2 !== mid) {
        maxDiff = this$1$1.getPlotBox(max2, bbox, arc);
        if (0 <= maxDiff && maxDiff <= 2) {
          break;
        }
      }
      if (minDiff > 0 && maxDiff > 0) {
        mid = min2 * 2;
      } else if (minDiff < 0 && maxDiff < 0) {
        mid = max2 * 2;
      } else {
        mid = round$1((min2 + max2) / 2 || 1, COORD_PRECISION);
      }
      midDiff = this$1$1.getPlotBox(mid, bbox, arc);
      if (0 <= midDiff && midDiff <= 2) {
        break;
      }
      oldDiff = maxDiff;
      if (midDiff > 0) {
        max2 = mid;
        maxDiff = midDiff;
      } else {
        min2 = mid;
        minDiff = midDiff;
      }
    }
  };
  RadialGauge2.prototype.getPlotBox = function getPlotBox(step, bbox, arc) {
    var this$1$1 = this;
    var scale = this.scale;
    var pointers = this.pointers;
    var radius = arc.getRadiusX();
    var scaleArc = arc.clone();
    scaleArc.setRadiusX(radius + step).setRadiusY(radius + step);
    scale.arc = scaleArc;
    scale.reflow(bbox);
    this.plotBbox = scale.bbox;
    for (var i16 = 0; i16 < pointers.length; i16++) {
      pointers[i16].reflow(scaleArc);
      this$1$1.plotBbox = Rect$1.union(this$1$1.plotBbox, pointers[i16].bbox);
    }
    return this.getDiff(this.plotBbox, bbox);
  };
  RadialGauge2.prototype.getDiff = function getDiff(plotBox, box) {
    return Math.min(box.width() - plotBox.width(), box.height() - plotBox.height());
  };
  RadialGauge2.prototype.alignScale = function alignScale(bbox) {
    var this$1$1 = this;
    var plotBoxCenter = this.plotBbox.center();
    var boxCenter = bbox.center();
    var paddingX = plotBoxCenter.x - boxCenter.x;
    var paddingY = plotBoxCenter.y - boxCenter.y;
    var ref2 = this;
    var scale = ref2.scale;
    var pointers = ref2.pointers;
    scale.arc.center.x -= paddingX;
    scale.arc.center.y -= paddingY;
    scale.reflow(bbox);
    for (var i16 = 0; i16 < pointers.length; i16++) {
      pointers[i16].reflow(scale.arc);
      this$1$1.plotBbox = Rect$1.union(scale.bbox, pointers[i16].bbox);
    }
  };
  RadialGauge2.prototype._createModel = function _createModel() {
    var this$1$1 = this;
    var options2 = this.options;
    var pointers = options2.pointer;
    var scale = this.scale = new RadialScale(options2.scale, this.contextService);
    this.pointers = [];
    var pointersArr = isArray$1(pointers) ? pointers : [pointers];
    for (var i16 = 0; i16 < pointersArr.length; i16++) {
      var current2 = new RadialPointer(scale, deepExtend({}, pointersArr[i16], {
        animation: {
          transitions: options2.transitions
        }
      }));
      this$1$1.pointers.push(current2);
    }
  };
  return RadialGauge2;
}(Gauge);
setDefaultOptions(RadialGauge, {
  transitions: true,
  gaugeArea: {
    background: ""
  }
});
var ArcScale = function(RadialScale2) {
  function ArcScale2() {
    RadialScale2.apply(this, arguments);
  }
  if (RadialScale2)
    ArcScale2.__proto__ = RadialScale2;
  ArcScale2.prototype = Object.create(RadialScale2 && RadialScale2.prototype);
  ArcScale2.prototype.constructor = ArcScale2;
  ArcScale2.prototype.rangeSegments = function rangeSegments() {
    var ref2 = this.options;
    var min2 = ref2.min;
    var max2 = ref2.max;
    var rangePlaceholderColor = ref2.rangePlaceholderColor;
    var rangeLineCap = ref2.rangeLineCap;
    return [{ from: min2, to: max2, color: rangePlaceholderColor, lineCap: rangeLineCap }];
  };
  ArcScale2.prototype.hasRanges = function hasRanges() {
    return true;
  };
  ArcScale2.prototype.placeholderRangeAngle = function placeholderRangeAngle(angle) {
    var geometry = this.ranges.children[0].geometry();
    if (this.options.reverse) {
      geometry.setEndAngle(angle);
    } else {
      geometry.setStartAngle(angle);
    }
  };
  ArcScale2.prototype.addRange = function addRange(from, to, options2) {
    var reverse = this.options.reverse;
    var startAngle = this.slotAngle(reverse ? to : from);
    var endAngle = this.slotAngle(reverse ? from : to);
    var range = this.createRange(startAngle, endAngle, this.getRangeRadius(), options2);
    this.ranges.append(range);
    return range;
  };
  return ArcScale2;
}(RadialScale);
setDefaultOptions(ArcScale, {
  min: 0,
  max: 100,
  majorTicks: {
    visible: false
  },
  minorTicks: {
    visible: false
  },
  labels: {
    visible: false
  },
  startAngle: 0,
  endAngle: 180,
  rangeLineCap: "round"
});
var MAX_DURATION = 800;
var RangePointerAnimation = function(superclass) {
  function RangePointerAnimation2(element, options2) {
    superclass.call(this, element, options2);
    var animationOptions = this.options;
    var duration2 = Math.abs(animationOptions.newAngle - animationOptions.oldAngle) / animationOptions.duration * 1e3;
    animationOptions.duration = limitValue(duration2, ANGULAR_SPEED, MAX_DURATION);
    var startColor = element.elements.options.get("stroke.color");
    var color = element.currentColor();
    if (startColor !== color) {
      this.startColor = new m$e(startColor);
      this.color = new m$e(color);
    }
  }
  if (superclass)
    RangePointerAnimation2.__proto__ = superclass;
  RangePointerAnimation2.prototype = Object.create(superclass && superclass.prototype);
  RangePointerAnimation2.prototype.constructor = RangePointerAnimation2;
  RangePointerAnimation2.prototype.step = function step(pos) {
    var ref2 = this;
    var options2 = ref2.options;
    var startColor = ref2.startColor;
    var color = ref2.color;
    var angle = interpolateValue(options2.oldAngle, options2.newAngle, pos);
    this.element.angle(angle);
    if (color) {
      var r12 = round$1(interpolateValue(startColor.r, color.r, pos));
      var g6 = round$1(interpolateValue(startColor.g, color.g, pos));
      var b2 = round$1(interpolateValue(startColor.b, color.b, pos));
      this.element.stroke(new m$e(r12, g6, b2).toHex());
    }
  };
  return RangePointerAnimation2;
}(Animation$2);
setDefaultOptions(RangePointerAnimation, {
  easing: LINEAR,
  duration: ANGULAR_SPEED
});
AnimationFactory$1.current.register(RADIAL_RANGE_POINTER, RangePointerAnimation);
var RangePointer = function(Pointer2) {
  function RangePointer2() {
    Pointer2.apply(this, arguments);
  }
  if (Pointer2)
    RangePointer2.__proto__ = Pointer2;
  RangePointer2.prototype = Object.create(Pointer2 && Pointer2.prototype);
  RangePointer2.prototype.constructor = RangePointer2;
  RangePointer2.prototype.repaint = function repaint() {
    var ref2 = this;
    var scale = ref2.scale;
    var options2 = ref2.options;
    var oldAngle = scale.slotAngle(options2._oldValue);
    var newAngle = scale.slotAngle(options2.value);
    if (this.animation) {
      this.animation.abort();
    }
    if (options2.animation.transitions === false) {
      this.angle(newAngle);
      this.stroke(this.currentColor());
    } else {
      this.animation = new RangePointerAnimation(this, deepExtend(options2.animation, {
        oldAngle,
        newAngle
      }));
      this.animation.play();
    }
  };
  RangePointer2.prototype.angle = function angle(value2) {
    var geometry = this.elements.geometry();
    if (this.scale.options.reverse) {
      geometry.setStartAngle(value2);
    } else {
      geometry.setEndAngle(value2);
    }
    this.scale.placeholderRangeAngle(value2);
  };
  RangePointer2.prototype.stroke = function stroke(value2) {
    this.elements.stroke(value2);
  };
  RangePointer2.prototype.render = function render() {
    if (this.elements) {
      return;
    }
    var ref2 = this;
    var scale = ref2.scale;
    var options2 = ref2.options;
    if (options2.animation !== false) {
      deepExtend(options2.animation, {
        startAngle: 0,
        center: scale.arc.center,
        reverse: scale.options.reverse
      });
    }
    this.elements = scale.addRange(scale.options.min, this.options.value, {
      color: this.currentColor(),
      opacity: options2.opacity,
      lineCap: scale.options.rangeLineCap
    });
  };
  RangePointer2.prototype.currentColor = function currentColor() {
    var ref2 = this.scale.options;
    var min2 = ref2.min;
    var max2 = ref2.max;
    var ref$1 = this.options;
    var colors = ref$1.colors;
    var color = ref$1.color;
    var value2 = ref$1.value;
    var currentValue = isNumber(value2) ? value2 : min2;
    if (colors) {
      for (var idx = 0; idx < colors.length; idx++) {
        var ref$2 = colors[idx];
        var rangeColor = ref$2.color;
        var from = ref$2.from;
        if (from === void 0)
          from = min2;
        var to = ref$2.to;
        if (to === void 0)
          to = max2;
        if (from <= currentValue && currentValue <= to) {
          return rangeColor;
        }
      }
    }
    return color;
  };
  RangePointer2.prototype.reflow = function reflow() {
    this.render();
    this.bbox = this.elements.bbox();
  };
  return RangePointer2;
}(Pointer);
setDefaultOptions(RangePointer, {
  animation: {
    type: RADIAL_RANGE_POINTER,
    duration: ANGULAR_SPEED
  }
});
var ArcGauge = function(RadialGauge2) {
  function ArcGauge2() {
    RadialGauge2.apply(this, arguments);
  }
  if (RadialGauge2)
    ArcGauge2.__proto__ = RadialGauge2;
  ArcGauge2.prototype = Object.create(RadialGauge2 && RadialGauge2.prototype);
  ArcGauge2.prototype.constructor = ArcGauge2;
  ArcGauge2.prototype._initTheme = function _initTheme(theme) {
    RadialGauge2.prototype._initTheme.call(this, theme);
    this.options.color = this.options.color || (this.theme.pointer || {}).color;
  };
  ArcGauge2.prototype._createModel = function _createModel() {
    var options2 = this.options;
    var scale = this.scale = new ArcScale(options2.scale, this.contextService);
    var pointer = new RangePointer(scale, deepExtend({}, {
      colors: options2.colors,
      color: options2.color,
      value: options2.value,
      opacity: options2.opacity,
      animation: {
        transitions: options2.transitions
      }
    }));
    this.pointers = [pointer];
  };
  ArcGauge2.prototype._buildPointers = function _buildPointers(pointers) {
    for (var i16 = 0; i16 < pointers.length; i16++) {
      var current2 = pointers[i16];
      current2.render();
      current2.value(current2.options.value);
    }
  };
  ArcGauge2.prototype._setValueOptions = function _setValueOptions(value2) {
    this.options.value = value2;
  };
  ArcGauge2.prototype.currentColor = function currentColor() {
    var pointer = this.pointers[0];
    if (pointer) {
      return pointer.currentColor();
    }
  };
  ArcGauge2.prototype.centerLabelPosition = function centerLabelPosition(width, height) {
    var size = this.getSize();
    var center = this.scale.arc.center;
    var left = center.x - width / 2;
    var top = center.y - height / 2;
    if (width < size.width) {
      var right = left + width;
      left = Math.max(left, 0);
      if (right > size.width) {
        left -= right - size.width;
      }
    }
    if (height < size.height) {
      var bbox = this.scale.bbox;
      var yLimit = bbox.bottomRight().y;
      var bottom = top + height;
      top = Math.max(top, bbox.origin.y);
      if (bottom > yLimit) {
        top -= bottom - yLimit;
      }
    }
    return {
      left,
      top
    };
  };
  return ArcGauge2;
}(RadialGauge);
var defaultStartAngle = 90;
(function(ArcGauge2) {
  function CircularGauge() {
    ArcGauge2.apply(this, arguments);
  }
  if (ArcGauge2)
    CircularGauge.__proto__ = ArcGauge2;
  CircularGauge.prototype = Object.create(ArcGauge2 && ArcGauge2.prototype);
  CircularGauge.prototype.constructor = CircularGauge;
  CircularGauge.prototype._createModel = function _createModel() {
    var scaleOptions = this.options.scale;
    if (typeof scaleOptions.startAngle !== "number") {
      scaleOptions.startAngle = defaultStartAngle;
    }
    scaleOptions.endAngle = scaleOptions.startAngle + 360;
    ArcGauge2.prototype._createModel.call(this);
  };
  return CircularGauge;
})(ArcGauge);
var DEFAULT_QUIET_ZONE_LENGTH = 10;
var Encoding = function(Class3) {
  function Encoding2(options2) {
    Class3.call(this);
    this.setOptions(options2);
    this.initProperties();
  }
  if (Class3)
    Encoding2.__proto__ = Class3;
  Encoding2.prototype = Object.create(Class3 && Class3.prototype);
  Encoding2.prototype.constructor = Encoding2;
  Encoding2.prototype.initProperties = function initProperties() {
  };
  Encoding2.prototype.setOptions = function setOptions(options2) {
    this.options = Object.assign({}, this.options, options2);
    this.quietZoneLength = this.options.addQuietZone ? 2 * this.options.quietZoneLength : 0;
  };
  Encoding2.prototype.encode = function encode(value2, width, height) {
    var convertedValue = defined(value2) ? String(value2) : value2;
    this.initValue(convertedValue, width, height);
    if (this.options.addQuietZone) {
      this.addQuietZone();
    }
    this.addData();
    if (this.options.addQuietZone) {
      this.addQuietZone();
    }
    return {
      baseUnit: this.baseUnit,
      pattern: this.pattern
    };
  };
  Encoding2.prototype.initValue = function initValue() {
  };
  Encoding2.prototype.addQuietZone = function addQuietZone() {
    this.pattern.push(this.options.quietZoneLength || DEFAULT_QUIET_ZONE_LENGTH);
  };
  Encoding2.prototype.addData = function addData() {
  };
  Encoding2.prototype.invalidCharacterError = function invalidCharacterError(character) {
    throw new Error('Character "' + character + '" is not valid for symbology ' + this.name + ".");
  };
  return Encoding2;
}(Class$1);
setDefaultOptions(Encoding, {
  quietZoneLength: DEFAULT_QUIET_ZONE_LENGTH,
  addQuietZone: true,
  addCheckSum: true
});
var extend$c = Object.assign;
var Code11 = function(Encoding2) {
  function Code112() {
    Encoding2.apply(this, arguments);
  }
  if (Encoding2)
    Code112.__proto__ = Encoding2;
  Code112.prototype = Object.create(Encoding2 && Encoding2.prototype);
  Code112.prototype.constructor = Code112;
  Code112.prototype.initProperties = function initProperties() {
    Encoding2.prototype.initProperties.call(this);
    extend$c(this, {
      name: "Code 11",
      characterMap: ["111121", "211121", "121121", "221111", "112121", "212111", "122111", "111221", "211211", "211111", "112111"],
      cCheckSumTotal: 10,
      kCheckSumTotal: 9,
      kCheckSumMinLength: 10,
      checkSumMod: 11,
      DASH_VALUE: 10,
      DASH: "-",
      START: "112211",
      STOP: "11221"
    });
  };
  Code112.prototype.initValue = function initValue(value2, width) {
    this.pattern = [];
    this.value = value2;
    this.width = width;
    this.totalUnits = 0;
  };
  Code112.prototype.addData = function addData() {
    var this$1$1 = this;
    var value2 = this.value;
    this.addPattern(this.START);
    for (var i16 = 0; i16 < value2.length; i16++) {
      this$1$1.addCharacter(value2.charAt(i16));
    }
    if (this.options.addCheckSum) {
      this.addCheckSum();
    }
    this.addPattern(this.STOP);
    this.setBaseUnit();
  };
  Code112.prototype.setBaseUnit = function setBaseUnit() {
    this.baseUnit = this.width / (this.totalUnits + this.quietZoneLength);
  };
  Code112.prototype.addCheckSum = function addCheckSum() {
    var value2 = this.value;
    var length = value2.length;
    var cValue = this.getWeightedSum(value2, length, this.cCheckSumTotal) % this.checkSumMod;
    this.checksum = String(cValue);
    this.addPattern(this.characterMap[cValue]);
    length++;
    if (length >= this.kCheckSumMinLength) {
      var kValue = (cValue + this.getWeightedSum(value2, length, this.kCheckSumTotal)) % this.checkSumMod;
      this.checksum += kValue;
      this.addPattern(this.characterMap[kValue]);
    }
  };
  Code112.prototype.getWeightedSum = function getWeightedSum(value2, length, total3) {
    var this$1$1 = this;
    var weightedSum = 0;
    for (var i16 = 0; i16 < value2.length; i16++) {
      weightedSum += this$1$1.weightedValue(this$1$1.getValue(value2.charAt(i16)), length, i16, total3);
    }
    return weightedSum;
  };
  Code112.prototype.weightedValue = function weightedValue(value2, length, index2, total3) {
    var weight = (length - index2) % total3 || total3;
    return weight * value2;
  };
  Code112.prototype.getValue = function getValue(character) {
    if (!isNaN(character)) {
      return parseInt(character, 10);
    } else if (character !== this.DASH) {
      this.invalidCharacterError(character);
    }
    return this.DASH_VALUE;
  };
  Code112.prototype.addCharacter = function addCharacter2(character) {
    var value2 = this.getValue(character);
    var pattern = this.characterMap[value2];
    this.addPattern(pattern);
  };
  Code112.prototype.addPattern = function addPattern(pattern) {
    var this$1$1 = this;
    var value2;
    for (var i16 = 0; i16 < pattern.length; i16++) {
      value2 = parseInt(pattern.charAt(i16), 10);
      this$1$1.pattern.push(value2);
      this$1$1.totalUnits += value2;
    }
  };
  return Code112;
}(Encoding);
setDefaultOptions(Code11, {
  addCheckSum: true
});
var extend$b = Object.assign;
var Code39Base = function(Encoding2) {
  function Code39Base2() {
    Encoding2.apply(this, arguments);
  }
  if (Encoding2)
    Code39Base2.__proto__ = Encoding2;
  Code39Base2.prototype = Object.create(Encoding2 && Encoding2.prototype);
  Code39Base2.prototype.constructor = Code39Base2;
  Code39Base2.prototype.initProperties = function initProperties() {
    Encoding2.prototype.initProperties.call(this);
    extend$b(this, {
      minBaseUnitLength: 0.7
    });
  };
  Code39Base2.prototype.addData = function addData() {
    var this$1$1 = this;
    var value2 = this.value;
    this.addStart();
    for (var idx = 0; idx < value2.length; idx++) {
      this$1$1.addCharacter(value2.charAt(idx));
    }
    if (this.options.addCheckSum) {
      this.pushCheckSum();
    }
    this.addStop();
    this.prepareValues();
  };
  Code39Base2.prototype.addCharacter = function addCharacter2(character) {
    var characterData = this.characterMap[character];
    if (!characterData) {
      this.invalidCharacterError(character);
    }
    this.addBase(characterData);
  };
  Code39Base2.prototype.addBase = function addBase() {
  };
  return Code39Base2;
}(Encoding);
var Code39 = function(Code39Base2) {
  function Code392() {
    Code39Base2.apply(this, arguments);
  }
  if (Code39Base2)
    Code392.__proto__ = Code39Base2;
  Code392.prototype = Object.create(Code39Base2 && Code39Base2.prototype);
  Code392.prototype.constructor = Code392;
  Code392.prototype.initProperties = function initProperties() {
    Code39Base2.prototype.initProperties.call(this);
    extend$b(this, {
      name: "Code 39",
      checkSumMod: 43,
      minRatio: 2.5,
      maxRatio: 3,
      gapWidth: 1,
      splitCharacter: "|",
      patternMappings: {
        "b": "1|",
        "w": "1|",
        "B": "ratio|",
        "W": "ratio|"
      },
      characterMap: {
        "0": { "pattern": "bwbWBwBwb", "value": 0 },
        "1": { "pattern": "BwbWbwbwB", "value": 1 },
        "2": { "pattern": "bwBWbwbwB", "value": 2 },
        "3": { "pattern": "BwBWbwbwb", "value": 3 },
        "4": { "pattern": "bwbWBwbwB", "value": 4 },
        "5": { "pattern": "BwbWBwbwb", "value": 5 },
        "6": { "pattern": "bwBWBwbwb", "value": 6 },
        "7": { "pattern": "bwbWbwBwB", "value": 7 },
        "8": { "pattern": "BwbWbwBwb", "value": 8 },
        "9": { "pattern": "bwBWbwBwb", "value": 9 },
        "A": { "pattern": "BwbwbWbwB", "value": 10 },
        "B": { "pattern": "bwBwbWbwB", "value": 11 },
        "C": { "pattern": "BwBwbWbwb", "value": 12 },
        "D": { "pattern": "bwbwBWbwB", "value": 13 },
        "E": { "pattern": "BwbwBWbwb", "value": 14 },
        "F": { "pattern": "bwBwBWbwb", "value": 15 },
        "G": { "pattern": "bwbwbWBwB", "value": 16 },
        "H": { "pattern": "BwbwbWBwb", "value": 17 },
        "I": { "pattern": "bwBwbWBwb", "value": 18 },
        "J": { "pattern": "bwbwBWBwb", "value": 19 },
        "K": { "pattern": "BwbwbwbWB", "value": 20 },
        "L": { "pattern": "bwBwbwbWB", "value": 21 },
        "M": { "pattern": "BwBwbwbWb", "value": 22 },
        "N": { "pattern": "bwbwBwbWB", "value": 23 },
        "O": { "pattern": "BwbwBwbWb", "value": 24 },
        "P": { "pattern": "bwBwBwbWb", "value": 25 },
        "Q": { "pattern": "bwbwbwBWB", "value": 26 },
        "R": { "pattern": "BwbwbwBWb", "value": 27 },
        "S": { "pattern": "bwBwbwBWb", "value": 28 },
        "T": { "pattern": "bwbwBwBWb", "value": 29 },
        "U": { "pattern": "BWbwbwbwB", "value": 30 },
        "V": { "pattern": "bWBwbwbwB", "value": 31 },
        "W": { "pattern": "BWBwbwbwb", "value": 32 },
        "X": { "pattern": "bWbwBwbwB", "value": 33 },
        "Y": { "pattern": "BWbwBwbwb", "value": 34 },
        "Z": { "pattern": "bWBwBwbwb", "value": 35 },
        "-": { "pattern": "bWbwbwBwB", "value": 36 },
        ".": { "pattern": "BWbwbwBwb", "value": 37 },
        " ": { "pattern": "bWBwbwBwb", "value": 38 },
        "$": { "pattern": "bWbWbWbwb", "value": 39 },
        "/": { "pattern": "bWbWbwbWb", "value": 40 },
        "+": { "pattern": "bWbwbWbWb", "value": 41 },
        "%": { "pattern": "bwbWbWbWb", "value": 42 },
        START: { pattern: "bWbwBwBwb" }
      }
    });
  };
  Code392.prototype.initValue = function initValue(value2, width, height) {
    this.width = width;
    this.height = height;
    this.value = value2;
    this.dataLength = value2.length;
    this.pattern = [];
    this.patternString = "";
  };
  Code392.prototype.prepareValues = function prepareValues() {
    var this$1$1 = this;
    var minBaseUnit = this.minBaseUnitLength;
    var minRatio = this.minRatio;
    var minHeight = Math.ceil(Math.max(0.15 * this.width, 24));
    var baseUnit;
    var ratio = this.maxRatio;
    if (this.height < minHeight) {
      throw new Error("Insufficient height for Code39 encoding: the current height is " + this.height + "px and the minimum height is " + minHeight + "px.");
    }
    baseUnit = this.getBaseUnit(ratio);
    while (baseUnit < minBaseUnit && ratio > minRatio) {
      ratio = parseFloat((ratio - 0.1).toFixed(1));
      baseUnit = this$1$1.getBaseUnit(ratio);
    }
    if (baseUnit < minBaseUnit) {
      var minWidth = Math.ceil(this.getBaseWidth(minRatio) * minBaseUnit);
      throw new Error("Insufficient width for Code39 encoding: the current width is " + this.width + 'px and the minimum width for value "' + this.value + '" is ' + minWidth + "px.");
    }
    this.ratio = ratio;
    this.baseUnit = baseUnit;
    this.patternString = this.patternString.substring(0, this.patternString.length - 1);
    this.pattern = this.pattern.concat(this.patternString.replace(/ratio/g, ratio).split(this.splitCharacter));
  };
  Code392.prototype.getBaseUnit = function getBaseUnit(ratio) {
    return this.width / this.getBaseWidth(ratio);
  };
  Code392.prototype.getBaseWidth = function getBaseWidth(ratio) {
    var characterLength = 3 * (ratio + 2);
    return this.quietZoneLength + characterLength * (this.dataLength + 2) + this.gapWidth * (this.dataLength + 1);
  };
  Code392.prototype.addStart = function addStart() {
    this.addPattern(this.characterMap.START.pattern);
    this.addCharacterGap();
  };
  Code392.prototype.addBase = function addBase(character) {
    this.addPattern(character.pattern);
    this.addCharacterGap();
  };
  Code392.prototype.addStop = function addStop() {
    this.addPattern(this.characterMap.START.pattern);
  };
  Code392.prototype.addPattern = function addPattern(pattern) {
    var this$1$1 = this;
    for (var i16 = 0; i16 < pattern.length; i16++) {
      this$1$1.patternString += this$1$1.patternMappings[pattern.charAt(i16)];
    }
  };
  Code392.prototype.addCharacterGap = function addCharacterGap() {
    this.patternString += this.gapWidth + this.splitCharacter;
  };
  return Code392;
}(Code39Base);
setDefaultOptions(Code39, {
  addCheckSum: false
});
var Code39ExtendedBase = {
  addCharacter: function addCharacter(character) {
    if (this.characterMap[character]) {
      this.addBase(this.characterMap[character]);
    } else if (character.charCodeAt(0) > 127) {
      this.invalidCharacterError(character);
    } else {
      this.addExtended(character.charCodeAt(0));
    }
  },
  addExtended: function addExtended(code) {
    var this$1$1 = this;
    var patterns;
    for (var i16 = 0; i16 < this.extendedMappings.length; i16++) {
      patterns = this$1$1.extendedMappings[i16].call(this$1$1, code);
      if (patterns) {
        for (var patternIndex = 0; patternIndex < patterns.length; patternIndex++) {
          var pattern = patterns[patternIndex];
          this$1$1.addBase(pattern);
        }
        this$1$1.dataLength += patterns.length - 1;
        return;
      }
    }
  },
  extendedMappings: [
    function(code) {
      if (97 <= code && code <= 122) {
        return [this.characterMap[this.shiftCharacters[0]], this.characterMap[String.fromCharCode(code - 32)]];
      }
    },
    function(code) {
      if (33 <= code && code <= 58) {
        return [this.characterMap[this.shiftCharacters[1]], this.characterMap[String.fromCharCode(code + 32)]];
      }
    },
    function(code) {
      if (1 <= code && code <= 26) {
        return [this.characterMap[this.shiftCharacters[2]], this.characterMap[String.fromCharCode(code + 64)]];
      }
    },
    function(code) {
      var this$1$1 = this;
      var result;
      var dataCharacter;
      if (!this.specialAsciiCodes[code]) {
        dataCharacter = Math.floor(code / 32) * 6 + (code - 27) % 32 + 64;
        result = [this.characterMap[this.shiftCharacters[3]], this.characterMap[String.fromCharCode(dataCharacter)]];
      } else {
        result = [];
        for (var i16 = 0; i16 < this.specialAsciiCodes[code].length; i16++) {
          result.push(this$1$1.characterMap[this$1$1.shiftCharacters[3]]);
          result.push(this$1$1.characterMap[this$1$1.specialAsciiCodes[code][i16]]);
        }
      }
      return result;
    }
  ],
  specialAsciiCodes: {
    "0": ["U"],
    "64": ["V"],
    "96": ["W"],
    "127": ["T", "X", "Y", "Z"]
  },
  shiftValuesAsciiCodes: {
    "39": 36,
    "40": 47,
    "41": 43,
    "42": 37
  },
  characterMap: {
    "+": false,
    "/": false,
    "$": false,
    "%": false
  },
  shiftCharacters: ["SHIFT0", "SHIFT1", "SHIFT2", "SHIFT3"]
};
var Code39Extended = function(Code392) {
  function Code39Extended2() {
    Code392.apply(this, arguments);
  }
  if (Code392)
    Code39Extended2.__proto__ = Code392;
  Code39Extended2.prototype = Object.create(Code392 && Code392.prototype);
  Code39Extended2.prototype.constructor = Code39Extended2;
  Code39Extended2.prototype.initProperties = function initProperties() {
    Code392.prototype.initProperties.call(this);
    deepExtend(this, Code39ExtendedBase, {
      name: "Code 39 extended",
      characterMap: {
        SHIFT0: { "pattern": "bWbwbWbWb", "value": 41 },
        SHIFT1: { "pattern": "bWbWbwbWb", "value": 40 },
        SHIFT2: { "pattern": "bWbWbWbwb", "value": 39 },
        SHIFT3: { "pattern": "bwbWbWbWb", "value": 42 }
      }
    });
  };
  return Code39Extended2;
}(Code39);
var extend$a = Object.assign;
var Code93 = function(Code39Base2) {
  function Code932() {
    Code39Base2.apply(this, arguments);
  }
  if (Code39Base2)
    Code932.__proto__ = Code39Base2;
  Code932.prototype = Object.create(Code39Base2 && Code39Base2.prototype);
  Code932.prototype.constructor = Code932;
  Code932.prototype.initProperties = function initProperties() {
    Code39Base2.prototype.initProperties.call(this);
    extend$a(this, {
      name: "Code 93",
      cCheckSumTotal: 20,
      kCheckSumTotal: 15,
      checkSumMod: 47,
      characterMap: {
        "0": { "pattern": "131112", "value": 0 },
        "1": { "pattern": "111213", "value": 1 },
        "2": { "pattern": "111312", "value": 2 },
        "3": { "pattern": "111411", "value": 3 },
        "4": { "pattern": "121113", "value": 4 },
        "5": { "pattern": "121212", "value": 5 },
        "6": { "pattern": "121311", "value": 6 },
        "7": { "pattern": "111114", "value": 7 },
        "8": { "pattern": "131211", "value": 8 },
        "9": { "pattern": "141111", "value": 9 },
        "A": { "pattern": "211113", "value": 10 },
        "B": { "pattern": "211212", "value": 11 },
        "C": { "pattern": "211311", "value": 12 },
        "D": { "pattern": "221112", "value": 13 },
        "E": { "pattern": "221211", "value": 14 },
        "F": { "pattern": "231111", "value": 15 },
        "G": { "pattern": "112113", "value": 16 },
        "H": { "pattern": "112212", "value": 17 },
        "I": { "pattern": "112311", "value": 18 },
        "J": { "pattern": "122112", "value": 19 },
        "K": { "pattern": "132111", "value": 20 },
        "L": { "pattern": "111123", "value": 21 },
        "M": { "pattern": "111222", "value": 22 },
        "N": { "pattern": "111321", "value": 23 },
        "O": { "pattern": "121122", "value": 24 },
        "P": { "pattern": "131121", "value": 25 },
        "Q": { "pattern": "212112", "value": 26 },
        "R": { "pattern": "212211", "value": 27 },
        "S": { "pattern": "211122", "value": 28 },
        "T": { "pattern": "211221", "value": 29 },
        "U": { "pattern": "221121", "value": 30 },
        "V": { "pattern": "222111", "value": 31 },
        "W": { "pattern": "112122", "value": 32 },
        "X": { "pattern": "112221", "value": 33 },
        "Y": { "pattern": "122121", "value": 34 },
        "Z": { "pattern": "123111", "value": 35 },
        "-": { "pattern": "121131", "value": 36 },
        ".": { "pattern": "311112", "value": 37 },
        " ": { "pattern": "311211", "value": 38 },
        "$": { "pattern": "321111", "value": 39 },
        "/": { "pattern": "112131", "value": 40 },
        "+": { "pattern": "113121", "value": 41 },
        "%": { "pattern": "211131", "value": 42 },
        SHIFT0: { "pattern": "122211", "value": 46 },
        SHIFT1: { "pattern": "311121", "value": 45 },
        SHIFT2: { "pattern": "121221", "value": 43 },
        SHIFT3: { "pattern": "312111", "value": 44 },
        START: { "pattern": "111141" },
        TERMINATION_BAR: "1"
      }
    });
  };
  Code932.prototype.initValue = function initValue(value2, width, height) {
    this.value = value2;
    this.width = width;
    this.height = height;
    this.pattern = [];
    this.values = [];
    this.dataLength = value2.length;
  };
  Code932.prototype.prepareValues = function prepareValues() {
    var minHeight = Math.ceil(Math.max(0.15 * this.width, 24));
    if (this.height < minHeight) {
      throw new Error("Insufficient height for Code93 encoding: the current height is " + this.height + "px, the minimum required height is " + minHeight + "px.");
    }
    this.setBaseUnit();
    if (this.baseUnit < this.minBaseUnitLength) {
      var minWidth = Math.ceil(this.minBaseUnitLength * (this.width / this.baseUnit));
      throw new Error("Insufficient width for Code93 encoding: the current width is " + this.width + 'px and the minimum required width for value "' + this.value + '" is ' + minWidth + "px.");
    }
  };
  Code932.prototype.setBaseUnit = function setBaseUnit() {
    var checkSumLength = 2;
    this.baseUnit = this.width / (9 * (this.dataLength + 2 + checkSumLength) + this.quietZoneLength + 1);
  };
  Code932.prototype.addStart = function addStart() {
    var pattern = this.characterMap.START.pattern;
    this.addPattern(pattern);
  };
  Code932.prototype.addStop = function addStop() {
    this.addStart();
    this.pattern.push(this.characterMap.TERMINATION_BAR);
  };
  Code932.prototype.addBase = function addBase(charData) {
    this.addPattern(charData.pattern);
    this.values.push(charData.value);
  };
  Code932.prototype.pushCheckSum = function pushCheckSum() {
    var this$1$1 = this;
    var checkValues = this._getCheckValues();
    var charData;
    this.checksum = checkValues.join("");
    for (var i16 = 0; i16 < checkValues.length; i16++) {
      charData = this$1$1.characterMap[this$1$1._findCharacterByValue(checkValues[i16])];
      this$1$1.addPattern(charData.pattern);
    }
  };
  Code932.prototype._getCheckValues = function _getCheckValues() {
    var this$1$1 = this;
    var values6 = this.values;
    var length = values6.length;
    var wightedSum = 0;
    var cValue;
    var kValue;
    var idx;
    for (idx = length - 1; idx >= 0; idx--) {
      wightedSum += this$1$1.weightedValue(values6[idx], length - idx, this$1$1.cCheckSumTotal);
    }
    cValue = wightedSum % this.checkSumMod;
    wightedSum = this.weightedValue(cValue, 1, this.kCheckSumTotal);
    for (idx = length - 1; idx >= 0; idx--) {
      wightedSum += this$1$1.weightedValue(values6[idx], length - idx + 1, this$1$1.kCheckSumTotal);
    }
    kValue = wightedSum % this.checkSumMod;
    return [cValue, kValue];
  };
  Code932.prototype._findCharacterByValue = function _findCharacterByValue(value2) {
    var this$1$1 = this;
    for (var character in this$1$1.characterMap) {
      if (this$1$1.characterMap[character].value === value2) {
        return character;
      }
    }
  };
  Code932.prototype.weightedValue = function weightedValue(value2, index2, total3) {
    return (index2 % total3 || total3) * value2;
  };
  Code932.prototype.addPattern = function addPattern(pattern) {
    var this$1$1 = this;
    var value2;
    for (var i16 = 0; i16 < pattern.length; i16++) {
      value2 = parseInt(pattern.charAt(i16), 10);
      this$1$1.pattern.push(value2);
    }
  };
  return Code932;
}(Code39Base);
var Code93Extended = function(Code932) {
  function Code93Extended2() {
    Code932.apply(this, arguments);
  }
  if (Code932)
    Code93Extended2.__proto__ = Code932;
  Code93Extended2.prototype = Object.create(Code932 && Code932.prototype);
  Code93Extended2.prototype.constructor = Code93Extended2;
  Code93Extended2.prototype.initProperties = function initProperties() {
    Code932.prototype.initProperties.call(this);
    deepExtend(this, Code39ExtendedBase, {
      name: "Code 93 extended",
      pushCheckSum: function() {
        var this$1$1 = this;
        var checkValues = this._getCheckValues();
        var value2;
        this.checksum = checkValues.join("");
        for (var i16 = 0; i16 < checkValues.length; i16++) {
          value2 = checkValues[i16];
          if (this$1$1.shiftValuesAsciiCodes[value2]) {
            this$1$1.addExtended(this$1$1.shiftValuesAsciiCodes[value2]);
          } else {
            var characterByValue = this$1$1._findCharacterByValue(value2);
            this$1$1.addPattern(this$1$1.characterMap[characterByValue].pattern);
          }
        }
      }
    });
  };
  return Code93Extended2;
}(Code93);
var numberRegex$2 = /^\d+$/;
var extend$9 = Object.assign;
var Postnet = function(Encoding2) {
  function Postnet2() {
    Encoding2.apply(this, arguments);
  }
  if (Encoding2)
    Postnet2.__proto__ = Encoding2;
  Postnet2.prototype = Object.create(Encoding2 && Encoding2.prototype);
  Postnet2.prototype.constructor = Postnet2;
  Postnet2.prototype.initProperties = function initProperties() {
    Encoding2.prototype.initProperties.call(this);
    extend$9(this, {
      name: "Postnet",
      START: "2",
      VALID_CODE_LENGTHS: [5, 9, 11],
      DIGIT_SEPARATOR: "-",
      characterMap: ["22111", "11122", "11212", "11221", "12112", "12121", "12211", "21112", "21121", "21211"]
    });
  };
  Postnet2.prototype.initValue = function initValue(value2, width, height) {
    this.height = height;
    this.width = width;
    this.baseHeight = height / 2;
    this.value = value2.replace(new RegExp(this.DIGIT_SEPARATOR, "g"), "");
    this.pattern = [];
    this.validate(this.value);
    this.checkSum = 0;
    this.setBaseUnit();
  };
  Postnet2.prototype.addData = function addData() {
    var this$1$1 = this;
    var value2 = this.value;
    this.addPattern(this.START);
    for (var i16 = 0; i16 < value2.length; i16++) {
      this$1$1.addCharacter(value2.charAt(i16));
    }
    if (this.options.addCheckSum) {
      this.addCheckSum();
    }
    this.addPattern(this.START);
    this.pattern.pop();
  };
  Postnet2.prototype.addCharacter = function addCharacter2(character) {
    var pattern = this.characterMap[character];
    this.checkSum += parseInt(character, 10);
    this.addPattern(pattern);
  };
  Postnet2.prototype.addCheckSum = function addCheckSum() {
    this.checksum = (10 - this.checkSum % 10) % 10;
    this.addCharacter(this.checksum);
  };
  Postnet2.prototype.setBaseUnit = function setBaseUnit() {
    var startStopLength = 3;
    this.baseUnit = this.width / ((this.value.length + 1) * 10 + startStopLength + this.quietZoneLength);
  };
  Postnet2.prototype.validate = function validate(value2) {
    if (!numberRegex$2.test(value2)) {
      this.invalidCharacterError(value2.match(/[^0-9]/)[0]);
    }
    if (!inArray(value2.length, this.VALID_CODE_LENGTHS)) {
      throw new Error("Invalid value length. Valid lengths for the Postnet symbology are " + this.VALID_CODE_LENGTHS.join(",") + ".");
    }
  };
  Postnet2.prototype.addPattern = function addPattern(pattern) {
    var this$1$1 = this;
    var y1;
    for (var i16 = 0; i16 < pattern.length; i16++) {
      y1 = this$1$1.height - this$1$1.baseHeight * pattern.charAt(i16);
      this$1$1.pattern.push({ width: 1, y1, y2: this$1$1.height });
      this$1$1.pattern.push(1);
    }
  };
  return Postnet2;
}(Encoding);
var numberRegex$1 = /^\d+$/;
var alphanumericRegex = /^[a-z0-9]+$/i;
var extend$8 = Object.assign;
var State128 = function(Class3) {
  function State1282(encoding) {
    Class3.call(this);
    this.encoding = encoding;
    this.initProperties();
  }
  if (Class3)
    State1282.__proto__ = Class3;
  State1282.prototype = Object.create(Class3 && Class3.prototype);
  State1282.prototype.constructor = State1282;
  State1282.prototype.initProperties = function initProperties() {
  };
  State1282.prototype.addStart = function addStart() {
  };
  State1282.prototype.is = function is() {
  };
  State1282.prototype.isCode = function isCode() {
    return false;
  };
  State1282.prototype.move = function move() {
  };
  State1282.prototype.pushState = function pushState() {
  };
  return State1282;
}(Class$1);
var State128AB = function(State1282) {
  function State128AB2(encoding, states) {
    State1282.call(this, encoding);
    this.states = states;
    this._initMoves(states);
  }
  if (State1282)
    State128AB2.__proto__ = State1282;
  State128AB2.prototype = Object.create(State1282 && State1282.prototype);
  State128AB2.prototype.constructor = State128AB2;
  State128AB2.prototype.initProperties = function initProperties() {
    State1282.prototype.initProperties.call(this);
    deepExtend(this, {
      FNC4: "FNC4",
      SHIFT: 98
    });
  };
  State128AB2.prototype.addStart = function addStart() {
    this.encoding.addPattern(this.START);
  };
  State128AB2.prototype.is = function is(value2, index2) {
    var code = value2.charCodeAt(index2);
    return this.isCode(code);
  };
  State128AB2.prototype.move = function move(encodingState) {
    var idx = 0;
    while (!this._moves[idx].call(this, encodingState) && idx < this._moves.length) {
      idx++;
    }
  };
  State128AB2.prototype.pushState = function pushState(encodingState) {
    var this$1$1 = this;
    var states = this.states, value2 = encodingState.value, maxLength = value2.length, code;
    if (inArray("C", states)) {
      var numberMatch = value2.substr(encodingState.index).match(/\d{4,}/g);
      if (numberMatch) {
        maxLength = value2.indexOf(numberMatch[0], encodingState.index);
      }
    }
    while ((code = encodingState.value.charCodeAt(encodingState.index)) >= 0 && this.isCode(code) && encodingState.index < maxLength) {
      this$1$1.encoding.addPattern(this$1$1.getValue(code));
      encodingState.index++;
    }
  };
  State128AB2.prototype._initMoves = function _initMoves(states) {
    this._moves = [];
    if (inArray(this.FNC4, states)) {
      this._moves.push(this._moveFNC);
    }
    if (inArray(this.shiftKey, states)) {
      this._moves.push(this._shiftState);
    }
    this._moves.push(this._moveState);
  };
  State128AB2.prototype._moveFNC = function _moveFNC(encodingState) {
    if (encodingState.fnc) {
      encodingState.fnc = false;
      return encodingState.previousState === this.key;
    }
  };
  State128AB2.prototype._shiftState = function _shiftState(encodingState) {
    if (encodingState.previousState === this.shiftKey && (encodingState.index + 1 >= encodingState.value.length || this.encoding[this.shiftKey].is(encodingState.value, encodingState.index + 1))) {
      this.encoding.addPattern(this.SHIFT);
      encodingState.shifted = true;
      return true;
    }
  };
  State128AB2.prototype._moveState = function _moveState() {
    this.encoding.addPattern(this.MOVE);
    return true;
  };
  return State128AB2;
}(State128);
var states128 = {};
states128.A = function(State128AB2) {
  function State128A() {
    State128AB2.apply(this, arguments);
  }
  if (State128AB2)
    State128A.__proto__ = State128AB2;
  State128A.prototype = Object.create(State128AB2 && State128AB2.prototype);
  State128A.prototype.constructor = State128A;
  State128A.prototype.initProperties = function initProperties() {
    State128AB2.prototype.initProperties.call(this);
    extend$8(this, {
      key: "A",
      shiftKey: "B",
      MOVE: 101,
      START: 103
    });
  };
  State128A.prototype.isCode = function isCode(code) {
    return 0 <= code && code < 96;
  };
  State128A.prototype.getValue = function getValue(code) {
    if (code < 32) {
      return code + 64;
    }
    return code - 32;
  };
  return State128A;
}(State128AB);
states128.B = function(State128AB2) {
  function State128B() {
    State128AB2.apply(this, arguments);
  }
  if (State128AB2)
    State128B.__proto__ = State128AB2;
  State128B.prototype = Object.create(State128AB2 && State128AB2.prototype);
  State128B.prototype.constructor = State128B;
  State128B.prototype.initProperties = function initProperties() {
    State128AB2.prototype.initProperties.call(this);
    extend$8(this, {
      key: "B",
      shiftKey: "A",
      MOVE: 100,
      START: 104
    });
  };
  State128B.prototype.isCode = function isCode(code) {
    return 32 <= code && code < 128;
  };
  State128B.prototype.getValue = function getValue(code) {
    return code - 32;
  };
  return State128B;
}(State128AB);
states128.C = function(State1282) {
  function State128C() {
    State1282.apply(this, arguments);
  }
  if (State1282)
    State128C.__proto__ = State1282;
  State128C.prototype = Object.create(State1282 && State1282.prototype);
  State128C.prototype.constructor = State128C;
  State128C.prototype.initProperties = function initProperties() {
    State1282.prototype.initProperties.call(this);
    extend$8(this, {
      key: "C",
      MOVE: 99,
      START: 105
    });
  };
  State128C.prototype.addStart = function addStart() {
    this.encoding.addPattern(this.START);
  };
  State128C.prototype.is = function is(value2, index2) {
    var next4 = getSubstring(value2, index2, 4);
    return (index2 + 4 <= value2.length || value2.length === 2) && numberRegex$1.test(next4);
  };
  State128C.prototype.move = function move() {
    this.encoding.addPattern(this.MOVE);
  };
  State128C.prototype.pushState = function pushState(encodingState) {
    var this$1$1 = this;
    var code;
    while ((code = getSubstring(encodingState.value, encodingState.index, 2)) && numberRegex$1.test(code) && code.length === 2) {
      this$1$1.encoding.addPattern(parseInt(code, 10));
      encodingState.index += 2;
    }
  };
  State128C.prototype.getValue = function getValue(code) {
    return code;
  };
  return State128C;
}(State128);
states128.FNC4 = function(State1282) {
  function State128FNC4(encoding, states) {
    State1282.call(this, encoding);
    this._initSubStates(states);
  }
  if (State1282)
    State128FNC4.__proto__ = State1282;
  State128FNC4.prototype = Object.create(State1282 && State1282.prototype);
  State128FNC4.prototype.constructor = State128FNC4;
  State128FNC4.prototype.initProperties = function initProperties() {
    State1282.prototype.initProperties.call(this);
    extend$8(this, {
      key: "FNC4",
      dependentStates: ["A", "B"]
    });
  };
  State128FNC4.prototype.addStart = function addStart(encodingState) {
    var code = encodingState.value.charCodeAt(0) - 128, subState = this._getSubState(code);
    this.encoding[subState].addStart();
  };
  State128FNC4.prototype.is = function is(value2, index2) {
    var code = value2.charCodeAt(index2);
    return this.isCode(code);
  };
  State128FNC4.prototype.isCode = function isCode(code) {
    return 128 <= code && code < 256;
  };
  State128FNC4.prototype.pushState = function pushState(encodingState) {
    var this$1$1 = this;
    var subState = this._initSubState(encodingState), encoding = this.encoding, length = subState.value.length;
    var code;
    encodingState.index += length;
    if (length < 3) {
      for (; subState.index < length; subState.index++) {
        code = subState.value.charCodeAt(subState.index);
        subState.state = this$1$1._getSubState(code);
        if (subState.previousState !== subState.state) {
          subState.previousState = subState.state;
          encoding[subState.state].move(subState);
        }
        encoding.addPattern(encoding[subState.state].MOVE);
        encoding.addPattern(encoding[subState.state].getValue(code));
      }
    } else {
      if (subState.state !== subState.previousState) {
        encoding[subState.state].move(subState);
      }
      this._pushStart(subState);
      encoding.pushData(subState, this.subStates);
      if (encodingState.index < encodingState.value.length) {
        this._pushStart(subState);
      }
    }
    encodingState.fnc = true;
    encodingState.state = subState.state;
  };
  State128FNC4.prototype._pushStart = function _pushStart(subState) {
    this.encoding.addPattern(this.encoding[subState.state].MOVE);
    this.encoding.addPattern(this.encoding[subState.state].MOVE);
  };
  State128FNC4.prototype._initSubState = function _initSubState(encodingState) {
    var subState = {
      value: this._getAll(encodingState.value, encodingState.index),
      index: 0
    };
    subState.state = this._getSubState(subState.value.charCodeAt(0));
    subState.previousState = encodingState.previousState === this.key ? subState.state : encodingState.previousState;
    return subState;
  };
  State128FNC4.prototype._initSubStates = function _initSubStates(states) {
    var this$1$1 = this;
    this.subStates = [];
    for (var i16 = 0; i16 < states.length; i16++) {
      if (inArray(states[i16], this$1$1.dependentStates)) {
        this$1$1.subStates.push(states[i16]);
      }
    }
  };
  State128FNC4.prototype._getSubState = function _getSubState(code) {
    var this$1$1 = this;
    for (var i16 = 0; i16 < this.subStates.length; i16++) {
      if (this$1$1.encoding[this$1$1.subStates[i16]].isCode(code)) {
        return this$1$1.subStates[i16];
      }
    }
  };
  State128FNC4.prototype._getAll = function _getAll(value2, index2) {
    var code;
    var result = "";
    var i16 = index2;
    while ((code = value2.charCodeAt(i16++)) && this.isCode(code)) {
      result += String.fromCharCode(code - 128);
    }
    return result;
  };
  return State128FNC4;
}(State128);
states128.FNC1 = function(State1282) {
  function States128FNC1(encoding, states) {
    State1282.call(this, encoding);
    this.states = states;
  }
  if (State1282)
    States128FNC1.__proto__ = State1282;
  States128FNC1.prototype = Object.create(State1282 && State1282.prototype);
  States128FNC1.prototype.constructor = States128FNC1;
  States128FNC1.prototype.initProperties = function initProperties() {
    State1282.prototype.initProperties.call(this);
    extend$8(this, {
      key: "FNC1",
      startState: "C",
      startAI: "(",
      endAI: ")",
      dependentStates: ["C", "B"],
      applicationIdentifiers: {
        "22": { max: 29, type: "alphanumeric" },
        "402": { length: 17 },
        "7004": { max: 4, type: "alphanumeric" },
        "242": { max: 6, type: "alphanumeric" },
        "8020": { max: 25, type: "alphanumeric" },
        "703": { min: 3, max: 30, type: "alphanumeric" },
        "8008": { min: 8, max: 12, type: "alphanumeric" },
        "253": { min: 13, max: 17, type: "alphanumeric" },
        "8003": { min: 14, max: 30, type: "alphanumeric" },
        multiKey: [{
          ids: ["15", "17", "8005", "8100"],
          ranges: [
            [11, 13],
            [310, 316],
            [320, 336],
            [340, 369]
          ],
          type: { length: 6 }
        }, {
          ids: ["240", "241", "250", "251", "400", "401", "403", "7002", "8004", "8007", "8110"],
          ranges: [[90 - 99]],
          type: { max: 30, type: "alphanumeric" }
        }, {
          ids: ["7001"],
          ranges: [[410, 414]],
          type: { length: 13 }
        }, {
          ids: ["10", "21", "254", "420", "8002"],
          type: { max: 20, type: "alphanumeric" }
        }, {
          ids: ["00", "8006", "8017", "8018"],
          type: { length: 18 }
        }, {
          ids: ["01", "02", "8001"],
          type: { length: 14 }
        }, {
          ids: ["422"],
          ranges: [
            [424, 426]
          ],
          type: { length: 3 }
        }, {
          ids: ["20", "8102"],
          type: { length: 2 }
        }, {
          ids: ["30", "37"],
          type: { max: 8, type: "alphanumeric" }
        }, {
          ids: ["390", "392"],
          type: { max: 15, type: "alphanumeric" }
        }, {
          ids: ["421", "423"],
          type: { min: 3, max: 15, type: "alphanumeric" }
        }, {
          ids: ["391", "393"],
          type: { min: 3, max: 18, type: "alphanumeric" }
        }, {
          ids: ["7003", "8101"],
          type: { length: 10 }
        }]
      },
      START: 102
    });
  };
  States128FNC1.prototype.addStart = function addStart() {
    this.encoding[this.startState].addStart();
  };
  States128FNC1.prototype.is = function is() {
    return inArray(this.key, this.states);
  };
  States128FNC1.prototype.pushState = function pushState(encodingState) {
    var this$1$1 = this;
    var encoding = this.encoding, value2 = encodingState.value.replace(/\s/g, ""), regexSeparators = new RegExp("[" + this.startAI + this.endAI + "]", "g"), index2 = encodingState.index, subState = {
      state: this.startState
    }, current2, nextStart, separatorLength;
    encoding.addPattern(this.START);
    var trueCondition = true;
    while (trueCondition) {
      subState.index = 0;
      separatorLength = value2.charAt(index2) === this$1$1.startAI ? 2 : 0;
      current2 = separatorLength > 0 ? this$1$1.getBySeparator(value2, index2) : this$1$1.getByLength(value2, index2);
      if (current2.ai.length) {
        nextStart = index2 + separatorLength + current2.id.length + current2.ai.length;
      } else {
        nextStart = value2.indexOf(this$1$1.startAI, index2 + 1);
        if (nextStart < 0) {
          if (index2 + current2.ai.max + current2.id.length + separatorLength < value2.length) {
            throw new Error("Separators are required after variable length identifiers");
          }
          nextStart = value2.length;
        }
      }
      subState.value = value2.substring(index2, nextStart).replace(regexSeparators, "");
      this$1$1.validate(current2, subState.value);
      encoding.pushData(subState, this$1$1.dependentStates);
      if (nextStart >= value2.length) {
        break;
      }
      index2 = nextStart;
      if (subState.state !== this$1$1.startState) {
        encoding[this$1$1.startState].move(subState);
        subState.state = this$1$1.startState;
      }
      if (!current2.ai.length) {
        encoding.addPattern(this$1$1.START);
      }
    }
    encodingState.index = encodingState.value.length;
  };
  States128FNC1.prototype.validate = function validate(current2, value2) {
    var code = value2.substr(current2.id.length), ai2 = current2.ai;
    if (!ai2.type && !numberRegex$1.test(code)) {
      throw new Error("Application identifier " + current2.id + " is numeric only but contains non numeric character(s).");
    }
    if (ai2.type === "alphanumeric" && !alphanumericRegex.test(code)) {
      throw new Error("Application identifier " + current2.id + " is alphanumeric only but contains non alphanumeric character(s).");
    }
    if (ai2.length && ai2.length !== code.length) {
      throw new Error("Application identifier " + current2.id + " must be " + ai2.length + " characters long.");
    }
    if (ai2.min && ai2.min > code.length) {
      throw new Error("Application identifier " + current2.id + " must be at least " + ai2.min + " characters long.");
    }
    if (ai2.max && ai2.max < code.length) {
      throw new Error("Application identifier " + current2.id + " must be at most " + ai2.max + " characters long.");
    }
  };
  States128FNC1.prototype.getByLength = function getByLength(value2, index2) {
    var this$1$1 = this;
    var id2;
    var applicationIdentifier;
    for (var i16 = 2; i16 <= 4; i16++) {
      id2 = getSubstring(value2, index2, i16);
      applicationIdentifier = this$1$1.getApplicationIdentifier(id2) || this$1$1.getApplicationIdentifier(id2.substring(0, id2.length - 1));
      if (applicationIdentifier) {
        return {
          id: id2,
          ai: applicationIdentifier
        };
      }
    }
    this.unsupportedAIError(id2);
  };
  States128FNC1.prototype.unsupportedAIError = function unsupportedAIError(id2) {
    throw new Error("'" + id2 + "' is not a supported Application Identifier");
  };
  States128FNC1.prototype.getBySeparator = function getBySeparator(value2, index2) {
    var start = value2.indexOf(this.startAI, index2), end = value2.indexOf(this.endAI, start), id2 = value2.substring(start + 1, end), ai2 = this.getApplicationIdentifier(id2) || this.getApplicationIdentifier(id2.substr(id2.length - 1));
    if (!ai2) {
      this.unsupportedAIError(id2);
    }
    return {
      ai: ai2,
      id: id2
    };
  };
  States128FNC1.prototype.getApplicationIdentifier = function getApplicationIdentifier(id2) {
    var applicationIdentifier = this.applicationIdentifiers, multiKey = applicationIdentifier.multiKey;
    if (applicationIdentifier[id2]) {
      return applicationIdentifier[id2];
    }
    for (var i16 = 0; i16 < multiKey.length; i16++) {
      if (multiKey[i16].ids && inArray(id2, multiKey[i16].ids)) {
        return multiKey[i16].type;
      } else if (multiKey[i16].ranges) {
        var ranges = multiKey[i16].ranges;
        for (var j2 = 0; j2 < ranges.length; j2++) {
          if (ranges[j2][0] <= id2 && id2 <= ranges[j2][1]) {
            return multiKey[i16].type;
          }
        }
      }
    }
  };
  return States128FNC1;
}(State128);
var Code128Base = function(Encoding2) {
  function Code128Base2(options2) {
    Encoding2.call(this, options2);
    this._initStates();
  }
  if (Encoding2)
    Code128Base2.__proto__ = Encoding2;
  Code128Base2.prototype = Object.create(Encoding2 && Encoding2.prototype);
  Code128Base2.prototype.constructor = Code128Base2;
  Code128Base2.prototype.initProperties = function initProperties() {
    Encoding2.prototype.initProperties.call(this);
    extend$8(this, {
      characterMap: [
        212222,
        222122,
        222221,
        121223,
        121322,
        131222,
        122213,
        122312,
        132212,
        221213,
        221312,
        231212,
        112232,
        122132,
        122231,
        113222,
        123122,
        123221,
        223211,
        221132,
        221231,
        213212,
        223112,
        312131,
        311222,
        321122,
        321221,
        312212,
        322112,
        322211,
        212123,
        212321,
        232121,
        111323,
        131123,
        131321,
        112313,
        132113,
        132311,
        211313,
        231113,
        231311,
        112133,
        112331,
        132131,
        113123,
        113321,
        133121,
        313121,
        211331,
        231131,
        213113,
        213311,
        213131,
        311123,
        311321,
        331121,
        312113,
        312311,
        332111,
        314111,
        221411,
        431111,
        111224,
        111422,
        121124,
        121421,
        141122,
        141221,
        112214,
        112412,
        122114,
        122411,
        142112,
        142211,
        241211,
        221114,
        413111,
        241112,
        134111,
        111242,
        121142,
        121241,
        114212,
        124112,
        124211,
        411212,
        421112,
        421211,
        212141,
        214121,
        412121,
        111143,
        111341,
        131141,
        114113,
        114311,
        411113,
        411311,
        113141,
        114131,
        311141,
        411131,
        211412,
        211214,
        211232,
        2331112
      ],
      STOP: 106
    });
  };
  Code128Base2.prototype._initStates = function _initStates() {
    var this$1$1 = this;
    for (var i16 = 0; i16 < this.states.length; i16++) {
      this$1$1[this$1$1.states[i16]] = new states128[this$1$1.states[i16]](this$1$1, this$1$1.states);
    }
  };
  Code128Base2.prototype.initValue = function initValue(value2, width, height) {
    this.pattern = [];
    this.value = value2;
    this.width = width;
    this.height = height;
    this.checkSum = 0;
    this.totalUnits = 0;
    this.index = 0;
    this.position = 1;
  };
  Code128Base2.prototype.addData = function addData() {
    var encodingState = {
      value: this.value,
      index: 0,
      state: ""
    };
    if (this.value.length === 0) {
      return;
    }
    encodingState.state = encodingState.previousState = this.getNextState(encodingState, this.states);
    this.addStart(encodingState);
    this.pushData(encodingState, this.states);
    this.addCheckSum();
    this.addStop();
    this.setBaseUnit();
  };
  Code128Base2.prototype.pushData = function pushData(encodingState, states) {
    var this$1$1 = this;
    var trueCondition = true;
    while (trueCondition) {
      this$1$1[encodingState.state].pushState(encodingState);
      if (encodingState.index >= encodingState.value.length) {
        break;
      }
      if (!encodingState.shifted) {
        encodingState.previousState = encodingState.state;
        encodingState.state = this$1$1.getNextState(encodingState, states);
        this$1$1[encodingState.state].move(encodingState);
      } else {
        var temp = encodingState.state;
        encodingState.state = encodingState.previousState;
        encodingState.previousState = temp;
        encodingState.shifted = false;
      }
    }
  };
  Code128Base2.prototype.addStart = function addStart(encodingState) {
    this[encodingState.state].addStart(encodingState);
    this.position = 1;
  };
  Code128Base2.prototype.addCheckSum = function addCheckSum() {
    this.checksum = this.checkSum % 103;
    this.addPattern(this.checksum);
  };
  Code128Base2.prototype.addStop = function addStop() {
    this.addPattern(this.STOP);
  };
  Code128Base2.prototype.setBaseUnit = function setBaseUnit() {
    this.baseUnit = this.width / (this.totalUnits + this.quietZoneLength);
  };
  Code128Base2.prototype.addPattern = function addPattern(code) {
    var this$1$1 = this;
    var pattern = this.characterMap[code].toString();
    var value2;
    for (var i16 = 0; i16 < pattern.length; i16++) {
      value2 = parseInt(pattern.charAt(i16), 10);
      this$1$1.pattern.push(value2);
      this$1$1.totalUnits += value2;
    }
    this.checkSum += code * this.position++;
  };
  Code128Base2.prototype.getNextState = function getNextState(encodingState, states) {
    var this$1$1 = this;
    for (var i16 = 0; i16 < states.length; i16++) {
      if (this$1$1[states[i16]].is(encodingState.value, encodingState.index)) {
        return states[i16];
      }
    }
    this.invalidCharacterError(encodingState.value.charAt(encodingState.index));
  };
  return Code128Base2;
}(Encoding);
var Code128a = function(Code128Base2) {
  function Code128a2() {
    Code128Base2.apply(this, arguments);
  }
  if (Code128Base2)
    Code128a2.__proto__ = Code128Base2;
  Code128a2.prototype = Object.create(Code128Base2 && Code128Base2.prototype);
  Code128a2.prototype.constructor = Code128a2;
  Code128a2.prototype.initProperties = function initProperties() {
    Code128Base2.prototype.initProperties.call(this);
    extend$8(this, {
      name: "Code 128 A",
      states: ["A"]
    });
  };
  return Code128a2;
}(Code128Base);
var Code128b = function(Code128Base2) {
  function Code128b2() {
    Code128Base2.apply(this, arguments);
  }
  if (Code128Base2)
    Code128b2.__proto__ = Code128Base2;
  Code128b2.prototype = Object.create(Code128Base2 && Code128Base2.prototype);
  Code128b2.prototype.constructor = Code128b2;
  Code128b2.prototype.initProperties = function initProperties() {
    Code128Base2.prototype.initProperties.call(this);
    extend$8(this, {
      name: "Code 128 B",
      states: ["B"]
    });
  };
  return Code128b2;
}(Code128Base);
var Code128c = function(Code128Base2) {
  function Code128c2() {
    Code128Base2.apply(this, arguments);
  }
  if (Code128Base2)
    Code128c2.__proto__ = Code128Base2;
  Code128c2.prototype = Object.create(Code128Base2 && Code128Base2.prototype);
  Code128c2.prototype.constructor = Code128c2;
  Code128c2.prototype.initProperties = function initProperties() {
    Code128Base2.prototype.initProperties.call(this);
    extend$8(this, {
      name: "Code 128 C",
      states: ["C"]
    });
  };
  return Code128c2;
}(Code128Base);
var Code128 = function(Code128Base2) {
  function Code1282() {
    Code128Base2.apply(this, arguments);
  }
  if (Code128Base2)
    Code1282.__proto__ = Code128Base2;
  Code1282.prototype = Object.create(Code128Base2 && Code128Base2.prototype);
  Code1282.prototype.constructor = Code1282;
  Code1282.prototype.initProperties = function initProperties() {
    Code128Base2.prototype.initProperties.call(this);
    extend$8(this, {
      name: "Code 128",
      states: ["C", "B", "A", "FNC4"]
    });
  };
  return Code1282;
}(Code128Base);
var CodeGS1128 = function(Code128Base2) {
  function CodeGS11282() {
    Code128Base2.apply(this, arguments);
  }
  if (Code128Base2)
    CodeGS11282.__proto__ = Code128Base2;
  CodeGS11282.prototype = Object.create(Code128Base2 && Code128Base2.prototype);
  CodeGS11282.prototype.constructor = CodeGS11282;
  CodeGS11282.prototype.initProperties = function initProperties() {
    Code128Base2.prototype.initProperties.call(this);
    extend$8(this, {
      name: "Code GS1-128",
      states: ["FNC1", "C", "B"]
    });
  };
  return CodeGS11282;
}(Code128Base);
function getSubstring(value2, index2, count) {
  return value2.substring(index2, index2 + count);
}
var extend$7 = Object.assign;
var MsiBase = function(Encoding2) {
  function MsiBase2() {
    Encoding2.apply(this, arguments);
  }
  if (Encoding2)
    MsiBase2.__proto__ = Encoding2;
  MsiBase2.prototype = Object.create(Encoding2 && Encoding2.prototype);
  MsiBase2.prototype.constructor = MsiBase2;
  MsiBase2.prototype.initProperties = function initProperties() {
    Encoding2.prototype.initProperties.call(this);
    extend$7(this, {
      characterMap: [
        "12121212",
        "12121221",
        "12122112",
        "12122121",
        "12211212",
        "12211221",
        "12212112",
        "12212121",
        "21121212",
        "21121221"
      ],
      START: "21",
      STOP: "121",
      checkSumType: "",
      checkSums
    });
  };
  MsiBase2.prototype.initValue = function initValue(value2, width) {
    this.pattern = [];
    this.value = value2;
    this.checkSumLength = 0;
    this.width = width;
  };
  MsiBase2.prototype.setBaseUnit = function setBaseUnit() {
    var startStopLength = 7;
    this.baseUnit = this.width / (12 * (this.value.length + this.checkSumLength) + this.quietZoneLength + startStopLength);
  };
  MsiBase2.prototype.addData = function addData() {
    var this$1$1 = this;
    var value2 = this.value;
    this.addPattern(this.START);
    for (var i16 = 0; i16 < value2.length; i16++) {
      this$1$1.addCharacter(value2.charAt(i16));
    }
    if (this.options.addCheckSum) {
      this.addCheckSum();
    }
    this.addPattern(this.STOP);
    this.setBaseUnit();
  };
  MsiBase2.prototype.addCharacter = function addCharacter2(character) {
    var pattern = this.characterMap[character];
    if (!pattern) {
      this.invalidCharacterError(character);
    }
    this.addPattern(pattern);
  };
  MsiBase2.prototype.addPattern = function addPattern(pattern) {
    var this$1$1 = this;
    for (var i16 = 0; i16 < pattern.length; i16++) {
      this$1$1.pattern.push(parseInt(pattern.charAt(i16), 10));
    }
  };
  MsiBase2.prototype.addCheckSum = function addCheckSum() {
    var this$1$1 = this;
    var checkSumFunction = this.checkSums[this.checkSumType];
    var checkValues = checkSumFunction.call(this.checkSums, this.value);
    this.checksum = checkValues.join("");
    for (var i16 = 0; i16 < checkValues.length; i16++) {
      this$1$1.checkSumLength++;
      this$1$1.addPattern(this$1$1.characterMap[checkValues[i16]]);
    }
  };
  return MsiBase2;
}(Encoding);
var MsiMod10 = function(MsiBase2) {
  function MsiMod102() {
    MsiBase2.apply(this, arguments);
  }
  if (MsiBase2)
    MsiMod102.__proto__ = MsiBase2;
  MsiMod102.prototype = Object.create(MsiBase2 && MsiBase2.prototype);
  MsiMod102.prototype.constructor = MsiMod102;
  MsiMod102.prototype.initProperties = function initProperties() {
    MsiBase2.prototype.initProperties.call(this);
    extend$7(this, {
      name: "MSI Modulo10",
      checkSumType: "Modulo10"
    });
  };
  return MsiMod102;
}(MsiBase);
var MsiMod11 = function(MsiBase2) {
  function MsiMod112() {
    MsiBase2.apply(this, arguments);
  }
  if (MsiBase2)
    MsiMod112.__proto__ = MsiBase2;
  MsiMod112.prototype = Object.create(MsiBase2 && MsiBase2.prototype);
  MsiMod112.prototype.constructor = MsiMod112;
  MsiMod112.prototype.initProperties = function initProperties() {
    MsiBase2.prototype.initProperties.call(this);
    extend$7(this, {
      name: "MSI Modulo11",
      checkSumType: "Modulo11"
    });
  };
  return MsiMod112;
}(MsiBase);
var MsiMod1010 = function(MsiBase2) {
  function MsiMod10102() {
    MsiBase2.apply(this, arguments);
  }
  if (MsiBase2)
    MsiMod10102.__proto__ = MsiBase2;
  MsiMod10102.prototype = Object.create(MsiBase2 && MsiBase2.prototype);
  MsiMod10102.prototype.constructor = MsiMod10102;
  MsiMod10102.prototype.initProperties = function initProperties() {
    MsiBase2.prototype.initProperties.call(this);
    extend$7(this, {
      name: "MSI Modulo10 Modulo10",
      checkSumType: "Modulo10Modulo10"
    });
  };
  return MsiMod10102;
}(MsiBase);
var MsiMod1110 = function(MsiBase2) {
  function MsiMod11102() {
    MsiBase2.apply(this, arguments);
  }
  if (MsiBase2)
    MsiMod11102.__proto__ = MsiBase2;
  MsiMod11102.prototype = Object.create(MsiBase2 && MsiBase2.prototype);
  MsiMod11102.prototype.constructor = MsiMod11102;
  MsiMod11102.prototype.initProperties = function initProperties() {
    MsiBase2.prototype.initProperties.call(this);
    extend$7(this, {
      name: "MSI Modulo11 Modulo10",
      checkSumType: "Modulo11Modulo10"
    });
  };
  return MsiMod11102;
}(MsiBase);
var checkSums = {
  Modulo10: function Modulo10(value2) {
    var checkValues = [0, ""], odd = value2.length % 2, idx, evenSum, oddSum;
    for (idx = 0; idx < value2.length; idx++) {
      checkValues[(idx + odd) % 2] += parseInt(value2.charAt(idx), 10);
    }
    oddSum = checkValues[0];
    evenSum = (checkValues[1] * 2).toString();
    for (idx = 0; idx < evenSum.length; idx++) {
      oddSum += parseInt(evenSum.charAt(idx), 10);
    }
    return [(10 - oddSum % 10) % 10];
  },
  Modulo11: function Modulo11(value2) {
    var weightedSum = 0, mod = 11, length = value2.length, weight, checkValue;
    for (var i16 = 0; i16 < length; i16++) {
      weight = ((length - i16) % 6 || 6) + 1;
      weightedSum += weight * value2.charAt(i16);
    }
    checkValue = (mod - weightedSum % mod) % mod;
    if (checkValue !== 10) {
      return [checkValue];
    }
    return [1, 0];
  },
  Modulo11Modulo10: function Modulo11Modulo10(value2) {
    var checkValues = this.Modulo11(value2), mod11Value;
    mod11Value = value2 + checkValues[0];
    return checkValues.concat(this.Modulo10(mod11Value));
  },
  Modulo10Modulo10: function Modulo10Modulo10(value2) {
    var checkValues = this.Modulo10(value2), mod10Value;
    mod10Value = value2 + checkValues[0];
    return checkValues.concat(this.Modulo10(mod10Value));
  }
};
var extend$6 = Object.assign;
var Ean13 = function(Encoding2) {
  function Ean132() {
    Encoding2.apply(this, arguments);
  }
  if (Encoding2)
    Ean132.__proto__ = Encoding2;
  Ean132.prototype = Object.create(Encoding2 && Encoding2.prototype);
  Ean132.prototype.constructor = Ean132;
  Ean132.prototype.initProperties = function initProperties() {
    Encoding2.prototype.initProperties.call(this);
    extend$6(this, {
      name: "EAN 13",
      keyTable: [
        "000000",
        "001011",
        "001101",
        "001110",
        "010011",
        "011001",
        "011100",
        "010101",
        "010110",
        "011010"
      ],
      characterMap: {
        digits: [
          [3, 2, 1, 1],
          [2, 2, 2, 1],
          [2, 1, 2, 2],
          [1, 4, 1, 1],
          [1, 1, 3, 2],
          [1, 2, 3, 1],
          [1, 1, 1, 4],
          [1, 3, 1, 2],
          [1, 2, 1, 3],
          [3, 1, 1, 2]
        ],
        start: [1, 1, 1],
        middle: [1, 1, 1, 1, 1]
      }
    });
  };
  Ean132.prototype.initValue = function initValue(value2, width, height) {
    var valueAsString = String(value2);
    if (valueAsString.length !== 12 || /\D/.test(valueAsString)) {
      throw new Error('The value of the "EAN13" encoding should be 12 symbols');
    }
    this.pattern = [];
    this.options.height = height;
    this.baseUnit = width / (95 + this.quietZoneLength);
    this.value = valueAsString;
    this.checksum = this.calculateChecksum();
    this.leftKey = valueAsString[0];
    this.leftPart = valueAsString.substr(1, 6);
    this.rightPart = valueAsString.substr(7) + this.checksum;
  };
  Ean132.prototype.addData = function addData() {
    this.addPieces(this.characterMap.start);
    this.addSide(this.leftPart, this.leftKey);
    this.addPieces(this.characterMap.middle);
    this.addSide(this.rightPart);
    this.addPieces(this.characterMap.start);
  };
  Ean132.prototype.addSide = function addSide(leftPart, key) {
    var this$1$1 = this;
    for (var i16 = 0; i16 < leftPart.length; i16++) {
      if (key && parseInt(this$1$1.keyTable[key].charAt(i16), 10)) {
        this$1$1.addPieces(Array.prototype.slice.call(this$1$1.characterMap.digits[leftPart.charAt(i16)]).reverse(), true);
      } else {
        this$1$1.addPieces(this$1$1.characterMap.digits[leftPart.charAt(i16)], true);
      }
    }
  };
  Ean132.prototype.addPieces = function addPieces(arrToAdd, limitedHeight) {
    var this$1$1 = this;
    for (var i16 = 0; i16 < arrToAdd.length; i16++) {
      if (limitedHeight) {
        this$1$1.pattern.push({
          y1: 0,
          y2: this$1$1.options.height * 0.95,
          width: arrToAdd[i16]
        });
      } else {
        this$1$1.pattern.push(arrToAdd[i16]);
      }
    }
  };
  Ean132.prototype.calculateChecksum = function calculateChecksum() {
    var odd = 0, even = 0, value2 = this.value.split("").reverse().join("");
    for (var i16 = 0; i16 < value2.length; i16++) {
      if (i16 % 2) {
        even += parseInt(value2.charAt(i16), 10);
      } else {
        odd += parseInt(value2.charAt(i16), 10);
      }
    }
    var checksum = (10 - (3 * odd + even) % 10) % 10;
    return checksum;
  };
  return Ean132;
}(Encoding);
var extend$5 = Object.assign;
var Ean8 = function(Ean132) {
  function Ean82() {
    Ean132.apply(this, arguments);
  }
  if (Ean132)
    Ean82.__proto__ = Ean132;
  Ean82.prototype = Object.create(Ean132 && Ean132.prototype);
  Ean82.prototype.constructor = Ean82;
  Ean82.prototype.initProperties = function initProperties() {
    Ean132.prototype.initProperties.call(this);
    extend$5(this, {
      name: "EAN 8"
    });
  };
  Ean82.prototype.initValue = function initValue(value2, width, height) {
    if (value2.length !== 7 || /\D/.test(value2)) {
      throw new Error("Invalid value provided");
    }
    this.value = value2;
    this.options.height = height;
    this.checksum = this.calculateChecksum(this.value);
    this.leftPart = this.value.substr(0, 4);
    this.rightPart = this.value.substr(4) + this.checksum;
    this.pattern = [];
    this.baseUnit = width / (67 + this.quietZoneLength);
  };
  return Ean82;
}(Ean13);
var Encodings = {
  code11: Code11,
  code39: Code39,
  code39extended: Code39Extended,
  code93: Code93,
  code93extended: Code93Extended,
  code128: Code128,
  code128a: Code128a,
  code128b: Code128b,
  code128c: Code128c
};
Encodings["gs1-128"] = CodeGS1128;
Encodings.msimod10 = MsiMod10;
Encodings.msimod11 = MsiMod11;
Encodings.msimod1010 = MsiMod1010;
Encodings.msimod1110 = MsiMod1110;
Encodings.postnet = Postnet;
Encodings.ean8 = Ean8;
Encodings.ean13 = Ean13;
function surfaceSize(element, surfaceType) {
  var display = element.style.display;
  if (surfaceType === "canvas") {
    element.style.display = "block";
  }
  var size = {
    width: element.clientWidth,
    height: element.clientHeight
  };
  element.style.display = display;
  return size;
}
var DEFAULT_BARCODE_WIDTH = 300;
var DEFAULT_BARCODE_HEIGHT = 100;
var Barcode = function(Class3) {
  function Barcode2(element, options2, errorHandler) {
    if (errorHandler === void 0)
      errorHandler = defaultErrorHandler;
    Class3.call(this);
    this.options = deepExtend({}, this.options, options2);
    this.element = element;
    this.onError = errorHandler;
    this._initElement();
    this._initSurface();
    this._setOptions(options2);
    if (options2 && defined(options2.value)) {
      this.redraw();
    }
  }
  if (Class3)
    Barcode2.__proto__ = Class3;
  Barcode2.prototype = Object.create(Class3 && Class3.prototype);
  Barcode2.prototype.constructor = Barcode2;
  Barcode2.prototype.destroy = function destroy2() {
    this._destroySurface();
  };
  Barcode2.prototype._initElement = function _initElement() {
    addClass2(this.element, "k-barcode");
  };
  Barcode2.prototype._initSurface = function _initSurface() {
    var ref2 = this;
    var options2 = ref2.options;
    var surface = ref2.surface;
    if (!surface || surface.options.type !== options2.renderAs) {
      this._destroySurface();
      this._initSurfaceElement();
      this.surface = this._createSurface();
    }
  };
  Barcode2.prototype._createSurface = function _createSurface() {
    return Surface$2.create(this.surfaceElement, {
      type: this.options.renderAs
    });
  };
  Barcode2.prototype._destroySurface = function _destroySurface() {
    if (this.surface) {
      this.surface.destroy();
      this.surface = null;
      this._destroySurfaceElement();
    }
  };
  Barcode2.prototype._initSurfaceElement = function _initSurfaceElement() {
    if (!this.surfaceElement) {
      this.surfaceElement = document.createElement("div");
      this.surfaceElement.style.position = "relative";
      this.element.appendChild(this.surfaceElement);
    }
  };
  Barcode2.prototype._destroySurfaceElement = function _destroySurfaceElement() {
    if (this.surfaceElement && this.surfaceElement.parentNode) {
      this.surfaceElement.parentNode.removeChild(this.surfaceElement);
      this.surfaceElement = null;
    }
  };
  Barcode2.prototype.setOptions = function setOptions(options2) {
    this._setOptions(options2);
    this._initSurface();
    this.redraw();
  };
  Barcode2.prototype.redraw = function redraw() {
    var size = this._getSize();
    this.surface.clear();
    this.surface.setSize({
      width: size.width,
      height: size.height
    });
    this.createVisual();
    this.surface.draw(this.visual);
  };
  Barcode2.prototype.getSize = function getSize() {
    return {
      width: this.element.offsetWidth,
      height: this.element.offsetHeight
    };
  };
  Barcode2.prototype._resize = function _resize() {
    this.redraw();
  };
  Barcode2.prototype.createVisual = function createVisual() {
    this.visual = this._render();
  };
  Barcode2.prototype._render = function _render() {
    var options2 = this.options;
    var value2 = options2.value;
    var textOptions = options2.text;
    var textMargin = getSpacing(textOptions.margin);
    var size = this._getSize();
    var border = options2.border || {};
    var encoding = this.encoding;
    var contentBox = new Box(0, 0, size.width, size.height).unpad(border.width).unpad(options2.padding);
    var barHeight = contentBox.height();
    var encodedValue;
    var textToDisplay;
    var textHeight;
    var visual = new Group$9();
    this.contentBox = contentBox;
    visual.append(this._getBackground(size));
    if (textOptions.visible) {
      textHeight = measureText(value2, { font: textOptions.font }).height;
      barHeight -= textHeight + textMargin.top + textMargin.bottom;
    }
    try {
      encodedValue = encoding.encode(value2, contentBox.width(), barHeight);
    } catch (error2) {
      this.onError(error2);
      return visual;
    }
    if (textOptions.visible) {
      textToDisplay = value2;
      if (options2.checksum && defined(encoding.checksum)) {
        textToDisplay += " " + encoding.checksum;
      }
      visual.append(this._getText(textToDisplay));
    }
    this.barHeight = barHeight;
    this._bandsGroup = this._getBands(encodedValue.pattern, encodedValue.baseUnit);
    visual.append(this._bandsGroup);
    return visual;
  };
  Barcode2.prototype.exportVisual = function exportVisual() {
    return this._render();
  };
  Barcode2.prototype._getSize = function _getSize() {
    var element = this.element;
    var elementSize2 = surfaceSize(element, this.options.renderAs);
    var size = new Size$1(DEFAULT_BARCODE_WIDTH, DEFAULT_BARCODE_HEIGHT);
    if (elementSize2.width > 0) {
      size.width = elementSize2.width;
    }
    if (elementSize2.height > 0) {
      size.height = elementSize2.height;
    }
    if (this.options.width) {
      size.width = this.options.width;
    }
    if (this.options.height) {
      size.height = this.options.height;
    }
    return size;
  };
  Barcode2.prototype.value = function value2(value$1) {
    if (!defined(value$1)) {
      return this.options.value;
    }
    this.options.value = String(value$1);
    this.redraw();
  };
  Barcode2.prototype._getBands = function _getBands(pattern, baseUnit) {
    var this$1$1 = this;
    var contentBox = this.contentBox;
    var offsetX = contentBox.x1;
    var stepX;
    var patternItem;
    var group2 = new Group$9();
    for (var i16 = 0; i16 < pattern.length; i16++) {
      patternItem = isObject(pattern[i16]) ? pattern[i16] : {
        width: pattern[i16],
        y1: 0,
        y2: this$1$1.barHeight
      };
      stepX = patternItem.width * baseUnit;
      if (i16 % 2) {
        var rect = Rect$1.fromPoints(
          new Point$7(offsetX, patternItem.y1 + contentBox.y1),
          new Point$7(offsetX + stepX, patternItem.y2 + contentBox.y1)
        );
        var path = Path$7.fromRect(rect, {
          fill: {
            color: this$1$1.options.color
          },
          stroke: null
        });
        group2.append(path);
      }
      offsetX += stepX;
    }
    return group2;
  };
  Barcode2.prototype._getBackground = function _getBackground(size) {
    var options2 = this.options;
    var border = options2.border || {};
    var box = new Box(0, 0, size.width, size.height).unpad(border.width / 2);
    var path = Path$7.fromRect(box.toRect(), {
      fill: {
        color: options2.background
      },
      stroke: {
        color: border.width ? border.color : "",
        width: border.width,
        dashType: border.dashType
      }
    });
    return path;
  };
  Barcode2.prototype._getText = function _getText(value2) {
    var textOptions = this.options.text;
    var text = this._textbox = new TextBox(value2, {
      font: textOptions.font,
      color: textOptions.color,
      align: "center",
      vAlign: "bottom",
      margin: textOptions.margin
    });
    text.reflow(this.contentBox);
    text.renderVisual();
    return text.visual;
  };
  Barcode2.prototype._setOptions = function _setOptions(options2) {
    this.type = (options2.type || this.options.type).toLowerCase();
    if (this.type === "upca") {
      this.type = "ean13";
      options2.value = "0" + options2.value;
    }
    if (this.type === "upce") {
      this.type = "ean8";
      options2.value = "0" + options2.value;
    }
    if (!Encodings[this.type]) {
      throw new Error("Encoding '" + this.type + "' is not supported.");
    }
    this.encoding = new Encodings[this.type]();
    this.options = deepExtend({}, this.options, options2);
  };
  return Barcode2;
}(Class$1);
setDefaultOptions(Barcode, {
  name: "Barcode",
  renderAs: "svg",
  value: "",
  type: "code39",
  checksum: false,
  width: 0,
  height: 0,
  color: "black",
  background: "white",
  text: {
    visible: true,
    font: "16px Consolas, Monaco, Sans Mono, monospace, sans-serif",
    color: "black",
    margin: {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    }
  },
  border: {
    width: 0,
    dashType: "solid",
    color: "black"
  },
  padding: {
    top: 0,
    bottom: 0,
    left: 0,
    right: 0
  }
});
var extend$4 = Object.assign;
function splitInto(str, chunkLength) {
  var result = [];
  var idx = 0;
  while (idx < str.length) {
    result.push(str.substring(idx, idx + chunkLength));
    idx += chunkLength;
  }
  return result;
}
function toBitsString(value2, length) {
  var bitString = Number(value2).toString(2);
  if (bitString.length < length) {
    bitString = new Array(length - bitString.length + 1).join(0) + bitString;
  }
  return bitString;
}
function toDecimal(value2) {
  return parseInt(value2, 2);
}
var FreeCellVisitor = function(Class3) {
  function FreeCellVisitor2(matrix) {
    Class3.call(this);
    this.matrix = matrix;
    this.row = matrix.length - 1;
    this.column = matrix.length - 1;
    this.startColumn = this.column;
    this.dir = -1;
    this.c = 0;
  }
  if (Class3)
    FreeCellVisitor2.__proto__ = Class3;
  FreeCellVisitor2.prototype = Object.create(Class3 && Class3.prototype);
  FreeCellVisitor2.prototype.constructor = FreeCellVisitor2;
  FreeCellVisitor2.prototype.move = function move() {
    this.row += this.dir * this.c;
    this.c ^= 1;
    this.column = this.startColumn - this.c;
  };
  FreeCellVisitor2.prototype.getNextCell = function getNextCell() {
    var this$1$1 = this;
    while (this.matrix[this.row][this.column] !== void 0) {
      this$1$1.move();
      if (this$1$1.row < 0 || this$1$1.row >= this$1$1.matrix.length) {
        this$1$1.dir = -this$1$1.dir;
        this$1$1.startColumn -= this$1$1.startColumn !== 8 ? 2 : 3;
        this$1$1.column = this$1$1.startColumn;
        this$1$1.row = this$1$1.dir < 0 ? this$1$1.matrix.length - 1 : 0;
      }
    }
    return {
      row: this.row,
      column: this.column
    };
  };
  FreeCellVisitor2.prototype.getNextRemainderCell = function getNextRemainderCell() {
    this.move();
    if (this.matrix[this.row][this.column] === void 0) {
      return {
        row: this.row,
        column: this.column
      };
    }
  };
  return FreeCellVisitor2;
}(Class$1);
var EncodingResult = function(Class3) {
  function EncodingResult2(dataString, version2) {
    Class3.call(this);
    this.dataString = dataString;
    this.version = version2;
  }
  if (Class3)
    EncodingResult2.__proto__ = Class3;
  EncodingResult2.prototype = Object.create(Class3 && Class3.prototype);
  EncodingResult2.prototype.constructor = EncodingResult2;
  return EncodingResult2;
}(Class$1);
var IsoEncoder = function(Class3) {
  function IsoEncoder2() {
    Class3.apply(this, arguments);
  }
  if (Class3)
    IsoEncoder2.__proto__ = Class3;
  IsoEncoder2.prototype = Object.create(Class3 && Class3.prototype);
  IsoEncoder2.prototype.constructor = IsoEncoder2;
  IsoEncoder2.prototype.getEncodingResult = function getEncodingResult(inputString, errorCorrectionLevel) {
    var modes = getModes(inputString), dataCodewordsCount = getDataCodewordsCount(modes), version2 = getVersion(dataCodewordsCount, errorCorrectionLevel), dataString = getDataString(modes, version2);
    return new EncodingResult(dataString, version2);
  };
  return IsoEncoder2;
}(Class$1);
var QRDataMode = function(Class3) {
  function QRDataMode2() {
    Class3.call(this);
    this.initProperties();
  }
  if (Class3)
    QRDataMode2.__proto__ = Class3;
  QRDataMode2.prototype = Object.create(Class3 && Class3.prototype);
  QRDataMode2.prototype.constructor = QRDataMode2;
  QRDataMode2.prototype.initProperties = function initProperties() {
    extend$4(this, {
      modeIndicator: "",
      bitsInCharacterCount: []
    });
  };
  QRDataMode2.prototype.getVersionIndex = function getVersionIndex(version2) {
    if (version2 < 10) {
      return 0;
    } else if (version2 > 26) {
      return 2;
    }
    return 1;
  };
  QRDataMode2.prototype.getBitsCharacterCount = function getBitsCharacterCount(version2) {
    return this.bitsInCharacterCount[this.getVersionIndex(version2 || 40)];
  };
  QRDataMode2.prototype.getModeCountString = function getModeCountString(length, version2) {
    return this.modeIndicator + toBitsString(length, this.getBitsCharacterCount(version2));
  };
  QRDataMode2.prototype.encode = function encode() {
  };
  QRDataMode2.prototype.getStringBitsLength = function getStringBitsLength() {
  };
  QRDataMode2.prototype.getValue = function getValue() {
  };
  return QRDataMode2;
}(Class$1);
var NumericQRDataMode = function(QRDataMode2) {
  function NumericQRDataMode2() {
    QRDataMode2.apply(this, arguments);
  }
  if (QRDataMode2)
    NumericQRDataMode2.__proto__ = QRDataMode2;
  NumericQRDataMode2.prototype = Object.create(QRDataMode2 && QRDataMode2.prototype);
  NumericQRDataMode2.prototype.constructor = NumericQRDataMode2;
  NumericQRDataMode2.prototype.initProperties = function initProperties() {
    QRDataMode2.prototype.initProperties.call(this);
    extend$4(this, {
      bitsInCharacterCount: [10, 12, 14],
      modeIndicator: "0001"
    });
  };
  NumericQRDataMode2.prototype.getValue = function getValue(character) {
    return parseInt(character, 10);
  };
  NumericQRDataMode2.prototype.encode = function encode(str, version2) {
    var mode = this, parts = splitInto(str, 3), result = mode.getModeCountString(str.length, version2);
    var i16;
    for (i16 = 0; i16 < parts.length - 1; i16++) {
      result += toBitsString(parts[i16], 10);
    }
    return result + toBitsString(parts[i16], 1 + 3 * parts[i16].length);
  };
  NumericQRDataMode2.prototype.getStringBitsLength = function getStringBitsLength(inputLength, version2) {
    var mod3 = inputLength % 3;
    return 4 + this.getBitsCharacterCount(version2) + 10 * Math.floor(inputLength / 3) + 3 * mod3 + (mod3 === 0 ? 0 : 1);
  };
  return NumericQRDataMode2;
}(QRDataMode);
var AlphaNumericQRDataMode = function(QRDataMode2) {
  function AlphaNumericQRDataMode2() {
    QRDataMode2.apply(this, arguments);
  }
  if (QRDataMode2)
    AlphaNumericQRDataMode2.__proto__ = QRDataMode2;
  AlphaNumericQRDataMode2.prototype = Object.create(QRDataMode2 && QRDataMode2.prototype);
  AlphaNumericQRDataMode2.prototype.constructor = AlphaNumericQRDataMode2;
  AlphaNumericQRDataMode2.prototype.initProperties = function initProperties() {
    QRDataMode2.prototype.initProperties.call(this);
    extend$4(this, {
      characters: {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7,
        "8": 8,
        "9": 9,
        "A": 10,
        "B": 11,
        "C": 12,
        "D": 13,
        "E": 14,
        "F": 15,
        "G": 16,
        "H": 17,
        "I": 18,
        "J": 19,
        "K": 20,
        "L": 21,
        "M": 22,
        "N": 23,
        "O": 24,
        "P": 25,
        "Q": 26,
        "R": 27,
        "S": 28,
        "T": 29,
        "U": 30,
        "V": 31,
        "W": 32,
        "X": 33,
        "Y": 34,
        "Z": 35,
        " ": 36,
        "$": 37,
        "%": 38,
        "*": 39,
        "+": 40,
        "-": 41,
        ".": 42,
        "/": 43,
        ":": 44
      },
      bitsInCharacterCount: [9, 11, 13],
      modeIndicator: "0010"
    });
  };
  AlphaNumericQRDataMode2.prototype.getValue = function getValue(character) {
    return this.characters[character];
  };
  AlphaNumericQRDataMode2.prototype.encode = function encode(str, version2) {
    var this$1$1 = this;
    var parts = splitInto(str, 2), result = this.getModeCountString(str.length, version2), value2;
    var i16;
    for (i16 = 0; i16 < parts.length - 1; i16++) {
      value2 = 45 * this$1$1.getValue(parts[i16].charAt(0)) + this$1$1.getValue(parts[i16].charAt(1));
      result += toBitsString(value2, 11);
    }
    value2 = parts[i16].length === 2 ? 45 * this.getValue(parts[i16].charAt(0)) + this.getValue(parts[i16].charAt(1)) : this.getValue(parts[i16].charAt(0));
    return result + toBitsString(value2, 1 + 5 * parts[i16].length);
  };
  AlphaNumericQRDataMode2.prototype.getStringBitsLength = function getStringBitsLength(inputLength, version2) {
    return 4 + this.getBitsCharacterCount(version2) + 11 * Math.floor(inputLength / 2) + 6 * (inputLength % 2);
  };
  return AlphaNumericQRDataMode2;
}(QRDataMode);
var ByteQRDataMode = function(QRDataMode2) {
  function ByteQRDataMode2() {
    QRDataMode2.apply(this, arguments);
  }
  if (QRDataMode2)
    ByteQRDataMode2.__proto__ = QRDataMode2;
  ByteQRDataMode2.prototype = Object.create(QRDataMode2 && QRDataMode2.prototype);
  ByteQRDataMode2.prototype.constructor = ByteQRDataMode2;
  ByteQRDataMode2.prototype.initProperties = function initProperties() {
    QRDataMode2.prototype.initProperties.call(this);
    extend$4(this, {
      bitsInCharacterCount: [8, 16, 16],
      modeIndicator: "0100"
    });
  };
  ByteQRDataMode2.prototype.getValue = function getValue(character) {
    var code = character.charCodeAt(0);
    if (code <= 127 || 160 <= code && code <= 255) {
      return code;
    }
    throw new Error('Unsupported character in QR Code: "' + character + '".');
  };
  ByteQRDataMode2.prototype.encode = function encode(str, version2) {
    var mode = this, result = mode.getModeCountString(str.length, version2);
    for (var i16 = 0; i16 < str.length; i16++) {
      result += toBitsString(mode.getValue(str.charAt(i16)), 8);
    }
    return result;
  };
  ByteQRDataMode2.prototype.getStringBitsLength = function getStringBitsLength(inputLength, version2) {
    return 4 + this.getBitsCharacterCount(version2) + 8 * inputLength;
  };
  return ByteQRDataMode2;
}(QRDataMode);
var NUMERIC$1 = "numeric";
var ALPHA_NUMERIC$1 = "alphanumeric";
var BYTE$2 = "byte";
var DataModeInstances = {};
DataModeInstances[NUMERIC$1] = new NumericQRDataMode();
DataModeInstances[ALPHA_NUMERIC$1] = new AlphaNumericQRDataMode();
DataModeInstances[BYTE$2] = new ByteQRDataMode();
var BYTE$1 = "byte";
var Utf8Encoder = function(Class3) {
  function Utf8Encoder2() {
    Class3.call(this);
    this.initProperties();
    this.mode = DataModeInstances[this.encodingMode];
  }
  if (Class3)
    Utf8Encoder2.__proto__ = Class3;
  Utf8Encoder2.prototype = Object.create(Class3 && Class3.prototype);
  Utf8Encoder2.prototype.constructor = Utf8Encoder2;
  Utf8Encoder2.prototype.initProperties = function initProperties() {
    extend$4(this, {
      encodingMode: BYTE$1,
      utfBOM: "111011111011101110111111",
      initialModeCountStringLength: 20,
      ranges: [128, 2048, 65536, 2097152, 67108864]
    });
  };
  Utf8Encoder2.prototype.getEncodingResult = function getEncodingResult(inputString, errorCorrectionLevel) {
    var data2 = this.encode(inputString), dataCodewordsCount = this.getDataCodewordsCount(data2), version2 = getVersion(dataCodewordsCount, errorCorrectionLevel), dataString = this.mode.getModeCountString(data2.length / 8, version2) + data2;
    return new EncodingResult(dataString, version2);
  };
  Utf8Encoder2.prototype.getDataCodewordsCount = function getDataCodewordsCount2(data2) {
    var dataLength = data2.length, dataCodewordsCount = Math.ceil((this.initialModeCountStringLength + dataLength) / 8);
    return dataCodewordsCount;
  };
  Utf8Encoder2.prototype.encode = function encode(str) {
    var this$1$1 = this;
    var result = this.utfBOM;
    for (var i16 = 0; i16 < str.length; i16++) {
      result += this$1$1.encodeCharacter(str.charCodeAt(i16));
    }
    return result;
  };
  Utf8Encoder2.prototype.encodeCharacter = function encodeCharacter(code) {
    var bytesCount = this.getBytesCount(code), bc2 = bytesCount - 1, result = "";
    if (bytesCount === 1) {
      result = toBitsString(code, 8);
    } else {
      var significantOnes = 8 - bytesCount;
      for (var i16 = 0; i16 < bc2; i16++) {
        result = toBitsString(code >> i16 * 6 & 63 | 128, 8) + result;
      }
      result = (code >> bc2 * 6 | 255 >> significantOnes << significantOnes).toString(2) + result;
    }
    return result;
  };
  Utf8Encoder2.prototype.getBytesCount = function getBytesCount(code) {
    var ranges = this.ranges;
    for (var i16 = 0; i16 < ranges.length; i16++) {
      if (code < ranges[i16]) {
        return i16 + 1;
      }
    }
  };
  return Utf8Encoder2;
}(Class$1);
var VersionsCodewordsInformation = [{
  L: {
    groups: [
      [1, 19]
    ],
    totalDataCodewords: 19,
    errorCodewordsPerBlock: 7
  },
  M: {
    groups: [
      [1, 16]
    ],
    totalDataCodewords: 16,
    errorCodewordsPerBlock: 10
  },
  Q: {
    groups: [
      [1, 13]
    ],
    totalDataCodewords: 13,
    errorCodewordsPerBlock: 13
  },
  H: {
    groups: [
      [1, 9]
    ],
    totalDataCodewords: 9,
    errorCodewordsPerBlock: 17
  }
}, {
  L: {
    groups: [
      [1, 34]
    ],
    totalDataCodewords: 34,
    errorCodewordsPerBlock: 10
  },
  M: {
    groups: [
      [1, 28]
    ],
    totalDataCodewords: 28,
    errorCodewordsPerBlock: 16
  },
  Q: {
    groups: [
      [1, 22]
    ],
    totalDataCodewords: 22,
    errorCodewordsPerBlock: 22
  },
  H: {
    groups: [
      [1, 16]
    ],
    totalDataCodewords: 16,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [
      [1, 55]
    ],
    totalDataCodewords: 55,
    errorCodewordsPerBlock: 15
  },
  M: {
    groups: [
      [1, 44]
    ],
    totalDataCodewords: 44,
    errorCodewordsPerBlock: 26
  },
  Q: {
    groups: [
      [2, 17]
    ],
    totalDataCodewords: 34,
    errorCodewordsPerBlock: 18
  },
  H: {
    groups: [
      [2, 13]
    ],
    totalDataCodewords: 26,
    errorCodewordsPerBlock: 22
  }
}, {
  L: {
    groups: [
      [1, 80]
    ],
    totalDataCodewords: 80,
    errorCodewordsPerBlock: 20
  },
  M: {
    groups: [
      [2, 32]
    ],
    totalDataCodewords: 64,
    errorCodewordsPerBlock: 18
  },
  Q: {
    groups: [
      [2, 24]
    ],
    totalDataCodewords: 48,
    errorCodewordsPerBlock: 26
  },
  H: {
    groups: [
      [4, 9]
    ],
    totalDataCodewords: 36,
    errorCodewordsPerBlock: 16
  }
}, {
  L: {
    groups: [
      [1, 108]
    ],
    totalDataCodewords: 108,
    errorCodewordsPerBlock: 26
  },
  M: {
    groups: [
      [2, 43]
    ],
    totalDataCodewords: 86,
    errorCodewordsPerBlock: 24
  },
  Q: {
    groups: [
      [2, 15],
      [2, 16]
    ],
    totalDataCodewords: 62,
    errorCodewordsPerBlock: 18
  },
  H: {
    groups: [
      [2, 11],
      [2, 12]
    ],
    totalDataCodewords: 46,
    errorCodewordsPerBlock: 22
  }
}, {
  L: {
    groups: [
      [2, 68]
    ],
    totalDataCodewords: 136,
    errorCodewordsPerBlock: 18
  },
  M: {
    groups: [
      [4, 27]
    ],
    totalDataCodewords: 108,
    errorCodewordsPerBlock: 16
  },
  Q: {
    groups: [
      [4, 19]
    ],
    totalDataCodewords: 76,
    errorCodewordsPerBlock: 24
  },
  H: {
    groups: [
      [4, 15]
    ],
    totalDataCodewords: 60,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [
      [2, 78]
    ],
    totalDataCodewords: 156,
    errorCodewordsPerBlock: 20
  },
  M: {
    groups: [
      [4, 31]
    ],
    totalDataCodewords: 124,
    errorCodewordsPerBlock: 18
  },
  Q: {
    groups: [
      [2, 14],
      [4, 15]
    ],
    totalDataCodewords: 88,
    errorCodewordsPerBlock: 18
  },
  H: {
    groups: [
      [4, 13],
      [1, 14]
    ],
    totalDataCodewords: 66,
    errorCodewordsPerBlock: 26
  }
}, {
  L: {
    groups: [
      [2, 97]
    ],
    totalDataCodewords: 194,
    errorCodewordsPerBlock: 24
  },
  M: {
    groups: [
      [2, 38],
      [2, 39]
    ],
    totalDataCodewords: 154,
    errorCodewordsPerBlock: 22
  },
  Q: {
    groups: [
      [4, 18],
      [2, 19]
    ],
    totalDataCodewords: 110,
    errorCodewordsPerBlock: 22
  },
  H: {
    groups: [
      [4, 14],
      [2, 15]
    ],
    totalDataCodewords: 86,
    errorCodewordsPerBlock: 26
  }
}, {
  L: {
    groups: [
      [2, 116]
    ],
    totalDataCodewords: 232,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [3, 36],
      [2, 37]
    ],
    totalDataCodewords: 182,
    errorCodewordsPerBlock: 22
  },
  Q: {
    groups: [
      [4, 16],
      [4, 17]
    ],
    totalDataCodewords: 132,
    errorCodewordsPerBlock: 20
  },
  H: {
    groups: [
      [4, 12],
      [4, 13]
    ],
    totalDataCodewords: 100,
    errorCodewordsPerBlock: 24
  }
}, {
  L: {
    groups: [
      [2, 68],
      [2, 69]
    ],
    totalDataCodewords: 274,
    errorCodewordsPerBlock: 18
  },
  M: {
    groups: [
      [4, 43],
      [1, 44]
    ],
    totalDataCodewords: 216,
    errorCodewordsPerBlock: 26
  },
  Q: {
    groups: [
      [6, 19],
      [2, 20]
    ],
    totalDataCodewords: 154,
    errorCodewordsPerBlock: 24
  },
  H: {
    groups: [
      [6, 15],
      [2, 16]
    ],
    totalDataCodewords: 122,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [
      [4, 81]
    ],
    totalDataCodewords: 324,
    errorCodewordsPerBlock: 20
  },
  M: {
    groups: [
      [1, 50],
      [4, 51]
    ],
    totalDataCodewords: 254,
    errorCodewordsPerBlock: 30
  },
  Q: {
    groups: [
      [4, 22],
      [4, 23]
    ],
    totalDataCodewords: 180,
    errorCodewordsPerBlock: 28
  },
  H: {
    groups: [
      [3, 12],
      [8, 13]
    ],
    totalDataCodewords: 140,
    errorCodewordsPerBlock: 24
  }
}, {
  L: {
    groups: [
      [2, 92],
      [2, 93]
    ],
    totalDataCodewords: 370,
    errorCodewordsPerBlock: 24
  },
  M: {
    groups: [
      [6, 36],
      [2, 37]
    ],
    totalDataCodewords: 290,
    errorCodewordsPerBlock: 22
  },
  Q: {
    groups: [
      [4, 20],
      [6, 21]
    ],
    totalDataCodewords: 206,
    errorCodewordsPerBlock: 26
  },
  H: {
    groups: [
      [7, 14],
      [4, 15]
    ],
    totalDataCodewords: 158,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [
      [4, 107]
    ],
    totalDataCodewords: 428,
    errorCodewordsPerBlock: 26
  },
  M: {
    groups: [
      [8, 37],
      [1, 38]
    ],
    totalDataCodewords: 334,
    errorCodewordsPerBlock: 22
  },
  Q: {
    groups: [
      [8, 20],
      [4, 21]
    ],
    totalDataCodewords: 244,
    errorCodewordsPerBlock: 24
  },
  H: {
    groups: [
      [12, 11],
      [4, 12]
    ],
    totalDataCodewords: 180,
    errorCodewordsPerBlock: 22
  }
}, {
  L: {
    groups: [
      [3, 115],
      [1, 116]
    ],
    totalDataCodewords: 461,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [4, 40],
      [5, 41]
    ],
    totalDataCodewords: 365,
    errorCodewordsPerBlock: 24
  },
  Q: {
    groups: [
      [11, 16],
      [5, 17]
    ],
    totalDataCodewords: 261,
    errorCodewordsPerBlock: 20
  },
  H: {
    groups: [
      [11, 12],
      [5, 13]
    ],
    totalDataCodewords: 197,
    errorCodewordsPerBlock: 24
  }
}, {
  L: {
    groups: [
      [5, 87],
      [1, 88]
    ],
    totalDataCodewords: 523,
    errorCodewordsPerBlock: 22
  },
  M: {
    groups: [
      [5, 41],
      [5, 42]
    ],
    totalDataCodewords: 415,
    errorCodewordsPerBlock: 24
  },
  Q: {
    groups: [
      [5, 24],
      [7, 25]
    ],
    totalDataCodewords: 295,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [11, 12],
      [7, 13]
    ],
    totalDataCodewords: 223,
    errorCodewordsPerBlock: 24
  }
}, {
  L: {
    groups: [
      [5, 98],
      [1, 99]
    ],
    totalDataCodewords: 589,
    errorCodewordsPerBlock: 24
  },
  M: {
    groups: [
      [7, 45],
      [3, 46]
    ],
    totalDataCodewords: 453,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [15, 19],
      [2, 20]
    ],
    totalDataCodewords: 325,
    errorCodewordsPerBlock: 24
  },
  H: {
    groups: [
      [3, 15],
      [13, 16]
    ],
    totalDataCodewords: 253,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [1, 107],
      [5, 108]
    ],
    totalDataCodewords: 647,
    errorCodewordsPerBlock: 28
  },
  M: {
    groups: [
      [10, 46],
      [1, 47]
    ],
    totalDataCodewords: 507,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [1, 22],
      [15, 23]
    ],
    totalDataCodewords: 367,
    errorCodewordsPerBlock: 28
  },
  H: {
    groups: [
      [2, 14],
      [17, 15]
    ],
    totalDataCodewords: 283,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [
      [5, 120],
      [1, 121]
    ],
    totalDataCodewords: 721,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [9, 43],
      [4, 44]
    ],
    totalDataCodewords: 563,
    errorCodewordsPerBlock: 26
  },
  Q: {
    groups: [
      [17, 22],
      [1, 23]
    ],
    totalDataCodewords: 397,
    errorCodewordsPerBlock: 28
  },
  H: {
    groups: [
      [2, 14],
      [19, 15]
    ],
    totalDataCodewords: 313,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [
      [3, 113],
      [4, 114]
    ],
    totalDataCodewords: 795,
    errorCodewordsPerBlock: 28
  },
  M: {
    groups: [
      [3, 44],
      [11, 45]
    ],
    totalDataCodewords: 627,
    errorCodewordsPerBlock: 26
  },
  Q: {
    groups: [
      [17, 21],
      [4, 22]
    ],
    totalDataCodewords: 445,
    errorCodewordsPerBlock: 26
  },
  H: {
    groups: [
      [9, 13],
      [16, 14]
    ],
    totalDataCodewords: 341,
    errorCodewordsPerBlock: 26
  }
}, {
  L: {
    groups: [
      [3, 107],
      [5, 108]
    ],
    totalDataCodewords: 861,
    errorCodewordsPerBlock: 28
  },
  M: {
    groups: [
      [3, 41],
      [13, 42]
    ],
    totalDataCodewords: 669,
    errorCodewordsPerBlock: 26
  },
  Q: {
    groups: [
      [15, 24],
      [5, 25]
    ],
    totalDataCodewords: 485,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [15, 15],
      [10, 16]
    ],
    totalDataCodewords: 385,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [
      [4, 116],
      [4, 117]
    ],
    totalDataCodewords: 932,
    errorCodewordsPerBlock: 28
  },
  M: {
    groups: [
      [17, 42]
    ],
    totalDataCodewords: 714,
    errorCodewordsPerBlock: 26
  },
  Q: {
    groups: [
      [17, 22],
      [6, 23]
    ],
    totalDataCodewords: 512,
    errorCodewordsPerBlock: 28
  },
  H: {
    groups: [
      [19, 16],
      [6, 17]
    ],
    totalDataCodewords: 406,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [2, 111],
      [7, 112]
    ],
    totalDataCodewords: 1006,
    errorCodewordsPerBlock: 28
  },
  M: {
    groups: [
      [17, 46]
    ],
    totalDataCodewords: 782,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [7, 24],
      [16, 25]
    ],
    totalDataCodewords: 568,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [34, 13]
    ],
    totalDataCodewords: 442,
    errorCodewordsPerBlock: 24
  }
}, {
  L: {
    groups: [
      [4, 121],
      [5, 122]
    ],
    totalDataCodewords: 1094,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [4, 47],
      [14, 48]
    ],
    totalDataCodewords: 860,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [11, 24],
      [14, 25]
    ],
    totalDataCodewords: 614,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [16, 15],
      [14, 16]
    ],
    totalDataCodewords: 464,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [6, 117],
      [4, 118]
    ],
    totalDataCodewords: 1174,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [6, 45],
      [14, 46]
    ],
    totalDataCodewords: 914,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [11, 24],
      [16, 25]
    ],
    totalDataCodewords: 664,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [30, 16],
      [2, 17]
    ],
    totalDataCodewords: 514,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [8, 106],
      [4, 107]
    ],
    totalDataCodewords: 1276,
    errorCodewordsPerBlock: 26
  },
  M: {
    groups: [
      [8, 47],
      [13, 48]
    ],
    totalDataCodewords: 1e3,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [7, 24],
      [22, 25]
    ],
    totalDataCodewords: 718,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [22, 15],
      [13, 16]
    ],
    totalDataCodewords: 538,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [10, 114],
      [2, 115]
    ],
    totalDataCodewords: 1370,
    errorCodewordsPerBlock: 28
  },
  M: {
    groups: [
      [19, 46],
      [4, 47]
    ],
    totalDataCodewords: 1062,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [28, 22],
      [6, 23]
    ],
    totalDataCodewords: 754,
    errorCodewordsPerBlock: 28
  },
  H: {
    groups: [
      [33, 16],
      [4, 17]
    ],
    totalDataCodewords: 596,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [8, 122],
      [4, 123]
    ],
    totalDataCodewords: 1468,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [22, 45],
      [3, 46]
    ],
    totalDataCodewords: 1128,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [8, 23],
      [26, 24]
    ],
    totalDataCodewords: 808,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [12, 15],
      [28, 16]
    ],
    totalDataCodewords: 628,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [3, 117],
      [10, 118]
    ],
    totalDataCodewords: 1531,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [3, 45],
      [23, 46]
    ],
    totalDataCodewords: 1193,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [4, 24],
      [31, 25]
    ],
    totalDataCodewords: 871,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [11, 15],
      [31, 16]
    ],
    totalDataCodewords: 661,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [7, 116],
      [7, 117]
    ],
    totalDataCodewords: 1631,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [21, 45],
      [7, 46]
    ],
    totalDataCodewords: 1267,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [1, 23],
      [37, 24]
    ],
    totalDataCodewords: 911,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [19, 15],
      [26, 16]
    ],
    totalDataCodewords: 701,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [5, 115],
      [10, 116]
    ],
    totalDataCodewords: 1735,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [19, 47],
      [10, 48]
    ],
    totalDataCodewords: 1373,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [15, 24],
      [25, 25]
    ],
    totalDataCodewords: 985,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [23, 15],
      [25, 16]
    ],
    totalDataCodewords: 745,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [13, 115],
      [3, 116]
    ],
    totalDataCodewords: 1843,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [2, 46],
      [29, 47]
    ],
    totalDataCodewords: 1455,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [42, 24],
      [1, 25]
    ],
    totalDataCodewords: 1033,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [23, 15],
      [28, 16]
    ],
    totalDataCodewords: 793,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [17, 115]
    ],
    totalDataCodewords: 1955,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [10, 46],
      [23, 47]
    ],
    totalDataCodewords: 1541,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [10, 24],
      [35, 25]
    ],
    totalDataCodewords: 1115,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [19, 15],
      [35, 16]
    ],
    totalDataCodewords: 845,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [17, 115],
      [1, 116]
    ],
    totalDataCodewords: 2071,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [14, 46],
      [21, 47]
    ],
    totalDataCodewords: 1631,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [29, 24],
      [19, 25]
    ],
    totalDataCodewords: 1171,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [11, 15],
      [46, 16]
    ],
    totalDataCodewords: 901,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [13, 115],
      [6, 116]
    ],
    totalDataCodewords: 2191,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [14, 46],
      [23, 47]
    ],
    totalDataCodewords: 1725,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [44, 24],
      [7, 25]
    ],
    totalDataCodewords: 1231,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [59, 16],
      [1, 17]
    ],
    totalDataCodewords: 961,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [12, 121],
      [7, 122]
    ],
    totalDataCodewords: 2306,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [12, 47],
      [26, 48]
    ],
    totalDataCodewords: 1812,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [39, 24],
      [14, 25]
    ],
    totalDataCodewords: 1286,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [22, 15],
      [41, 16]
    ],
    totalDataCodewords: 986,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [6, 121],
      [14, 122]
    ],
    totalDataCodewords: 2434,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [6, 47],
      [34, 48]
    ],
    totalDataCodewords: 1914,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [46, 24],
      [10, 25]
    ],
    totalDataCodewords: 1354,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [2, 15],
      [64, 16]
    ],
    totalDataCodewords: 1054,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [17, 122],
      [4, 123]
    ],
    totalDataCodewords: 2566,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [29, 46],
      [14, 47]
    ],
    totalDataCodewords: 1992,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [49, 24],
      [10, 25]
    ],
    totalDataCodewords: 1426,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [24, 15],
      [46, 16]
    ],
    totalDataCodewords: 1096,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [4, 122],
      [18, 123]
    ],
    totalDataCodewords: 2702,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [13, 46],
      [32, 47]
    ],
    totalDataCodewords: 2102,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [48, 24],
      [14, 25]
    ],
    totalDataCodewords: 1502,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [42, 15],
      [32, 16]
    ],
    totalDataCodewords: 1142,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [20, 117],
      [4, 118]
    ],
    totalDataCodewords: 2812,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [40, 47],
      [7, 48]
    ],
    totalDataCodewords: 2216,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [43, 24],
      [22, 25]
    ],
    totalDataCodewords: 1582,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [10, 15],
      [67, 16]
    ],
    totalDataCodewords: 1222,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [19, 118],
      [6, 119]
    ],
    totalDataCodewords: 2956,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [18, 47],
      [31, 48]
    ],
    totalDataCodewords: 2334,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [34, 24],
      [34, 25]
    ],
    totalDataCodewords: 1666,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [20, 15],
      [61, 16]
    ],
    totalDataCodewords: 1276,
    errorCodewordsPerBlock: 30
  }
}];
var terminator = "0000", NUMERIC = "numeric", ALPHA_NUMERIC = "alphanumeric", BYTE = "byte", powersOfTwo = { "1": 0 }, powersOfTwoResult = { "0": 1 }, irregularAlignmentPatternsStartDistance = {
  15: 20,
  16: 20,
  18: 24,
  19: 24,
  22: 20,
  24: 22,
  26: 24,
  28: 20,
  30: 20,
  31: 24,
  32: 28,
  33: 24,
  36: 18,
  37: 22,
  39: 20,
  40: 24
}, finderPattern = [1, 0, 1, 1, 1], alignmentPattern = [1, 0, 1], errorCorrectionPatterns = { L: "01", M: "00", Q: "11", H: "10" }, formatMaskPattern = "101010000010010", formatGeneratorPolynomial = "10100110111", versionGeneratorPolynomial = "1111100100101", paddingCodewords = ["11101100", "00010001"], finderPatternValue = 93, maskPatternConditions = [
  function(row, column) {
    return (row + column) % 2 === 0;
  },
  function(row, column) {
    return row % 2 === 0;
  },
  function(row, column) {
    return column % 3 === 0;
  },
  function(row, column) {
    return (row + column) % 3 === 0;
  },
  function(row, column) {
    return (Math.floor(row / 2) + Math.floor(column / 3)) % 2 === 0;
  },
  function(row, column) {
    return row * column % 2 + row * column % 3 === 0;
  },
  function(row, column) {
    return (row * column % 2 + row * column % 3) % 2 === 0;
  },
  function(row, column) {
    return ((row + column) % 2 + row * column % 3) % 2 === 0;
  }
], numberRegex = /^\d+/, alphaPattern = "A-Z0-9 $%*+./:-", alphaExclusiveSet = "A-Z $%*+./:-", alphaRegex = new RegExp("^[" + alphaExclusiveSet + "]+"), alphaNumericRegex = new RegExp("^[" + alphaPattern + "]+"), byteRegex = new RegExp("^[^" + alphaPattern + "]+"), initMinNumericBeforeAlpha = 8, initMinNumericBeforeByte = 5, initMinAlphaBeforeByte = 8, minNumericBeforeAlpha = 17, minNumericBeforeByte = 9, minAlphaBeforeByte = 16;
var generatorPolynomials = [[1, 0], [1, 25, 0]];
function fillFunctionCell(matrices, bit, x3, y4) {
  for (var i16 = 0; i16 < matrices.length; i16++) {
    matrices[i16][x3][y4] = bit;
  }
}
function fillDataCell(matrices, bit, x3, y4) {
  for (var i16 = 0; i16 < maskPatternConditions.length; i16++) {
    matrices[i16][x3][y4] = maskPatternConditions[i16](x3, y4) ? bit ^ 1 : parseInt(bit, 10);
  }
}
function fillData(matrices, blocks) {
  var cellVisitor = new FreeCellVisitor(matrices[0]), block, codewordIdx, cell;
  for (var blockIdx = 0; blockIdx < blocks.length; blockIdx++) {
    block = blocks[blockIdx];
    codewordIdx = 0;
    while (block.length > 0) {
      for (var i16 = 0; i16 < block.length; i16++) {
        for (var j2 = 0; j2 < 8; j2++) {
          cell = cellVisitor.getNextCell();
          fillDataCell(matrices, block[i16][codewordIdx].charAt(j2), cell.row, cell.column);
        }
      }
      codewordIdx++;
      while (block[0] && codewordIdx === block[0].length) {
        block.splice(0, 1);
      }
    }
  }
  while (cell = cellVisitor.getNextRemainderCell()) {
    fillDataCell(matrices, 0, cell.row, cell.column);
  }
}
function padDataString(initialDataString, totalDataCodewords) {
  var dataBitsCount = totalDataCodewords * 8, terminatorIndex = 0, paddingCodewordIndex = 0;
  var dataString = initialDataString;
  while (dataString.length < dataBitsCount && terminatorIndex < terminator.length) {
    dataString += terminator.charAt(terminatorIndex++);
  }
  if (dataString.length % 8 !== 0) {
    dataString += new Array(9 - dataString.length % 8).join("0");
  }
  while (dataString.length < dataBitsCount) {
    dataString += paddingCodewords[paddingCodewordIndex];
    paddingCodewordIndex ^= 1;
  }
  return dataString;
}
function generatePowersOfTwo() {
  var result;
  var power;
  for (power = 1; power < 255; power++) {
    result = powersOfTwoResult[power - 1] * 2;
    if (result > 255) {
      result = result ^ 285;
    }
    powersOfTwoResult[power] = result;
    powersOfTwo[result] = power;
  }
  result = powersOfTwoResult[power - 1] * 2 ^ 285;
  powersOfTwoResult[power] = result;
  powersOfTwoResult[-1] = 0;
}
function xorPolynomials(x3, y4) {
  var result = [], idx = x3.length - 2;
  for (var i16 = idx; i16 >= 0; i16--) {
    result[i16] = x3[i16] ^ y4[i16];
  }
  return result;
}
function multiplyPolynomials(x3, y4) {
  var result = [];
  for (var i16 = 0; i16 < x3.length; i16++) {
    for (var j2 = 0; j2 < y4.length; j2++) {
      if (result[i16 + j2] === void 0) {
        result[i16 + j2] = (x3[i16] + (y4[j2] >= 0 ? y4[j2] : 0)) % 255;
      } else {
        result[i16 + j2] = powersOfTwo[powersOfTwoResult[result[i16 + j2]] ^ powersOfTwoResult[(x3[i16] + y4[j2]) % 255]];
      }
    }
  }
  return result;
}
function generateGeneratorPolynomials() {
  var maxErrorCorrectionCodeWordsCount = 68;
  for (var idx = 2; idx <= maxErrorCorrectionCodeWordsCount; idx++) {
    var firstPolynomial = generatorPolynomials[idx - 1], secondPolynomial = [idx, 0];
    generatorPolynomials[idx] = multiplyPolynomials(firstPolynomial, secondPolynomial);
  }
}
generatePowersOfTwo();
generateGeneratorPolynomials();
function multiplyByConstant(polynomial, power) {
  var result = [], idx = polynomial.length - 1;
  do {
    result[idx] = powersOfTwoResult[(polynomial[idx] + power) % 255];
    idx--;
  } while (polynomial[idx] !== void 0);
  return result;
}
function generateErrorCodewords(data2, errorCodewordsCount) {
  var generator = generatorPolynomials[errorCodewordsCount - 1], result = new Array(errorCodewordsCount).concat(data2), generatorPolynomial = new Array(result.length - generator.length).concat(generator), steps = data2.length, errorCodewords = [], divisor, idx;
  for (idx = 0; idx < steps; idx++) {
    divisor = multiplyByConstant(generatorPolynomial, powersOfTwo[result[result.length - 1]]);
    generatorPolynomial.splice(0, 1);
    result = xorPolynomials(divisor, result);
  }
  for (idx = result.length - 1; idx >= 0; idx--) {
    errorCodewords[errorCodewordsCount - 1 - idx] = toBitsString(result[idx], 8);
  }
  return errorCodewords;
}
function getBlocks(dataStream, versionCodewordsInformation) {
  var codewordStart = 0, dataBlocks = [], errorBlocks = [], dataBlock, versionGroups = versionCodewordsInformation.groups, blockCodewordsCount, groupBlocksCount, messagePolynomial, codeword;
  for (var groupIdx = 0; groupIdx < versionGroups.length; groupIdx++) {
    groupBlocksCount = versionGroups[groupIdx][0];
    for (var blockIdx = 0; blockIdx < groupBlocksCount; blockIdx++) {
      blockCodewordsCount = versionGroups[groupIdx][1];
      dataBlock = [];
      messagePolynomial = [];
      for (var codewordIdx = 1; codewordIdx <= blockCodewordsCount; codewordIdx++) {
        codeword = dataStream.substring(codewordStart, codewordStart + 8);
        dataBlock.push(codeword);
        messagePolynomial[blockCodewordsCount - codewordIdx] = toDecimal(codeword);
        codewordStart += 8;
      }
      dataBlocks.push(dataBlock);
      errorBlocks.push(generateErrorCodewords(
        messagePolynomial,
        versionCodewordsInformation.errorCodewordsPerBlock
      ));
    }
  }
  return [dataBlocks, errorBlocks];
}
function chooseMode(str, minNumericBeforeAlpha2, minNumericBeforeByte2, minAlphaBeforeByte2, previousMode) {
  var numeric = numberRegex.exec(str), numericMatch = numeric ? numeric[0] : "", alpha = alphaRegex.exec(str), alphaMatch = alpha ? alpha[0] : "", alphaNumeric = alphaNumericRegex.exec(str), alphaNumericMatch = alphaNumeric ? alphaNumeric[0] : "", mode, modeString;
  if (numericMatch && (numericMatch.length >= minNumericBeforeAlpha2 || str.length === numericMatch.length || numericMatch.length >= minNumericBeforeByte2 && !alphaNumericRegex.test(str.charAt(numericMatch.length)))) {
    mode = NUMERIC;
    modeString = numericMatch;
  } else if (alphaNumericMatch && (str.length === alphaNumericMatch.length || alphaNumericMatch.length >= minAlphaBeforeByte2 || previousMode === ALPHA_NUMERIC)) {
    mode = ALPHA_NUMERIC;
    modeString = numericMatch || alphaMatch;
  } else {
    mode = BYTE;
    if (alphaNumericMatch) {
      modeString = alphaNumericMatch + byteRegex.exec(str.substring(alphaNumericMatch.length))[0];
    } else {
      modeString = byteRegex.exec(str)[0];
    }
  }
  return {
    mode,
    modeString
  };
}
function getModes(inputString) {
  var modes = [], previousMode, idx = 0;
  var str = inputString;
  modes.push(chooseMode(str, initMinNumericBeforeAlpha, initMinNumericBeforeByte, initMinAlphaBeforeByte, previousMode));
  previousMode = modes[0].mode;
  str = str.substr(modes[0].modeString.length);
  while (str.length > 0) {
    var nextMode = chooseMode(str, minNumericBeforeAlpha, minNumericBeforeByte, minAlphaBeforeByte, previousMode);
    if (nextMode.mode !== previousMode) {
      previousMode = nextMode.mode;
      modes.push(nextMode);
      idx++;
    } else {
      modes[idx].modeString += nextMode.modeString;
    }
    str = str.substr(nextMode.modeString.length);
  }
  return modes;
}
function getDataCodewordsCount(modes) {
  var length = 0, mode;
  for (var i16 = 0; i16 < modes.length; i16++) {
    mode = DataModeInstances[modes[i16].mode];
    length += mode.getStringBitsLength(modes[i16].modeString.length);
  }
  return Math.ceil(length / 8);
}
function getVersion(dataCodewordsCount, errorCorrectionLevel) {
  var x3 = 0, y4 = VersionsCodewordsInformation.length - 1, version2 = Math.floor(VersionsCodewordsInformation.length / 2);
  do {
    if (dataCodewordsCount < VersionsCodewordsInformation[version2][errorCorrectionLevel].totalDataCodewords) {
      y4 = version2;
    } else {
      x3 = version2;
    }
    version2 = x3 + Math.floor((y4 - x3) / 2);
  } while (y4 - x3 > 1);
  if (dataCodewordsCount <= VersionsCodewordsInformation[x3][errorCorrectionLevel].totalDataCodewords) {
    return version2 + 1;
  }
  return y4 + 1;
}
function getDataString(modes, version2) {
  var dataString = "", mode;
  for (var i16 = 0; i16 < modes.length; i16++) {
    mode = DataModeInstances[modes[i16].mode];
    dataString += mode.encode(modes[i16].modeString, version2);
  }
  return dataString;
}
function encodeFormatInformation(format2) {
  var formatNumber2 = toDecimal(format2), encodedString, result = "";
  if (formatNumber2 === 0) {
    return "101010000010010";
  }
  encodedString = encodeBCH(toDecimal(format2), formatGeneratorPolynomial, 15);
  for (var i16 = 0; i16 < encodedString.length; i16++) {
    result += encodedString.charAt(i16) ^ formatMaskPattern.charAt(i16);
  }
  return result;
}
function encodeBCH(value2, generatorPolynomial, codeLength) {
  var generatorNumber = toDecimal(generatorPolynomial), polynomialLength = generatorPolynomial.length - 1, valueNumber = value2 << polynomialLength, length = codeLength - polynomialLength, valueString = toBitsString(value2, length), result = dividePolynomials(valueNumber, generatorNumber);
  result = valueString + toBitsString(result, polynomialLength);
  return result;
}
function dividePolynomials(numberX, numberY) {
  var yLength = numberY.toString(2).length, xLength = numberX.toString(2).length;
  var x3 = numberX;
  do {
    x3 ^= numberY << xLength - yLength;
    xLength = x3.toString(2).length;
  } while (xLength >= yLength);
  return x3;
}
function getNumberAt(str, idx) {
  return parseInt(str.charAt(idx), 10);
}
function initMatrices(version2) {
  var matrices = [], modules = 17 + 4 * version2;
  for (var i16 = 0; i16 < maskPatternConditions.length; i16++) {
    matrices[i16] = new Array(modules);
    for (var j2 = 0; j2 < modules; j2++) {
      matrices[i16][j2] = new Array(modules);
    }
  }
  return matrices;
}
function addFormatInformation(matrices, formatString2) {
  var matrix = matrices[0], x3, y4, idx = 0, length = formatString2.length;
  for (x3 = 0, y4 = 8; x3 <= 8; x3++) {
    if (x3 !== 6) {
      fillFunctionCell(matrices, getNumberAt(formatString2, length - 1 - idx++), x3, y4);
    }
  }
  for (x3 = 8, y4 = 7; y4 >= 0; y4--) {
    if (y4 !== 6) {
      fillFunctionCell(matrices, getNumberAt(formatString2, length - 1 - idx++), x3, y4);
    }
  }
  idx = 0;
  for (y4 = matrix.length - 1, x3 = 8; y4 >= matrix.length - 8; y4--) {
    fillFunctionCell(matrices, getNumberAt(formatString2, length - 1 - idx++), x3, y4);
  }
  fillFunctionCell(matrices, 1, matrix.length - 8, 8);
  for (x3 = matrix.length - 7, y4 = 8; x3 < matrix.length; x3++) {
    fillFunctionCell(matrices, getNumberAt(formatString2, length - 1 - idx++), x3, y4);
  }
}
function encodeVersionInformation(version2) {
  return encodeBCH(version2, versionGeneratorPolynomial, 18);
}
function addVersionInformation(matrices, dataString) {
  var matrix = matrices[0], modules = matrix.length, x1 = 0, y1 = modules - 11, x22 = modules - 11, y22 = 0, quotient, mod, value2;
  for (var idx = 0; idx < dataString.length; idx++) {
    quotient = Math.floor(idx / 3);
    mod = idx % 3;
    value2 = getNumberAt(dataString, dataString.length - idx - 1);
    fillFunctionCell(matrices, value2, x1 + quotient, y1 + mod);
    fillFunctionCell(matrices, value2, x22 + mod, y22 + quotient);
  }
}
function addCentricPattern(matrices, pattern, x3, y4) {
  var size = pattern.length + 2, length = pattern.length + 1, value2;
  for (var i16 = 0; i16 < pattern.length; i16++) {
    for (var j2 = i16; j2 < size - i16; j2++) {
      value2 = pattern[i16];
      fillFunctionCell(matrices, value2, x3 + j2, y4 + i16);
      fillFunctionCell(matrices, value2, x3 + i16, y4 + j2);
      fillFunctionCell(matrices, value2, x3 + length - j2, y4 + length - i16);
      fillFunctionCell(matrices, value2, x3 + length - i16, y4 + length - j2);
    }
  }
}
function addFinderSeparator(matrices, direction, x3, y4) {
  var nextX = x3, nextY = y4, matrix = matrices[0];
  do {
    fillFunctionCell(matrices, 0, nextX, y4);
    fillFunctionCell(matrices, 0, x3, nextY);
    nextX += direction[0];
    nextY += direction[1];
  } while (nextX >= 0 && nextX < matrix.length);
}
function addFinderPatterns(matrices) {
  var modules = matrices[0].length;
  addCentricPattern(matrices, finderPattern, 0, 0);
  addFinderSeparator(matrices, [-1, -1], 7, 7);
  addCentricPattern(matrices, finderPattern, modules - 7, 0);
  addFinderSeparator(matrices, [1, -1], modules - 8, 7);
  addCentricPattern(matrices, finderPattern, 0, modules - 7);
  addFinderSeparator(matrices, [-1, 1], 7, modules - 8);
}
function addAlignmentPatterns(matrices, version2) {
  if (version2 < 2) {
    return;
  }
  var matrix = matrices[0], modules = matrix.length, pointsCount = Math.floor(version2 / 7), points2 = [6], startDistance, distance, idx = 0;
  if (startDistance = irregularAlignmentPatternsStartDistance[version2]) {
    distance = (modules - 13 - startDistance) / pointsCount;
  } else {
    startDistance = distance = (modules - 13) / (pointsCount + 1);
  }
  points2.push(points2[idx++] + startDistance);
  while (points2[idx] + distance < modules) {
    points2.push(points2[idx++] + distance);
  }
  for (var i16 = 0; i16 < points2.length; i16++) {
    for (var j2 = 0; j2 < points2.length; j2++) {
      if (matrix[points2[i16]][points2[j2]] === void 0) {
        addCentricPattern(matrices, alignmentPattern, points2[i16] - 2, points2[j2] - 2);
      }
    }
  }
}
function addTimingFunctions(matrices) {
  var row = 6, column = 6, value2 = 1, modules = matrices[0].length;
  for (var i16 = 8; i16 < modules - 8; i16++) {
    fillFunctionCell(matrices, value2, row, i16);
    fillFunctionCell(matrices, value2, i16, column);
    value2 ^= 1;
  }
}
function scoreMaskMatrixes(matrices) {
  var scores = [], previousBits = [], darkModules = [], patterns = [], adjacentSameBits = [], matrix, i16, row = 0, column = 1, modulesLength = matrices[0].length;
  for (i16 = 0; i16 < matrices.length; i16++) {
    scores[i16] = 0;
    darkModules[i16] = 0;
    adjacentSameBits[i16] = [0, 0];
    patterns[i16] = [0, 0];
    previousBits[i16] = [];
  }
  for (var rowIndex = 0; rowIndex < modulesLength; rowIndex++) {
    for (var columnIndex = 0; columnIndex < modulesLength; columnIndex++) {
      for (var matrixIndex = 0; matrixIndex < matrices.length; matrixIndex++) {
        matrix = matrices[matrixIndex];
        darkModules[matrixIndex] += parseInt(matrix[rowIndex][columnIndex], 10);
        if (previousBits[matrixIndex][row] === matrix[rowIndex][columnIndex] && rowIndex + 1 < modulesLength && columnIndex - 1 >= 0 && matrix[rowIndex + 1][columnIndex] === previousBits[matrixIndex][row] && matrix[rowIndex + 1][columnIndex - 1] === previousBits[matrixIndex][row]) {
          scores[matrixIndex] += 3;
        }
        scoreFinderPatternOccurance(matrixIndex, patterns, scores, row, matrix[rowIndex][columnIndex]);
        scoreFinderPatternOccurance(matrixIndex, patterns, scores, column, matrix[columnIndex][rowIndex]);
        scoreAdjacentSameBits(matrixIndex, scores, previousBits, matrix[rowIndex][columnIndex], adjacentSameBits, row);
        scoreAdjacentSameBits(matrixIndex, scores, previousBits, matrix[columnIndex][rowIndex], adjacentSameBits, column);
      }
    }
  }
  var total3 = modulesLength * modulesLength, minIdx, min2 = Number.MAX_VALUE;
  for (i16 = 0; i16 < scores.length; i16++) {
    scores[i16] += calculateDarkModulesRatioScore(darkModules[i16], total3);
    if (scores[i16] < min2) {
      min2 = scores[i16];
      minIdx = i16;
    }
  }
  return minIdx;
}
function scoreFinderPatternOccurance(idx, patterns, scores, rowColumn, bit) {
  patterns[idx][rowColumn] = (patterns[idx][rowColumn] << 1 ^ bit) % 128;
  if (patterns[idx][rowColumn] === finderPatternValue) {
    scores[idx] += 40;
  }
}
function scoreAdjacentSameBits(idx, scores, previousBits, bit, adjacentBits, rowColumn) {
  if (previousBits[idx][rowColumn] === bit) {
    adjacentBits[idx][rowColumn]++;
  } else {
    previousBits[idx][rowColumn] = bit;
    if (adjacentBits[idx][rowColumn] >= 5) {
      scores[idx] += 3 + adjacentBits[idx][rowColumn] - 5;
    }
    adjacentBits[idx][rowColumn] = 1;
  }
}
function calculateDarkModulesRatioScore(darkModules, total3) {
  var percent = Math.floor(darkModules / total3 * 100), mod5 = percent % 5, previous = Math.abs(percent - mod5 - 50), next = Math.abs(percent + 5 - mod5 - 50), score = 10 * Math.min(previous / 5, next / 5);
  return score;
}
function createQRCodeDataEncoder(encoding) {
  if (encoding && encoding.toLowerCase().indexOf("utf_8") >= 0) {
    return new Utf8Encoder();
  }
  return new IsoEncoder();
}
function encodeData(inputString, errorCorrectionLevel, encoding) {
  var encoder = createQRCodeDataEncoder(encoding), encodingResult = encoder.getEncodingResult(inputString, errorCorrectionLevel), version2 = encodingResult.version, versionInformation = VersionsCodewordsInformation[version2 - 1][errorCorrectionLevel], dataString = padDataString(encodingResult.dataString, versionInformation.totalDataCodewords), blocks = getBlocks(dataString, versionInformation), matrices = initMatrices(version2);
  addFinderPatterns(matrices);
  addAlignmentPatterns(matrices, version2);
  addTimingFunctions(matrices);
  if (version2 >= 7) {
    addVersionInformation(matrices, toBitsString(0, 18));
  }
  addFormatInformation(matrices, toBitsString(0, 15));
  fillData(matrices, blocks);
  var minIdx = scoreMaskMatrixes(matrices), optimalMatrix = matrices[minIdx];
  if (version2 >= 7) {
    addVersionInformation([optimalMatrix], encodeVersionInformation(version2));
  }
  var formatString2 = errorCorrectionPatterns[errorCorrectionLevel] + toBitsString(minIdx, 3);
  addFormatInformation([optimalMatrix], encodeFormatInformation(formatString2));
  return optimalMatrix;
}
var round = Math.round;
var crossPattern = [[0, 1], [1, 1], [1, 2], [2, 2], [2, 1], [3, 1], [3, 0], [2, 0], [2, -1], [1, -1], [1, 0]];
var squarePattern = [[0, 1], [1, 1], [1, 0]];
var QRCodeDefaults = {
  DEFAULT_SIZE: 200,
  QUIET_ZONE_LENGTH: 4,
  DEFAULT_ERROR_CORRECTION_LEVEL: "L",
  DEFAULT_BACKGROUND: "#fff",
  DEFAULT_DARK_MODULE_COLOR: "#000",
  MIN_BASE_UNIT_SIZE: 1,
  DEFAULT_LOGO_SIZE: 7
};
var QRCode = function(Class3) {
  function QRCode2(element, options2, errorHandler) {
    if (errorHandler === void 0)
      errorHandler = defaultErrorHandler;
    Class3.call(this);
    this.options = deepExtend({}, this.options, options2);
    this.element = element;
    this.wrapper = this.element;
    this.onError = errorHandler;
    this._initElement();
    this._initSurface();
    this.setOptions(options2);
  }
  if (Class3)
    QRCode2.__proto__ = Class3;
  QRCode2.prototype = Object.create(Class3 && Class3.prototype);
  QRCode2.prototype.constructor = QRCode2;
  QRCode2.prototype.destroy = function destroy2() {
    this._destroySurface();
  };
  QRCode2.prototype._initElement = function _initElement() {
    addClass2(this.element, "k-qrcode");
  };
  QRCode2.prototype._initSurface = function _initSurface() {
    var ref2 = this;
    var options2 = ref2.options;
    var surface = ref2.surface;
    if (!surface || surface.options.type !== options2.renderAs) {
      this._destroySurface();
      this._initSurfaceElement();
      this.surface = this._createSurface();
    }
  };
  QRCode2.prototype._createSurface = function _createSurface() {
    return Surface$2.create(this.surfaceElement, {
      type: this.options.renderAs
    });
  };
  QRCode2.prototype._destroySurface = function _destroySurface() {
    if (this.surface) {
      this.surface.destroy();
      this.surface = null;
      this._destroySurfaceElement();
    }
  };
  QRCode2.prototype._initSurfaceElement = function _initSurfaceElement() {
    if (!this.surfaceElement) {
      this.surfaceElement = document.createElement("div");
      this.surfaceElement.style.position = "relative";
      this.element.appendChild(this.surfaceElement);
    }
  };
  QRCode2.prototype._destroySurfaceElement = function _destroySurfaceElement() {
    if (this.surfaceElement && this.surfaceElement.parentNode) {
      this.surfaceElement.parentNode.removeChild(this.surfaceElement);
      this.surfaceElement = null;
    }
  };
  QRCode2.prototype.redraw = function redraw() {
    var size = this._getSize();
    this.surface.clear();
    this.surface.setSize({
      width: size,
      height: size
    });
    this.createVisual();
    this.surface.draw(this.visual);
  };
  QRCode2.prototype.getSize = function getSize() {
    var element = this.element;
    var elementWidth = element.clientWidth;
    var elementHeight = element.clientHeight;
    var size = { width: 0, height: 0 };
    if (elementWidth > 0) {
      size.width = elementWidth;
    }
    if (elementHeight) {
      size.height = elementHeight;
    }
    return size;
  };
  QRCode2.prototype._resize = function _resize() {
    this.redraw();
  };
  QRCode2.prototype.createVisual = function createVisual() {
    this.visual = this._render();
  };
  QRCode2.prototype.exportVisual = function exportVisual() {
    return this._render();
  };
  QRCode2.prototype._render = function _render() {
    var value2 = this._value, baseUnit, border = this.options.border || {}, padding = this.options.padding || 0, borderWidth = border.width || 0, quietZoneSize, matrix, size, dataSize, contentSize;
    border.width = borderWidth;
    var visual = new Group$9();
    try {
      if (value2) {
        matrix = encodeData(value2, this.options.errorCorrection, this.options.encoding);
        size = this._getSize();
        contentSize = size - 2 * (borderWidth + padding);
        baseUnit = this._calculateBaseUnit(contentSize, matrix.length);
        dataSize = matrix.length * baseUnit;
        quietZoneSize = borderWidth + padding + (contentSize - dataSize) / 2;
        visual.append(this._renderBackground(size, border));
        visual.append(this._renderMatrix(matrix, baseUnit, quietZoneSize));
        if (this._hasCustomLogo()) {
          visual.append(this._renderLogo(size, baseUnit));
        } else if (this._isSwiss()) {
          visual.append(this._renderSwissCode(size, baseUnit));
        }
      }
    } catch (error2) {
      this.onError(error2);
    }
    return visual;
  };
  QRCode2.prototype._renderLogo = function _renderLogo(qrSize, baseUnit) {
    var image;
    var imageRect;
    var center = round(qrSize / 2);
    var logoSize = this._getLogoSize(baseUnit * QRCodeDefaults.DEFAULT_LOGO_SIZE);
    var logoUrl = this.options.overlay.imageUrl;
    var position2 = {
      x: center - logoSize.width / 2,
      y: center - logoSize.height / 2
    };
    imageRect = new Rect$1(
      new Point$7(position2.x, position2.y),
      new Size$1(logoSize.width, logoSize.height)
    );
    image = new Image$3(logoUrl, imageRect);
    return image;
  };
  QRCode2.prototype._renderSwissCode = function _renderSwissCode(qrSize, baseUnit) {
    var logoSize = this._getLogoSize(baseUnit * QRCodeDefaults.DEFAULT_LOGO_SIZE);
    logoSize = Math.max(logoSize.width, logoSize.height);
    var crossSize = logoSize / 4;
    var crossOffset = crossSize / 2;
    var center = qrSize / 2;
    var start = {};
    var visual = new Group$9();
    start.x = start.y = Math.ceil(center - baseUnit - logoSize / 2);
    visual.append(this._renderShape(start, Math.ceil(logoSize + baseUnit * 2), squarePattern, "#fff"));
    start.x = start.y = center - logoSize / 2;
    visual.append(this._renderShape(start, logoSize, squarePattern, this.options.color));
    start.x = center + crossOffset - logoSize / 2;
    start.y = center + crossOffset + crossSize - logoSize / 2;
    visual.append(this._renderShape(start, crossSize, crossPattern, "#fff"));
    return visual;
  };
  QRCode2.prototype._renderShape = function _renderShape(start, step, pattern, color) {
    var path = new MultiPath({
      fill: {
        color
      },
      stroke: null
    });
    path.moveTo(start.x, start.y);
    for (var i16 = 0; i16 < pattern.length; i16++) {
      path.lineTo(start.x + step * pattern[i16][0], start.y + step * pattern[i16][1]);
    }
    path.close();
    return path;
  };
  QRCode2.prototype._getSize = function _getSize() {
    var size;
    if (this.options.size) {
      size = parseInt(this.options.size, 10);
    } else {
      var element = this.element;
      var elementSize2 = surfaceSize(element, this.options.renderAs);
      var min2 = Math.min(elementSize2.width, elementSize2.height);
      if (min2 > 0) {
        size = min2;
      } else {
        size = QRCodeDefaults.DEFAULT_SIZE;
      }
    }
    return size;
  };
  QRCode2.prototype._calculateBaseUnit = function _calculateBaseUnit(size, matrixSize) {
    var baseUnit = Math.floor(size / matrixSize);
    if (baseUnit < QRCodeDefaults.MIN_BASE_UNIT_SIZE) {
      var minSize = Math.ceil(matrixSize * QRCodeDefaults.MIN_BASE_UNIT_SIZE);
      this.onError(new Error(
        "Insufficient size for QR Code: the current size is " + size + "px and the minimum size is " + minSize + "px."
      ));
    } else if (baseUnit * matrixSize >= size && baseUnit - 1 >= QRCodeDefaults.MIN_BASE_UNIT_SIZE) {
      baseUnit--;
    }
    return baseUnit;
  };
  QRCode2.prototype._renderMatrix = function _renderMatrix(matrix, baseUnit, quietZoneSize) {
    var path = new MultiPath({
      fill: {
        color: this.options.color
      },
      stroke: null
    });
    for (var row = 0; row < matrix.length; row++) {
      var y4 = quietZoneSize + row * baseUnit;
      var column = 0;
      while (column < matrix.length) {
        while (matrix[row][column] === 0 && column < matrix.length) {
          column++;
        }
        if (column < matrix.length) {
          var x3 = column;
          while (matrix[row][column] === 1) {
            column++;
          }
          var x1 = round(quietZoneSize + x3 * baseUnit);
          var y1 = round(y4);
          var x22 = round(quietZoneSize + column * baseUnit);
          var y22 = round(y4 + baseUnit);
          path.moveTo(x1, y1).lineTo(x1, y22).lineTo(x22, y22).lineTo(x22, y1).close();
        }
      }
    }
    return path;
  };
  QRCode2.prototype._renderBackground = function _renderBackground(size, border) {
    var box = new Box(0, 0, size, size).unpad(border.width / 2);
    var background = Path$7.fromRect(box.toRect(), {
      fill: {
        color: this.options.background
      },
      stroke: {
        color: border.color,
        width: border.width
      }
    });
    return background;
  };
  QRCode2.prototype.setOptions = function setOptions(options2) {
    var newOptions = options2 || {};
    this.options = extend$4(this.options, newOptions);
    if (options2.value !== void 0) {
      this._value = String(this.options.value);
    }
    this._initSurface();
    this.redraw();
  };
  QRCode2.prototype.value = function value2(value$1) {
    if (value$1 === void 0) {
      return this._value;
    }
    this._value = String(value$1);
    this.redraw();
  };
  QRCode2.prototype._hasCustomLogo = function _hasCustomLogo() {
    return Boolean(this.options.overlay.imageUrl);
  };
  QRCode2.prototype._isSwiss = function _isSwiss() {
    return this.options.overlay.type === "swiss";
  };
  QRCode2.prototype._getLogoSize = function _getLogoSize(defautLogoSize) {
    var width = this.options.overlay.width;
    var height = this.options.overlay.height;
    if (!width && !height) {
      width = height = defautLogoSize;
    } else if (width && !height) {
      height = width;
    } else if (!width && height) {
      width = height;
    }
    return {
      width,
      height
    };
  };
  return QRCode2;
}(Class$1);
setDefaultOptions(QRCode, {
  name: "QRCode",
  renderAs: "svg",
  encoding: "ISO_8859_1",
  value: "",
  errorCorrection: QRCodeDefaults.DEFAULT_ERROR_CORRECTION_LEVEL,
  background: QRCodeDefaults.DEFAULT_BACKGROUND,
  color: QRCodeDefaults.DEFAULT_DARK_MODULE_COLOR,
  size: "",
  padding: 0,
  border: {
    color: "",
    width: 0
  },
  overlay: {
    type: "image",
    imageUrl: "",
    width: 0,
    height: 0
  }
});
var WGS84$1 = {
  a: 6378137,
  // Semi-major radius
  b: 6356752314245179e-9,
  // Semi-minor radius
  f: 0.0033528106647474805,
  // Flattening
  e: 0.08181919084262149
  // Eccentricity
};
var datums = {
  WGS84: WGS84$1
};
function toSquare(value2) {
  return value2 * value2;
}
var math$4 = Math, abs$1 = math$4.abs, atan$1 = math$4.atan, atan2 = math$4.atan2, cos = math$4.cos, sin$1 = math$4.sin, tan$1 = math$4.tan;
var Location = function(Class3) {
  function Location2(lat, lng) {
    Class3.call(this);
    this.initProperties();
    if (arguments.length === 1) {
      this.lat = lat[0];
      this.lng = lat[1];
    } else {
      this.lat = lat;
      this.lng = lng;
    }
  }
  if (Class3)
    Location2.__proto__ = Class3;
  Location2.prototype = Object.create(Class3 && Class3.prototype);
  Location2.prototype.constructor = Location2;
  Location2.prototype.initProperties = function initProperties() {
    deepExtend(this, {
      DISTANCE_ITERATIONS: 100,
      DISTANCE_CONVERGENCE: 1e-12,
      DISTANCE_PRECISION: 2,
      FORMAT: "{0:N6}{1:N6}"
    });
  };
  Location2.prototype.toArray = function toArray2() {
    return [
      this.lat,
      this.lng
    ];
  };
  Location2.prototype.equals = function equals(loc) {
    return loc && loc.lat === this.lat && loc.lng === this.lng;
  };
  Location2.prototype.clone = function clone3() {
    return new Location2(this.lat, this.lng);
  };
  Location2.prototype.round = function round$1$1(precision) {
    this.lng = round$1(this.lng, precision);
    this.lat = round$1(this.lat, precision);
    return this;
  };
  Location2.prototype.wrap = function wrap() {
    this.lng = this.lng % 180;
    this.lat = this.lat % 90;
    return this;
  };
  Location2.prototype.distanceTo = function distanceTo(dest, datum) {
    return this.greatCircleTo(dest, datum).distance;
  };
  Location2.prototype.destination = function destination(distance, initialBearing, initialDatum) {
    var bearing = rad(initialBearing);
    var datum = initialDatum || datums.WGS84;
    var fromLat = rad(this.lat);
    var fromLng = rad(this.lng);
    var dToR = distance / datum.a;
    var lat = math$4.asin(sin$1(fromLat) * cos(dToR) + cos(fromLat) * sin$1(dToR) * cos(bearing));
    var lng = fromLng + atan2(sin$1(bearing) * sin$1(dToR) * cos(fromLat), cos(dToR) - sin$1(fromLat) * sin$1(lat));
    return new Location2(deg(lat), deg(lng));
  };
  Location2.prototype.greatCircleTo = function greatCircleTo(initialDest, initialDatum) {
    var this$1$1 = this;
    var dest = Location2.create(dest);
    var datum = initialDatum || datums.WGS84;
    if (!dest || this.clone().round(8).equals(dest.clone().round(8))) {
      return {
        distance: 0,
        azimuthFrom: 0,
        azimuthTo: 0
      };
    }
    var a9 = datum.a;
    var b2 = datum.b;
    var f4 = datum.f;
    var L3 = rad(dest.lng - this.lng);
    var U1 = atan$1((1 - f4) * tan$1(rad(this.lat)));
    var sinU1 = sin$1(U1);
    var cosU1 = cos(U1);
    var U22 = atan$1((1 - f4) * tan$1(rad(dest.lat)));
    var sinU2 = sin$1(U22);
    var cosU2 = cos(U22);
    var lambda = L3;
    var prevLambda;
    var i16 = this.DISTANCE_ITERATIONS;
    var converged = false;
    var sinLambda;
    var cosLambda;
    var sino;
    var cosA2;
    var coso;
    var cos2om;
    var sigma;
    while (!converged && i16-- > 0) {
      sinLambda = sin$1(lambda);
      cosLambda = cos(lambda);
      sino = math$4.sqrt(toSquare(cosU2 * sinLambda) + toSquare(cosU1 * sinU2 - sinU1 * cosU2 * cosLambda));
      coso = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda;
      sigma = atan2(sino, coso);
      var sinA = cosU1 * cosU2 * sinLambda / sino;
      cosA2 = 1 - toSquare(sinA);
      cos2om = 0;
      if (cosA2 !== 0) {
        cos2om = coso - 2 * sinU1 * sinU2 / cosA2;
      }
      prevLambda = lambda;
      var C2 = f4 / 16 * cosA2 * (4 + f4 * (4 - 3 * cosA2));
      lambda = L3 + (1 - C2) * f4 * sinA * (sigma + C2 * sino * (cos2om + C2 * coso * (-1 + 2 * toSquare(cos2om))));
      converged = abs$1(lambda - prevLambda) <= this$1$1.DISTANCE_CONVERGENCE;
    }
    var u22 = cosA2 * (toSquare(a9) - toSquare(b2)) / toSquare(b2);
    var A2 = 1 + u22 / 16384 * (4096 + u22 * (-768 + u22 * (320 - 175 * u22)));
    var B2 = u22 / 1024 * (256 + u22 * (-128 + u22 * (74 - 47 * u22)));
    var deltao = B2 * sino * (cos2om + B2 / 4 * (coso * (-1 + 2 * toSquare(cos2om)) - B2 / 6 * cos2om * (-3 + 4 * toSquare(sino)) * (-3 + 4 * toSquare(cos2om))));
    var azimuthFrom = atan2(cosU2 * sinLambda, cosU1 * sinU2 - sinU1 * cosU2 * cosLambda);
    var azimuthTo = atan2(cosU1 * sinLambda, -sinU1 * cosU2 + cosU1 * sinU2 * cosLambda);
    return {
      distance: round$1(b2 * A2 * (sigma - deltao), this.DISTANCE_PRECISION),
      azimuthFrom: deg(azimuthFrom),
      azimuthTo: deg(azimuthTo)
    };
  };
  Location2.prototype.toString = function toString2() {
    return String(this.lat) + "," + String(this.lng);
  };
  Location2.fromLngLat = function fromLngLat(lngAndLat) {
    return new Location2(lngAndLat[1], lngAndLat[0]);
  };
  Location2.fromLatLng = function fromLatLng(lngAndLat) {
    return new Location2(lngAndLat[0], lngAndLat[1]);
  };
  Location2.create = function create2(a9, b2) {
    if (defined(a9)) {
      if (a9 instanceof Location2) {
        return a9.clone();
      } else if (arguments.length === 1 && a9.length === 2) {
        return Location2.fromLatLng(a9);
      }
      return new Location2(a9, b2);
    }
  };
  return Location2;
}(Class$1);
var math$3 = Math, atan = math$3.atan, exp = math$3.exp, pow$1 = math$3.pow, sin = math$3.sin, log = math$3.log, tan = math$3.tan, Point$2 = Point$7;
var PI = math$3.PI, PI_DIV_2 = PI / 2, PI_DIV_4 = PI / 4, DEG_TO_RAD = PI / 180;
var WGS84 = datums.WGS84;
var Mercator = function(Class3) {
  function Mercator2(options2) {
    Class3.call(this);
    this.initProperties();
    this._initOptions(options2);
  }
  if (Class3)
    Mercator2.__proto__ = Class3;
  Mercator2.prototype = Object.create(Class3 && Class3.prototype);
  Mercator2.prototype.constructor = Mercator2;
  Mercator2.prototype._initOptions = function _initOptions(options2) {
    this.options = deepExtend({}, this.options, options2);
  };
  Mercator2.prototype.initProperties = function initProperties() {
    deepExtend(this, {
      MAX_LNG: 180,
      MAX_LAT: 85.0840590501,
      INVERSE_ITERATIONS: 15,
      INVERSE_CONVERGENCE: 1e-12
    });
  };
  Mercator2.prototype.forward = function forward(loc, clamp2) {
    var proj = this, options2 = proj.options, datum = options2.datum, r12 = datum.a, lng0 = options2.centralMeridian, lat = limitValue(loc.lat, -proj.MAX_LAT, proj.MAX_LAT), lng = clamp2 ? limitValue(loc.lng, -proj.MAX_LNG, proj.MAX_LNG) : loc.lng, x3 = rad(lng - lng0) * r12, y4 = proj._projectLat(lat);
    return new Point$2(x3, y4);
  };
  Mercator2.prototype._projectLat = function _projectLat(lat) {
    var datum = this.options.datum, ecc = datum.e, r12 = datum.a, y4 = rad(lat), ts = tan(PI_DIV_4 + y4 / 2), con = ecc * sin(y4), p6 = pow$1((1 - con) / (1 + con), ecc / 2);
    return r12 * log(ts * p6);
  };
  Mercator2.prototype.inverse = function inverse2(point2, clamp2) {
    var proj = this, options2 = proj.options, datum = options2.datum, r12 = datum.a, lng0 = options2.centralMeridian, lng = point2.x / (DEG_TO_RAD * r12) + lng0, lat = limitValue(proj._inverseY(point2.y), -proj.MAX_LAT, proj.MAX_LAT);
    if (clamp2) {
      lng = limitValue(lng, -proj.MAX_LNG, proj.MAX_LNG);
    }
    return new Location(lat, lng);
  };
  Mercator2.prototype._inverseY = function _inverseY(y4) {
    var proj = this, datum = proj.options.datum, r12 = datum.a, ecc = datum.e, ecch = ecc / 2, ts = exp(-y4 / r12), phi = PI_DIV_2 - 2 * atan(ts), i16;
    for (i16 = 0; i16 <= proj.INVERSE_ITERATIONS; i16++) {
      var con = ecc * sin(phi), p6 = pow$1((1 - con) / (1 + con), ecch), dphi = PI_DIV_2 - 2 * atan(ts * p6) - phi;
      phi += dphi;
      if (math$3.abs(dphi) <= proj.INVERSE_CONVERGENCE) {
        break;
      }
    }
    return deg(phi);
  };
  return Mercator2;
}(Class$1);
setDefaultOptions(Mercator, {
  centralMeridian: 0,
  datum: WGS84
});
var SphericalMercator = function(Mercator2) {
  function SphericalMercator2() {
    Mercator2.apply(this, arguments);
  }
  if (Mercator2)
    SphericalMercator2.__proto__ = Mercator2;
  SphericalMercator2.prototype = Object.create(Mercator2 && Mercator2.prototype);
  SphericalMercator2.prototype.constructor = SphericalMercator2;
  SphericalMercator2.prototype.initProperties = function initProperties() {
    Mercator2.prototype.initProperties.call(this);
    deepExtend(this, {
      MAX_LAT: 85.0511287798
    });
  };
  SphericalMercator2.prototype._projectLat = function _projectLat(lat) {
    var r12 = this.options.datum.a, y4 = rad(lat), ts = tan(PI_DIV_4 + y4 / 2);
    return r12 * log(ts);
  };
  SphericalMercator2.prototype._inverseY = function _inverseY(y4) {
    var r12 = this.options.datum.a, ts = exp(-y4 / r12);
    return deg(PI_DIV_2 - 2 * atan(ts));
  };
  return SphericalMercator2;
}(Mercator);
var Equirectangular = function(Class3) {
  function Equirectangular2() {
    Class3.apply(this, arguments);
  }
  if (Class3)
    Equirectangular2.__proto__ = Class3;
  Equirectangular2.prototype = Object.create(Class3 && Class3.prototype);
  Equirectangular2.prototype.constructor = Equirectangular2;
  Equirectangular2.prototype.forward = function forward(loc) {
    return new Point$2(loc.lng, loc.lat);
  };
  Equirectangular2.prototype.inverse = function inverse2(point2) {
    return new Location(point2.y, point2.x);
  };
  return Equirectangular2;
}(Class$1);
var EPSG3857 = function(Class3) {
  function EPSG38572() {
    Class3.call(this);
    var crs = this, proj = crs._proj = new SphericalMercator();
    var c6 = this.c = 2 * PI * proj.options.datum.a;
    this._tm = transform().translate(0.5, 0.5).scale(1 / c6, -1 / c6);
    this._itm = transform().scale(c6, -c6).translate(-0.5, -0.5);
  }
  if (Class3)
    EPSG38572.__proto__ = Class3;
  EPSG38572.prototype = Object.create(Class3 && Class3.prototype);
  EPSG38572.prototype.constructor = EPSG38572;
  EPSG38572.prototype.toPoint = function toPoint(loc, scale, clamp2) {
    var point2 = this._proj.forward(loc, clamp2);
    return point2.transform(this._tm).scale(scale || 1);
  };
  EPSG38572.prototype.toLocation = function toLocation(point2, scale, clamp2) {
    var newPoint = point2.clone().scale(1 / (scale || 1)).transform(this._itm);
    return this._proj.inverse(newPoint, clamp2);
  };
  return EPSG38572;
}(Class$1);
(function(Class3) {
  function EPSG3395() {
    Class3.call(this);
    this._proj = new Mercator();
  }
  if (Class3)
    EPSG3395.__proto__ = Class3;
  EPSG3395.prototype = Object.create(Class3 && Class3.prototype);
  EPSG3395.prototype.constructor = EPSG3395;
  EPSG3395.prototype.toPoint = function toPoint(loc) {
    return this._proj.forward(loc);
  };
  EPSG3395.prototype.toLocation = function toLocation(point2) {
    return this._proj.inverse(point2);
  };
  return EPSG3395;
})(Class$1);
(function(Class3) {
  function EPSG4326() {
    Class3.call(this);
    this._proj = new Equirectangular();
  }
  if (Class3)
    EPSG4326.__proto__ = Class3;
  EPSG4326.prototype = Object.create(Class3 && Class3.prototype);
  EPSG4326.prototype.constructor = EPSG4326;
  EPSG4326.prototype.toPoint = function toPoint(loc) {
    return this._proj.forward(loc);
  };
  EPSG4326.prototype.toLocation = function toLocation(point2) {
    return this._proj.inverse(point2);
  };
  return EPSG4326;
})(Class$1);
var proxy = function(method, context2) {
  return method.bind(context2);
};
var convertToHtml = function(html2) {
  var div = document.createElement("div");
  div.innerHTML = html2;
  return div.firstChild;
};
var appendHtml = function(html2, element) {
  var div = document.createElement("div");
  div.innerHTML = html2;
  while (div.childNodes.length > 0) {
    element.appendChild(div.childNodes[0]);
  }
};
var removeChildren = function(element) {
  while (element.firstChild) {
    element.removeChild(element.firstChild);
  }
};
var prepend = function(element, originElement) {
  originElement.insertBefore(element, originElement.firstChild);
};
var wrapInner = function(parent, wrapper2) {
  parent.appendChild(wrapper2);
  while (parent.firstChild !== wrapper2) {
    wrapper2.appendChild(parent.firstChild);
  }
};
var toHyphens = function(str) {
  var result = str.replace(/([a-z][A-Z])/g, function(g6) {
    return g6.charAt(0) + "-" + g6.charAt(1).toLowerCase();
  });
  return result;
};
var toPixels = function(value2) {
  var result;
  if (value2 && String(value2).endsWith("px")) {
    result = value2;
  } else {
    result = String(value2) + "px";
  }
  return result;
};
var hasNativeScrolling = function(userAgent2) {
  var ref2 = getSupportedFeatures();
  var mobileOS = ref2.mobileOS;
  return mobileOS.ios || mobileOS.android;
};
var setDefaultEvents = function(type, events2) {
  var proto = type.prototype;
  if (proto.events) {
    events2.forEach(function(event) {
      if (proto.events.indexOf(event) < 0) {
        proto.events.push(event);
      }
    });
  } else {
    proto.events = events2;
  }
};
var wheelDeltaY = function(e3) {
  var deltaY = e3.wheelDeltaY;
  var delta;
  if (e3.wheelDelta) {
    if (deltaY === void 0 || deltaY) {
      delta = e3.wheelDelta;
    }
  } else if (e3.detail && e3.axis === e3.VERTICAL_AXIS) {
    delta = -e3.detail * 10;
  }
  return delta;
};
var renderPos = function(pos) {
  var result = [];
  if (pos) {
    var parts = toHyphens(pos).split("-");
    for (var i16 = 0; i16 < parts.length; i16++) {
      result.push("k-pos-" + parts[i16]);
    }
  }
  return result.join(" ");
};
var Attribution = function(Observable2) {
  function Attribution2(element, options2) {
    Observable2.call(this);
    this.element = element;
    this._initOptions(options2);
    this.items = [];
    addClass2(this.element, "k-widget k-attribution");
  }
  if (Observable2)
    Attribution2.__proto__ = Observable2;
  Attribution2.prototype = Object.create(Observable2 && Observable2.prototype);
  Attribution2.prototype.constructor = Attribution2;
  Attribution2.prototype._initOptions = function _initOptions(options2) {
    this.options = deepExtend({}, this.options, options2);
  };
  Attribution2.prototype.filter = function filter(extent, zoom) {
    this._extent = extent;
    this._zoom = zoom;
    this._render();
  };
  Attribution2.prototype.add = function add3(item) {
    var newItem = item;
    if (defined(item)) {
      if (typeof item === "string") {
        newItem = {
          text: item
        };
      }
      this.items.push(newItem);
      this._render();
    }
  };
  Attribution2.prototype.remove = function remove(text) {
    var this$1$1 = this;
    var result = [];
    for (var i16 = 0; i16 < this.items.length; i16++) {
      var item = this$1$1.items[i16];
      if (item.text !== text) {
        result.push(item);
      }
    }
    this.items = result;
    this._render();
  };
  Attribution2.prototype.clear = function clear4() {
    this.items = [];
    removeChildren(this.element);
  };
  Attribution2.prototype._render = function _render() {
    var this$1$1 = this;
    var result = [];
    for (var i16 = 0; i16 < this.items.length; i16++) {
      var item = this$1$1.items[i16];
      var text = this$1$1._itemText(item);
      if (text !== "") {
        result.push(text);
      }
    }
    if (result.length > 0) {
      removeChildren(this.element);
      var html2 = result.join(this.options.separator);
      appendHtml(html2, this.element);
      this.showElement();
    } else {
      this.hideElement();
    }
  };
  Attribution2.prototype.hideElement = function hideElement() {
    this.element.style.display = "none";
  };
  Attribution2.prototype.showElement = function showElement() {
    this.element.style.display = "";
  };
  Attribution2.prototype._itemText = function _itemText(item) {
    var text = "";
    var inZoomLevel = this._inZoomLevel(item.minZoom, item.maxZoom);
    var inArea = this._inArea(item.extent);
    if (inZoomLevel && inArea) {
      text += item.text;
    }
    return text;
  };
  Attribution2.prototype._inZoomLevel = function _inZoomLevel(min2, max2) {
    var result = true;
    var newMin = valueOrDefault$1(min2, -Number.MAX_VALUE);
    var newMax = valueOrDefault$1(max2, Number.MAX_VALUE);
    result = this._zoom > newMin && this._zoom < newMax;
    return result;
  };
  Attribution2.prototype._inArea = function _inArea(area) {
    var result = true;
    if (area) {
      result = area.contains(this._extent);
    }
    return result;
  };
  return Attribution2;
}(Observable);
setDefaultOptions(Attribution, {
  name: "Attribution",
  separator: "&nbsp;|&nbsp;"
});
var PAN = "pan";
var directionsMap = {
  up: {
    className: "k-navigator-n",
    iconClass: "k-i-caret-alt-up"
  },
  down: {
    className: "k-navigator-s",
    iconClass: "k-i-caret-alt-down"
  },
  right: {
    className: "k-navigator-e",
    iconClass: "k-i-caret-alt-right"
  },
  left: {
    className: "k-navigator-w",
    iconClass: "k-i-caret-alt-left"
  }
};
function createButton$1(direction, iconOptions) {
  var html2 = '<button class="k-button k-button-square k-rounded-full k-button-flat k-button-flat-base k-icon-button ' + directionsMap[direction].className + '" aria-label="move ' + direction + '">' + renderIcon({ icon: "caret-alt-" + direction, iconClass: "k-button-icon", svgIcons: iconOptions.svgIcons, type: iconOptions.type }) + "</button>";
  return convertToHtml(html2);
}
var Navigator = function(Observable2) {
  function Navigator2(element, options2) {
    Observable2.call(this);
    this.element = element;
    this._initOptions(options2);
    var navigateUpButton = createButton$1("up", options2.icons);
    var navigateRightlButton = createButton$1("right", options2.icons);
    var navigateDownButton = createButton$1("down", options2.icons);
    var navigateLeftButton = createButton$1("left", options2.icons);
    this.element.appendChild(navigateUpButton);
    this.element.appendChild(navigateRightlButton);
    this.element.appendChild(navigateDownButton);
    this.element.appendChild(navigateLeftButton);
    addClass2(this.element, "k-widget k-navigator");
    on(this.element, "click", ".k-button", proxy(this._click, this));
    var parentElement = this.element.parentNode.closest("[data-role]");
    this._keyroot = parentElement ? parentElement : this.element;
    this._tabindex(this._keyroot);
    this._keydownHandler = proxy(this._keydown, this);
    on(this._keyroot, "keydown", this._keydownHandler);
  }
  if (Observable2)
    Navigator2.__proto__ = Observable2;
  Navigator2.prototype = Object.create(Observable2 && Observable2.prototype);
  Navigator2.prototype.constructor = Navigator2;
  Navigator2.prototype.destroy = function destroy2() {
    this.dispose();
  };
  Navigator2.prototype.dispose = function dispose() {
    off(this._keyroot, "keydown", this._keydownHandler);
  };
  Navigator2.prototype._tabindex = function _tabindex(target) {
    var targetElement = target || this.wrapper || this.element;
    var element = this.element, TABINDEX = "tabindex", tabindex = targetElement.getAttribute(TABINDEX) || element.getAttribute(TABINDEX);
    element.removeAttribute(TABINDEX);
    targetElement.setAttribute(TABINDEX, !isNaN(tabindex) ? tabindex : 0);
  };
  Navigator2.prototype._initOptions = function _initOptions(options2) {
    this.options = deepExtend({}, this.options, options2);
  };
  Navigator2.prototype._pan = function _pan(x3, y4) {
    var panStep = this.options.panStep;
    this.trigger(PAN, {
      x: x3 * panStep,
      y: y4 * panStep
    });
  };
  Navigator2.prototype._click = function _click(e3) {
    var x3 = 0;
    var y4 = 0;
    var button = e3.currentTarget;
    if (button.matches(".k-navigator-n")) {
      y4 = 1;
    } else if (button.matches(".k-navigator-s")) {
      y4 = -1;
    } else if (button.matches(".k-navigator-e")) {
      x3 = 1;
    } else if (button.matches(".k-navigator-w")) {
      x3 = -1;
    }
    this._pan(x3, y4);
    e3.preventDefault();
  };
  Navigator2.prototype._keydown = function _keydown(e3) {
    switch (e3.which) {
      case keys.UP:
        this._pan(0, 1);
        e3.preventDefault();
        break;
      case keys.DOWN:
        this._pan(0, -1);
        e3.preventDefault();
        break;
      case keys.RIGHT:
        this._pan(1, 0);
        e3.preventDefault();
        break;
      case keys.LEFT:
        this._pan(-1, 0);
        e3.preventDefault();
        break;
    }
  };
  return Navigator2;
}(Observable);
setDefaultOptions(Navigator, {
  name: "Navigator",
  panStep: 1
});
setDefaultEvents(Navigator, [
  PAN
]);
function createButton(direction, icon, iconOptions) {
  var html2 = '<button class="k-button k-button-md k-rounded-md k-button-solid k-button-solid-base k-icon-button k-zoom-' + direction + '" title="zoom-' + direction + '" aria-label="zoom-' + direction + '">' + renderIcon({ icon, iconClass: "k-button-icon", svgIcons: iconOptions.svgIcons, type: iconOptions.type }) + "</button>";
  return convertToHtml(html2);
}
var PLUS = 187;
var MINUS = 189;
var FF_PLUS = 61;
var FF_MINUS = 173;
var CHANGE$2 = "change";
var ZoomControl = function(Observable2) {
  function ZoomControl2(element, options2, iconOptions) {
    Observable2.call(this);
    this.element = element;
    this._initOptions(options2);
    var zoomInButton = createButton("in", "plus", iconOptions);
    var zoomOutButton = createButton("out", "minus", iconOptions);
    this.element.appendChild(zoomInButton);
    this.element.appendChild(zoomOutButton);
    this.element.setAttribute("role", "group");
    addClass2(this.element, "k-widget k-zoom-control k-button-group k-group-horizontal");
    this._clickHandler = this._click.bind(this);
    on(this.element, "click", ".k-button", this._clickHandler);
    var parentElement = this.element.parentNode.closest("[data-role]");
    this._keyroot = parentElement ? parentElement : this.element;
    this._tabindex(this._keyroot);
    this._keydownHandler = this._keydown.bind(this);
    on(this._keyroot, "keydown", this._keydownHandler);
  }
  if (Observable2)
    ZoomControl2.__proto__ = Observable2;
  ZoomControl2.prototype = Object.create(Observable2 && Observable2.prototype);
  ZoomControl2.prototype.constructor = ZoomControl2;
  ZoomControl2.prototype.destroy = function destroy2() {
    if (this.element) {
      off(this.element, "click", this._clickHandler);
    }
    if (this._keyroot) {
      off(this._keyroot, "keydown", this._keydownHandler);
    }
  };
  ZoomControl2.prototype._tabindex = function _tabindex(target) {
    var targetElement = target || this.wrapper || this.element;
    var element = this.element, TABINDEX = "tabindex", tabindex = targetElement.getAttribute(TABINDEX) || element.getAttribute(TABINDEX);
    element.removeAttribute(TABINDEX);
    targetElement.setAttribute(TABINDEX, !isNaN(tabindex) ? tabindex : 0);
  };
  ZoomControl2.prototype._initOptions = function _initOptions(options2) {
    this.options = deepExtend({}, this.options, options2);
  };
  ZoomControl2.prototype._change = function _change(direction) {
    var zoomStep = this.options.zoomStep;
    this.trigger(CHANGE$2, { delta: direction * zoomStep });
  };
  ZoomControl2.prototype._click = function _click(e3) {
    var button = e3.currentTarget;
    var direction = 1;
    if (hasClasses(button, "k-zoom-out")) {
      direction = -1;
    }
    this._change(direction);
    e3.preventDefault();
  };
  ZoomControl2.prototype._keydown = function _keydown(e3) {
    switch (e3.which) {
      case keys.NUMPAD_PLUS:
      case PLUS:
      case FF_PLUS:
        this._change(1);
        break;
      case keys.NUMPAD_MINUS:
      case MINUS:
      case FF_MINUS:
        this._change(-1);
        break;
    }
  };
  return ZoomControl2;
}(Observable);
setDefaultOptions(ZoomControl, {
  name: "ZoomControl",
  zoomStep: 1
});
setDefaultEvents(ZoomControl, [
  CHANGE$2
]);
var math$2 = Math, max$1 = math$2.max, min$2 = math$2.min;
var Extent = function(Class3) {
  function Extent2(initialNw, initialSe) {
    Class3.call(this);
    var nw = Location.create(initialNw);
    var se2 = Location.create(initialSe);
    if (nw.lng + 180 > se2.lng + 180 && nw.lat + 90 < se2.lat + 90) {
      this.se = nw;
      this.nw = se2;
    } else {
      this.se = se2;
      this.nw = nw;
    }
  }
  if (Class3)
    Extent2.__proto__ = Class3;
  Extent2.prototype = Object.create(Class3 && Class3.prototype);
  Extent2.prototype.constructor = Extent2;
  var staticAccessors2 = { World: { configurable: true } };
  Extent2.prototype.contains = function contains(loc) {
    var nw = this.nw, se2 = this.se, lng = valueOrDefault$1(loc.lng, loc[1]), lat = valueOrDefault$1(loc.lat, loc[0]);
    return loc && lng + 180 >= nw.lng + 180 && lng + 180 <= se2.lng + 180 && lat + 90 >= se2.lat + 90 && lat + 90 <= nw.lat + 90;
  };
  Extent2.prototype.center = function center() {
    var nw = this.nw;
    var se2 = this.se;
    var lng = nw.lng + (se2.lng - nw.lng) / 2;
    var lat = nw.lat + (se2.lat - nw.lat) / 2;
    return new Location(lat, lng);
  };
  Extent2.prototype.containsAny = function containsAny(locs) {
    var this$1$1 = this;
    var result = false;
    for (var i16 = 0; i16 < locs.length; i16++) {
      result = result || this$1$1.contains(locs[i16]);
    }
    return result;
  };
  Extent2.prototype.include = function include(loc) {
    var nw = this.nw, se2 = this.se, lng = valueOrDefault$1(loc.lng, loc[1]), lat = valueOrDefault$1(loc.lat, loc[0]);
    nw.lng = min$2(nw.lng, lng);
    nw.lat = max$1(nw.lat, lat);
    se2.lng = max$1(se2.lng, lng);
    se2.lat = min$2(se2.lat, lat);
  };
  Extent2.prototype.includeAll = function includeAll(locs) {
    var this$1$1 = this;
    for (var i16 = 0; i16 < locs.length; i16++) {
      this$1$1.include(locs[i16]);
    }
  };
  Extent2.prototype.edges = function edges() {
    var nw = this.nw, se2 = this.se;
    return {
      nw: this.nw,
      ne: new Location(nw.lat, se2.lng),
      se: this.se,
      sw: new Location(se2.lat, nw.lng)
    };
  };
  Extent2.prototype.toArray = function toArray2() {
    var nw = this.nw, se2 = this.se;
    return [
      nw,
      new Location(nw.lat, se2.lng),
      se2,
      new Location(se2.lat, nw.lng)
    ];
  };
  Extent2.prototype.overlaps = function overlaps(extent) {
    return this.containsAny(extent.toArray()) || extent.containsAny(this.toArray());
  };
  Extent2.create = function create2(a9, b2) {
    if (a9 instanceof Extent2) {
      return a9;
    } else if (a9 && b2) {
      return new Extent2(a9, b2);
    } else if (a9 && a9.length === 4 && !b2) {
      return new Extent2([
        a9[0],
        a9[1]
      ], [
        a9[2],
        a9[3]
      ]);
    }
  };
  staticAccessors2.World.get = function() {
    return new Extent2([90, -180], [-90, 180]);
  };
  Object.defineProperties(Extent2, staticAccessors2);
  return Extent2;
}(Class$1);
var SHOW_TOOLTIP = "showTooltip";
var HIDE_TOOLTIP = "hideTooltip";
var CENTER_CHANGE = "centerChange";
var ZOOM_CHANGE = "zoomChange";
var INIT = "init";
var Tooltip = function(Class3) {
  function Tooltip2(widgetService, options2) {
    Class3.call(this);
    this.widgetService = widgetService;
    this.options = deepExtend({}, this.options, options2);
    this.offset = { x: 0, y: 0 };
  }
  if (Class3)
    Tooltip2.__proto__ = Class3;
  Tooltip2.prototype = Object.create(Class3 && Class3.prototype);
  Tooltip2.prototype.constructor = Tooltip2;
  var prototypeAccessors2 = { anchor: { configurable: true } };
  Tooltip2.prototype.show = function show2(anchor, args) {
    if (this.location === args.location) {
      return;
    }
    this.anchor = anchor;
    this.location = args.location;
    this.widgetService.notify(
      SHOW_TOOLTIP,
      Object.assign({ anchor: this.anchor }, args)
    );
    this.visible = true;
  };
  Tooltip2.prototype.hide = function hide2() {
    if (this.widgetService) {
      this.widgetService.notify(HIDE_TOOLTIP);
    }
    this.visible = false;
    this.location = null;
  };
  prototypeAccessors2.anchor.get = function() {
    return this._anchor;
  };
  prototypeAccessors2.anchor.set = function(anchor) {
    var documentPoint = this.widgetService.widget._toDocumentCoordinates({
      x: anchor.left - this.offset.x,
      y: anchor.top - this.offset.y
    });
    this._anchor = {
      left: documentPoint.left,
      top: documentPoint.top
    };
  };
  Tooltip2.prototype.destroy = function destroy2() {
    this.widgetService = null;
  };
  Object.defineProperties(Tooltip2.prototype, prototypeAccessors2);
  return Tooltip2;
}(Class$1);
setDefaultOptions(Tooltip, {
  border: {
    width: 1
  },
  opacity: 1
});
var Layer = function(Class3) {
  function Layer2(map3, options2) {
    Class3.call(this);
    this.support = getSupportedFeatures();
    this._initOptions(options2);
    this.map = map3;
    var element = document.createElement("div");
    addClass2(element, "k-layer");
    element.style.zIndex = this.options.zIndex;
    element.style.opacity = this.options.opacity;
    this.element = element;
    map3.scrollElement.appendChild(this.element);
    this._beforeReset = this._beforeReset.bind(this);
    this._reset = this._reset.bind(this);
    this._resize = this._resize.bind(this);
    this._panEnd = this._panEnd.bind(this);
    this._activate();
    this._updateAttribution();
  }
  if (Class3)
    Layer2.__proto__ = Class3;
  Layer2.prototype = Object.create(Class3 && Class3.prototype);
  Layer2.prototype.constructor = Layer2;
  Layer2.prototype.destroy = function destroy2() {
    this._deactivate();
  };
  Layer2.prototype._initOptions = function _initOptions(options2) {
    this.options = deepExtend({}, this.options, options2);
  };
  Layer2.prototype.show = function show2() {
    this.reset();
    this._activate();
    this._applyExtent(true);
  };
  Layer2.prototype.hide = function hide2() {
    this._deactivate();
    this._setVisibility(false);
  };
  Layer2.prototype.reset = function reset() {
    this._beforeReset();
    this._reset();
  };
  Layer2.prototype._reset = function _reset() {
    this._applyExtent();
  };
  Layer2.prototype._beforeReset = function _beforeReset() {
  };
  Layer2.prototype._resize = function _resize() {
  };
  Layer2.prototype._panEnd = function _panEnd() {
    this._applyExtent();
  };
  Layer2.prototype._applyExtent = function _applyExtent() {
    var options2 = this.options;
    var zoom = this.map.zoom();
    var matchMinZoom = !defined(options2.minZoom) || zoom >= options2.minZoom;
    var matchMaxZoom = !defined(options2.maxZoom) || zoom <= options2.maxZoom;
    var extent = Extent.create(options2.extent);
    var inside = !extent || extent.overlaps(this.map.extent());
    this._setVisibility(matchMinZoom && matchMaxZoom && inside);
  };
  Layer2.prototype._setVisibility = function _setVisibility(visible) {
    this.element.style.display = visible ? "" : "none";
  };
  Layer2.prototype._activate = function _activate() {
    var map3 = this.map;
    this._deactivate();
    map3.bind("beforeReset", this._beforeReset);
    map3.bind("reset", this._reset);
    map3.bind("resize", this._resize);
    map3.bind("panEnd", this._panEnd);
  };
  Layer2.prototype._deactivate = function _deactivate() {
    var map3 = this.map;
    map3.unbind("beforeReset", this._beforeReset);
    map3.unbind("reset", this._reset);
    map3.unbind("resize", this._resize);
    map3.unbind("panEnd", this._panEnd);
  };
  Layer2.prototype._updateAttribution = function _updateAttribution() {
    var attribution = this.map.attribution;
    if (attribution) {
      attribution.add(this.options.attribution);
    }
  };
  Layer2.prototype._readData = function _readData() {
    var data2 = this.options.data || [];
    return data2;
  };
  Layer2.prototype._hasData = function _hasData() {
    return this._data && this._data.length > 0;
  };
  Layer2.prototype._layerIndex = function _layerIndex() {
    var layers = this.map.layers || [];
    return layers.indexOf(this);
  };
  return Layer2;
}(Class$1);
var math$1 = Math, Point$1 = Point$7;
function compileTemplate(template) {
  if (isFunction$1(template)) {
    return template;
  }
  return TemplateService.compile(template);
}
function roundPoint(point2) {
  return new Point$1(round$1(point2.x), round$1(point2.y));
}
function renderSize(size) {
  var newSize = size;
  if (typeof size !== "string") {
    newSize += "px";
  }
  return newSize;
}
var TileLayer = function(Layer2) {
  function TileLayer2(map3, options2) {
    Layer2.call(this, map3, options2);
    if (typeof this.options.subdomains === "string") {
      this.options.subdomains = this.options.subdomains.split("");
    }
    var viewType = this._viewType();
    this._view = new viewType(this.element, this.options);
  }
  if (Layer2)
    TileLayer2.__proto__ = Layer2;
  TileLayer2.prototype = Object.create(Layer2 && Layer2.prototype);
  TileLayer2.prototype.constructor = TileLayer2;
  TileLayer2.prototype.destroy = function destroy2() {
    Layer2.prototype.destroy.call(this);
    this._view.destroy();
    this._view = null;
  };
  TileLayer2.prototype._beforeReset = function _beforeReset() {
    var map3 = this.map;
    var origin = map3.locationToLayer(map3.extent().nw).round();
    this._view.viewOrigin(origin);
  };
  TileLayer2.prototype._reset = function _reset() {
    Layer2.prototype._reset.call(this);
    this._updateView();
    this._view.reset();
  };
  TileLayer2.prototype._viewType = function _viewType() {
    return TileView;
  };
  TileLayer2.prototype._activate = function _activate() {
    Layer2.prototype._activate.call(this);
    if (!this.support.mobileOS) {
      if (!this._pan) {
        this._pan = throttle(this._render.bind(this), 100);
      }
      this.map.bind("pan", this._pan);
    }
  };
  TileLayer2.prototype._deactivate = function _deactivate() {
    Layer2.prototype._deactivate.call(this);
    if (this._pan) {
      this.map.unbind("pan", this._pan);
    }
  };
  TileLayer2.prototype._updateView = function _updateView() {
    var view = this._view, map3 = this.map, extent = map3.extent(), extentToPoint = {
      nw: map3.locationToLayer(extent.nw).round(),
      se: map3.locationToLayer(extent.se).round()
    };
    view.center(map3.locationToLayer(map3.center()));
    view.extent(extentToPoint);
    view.zoom(map3.zoom());
  };
  TileLayer2.prototype._resize = function _resize() {
    this._render();
  };
  TileLayer2.prototype._panEnd = function _panEnd(e3) {
    Layer2.prototype._panEnd.call(this, e3);
    this._render();
  };
  TileLayer2.prototype._render = function _render() {
    this._updateView();
    this._view.render();
  };
  return TileLayer2;
}(Layer);
setDefaultOptions(TileLayer, {
  tileSize: 256,
  subdomains: ["a", "b", "c"],
  urlTemplate: "",
  zIndex: 1
});
var TileView = function(Class3) {
  function TileView2(element, options2) {
    Class3.call(this);
    this.element = element;
    this._initOptions(options2);
    this.pool = new TilePool();
  }
  if (Class3)
    TileView2.__proto__ = Class3;
  TileView2.prototype = Object.create(Class3 && Class3.prototype);
  TileView2.prototype.constructor = TileView2;
  TileView2.prototype._initOptions = function _initOptions(options2) {
    this.options = deepExtend({}, this.options, options2);
  };
  TileView2.prototype.center = function center(center$1) {
    this._center = center$1;
  };
  TileView2.prototype.extent = function extent(extent$1) {
    this._extent = extent$1;
  };
  TileView2.prototype.viewOrigin = function viewOrigin(origin) {
    this._viewOrigin = origin;
  };
  TileView2.prototype.zoom = function zoom(zoom$1) {
    this._zoom = zoom$1;
  };
  TileView2.prototype.pointToTileIndex = function pointToTileIndex(point2) {
    return new Point$1(math$1.floor(point2.x / this.options.tileSize), math$1.floor(point2.y / this.options.tileSize));
  };
  TileView2.prototype.tileCount = function tileCount() {
    var size = this.size(), firstTileIndex = this.pointToTileIndex(this._extent.nw), nw = this._extent.nw, point2 = this.indexToPoint(firstTileIndex).translate(-nw.x, -nw.y);
    return {
      x: math$1.ceil((math$1.abs(point2.x) + size.width) / this.options.tileSize),
      y: math$1.ceil((math$1.abs(point2.y) + size.height) / this.options.tileSize)
    };
  };
  TileView2.prototype.size = function size() {
    var nw = this._extent.nw, se2 = this._extent.se, diff = se2.clone().translate(-nw.x, -nw.y);
    return {
      width: diff.x,
      height: diff.y
    };
  };
  TileView2.prototype.indexToPoint = function indexToPoint(index2) {
    var x3 = index2.x, y4 = index2.y;
    return new Point$1(x3 * this.options.tileSize, y4 * this.options.tileSize);
  };
  TileView2.prototype.subdomainText = function subdomainText() {
    var subdomains = this.options.subdomains;
    return subdomains[this.subdomainIndex++ % subdomains.length];
  };
  TileView2.prototype.destroy = function destroy2() {
    removeChildren(this.element);
    this.pool.empty();
  };
  TileView2.prototype.reset = function reset() {
    this.pool.reset();
    this.subdomainIndex = 0;
    this.render();
  };
  TileView2.prototype.render = function render() {
    var this$1$1 = this;
    var size = this.tileCount(), firstTileIndex = this.pointToTileIndex(this._extent.nw), tile, x3, y4;
    for (x3 = 0; x3 < size.x; x3++) {
      for (y4 = 0; y4 < size.y; y4++) {
        tile = this$1$1.createTile({
          x: firstTileIndex.x + x3,
          y: firstTileIndex.y + y4
        });
        if (!tile.visible) {
          tile.show();
        }
      }
    }
  };
  TileView2.prototype.createTile = function createTile(currentIndex) {
    var options2 = this.tileOptions(currentIndex);
    var tile = this.pool.get(this._center, options2);
    if (!tile.element.parentNode) {
      this.element.append(tile.element);
    }
    return tile;
  };
  TileView2.prototype.tileOptions = function tileOptions(currentIndex) {
    var index2 = this.wrapIndex(currentIndex), point2 = this.indexToPoint(currentIndex), origin = this._viewOrigin, offset2 = point2.clone().translate(-origin.x, -origin.y);
    return {
      index: index2,
      currentIndex,
      point: point2,
      offset: roundPoint(offset2),
      zoom: this._zoom,
      size: this.options.tileSize,
      subdomain: this.subdomainText(),
      urlTemplate: this.options.urlTemplate,
      errorUrlTemplate: this.options.errorUrlTemplate
    };
  };
  TileView2.prototype.wrapIndex = function wrapIndex(index2) {
    var boundary = math$1.pow(2, this._zoom);
    return {
      x: this.wrapValue(index2.x, boundary),
      y: limitValue(index2.y, 0, boundary - 1)
    };
  };
  TileView2.prototype.wrapValue = function wrapValue(value2, boundary) {
    var remainder = math$1.abs(value2) % boundary;
    var wrappedValue = value2;
    if (value2 >= 0) {
      wrappedValue = remainder;
    } else {
      wrappedValue = boundary - (remainder === 0 ? boundary : remainder);
    }
    return wrappedValue;
  };
  return TileView2;
}(Class$1);
var ImageTile = function(Class3) {
  function ImageTile2(id2, options2) {
    Class3.call(this);
    this.id = id2;
    this.visible = true;
    this._initOptions(options2);
    this.createElement();
    this.show();
  }
  if (Class3)
    ImageTile2.__proto__ = Class3;
  ImageTile2.prototype = Object.create(Class3 && Class3.prototype);
  ImageTile2.prototype.constructor = ImageTile2;
  ImageTile2.prototype.destroy = function destroy2() {
    var element = this.element;
    var parentNode = element ? element.parentNode : null;
    if (element) {
      if (parentNode) {
        parentNode.removeChild(element);
      }
      this.element = null;
    }
  };
  ImageTile2.prototype._initOptions = function _initOptions(options2) {
    this.options = deepExtend({}, this.options, options2);
  };
  ImageTile2.prototype.createElement = function createElement() {
    var el2 = document.createElement("img");
    var size = this.options.size + "px";
    el2.setAttribute("alt", "");
    el2.style.position = "absolute";
    el2.style.display = "block";
    el2.style.width = el2.style.maxWidth = size;
    el2.style.height = el2.style.maxHeight = size;
    this.element = el2;
  };
  ImageTile2.prototype.show = function show2() {
    var element = this.element;
    element.style.top = renderSize(this.options.offset.y);
    element.style.left = renderSize(this.options.offset.x);
    var url = this.url();
    if (url) {
      element.setAttribute("src", url);
    }
    element.style.visibility = "visible";
    this.visible = true;
  };
  ImageTile2.prototype.hide = function hide2() {
    this.element.style.visibility = "hidden";
    this.visible = false;
  };
  ImageTile2.prototype.url = function url() {
    var urlResult = compileTemplate(this.options.urlTemplate);
    return urlResult(this.urlOptions());
  };
  ImageTile2.prototype.errorUrl = function errorUrl() {
    var urlResult = compileTemplate(this.options.errorUrlTemplate);
    return urlResult(this.urlOptions());
  };
  ImageTile2.prototype.urlOptions = function urlOptions() {
    var options2 = this.options;
    return {
      zoom: options2.zoom,
      subdomain: options2.subdomain,
      z: options2.zoom,
      x: options2.index.x,
      y: options2.index.y,
      s: options2.subdomain,
      quadkey: options2.quadkey,
      q: options2.quadkey,
      culture: options2.culture,
      c: options2.culture
    };
  };
  return ImageTile2;
}(Class$1);
setDefaultOptions(ImageTile, {
  urlTemplate: "",
  errorUrlTemplate: ""
});
var TilePool = function(Class3) {
  function TilePool2() {
    Class3.call(this);
    this._items = [];
  }
  if (Class3)
    TilePool2.__proto__ = Class3;
  TilePool2.prototype = Object.create(Class3 && Class3.prototype);
  TilePool2.prototype.constructor = TilePool2;
  TilePool2.prototype.get = function get3(center, options2) {
    if (this._items.length >= this.options.maxSize) {
      this._remove(center);
    }
    return this._create(options2);
  };
  TilePool2.prototype.empty = function empty2() {
    var items = this._items;
    for (var i16 = 0; i16 < items.length; i16++) {
      items[i16].destroy();
    }
    this._items = [];
  };
  TilePool2.prototype.reset = function reset() {
    var items = this._items;
    for (var i16 = 0; i16 < items.length; i16++) {
      items[i16].hide();
    }
  };
  TilePool2.prototype._create = function _create(options2) {
    var items = this._items;
    var tile;
    var id2 = hashKey(options2.point.toString() + options2.offset.toString() + options2.zoom + options2.urlTemplate);
    for (var i16 = 0; i16 < items.length; i16++) {
      if (items[i16].id === id2) {
        tile = items[i16];
        break;
      }
    }
    if (tile) {
      tile.show();
    } else {
      tile = new ImageTile(id2, options2);
      this._items.push(tile);
    }
    return tile;
  };
  TilePool2.prototype._remove = function _remove(center) {
    var items = this._items;
    var maxDist = -1;
    var index2 = -1;
    for (var i16 = 0; i16 < items.length; i16++) {
      var dist = items[i16].options.point.distanceTo(center);
      if (dist > maxDist && !items[i16].visible) {
        index2 = i16;
        maxDist = dist;
      }
    }
    if (index2 !== -1) {
      items[index2].destroy();
      items.splice(index2, 1);
    }
  };
  return TilePool2;
}(Class$1);
setDefaultOptions(TilePool, {
  maxSize: 100
});
var extend$3 = Object.assign;
var CHANGE$1 = "change";
var TapCapture = function(Observable2) {
  function TapCapture2(element, options2) {
    Observable2.call(this);
    var that = this, domElement = element[0] || element;
    that.capture = false;
    if (domElement.addEventListener) {
      eventMap.down.split(" ").forEach(function(event) {
        domElement.addEventListener(event, proxy(that._press, that), true);
      });
      eventMap.up.split(" ").forEach(function(event) {
        domElement.addEventListener(event, proxy(that._release, that), true);
      });
    } else {
      eventMap.down.split(" ").forEach(function(event) {
        domElement.attachEvent(event, proxy(that._press, that));
      });
      eventMap.up.split(" ").forEach(function(event) {
        domElement.attachEvent(event, proxy(that._release, that));
      });
    }
    that.bind([
      "press",
      "release"
    ], options2 || {});
  }
  if (Observable2)
    TapCapture2.__proto__ = Observable2;
  TapCapture2.prototype = Object.create(Observable2 && Observable2.prototype);
  TapCapture2.prototype.constructor = TapCapture2;
  TapCapture2.prototype.captureNext = function captureNext() {
    this.capture = true;
  };
  TapCapture2.prototype.cancelCapture = function cancelCapture() {
    this.capture = false;
  };
  TapCapture2.prototype._press = function _press(e3) {
    var that = this;
    that.trigger("press");
    if (that.capture) {
      e3.preventDefault();
    }
  };
  TapCapture2.prototype._release = function _release(e3) {
    var that = this;
    that.trigger("release");
    if (that.capture) {
      e3.preventDefault();
      that.cancelCapture();
    }
  };
  return TapCapture2;
}(Observable);
var PaneDimension = function(Observable2) {
  function PaneDimension2(options2) {
    Observable2.call(this);
    var that = this;
    that.forcedEnabled = false;
    extend$3(that, options2);
    that.scale = 1;
    if (that.horizontal) {
      that.measure = "offsetWidth";
      that.scrollSize = "scrollWidth";
      that.axis = "x";
    } else {
      that.measure = "offsetHeight";
      that.scrollSize = "scrollHeight";
      that.axis = "y";
    }
  }
  if (Observable2)
    PaneDimension2.__proto__ = Observable2;
  PaneDimension2.prototype = Object.create(Observable2 && Observable2.prototype);
  PaneDimension2.prototype.constructor = PaneDimension2;
  PaneDimension2.prototype.makeVirtual = function makeVirtual() {
    extend$3(this, {
      virtual: true,
      forcedEnabled: true,
      _virtualMin: 0,
      _virtualMax: 0
    });
  };
  PaneDimension2.prototype.virtualSize = function virtualSize(min2, max2) {
    if (this._virtualMin !== min2 || this._virtualMax !== max2) {
      this._virtualMin = min2;
      this._virtualMax = max2;
      this.update();
    }
  };
  PaneDimension2.prototype.outOfBounds = function outOfBounds(offset2) {
    return offset2 > this.max || offset2 < this.min;
  };
  PaneDimension2.prototype.forceEnabled = function forceEnabled() {
    this.forcedEnabled = true;
  };
  PaneDimension2.prototype.getSize = function getSize() {
    return this.container[this.measure];
  };
  PaneDimension2.prototype.getTotal = function getTotal() {
    return this.element[this.scrollSize];
  };
  PaneDimension2.prototype.rescale = function rescale(scale) {
    this.scale = scale;
  };
  PaneDimension2.prototype.update = function update(silent) {
    var that = this, total3 = that.virtual ? that._virtualMax : that.getTotal(), scaledTotal = total3 * that.scale, size = that.getSize();
    if (total3 === 0 && !that.forcedEnabled) {
      return;
    }
    that.max = that.virtual ? -that._virtualMin : 0;
    that.size = size;
    that.total = scaledTotal;
    that.min = Math.min(that.max, size - scaledTotal);
    that.minScale = size / total3;
    that.centerOffset = (scaledTotal - size) / 2;
    that.enabled = that.forcedEnabled || scaledTotal > size;
    if (!silent) {
      that.trigger(CHANGE$1, that);
    }
  };
  return PaneDimension2;
}(Observable);
var PaneDimensions = function(Observable2) {
  function PaneDimensions2(options2) {
    Observable2.call(this);
    var that = this;
    that.x = new PaneDimension(extend$3({
      horizontal: true
    }, options2));
    that.y = new PaneDimension(extend$3({
      horizontal: false
    }, options2));
    that.container = options2.container;
    that.forcedMinScale = options2.minScale;
    that.maxScale = options2.maxScale || 100;
    that.bind(CHANGE$1, options2);
  }
  if (Observable2)
    PaneDimensions2.__proto__ = Observable2;
  PaneDimensions2.prototype = Object.create(Observable2 && Observable2.prototype);
  PaneDimensions2.prototype.constructor = PaneDimensions2;
  PaneDimensions2.prototype.rescale = function rescale(newScale) {
    this.x.rescale(newScale);
    this.y.rescale(newScale);
    this.refresh();
  };
  PaneDimensions2.prototype.centerCoordinates = function centerCoordinates() {
    return {
      x: Math.min(0, -this.x.centerOffset),
      y: Math.min(0, -this.y.centerOffset)
    };
  };
  PaneDimensions2.prototype.refresh = function refresh() {
    var that = this;
    that.x.update();
    that.y.update();
    that.enabled = that.x.enabled || that.y.enabled;
    that.minScale = that.forcedMinScale || Math.min(that.x.minScale, that.y.minScale);
    that.fitScale = Math.max(that.x.minScale, that.y.minScale);
    that.trigger(CHANGE$1);
  };
  return PaneDimensions2;
}(Observable);
var PaneAxis = function(Observable2) {
  function PaneAxis2(options2) {
    Observable2.call(this);
    extend$3(this, options2);
  }
  if (Observable2)
    PaneAxis2.__proto__ = Observable2;
  PaneAxis2.prototype = Object.create(Observable2 && Observable2.prototype);
  PaneAxis2.prototype.constructor = PaneAxis2;
  PaneAxis2.prototype.outOfBounds = function outOfBounds() {
    return this.dimension.outOfBounds(this.movable[this.axis]);
  };
  PaneAxis2.prototype.dragMove = function dragMove(delta) {
    var that = this, dimension = that.dimension, axis = that.axis, movable = that.movable, position2 = movable[axis] + delta;
    if (!dimension.enabled) {
      return;
    }
    var dragDelta = delta;
    if (position2 < dimension.min && delta < 0 || position2 > dimension.max && delta > 0) {
      dragDelta *= that.resistance;
    }
    movable.translateAxis(axis, dragDelta);
    that.trigger(CHANGE$1, that);
  };
  return PaneAxis2;
}(Observable);
var Pane = function(Class3) {
  function Pane2(options2) {
    Class3.call(this);
    var that = this, x3, y4, resistance, movable;
    extend$3(that, {
      elastic: true
    }, options2);
    resistance = that.elastic ? 0.5 : 0;
    movable = that.movable;
    that.x = x3 = new PaneAxis({
      axis: "x",
      dimension: that.dimensions.x,
      resistance,
      movable
    });
    that.y = y4 = new PaneAxis({
      axis: "y",
      dimension: that.dimensions.y,
      resistance,
      movable
    });
    that.userEvents.bind([
      "press",
      "move",
      "end",
      "gesturestart",
      "gesturechange"
    ], {
      gesturestart: function gesturestart(e3) {
        that.gesture = e3;
        that.offset = elementOffset(that.dimensions.container);
      },
      press: function press(e3) {
        var closestAnchor = e3.event.target.closest("a");
        if (closestAnchor && closestAnchor.matches("[data-navigate-on-press=true]")) {
          e3.sender.cancel();
        }
      },
      gesturechange: function gesturechange(e3) {
        var previousGesture = that.gesture, previousCenter = previousGesture.center, center = e3.center, scaleDelta = e3.distance / previousGesture.distance, minScale = that.dimensions.minScale, maxScale = that.dimensions.maxScale, coordinates;
        if (movable.scale <= minScale && scaleDelta < 1) {
          scaleDelta += (1 - scaleDelta) * 0.8;
        }
        if (movable.scale * scaleDelta >= maxScale) {
          scaleDelta = maxScale / movable.scale;
        }
        var offsetX = movable.x + that.offset.left, offsetY = movable.y + that.offset.top;
        coordinates = {
          x: (offsetX - previousCenter.x) * scaleDelta + center.x - offsetX,
          y: (offsetY - previousCenter.y) * scaleDelta + center.y - offsetY
        };
        movable.scaleWith(scaleDelta);
        x3.dragMove(coordinates.x);
        y4.dragMove(coordinates.y);
        that.dimensions.rescale(movable.scale);
        that.gesture = e3;
        e3.preventDefault();
      },
      move: function move(e3) {
        if (e3.event.target.tagName.match(/textarea|input/i)) {
          return;
        }
        if (x3.dimension.enabled || y4.dimension.enabled) {
          x3.dragMove(e3.x.delta);
          y4.dragMove(e3.y.delta);
          e3.preventDefault();
        } else {
          e3.touch.skip();
        }
      },
      end: function end(e3) {
        e3.preventDefault();
      }
    });
  }
  if (Class3)
    Pane2.__proto__ = Class3;
  Pane2.prototype = Object.create(Class3 && Class3.prototype);
  Pane2.prototype.constructor = Pane2;
  return Pane2;
}(Class$1);
var translate = function(x3, y4, scale) {
  return "translate3d(" + x3 + "px," + y4 + "px,0) scale(" + scale + ")";
};
var Movable = function(Observable2) {
  function Movable2(element) {
    Observable2.call(this);
    var that = this;
    that.element = element;
    that.element.style.transformOrigin = "left top";
    that.x = 0;
    that.y = 0;
    that.scale = 1;
    var coordinates = translate(that.x, that.y, that.scale);
    that.element.style.transform = coordinates;
    that._saveCoordinates(coordinates);
  }
  if (Observable2)
    Movable2.__proto__ = Observable2;
  Movable2.prototype = Object.create(Observable2 && Observable2.prototype);
  Movable2.prototype.constructor = Movable2;
  Movable2.prototype.translateAxis = function translateAxis(axis, by) {
    this[axis] += by;
    this.refresh();
  };
  Movable2.prototype.scaleTo = function scaleTo(scale) {
    this.scale = scale;
    this.refresh();
  };
  Movable2.prototype.scaleWith = function scaleWith(scaleDelta) {
    this.scale *= scaleDelta;
    this.refresh();
  };
  Movable2.prototype.translate = function translate2(coordinates) {
    this.x += coordinates.x;
    this.y += coordinates.y;
    this.refresh();
  };
  Movable2.prototype.moveAxis = function moveAxis(axis, value2) {
    this[axis] = value2;
    this.refresh();
  };
  Movable2.prototype.moveTo = function moveTo(coordinates) {
    extend$3(this, coordinates);
    this.refresh();
  };
  Movable2.prototype.refresh = function refresh() {
    var that = this, x3 = that.x, y4 = that.y, newCoordinates;
    if (that.round) {
      x3 = Math.round(x3);
      y4 = Math.round(y4);
    }
    newCoordinates = translate(x3, y4, that.scale);
    if (newCoordinates !== that.coordinates) {
      that.element.style.transform = newCoordinates;
      that._saveCoordinates(newCoordinates);
      that.trigger(CHANGE$1);
    }
  };
  Movable2.prototype._saveCoordinates = function _saveCoordinates(coordinates) {
    this.coordinates = coordinates;
  };
  return Movable2;
}(Observable);
var Group = Group$9;
var ShapeLayer = function(Layer2) {
  function ShapeLayer2(map3, options2) {
    Layer2.call(this, map3, options2);
    this._pan = proxy(this._pan, this);
    this.surface = Surface$2.create(this.element, {
      width: map3.scrollElement.clientWidth,
      height: map3.scrollElement.clientHeight
    });
    this._initRoot();
    this.movable = new Movable(this.surface.element);
    this._markers = [];
    this._click = this._handler("shapeClick");
    this.surface.bind("click", this._click);
    this._mouseleave = this._handler("shapeMouseLeave");
    this.surface.bind("mouseleave", this._mouseleave);
    this.surface.bind("mouseenter", this._mouseenter.bind(this));
  }
  if (Layer2)
    ShapeLayer2.__proto__ = Layer2;
  ShapeLayer2.prototype = Object.create(Layer2 && Layer2.prototype);
  ShapeLayer2.prototype.constructor = ShapeLayer2;
  ShapeLayer2.prototype.destroy = function destroy2() {
    Layer2.prototype.destroy.call(this);
    this.surface.destroy();
  };
  ShapeLayer2.prototype._reset = function _reset() {
    Layer2.prototype._reset.call(this);
    this._translateSurface();
    this._data = this._readData();
    if (this._hasData()) {
      this._load(this._data);
    }
  };
  ShapeLayer2.prototype._initRoot = function _initRoot() {
    this._root = new Group();
    this.surface.draw(this._root);
  };
  ShapeLayer2.prototype._beforeReset = function _beforeReset() {
    this.surface.clear();
    this._initRoot();
  };
  ShapeLayer2.prototype._resize = function _resize() {
    this.surface.size(this.map.size());
  };
  ShapeLayer2.prototype._readData = function _readData() {
    var data2 = Layer2.prototype._readData.call(this);
    if (data2.type === "FeatureCollection") {
      return data2.features;
    }
    if (data2.type === "GeometryCollection") {
      return data2.geometries;
    }
    return data2;
  };
  ShapeLayer2.prototype._load = function _load(data2) {
    var this$1$1 = this;
    this._data = data2;
    this._clearMarkers();
    if (!this._loader) {
      this._loader = new GeoJsonLoader(this.map, this.options.style, this);
    }
    var container = new Group();
    for (var i16 = 0; i16 < data2.length; i16++) {
      var shape = this$1$1._loader.parse(data2[i16]);
      if (shape) {
        container.append(shape);
      }
    }
    this._root.clear();
    this._root.append(container);
  };
  ShapeLayer2.prototype.shapeCreated = function shapeCreated(shape) {
    var cancelled = false;
    if (shape instanceof Circle$3 && this.map.options.renderPointsAsMarkers) {
      cancelled = defined(this._createMarker(shape));
    }
    if (!cancelled) {
      var args = {
        layer: this,
        shape
      };
      cancelled = this.map.trigger("shapeCreated", args);
    }
    return cancelled;
  };
  ShapeLayer2.prototype.featureCreated = function featureCreated(e3) {
    e3.layer = this;
    this.map.trigger("shapeFeatureCreated", e3);
  };
  ShapeLayer2.prototype._createMarker = function _createMarker(shape) {
    var marker = this.map.markers.bind({
      location: shape.location
    }, shape.dataItem);
    if (marker) {
      this._markers.push(marker);
    }
    return marker;
  };
  ShapeLayer2.prototype._clearMarkers = function _clearMarkers() {
    var this$1$1 = this;
    for (var i16 = 0; i16 < this._markers.length; i16++) {
      this$1$1.map.markers.remove(this$1$1._markers[i16]);
    }
    this._markers = [];
  };
  ShapeLayer2.prototype._pan = function _pan() {
    if (!this._panning) {
      this._panning = true;
      this.surface.suspendTracking();
    }
  };
  ShapeLayer2.prototype._panEnd = function _panEnd(e3) {
    Layer2.prototype._panEnd.call(this, e3);
    this._translateSurface();
    this.surface.resumeTracking();
    this._panning = false;
  };
  ShapeLayer2.prototype._translateSurface = function _translateSurface() {
    var map3 = this.map;
    var nw = map3.locationToView(map3.extent().nw);
    if (this.surface.translate) {
      this.surface.translate(nw);
      this.movable.moveTo({
        x: nw.x,
        y: nw.y
      });
    }
  };
  ShapeLayer2.prototype._eventArgs = function _eventArgs(e3) {
    return {
      layer: this,
      layerIndex: this._layerIndex(),
      shape: e3.element,
      shapeIndex: (this._data || []).indexOf(e3.element.dataItem),
      originalEvent: e3.originalEvent
    };
  };
  ShapeLayer2.prototype._handler = function _handler(eventName) {
    var this$1$1 = this;
    return function(e3) {
      if (e3.element) {
        this$1$1.map.trigger(eventName, this$1$1._eventArgs(e3));
      }
    };
  };
  ShapeLayer2.prototype._mouseenter = function _mouseenter2(e3) {
    if (!e3.element) {
      return;
    }
    this.map.trigger("shapeMouseEnter", this._eventArgs(e3));
    var shape = e3.element;
    var anchor = this._tooltipAnchor(e3);
    this.map._tooltip.show(anchor, this._tooltipContext(shape));
  };
  ShapeLayer2.prototype._tooltipContext = function _tooltipContext(shape) {
    return {
      type: "shape",
      layerIndex: this._layerIndex(),
      className: "k-map-shape-tooltip",
      dataItem: shape.dataItem,
      location: shape.location
    };
  };
  ShapeLayer2.prototype._tooltipAnchor = function _tooltipAnchor(e3) {
    var cursor = this.map.eventOffset(e3.originalEvent);
    return {
      top: cursor.y,
      left: cursor.x
    };
  };
  ShapeLayer2.prototype._activate = function _activate() {
    Layer2.prototype._activate.call(this);
    this._panHandler = proxy(this._pan, this);
    this.map.bind("pan", this.panHandler);
  };
  ShapeLayer2.prototype._deactivate = function _deactivate() {
    Layer2.prototype._deactivate.call(this);
    this.map.unbind("pan", this._panHandler);
  };
  return ShapeLayer2;
}(Layer);
setDefaultOptions(ShapeLayer, {
  autoBind: true,
  zIndex: 100
});
var GeoJsonLoader = function(Class3) {
  function GeoJsonLoader2(locator, defaultStyle, observer) {
    Class3.call(this);
    this.observer = observer;
    this.locator = locator;
    this.style = defaultStyle;
  }
  if (Class3)
    GeoJsonLoader2.__proto__ = Class3;
  GeoJsonLoader2.prototype = Object.create(Class3 && Class3.prototype);
  GeoJsonLoader2.prototype.constructor = GeoJsonLoader2;
  GeoJsonLoader2.prototype.parse = function parse(item) {
    var root = new Group();
    var unwrap = true;
    if (item.type === "Feature") {
      unwrap = false;
      this._loadGeometryTo(root, item.geometry, item);
      this._featureCreated(root, item);
    } else {
      this._loadGeometryTo(root, item, item);
    }
    if (unwrap && root.children.length < 2) {
      root = root.children[0];
    }
    return root;
  };
  GeoJsonLoader2.prototype._shapeCreated = function _shapeCreated(shape) {
    var cancelled = false;
    if (this.observer && this.observer.shapeCreated) {
      cancelled = this.observer.shapeCreated(shape);
    }
    return cancelled;
  };
  GeoJsonLoader2.prototype._featureCreated = function _featureCreated(group2, dataItem) {
    if (this.observer && this.observer.featureCreated) {
      this.observer.featureCreated({
        group: group2,
        dataItem,
        properties: dataItem.properties
      });
    }
  };
  GeoJsonLoader2.prototype._loadGeometryTo = function _loadGeometryTo(container, geometry, dataItem) {
    var this$1$1 = this;
    var coords = geometry.coordinates;
    var i16;
    var path;
    switch (geometry.type) {
      case "LineString":
        path = this._loadPolygon(container, [coords], dataItem);
        this._setLineFill(path);
        break;
      case "MultiLineString":
        for (i16 = 0; i16 < coords.length; i16++) {
          path = this$1$1._loadPolygon(container, [coords[i16]], dataItem);
          this$1$1._setLineFill(path);
        }
        break;
      case "Polygon":
        this._loadPolygon(container, coords, dataItem);
        break;
      case "MultiPolygon":
        for (i16 = 0; i16 < coords.length; i16++) {
          this$1$1._loadPolygon(container, coords[i16], dataItem);
        }
        break;
      case "Point":
        this._loadPoint(container, coords, dataItem);
        break;
      case "MultiPoint":
        for (i16 = 0; i16 < coords.length; i16++) {
          this$1$1._loadPoint(container, coords[i16], dataItem);
        }
        break;
    }
  };
  GeoJsonLoader2.prototype._setLineFill = function _setLineFill(path) {
    var segments = path.segments;
    if (segments.length < 4 || !segments[0].anchor().equals(last(segments).anchor())) {
      path.options.fill = null;
    }
  };
  GeoJsonLoader2.prototype._loadShape = function _loadShape(container, shape) {
    if (!this._shapeCreated(shape)) {
      container.append(shape);
    }
    return shape;
  };
  GeoJsonLoader2.prototype._loadPolygon = function _loadPolygon(container, rings, dataItem) {
    var shape = this._buildPolygon(rings);
    shape.dataItem = dataItem;
    shape.location = this.locator.viewToLocation(shape.bbox().center());
    return this._loadShape(container, shape);
  };
  GeoJsonLoader2.prototype._buildPolygon = function _buildPolygon(rings) {
    var this$1$1 = this;
    var type = rings.length > 1 ? MultiPath : Path$7;
    var path = new type(this.style);
    for (var i16 = 0; i16 < rings.length; i16++) {
      for (var j2 = 0; j2 < rings[i16].length; j2++) {
        var point2 = this$1$1.locator.locationToView(Location.fromLngLat(rings[i16][j2]));
        if (j2 === 0) {
          path.moveTo(point2.x, point2.y);
        } else {
          path.lineTo(point2.x, point2.y);
        }
      }
    }
    return path;
  };
  GeoJsonLoader2.prototype._loadPoint = function _loadPoint(container, coords, dataItem) {
    var location = Location.fromLngLat(coords);
    var point2 = this.locator.locationToView(location);
    var circle = new geomCircle(point2, 10);
    var shape = new Circle$3(circle, this.style);
    shape.dataItem = dataItem;
    shape.location = location;
    return this._loadShape(container, shape);
  };
  return GeoJsonLoader2;
}(Class$1);
var BubbleLayer = function(ShapeLayer2) {
  function BubbleLayer2() {
    ShapeLayer2.apply(this, arguments);
  }
  if (ShapeLayer2)
    BubbleLayer2.__proto__ = ShapeLayer2;
  BubbleLayer2.prototype = Object.create(ShapeLayer2 && ShapeLayer2.prototype);
  BubbleLayer2.prototype.constructor = BubbleLayer2;
  BubbleLayer2.prototype._readData = function _readData() {
    var data2 = this.options.data || [];
    return data2;
  };
  BubbleLayer2.prototype._load = function _load(data2) {
    var this$1$1 = this;
    this._data = data2;
    this.surface.clear();
    if (data2.length === 0) {
      return;
    }
    var options2 = this.options;
    var getValue = getter$1(options2.valueField);
    var newData = data2.slice(0);
    newData.sort(function(a9, b2) {
      return getValue(b2) - getValue(a9);
    });
    var scaleType = this._scaleType();
    var scale;
    var getLocation = getter$1(this.options.locationField);
    for (var i16 = 0; i16 < newData.length; i16++) {
      var dataItem = newData[i16];
      var location = getLocation(dataItem);
      var value2 = getValue(dataItem);
      if (defined(location) && defined(value2)) {
        if (!scale) {
          scale = new scaleType([
            0,
            value2
          ], [
            options2.minSize,
            options2.maxSize
          ]);
        }
        location = Location.create(location);
        var center = this$1$1.map.locationToView(location);
        var size = scale.map(value2);
        var symbol = this$1$1._createSymbol({
          center,
          size,
          style: options2.style,
          dataItem,
          location
        });
        symbol.dataItem = dataItem;
        symbol.location = location;
        symbol.value = value2;
        this$1$1._drawSymbol(symbol);
      }
    }
  };
  BubbleLayer2.prototype._scaleType = function _scaleType() {
    var scale = this.options.scale;
    if (isFunction$1(scale)) {
      return scale;
    }
    return Scales[scale];
  };
  BubbleLayer2.prototype._createSymbol = function _createSymbol(args) {
    var symbol = this.options.symbol;
    if (!isFunction$1(symbol)) {
      symbol = Symbols[symbol];
    }
    return symbol(args);
  };
  BubbleLayer2.prototype._drawSymbol = function _drawSymbol(shape) {
    var args = {
      layer: this,
      shape
    };
    var cancelled = this.map.trigger("shapeCreated", args);
    if (!cancelled) {
      this.surface.draw(shape);
    }
  };
  BubbleLayer2.prototype._tooltipContext = function _tooltipContext(shape) {
    return {
      type: "bubble",
      layerIndex: this._layerIndex(),
      className: "k-map-bubble-tooltip",
      dataItem: shape.dataItem,
      location: shape.location,
      value: shape.value
    };
  };
  BubbleLayer2.prototype._tooltipAnchor = function _tooltipAnchor(e3) {
    var shape = e3.element;
    var center = shape.bbox().center();
    return {
      top: center.y,
      left: center.x
    };
  };
  return BubbleLayer2;
}(ShapeLayer);
setDefaultOptions(BubbleLayer, {
  // autoBind: true,
  locationField: "location",
  valueField: "value",
  minSize: 0,
  maxSize: 100,
  scale: "sqrt",
  symbol: "circle",
  // ensure bubble layers are displayed over tile and shape layers
  zIndex: 200
});
var SqrtScale = function(Class3) {
  function SqrtScale2(domain, range) {
    Class3.call(this);
    this._domain = domain;
    this._range = range;
    var domainRange = Math.sqrt(domain[1]) - Math.sqrt(domain[0]);
    var outputRange = range[1] - range[0];
    this._ratio = outputRange / domainRange;
  }
  if (Class3)
    SqrtScale2.__proto__ = Class3;
  SqrtScale2.prototype = Object.create(Class3 && Class3.prototype);
  SqrtScale2.prototype.constructor = SqrtScale2;
  SqrtScale2.prototype.map = function map3(value2) {
    var rel = (Math.sqrt(value2) - Math.sqrt(this._domain[0])) * this._ratio;
    return this._range[0] + rel;
  };
  return SqrtScale2;
}(Class$1);
var Scales = {
  sqrt: SqrtScale
};
var Symbols = {
  circle: function(args) {
    var geo = new geomCircle(args.center, args.size / 2);
    return new Circle$3(geo, args.style);
  },
  square: function(args) {
    var path = new Path$7(args.style);
    var halfSize = args.size / 2;
    var center = args.center;
    path.moveTo(center.x - halfSize, center.y - halfSize).lineTo(center.x + halfSize, center.y - halfSize).lineTo(center.x + halfSize, center.y + halfSize).lineTo(center.x - halfSize, center.y + halfSize).close();
    return path;
  }
};
var CLICK = "click";
var MOUSE_ENTER = "mouseenter";
var MOUSE_LEAVE = "mouseleave";
var extend$2 = Object.assign;
var MARKER_CLASS_NAME = "k-marker";
var MARKER_CLASS = "." + MARKER_CLASS_NAME;
var MarkerLayer = function(Layer2) {
  function MarkerLayer2(map3, options2) {
    Layer2.call(this, map3, options2);
    this._markerClickHandler = proxy(this._markerClick, this);
    on(this.element, CLICK, MARKER_CLASS, this._markerClickHandler);
    this.items = [];
    this._load(this._readData());
  }
  if (Layer2)
    MarkerLayer2.__proto__ = Layer2;
  MarkerLayer2.prototype = Object.create(Layer2 && Layer2.prototype);
  MarkerLayer2.prototype.constructor = MarkerLayer2;
  MarkerLayer2.prototype.destroy = function destroy2() {
    Layer2.prototype.destroy.call(this);
    off(this.element, CLICK, this._markerClickHandler);
    this.clear();
  };
  MarkerLayer2.prototype.add = function add3(args) {
    var this$1$1 = this;
    if (isArray$1(args)) {
      for (var i16 = 0; i16 < args.length; i16++) {
        this$1$1._addOne(args[i16]);
      }
    } else {
      return this._addOne(args);
    }
  };
  MarkerLayer2.prototype.remove = function remove(marker) {
    marker.destroy();
    var index2 = (this.items || []).indexOf(marker);
    if (index2 > -1) {
      this.items.splice(index2, 1);
    }
  };
  MarkerLayer2.prototype.clear = function clear4() {
    var this$1$1 = this;
    for (var i16 = 0; i16 < this.items.length; i16++) {
      this$1$1.items[i16].destroy();
    }
    this.items = [];
  };
  MarkerLayer2.prototype.update = function update(marker) {
    var location = marker.location();
    if (location) {
      marker.showAt(this.map.locationToView(location));
      var args = {
        marker,
        layer: this
      };
      this.map.trigger("markerActivate", args);
    }
  };
  MarkerLayer2.prototype._reset = function _reset() {
    var this$1$1 = this;
    Layer2.prototype._reset.call(this);
    var items = this.items;
    for (var i16 = 0; i16 < items.length; i16++) {
      this$1$1.update(items[i16]);
    }
  };
  MarkerLayer2.prototype.bind = function bind(options2, dataItem) {
    var marker = Marker.create(options2, this.options);
    marker.dataItem = dataItem;
    var args = {
      marker,
      layer: this
    };
    var cancelled = this.map.trigger("markerCreated", args);
    if (!cancelled) {
      this.add(marker);
      return marker;
    }
  };
  MarkerLayer2.prototype._addOne = function _addOne(arg) {
    var marker = Marker.create(arg, this.options);
    marker.addTo(this);
    return marker;
  };
  MarkerLayer2.prototype._readData = function _readData() {
    var data2 = this.options.data || [];
    return data2;
  };
  MarkerLayer2.prototype._load = function _load(data2) {
    var this$1$1 = this;
    this._data = data2;
    this.clear();
    var getLocation = getter$1(this.options.locationField);
    var getTitle = getter$1(this.options.titleField);
    for (var i16 = 0; i16 < data2.length; i16++) {
      var dataItem = data2[i16];
      this$1$1.bind({
        location: getLocation(dataItem),
        title: getTitle(dataItem)
      }, dataItem);
    }
  };
  MarkerLayer2.prototype._markerClick = function _markerClick(e3) {
    var marker = e3.currentTarget._kendoNode;
    var args = {
      layer: this,
      layerIndex: this._layerIndex(),
      marker,
      markerIndex: (this.items || []).indexOf(marker),
      originalEvent: e3
    };
    this.map.trigger("markerClick", args);
  };
  MarkerLayer2.prototype._markerMouseEnter = function _markerMouseEnter(e3) {
    var args = this._createMarkerEventArgs(e3);
    this.map.trigger("markerMouseEnter", args);
  };
  MarkerLayer2.prototype._markerMouseLeave = function _markerMouseLeave(e3) {
    var args = this._createMarkerEventArgs(e3);
    this.map.trigger("markerMouseLeave", args);
  };
  MarkerLayer2.prototype._createMarkerEventArgs = function _createMarkerEventArgs(e3) {
    var marker = e3.marker;
    var args = extend$2({}, {
      layer: this,
      layerIndex: this._layerIndex(),
      marker,
      markerIndex: (this.items || []).indexOf(marker)
    }, e3);
    return args;
  };
  return MarkerLayer2;
}(Layer);
setDefaultOptions(MarkerLayer, {
  zIndex: 1e3,
  autoBind: true,
  locationField: "location",
  titleField: "title",
  template: ""
});
var Marker = function(Class3) {
  function Marker2(options2) {
    Class3.call(this);
    this.options = options2 || {};
  }
  if (Class3)
    Marker2.__proto__ = Class3;
  Marker2.prototype = Object.create(Class3 && Class3.prototype);
  Marker2.prototype.constructor = Marker2;
  Marker2.prototype.destroy = function destroy2() {
    this.layer = null;
    this.unbindEvents();
    this.hide();
  };
  Marker2.prototype.addTo = function addTo(parent) {
    this.layer = parent.markers || parent;
    this.layer.items.push(this);
    this.layer.update(this);
  };
  Marker2.prototype.location = function location(value2) {
    if (value2) {
      this.options.location = Location.create(value2).toArray();
      if (this.layer) {
        this.layer.update(this);
      }
      return this;
    }
    return Location.create(this.options.location);
  };
  Marker2.prototype.showAt = function showAt(point2) {
    this.render();
    this._anchor = { left: Math.round(point2.x), top: Math.round(point2.y) };
    this.element.style.left = toPixels(this._anchor.left);
    this.element.style.top = toPixels(this._anchor.top);
  };
  Marker2.prototype.hide = function hide2() {
    if (this.element) {
      this.element.remove();
      this.element = null;
    }
  };
  Marker2.prototype.bindEvents = function bindEvents2() {
    if (!this.element) {
      return;
    }
    this._mouseEnterHandler = proxy(this._mouseEnter, this);
    on(this.element, MOUSE_ENTER, MARKER_CLASS, this._mouseEnterHandler);
    this._mouseLeaveHandler = proxy(this._mouseLeave, this);
    on(this.element, MOUSE_LEAVE, MARKER_CLASS, this._mouseLeaveHandler);
  };
  Marker2.prototype.unbindEvents = function unbindEvents2() {
    if (!this.element) {
      return;
    }
    off(this.element, MOUSE_ENTER, this._mouseEnterHandler);
    off(this.element, MOUSE_LEAVE, this._mouseLeaveHandler);
  };
  Marker2.prototype.render = function render() {
    if (!this.element) {
      var options2 = this.options;
      var layer = this.layer;
      var element = document.createElement("span");
      addClass2(element, MARKER_CLASS_NAME);
      if (this.options.template) {
        var templateFn = this._compileTemplate(this.options.template);
        var templateHtml = templateFn(this.dataItem);
        var templateElement = convertToHtml(templateHtml);
        element.appendChild(templateElement);
      } else if (options2.svgIcon) {
        renderIcon(element, { icon: options2.svgIcon, iconClass: "k-icon-xxl", svgIcons: this.options.icons.svgIcons, type: "svg" });
      } else {
        var iconOptions = { icon: "map-marker", iconClass: "k-icon-xxl", svgIcons: this.options.icons.svgIcons, type: this.options.icons.type };
        if (options2.shape) {
          if (options2.shape === "pinTarget") {
            iconOptions.icon = "map-marker-target";
            renderIcon(element, iconOptions);
          } else if (options2.shape === "pin") {
            renderIcon(element, iconOptions);
          } else {
            addClass2(element, "k-icon k-icon-xxl k-i-marker-" + toHyphens(options2.shape || "pin"));
          }
        } else {
          renderIcon(element, iconOptions);
        }
      }
      if (options2.title) {
        element.setAttribute("title", options2.title);
      }
      var attributes2 = options2.attributes || {};
      Object.keys(attributes2).forEach(function(key) {
        element.setAttribute(key, attributes2[key]);
      });
      element._kendoNode = this;
      element.style.zIndex = options2.zIndex;
      this.element = element;
      if (layer) {
        layer.element.appendChild(this.element);
      }
      this.bindEvents();
    }
  };
  Marker2.prototype._mouseEnter = function _mouseEnter(e3) {
    var args = this._createEventArgs(e3);
    this.layer._markerMouseEnter(args);
    this.layer.map._tooltip.show({
      top: this._anchor.top - this.element.offsetHeight,
      left: this._anchor.left
    }, this._tooltipContext());
  };
  Marker2.prototype._tooltipContext = function _tooltipContext() {
    return {
      type: "marker",
      layerIndex: this.layer._layerIndex(),
      className: "k-map-marker-tooltip",
      dataItem: this.dataItem,
      title: this.options.title,
      location: this.location()
    };
  };
  Marker2.prototype._mouseLeave = function _mouseLeave(e3) {
    var args = this._createEventArgs(e3);
    this.layer._markerMouseLeave(args);
  };
  Marker2.prototype._createEventArgs = function _createEventArgs(e3) {
    var args = {
      marker: this,
      originalEvent: e3
    };
    return args;
  };
  Marker2.prototype._compileTemplate = function _compileTemplate(template) {
    return TemplateService.compile(template, {
      paramName: "dataItem",
      useWithBlock: false
    });
  };
  Marker2.create = function create2(arg, defaults) {
    if (arg instanceof Marker2) {
      return arg;
    }
    return new Marker2(deepExtend({}, defaults, arg));
  };
  return Marker2;
}(Class$1);
var extend$1 = Object.assign;
function animationFrame(callback) {
  window.requestAnimationFrame(callback);
}
var Animation = function(Class3) {
  function Animation2() {
    Class3.call(this);
    var that = this;
    that._tickProxy = proxy(that._tick, that);
    that._started = false;
  }
  if (Class3)
    Animation2.__proto__ = Class3;
  Animation2.prototype = Object.create(Class3 && Class3.prototype);
  Animation2.prototype.constructor = Animation2;
  Animation2.prototype.tick = function tick() {
  };
  Animation2.prototype.done = function done() {
  };
  Animation2.prototype.onEnd = function onEnd() {
  };
  Animation2.prototype.onCancel = function onCancel() {
  };
  Animation2.prototype.start = function start() {
    if (!this.enabled()) {
      return;
    }
    if (!this.done()) {
      this._started = true;
      animationFrame(this._tickProxy);
    } else {
      this.onEnd();
    }
  };
  Animation2.prototype.enabled = function enabled() {
    return true;
  };
  Animation2.prototype.cancel = function cancel() {
    this._started = false;
    this.onCancel();
  };
  Animation2.prototype._tick = function _tick() {
    var that = this;
    if (!that._started) {
      return;
    }
    that.tick();
    if (!that.done()) {
      animationFrame(that._tickProxy);
    } else {
      that._started = false;
      that.onEnd();
    }
  };
  return Animation2;
}(Class$1);
var Transition = function(Animation2) {
  function Transition2(options2) {
    Animation2.call(this);
    extend$1(this, options2);
  }
  if (Animation2)
    Transition2.__proto__ = Animation2;
  Transition2.prototype = Object.create(Animation2 && Animation2.prototype);
  Transition2.prototype.constructor = Transition2;
  Transition2.prototype.done = function done() {
    return this.timePassed() >= this.duration;
  };
  Transition2.prototype.timePassed = function timePassed() {
    return Math.min(this.duration, now() - this.startDate);
  };
  Transition2.prototype.moveTo = function moveTo(options2) {
    var that = this, movable = that.movable;
    that.initial = movable[that.axis];
    that.delta = options2.location - that.initial;
    that.duration = typeof options2.duration === "number" ? options2.duration : 300;
    that.tick = that._easeProxy(options2.ease);
    that.startDate = now();
    that.start();
  };
  Transition2.prototype._easeProxy = function _easeProxy(ease) {
    var that = this;
    return function() {
      that.movable.moveAxis(that.axis, ease(that.timePassed(), that.initial, that.delta, that.duration));
    };
  };
  Transition2.easeOutExpo = function easeOutExpo(t6, b2, c6, d8) {
    return t6 === d8 ? b2 + c6 : c6 * (-Math.pow(2, -10 * t6 / d8) + 1) + b2;
  };
  return Transition2;
}(Animation);
var extend = Object.assign, abs = Math.abs, SNAPBACK_DURATION = 500, SCROLLBAR_OPACITY = 0.7, FRICTION$1 = 0.96, VELOCITY_MULTIPLIER$1 = 10, MAX_VELOCITY = 55, OUT_OF_BOUNDS_FRICTION = 0.5, ANIMATED_SCROLLER_PRECISION = 5, PULL = "pull", CHANGE = "change", RESIZE = "resize", SCROLL = "scroll", MOUSE_WHEEL_ID = 2;
var ZoomSnapBack = function(Animation2) {
  function ZoomSnapBack2(options2) {
    Animation2.call(this, options2);
    var that = this;
    extend(that, options2);
    that.userEvents.bind("gestureend", that.start.bind(this));
    that.tapCapture.bind("press", that.cancel.bind(this));
  }
  if (Animation2)
    ZoomSnapBack2.__proto__ = Animation2;
  ZoomSnapBack2.prototype = Object.create(Animation2 && Animation2.prototype);
  ZoomSnapBack2.prototype.constructor = ZoomSnapBack2;
  ZoomSnapBack2.prototype.enabled = function enabled() {
    return this.movable.scale < this.dimensions.minScale;
  };
  ZoomSnapBack2.prototype.done = function done() {
    return this.dimensions.minScale - this.movable.scale < 0.01;
  };
  ZoomSnapBack2.prototype.tick = function tick() {
    var movable = this.movable;
    movable.scaleWith(1.1);
    this.dimensions.rescale(movable.scale);
  };
  ZoomSnapBack2.prototype.onEnd = function onEnd() {
    var movable = this.movable;
    movable.scaleTo(this.dimensions.minScale);
    this.dimensions.rescale(movable.scale);
  };
  return ZoomSnapBack2;
}(Animation);
var DragInertia = function(Animation2) {
  function DragInertia2(options2) {
    Animation2.call(this);
    var that = this;
    extend(that, options2, {
      transition: new Transition({
        axis: options2.axis,
        movable: options2.movable,
        onEnd: function onEnd() {
          that._end();
        }
      })
    });
    that.tapCapture.bind("press", function() {
      that.cancel();
    });
    that.userEvents.bind("end", proxy(that.start, that));
    that.userEvents.bind("gestureend", proxy(that.start, that));
    that.userEvents.bind("tap", proxy(that.onEnd, that));
  }
  if (Animation2)
    DragInertia2.__proto__ = Animation2;
  DragInertia2.prototype = Object.create(Animation2 && Animation2.prototype);
  DragInertia2.prototype.constructor = DragInertia2;
  DragInertia2.prototype.onCancel = function onCancel() {
    this.transition.cancel();
  };
  DragInertia2.prototype.freeze = function freeze(location) {
    var that = this;
    that.cancel();
    that._moveTo(location);
  };
  DragInertia2.prototype.onEnd = function onEnd() {
    var that = this;
    if (that.paneAxis.outOfBounds()) {
      that._snapBack();
    } else {
      that._end();
    }
  };
  DragInertia2.prototype.done = function done() {
    return abs(this.velocity) < 1;
  };
  DragInertia2.prototype.start = function start(e3) {
    var that = this, velocity;
    if (!that.dimension.enabled) {
      return;
    }
    if (that.paneAxis.outOfBounds()) {
      if (that.transition._started) {
        that.transition.cancel();
        that.velocity = Math.min(e3.touch[that.axis].velocity * that.velocityMultiplier, MAX_VELOCITY);
        Animation2.prototype.start.call(this);
      } else {
        that._snapBack();
      }
    } else {
      velocity = e3.touch.id === MOUSE_WHEEL_ID ? 0 : e3.touch[that.axis].velocity;
      that.velocity = Math.max(Math.min(velocity * that.velocityMultiplier, MAX_VELOCITY), -MAX_VELOCITY);
      that.tapCapture.captureNext();
      Animation2.prototype.start.call(this);
    }
  };
  DragInertia2.prototype.tick = function tick() {
    var that = this, dimension = that.dimension, friction = that.paneAxis.outOfBounds() ? OUT_OF_BOUNDS_FRICTION : that.friction, delta = that.velocity *= friction, location = that.movable[that.axis] + delta;
    if (!that.elastic && dimension.outOfBounds(location)) {
      location = Math.max(Math.min(location, dimension.max), dimension.min);
      that.velocity = 0;
    }
    that.movable.moveAxis(that.axis, location);
  };
  DragInertia2.prototype._end = function _end() {
    this.tapCapture.cancelCapture();
    this.end();
  };
  DragInertia2.prototype._snapBack = function _snapBack() {
    var that = this, dimension = that.dimension, snapBack = that.movable[that.axis] > dimension.max ? dimension.max : dimension.min;
    that._moveTo(snapBack);
  };
  DragInertia2.prototype._moveTo = function _moveTo(location) {
    this.transition.moveTo({
      location,
      duration: SNAPBACK_DURATION,
      ease: Transition.easeOutExpo
    });
  };
  return DragInertia2;
}(Animation);
var AnimatedScroller = function(Animation2) {
  function AnimatedScroller2(options2) {
    Animation2.call(this, options2);
    var that = this;
    extend(that, options2, {
      origin: {},
      destination: {},
      offset: {}
    });
  }
  if (Animation2)
    AnimatedScroller2.__proto__ = Animation2;
  AnimatedScroller2.prototype = Object.create(Animation2 && Animation2.prototype);
  AnimatedScroller2.prototype.constructor = AnimatedScroller2;
  AnimatedScroller2.prototype.tick = function tick() {
    this._updateCoordinates();
    this.moveTo(this.origin);
  };
  AnimatedScroller2.prototype.done = function done() {
    return abs(this.offset.y) < ANIMATED_SCROLLER_PRECISION && abs(this.offset.x) < ANIMATED_SCROLLER_PRECISION;
  };
  AnimatedScroller2.prototype.onEnd = function onEnd() {
    this.moveTo(this.destination);
    if (this.callback) {
      this.callback.call();
    }
  };
  AnimatedScroller2.prototype.setCoordinates = function setCoordinates(from, to) {
    this.offset = {};
    this.origin = from;
    this.destination = to;
  };
  AnimatedScroller2.prototype.setCallback = function setCallback(callback) {
    if (callback && isFunction$1(callback)) {
      this.callback = callback;
    } else {
      callback = void 0;
    }
  };
  AnimatedScroller2.prototype._updateCoordinates = function _updateCoordinates() {
    this.offset = {
      x: (this.destination.x - this.origin.x) / 4,
      y: (this.destination.y - this.origin.y) / 4
    };
    this.origin = {
      y: this.origin.y + this.offset.y,
      x: this.origin.x + this.offset.x
    };
  };
  return AnimatedScroller2;
}(Animation);
var ScrollBar = function(Class3) {
  function ScrollBar2(options2) {
    Class3.call(this);
    var that = this, horizontal = options2.axis === "x";
    var orientation = horizontal ? "horizontal" : "vertical";
    var element = convertToHtml('<div class="km-touch-scrollbar km-' + orientation + '-scrollbar" />');
    extend(that, options2, {
      element,
      elementSize: 0,
      movable: new Movable(element),
      scrollMovable: options2.movable,
      alwaysVisible: options2.alwaysVisible,
      size: horizontal ? "width" : "height"
    });
    that.scrollMovable.bind(CHANGE, that.refresh.bind(that));
    that.container.appendChild(element);
    if (options2.alwaysVisible) {
      that.show();
    }
  }
  if (Class3)
    ScrollBar2.__proto__ = Class3;
  ScrollBar2.prototype = Object.create(Class3 && Class3.prototype);
  ScrollBar2.prototype.constructor = ScrollBar2;
  ScrollBar2.prototype.refresh = function refresh() {
    var that = this, axis = that.axis, dimension = that.dimension, paneSize = dimension.size, scrollMovable = that.scrollMovable, sizeRatio = paneSize / dimension.total, position2 = Math.round(-scrollMovable[axis] * sizeRatio), size = Math.round(paneSize * sizeRatio);
    if (sizeRatio >= 1) {
      this.element.style.display = "none";
    } else {
      this.element.style.display = "";
    }
    if (position2 + size > paneSize) {
      size = paneSize - position2;
    } else if (position2 < 0) {
      size += position2;
      position2 = 0;
    }
    if (that.elementSize !== size) {
      that.element.style[that.size] = size + "px";
      that.elementSize = size;
    }
    that.movable.moveAxis(axis, position2);
  };
  ScrollBar2.prototype.show = function show2() {
    this.element.style.opacity = SCROLLBAR_OPACITY;
    this.element.style.visibility = "visible";
  };
  ScrollBar2.prototype.hide = function hide2() {
    if (!this.alwaysVisible) {
      this.element.style.opacity = 0;
    }
  };
  return ScrollBar2;
}(Class$1);
var Scroller = function(Observable2) {
  function Scroller2(element, options2) {
    Observable2.call(this);
    var that = this;
    this.element = element;
    this._initOptions(options2);
    var hasScrolling = hasNativeScrolling();
    that._native = that.options.useNative && hasScrolling;
    var scrollHeader = convertToHtml('<div class="km-scroll-header"/>');
    if (that._native) {
      addClass2(element, "km-native-scroller");
      prepend(scrollHeader, element);
      extend(that, {
        scrollElement: element,
        fixedContainer: element.children[0]
      });
      return;
    }
    element.style.overflow = "hidden";
    addClass2(element, "km-scroll-wrapper");
    var scrollContainer = convertToHtml('<div class="km-scroll-container"/>');
    wrapInner(element, scrollContainer);
    prepend(scrollHeader, element);
    var inner = element.children[1], tapCapture = new TapCapture(element), movable = new Movable(inner), dimensions = new PaneDimensions({
      element: inner,
      container: element,
      forcedEnabled: that.options.zoom
    }), avoidScrolling2 = this.options.avoidScrolling, userEvents = new UserEvents(element, {
      touchAction: "none",
      allowSelection: true,
      preventDragEvent: true,
      captureUpIfMoved: true,
      multiTouch: that.options.zoom,
      supportDoubleTap: that.options.supportDoubleTap,
      start: function start(e3) {
        dimensions.refresh();
        var velocityX = abs(e3.x.velocity), velocityY = abs(e3.y.velocity), horizontalSwipe = velocityX * 2 >= velocityY, originatedFromFixedContainer = that.fixedContainer.contains(e3.event.target), verticalSwipe = velocityY * 2 >= velocityX;
        if (!originatedFromFixedContainer && !avoidScrolling2(e3) && that.enabled && (dimensions.x.enabled && horizontalSwipe || dimensions.y.enabled && verticalSwipe)) {
          userEvents.capture();
        } else {
          userEvents.cancel();
        }
      }
    }), pane = new Pane({
      movable,
      dimensions,
      userEvents,
      elastic: that.options.elastic
    }), zoomSnapBack = new ZoomSnapBack({
      movable,
      dimensions,
      userEvents,
      tapCapture
    }), animatedScroller = new AnimatedScroller({
      moveTo: function moveTo(coordinates) {
        that.scrollTo(coordinates.x, coordinates.y);
      }
    });
    movable.bind(CHANGE, function() {
      that.scrollTop = -movable.y;
      that.scrollLeft = -movable.x;
      that.trigger(SCROLL, {
        scrollTop: that.scrollTop,
        scrollLeft: that.scrollLeft
      });
    });
    if (that.options.mousewheelScrolling) {
      this._wheelScrollHandler = this._wheelScroll.bind(this);
      on(element, "wheel", this._wheelScrollHandler);
    }
    extend(that, {
      movable,
      dimensions,
      zoomSnapBack,
      animatedScroller,
      userEvents,
      pane,
      tapCapture,
      pulled: false,
      enabled: true,
      scrollElement: inner,
      scrollTop: 0,
      scrollLeft: 0,
      fixedContainer: element.children[0]
    });
    that._initAxis("x");
    that._initAxis("y");
    that._wheelEnd = function() {
      that._wheel = false;
      that.userEvents.end(0, that._wheelY);
    };
    dimensions.refresh();
    if (that.options.pullToRefresh) {
      that._initPullToRefresh();
    }
  }
  if (Observable2)
    Scroller2.__proto__ = Observable2;
  Scroller2.prototype = Object.create(Observable2 && Observable2.prototype);
  Scroller2.prototype.constructor = Scroller2;
  Scroller2.prototype._initOptions = function _initOptions(options2) {
    this.options = deepExtend({}, this.options, options2);
  };
  Scroller2.prototype._wheelScroll = function _wheelScroll(e3) {
    if (e3.ctrlKey) {
      return;
    }
    if (!this._wheel) {
      this._wheel = true;
      this._wheelY = 0;
      this.userEvents.press(0, this._wheelY);
    }
    clearTimeout(this._wheelTimeout);
    this._wheelTimeout = setTimeout(this._wheelEnd, 50);
    var delta = wheelDeltaY(e3);
    if (delta) {
      this._wheelY += delta;
      this.userEvents.move(0, this._wheelY);
    }
    e3.preventDefault();
  };
  Scroller2.prototype.makeVirtual = function makeVirtual() {
    this.dimensions.y.makeVirtual();
  };
  Scroller2.prototype.virtualSize = function virtualSize(min2, max2) {
    this.dimensions.y.virtualSize(min2, max2);
  };
  Scroller2.prototype.height = function height() {
    return this.dimensions.y.size;
  };
  Scroller2.prototype.scrollHeight = function scrollHeight() {
    return this.scrollElement.scrollHeight;
  };
  Scroller2.prototype.scrollWidth = function scrollWidth() {
    return this.scrollElement.scrollWidth;
  };
  Scroller2.prototype._resize = function _resize() {
    if (!this._native) {
      this.contentResized();
    }
  };
  Scroller2.prototype.setOptions = function setOptions(options2) {
    var that = this;
    this._initOptions(options2);
    if (options2.pullToRefresh) {
      that._initPullToRefresh();
    }
  };
  Scroller2.prototype.reset = function reset() {
    if (this._native) {
      this.scrollElement.scrollTop(0);
    } else {
      this.movable.moveTo({
        x: 0,
        y: 0
      });
      this._scale(1);
    }
  };
  Scroller2.prototype.contentResized = function contentResized() {
    this.dimensions.refresh();
    if (this.pane.x.outOfBounds()) {
      this.movable.moveAxis("x", this.dimensions.x.min);
    }
    if (this.pane.y.outOfBounds()) {
      this.movable.moveAxis("y", this.dimensions.y.min);
    }
  };
  Scroller2.prototype.zoomOut = function zoomOut() {
    var dimensions = this.dimensions;
    dimensions.refresh();
    this._scale(dimensions.fitScale);
    this.movable.moveTo(dimensions.centerCoordinates());
  };
  Scroller2.prototype.enable = function enable() {
    this.enabled = true;
  };
  Scroller2.prototype.disable = function disable() {
    this.enabled = false;
  };
  Scroller2.prototype.scrollTo = function scrollTo(x3, y4) {
    if (this._native) {
      this.scrollElement.scrollLeft(abs(x3));
      this.scrollElement.scrollTop(abs(y4));
    } else {
      this.dimensions.refresh();
      this.movable.moveTo({
        x: x3,
        y: y4
      });
    }
  };
  Scroller2.prototype.animatedScrollTo = function animatedScrollTo(x3, y4, callback) {
    var from, to;
    if (this._native) {
      this.scrollTo(x3, y4);
    } else {
      from = {
        x: this.movable.x,
        y: this.movable.y
      };
      to = {
        x: x3,
        y: y4
      };
      this.animatedScroller.setCoordinates(from, to);
      this.animatedScroller.setCallback(callback);
      this.animatedScroller.start();
    }
  };
  Scroller2.prototype.pullHandled = function pullHandled() {
  };
  Scroller2.prototype.destroy = function destroy2() {
    var element = this.element;
    off(element, "wheel", this._wheelScrollHandler);
    if (this.userEvents) {
      this.userEvents.destroy();
    }
  };
  Scroller2.prototype._scale = function _scale(scale) {
    this.dimensions.rescale(scale);
    this.movable.scaleTo(scale);
  };
  Scroller2.prototype._initPullToRefresh = function _initPullToRefresh() {
  };
  Scroller2.prototype._dragEnd = function _dragEnd() {
  };
  Scroller2.prototype._paneChange = function _paneChange() {
  };
  Scroller2.prototype._initAxis = function _initAxis(axis) {
    var that = this, movable = that.movable, dimension = that.dimensions[axis], tapCapture = that.tapCapture, paneAxis = that.pane[axis], scrollBar = new ScrollBar({
      axis,
      movable,
      dimension,
      container: that.element,
      alwaysVisible: that.options.visibleScrollHints
    });
    dimension.bind(CHANGE, function() {
      scrollBar.refresh();
    });
    paneAxis.bind(CHANGE, function() {
      scrollBar.show();
    });
    that[axis + "inertia"] = new DragInertia({
      axis,
      paneAxis,
      movable,
      tapCapture,
      userEvents: that.userEvents,
      dimension,
      elastic: that.options.elastic,
      friction: that.options.friction || FRICTION$1,
      velocityMultiplier: that.options.velocityMultiplier || VELOCITY_MULTIPLIER$1,
      end: function end() {
        scrollBar.hide();
        that.trigger("scrollEnd", {
          axis,
          scrollTop: that.scrollTop,
          scrollLeft: that.scrollLeft
        });
      }
    });
  };
  return Scroller2;
}(Observable);
setDefaultOptions(Scroller, {
  name: "Scroller",
  zoom: false,
  pullOffset: 140,
  visibleScrollHints: false,
  elastic: true,
  useNative: false,
  mousewheelScrolling: true,
  avoidScrolling: function avoidScrolling() {
    return false;
  },
  pullToRefresh: false,
  messages: {
    pullTemplate: "Pull to refresh",
    releaseTemplate: "Release to refresh",
    refreshTemplate: "Refreshing"
  }
});
setDefaultEvents(Scroller, [
  PULL,
  SCROLL,
  RESIZE
]);
var MapService = function MapService2(widget, context2) {
  if (context2 === void 0)
    context2 = {};
  this.sender = context2.sender || widget;
  this.widget = widget;
  this.rtl = Boolean(context2.rtl);
};
MapService.prototype.notify = function notify2(name2, args) {
  if (this.widget) {
    this.widget.trigger(name2, args);
  }
};
var math = Math, min$1 = math.min, pow = math.pow, Point = Point$7, MARKER = "marker", LOCATION = "location", FRICTION = 0.9, FRICTION_MOBILE = 0.93, MOUSEWHEEL = "wheel", MOUSEWHEEL_THROTTLE = 50, VELOCITY_MULTIPLIER = 5, DEFAULT_ZOOM_RATE = 1;
var layersMap = {
  bubble: BubbleLayer,
  shape: ShapeLayer,
  tile: TileLayer
};
layersMap[MARKER] = MarkerLayer;
var Map$1 = function(Observable2) {
  function Map2(element, options2, themeOptions, context2) {
    if (options2 === void 0)
      options2 = {};
    if (themeOptions === void 0)
      themeOptions = {};
    if (context2 === void 0)
      context2 = {};
    Observable2.call(this);
    this._init(element, options2, themeOptions, context2);
  }
  if (Observable2)
    Map2.__proto__ = Observable2;
  Map2.prototype = Object.create(Observable2 && Observable2.prototype);
  Map2.prototype.constructor = Map2;
  Map2.prototype.destroy = function destroy2() {
    var this$1$1 = this;
    this.scroller.destroy();
    if (this._tooltip) {
      this._tooltip.destroy();
    }
    if (this.navigator) {
      this.navigator.destroy();
    }
    if (this.attribution) {
      this.attribution.destroy();
    }
    if (this.zoomControl) {
      this.zoomControl.destroy();
    }
    if (isArray$1(this.markers)) {
      this.markers.forEach(function(markerLayer) {
        markerLayer.destroy();
      });
    } else {
      this.markers.destroy();
    }
    for (var i16 = 0; i16 < this.layers.length; i16++) {
      this$1$1.layers[i16].destroy();
    }
    off(this.element, MOUSEWHEEL, this._mousewheelHandler);
    Observable2.prototype.destroy.call(this);
  };
  Map2.prototype._init = function _init(element, options2, themeOptions, context2) {
    if (options2 === void 0)
      options2 = {};
    if (context2 === void 0)
      context2 = {};
    this.support = getSupportedFeatures();
    this.context = context2;
    this.initObserver(context2);
    this.initServices(context2);
    this._notifyObserver(INIT);
    this._initOptions(options2);
    this._setEvents(options2);
    this.crs = new EPSG3857();
    this._initElement(element);
    this._viewOrigin = this._getOrigin();
    this._tooltip = this._createTooltip();
    this._initScroller();
    this._initMarkers();
    this._initControls();
    this._initLayers();
    this._reset();
    var mousewheelThrottled = throttle(this._mousewheel.bind(this), MOUSEWHEEL_THROTTLE);
    this._mousewheelHandler = function(e3) {
      e3.preventDefault();
      mousewheelThrottled(e3);
    };
    on(this.element, MOUSEWHEEL, this._mousewheelHandler);
  };
  Map2.prototype._initOptions = function _initOptions(options2) {
    this.options = deepExtend({}, this.options, options2);
  };
  Map2.prototype._initElement = function _initElement(element) {
    this.element = element;
    addClass2(element, "k-map");
    element.style.position = "relative";
    element.setAttribute("data-role", "map");
    removeChildren(element);
    var div = convertToHtml("<div />");
    this.element.appendChild(div);
  };
  Map2.prototype.initServices = function initServices(context2) {
    if (context2 === void 0)
      context2 = {};
    this.widgetService = new MapService(this, context2);
  };
  Map2.prototype.initObserver = function initObserver(context2) {
    if (context2 === void 0)
      context2 = {};
    this.observers = [];
    this.addObserver(context2.observer);
  };
  Map2.prototype.addObserver = function addObserver(observer) {
    if (observer) {
      this.observers.push(observer);
    }
  };
  Map2.prototype.removeObserver = function removeObserver(observer) {
    var index2 = this.observers.indexOf(observer);
    if (index2 >= 0) {
      this.observers.splice(index2, 1);
    }
  };
  Map2.prototype.requiresHandlers = function requiresHandlers2(eventNames) {
    var observers2 = this.observers;
    for (var idx = 0; idx < observers2.length; idx++) {
      if (observers2[idx].requiresHandlers(eventNames)) {
        return true;
      }
    }
  };
  Map2.prototype.trigger = function trigger2(name2, args) {
    if (args === void 0)
      args = {};
    args.sender = this;
    var observers2 = this.observers;
    var isDefaultPrevented2 = false;
    for (var idx = 0; idx < observers2.length; idx++) {
      if (observers2[idx].trigger(name2, args)) {
        isDefaultPrevented2 = true;
      }
    }
    if (!isDefaultPrevented2) {
      Observable2.prototype.trigger.call(this, name2, args);
    }
    return isDefaultPrevented2;
  };
  Map2.prototype._notifyObserver = function _notifyObserver(name2, args) {
    if (args === void 0)
      args = {};
    args.sender = this;
    var observers2 = this.observers;
    var isDefaultPrevented2 = false;
    for (var idx = 0; idx < observers2.length; idx++) {
      if (observers2[idx].trigger(name2, args)) {
        isDefaultPrevented2 = true;
      }
    }
    return isDefaultPrevented2;
  };
  Map2.prototype.zoom = function zoom(level) {
    var options2 = this.options;
    var result;
    if (defined(level)) {
      var zoomLevel2 = math.round(limitValue(level, options2.minZoom, options2.maxZoom));
      if (options2.zoom !== zoomLevel2) {
        options2.zoom = zoomLevel2;
        this.widgetService.notify(ZOOM_CHANGE, { zoom: options2.zoom });
        this._reset();
      }
      result = this;
    } else {
      result = options2.zoom;
    }
    return result;
  };
  Map2.prototype.center = function center(center$1) {
    var result;
    if (center$1) {
      var current2 = Location.create(center$1);
      var previous = Location.create(this.options.center);
      if (!current2.equals(previous)) {
        this.options.center = current2.toArray();
        this.widgetService.notify(CENTER_CHANGE, { center: this.options.center });
        this._reset();
      }
      result = this;
    } else {
      result = Location.create(this.options.center);
    }
    return result;
  };
  Map2.prototype.extent = function extent(extent$1) {
    var result;
    if (extent$1) {
      this._setExtent(extent$1);
      result = this;
    } else {
      result = this._getExtent();
    }
    return result;
  };
  Map2.prototype.setOptions = function setOptions(options2) {
    if (options2 === void 0)
      options2 = {};
    var element = this.element;
    this.destroy();
    removeChildren(element);
    this._init(element, options2, {}, this.context);
    this._reset();
  };
  Map2.prototype.locationToLayer = function locationToLayer(location, zoom) {
    var clamp2 = !this.options.wraparound;
    var locationObject = Location.create(location);
    return this.crs.toPoint(locationObject, this._layerSize(zoom), clamp2);
  };
  Map2.prototype.layerToLocation = function layerToLocation(point2, zoom) {
    var clamp2 = !this.options.wraparound;
    var pointObject = Point.create(point2);
    return this.crs.toLocation(pointObject, this._layerSize(zoom), clamp2);
  };
  Map2.prototype.locationToView = function locationToView(location) {
    var locationObject = Location.create(location);
    var origin = this.locationToLayer(this._viewOrigin);
    var point2 = this.locationToLayer(locationObject);
    return point2.translateWith(origin.scale(-1));
  };
  Map2.prototype.viewToLocation = function viewToLocation(point2, zoom) {
    var origin = this.locationToLayer(this._getOrigin(), zoom);
    var pointObject = Point.create(point2);
    var pointResult = pointObject.clone().translateWith(origin);
    return this.layerToLocation(pointResult, zoom);
  };
  Map2.prototype.eventOffset = function eventOffset(e3) {
    var x3;
    var y4;
    var offset2 = elementOffset(this.element);
    if (e3.x && e3.x[LOCATION] || e3.y && e3.y[LOCATION]) {
      x3 = e3.x[LOCATION] - offset2.left;
      y4 = e3.y[LOCATION] - offset2.top;
    } else {
      var event = e3.originalEvent || e3;
      x3 = valueOrDefault$1(event.pageX, event.clientX) - offset2.left;
      y4 = valueOrDefault$1(event.pageY, event.clientY) - offset2.top;
    }
    var point2 = new Point$7(x3, y4);
    return point2;
  };
  Map2.prototype.eventToView = function eventToView(e3) {
    var cursor = this.eventOffset(e3);
    return this.locationToView(this.viewToLocation(cursor));
  };
  Map2.prototype.eventToLayer = function eventToLayer(e3) {
    return this.locationToLayer(this.eventToLocation(e3));
  };
  Map2.prototype.eventToLocation = function eventToLocation(e3) {
    var cursor = this.eventOffset(e3);
    return this.viewToLocation(cursor);
  };
  Map2.prototype.viewSize = function viewSize() {
    var element = this.element;
    var scale = this._layerSize();
    var width = element.clientWidth;
    if (!this.options.wraparound) {
      width = min$1(scale, width);
    }
    return {
      width,
      height: min$1(scale, element.clientHeight)
    };
  };
  Map2.prototype.exportVisual = function exportVisual() {
    this._reset();
    return false;
  };
  Map2.prototype.hideTooltip = function hideTooltip() {
    if (this._tooltip) {
      this._tooltip.hide();
    }
  };
  Map2.prototype._setOrigin = function _setOrigin(origin, zoom) {
    var size = this.viewSize(), topLeft;
    var originLocation = this._origin = Location.create(origin);
    topLeft = this.locationToLayer(originLocation, zoom);
    topLeft.x += size.width / 2;
    topLeft.y += size.height / 2;
    this.options.center = this.layerToLocation(topLeft, zoom).toArray();
    this.widgetService.notify(CENTER_CHANGE, { center: this.options.center });
    return this;
  };
  Map2.prototype._getOrigin = function _getOrigin(invalidate) {
    var size = this.viewSize(), topLeft;
    if (invalidate || !this._origin) {
      topLeft = this.locationToLayer(this.center());
      topLeft.x -= size.width / 2;
      topLeft.y -= size.height / 2;
      this._origin = this.layerToLocation(topLeft);
    }
    return this._origin;
  };
  Map2.prototype._setExtent = function _setExtent(newExtent) {
    var this$1$1 = this;
    var raw = Extent.create(newExtent);
    var se2 = raw.se.clone();
    if (this.options.wraparound && se2.lng < 0 && newExtent.nw.lng > 0) {
      se2.lng = 180 + (180 + se2.lng);
    }
    var extent = new Extent(raw.nw, se2);
    this.center(extent.center());
    var width = this.element.clientWidth;
    var height = this.element.clientHeight;
    var zoom;
    for (zoom = this.options.maxZoom; zoom >= this.options.minZoom; zoom--) {
      var topLeft = this$1$1.locationToLayer(extent.nw, zoom);
      var bottomRight = this$1$1.locationToLayer(extent.se, zoom);
      var layerWidth = math.abs(bottomRight.x - topLeft.x);
      var layerHeight = math.abs(bottomRight.y - topLeft.y);
      if (layerWidth <= width && layerHeight <= height) {
        break;
      }
    }
    this.zoom(zoom);
  };
  Map2.prototype._getExtent = function _getExtent() {
    var nw = this._getOrigin();
    var bottomRight = this.locationToLayer(nw);
    var size = this.viewSize();
    bottomRight.x += size.width;
    bottomRight.y += size.height;
    var se2 = this.layerToLocation(bottomRight);
    return new Extent(nw, se2);
  };
  Map2.prototype._zoomAround = function _zoomAround(pivot, level) {
    this._setOrigin(this.layerToLocation(pivot, level), level);
    this.zoom(level);
  };
  Map2.prototype._initControls = function _initControls() {
    var controls = this.options.controls;
    if (controls.attribution) {
      this._createAttribution(controls.attribution);
    }
    if (!this.support.mobileOS) {
      if (controls.navigator) {
        this._createNavigator(controls.navigator);
      }
      if (controls.zoom) {
        this._createZoomControl(controls.zoom);
      }
    }
  };
  Map2.prototype._createControlElement = function _createControlElement(options2, defaultPosition) {
    var pos = options2.position || defaultPosition;
    var posSelector = "." + renderPos(pos).replace(" ", ".");
    var wrap = this.element.querySelector(".k-map-controls" + posSelector) || [];
    if (wrap.length === 0) {
      var div$1 = document.createElement("div");
      addClass2(div$1, "k-map-controls " + renderPos(pos));
      wrap = div$1;
      this.element.appendChild(wrap);
    }
    var div = document.createElement("div");
    wrap.appendChild(div);
    return div;
  };
  Map2.prototype._createAttribution = function _createAttribution(options2) {
    var element = this._createControlElement(options2, "bottomRight");
    this.attribution = new Attribution(element, options2);
  };
  Map2.prototype._createNavigator = function _createNavigator(options2) {
    var element = this._createControlElement(options2, "topLeft");
    var navigator2 = this.navigator = new Navigator(element, deepExtend({}, options2, { icons: this.options.icons }));
    this._navigatorPan = this._navigatorPan.bind(this);
    navigator2.bind("pan", this._navigatorPan);
    this._navigatorCenter = this._navigatorCenter.bind(this);
    navigator2.bind("center", this._navigatorCenter);
  };
  Map2.prototype._navigatorPan = function _navigatorPan(e3) {
    var scroller = this.scroller;
    var x3 = scroller.scrollLeft + e3.x;
    var y4 = scroller.scrollTop - e3.y;
    var bounds = this._virtualSize;
    var width = this.element.clientWidth;
    var height = this.element.clientHeight;
    x3 = limitValue(x3, bounds.x.min, bounds.x.max - width);
    y4 = limitValue(y4, bounds.y.min, bounds.y.max - height);
    this.scroller.one("scroll", proxy(this._scrollEnd, this));
    this.scroller.scrollTo(-x3, -y4);
  };
  Map2.prototype._navigatorCenter = function _navigatorCenter() {
    this.center(this.options.center);
  };
  Map2.prototype._createZoomControl = function _createZoomControl(options2) {
    var element = this._createControlElement(options2, "topLeft");
    var zoomControl = this.zoomControl = new ZoomControl(element, options2, this.options.icons);
    this._zoomControlChange = this._zoomControlChange.bind(this);
    zoomControl.bind("change", this._zoomControlChange);
  };
  Map2.prototype._zoomControlChange = function _zoomControlChange(e3) {
    if (!this.trigger("zoomStart", { originalEvent: e3 })) {
      this.zoom(this.zoom() + e3.delta);
      this.trigger("zoomEnd", {
        originalEvent: e3
      });
    }
  };
  Map2.prototype._initScroller = function _initScroller() {
    var friction = this.support.mobileOS ? FRICTION_MOBILE : FRICTION;
    var zoomable = this.options.zoomable !== false;
    var scroller = this.scroller = new Scroller(this.element.children[0], {
      friction,
      velocityMultiplier: VELOCITY_MULTIPLIER,
      zoom: zoomable,
      mousewheelScrolling: false,
      supportDoubleTap: true
    });
    scroller.bind("scroll", proxy(this._scroll, this));
    scroller.bind("scrollEnd", proxy(this._scrollEnd, this));
    scroller.userEvents.bind("gesturestart", proxy(this._scaleStart, this));
    scroller.userEvents.bind("gestureend", proxy(this._scale, this));
    scroller.userEvents.bind("doubleTap", proxy(this._doubleTap, this));
    scroller.userEvents.bind("tap", proxy(this._tap, this));
    this.scrollElement = scroller.scrollElement;
  };
  Map2.prototype._initLayers = function _initLayers() {
    var this$1$1 = this;
    var defs = this.options.layers, layers = this.layers = [];
    for (var i16 = 0; i16 < defs.length; i16++) {
      var options2 = defs[i16];
      var layer = this$1$1._createLayer(options2);
      layers.push(layer);
    }
  };
  Map2.prototype._createLayer = function _createLayer(options2) {
    var type = options2.type || "shape";
    var layerDefaults = this.options.layerDefaults[type];
    var layerOptions = type === MARKER ? deepExtend({}, this.options.markerDefaults, options2, { icons: this.options.icons }) : deepExtend({}, layerDefaults, options2);
    var layerConstructor = layersMap[type];
    var layer = new layerConstructor(this, layerOptions);
    if (type === MARKER) {
      this.markers = layer;
    }
    return layer;
  };
  Map2.prototype._createTooltip = function _createTooltip() {
    return new Tooltip(this.widgetService, this.options.tooltip);
  };
  Map2.prototype._initMarkers = function _initMarkers() {
    var markerLayers = (this.options.layers || []).filter(function(x3) {
      return x3 && x3.type === MARKER;
    });
    if (markerLayers.length > 0) {
      return;
    }
    this.markers = new MarkerLayer(this, deepExtend({}, this.options.markerDefaults, { icons: this.options.icons }));
    this.markers.add(this.options.markers);
  };
  Map2.prototype._scroll = function _scroll(e3) {
    var origin = this.locationToLayer(this._viewOrigin).round();
    var movable = e3.sender.movable;
    var offset2 = new Point$7(movable.x, movable.y).scale(-1).scale(1 / movable.scale);
    origin.x += offset2.x;
    origin.y += offset2.y;
    this._scrollOffset = offset2;
    this._tooltip.offset = offset2;
    this.hideTooltip();
    this._setOrigin(this.layerToLocation(origin));
    this.trigger("pan", {
      originalEvent: e3,
      origin: this._getOrigin(),
      center: this.center()
    });
  };
  Map2.prototype._scrollEnd = function _scrollEnd(e3) {
    if (!this._scrollOffset || !this._panComplete()) {
      return;
    }
    this._scrollOffset = null;
    this._panEndTimestamp = now();
    this.trigger("panEnd", {
      originalEvent: e3,
      origin: this._getOrigin(),
      center: this.center()
    });
  };
  Map2.prototype._panComplete = function _panComplete() {
    return now() - (this._panEndTimestamp || 0) > 50;
  };
  Map2.prototype._scaleStart = function _scaleStart(e3) {
    if (this.trigger("zoomStart", { originalEvent: e3 })) {
      var touch = e3.touches[1];
      if (touch) {
        touch.cancel();
      }
    }
  };
  Map2.prototype._scale = function _scale(e3) {
    var scale = this.scroller.movable.scale;
    var zoom = this._scaleToZoom(scale);
    var gestureCenter = new Point$7(e3.center.x, e3.center.y);
    var centerLocation = this.viewToLocation(gestureCenter, zoom);
    var centerPoint = this.locationToLayer(centerLocation, zoom);
    var originPoint = centerPoint.translate(-gestureCenter.x, -gestureCenter.y);
    this._zoomAround(originPoint, zoom);
    this.trigger("zoomEnd", {
      originalEvent: e3
    });
  };
  Map2.prototype._scaleToZoom = function _scaleToZoom(scaleDelta) {
    var scale = this._layerSize() * scaleDelta;
    var tiles = scale / this.options.minSize;
    var zoom = math.log(tiles) / math.log(2);
    return math.round(zoom);
  };
  Map2.prototype._reset = function _reset() {
    if (this.attribution) {
      this.attribution.filter(this.center(), this.zoom());
    }
    this._viewOrigin = this._getOrigin(true);
    this._resetScroller();
    this.hideTooltip();
    this.trigger("beforeReset");
    this.trigger("reset");
  };
  Map2.prototype._resetScroller = function _resetScroller() {
    var scroller = this.scroller;
    var x3 = scroller.dimensions.x;
    var y4 = scroller.dimensions.y;
    var scale = this._layerSize();
    var nw = this.extent().nw;
    var topLeft = this.locationToLayer(nw).round();
    scroller.movable.round = true;
    scroller.reset();
    scroller.userEvents.cancel();
    var zoom = this.zoom();
    scroller.dimensions.forcedMinScale = pow(2, this.options.minZoom - zoom);
    scroller.dimensions.maxScale = pow(2, this.options.maxZoom - zoom);
    var xBounds = {
      min: -topLeft.x,
      max: scale - topLeft.x
    };
    var yBounds = {
      min: -topLeft.y,
      max: scale - topLeft.y
    };
    if (this.options.wraparound) {
      xBounds.max = 20 * scale;
      xBounds.min = -xBounds.max;
    }
    if (this.options.pannable === false) {
      var viewSize = this.viewSize();
      xBounds.min = yBounds.min = 0;
      xBounds.max = viewSize.width;
      yBounds.max = viewSize.height;
    }
    x3.makeVirtual();
    y4.makeVirtual();
    x3.virtualSize(xBounds.min, xBounds.max);
    y4.virtualSize(yBounds.min, yBounds.max);
    this._virtualSize = {
      x: xBounds,
      y: yBounds
    };
  };
  Map2.prototype._renderLayers = function _renderLayers() {
  };
  Map2.prototype._layerSize = function _layerSize(zoom) {
    var newZoom = valueOrDefault$1(zoom, this.options.zoom);
    return this.options.minSize * pow(2, newZoom);
  };
  Map2.prototype._tap = function _tap(e3) {
    if (!this._panComplete()) {
      return;
    }
    var cursor = this.eventOffset(e3);
    this.hideTooltip();
    this.trigger("click", {
      originalEvent: e3,
      location: this.viewToLocation(cursor)
    });
  };
  Map2.prototype._doubleTap = function _doubleTap(e3) {
    var options2 = this.options;
    if (options2.zoomable !== false) {
      if (!this.trigger("zoomStart", { originalEvent: e3 })) {
        var toZoom = this.zoom() + DEFAULT_ZOOM_RATE;
        var cursor = this.eventOffset(e3);
        var location = this.viewToLocation(cursor);
        var postZoom = this.locationToLayer(location, toZoom);
        var origin = postZoom.translate(-cursor.x, -cursor.y);
        this._zoomAround(origin, toZoom);
        this.trigger("zoomEnd", {
          originalEvent: e3
        });
      }
    }
  };
  Map2.prototype._mousewheel = function _mousewheel(e3) {
    var delta = mousewheelDelta(e3) > 0 ? -1 : 1;
    var options2 = this.options;
    var fromZoom = this.zoom();
    var toZoom = limitValue(fromZoom + delta, options2.minZoom, options2.maxZoom);
    if (options2.zoomable !== false && toZoom !== fromZoom) {
      if (!this.trigger("zoomStart", { originalEvent: e3 })) {
        var cursor = this.eventOffset(e3);
        var location = this.viewToLocation(cursor);
        var postZoom = this.locationToLayer(location, toZoom);
        var origin = postZoom.translate(-cursor.x, -cursor.y);
        this._zoomAround(origin, toZoom);
        this.trigger("zoomEnd", {
          originalEvent: e3
        });
      }
    }
  };
  Map2.prototype._toDocumentCoordinates = function _toDocumentCoordinates(point2) {
    var offset2 = elementOffset(this.element);
    return {
      left: round$1(point2.x + offset2.left),
      top: round$1(point2.y + offset2.top)
    };
  };
  return Map2;
}(Observable);
setDefaultOptions(Map$1, {
  name: "Map",
  controls: {
    attribution: true,
    navigator: {
      panStep: 100
    },
    zoom: true
  },
  layers: [],
  layerDefaults: {
    shape: {
      style: {
        fill: {
          color: "#fff"
        },
        stroke: {
          color: "#aaa",
          width: 0.5
        }
      }
    },
    bubble: {
      style: {
        fill: {
          color: "#fff",
          opacity: 0.5
        },
        stroke: {
          color: "#aaa",
          width: 0.5
        }
      }
    },
    marker: {
      shape: "pinTarget",
      tooltip: {
        position: "top"
      }
    }
  },
  center: [
    0,
    0
  ],
  icons: {
    type: "font",
    svgIcons: {}
  },
  zoom: 3,
  minSize: 256,
  minZoom: 1,
  maxZoom: 19,
  markers: [],
  markerDefaults: {
    shape: "pinTarget",
    tooltip: {
      position: "top"
    }
  },
  wraparound: true,
  // If set to true, GeoJSON layer "Point" features will be rendered as markers.
  // Otherwise, the points will be rendered as circles.
  // Defaults to `true` for KUI/jQuery, `false` everywhere else.
  renderPointsAsMarkers: false
});
setDefaultEvents(Map$1, [
  "beforeReset",
  "click",
  "markerActivate",
  "markerClick",
  "markerCreated",
  // Events for implementing custom tooltips.
  "markerMouseEnter",
  "markerMouseLeave",
  "pan",
  "panEnd",
  "reset",
  "shapeClick",
  "shapeCreated",
  "shapeFeatureCreated",
  "shapeMouseEnter",
  "shapeMouseLeave",
  "zoomEnd",
  "zoomStart"
]);
var max = function(array, mapFn) {
  return Math.max.apply(null, array.map(mapFn));
};
var min = function(array, mapFn) {
  return Math.min.apply(null, array.map(mapFn));
};
var sum = function(array, mapFn) {
  return array.map(mapFn).reduce(function(acc, curr) {
    return acc + curr;
  }, 0);
};
var sortAsc = function(a9, b2) {
  return a9.y0 === b2.y0 ? a9.index - b2.index : a9.y0 + a9.y1 - b2.y0 - b2.y1;
};
var sortSource = function(a9, b2) {
  return sortAsc(a9.source, b2.source);
};
var sortTarget = function(a9, b2) {
  return sortAsc(a9.target, b2.target);
};
var value = function(node) {
  return node.value;
};
function sortLinks(nodes) {
  nodes.forEach(function(node) {
    node.targetLinks.forEach(function(link) {
      link.source.sourceLinks.sort(sortTarget);
    });
    node.sourceLinks.forEach(function(link) {
      link.target.targetLinks.sort(sortSource);
    });
  });
}
var calcLayer = function(node, maxDepth) {
  if (node.align === "left") {
    return node.depth;
  }
  if (node.align === "right") {
    return maxDepth - node.height;
  }
  return node.sourceLinks.length ? node.depth : maxDepth;
};
var Sankey$1 = function Sankey(options2) {
  var ref2 = options2.nodesOptions;
  var offset2 = ref2.offset;
  if (offset2 === void 0)
    offset2 = {};
  var align2 = ref2.align;
  this.data = {
    nodes: options2.nodes.map(function(node) {
      return deepExtend({}, { offset: offset2, align: align2 }, node);
    }),
    links: options2.links.map(function(link) {
      return deepExtend({}, link);
    })
  };
  this.width = options2.width;
  this.height = options2.height;
  this.offsetX = options2.offsetX || 0;
  this.offsetY = options2.offsetY || 0;
  this.nodeWidth = options2.nodesOptions.width;
  this.nodePadding = options2.nodesOptions.padding;
  this.reverse = options2.reverse;
  this.targetColumnIndex = options2.targetColumnIndex;
  this.loops = options2.loops;
  this.autoLayout = options2.autoLayout;
};
Sankey$1.prototype.calculate = function calculate() {
  var ref2 = this.data;
  var nodes = ref2.nodes;
  var links = ref2.links;
  this.connectLinksToNodes(nodes, links);
  this.calculateNodeValues(nodes);
  var circularLinks = this.calculateNodeHeights(nodes);
  if (circularLinks) {
    return { nodes: [], links: [], columns: [], circularLinks };
  }
  this.calculateNodeDepths(nodes);
  var columns = this.calculateNodeColumns(nodes);
  this.calculateNodeBreadths(columns);
  this.applyNodesOffset(nodes);
  this.calculateLinkBreadths(nodes);
  return Object.assign({}, this.data, { columns });
};
Sankey$1.prototype.connectLinksToNodes = function connectLinksToNodes(nodes, links) {
  var nodesMap = /* @__PURE__ */ new Map();
  nodes.forEach(function(node, i16) {
    node.index = i16;
    node.sourceLinks = [];
    node.targetLinks = [];
    node.id = node.id !== void 0 ? node.id : node.label.text;
    nodesMap.set(node.id, node);
  });
  links.forEach(function(link) {
    link.source = nodesMap.get(link.sourceId);
    link.target = nodesMap.get(link.targetId);
    link.source.sourceLinks.push(link);
    link.target.targetLinks.push(link);
  });
};
Sankey$1.prototype.calculateNodeValues = function calculateNodeValues(nodes) {
  nodes.forEach(function(node) {
    node.value = Math.max(
      sum(node.sourceLinks, value),
      sum(node.targetLinks, value)
    );
  });
};
Sankey$1.prototype.calculateNodeDepths = function calculateNodeDepths(nodes) {
  var current2 = new Set(nodes);
  var next = /* @__PURE__ */ new Set();
  var currDepth = 0;
  while (current2.size) {
    var currentNodes = Array.from(current2);
    for (var n10 = 0; n10 < currentNodes.length; n10++) {
      var node = currentNodes[n10];
      node.depth = currDepth;
      for (var l7 = 0; l7 < node.sourceLinks.length; l7++) {
        var link = node.sourceLinks[l7];
        next.add(link.target);
      }
    }
    currDepth++;
    current2 = next;
    next = /* @__PURE__ */ new Set();
  }
};
Sankey$1.prototype.calculateNodeHeights = function calculateNodeHeights(nodes) {
  var nodesLength = nodes.length;
  var current2 = new Set(nodes);
  var next = /* @__PURE__ */ new Set();
  var currentHeight = 0;
  var eachNode = function(node) {
    node.height = currentHeight;
    node.targetLinks.forEach(function(link) {
      next.add(link.source);
    });
  };
  while (current2.size) {
    current2.forEach(eachNode);
    currentHeight++;
    if (currentHeight > nodesLength) {
      return true;
    }
    current2 = next;
    next = /* @__PURE__ */ new Set();
  }
  return false;
};
Sankey$1.prototype.calculateNodeColumns = function calculateNodeColumns(nodes) {
  var this$1$1 = this;
  var maxDepth = max(nodes, function(d8) {
    return d8.depth;
  });
  var columnWidth = (this.width - this.offsetX - this.nodeWidth) / maxDepth;
  var columns = new Array(maxDepth + 1);
  for (var i16 = 0; i16 < nodes.length; i16++) {
    var node = nodes[i16];
    var layer = Math.max(0, Math.min(maxDepth, calcLayer(node, maxDepth)));
    node.x0 = this$1$1.offsetX + layer * columnWidth;
    node.x1 = node.x0 + this$1$1.nodeWidth;
    node.layer = layer;
    columns[layer] = columns[layer] || [];
    columns[layer].push(node);
  }
  return columns;
};
Sankey$1.prototype.calculateNodeBreadths = function calculateNodeBreadths(columns) {
  var this$1$1 = this;
  var kSize = min(columns, function(c6) {
    return (this$1$1.height - this$1$1.offsetY - (c6.length - 1) * this$1$1.nodePadding) / sum(c6, value);
  });
  columns.forEach(function(nodes) {
    var y4 = this$1$1.offsetY;
    nodes.forEach(function(node) {
      node.y0 = y4;
      node.y1 = y4 + node.value * kSize;
      y4 = node.y1 + this$1$1.nodePadding;
      node.sourceLinks.forEach(function(link) {
        link.width = link.value * kSize;
      });
    });
    y4 = (this$1$1.height - y4 + this$1$1.nodePadding) / (nodes.length + 1);
    nodes.forEach(function(node, i17) {
      node.y0 += y4 * (i17 + 1);
      node.y1 += y4 * (i17 + 1);
    });
  });
  if (this.autoLayout !== false) {
    var loops = this.loops !== void 0 ? this.loops : columns.length - 1;
    var targetColumnIndex = this.targetColumnIndex || 1;
    for (var i16 = 0; i16 < loops; i16++) {
      if (!this$1$1.reverse) {
        this$1$1.uncurlLinksToLeft(columns, targetColumnIndex);
        this$1$1.uncurlLinksToRight(columns, targetColumnIndex);
      } else {
        this$1$1.uncurlLinksToRight(columns, targetColumnIndex);
        this$1$1.uncurlLinksToLeft(columns, targetColumnIndex);
      }
    }
  }
  columns.forEach(sortLinks);
};
Sankey$1.prototype.applyNodesOffset = function applyNodesOffset(nodes) {
  nodes.forEach(function(node) {
    var offsetX = (node.offset ? node.offset.left : 0) || 0;
    var offsetY = (node.offset ? node.offset.top : 0) || 0;
    node.x0 += offsetX;
    node.x1 += offsetX;
    node.y0 += offsetY;
    node.y1 += offsetY;
  });
};
Sankey$1.prototype.calculateLinkBreadths = function calculateLinkBreadths(nodes) {
  nodes.forEach(function(node) {
    var sourceLinks = node.sourceLinks;
    var targetLinks = node.targetLinks;
    var y4 = node.y0;
    var y1 = y4;
    sourceLinks.forEach(function(link) {
      link.x0 = link.source.x1;
      link.y0 = y4 + link.width / 2;
      y4 += link.width;
    });
    targetLinks.forEach(function(link) {
      link.x1 = link.target.x0;
      link.y1 = y1 + link.width / 2;
      y1 += link.width;
    });
  });
};
Sankey$1.prototype.uncurlLinksToRight = function uncurlLinksToRight(columns, targetColumnIndex) {
  var this$1$1 = this;
  var n10 = columns.length;
  for (var i16 = targetColumnIndex; i16 < n10; i16++) {
    var column = columns[i16];
    column.forEach(function(target) {
      var y4 = 0;
      var sum2 = 0;
      target.targetLinks.forEach(function(link) {
        var kValue = link.value * (target.layer - link.source.layer);
        y4 += this$1$1.targetTopPos(link.source, target) * kValue;
        sum2 += kValue;
      });
      var dy = y4 === 0 ? 0 : y4 / sum2 - target.y0;
      target.y0 += dy;
      target.y1 += dy;
      sortLinks([target]);
    });
    column.sort(sortAsc);
    this$1$1.arrangeNodesVertically(column);
  }
};
Sankey$1.prototype.uncurlLinksToLeft = function uncurlLinksToLeft(columns, targetColumnIndex) {
  var this$1$1 = this;
  var l7 = columns.length;
  var startIndex = l7 - 1 - targetColumnIndex;
  for (var i16 = startIndex; i16 >= 0; i16--) {
    var column = columns[i16];
    var loop = function(j3) {
      var source = column[j3];
      var y4 = 0;
      var sum2 = 0;
      source.sourceLinks.forEach(function(link) {
        var kValue = link.value * (link.target.layer - source.layer);
        y4 += this$1$1.sourceTopPos(source, link.target) * kValue;
        sum2 += kValue;
      });
      var dy = y4 === 0 ? 0 : y4 / sum2 - source.y0;
      source.y0 += dy;
      source.y1 += dy;
      sortLinks([source]);
    };
    for (var j2 = 0; j2 < column.length; j2++)
      loop(j2);
    column.sort(sortAsc);
    this$1$1.arrangeNodesVertically(column);
  }
};
Sankey$1.prototype.arrangeNodesVertically = function arrangeNodesVertically(nodes) {
  var startIndex = 0;
  var endIndex = nodes.length - 1;
  this.arrangeUp(nodes, this.height, endIndex);
  this.arrangeDown(nodes, this.offsetY, startIndex);
};
Sankey$1.prototype.arrangeDown = function arrangeDown(nodes, yPos, index2) {
  var this$1$1 = this;
  var currentY = yPos;
  for (var i16 = index2; i16 < nodes.length; i16++) {
    var node = nodes[i16];
    var dy = Math.max(0, currentY - node.y0);
    node.y0 += dy;
    node.y1 += dy;
    currentY = node.y1 + this$1$1.nodePadding;
  }
};
Sankey$1.prototype.arrangeUp = function arrangeUp(nodes, yPos, index2) {
  var this$1$1 = this;
  var currentY = yPos;
  for (var i16 = index2; i16 >= 0; --i16) {
    var node = nodes[i16];
    var dy = Math.max(0, node.y1 - currentY);
    node.y0 -= dy;
    node.y1 -= dy;
    currentY = node.y0 - this$1$1.nodePadding;
  }
};
Sankey$1.prototype.sourceTopPos = function sourceTopPos(source, target) {
  var this$1$1 = this;
  var y4 = target.y0 - (target.targetLinks.length - 1) * this.nodePadding / 2;
  for (var i16 = 0; i16 < target.targetLinks.length; i16++) {
    var link = target.targetLinks[i16];
    if (link.source === source) {
      break;
    }
    y4 += link.width + this$1$1.nodePadding;
  }
  for (var i$12 = 0; i$12 < source.sourceLinks.length; i$12++) {
    var link$1 = source.sourceLinks[i$12];
    if (link$1.target === target) {
      break;
    }
    y4 -= link$1.width;
  }
  return y4;
};
Sankey$1.prototype.targetTopPos = function targetTopPos(source, target) {
  var this$1$1 = this;
  var y4 = source.y0 - (source.sourceLinks.length - 1) * this.nodePadding / 2;
  for (var i16 = 0; i16 < source.sourceLinks.length; i16++) {
    var link = source.sourceLinks[i16];
    if (link.target === target) {
      break;
    }
    y4 += link.width + this$1$1.nodePadding;
  }
  for (var i$12 = 0; i$12 < target.targetLinks.length; i$12++) {
    var link$1 = target.targetLinks[i$12];
    if (link$1.source === source) {
      break;
    }
    y4 -= link$1.width;
  }
  return y4;
};
var calculateSankey = function(options2) {
  return new Sankey$1(options2).calculate();
};
var crossesValue = function(links) {
  var value2 = 0;
  var linksLength = links.length;
  for (var i16 = 0; i16 < linksLength; i16++) {
    var link = links[i16];
    for (var lNext = i16 + 1; lNext < linksLength; lNext++) {
      var nextLink = links[lNext];
      if (intersect(link, nextLink)) {
        value2 += Math.min(link.value, nextLink.value);
      }
    }
  }
  return value2;
};
function rotationDirection(p1x, p1y, p2x, p2y, p3x, p3y) {
  var expression1 = (p3y - p1y) * (p2x - p1x);
  var expression2 = (p2y - p1y) * (p3x - p1x);
  if (expression1 > expression2) {
    return 1;
  } else if (expression1 === expression2) {
    return 0;
  }
  return -1;
}
function intersect(link1, link2) {
  var f1 = rotationDirection(link1.x0, link1.y0, link1.x1, link1.y1, link2.x1, link2.y1);
  var f22 = rotationDirection(link1.x0, link1.y0, link1.x1, link1.y1, link2.x0, link2.y0);
  var f32 = rotationDirection(link1.x0, link1.y0, link2.x0, link2.y0, link2.x1, link2.y1);
  var f4 = rotationDirection(link1.x1, link1.y1, link2.x0, link2.y0, link2.x1, link2.y1);
  return f1 !== f22 && f32 !== f4;
}
var SankeyElement = function(Class3) {
  function SankeyElement2(options2) {
    Class3.call(this);
    this.options = deepExtend({}, this.options, options2);
    this.createVisual();
  }
  if (Class3)
    SankeyElement2.__proto__ = Class3;
  SankeyElement2.prototype = Object.create(Class3 && Class3.prototype);
  SankeyElement2.prototype.constructor = SankeyElement2;
  SankeyElement2.prototype.createVisual = function createVisual() {
    this.visual = this.createElement();
  };
  SankeyElement2.prototype.exportVisual = function exportVisual() {
    return this.visual;
  };
  SankeyElement2.prototype.createElement = function createElement() {
    var this$1$1 = this;
    var customVisual = this.options.visual;
    var visual;
    if (customVisual) {
      visual = customVisual({
        sender: this.getSender(),
        options: this.visualOptions(),
        createVisual: function() {
          return this$1$1.getElement();
        }
      });
    } else {
      visual = this.getElement();
    }
    return visual;
  };
  SankeyElement2.prototype.getSender = function getSender() {
    return this;
  };
  return SankeyElement2;
}(Class$1);
var Node$1 = function(SankeyElement2) {
  function Node2() {
    SankeyElement2.apply(this, arguments);
  }
  if (SankeyElement2)
    Node2.__proto__ = SankeyElement2;
  Node2.prototype = Object.create(SankeyElement2 && SankeyElement2.prototype);
  Node2.prototype.constructor = Node2;
  Node2.prototype.getElement = function getElement() {
    return Path$7.fromRect(this.getRect(), this.visualOptions());
  };
  Node2.prototype.getRect = function getRect() {
    var node = this.options.node;
    return new Rect$1([node.x0, node.y0], [node.x1 - node.x0, node.y1 - node.y0]);
  };
  Node2.prototype.getLabelText = function getLabelText(options2) {
    var labelTemplate = options2.labels.ariaTemplate;
    if (labelTemplate) {
      return labelTemplate({ node: options2.node });
    }
  };
  Node2.prototype.visualOptions = function visualOptions() {
    var options2 = deepExtend({}, this.options, this.options.node);
    var ariaLabel = this.getLabelText(options2);
    return {
      fill: {
        color: options2.color,
        opacity: options2.opacity
      },
      stroke: { width: 0 },
      className: "k-sankey-node",
      role: "graphics-symbol",
      ariaRoleDescription: "Node",
      ariaLabel
    };
  };
  Node2.prototype.createFocusHighlight = function createFocusHighlight() {
    if (!this.options.navigatable) {
      return;
    }
    this._highlight = Path$7.fromRect(this.getRect(), {
      stroke: this.options.focusHighlight,
      visible: false
    });
    return this._highlight;
  };
  Node2.prototype.focus = function focus(options2) {
    if (this._highlight) {
      var ref2 = options2 || {};
      var highlight = ref2.highlight;
      if (highlight === void 0)
        highlight = true;
      if (highlight) {
        this._highlight.options.set("visible", true);
      }
      var id2 = this.options.node.id;
      this.visual.options.set("id", id2);
      if (this.options.root()) {
        this.options.root().setAttribute(ARIA_ACTIVE_DESCENDANT, id2);
      }
    }
  };
  Node2.prototype.blur = function blur() {
    if (this._highlight) {
      this._highlight.options.set("visible", false);
      this.visual.options.set("id", "");
      if (this.options.root()) {
        this.options.root().removeAttribute(ARIA_ACTIVE_DESCENDANT);
      }
    }
  };
  return Node2;
}(SankeyElement);
var nodeColor = function(node, nodeColors, index2) {
  return node.color || nodeColors[index2 % nodeColors.length];
};
var resolveNodeOptions = function(node, options2, nodeColors, index2) {
  var nodeOptions = deepExtend({}, options2, options2.node);
  return deepExtend(
    {},
    { color: nodeColor(node, nodeColors, index2) },
    nodeOptions,
    { node },
    {
      visual: node.visual,
      opacity: node.opacity,
      offset: node.offset,
      color: node.color
    }
  );
};
var distanceToLine = function(line, point2) {
  var ref2 = line[0];
  var x1 = ref2[0];
  var y1 = ref2[1];
  var ref$1 = line[1];
  var x22 = ref$1[0];
  var y22 = ref$1[1];
  var x3 = point2[0];
  var y32 = point2[1];
  return Math.abs((x22 - x1) * (y32 - y1) - (x3 - x1) * (y22 - y1)) / Math.sqrt(Math.pow(x22 - x1, 2) + Math.pow(y22 - y1, 2));
};
var bezierPoint = function(p1, p22, p32, p42, t6) {
  var t1 = 1 - t6;
  var t1t1 = t1 * t1;
  var tt = t6 * t6;
  return p1 * t1t1 * t1 + 3 * p22 * t6 * t1t1 + 3 * p32 * tt * t1 + p42 * tt * t6;
};
var angelBetweenTwoLines = function(line1, line2) {
  var ref2 = line1[0];
  var x1 = ref2[0];
  var y1 = ref2[1];
  var ref$1 = line1[1];
  var x22 = ref$1[0];
  var y22 = ref$1[1];
  var ref$2 = line2[0];
  var x3 = ref$2[0];
  var y32 = ref$2[1];
  var ref$3 = line2[1];
  var x4 = ref$3[0];
  var y4 = ref$3[1];
  var a1 = Math.atan2(y22 - y1, x22 - x1);
  var a22 = Math.atan2(y4 - y32, x4 - x3);
  return Math.abs(a1 - a22);
};
var calculateControlPointsOffsetX = function(link, rtl) {
  var x0 = link.x0;
  var x1 = link.x1;
  var y0 = link.y0;
  var y1 = link.y1;
  var xC = (x0 + x1) / 2;
  var width = link.width;
  var halfWidth = width / 2;
  var upperCurveMiddleLine = [[(x0 + xC) / 2, y0 - halfWidth], [(x1 + xC) / 2, y1 - halfWidth]];
  var lowerCurveMiddlePoint = [xC, bezierPoint(y0 + halfWidth, y0 + halfWidth, y1 + halfWidth, y1 + halfWidth, 0.5)];
  var actualWidth = distanceToLine(upperCurveMiddleLine, lowerCurveMiddlePoint);
  var upperNarrowness = (width - actualWidth) / 2;
  var alpha = angelBetweenTwoLines(upperCurveMiddleLine, [[x0, y0 - halfWidth], [xC, y0 - halfWidth]]);
  var a9 = upperNarrowness;
  var b2 = Math.sin(alpha) * a9;
  var offset2 = Math.sqrt(a9 * a9 + b2 * b2);
  var sign = y0 - y1 > 0 ? -1 : 1;
  if (rtl) {
    sign = -sign;
  }
  return sign * offset2;
};
var Link$1 = function(SankeyElement2) {
  function Link2() {
    SankeyElement2.apply(this, arguments);
  }
  if (SankeyElement2)
    Link2.__proto__ = SankeyElement2;
  Link2.prototype = Object.create(SankeyElement2 && SankeyElement2.prototype);
  Link2.prototype.constructor = Link2;
  Link2.prototype.getElement = function getElement() {
    var link = this.options.link;
    var x0 = link.x0;
    var x1 = link.x1;
    var y0 = link.y0;
    var y1 = link.y1;
    var xC = (x0 + x1) / 2;
    return new Path$7(this.visualOptions()).moveTo(x0, y0).curveTo([xC, y0], [xC, y1], [x1, y1]);
  };
  Link2.prototype.getLabelText = function getLabelText(options2) {
    var labelTemplate = options2.labels.ariaTemplate;
    if (labelTemplate) {
      return labelTemplate({ link: options2.link });
    }
  };
  Link2.prototype.visualOptions = function visualOptions() {
    var options2 = this.options;
    var link = this.options.link;
    var ariaLabel = this.getLabelText(options2);
    return {
      stroke: {
        width: options2.link.width,
        color: link.color || options2.color,
        opacity: defined(link.opacity) ? link.opacity : options2.opacity
      },
      role: "graphics-symbol",
      ariaRoleDescription: "Link",
      ariaLabel
    };
  };
  Link2.prototype.createFocusHighlight = function createFocusHighlight() {
    if (!this.options.navigatable) {
      return;
    }
    var ref2 = this.options;
    var link = ref2.link;
    var rtl = ref2.rtl;
    var x0 = link.x0;
    var x1 = link.x1;
    var y0 = link.y0;
    var y1 = link.y1;
    var xC = (x0 + x1) / 2;
    var halfWidth = link.width / 2;
    var offset2 = calculateControlPointsOffsetX(link, rtl);
    this._highlight = new Path$7({ stroke: this.options.focusHighlight, visible: false }).moveTo(x0, y0 + halfWidth).lineTo(x0, y0 - halfWidth).curveTo([xC + offset2, y0 - halfWidth], [xC + offset2, y1 - halfWidth], [x1, y1 - halfWidth]).lineTo(x1, y1 + halfWidth).curveTo([xC - offset2, y1 + halfWidth], [xC - offset2, y0 + halfWidth], [x0, y0 + halfWidth]);
  };
  Link2.prototype.focus = function focus(options2) {
    if (this._highlight) {
      var ref2 = options2 || {};
      var highlight = ref2.highlight;
      if (highlight === void 0)
        highlight = true;
      if (highlight) {
        this._highlight.options.set("visible", true);
      }
      var id2 = this.options.link.sourceId + "->" + this.options.link.targetId;
      this.visual.options.set("id", id2);
      if (this.options.root()) {
        this.options.root().setAttribute(ARIA_ACTIVE_DESCENDANT, id2);
      }
    }
  };
  Link2.prototype.blur = function blur() {
    if (this._highlight) {
      this._highlight.options.set("visible", false);
      this.visual.options.set("id", "");
      if (this.options.root()) {
        this.options.root().removeAttribute(ARIA_ACTIVE_DESCENDANT);
      }
    }
  };
  return Link2;
}(SankeyElement);
var resolveLinkOptions = function(link, options2, sourceNode, targetNode) {
  var linkOptions = deepExtend(
    {},
    options2,
    {
      link,
      opacity: link.opacity,
      color: link.color,
      colorType: link.colorType,
      visual: link.visual,
      highlight: link.highlight
    }
  );
  if (linkOptions.colorType === "source") {
    linkOptions.color = sourceNode.options.fill.color;
  } else if (linkOptions.colorType === "target") {
    linkOptions.color = targetNode.options.fill.color;
  }
  return linkOptions;
};
var INSIDE = "inside";
var BEFORE = "before";
var AFTER = "after";
var Label = function(SankeyElement2) {
  function Label2() {
    SankeyElement2.apply(this, arguments);
  }
  if (SankeyElement2)
    Label2.__proto__ = SankeyElement2;
  Label2.prototype = Object.create(SankeyElement2 && SankeyElement2.prototype);
  Label2.prototype.constructor = Label2;
  Label2.prototype.getElement = function getElement() {
    var options2 = deepExtend({}, this.options, this.options.node.label);
    var node = options2.node;
    var diagramMinX = options2.diagramMinX;
    var diagramMaxX = options2.diagramMaxX;
    var text = options2.text;
    var offset2 = options2.offset;
    var rtl = options2.rtl;
    var position2 = options2.position;
    if (rtl && position2 !== INSIDE) {
      position2 = position2 === BEFORE ? AFTER : BEFORE;
    }
    if (!options2.visible || !text) {
      return null;
    }
    var nodeBox = new Box(node.x0, node.y0, node.x1, node.y1);
    var visualOptions = this.visualOptions();
    if (rtl && !visualOptions.align) {
      visualOptions.align = "right";
    }
    var textbox = new TextBox(text, visualOptions);
    textbox.reflow(new Box());
    var textSizeBox = textbox.box;
    var textY = nodeBox.center().y - textSizeBox.height() / 2;
    var labelAfterLastNode = node.x1 + textSizeBox.width() > diagramMaxX;
    var labelBeforeFirstNode = node.x0 - textSizeBox.width() < diagramMinX;
    var side = position2 === BEFORE || position2 === INSIDE && labelAfterLastNode ? BEFORE : AFTER;
    if (rtl) {
      side = position2 === AFTER || position2 === INSIDE && labelBeforeFirstNode ? AFTER : BEFORE;
    }
    var textOrigin = [side === BEFORE ? node.x0 - textSizeBox.width() : node.x1, textY];
    var textRect = new Box(textOrigin[0], textOrigin[1], textOrigin[0] + textSizeBox.width(), textOrigin[1] + textSizeBox.height());
    textRect.translate(offset2.left || 0, offset2.top || 0);
    textbox.reflow(textRect);
    textbox.renderVisual();
    return textbox.visual;
  };
  Label2.prototype.visualOptions = function visualOptions() {
    var options2 = deepExtend({}, this.options, this.options.node.label);
    return {
      color: options2.color,
      font: options2.font,
      border: options2.border,
      margin: options2.margin,
      padding: options2.padding,
      align: options2.align,
      paintOrder: options2.paintOrder,
      stroke: options2.stroke
    };
  };
  return Label2;
}(SankeyElement);
setDefaultOptions(Label, {
  position: INSIDE
  // inside, before, after
});
var resolveLabelOptions = function(node, options2, rtl, diagramMinX, diagramMaxX) {
  return deepExtend(
    {},
    options2,
    {
      node,
      diagramMinX,
      diagramMaxX,
      rtl,
      visual: node.label.visual,
      visible: node.label.visible,
      margin: node.label.margin,
      padding: node.label.padding,
      border: node.label.border,
      align: node.label.align,
      offset: node.label.offset
    }
  );
};
var Title = function(SankeyElement2) {
  function Title2() {
    SankeyElement2.apply(this, arguments);
  }
  if (SankeyElement2)
    Title2.__proto__ = SankeyElement2;
  Title2.prototype = Object.create(SankeyElement2 && SankeyElement2.prototype);
  Title2.prototype.constructor = Title2;
  Title2.prototype.getElement = function getElement() {
    var options2 = this.options;
    var drawingRect = options2.drawingRect;
    var text = options2.text;
    if (options2.visible === false || !text) {
      return null;
    }
    var title2 = Title$1.buildTitle(text, options2);
    title2.reflow(drawingRect);
    title2.renderVisual();
    return title2.visual;
  };
  Title2.prototype.createElement = function createElement() {
    return this.getElement();
  };
  return Title2;
}(SankeyElement);
setDefaultOptions(Title, {
  align: CENTER,
  // 'left', 'right', 'center'
  border: {
    width: 0
  },
  margin: getSpacing(5),
  padding: getSpacing(5)
});
var sortData = function(a9, b2) {
  if (a9.node.x0 - b2.node.x0 !== 0) {
    return a9.node.x0 - b2.node.x0;
  }
  return a9.node.y0 - b2.node.y0;
};
var sortDataRTL = function(a9, b2) {
  if (a9.node.x1 - b2.node.x1 !== 0) {
    return a9.node.x1 - b2.node.x1;
  }
  return b2.node.y0 - a9.node.y0;
};
var sort$1 = function(rtl) {
  return rtl ? sortDataRTL : sortData;
};
var Legend = function(SankeyElement2) {
  function Legend2() {
    SankeyElement2.apply(this, arguments);
  }
  if (SankeyElement2)
    Legend2.__proto__ = SankeyElement2;
  Legend2.prototype = Object.create(SankeyElement2 && SankeyElement2.prototype);
  Legend2.prototype.constructor = Legend2;
  Legend2.prototype.getElement = function getElement() {
    var options2 = this.options;
    var drawingRect = options2.drawingRect;
    var rtl = options2.rtl;
    var nodes = options2.nodes;
    if (nodes === void 0)
      nodes = [];
    var item = options2.item;
    var position2 = options2.position;
    if (options2.visible === false || !nodes.length) {
      return null;
    }
    var data2 = nodes.map(function(node) {
      return {
        text: node.label && node.label.text || "",
        area: {
          background: item.areaBackground !== void 0 ? item.areaBackground : node.color,
          opacity: item.areaOpacity !== void 0 ? item.areaOpacity : node.opacity
        },
        node
      };
    });
    data2.sort(sort$1(rtl));
    var reverse = rtl && position2 !== LEFT && position2 !== RIGHT;
    var legend2 = new Legend$1(Object.assign({}, options2, { data: data2, reverse }), { rtl });
    legend2.reflow(drawingRect);
    legend2.renderVisual();
    return legend2.visual;
  };
  Legend2.prototype.createElement = function createElement() {
    return this.getElement();
  };
  return Legend2;
}(SankeyElement);
setDefaultOptions(Legend, {
  markers: { visible: false },
  item: {
    type: AREA,
    cursor: POINTER,
    opacity: 1
  },
  position: BOTTOM,
  align: CENTER,
  accessibility: {
    role: "presentation",
    ariaLabel: null,
    ariaRoleDescription: null
  },
  border: {
    width: 0
  }
});
var LINK = "link";
var NODE = "node";
var toRtl = function(sankey) {
  var nodes = sankey.nodes;
  var links = sankey.links;
  var startX = Math.min.apply(Math, nodes.map(function(node) {
    return node.x0;
  }));
  var endX = Math.max.apply(Math, nodes.map(function(node) {
    return node.x1;
  }));
  var width = endX - startX;
  nodes.forEach(function(node) {
    var x0 = width - (node.x1 - 2 * startX);
    var x1 = width - (node.x0 - 2 * startX);
    node.x0 = x0;
    node.x1 = x1;
  });
  links.forEach(function(link) {
    var x0 = width - (link.x1 - 2 * startX);
    var x1 = width - (link.x0 - 2 * startX);
    link.x1 = x0;
    link.x0 = x1;
  });
};
var Sankey2 = function(Observable2) {
  function Sankey3(element, options2, theme) {
    Observable2.call(this);
    this._initTheme(theme);
    this._setOptions(options2);
    this._initElement(element);
    this._initSurface();
    if (options2 && options2.data) {
      this._redraw();
      this._initResizeObserver();
      this._initNavigation(element);
    }
  }
  if (Observable2)
    Sankey3.__proto__ = Observable2;
  Sankey3.prototype = Object.create(Observable2 && Observable2.prototype);
  Sankey3.prototype.constructor = Sankey3;
  Sankey3.prototype.destroy = function destroy2() {
    this.unbind();
    this._destroySurface();
    this._destroyResizeObserver();
    if (this.element) {
      this.element.removeEventListener("keydown", this._keydownHandler);
      this.element.removeEventListener("focus", this._focusHandler);
      this.element.removeEventListener("mousedown", this._onDownHandler);
      this.element.removeEventListener("touchstart", this._onDownHandler);
      this.element.removeEventListener("pointerdown", this._onDownHandler);
    }
    this._focusState = null;
    this.element = null;
  };
  Sankey3.prototype._initElement = function _initElement(element) {
    this.element = element;
    addClass2(element, ["k-chart", "k-sankey"]);
    element.setAttribute("role", "graphics-document");
    var ref2 = this.options;
    var title2 = ref2.title;
    if (title2.text) {
      element.setAttribute("aria-label", title2.text);
    }
    if (title2.description) {
      element.setAttribute("aria-roledescription", title2.description);
    }
  };
  Sankey3.prototype._initSurface = function _initSurface() {
    if (!this.surface) {
      this._destroySurface();
      this._initSurfaceElement();
      this.surface = this._createSurface();
    }
  };
  Sankey3.prototype._initNavigation = function _initNavigation(element) {
    element.tabIndex = element.getAttribute("tabindex") || 0;
    if (this.options.disableKeyboardNavigation) {
      return;
    }
    this._keydownHandler = this._keydown.bind(this);
    this._focusHandler = this._focus.bind(this);
    this._blurHandler = this._blur.bind(this);
    this._onDownHandler = this._onDown.bind(this);
    element.addEventListener("keydown", this._keydownHandler);
    element.addEventListener("focus", this._focusHandler);
    element.addEventListener("blur", this._blurHandler);
    element.addEventListener("mousedown", this._onDownHandler);
    element.addEventListener("touchstart", this._onDownHandler);
    element.addEventListener("pointerdown", this._onDownHandler);
    this._focusState = {
      node: this.firstFocusableNode(),
      link: null
    };
  };
  Sankey3.prototype.firstFocusableNode = function firstFocusableNode() {
    return this.columns[0][0];
  };
  Sankey3.prototype._initResizeObserver = function _initResizeObserver() {
    var this$1$1 = this;
    var observer = new ResizeObserver(function(entries) {
      entries.forEach(function(entry) {
        var ref2 = entry.contentRect;
        var width = ref2.width;
        var height = ref2.height;
        if (entry.target !== this$1$1.element || this$1$1.size && this$1$1.size.width === width && this$1$1.size.height === height) {
          return;
        }
        this$1$1.size = { width, height };
        this$1$1.surface.setSize(this$1$1.size);
        this$1$1.resize = true;
        this$1$1._redraw();
      });
    });
    this._resizeObserver = observer;
    observer.observe(this.element);
  };
  Sankey3.prototype._createSurface = function _createSurface() {
    return Surface$2.create(this.surfaceElement, {
      mouseenter: this._mouseenter.bind(this),
      mouseleave: this._mouseleave.bind(this),
      mousemove: this._mousemove.bind(this),
      click: this._click.bind(this)
    });
  };
  Sankey3.prototype._initTheme = function _initTheme(theme) {
    var currentTheme = theme || this.theme || {};
    this.theme = currentTheme;
    this.options = deepExtend({}, currentTheme, this.options);
  };
  Sankey3.prototype.setLinksOpacity = function setLinksOpacity(opacity) {
    var this$1$1 = this;
    this.linksVisuals.forEach(function(link) {
      this$1$1.setOpacity(link, opacity, link.linkOptions.opacity);
    });
  };
  Sankey3.prototype.setLinksInactivityOpacity = function setLinksInactivityOpacity(inactiveOpacity) {
    var this$1$1 = this;
    this.linksVisuals.forEach(function(link) {
      this$1$1.setOpacity(link, inactiveOpacity, link.linkOptions.highlight.inactiveOpacity);
    });
  };
  Sankey3.prototype.setOpacity = function setOpacity(link, opacity, linkValue) {
    link.options.set("stroke", Object.assign(
      {},
      link.options.stroke,
      { opacity: defined(linkValue) ? linkValue : opacity }
    ));
  };
  Sankey3.prototype.trigger = function trigger2(name2, ev) {
    var dataItem = ev.element.dataItem;
    var targetType = ev.element.type;
    var event = Object.assign(
      {},
      ev,
      {
        type: name2,
        targetType,
        dataItem
      }
    );
    return Observable2.prototype.trigger.call(this, name2, event);
  };
  Sankey3.prototype._mouseenter = function _mouseenter2(ev) {
    var element = ev.element;
    var isLink = element.type === LINK;
    var isNode = element.type === NODE;
    var isLegendItem = Boolean(element.chartElement && element.chartElement.options.node);
    if (isLink && this.trigger("linkEnter", ev) || isNode && this.trigger("nodeEnter", ev)) {
      return;
    }
    var ref2 = this.options.links;
    var highlight = ref2.highlight;
    if (isLink) {
      this.setLinksInactivityOpacity(highlight.inactiveOpacity);
      this.setOpacity(element, highlight.opacity, element.linkOptions.highlight.opacity);
    } else if (isNode) {
      this.highlightLinks(element, highlight);
    } else if (isLegendItem) {
      var nodeVisual = this.nodesVisuals.get(element.chartElement.options.node.id);
      this.highlightLinks(nodeVisual, highlight);
    }
  };
  Sankey3.prototype._mouseleave = function _mouseleave2(ev) {
    var this$1$1 = this;
    var element = ev.element;
    var isLink = element.type === LINK;
    var isNode = element.type === NODE;
    var isLegendItem = Boolean(element.chartElement && element.chartElement.options.node);
    var target = ev.originalEvent.relatedTarget;
    if (isLink && target && target.nodeName === "text") {
      return;
    }
    if (isLink || isNode) {
      if (this.tooltipTimeOut) {
        clearTimeout(this.tooltipTimeOut);
        this.tooltipTimeOut = null;
      }
      this.tooltipShown = false;
      this.trigger("tooltipHide", ev);
    }
    if (isLink && this.trigger("linkLeave", ev) || isNode && this.trigger("nodeLeave", ev)) {
      return;
    }
    if (isLink || isNode || isLegendItem) {
      this.linksVisuals.forEach(function(link) {
        this$1$1.setOpacity(link, this$1$1.options.links.opacity, link.linkOptions.opacity);
      });
    }
  };
  Sankey3.prototype._mousemove = function _mousemove(ev) {
    var this$1$1 = this;
    var ref2 = this.options.tooltip;
    var followPointer = ref2.followPointer;
    var delay = ref2.delay;
    var element = ev.element;
    var tooltipElType = element.type;
    if (tooltipElType !== LINK && tooltipElType !== NODE || this.tooltipShown && !followPointer) {
      return;
    }
    var mouseEvent = ev.originalEvent;
    var rect = this.element.getBoundingClientRect();
    var isLeft = mouseEvent.clientX - rect.left < rect.width / 2;
    var isTop = mouseEvent.clientY - rect.top < rect.height / 2;
    ev.tooltipData = {
      popupOffset: {
        left: mouseEvent.pageX,
        top: mouseEvent.pageY
      },
      popupAlign: {
        horizontal: isLeft ? "left" : "right",
        vertical: isTop ? "top" : "bottom"
      }
    };
    if (tooltipElType === NODE) {
      var ref$1 = element.dataItem;
      var sourceLinks = ref$1.sourceLinks;
      var targetLinks = ref$1.targetLinks;
      var links = targetLinks.length ? targetLinks : sourceLinks;
      ev.nodeValue = links.reduce(function(acc, link) {
        return acc + link.value;
      }, 0);
    }
    if (this.tooltipTimeOut) {
      clearTimeout(this.tooltipTimeOut);
      this.tooltipTimeOut = null;
    }
    var nextDelay = followPointer && this.tooltipShown ? 0 : delay;
    this.tooltipTimeOut = setTimeout(function() {
      this$1$1.trigger("tooltipShow", ev);
      this$1$1.tooltipShown = true;
      this$1$1.tooltipTimeOut = null;
    }, nextDelay);
  };
  Sankey3.prototype._click = function _click(ev) {
    var element = ev.element;
    var dataItem = element.dataItem;
    var isLink = element.type === LINK;
    var isNode = element.type === NODE;
    var focusState = this._focusState || {};
    if (isNode) {
      var focusedNodeClicked = !focusState.link && this.sameNode(focusState.node, dataItem);
      if (!focusedNodeClicked) {
        this._focusState = { node: dataItem, link: null };
        this._focusNode({ highlight: false });
      }
      this.trigger("nodeClick", ev);
    } else if (isLink) {
      var link = {
        sourceId: dataItem.source.id,
        targetId: dataItem.target.id,
        value: dataItem.value
      };
      var focusedLinkClicked = this.sameLink(focusState.link, link);
      if (!focusedLinkClicked) {
        this._focusState = { node: dataItem.source, link };
        this._focusLink({ highlight: false });
      }
      this.trigger("linkClick", ev);
    }
  };
  Sankey3.prototype.sameNode = function sameNode(node1, node2) {
    return node1 && node2 && node1.id === node2.id;
  };
  Sankey3.prototype.sameLink = function sameLink(link1, link2) {
    return link1 && link2 && link1.sourceId === link2.sourceId && link1.targetId === link2.targetId;
  };
  Sankey3.prototype._focusNode = function _focusNode(options2) {
    this._cleanFocusHighlight();
    var nodeData = this._focusState.node;
    var node = this.models.map.get(nodeData.id);
    node.focus(options2);
  };
  Sankey3.prototype._focusLink = function _focusLink(options2) {
    this._cleanFocusHighlight();
    var linkData = this._focusState.link;
    var link = this.models.map.get(linkData.sourceId + "-" + linkData.targetId);
    link.focus(options2);
  };
  Sankey3.prototype._focusNextNode = function _focusNextNode(direction) {
    if (direction === void 0)
      direction = 1;
    var current2 = this._focusState.node;
    var columnIndex = this.columns.findIndex(function(column) {
      return column.find(function(n10) {
        return n10.id === current2.id;
      });
    });
    var columnNodes = this.columns[columnIndex];
    var nodeIndex = columnNodes.findIndex(function(n10) {
      return n10.id === current2.id;
    });
    var nextNode = columnNodes[nodeIndex + direction];
    if (nextNode) {
      this._focusState.node = nextNode;
      this._focusNode();
    }
  };
  Sankey3.prototype._focusNextLink = function _focusNextLink(direction) {
    if (direction === void 0)
      direction = 1;
    var node = this._focusState.node;
    var link = this._focusState.link;
    var sourceLinkIndex = node.sourceLinks.findIndex(function(l7) {
      return l7.sourceId === link.sourceId && l7.targetId === link.targetId;
    });
    var targetLinkIndex = node.targetLinks.findIndex(function(l7) {
      return l7.sourceId === link.sourceId && l7.targetId === link.targetId;
    });
    if (sourceLinkIndex !== -1) {
      var nextLink = node.sourceLinks[sourceLinkIndex + direction];
      if (nextLink) {
        this._focusState.link = nextLink;
        this._focusLink();
      }
    } else if (targetLinkIndex !== -1) {
      var nextLink$1 = node.targetLinks[targetLinkIndex + direction];
      if (nextLink$1) {
        this._focusState.link = nextLink$1;
        this._focusLink();
      }
    }
  };
  Sankey3.prototype._focusSourceNode = function _focusSourceNode() {
    var linkData = this._focusState.link;
    var sourceNode = this.models.map.get(linkData.sourceId);
    this._focusState = { node: sourceNode.options.node, link: null };
    this._focusNode();
  };
  Sankey3.prototype._focusTargetNode = function _focusTargetNode() {
    var linkData = this._focusState.link;
    var targetNode = this.models.map.get(linkData.targetId);
    this._focusState = { node: targetNode.options.node, link: null };
    this._focusNode();
  };
  Sankey3.prototype._focusSourceLink = function _focusSourceLink() {
    var nodeData = this._focusState.node;
    var sourceLinks = nodeData.sourceLinks;
    var linkData = sourceLinks[0];
    if (linkData) {
      this._focusState.link = linkData;
      this._focusLink();
    }
  };
  Sankey3.prototype._focusTargetLink = function _focusTargetLink() {
    var nodeData = this._focusState.node;
    var targetLinks = nodeData.targetLinks;
    var linkData = targetLinks[0];
    if (linkData) {
      this._focusState.link = linkData;
      this._focusLink();
    }
  };
  Sankey3.prototype._focus = function _focus() {
    if (!this._skipFocusHighlight) {
      if (this._focusState.link) {
        this._focusLink();
      } else {
        this._focusNode();
      }
    }
    this._skipFocusHighlight = false;
  };
  Sankey3.prototype._blur = function _blur() {
    this._cleanFocusHighlight();
  };
  Sankey3.prototype._onDown = function _onDown() {
    if (!this._hasFocus()) {
      this._skipFocusHighlight = true;
    }
  };
  Sankey3.prototype._hasFocus = function _hasFocus() {
    return this.element.ownerDocument.activeElement === this.element;
  };
  Sankey3.prototype._cleanFocusHighlight = function _cleanFocusHighlight() {
    this.models.nodes.forEach(function(node) {
      return node.blur();
    });
    this.models.links.forEach(function(link) {
      return link.blur();
    });
  };
  Sankey3.prototype._keydown = function _keydown(ev) {
    var handler = this["on" + ev.key];
    var rtl = this.options.rtl;
    if (rtl && ev.key === "ArrowLeft") {
      handler = this.onArrowRight;
    } else if (rtl && ev.key === "ArrowRight") {
      handler = this.onArrowLeft;
    }
    if (handler) {
      handler.call(this, ev);
    }
  };
  Sankey3.prototype.onEscape = function onEscape(ev) {
    ev.preventDefault();
    this._focusState = { node: this.firstFocusableNode(), link: null };
    this._focusNode();
  };
  Sankey3.prototype.onArrowDown = function onArrowDown(ev) {
    ev.preventDefault();
    if (this._focusState.link) {
      this._focusNextLink(1);
    } else {
      this._focusNextNode(1);
    }
  };
  Sankey3.prototype.onArrowUp = function onArrowUp(ev) {
    ev.preventDefault();
    if (this._focusState.link) {
      this._focusNextLink(-1);
    } else {
      this._focusNextNode(-1);
    }
  };
  Sankey3.prototype.onArrowLeft = function onArrowLeft(ev) {
    ev.preventDefault();
    if (this._focusState.link) {
      this._focusSourceNode();
    } else {
      this._focusTargetLink();
    }
  };
  Sankey3.prototype.onArrowRight = function onArrowRight(ev) {
    ev.preventDefault();
    if (this._focusState.link) {
      this._focusTargetNode();
    } else {
      this._focusSourceLink();
    }
  };
  Sankey3.prototype.highlightLinks = function highlightLinks(node, highlight) {
    var this$1$1 = this;
    if (node) {
      this.setLinksInactivityOpacity(highlight.inactiveOpacity);
      node.links.forEach(function(link) {
        this$1$1.setOpacity(link, highlight.opacity, link.linkOptions.highlight.opacity);
      });
    }
  };
  Sankey3.prototype._destroySurface = function _destroySurface() {
    if (this.surface) {
      this.surface.destroy();
      this.surface = null;
      this._destroySurfaceElement();
    }
  };
  Sankey3.prototype._destroyResizeObserver = function _destroyResizeObserver() {
    if (this._resizeObserver) {
      this._resizeObserver.disconnect();
      this._resizeObserver = null;
    }
  };
  Sankey3.prototype._initSurfaceElement = function _initSurfaceElement() {
    if (!this.surfaceElement) {
      this.surfaceElement = document.createElement("div");
      this.element.appendChild(this.surfaceElement);
    }
  };
  Sankey3.prototype._destroySurfaceElement = function _destroySurfaceElement() {
    if (this.surfaceElement && this.surfaceElement.parentNode) {
      this.surfaceElement.parentNode.removeChild(this.surfaceElement);
      this.surfaceElement = null;
    }
  };
  Sankey3.prototype.setOptions = function setOptions(options2, theme) {
    this._setOptions(options2);
    this._initTheme(theme);
    this._initSurface();
    this._redraw();
  };
  Sankey3.prototype._redraw = function _redraw() {
    this.surface.clear();
    var ref2 = this._getSize();
    var width = ref2.width;
    var height = ref2.height;
    this.size = { width, height };
    this.surface.setSize(this.size);
    this.createVisual();
    this.surface.draw(this.visual);
  };
  Sankey3.prototype._getSize = function _getSize() {
    return this.element.getBoundingClientRect();
  };
  Sankey3.prototype.createVisual = function createVisual() {
    this.visual = this._render();
  };
  Sankey3.prototype.titleBox = function titleBox(title2, drawingRect) {
    if (!title2 || title2.visible === false || !title2.text) {
      return null;
    }
    var titleElement = new Title(Object.assign({}, { drawingRect }, title2));
    var titleVisual = titleElement.exportVisual();
    return titleVisual.chartElement.box;
  };
  Sankey3.prototype.legendBox = function legendBox(options2, nodes, drawingRect) {
    if (!options2 || options2.visible === false) {
      return null;
    }
    var legend2 = new Legend(Object.assign({}, { nodes }, options2, { drawingRect }));
    var legendVisual = legend2.exportVisual();
    return legendVisual.chartElement.box;
  };
  Sankey3.prototype.calculateSankey = function calculateSankey$1(calcOptions, sankeyOptions) {
    var title2 = sankeyOptions.title;
    var legend2 = sankeyOptions.legend;
    var data2 = sankeyOptions.data;
    var nodes = sankeyOptions.nodes;
    var labels = sankeyOptions.labels;
    var nodeColors = sankeyOptions.nodeColors;
    var disableAutoLayout = sankeyOptions.disableAutoLayout;
    var disableKeyboardNavigation = sankeyOptions.disableKeyboardNavigation;
    var rtl = sankeyOptions.rtl;
    var autoLayout = !disableAutoLayout;
    var padding = disableKeyboardNavigation ? 0 : highlightOptions.width / 2;
    var sankeyBox = new Box(0, 0, calcOptions.width, calcOptions.height);
    sankeyBox.unpad(padding);
    var titleBox = this.titleBox(title2, sankeyBox);
    var legendArea = sankeyBox.clone();
    if (titleBox) {
      var titleHeight = titleBox.height();
      if (title2.position === TOP) {
        sankeyBox.unpad({ top: titleHeight });
        legendArea = new Box(0, titleHeight, calcOptions.width, calcOptions.height);
      } else {
        sankeyBox.shrink(0, titleHeight);
        legendArea = new Box(0, 0, calcOptions.width, calcOptions.height - titleHeight);
      }
    }
    var legendBox = this.legendBox(legend2, data2.nodes, legendArea);
    var legendPosition = legend2 && legend2.position || Legend.prototype.options.position;
    if (legendBox) {
      if (legendPosition === LEFT) {
        sankeyBox.unpad({ left: legendBox.width() });
      }
      if (legendPosition === RIGHT) {
        sankeyBox.shrink(legendBox.width(), 0);
      }
      if (legendPosition === TOP) {
        sankeyBox.unpad({ top: legendBox.height() });
      }
      if (legendPosition === BOTTOM) {
        sankeyBox.shrink(0, legendBox.height());
      }
    }
    var ref2 = calculateSankey(Object.assign({}, calcOptions, { offsetX: 0, offsetY: 0, width: sankeyBox.width(), height: sankeyBox.height() }));
    var calculatedNodes = ref2.nodes;
    var circularLinks = ref2.circularLinks;
    if (circularLinks) {
      console.warn("Circular links detected. Kendo Sankey diagram does not support circular links.");
      return { sankey: { nodes: [], links: [], columns: [[]], circularLinks }, legendBox, titleBox };
    }
    var box = new Box();
    var diagramMinX = calculatedNodes.reduce(function(acc, node) {
      return Math.min(acc, node.x0);
    }, Infinity);
    var diagramMaxX = calculatedNodes.reduce(function(acc, node) {
      return Math.max(acc, node.x1);
    }, 0);
    calculatedNodes.forEach(function(nodeEl, i16) {
      if (rtl) {
        var x0 = nodeEl.x0;
        var x1 = nodeEl.x1;
        nodeEl.x0 = diagramMaxX - x1;
        nodeEl.x1 = diagramMaxX - x0;
      }
      var nodeOps = resolveNodeOptions(nodeEl, nodes, nodeColors, i16);
      var nodeInstance = new Node$1(nodeOps);
      box.wrap(rectToBox(nodeInstance.exportVisual().rawBBox()));
      var labelInstance = new Label(resolveLabelOptions(nodeEl, labels, rtl, diagramMinX, diagramMaxX));
      var labelVisual = labelInstance.exportVisual();
      if (labelVisual) {
        box.wrap(rectToBox(labelVisual.rawBBox()));
      }
    });
    var offsetX = sankeyBox.x1;
    var offsetY = sankeyBox.y1;
    var width = sankeyBox.width() + offsetX;
    var height = sankeyBox.height() + offsetY;
    width -= box.x2 > sankeyBox.width() ? box.x2 - sankeyBox.width() : 0;
    height -= box.y2 > sankeyBox.height() ? box.y2 - sankeyBox.height() : 0;
    offsetX += box.x1 < 0 ? -box.x1 : 0;
    offsetY += box.y1 < 0 ? -box.y1 : 0;
    if (autoLayout === false) {
      return {
        sankey: calculateSankey(Object.assign({}, calcOptions, { offsetX, offsetY, width, height, autoLayout: false })),
        legendBox,
        titleBox
      };
    }
    if (this.resize && autoLayout && this.permutation) {
      this.resize = false;
      return {
        sankey: calculateSankey(Object.assign({}, calcOptions, { offsetX, offsetY, width, height }, this.permutation)),
        legendBox,
        titleBox
      };
    }
    var startColumn = 1;
    var loops = 2;
    var columnsLength = calculateSankey(Object.assign({}, calcOptions, { offsetX, offsetY, width, height, autoLayout: false })).columns.length;
    var results = [];
    var permutation = function(targetColumnIndex, reverse) {
      var currPerm = calculateSankey(Object.assign({}, calcOptions, { offsetX, offsetY, width, height, loops, targetColumnIndex, reverse }));
      var crosses = crossesValue(currPerm.links);
      results.push({
        crosses,
        reverse,
        targetColumnIndex
      });
      return crosses === 0;
    };
    for (var index2 = startColumn; index2 <= columnsLength - 1; index2++) {
      if (permutation(index2, false) || permutation(index2, true)) {
        break;
      }
    }
    var minCrosses = Math.min.apply(null, results.map(function(r12) {
      return r12.crosses;
    }));
    var bestResult = results.find(function(r12) {
      return r12.crosses === minCrosses;
    });
    this.permutation = { targetColumnIndex: bestResult.targetColumnIndex, reverse: bestResult.reverse };
    var result = calculateSankey(Object.assign({}, calcOptions, { offsetX, offsetY, width, height }, this.permutation));
    return {
      sankey: result,
      legendBox,
      titleBox
    };
  };
  Sankey3.prototype._render = function _render(options2, context2) {
    var sankeyOptions = options2 || this.options;
    var sankeyContext = context2 || this;
    var labelOptions = sankeyOptions.labels;
    var nodesOptions = sankeyOptions.nodes;
    var linkOptions = sankeyOptions.links;
    var nodeColors = sankeyOptions.nodeColors;
    var title2 = sankeyOptions.title;
    var legend2 = sankeyOptions.legend;
    var rtl = sankeyOptions.rtl;
    var disableKeyboardNavigation = sankeyOptions.disableKeyboardNavigation;
    var data2 = sankeyOptions.data;
    var ref2 = sankeyContext.size;
    var width = ref2.width;
    var height = ref2.height;
    var calcOptions = Object.assign({}, data2, { width, height, nodesOptions, title: title2, legend: legend2 });
    var ref$1 = this.calculateSankey(calcOptions, sankeyOptions);
    var sankey = ref$1.sankey;
    var titleBox = ref$1.titleBox;
    var legendBox = ref$1.legendBox;
    if (rtl) {
      toRtl(sankey);
    }
    var nodes = sankey.nodes;
    var links = sankey.links;
    var columns = sankey.columns;
    sankeyContext.columns = columns.map(function(column) {
      var newColumn = column.slice();
      newColumn.sort(function(a9, b2) {
        return a9.y0 - b2.y0;
      });
      return newColumn;
    });
    var visual = new Group$9({
      clip: Path$7.fromRect(new Rect$1([0, 0], [width, height]))
    });
    if (titleBox) {
      var titleElement = new Title(Object.assign({}, title2, { drawingRect: titleBox }));
      var titleVisual = titleElement.exportVisual();
      visual.append(titleVisual);
    }
    if (sankey.circularLinks) {
      return visual;
    }
    var visualNodes = /* @__PURE__ */ new Map();
    sankeyContext.nodesVisuals = visualNodes;
    var models = {
      nodes: [],
      links: [],
      map: /* @__PURE__ */ new Map()
    };
    sankeyContext.models = models;
    var focusHighlights = [];
    nodes.forEach(function(node, i16) {
      var nodeOps = resolveNodeOptions(node, nodesOptions, nodeColors, i16);
      nodeOps.root = function() {
        return sankeyContext.element;
      };
      nodeOps.navigatable = disableKeyboardNavigation !== true;
      var nodeInstance = new Node$1(nodeOps);
      var nodeVisual = nodeInstance.exportVisual();
      nodeVisual.links = [];
      nodeVisual.type = NODE;
      node.color = nodeOps.color;
      node.opacity = nodeOps.opacity;
      nodeVisual.dataItem = Object.assign(
        {},
        data2.nodes[i16],
        {
          color: nodeOps.color,
          opacity: nodeOps.opacity,
          sourceLinks: node.sourceLinks.map(function(link) {
            return { sourceId: link.sourceId, targetId: link.targetId, value: link.value };
          }),
          targetLinks: node.targetLinks.map(function(link) {
            return { sourceId: link.sourceId, targetId: link.targetId, value: link.value };
          })
        }
      );
      visualNodes.set(node.id, nodeVisual);
      models.nodes.push(nodeInstance);
      models.map.set(node.id, nodeInstance);
      visual.append(nodeVisual);
      nodeInstance.createFocusHighlight();
      if (nodeInstance._highlight) {
        focusHighlights.push(nodeInstance._highlight);
      }
    });
    var sortedLinks = links.slice().sort(function(a9, b2) {
      return b2.value - a9.value;
    });
    var linksVisuals = [];
    sankeyContext.linksVisuals = linksVisuals;
    sortedLinks.forEach(function(link) {
      var source = link.source;
      var target = link.target;
      var sourceNode = visualNodes.get(source.id);
      var targetNode = visualNodes.get(target.id);
      var resolvedOptions = resolveLinkOptions(link, linkOptions, sourceNode, targetNode);
      resolvedOptions.root = function() {
        return sankeyContext.element;
      };
      resolvedOptions.navigatable = disableKeyboardNavigation !== true;
      resolvedOptions.rtl = rtl;
      var linkInstance = new Link$1(resolvedOptions);
      var linkVisual = linkInstance.exportVisual();
      linkVisual.type = LINK;
      linkVisual.dataItem = {
        source: Object.assign({}, sourceNode.dataItem),
        target: Object.assign({}, targetNode.dataItem),
        value: link.value
      };
      linkVisual.linkOptions = resolvedOptions;
      linksVisuals.push(linkVisual);
      sourceNode.links.push(linkVisual);
      targetNode.links.push(linkVisual);
      models.links.push(linkInstance);
      models.map.set(source.id + "-" + target.id, linkInstance);
      linkInstance.createFocusHighlight();
      if (linkInstance._highlight) {
        focusHighlights.push(linkInstance._highlight);
      }
      visual.append(linkVisual);
    });
    var diagramMinX = nodes.reduce(function(acc, node) {
      return Math.min(acc, node.x0);
    }, Infinity);
    var diagramMaxX = nodes.reduce(function(acc, node) {
      return Math.max(acc, node.x1);
    }, 0);
    nodes.forEach(function(node) {
      var textOps = resolveLabelOptions(node, labelOptions, rtl, diagramMinX, diagramMaxX);
      var labelInstance = new Label(textOps);
      var labelVisual = labelInstance.exportVisual();
      if (labelVisual) {
        visual.append(labelVisual);
      }
    });
    if (legendBox) {
      var legendElement = new Legend(Object.assign({}, legend2, { rtl, drawingRect: legendBox, nodes }));
      var legendVisual = legendElement.exportVisual();
      visual.append(legendVisual);
    }
    if (focusHighlights.length !== 0) {
      var focusHighlight = new Group$9();
      focusHighlight.append.apply(focusHighlight, focusHighlights);
      visual.append(focusHighlight);
    }
    return visual;
  };
  Sankey3.prototype.exportVisual = function exportVisual(exportOptions) {
    var options2 = exportOptions && exportOptions.options ? deepExtend({}, this.options, exportOptions.options) : this.options;
    var context2 = {
      size: {
        width: defined(exportOptions && exportOptions.width) ? exportOptions.width : this.size.width,
        height: defined(exportOptions && exportOptions.height) ? exportOptions.height : this.size.height
      }
    };
    return this._render(options2, context2);
  };
  Sankey3.prototype._setOptions = function _setOptions(options2) {
    this.options = deepExtend({}, this.options, options2);
  };
  return Sankey3;
}(Observable);
var highlightOptions = {
  opacity: 1,
  width: 2,
  color: BLACK$1
};
setDefaultOptions(Sankey2, {
  title: {
    position: TOP
    // 'top', 'bottom'
  },
  labels: {
    visible: true,
    margin: {
      left: 8,
      right: 8
    },
    padding: 0,
    border: {
      width: 0
    },
    paintOrder: "stroke",
    stroke: {
      lineJoin: "round",
      width: 1
    },
    offset: { left: 0, top: 0 }
  },
  nodes: {
    width: 24,
    padding: 16,
    opacity: 1,
    align: "stretch",
    // 'left', 'right', 'stretch'
    offset: { left: 0, top: 0 },
    focusHighlight: Object.assign({}, highlightOptions),
    labels: {
      ariaTemplate: function(ref2) {
        var node = ref2.node;
        return node.label.text;
      }
    }
  },
  links: {
    colorType: "static",
    // 'source', 'target', 'static'
    opacity: 0.4,
    highlight: {
      opacity: 0.8,
      inactiveOpacity: 0.2
    },
    focusHighlight: Object.assign({}, highlightOptions),
    labels: {
      ariaTemplate: function(ref2) {
        var link = ref2.link;
        return link.source.label.text + " to " + link.target.label.text;
      }
    }
  },
  tooltip: {
    followPointer: false,
    delay: 200
  }
});
var fontNames = [
  {
    text: "Arial",
    value: "Arial, Helvetica, sans-serif",
    style: { fontFamily: "Arial, Helvetica, sans-serif" }
  },
  {
    text: "Courier New",
    value: "'Courier New', Courier, monospace",
    style: { fontFamily: "'Courier New', Courier, monospace" }
  },
  {
    text: "Georgia",
    value: "Georgia, serif",
    style: { fontFamily: "Georgia, serif" }
  },
  {
    text: "Impact",
    value: "Impact, Charcoal, sans-serif",
    style: { fontFamily: "Impact, Charcoal, sans-serif" }
  },
  {
    text: "Lucida Console",
    value: "'Lucida Console', Monaco, monospace",
    style: { fontFamily: "'Lucida Console', Monaco, monospace" }
  },
  {
    text: "Tahoma",
    value: "Tahoma, Geneva, sans-serif",
    style: { fontFamily: "Tahoma, Geneva, sans-serif" }
  },
  {
    text: "Times New Roman",
    value: "'Times New Roman', Times,serif",
    style: { fontFamily: "'Times New Roman', Times,serif" }
  },
  {
    text: "Trebuchet MS",
    value: "'Trebuchet MS', Helvetica, sans-serif",
    style: { fontFamily: "'Trebuchet MS', Helvetica, sans-serif" }
  },
  {
    text: "Verdana",
    value: "Verdana, Geneva, sans-serif",
    style: { fontFamily: "Verdana, Geneva, sans-serif" }
  }
];
fontNames[0].value;
var BAR_GAP = 1.5;
var BAR_SPACING = 0.4;
var BLACK = "#000";
var SANS = "Arial, Helvetica, sans-serif";
var SANS11 = "11px " + SANS;
var SANS12 = "12px " + SANS;
var SANS16 = "16px " + SANS;
var TRANSPARENT = "transparent";
var WHITE = "#fff";
var lineSeriesLegendItem = {
  type: LINE
};
var areaSeriesLegendItem = {
  type: AREA
};
var areaNoMarkersSeriesLegendItem = Object.assign(
  {},
  areaSeriesLegendItem,
  {
    markers: {
      visible: false
    },
    highlight: {
      visible: false
    }
  }
);
var notes = function() {
  return {
    icon: {
      border: {
        width: 1
      }
    },
    label: {
      font: SANS12,
      padding: 3
    },
    line: {
      length: 10,
      width: 2
    },
    legendItem: areaNoMarkersSeriesLegendItem,
    visible: true
  };
};
var axisDefaults = function() {
  return {
    labels: {
      font: SANS12
    },
    notes: notes(),
    title: {
      font: SANS16,
      margin: 5
    }
  };
};
var areaSeries = function() {
  return {
    highlight: {
      markers: {
        border: {}
      }
    },
    line: {
      opacity: 1,
      width: 0
    },
    markers: {
      size: 6,
      visible: false
    },
    legendItem: areaSeriesLegendItem,
    opacity: 0.4
  };
};
var rangeAreaSeries = function() {
  return {
    highlight: {
      markers: {
        border: {}
      }
    },
    line: {
      opacity: 1,
      width: 0
    },
    markers: {
      size: 6,
      visible: false
    },
    legendItem: areaSeriesLegendItem,
    opacity: 0.4
  };
};
var barSeries = function() {
  return {
    gap: BAR_GAP,
    spacing: BAR_SPACING,
    legendItem: areaNoMarkersSeriesLegendItem
  };
};
var boxPlotSeries = function() {
  return {
    outliersField: "",
    meanField: "",
    border: {
      _brightness: 0.8,
      width: 1
    },
    downColor: WHITE,
    gap: 1,
    highlight: {
      border: {
        opacity: 1,
        width: 2
      },
      whiskers: {
        width: 3
      },
      mean: {
        width: 2
      },
      median: {
        width: 2
      }
    },
    mean: {
      width: 2
    },
    median: {
      width: 2
    },
    spacing: 0.3,
    whiskers: {
      width: 2
    },
    legendItem: areaNoMarkersSeriesLegendItem
  };
};
var bubbleSeries = function() {
  return {
    border: {
      width: 0
    },
    labels: {
      background: TRANSPARENT
    },
    legendItem: areaNoMarkersSeriesLegendItem,
    opacity: 0.6
  };
};
var bulletSeries = function() {
  return {
    gap: BAR_GAP,
    spacing: BAR_SPACING,
    target: {
      color: "#ff0000"
    },
    legendItem: areaNoMarkersSeriesLegendItem
  };
};
var candlestickSeries = function() {
  return {
    border: {
      _brightness: 0.8,
      width: 1
    },
    downColor: WHITE,
    gap: 1,
    highlight: {
      border: {
        opacity: 1,
        width: 2
      },
      line: {
        width: 2
      }
    },
    line: {
      color: BLACK,
      width: 1
    },
    legendItem: areaNoMarkersSeriesLegendItem,
    spacing: 0.3
  };
};
var columnSeries = function() {
  return {
    gap: BAR_GAP,
    spacing: BAR_SPACING,
    legendItem: areaNoMarkersSeriesLegendItem
  };
};
var radarColumnSeries = function() {
  return {
    legendItem: areaNoMarkersSeriesLegendItem
  };
};
var polarScatterSeries = function() {
  return {
    legendItem: lineSeriesLegendItem
  };
};
var scatterSeries = function() {
  return {
    legendItem: lineSeriesLegendItem
  };
};
var donutSeries = function() {
  return {
    margin: 1,
    legendItem: areaNoMarkersSeriesLegendItem
  };
};
var lineSeries = function() {
  return {
    width: 2,
    legendItem: lineSeriesLegendItem
  };
};
var ohlcSeries = function() {
  return {
    gap: 1,
    highlight: {
      line: {
        opacity: 1,
        width: 3
      }
    },
    line: {
      width: 1
    },
    legendItem: areaNoMarkersSeriesLegendItem,
    spacing: 0.3
  };
};
var radarAreaSeries = function() {
  return {
    line: {
      opacity: 1,
      width: 0
    },
    markers: {
      size: 6,
      visible: false
    },
    legendItem: areaSeriesLegendItem,
    opacity: 0.5
  };
};
var radarLineSeries = function() {
  return {
    markers: {
      visible: false
    },
    legendItem: lineSeriesLegendItem,
    width: 2
  };
};
var rangeBarSeries = function() {
  return {
    gap: BAR_GAP,
    spacing: BAR_SPACING,
    legendItem: areaNoMarkersSeriesLegendItem
  };
};
var rangeColumnSeries = function() {
  return {
    gap: BAR_GAP,
    spacing: BAR_SPACING,
    legendItem: areaNoMarkersSeriesLegendItem
  };
};
var scatterLineSeries = function() {
  return {
    width: 1,
    legendItem: lineSeriesLegendItem
  };
};
var waterfallSeries = function() {
  return {
    gap: 0.5,
    line: {
      color: BLACK,
      width: 1
    },
    legendItem: areaNoMarkersSeriesLegendItem,
    spacing: BAR_SPACING
  };
};
var pieSeries = function() {
  return {
    labels: {
      background: "",
      color: "",
      padding: {
        top: 5,
        bottom: 5,
        left: 7,
        right: 7
      }
    },
    legendItem: areaNoMarkersSeriesLegendItem
  };
};
var funnelSeries = function() {
  return {
    labels: {
      background: "",
      color: "",
      padding: {
        top: 5,
        bottom: 5,
        left: 7,
        right: 7
      }
    },
    legendItem: areaNoMarkersSeriesLegendItem
  };
};
var pyramidSeries = funnelSeries;
var heatmapSeries = function() {
  return {
    labels: {
      color: "",
      background: TRANSPARENT,
      visible: true
    },
    highlight: {
      border: {
        width: 0
      }
    },
    legendItem: areaNoMarkersSeriesLegendItem
  };
};
var trendlineSeriesDefaults = function(options2) {
  return Object.assign({
    color: INHERIT,
    trendline: {},
    markers: {
      visible: false
    },
    width: 1,
    dashType: "longDash",
    legendItem: lineSeriesLegendItem
  }, options2);
};
var seriesDefaults = function(options2) {
  return {
    visible: true,
    labels: {
      font: SANS11
    },
    overlay: options2.gradients ? {} : {
      gradient: "none"
    },
    area: areaSeries(),
    rangeArea: rangeAreaSeries(),
    verticalRangeArea: rangeAreaSeries(),
    bar: barSeries(),
    boxPlot: boxPlotSeries(),
    bubble: bubbleSeries(),
    bullet: bulletSeries(),
    candlestick: candlestickSeries(),
    column: columnSeries(),
    heatmap: heatmapSeries(),
    pie: pieSeries(),
    donut: donutSeries(),
    funnel: funnelSeries(),
    pyramid: pyramidSeries(),
    horizontalWaterfall: waterfallSeries(),
    line: lineSeries(),
    notes: notes(),
    ohlc: ohlcSeries(),
    radarArea: radarAreaSeries(),
    radarLine: radarLineSeries(),
    radarColumn: radarColumnSeries(),
    polarArea: radarAreaSeries(),
    polarLine: radarLineSeries(),
    polarScatter: polarScatterSeries(),
    rangeBar: rangeBarSeries(),
    rangeColumn: rangeColumnSeries(),
    scatter: scatterSeries(),
    scatterLine: scatterLineSeries(),
    verticalArea: areaSeries(),
    verticalBoxPlot: boxPlotSeries(),
    verticalBullet: bulletSeries(),
    verticalLine: lineSeries(),
    waterfall: waterfallSeries(),
    linearTrendline: trendlineSeriesDefaults(),
    exponentialTrendline: trendlineSeriesDefaults({ style: "smooth" }),
    logarithmicTrendline: trendlineSeriesDefaults({ style: "smooth" }),
    polynomialTrendline: trendlineSeriesDefaults({ style: "smooth" }),
    powerTrendline: trendlineSeriesDefaults({ style: "smooth" }),
    movingAverageTrendline: trendlineSeriesDefaults()
  };
};
var title = function() {
  return {
    font: SANS16
  };
};
var subtitle = function() {
  return {
    font: SANS12
  };
};
var legend = function() {
  return {
    labels: {
      font: SANS12
    }
  };
};
var baseTheme = function(options2) {
  if (options2 === void 0)
    options2 = {};
  return {
    axisDefaults: axisDefaults(),
    categoryAxis: {
      majorGridLines: {
        visible: true
      }
    },
    navigator: {
      pane: {
        height: 90,
        margin: {
          top: 10
        }
      }
    },
    seriesDefaults: seriesDefaults(options2),
    title: title(),
    subtitle: subtitle(),
    legend: legend()
  };
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
function a$q(r12, t6) {
  let e3 = r12;
  for (; e3 && e3 !== t6; )
    e3 = e3.parentNode;
  return !!e3;
}
function i$r(r12, t6, e3, o9) {
  const n10 = r12[t6];
  if (n10 && Array.isArray(n10)) {
    for (let l7 of n10)
      if (!l7.type || l7.type !== o9)
        return new Error(
          `${e3} children should be Array of type ${o9.displayName}.`
        );
  }
  return null;
}
const u$m = (r12) => r12 === void 0 ? false : !r12;
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let s$j = class s {
  /**
   * @hidden
   */
  constructor(t6) {
    this.target = t6;
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let x$g = class x extends s$j {
  /**
   * @hidden
   */
  constructor(t6, s10) {
    super(s10), this.axis = t6.axis, this.dataItem = t6.dataItem, this.index = t6.index, this.text = t6.text, this.value = t6.value;
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let n$m = class n extends s$j {
  constructor() {
    super(...arguments), this.prevented = false;
  }
  /* eslint-disable max-len */
  /**
   * Prevents the default action for a specified event. In this way, the source component suppresses the built-in behavior that follows the event.
   */
  preventDefault() {
    this.prevented = true;
  }
  /**
   * Returns `true` if the event was prevented by any of its subscribers.
   *
   * @returns `true` if the default action was prevented.
   * Otherwise, returns `false`.
   */
  isDefaultPrevented() {
    return this.prevented;
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let i$q = class i extends n$m {
  /**
   * @hidden
   */
  constructor(e3, t6) {
    super(t6), this.axisRanges = e3.axisRanges, this.nativeEvent = e3.originalEvent;
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let i$p = class i2 extends s$j {
  /**
   * @hidden
   */
  constructor(e3, s10) {
    super(s10), this.axisRanges = e3.axisRanges, this.nativeEvent = e3.originalEvent;
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let r$l = class r2 extends n$m {
  /**
   * @hidden
   */
  constructor(t6, e3) {
    super(e3), this.axisRanges = t6.axisRanges, this.nativeEvent = t6.originalEvent;
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let n$l = class n2 extends s$j {
  /**
   * @hidden
   */
  constructor(t6, e3) {
    super(e3), this.value = t6.value, this.point = t6.point, this.series = t6.series, this.currentState = t6.currentState, this.nextState = t6.nextState;
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let i$o = class i3 extends n$m {
  /**
   * @hidden
   */
  constructor(e3, t6) {
    super(t6), this.series = e3.series, this.seriesIndex = e3.seriesIndex, this.pointIndex = e3.pointIndex, this.text = e3.text;
  }
  /**
   * If called, the series highlight is not shown as a result of hovering over the legend item.
   */
  preventDefault() {
    super.preventDefault();
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let i$n = class i4 extends n$m {
  /**
   * @hidden
   */
  constructor(e3, t6) {
    super(t6), this.series = e3.series, this.seriesIndex = e3.seriesIndex, this.pointIndex = e3.pointIndex, this.text = e3.text;
  }
  /**
   * If called, the series visibility is not toggled as a result of clicking the legend item.
   */
  preventDefault() {
    super.preventDefault();
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let i$m = class i5 extends n$m {
  /**
   * @hidden
   */
  constructor(e3, t6) {
    super(t6), this.series = e3.series, this.seriesIndex = e3.seriesIndex, this.pointIndex = e3.pointIndex, this.text = e3.text;
  }
  /**
   * @hidden
   */
  preventDefault() {
    super.preventDefault();
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let i$l = class i6 extends s$j {
  /**
   * Constructs the event arguments from a raw object.
   */
  constructor(t6, o9) {
    super(o9), this.from = t6.from, this.to = t6.to;
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let r$k = class r3 extends s$j {
  /**
   * @hidden
   */
  constructor(t6, s10) {
    super(s10), this.category = t6.category, this.dataItem = t6.dataItem, this.series = t6.series, this.value = t6.value, this.visual = t6.visual;
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let r$j = class r4 extends s$j {
  /**
   * @hidden
   */
  constructor(t6, s10) {
    super(s10), this.category = t6.category, this.dataItem = t6.dataItem, this.series = t6.series, this.value = t6.value, this.visual = t6.visual;
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let a$p = class a extends s$j {
  /**
   * @hidden
   */
  constructor(t6, e3) {
    super(e3), this.category = t6.category, this.nativeEvent = t6.originalEvent, this.value = t6.value, this.x = t6.x, this.y = t6.y;
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let o$j = class o extends s$j {
  /**
   * @hidden
   */
  constructor(t6, e3) {
    super(e3), this.category = t6.category, this.nativeEvent = t6.originalEvent, this.value = t6.value, this.x = t6.x, this.y = t6.y;
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let o$i = class o2 extends s$j {
  /**
   * @hidden
   */
  constructor(s10, e3) {
    super(e3);
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let i$k = class i7 extends n$m {
  /**
   * @hidden
   */
  constructor(t6, e3) {
    super(e3), this.axis = t6.axis, this.from = t6.from, this.to = t6.to;
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let i$j = class i8 extends s$j {
  /**
   * @hidden
   */
  constructor(t6, s10) {
    super(s10), this.axis = t6.axis, this.from = t6.from, this.to = t6.to;
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let i$i = class i9 extends n$m {
  /**
   * @hidden
   */
  constructor(t6, e3) {
    super(e3), this.axis = t6.axis, this.from = t6.from, this.to = t6.to;
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let r$i = class r5 extends s$j {
  // tslint:enable:max-line-length
  /**
   * @hidden
   */
  constructor(t6, e3) {
    super(e3), this.category = t6.category, this.dataItem = t6.dataItem, this.nativeEvent = t6.originalEvent, this.percentage = t6.percentage, this.point = t6.point, this.series = t6.series, this.stackValue = t6.stackValue, this.value = t6.value;
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let r$h = class r6 extends n$m {
  /**
   * @hidden
   */
  constructor(t6, e3) {
    super(e3), this.category = t6.category, this.categoryPoints = t6.categoryPoints, this.dataItem = t6.dataItem, this.nativeEvent = t6.originalEvent, this.percentage = t6.percentage, this.point = t6.point, this.series = t6.series, this.stackValue = t6.stackValue, this.value = t6.value;
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let i$h = class i10 extends n$m {
  // tslint:enable:max-line-length
  /**
   * @hidden
   */
  constructor(t6, e3) {
    super(e3), this.axisRanges = t6.axisRanges, this.delta = t6.delta, this.nativeEvent = t6.originalEvent;
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let a$o = class a2 extends s$j {
  // tslint:enable:max-line-length
  /**
   * @hidden
   */
  constructor(e3, s10) {
    super(s10), this.axisRanges = e3.axisRanges, this.nativeEvent = e3.originalEvent;
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let i$g = class i11 extends n$m {
  // tslint:enable:max-line-length
  /**
   * @hidden
   */
  constructor(t6, e3) {
    super(e3), this.axisRanges = t6.axisRanges, this.nativeEvent = t6.originalEvent;
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const t$i = {
  axisLabelClick: x$g,
  drag: i$q,
  dragEnd: i$p,
  dragStart: r$l,
  drilldownEvent: n$l,
  legendItemHover: i$o,
  legendItemClick: i$n,
  legendItemLeave: i$m,
  navigatorFilter: i$l,
  noteClick: r$k,
  noteHover: r$j,
  plotAreaClick: a$p,
  plotAreaHover: o$j,
  render: o$i,
  select: i$k,
  selectEnd: i$j,
  selectStart: i$i,
  seriesClick: r$i,
  seriesHover: r$h,
  zoom: i$h,
  zoomEnd: a$o,
  zoomStart: i$g
};
function Q$6(e3, r12, o9) {
  if (t$i[e3])
    return new t$i[e3](r12, o9);
}
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let s$i = class s2 {
  /**
   * @hidden
   */
  constructor(t6, n10) {
    this.sender = t6, this.syntheticEvent = n10;
  }
};
function o$h(e3, t6) {
  return new s$i(e3, t6);
}
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const r$g = (t6) => `${t6.fontWeight} ${t6.fontSize} ${t6.fontFamily}`, d$o = (t6) => window.getComputedStyle(t6).backgroundColor, v$9 = (t6) => t6.toLowerCase().charCodeAt(0) - 97, u$l = (t6) => {
  const e3 = t6.match(/series-([a-z])$/);
  if (e3 !== null)
    return v$9(e3[1]);
  const s10 = t6.split("--series-")[1];
  return parseInt(s10, 10) - 1;
}, m$d = 30, p$s = () => {
  let t6 = `
      <div class="k-var--series-a"></div>
      <div class="k-var--series-b"></div>
      <div class="k-var--series-c"></div>
      <div class="k-var--series-d"></div>
      <div class="k-var--series-e"></div>
      <div class="k-var--series-f"></div>
`;
  for (let e3 = 0; e3 < m$d; e3++)
    t6 += `
      <div class="k-var--series-${e3 + 1}"></div>`;
  return t6;
}, f$e = `
    <div class="k-var--primary"></div>
    <div class="k-var--base"></div>
    <div class="k-var--background"></div>

    <div class="k-var--normal-background"></div>
    <div class="k-var--normal-text-color"></div>
    <div class="k-var--hover-background"></div>
    <div class="k-var--hover-text-color"></div>
    <div class="k-var--selected-background"></div>
    <div class="k-var--selected-text-color"></div>
    <div class="k-var--chart-error-bars-background"></div>
    <div class="k-var--chart-notes-background"></div>
    <div class="k-var--chart-notes-border"></div>
    <div class="k-var--chart-notes-lines"></div>
    <div class="k-var--chart-crosshair-background"></div>

    <div class="k-var--chart-inactive"></div>
    <div class="k-var--chart-major-lines"></div>
    <div class="k-var--chart-minor-lines"></div>
    <div class="k-var--chart-area-opacity"></div>
    <div class="k-var--chart-area-inactive-opacity"></div>
    <div class="k-var--chart-line-inactive-opacity"></div>

    <div class="k-widget k-chart">
        <div class="k-var--chart-font"></div>
        <div class="k-var--chart-title-font"></div>
        <div class="k-var--chart-pane-title-font"></div>
        <div class="k-var--chart-label-font"></div>
    </div>

    <div class="k-var--series-unset"></div>
    <div class="k-var--series">
      ${p$s()}
    </div>
`;
let y$9 = class y {
  constructor(e3) {
    this.store = e3;
  }
  setStyle(e3, s10) {
    this.store.dispatch({ type: "set", payload: { field: e3, value: s10 } });
  }
  setColors() {
    this.mapColor("axisDefaults.crosshair.color", "chart-crosshair-background"), this.mapColor("axisDefaults.labels.color", "normal-text-color"), this.mapColor("axisDefaults.line.color", "chart-major-lines"), this.mapColor("axisDefaults.majorGridLines.color", "chart-major-lines"), this.mapColor("axisDefaults.minorGridLines.color", "chart-minor-lines"), this.mapColor("axisDefaults.notes.icon.background", "chart-notes-background"), this.mapColor("axisDefaults.notes.icon.border.color", "chart-notes-border"), this.mapColor("axisDefaults.notes.line.color", "chart-notes-lines"), this.mapColor("axisDefaults.title.color", "normal-text-color"), this.mapColor("chartArea.background", "background"), this.mapColor("legend.inactiveItems.labels.color", "chart-inactive"), this.mapColor("legend.inactiveItems.markers.color", "chart-inactive"), this.mapColor("legend.labels.color", "normal-text-color"), this.mapColor("seriesDefaults.boxPlot.downColor", "chart-major-lines"), this.mapColor("seriesDefaults.boxPlot.mean.color", "base"), this.mapColor("seriesDefaults.boxPlot.median.color", "base"), this.mapColor("seriesDefaults.boxPlot.whiskers.color", "primary"), this.mapColor("seriesDefaults.bullet.target.color", "normal-text-color"), this.mapColor("seriesDefaults.candlestick.downColor", "normal-text-color"), this.mapColor("seriesDefaults.candlestick.line.color", "normal-text-color"), this.mapColor("seriesDefaults.errorBars.color", "chart-error-bars-background"), this.mapColor("seriesDefaults.horizontalWaterfall.line.color", "chart-major-lines"), this.mapColor("seriesDefaults.icon.border.color", "chart-major-lines"), this.mapColor("seriesDefaults.labels.background", "background"), this.mapColor("seriesDefaults.labels.color", "normal-text-color"), this.mapColor("seriesDefaults.notes.icon.background", "chart-notes-background"), this.mapColor("seriesDefaults.notes.icon.border.color", "chart-notes-border"), this.mapColor("seriesDefaults.notes.line.color", "chart-notes-lines"), this.mapColor("seriesDefaults.verticalBoxPlot.downColor", "chart-major-lines"), this.mapColor("seriesDefaults.verticalBoxPlot.mean.color", "base"), this.mapColor("seriesDefaults.verticalBoxPlot.median.color", "base"), this.mapColor("seriesDefaults.verticalBoxPlot.whiskers.color", "primary"), this.mapColor("seriesDefaults.verticalBullet.target.color", "normal-text-color"), this.mapColor("seriesDefaults.waterfall.line.color", "chart-major-lines"), this.mapColor("title.color", "normal-text-color"), this.mapColor("subtitle.color", "normal-text-color");
    const e3 = parseFloat(this.queryStyle("chart-area-opacity").opacity);
    isNaN(e3) || (this.setStyle("seriesDefaults.area.opacity", e3), this.setStyle("seriesDefaults.radarArea.opacity", e3), this.setStyle("seriesDefaults.verticalArea.opacity", e3), this.setStyle("seriesDefaults.labels.opacity", e3)), this.setInactiveOpacity(["area", "verticalArea"], "chart-area-inactive-opacity"), this.setInactiveOpacity(["line", "verticalLine"], "chart-line-inactive-opacity");
  }
  setFonts() {
    const e3 = r$g(this.queryStyle("chart-font")), s10 = r$g(this.queryStyle("chart-title-font")), a9 = r$g(this.queryStyle("chart-pane-title-font")), o9 = r$g(this.queryStyle("chart-label-font"));
    this.setStyle("axisDefaults.labels.font", o9), this.setStyle("axisDefaults.notes.label.font", e3), this.setStyle("axisDefaults.title.font", e3), this.setStyle("legend.labels.font", e3), this.setStyle("seriesDefaults.labels.font", o9), this.setStyle("seriesDefaults.notes.label.font", e3), this.setStyle("title.font", s10), this.setStyle("subtitle.font", a9), this.setStyle("paneDefaults.title.font", a9);
  }
  setSeriesColors() {
    const e3 = this.element, s10 = [].slice.call(e3.querySelectorAll(".k-var--series div")), a9 = d$o(e3.querySelector(".k-var--series-unset")), o9 = s10.reduce(
      (l7, i16) => {
        const h3 = u$l(i16.className), c6 = d$o(i16);
        return c6 !== a9 && (l7[h3] = c6), l7;
      },
      []
      // Will populate the series colors in this array
    );
    this.setStyle("seriesColors", o9);
  }
  mapColor(e3, s10) {
    this.setStyle(e3, this.queryStyle(s10).backgroundColor);
  }
  queryStyle(e3) {
    const s10 = this.element;
    return window.getComputedStyle(s10.querySelector(`.k-var--${e3}`));
  }
  setInactiveOpacity(e3, s10) {
    const a9 = parseFloat(this.queryStyle(s10).opacity);
    !isNaN(a9) && a9 < 1 && e3.forEach(
      (o9) => this.setStyle(`seriesDefaults.${o9}.highlight.inactiveOpacity`, a9)
    );
  }
};
const C$f = (t6, e3, s10) => {
  const a9 = new y$9(t6);
  if (typeof s10 == "undefined") {
    t6.dispatch({ type: "push", payload: baseTheme() });
    return;
  }
  const o9 = a9.element = s10.createElement("div");
  o9.style.display = "none", o9.innerHTML = f$e, s10.body.appendChild(o9);
  try {
    t6.dispatch({ type: "push", payload: baseTheme() }), a9.setColors(), a9.setFonts(), a9.setSeriesColors();
  } finally {
    s10.body.removeChild(a9.element), delete a9.element, e3();
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const l$k = 1e3 / 60, T$9 = (i16) => {
  let o9, s10, t6 = [];
  const n10 = () => o9, c6 = (e3) => {
    o9 = i16(o9, e3), e$C && (window.clearTimeout(s10), s10 = window.setTimeout(() => t6.forEach((r12) => r12()), l$k));
  }, a9 = (e3) => (t6.push(e3), () => t6 = t6.filter((r12) => r12 !== e3));
  return c6({}), { getState: n10, dispatch: c6, subscribe: a9 };
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const u$k = (t6, e3) => e3.chartCollectionIdxKey ? c$i.collectionConfigurationItem(t6, e3) : e3.chartKey ? c$i.configurationItem(t6, e3) : {}, a$n = (t6, e3) => {
  if (e3.type)
    switch (e3.type) {
      case "set":
        return c$i.themeItem(t6, e3);
      case "push":
        return Object.assign(t6, e3.payload);
      default:
        return t6;
    }
  else
    return {};
}, p$r = (t6, e3) => {
  if (e3.type)
    switch (e3.type) {
      case "add":
        return [...t6, e3.payload];
      case "remove":
        return t6.filter((l7) => l7 !== e3.payload);
      default:
        return t6;
    }
  else
    return [];
}, c$i = {
  configurationItem(t6, e3) {
    return Object.assign(t6, {
      [e3.chartKey]: e3.payload
    });
  },
  collectionConfigurationItem(t6, e3) {
    let l7 = false;
    const [o9, n10] = e3.chartCollectionIdxKey.split("_"), i16 = t6[o9].map((s10, r12) => parseInt(n10, 10) === r12 ? (l7 = true, e3.payload) : s10);
    return l7 === false && i16.splice(parseInt(n10, 10), 0, e3.payload), Object.assign(t6, {
      [o9]: i16
    });
  },
  themeItem(t6, e3) {
    let l7 = {}, o9 = Object.assign(l7, t6);
    const { field: n10, value: i16 } = e3.payload, s10 = n10.split(".");
    let r12 = s10.shift();
    for (; s10.length > 0; )
      l7 = l7[r12] = l7[r12] || {}, r12 = s10.shift();
    return l7[r12] = i16, o9;
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let h$a = class h {
  /**
   * @hidden
   */
  constructor(t6, s10) {
    this.value = t6.value, this.category = t6.category, this.categoryIndex = t6.categoryIx, this.series = t6.series, this.dataItem = t6.dataItem, this.percentage = t6.percentage, this.runningTotal = t6.runningTotal, this.total = t6.total, this.low = t6.low, this.high = t6.high, this.xLow = t6.xLow, this.xHigh = t6.xHigh, this.yLow = t6.yLow, this.yHigh = t6.yHigh, this.point = t6, this.format = ((t6.options || {}).tooltip || {}).format || s10;
  }
  get formattedValue() {
    return this.format ? this.point.formatValue(this.format) : String(this.value);
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const u$j = "k-chart-shared-tooltip-marker", E$a = (l7) => {
  const { categoryText: r12, colorMarker: n10, colspan: a9, nameColumn: o9, points: c6 } = l7, m3 = (t6, s10) => /* @__PURE__ */ reactExports.createElement("tr", { key: s10 }, n10 && /* @__PURE__ */ reactExports.createElement("td", null, /* @__PURE__ */ reactExports.createElement(
    "span",
    {
      className: u$j,
      style: { backgroundColor: t6.series.color }
    }
  )), o9 && /* @__PURE__ */ reactExports.createElement("td", null, t6.series.name), /* @__PURE__ */ reactExports.createElement("td", { dangerouslySetInnerHTML: { __html: t6.formattedValue } }));
  return /* @__PURE__ */ reactExports.createElement("table", null, /* @__PURE__ */ reactExports.createElement("thead", null, /* @__PURE__ */ reactExports.createElement("tr", null, /* @__PURE__ */ reactExports.createElement("th", { colSpan: a9 }, r12))), /* @__PURE__ */ reactExports.createElement("tbody", null, c6.map(m3)));
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const p$q = (i16, s10, n10) => {
  i16.style.transitionDuration = "", s10 && i16.classList.remove(...s10.split(" ")), s10 && i16.classList.remove(...n10.split(" "));
}, L$b = typeof window != "undefined" && /Firefox/.test(window.navigator.userAgent), A$b = (i16, s10, n10, r12, c6, d8) => {
  if (n10 === 0)
    return c6();
  const o9 = r$r(l$l.slide({ direction: s10, type: r12, c: d8 })), a9 = r$r(l$l.slideActive({ direction: s10, type: r12, c: d8 })), f4 = (t6) => {
    t6.target === i16 && (i16.removeEventListener("transitionend", f4), p$q(i16, o9, a9), r12 === "exit" ? i16.style.display = "none" : i16.style.display = "", c6());
  };
  i16.addEventListener("transitionend", f4);
  const u5 = i16.ownerDocument;
  if (!u5)
    return;
  const e3 = u5.defaultView;
  if (!e3)
    return;
  const l7 = () => {
    p$q(i16, o9, a9), o9 && i16.classList.add(...o9.split(" ").filter((t6) => t6)), e3.requestAnimationFrame(() => {
      i16.style.transitionDuration = n10 + "ms", i16.classList.add(...a9.split(" ").filter((t6) => t6));
    });
  };
  L$b ? e3.requestAnimationFrame(l7) : l7();
};
const p$p = {
  "bottom": "bottom",
  "center": "center",
  "middle": "middle",
  "left": "left",
  "right": "right",
  "top": "top"
};
var align = function(options2) {
  var anchorRect = options2.anchorRect;
  var anchorAlign = options2.anchorAlign;
  var elementRect = options2.elementRect;
  var elementAlign = options2.elementAlign;
  var margin = options2.margin;
  if (margin === void 0)
    margin = {};
  var anchorHorizontal = anchorAlign.horizontal;
  var anchorVertical = anchorAlign.vertical;
  var elementHorizontal = elementAlign.horizontal;
  var elementVertical = elementAlign.vertical;
  var horizontalMargin = margin.horizontal || 0;
  var verticalMargin = margin.vertical || 0;
  var top = anchorRect.top;
  var left = anchorRect.left;
  if (anchorVertical === p$p.bottom) {
    top += anchorRect.height;
  }
  if (anchorVertical === p$p.center || anchorVertical === p$p.middle) {
    top += Math.round(anchorRect.height / 2);
  }
  if (elementVertical === p$p.bottom) {
    top -= elementRect.height;
    verticalMargin *= -1;
  }
  if (elementVertical === p$p.center || elementVertical === p$p.middle) {
    top -= Math.round(elementRect.height / 2);
    verticalMargin *= -1;
  }
  if (anchorHorizontal === p$p.right) {
    left += anchorRect.width;
  }
  if (anchorHorizontal === p$p.center || anchorHorizontal === p$p.middle) {
    left += Math.round(anchorRect.width / 2);
  }
  if (elementHorizontal === p$p.right) {
    left -= elementRect.width;
    horizontalMargin *= -1;
  }
  if (elementHorizontal === p$p.center || elementHorizontal === p$p.middle) {
    left -= Math.round(elementRect.width / 2);
    horizontalMargin *= -1;
  }
  return {
    top: top + verticalMargin,
    left: left + horizontalMargin
  };
};
function addScroll(rect, scroll) {
  return {
    top: rect.top + scroll.y,
    left: rect.left + scroll.x,
    height: rect.height,
    width: rect.width
  };
}
function ownerDocument(element) {
  return element.ownerDocument || element.document || element;
}
var getWindow$1 = function(element) {
  return ownerDocument(element).defaultView;
};
var getDocument = function(element) {
  return ownerDocument(element).documentElement;
};
var cachedWidth = 0;
function scrollbarWidth() {
  if (!cachedWidth && typeof document !== "undefined") {
    var div = document.createElement("div");
    div.style.cssText = "overflow:scroll;overflow-x:hidden;zoom:1;clear:both;display:block";
    div.innerHTML = "&nbsp;";
    document.body.appendChild(div);
    cachedWidth = div.offsetWidth - div.scrollWidth;
    document.body.removeChild(div);
  }
  return cachedWidth;
}
function windowViewport(element) {
  var win = getWindow$1(element);
  var document2 = getDocument(element);
  var result = {
    height: win.innerHeight,
    width: win.innerWidth
  };
  if (document2.scrollHeight - document2.clientHeight > 0) {
    result.width -= scrollbarWidth();
  }
  return result;
}
var boundingOffset = function(element) {
  if (!element.getBoundingClientRect) {
    var viewport = windowViewport(element);
    return {
      bottom: viewport.height,
      left: 0,
      right: viewport.width,
      top: 0
    };
  }
  var ref2 = element.getBoundingClientRect();
  var bottom = ref2.bottom;
  var left = ref2.left;
  var right = ref2.right;
  var top = ref2.top;
  return {
    bottom,
    left,
    right,
    top
  };
};
var offsetParent = function(element) {
  var offsetParent2 = element.offsetParent;
  while (offsetParent2 && offsetParent2.style.position === "static") {
    offsetParent2 = offsetParent2.offsetParent;
  }
  return offsetParent2 || getDocument(element);
};
var rectOfHiddenElement = function(element) {
  var ref2 = element.style;
  var display = ref2.display;
  var left = ref2.left;
  var position2 = ref2.position;
  element.style.display = "";
  element.style.left = "-10000px";
  element.style.position = "absolute";
  var rect = element.getBoundingClientRect();
  element.style.display = display;
  element.style.left = left;
  element.style.position = position2;
  return rect;
};
var offset$1 = function(element) {
  var rect = element.getBoundingClientRect();
  var left = rect.left;
  var top = rect.top;
  if (!rect.height && !rect.width) {
    rect = rectOfHiddenElement(element);
  }
  return {
    top,
    left,
    height: rect.height,
    width: rect.width
  };
};
function parents(element, until) {
  var result = [];
  var next = element.parentNode;
  while (next) {
    result.push(next);
    if (next === until) {
      break;
    }
    next = next.parentNode;
  }
  return result;
}
function scrollPosition(element) {
  var documentElement = getDocument(element);
  var win = getWindow$1(element);
  return {
    x: win.pageXOffset || documentElement.scrollLeft || 0,
    y: win.pageYOffset || documentElement.scrollTop || 0
  };
}
function elementScrollPosition$1(element) {
  if (element === (element.ownerDocument || {}).body) {
    return scrollPosition(element);
  }
  return {
    x: element.scrollLeft,
    y: element.scrollTop
  };
}
function parentScrollPosition(element) {
  var parent = offsetParent(element);
  return parent ? elementScrollPosition$1(parent) : { x: 0, y: 0 };
}
var position$1 = function(element, parent) {
  var win = getWindow$1(element);
  var elementStyles2 = win.getComputedStyle(element);
  var offset2 = offset$1(element);
  var parentElement = parent || offsetParent(element);
  var ownerDocument2 = element.ownerDocument;
  var useRelative = parentElement !== ownerDocument2.body && parentElement !== ownerDocument2.documentElement;
  var parentOffset = { top: 0, left: 0 };
  if (elementStyles2.position !== "fixed" && useRelative) {
    var parentStyles = win.getComputedStyle(parentElement);
    parentOffset = offset$1(parentElement);
    parentOffset.top += parseInt(parentStyles.borderTopWidth, 10);
    parentOffset.left += parseInt(parentStyles.borderLeftWidth, 10);
  }
  return {
    top: offset2.top - parentOffset.top,
    left: offset2.left - parentOffset.left,
    height: offset2.height,
    width: offset2.width
  };
};
function offsetParentScrollPosition(offsetParentElement, element) {
  return (
    // eslint-disable-line no-arrow-condition
    offsetParentElement ? elementScrollPosition$1(offsetParentElement) : parentScrollPosition(element)
  );
}
function positionWithScroll(element, parent, scale) {
  if (scale === void 0)
    scale = 1;
  var offsetParentElement = parent ? offsetParent(parent) : null;
  var ref2 = position$1(element, offsetParentElement);
  var top = ref2.top;
  var left = ref2.left;
  var height = ref2.height;
  var width = ref2.width;
  var ref$1 = offsetParentScrollPosition(offsetParentElement, element);
  var x3 = ref$1.x;
  var y4 = ref$1.y;
  var ownerDocument2 = element.ownerDocument;
  var positionScale = offsetParentElement === ownerDocument2.body || offsetParentElement === ownerDocument2.documentElement ? 1 : scale;
  return {
    top: top + y4 * positionScale,
    left: left + x3 * positionScale,
    height,
    width
  };
}
function removeScroll(rect, scroll) {
  return {
    top: rect.top - scroll.y,
    left: rect.left - scroll.x,
    height: rect.height,
    width: rect.width
  };
}
const d$n = {
  "fit": "fit",
  "flip": "flip",
  "none": "none"
};
var fit = function(position2, size, viewPortSize) {
  var output = 0;
  if (position2 + size > viewPortSize) {
    output = viewPortSize - (position2 + size);
  }
  if (position2 < 0) {
    output = -position2;
  }
  return output;
};
var flip = function(ref2) {
  var offset2 = ref2.offset;
  var size = ref2.size;
  var anchorSize = ref2.anchorSize;
  var viewPortSize = ref2.viewPortSize;
  var anchorAlignPoint = ref2.anchorAlignPoint;
  var elementAlignPoint = ref2.elementAlignPoint;
  var margin = ref2.margin;
  var output = 0;
  var isPositionCentered = elementAlignPoint === p$p.center || elementAlignPoint === p$p.middle;
  var isOriginCentered = anchorAlignPoint === p$p.center || anchorAlignPoint === p$p.middle;
  var marginToAdd = 2 * margin;
  if (elementAlignPoint !== anchorAlignPoint && !isPositionCentered && !isOriginCentered) {
    var isBeforeAnchor = anchorAlignPoint === p$p.top || anchorAlignPoint === p$p.left;
    if (offset2 < 0 && isBeforeAnchor) {
      output = size + anchorSize + marginToAdd;
      if (offset2 + output + size > viewPortSize) {
        output = 0;
      }
    } else if (offset2 >= 0 && !isBeforeAnchor) {
      if (offset2 + size > viewPortSize) {
        output += -(anchorSize + size + marginToAdd);
      }
      if (offset2 + output < 0) {
        output = 0;
      }
    }
  }
  return output;
};
var restrictToView = function(options2) {
  var anchorRect = options2.anchorRect;
  var anchorAlign = options2.anchorAlign;
  var elementRect = options2.elementRect;
  var elementAlign = options2.elementAlign;
  var collisions = options2.collisions;
  var viewPort = options2.viewPort;
  var margin = options2.margin;
  if (margin === void 0)
    margin = {};
  var elementTop = elementRect.top;
  var elementLeft = elementRect.left;
  var elementHeight = elementRect.height;
  var elementWidth = elementRect.width;
  var viewPortHeight = viewPort.height;
  var viewPortWidth = viewPort.width;
  var horizontalMargin = margin.horizontal || 0;
  var verticalMargin = margin.vertical || 0;
  var left = 0;
  var top = 0;
  var isVerticalFit = collisions.vertical === d$n.fit;
  var isHorizontalFit = collisions.horizontal === d$n.fit;
  var isVerticalFlip = collisions.vertical === d$n.flip;
  var isHorizontalFlip = collisions.horizontal === d$n.flip;
  if (isVerticalFit) {
    top += fit(elementTop, elementHeight, viewPortHeight);
  }
  if (isHorizontalFit) {
    left += fit(elementLeft, elementWidth, viewPortWidth);
  }
  if (isVerticalFlip) {
    top += flip({
      margin: verticalMargin,
      offset: elementTop,
      size: elementHeight,
      anchorSize: anchorRect.height,
      viewPortSize: viewPortHeight,
      anchorAlignPoint: anchorAlign.vertical,
      elementAlignPoint: elementAlign.vertical
    });
  }
  if (isHorizontalFlip) {
    left += flip({
      margin: horizontalMargin,
      offset: elementLeft,
      size: elementWidth,
      anchorSize: anchorRect.width,
      viewPortSize: viewPortWidth,
      anchorAlignPoint: anchorAlign.horizontal,
      elementAlignPoint: elementAlign.horizontal
    });
  }
  var flippedVertical = isVerticalFlip && top !== 0;
  var flippedHorizontal = isHorizontalFlip && left !== 0;
  var fittedVertical = isVerticalFit && top !== 0;
  var fittedHorizontal = isHorizontalFit && left !== 0;
  return {
    flipped: flippedHorizontal || flippedVertical,
    fitted: fittedVertical || fittedHorizontal,
    flip: {
      horizontal: flippedHorizontal,
      vertical: flippedVertical
    },
    fit: {
      horizontal: fittedHorizontal,
      vertical: fittedVertical
    },
    offset: {
      left,
      top
    }
  };
};
function siblings(element) {
  var result = [];
  var sibling = element.parentNode.firstElementChild;
  while (sibling) {
    if (sibling !== element) {
      result.push(sibling);
    }
    sibling = sibling.nextElementSibling;
  }
  return result;
}
function siblingContainer(anchor, container) {
  var parentElements = parents(anchor);
  var containerElement = container;
  var siblingElements;
  var result;
  while (containerElement) {
    siblingElements = siblings(containerElement);
    result = parentElements.reduce(
      function(list, p6) {
        return list.concat(siblingElements.filter(function(s10) {
          return s10 === p6;
        }));
      },
      []
    )[0];
    if (result) {
      break;
    }
    containerElement = containerElement.parentElement;
  }
  return result;
}
var eitherRect = function(rect, offset2) {
  if (!rect) {
    return { height: 0, left: offset2.left, top: offset2.top, width: 0 };
  }
  return rect;
};
var scaleRect = function(rect, scale) {
  if (!rect || scale === 1) {
    return rect;
  }
  return {
    height: rect.height / scale,
    left: rect.left / scale,
    top: rect.top / scale,
    width: rect.width / scale
  };
};
var removeStackingOffset = function(rect, stackingOffset) {
  if (!stackingOffset) {
    return rect;
  }
  var result = {
    height: rect.height,
    left: rect.left - stackingOffset.left,
    top: rect.top - stackingOffset.top,
    width: rect.width
  };
  return result;
};
function memoize(fun) {
  var result;
  var called = false;
  return function() {
    var args = [], len = arguments.length;
    while (len--)
      args[len] = arguments[len];
    if (called) {
      return result;
    }
    result = fun.apply(void 0, args);
    called = true;
    return result;
  };
}
var hasRelativeStackingContext = memoize(function(elementSource) {
  if (!canUseDOM()) {
    return false;
  }
  var currentDocument = elementSource ? elementSource.ownerDocument : document;
  if (!currentDocument || !currentDocument.body) {
    return false;
  }
  var top = 10;
  var parent = currentDocument.createElement("div");
  parent.style.transform = "matrix(10, 0, 0, 10, 0, 0)";
  parent.innerHTML = '<div style="position: fixed; top: ' + top + 'px;">child</div>';
  currentDocument.body.appendChild(parent);
  var isDifferent = parent.children[0].getBoundingClientRect().top !== top;
  currentDocument.body.removeChild(parent);
  return isDifferent;
});
var canUseDOM = function() {
  return Boolean(
    // from fbjs
    typeof window !== "undefined" && window.document && window.document.createElement
  );
};
var utils = {
  eitherRect,
  scaleRect,
  removeStackingOffset,
  hasRelativeStackingContext,
  canUseDOM
};
var STYLES = [
  "font-size",
  "font-family",
  "font-stretch",
  "font-style",
  "font-weight",
  "line-height"
];
var addOffset = function(current2, addition) {
  return {
    left: current2.left + addition.left,
    top: current2.top + addition.top
  };
};
var getWindow = function() {
  return utils.canUseDOM() ? window : null;
};
var getFontStyles = function(el2) {
  var window2 = getWindow();
  if (!window2 || !el2) {
    return [];
  }
  var computedStyles = window2.getComputedStyle(el2);
  return STYLES.map(function(font2) {
    return { key: font2, value: computedStyles[font2] };
  });
};
var hasOffsetParent = function(el2) {
  if (!el2) {
    return false;
  }
  return Boolean(el2.offsetParent);
};
var offset = function(el2) {
  if (!el2) {
    return null;
  }
  return offset$1(el2);
};
var offsetAtPoint = function(element, currentLocation) {
  if (!element) {
    return null;
  }
  var ref2 = element.style;
  var left = ref2.left;
  var top = ref2.top;
  var transition = ref2.transition;
  element.style.transition = "none";
  element.style.left = currentLocation.left + "px";
  element.style.top = currentLocation.top + "px";
  var currentOffset = offset$1(element);
  element.style.left = left;
  element.style.top = top;
  element.offsetHeight;
  element.style.transition = transition;
  return currentOffset;
};
var position = function(element, popupElement, scale) {
  if (!element || !popupElement) {
    return null;
  }
  var currentScale = scale || 1;
  return positionWithScroll(element, popupElement, currentScale);
};
var OVERFLOW_REGEXP = /auto|scroll/;
var overflowElementStyle = function(element) {
  return "" + element.style.overflow + element.style.overflowX + element.style.overflowY;
};
var overflowComputedStyle = function(element) {
  var styles = window.getComputedStyle(element);
  return "" + styles.overflow + styles.overflowX + styles.overflowY;
};
var overflowStyle = function(element) {
  return overflowElementStyle(element) || overflowComputedStyle(element);
};
var scrollableParents = function(element) {
  var parentElements = [];
  if (!utils.canUseDOM()) {
    return parentElements;
  }
  var parent = element.parentElement;
  while (parent) {
    if (OVERFLOW_REGEXP.test(overflowStyle(parent)) || parent.hasAttribute("data-scrollable")) {
      parentElements.push(parent);
    }
    parent = parent.parentElement;
  }
  parentElements.push(window);
  return parentElements;
};
var getRelativeContextElement = function(el2) {
  if (!el2 || !utils.hasRelativeStackingContext()) {
    return null;
  }
  var parent = el2.parentElement;
  while (parent) {
    if (window.getComputedStyle(parent).transform !== "none") {
      return parent;
    }
    parent = parent.parentElement;
  }
  return null;
};
var stackingElementOffset = function(el2) {
  var relativeContextElement = getRelativeContextElement(el2);
  if (!relativeContextElement) {
    return null;
  }
  return offset$1(relativeContextElement);
};
var stackingElementScroll = function(el2) {
  var relativeContextElement = getRelativeContextElement(el2);
  if (!relativeContextElement) {
    return { x: 0, y: 0 };
  }
  return {
    x: relativeContextElement.scrollLeft,
    y: relativeContextElement.scrollTop
  };
};
var stackingElementViewPort = function(el2) {
  var relativeContextElement = getRelativeContextElement(el2);
  if (!relativeContextElement) {
    return null;
  }
  return {
    height: relativeContextElement.scrollHeight,
    width: relativeContextElement.scrollWidth
  };
};
var useRelativePosition = function(el2) {
  return Boolean(getRelativeContextElement(el2));
};
var zoomLevel = function() {
  if (!utils.canUseDOM()) {
    return 1;
  }
  return parseFloat((document.documentElement.clientWidth / window.innerWidth).toFixed(2)) || 1;
};
var isZoomed = function() {
  return zoomLevel() > 1;
};
var zIndex = function(anchor, container) {
  if (!anchor || !utils.canUseDOM()) {
    return null;
  }
  var sibling = siblingContainer(anchor, container);
  if (!sibling) {
    return null;
  }
  var result = [anchor].concat(parents(anchor, sibling)).reduce(
    function(index2, p6) {
      var zIndexStyle = p6.style.zIndex || window.getComputedStyle(p6).zIndex;
      var current2 = parseInt(zIndexStyle, 10);
      return current2 > index2 ? current2 : index2;
    },
    0
  );
  return result ? result + 1 : null;
};
var domUtils = {
  addOffset,
  addScroll,
  align,
  boundingOffset,
  getFontStyles,
  getWindow,
  hasOffsetParent,
  offset,
  offsetAtPoint,
  position,
  removeScroll,
  restrictToView,
  scrollPosition,
  scrollableParents,
  getRelativeContextElement,
  stackingElementOffset,
  stackingElementScroll,
  stackingElementViewPort,
  useRelativePosition,
  windowViewPort: windowViewport,
  zoomLevel,
  isZoomed,
  zIndex
};
var absoluteRect = function(anchor, element, offset2, scale) {
  var scrollPos = elementScrollPosition(anchor, element);
  var rect = utils.eitherRect(domUtils.offset(anchor), offset2);
  var stackScale = 2 * scale;
  var stackScroll = domUtils.stackingElementScroll(element);
  if (scale !== 1 && stackScroll) {
    stackScroll.x /= stackScale;
    stackScroll.y /= stackScale;
  }
  var stackOffset = domUtils.stackingElementOffset(element);
  if (scale !== 1 && stackOffset) {
    stackOffset.left /= stackScale;
    stackOffset.top /= stackScale;
  }
  return domUtils.removeScroll(
    domUtils.addScroll(
      utils.removeStackingOffset(
        utils.scaleRect(rect, scale),
        stackOffset
      ),
      stackScroll
    ),
    scrollPos
  );
};
var relativeRect = function(anchor, element, offset2, scale) {
  var rect = utils.eitherRect(domUtils.position(anchor, element, scale), offset2);
  return utils.scaleRect(rect, scale);
};
var elementScrollPosition = function(anchor, element) {
  return anchor ? { x: 0, y: 0 } : domUtils.scrollPosition(element);
};
var alignElement = function(settings) {
  var anchor = settings.anchor;
  var element = settings.element;
  var anchorAlign = settings.anchorAlign;
  var elementAlign = settings.elementAlign;
  var margin = settings.margin;
  var offset2 = settings.offset;
  var positionMode = settings.positionMode;
  var scale = settings.scale;
  var currentScale = scale || 1;
  var fixedMode = positionMode === "fixed" || !domUtils.hasOffsetParent(element);
  var anchorRect = fixedMode ? absoluteRect(anchor, element, offset2, currentScale) : relativeRect(anchor, element, offset2, currentScale);
  var elementRect = utils.scaleRect(domUtils.offset(element), currentScale);
  var result = domUtils.align({
    anchorAlign,
    anchorRect,
    elementAlign,
    elementRect,
    margin
  });
  return result;
};
var positionElement = function(settings) {
  var anchor = settings.anchor;
  var currentLocation = settings.currentLocation;
  var element = settings.element;
  var anchorAlign = settings.anchorAlign;
  var elementAlign = settings.elementAlign;
  var collisions = settings.collisions;
  var margin = settings.margin;
  var scale = settings.scale;
  var currentScale = scale || 1;
  var elementOffset2 = domUtils.offsetAtPoint(element, currentLocation);
  var elementRect = utils.scaleRect(elementOffset2, currentScale);
  var anchorOffset = utils.scaleRect(domUtils.offset(anchor), currentScale);
  var anchorRect = utils.eitherRect(anchorOffset, currentLocation);
  var viewPort = settings.viewPort || domUtils.windowViewPort(element);
  viewPort.width = viewPort.width / currentScale;
  viewPort.height = viewPort.height / currentScale;
  var result = domUtils.restrictToView({
    anchorAlign,
    anchorRect,
    collisions,
    elementAlign,
    elementRect,
    margin,
    viewPort
  });
  var offset2 = domUtils.addOffset(currentLocation, result.offset);
  return {
    flip: result.flip,
    flipped: result.flipped,
    fit: result.fit,
    fitted: result.fitted,
    offset: offset2
  };
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const d$m = 16.666666666666668, g$e = function(u5, s10, t6 = {}) {
  let e3, n10, l7, r12, i16 = 0;
  t6 = t6 || {};
  const c6 = function() {
    i16 = t6.leading === false ? 0 : (/* @__PURE__ */ new Date()).getTime(), e3 = void 0, r12 = u5.apply(n10, l7), e3 || (n10 = l7 = null);
  };
  return function() {
    const o9 = (/* @__PURE__ */ new Date()).getTime();
    !i16 && t6.leading === false && (i16 = o9);
    const a9 = s10 - (o9 - i16);
    return n10 = void 0, l7 = arguments, a9 <= 0 || a9 > s10 ? (e3 && (clearTimeout(e3), e3 = void 0), i16 = o9, r12 = u5.apply(n10, l7), e3 || (n10 = l7 = null)) : !e3 && t6.trailing !== false && (e3 = window.setTimeout(c6, a9)), r12;
  };
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const e$r = {
  name: "@progress/kendo-react-popup",
  productName: "KendoReact",
  productCodes: ["KENDOUIREACT", "KENDOUICOMPLETE"],
  publishDate: 1728906368,
  version: "",
  licensingDocsUrl: "https://www.telerik.com/kendo-react-ui/components/my-license/"
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const S$a = 100, U$4 = 1;
function w$c(b2, o9) {
  if (b2 === o9)
    return true;
  if (!!b2 != !!o9)
    return false;
  const t6 = Object.getOwnPropertyNames(b2), s10 = Object.getOwnPropertyNames(o9);
  if (t6.length !== s10.length)
    return false;
  for (let n10 = 0; n10 < t6.length; n10++) {
    const i16 = t6[n10];
    if (b2[i16] !== o9[i16])
      return false;
  }
  return true;
}
const K$6 = {
  left: -1e3,
  top: 0
}, y$8 = class y2 extends reactExports.Component {
  constructor(o9) {
    super(o9), this.context = 0, this.state = { current: "hidden", previous: "hidden", props: {} }, this._popup = null, this.show = (t6) => {
      window == null || window.addEventListener("mousedown", this.handleMouseDown), this.setPosition(t6), this.animate(t6.firstChild, "enter", this.onOpened), this.setState({ current: "shown", previous: this.state.current });
    }, this.setPosition = (t6) => {
      const { anchorAlign: s10, popupAlign: n10, collision: i16, offset: a9, anchor: l7, margin: h3, scale: c6, positionMode: u5 } = this.props, { width: m3, height: f4 } = t6.style;
      t6.style.width = t6.offsetWidth + "px", t6.style.height = t6.offsetHeight + "px";
      const g6 = alignElement({
        anchor: l7,
        anchorAlign: s10,
        element: t6,
        elementAlign: n10,
        offset: a9,
        margin: h3,
        positionMode: u5,
        scale: c6
      }), r12 = positionElement({
        anchor: l7,
        anchorAlign: s10,
        element: t6,
        elementAlign: n10,
        collisions: i16,
        currentLocation: g6,
        margin: this.props.margin
      });
      if (t6.style.top = r12.offset.top + "px", t6.style.left = r12.offset.left + "px", t6.style.width = m3, t6.style.height = f4, this._collisions = {
        fit: r12.fit,
        fitted: r12.fitted,
        flip: r12.flip,
        flipped: r12.flipped
      }, this.props.onPosition) {
        const T3 = {
          target: this,
          flipped: r12.flipped,
          fitted: r12.fitted
        };
        this.props.onPosition.call(void 0, T3);
      }
    }, this.onOpened = () => {
      const t6 = this._popup;
      if (t6) {
        if (this.props.show) {
          const { unstyled: s10 } = this.props, n10 = s10 && s10.uPopup;
          t6.classList.add(
            ...r$r(l$l.animationContainerShown({ c: n10 })).split(" ").filter((i16) => i16)
          );
        }
        this.attachRepositionHandlers(t6), this.props.onOpen && this.props.onOpen.call(void 0, { target: this });
      }
    }, this.animate = (t6, s10, n10) => {
      if (!this.props.popupAlign)
        return;
      let i16;
      const { horizontal: a9, vertical: l7 } = this.props.popupAlign;
      a9 === "left" && l7 === "center" ? i16 = "right" : a9 === "right" && l7 === "center" ? i16 = "left" : l7 === "top" ? i16 = "down" : i16 = "up";
      const h3 = {
        down: "up",
        up: "down",
        left: "right",
        right: "left"
      };
      this._collisions && this._collisions.flipped && (i16 = h3[i16]);
      const { unstyled: c6 } = this.props, u5 = c6 && c6.uPopup;
      A$b(t6, i16, this.animationDuration[s10], s10, n10, u5);
    }, this.handleMouseDown = (t6) => {
      var i16, a9;
      const s10 = ((i16 = t6 == null ? void 0 : t6.target) == null ? void 0 : i16.closest(".k-animation-container")) === null, n10 = ((a9 = this.props.anchor) == null ? void 0 : a9.contains(t6 == null ? void 0 : t6.target)) || false;
      if (s10) {
        if (this.props.onMouseDownOutside) {
          const l7 = {
            target: this,
            event: t6,
            state: this.state,
            isAnchorClicked: n10
          };
          this.props.onMouseDownOutside.call(void 0, l7);
        }
        window == null || window.removeEventListener("mousedown", this.handleMouseDown);
      }
    }, this.onClosing = (t6) => {
      if (!this.props.show) {
        const { unstyled: s10 } = this.props, n10 = s10 && s10.uPopup;
        t6.classList.remove(
          ...r$r(l$l.animationContainerShown({ c: n10 })).split(" ").filter((i16) => i16)
        );
      }
      this.detachRepositionHandlers();
    }, this.onClosed = () => {
      this.state.current === "hiding" && this.state.previous === "shown" && this.setState({ current: "hidden", previous: this.state.current }), this.props.onClose && this.props.onClose.call(void 0, { target: this });
    }, this.getCurrentZIndex = () => this.context ? this.context + U$4 : S$a, l$p(e$r), this.reposition = g$e(this.reposition.bind(this), d$m);
  }
  /**
   * Represents the Popup DOM element.
   */
  get element() {
    return this._popup;
  }
  /**
   * @hidden
   */
  static getDerivedStateFromProps(o9, t6) {
    const {
      show: s10,
      anchor: n10,
      anchorAlign: i16,
      appendTo: a9,
      collision: l7,
      popupAlign: h3,
      className: c6,
      popupClass: u5,
      style: m3,
      offset: f4,
      contentKey: g6
    } = o9, r12 = {
      ...t6,
      props: {
        show: s10,
        anchor: n10,
        anchorAlign: i16,
        appendTo: a9,
        collision: l7,
        popupAlign: h3,
        className: c6,
        popupClass: u5,
        style: m3,
        offset: f4,
        contentKey: g6
      }
    };
    return o9.show ? t6.current === "hidden" || t6.current === "hiding" ? { ...r12, current: "showing", previous: t6.current } : t6.current === "showing" ? { ...r12, current: "shown", previous: t6.current } : t6.current === "shown" && (!w$c(f4, t6.props.offset) || !w$c(i16, t6.props.anchorAlign) || !w$c(a9, t6.props.appendTo) || !w$c(l7, t6.props.collision) || !w$c(h3, t6.props.popupAlign) || !w$c(m3, t6.props.style) || n10 !== t6.props.anchor || u5 !== t6.props.popupClass || c6 !== t6.props.className) ? { ...r12, current: "reposition", previous: t6.current } : r12 : t6.current === "hiding" || t6.current === "hidden" ? { ...r12, current: "hidden", previous: t6.current } : { ...r12, current: "hiding", previous: t6.current };
  }
  /**
   *
   * @hidden
   */
  componentDidUpdate(o9) {
    this.state.current === "showing" && this._popup ? this.show(this._popup) : this.state.current === "hiding" && this._popup ? (this.onClosing(this._popup), this.animate(this._popup.firstChild, "exit", this.onClosed)) : this.state.current === "reposition" && this.state.previous === "shown" ? setTimeout(() => {
      this.setState({ current: "shown", previous: this.state.current });
    }, 0) : this.state.current === "shown" && o9.contentKey !== this.props.contentKey && this._popup && this.setPosition(this._popup);
  }
  /**
   * @hidden
   */
  componentDidMount() {
    this.state.current === "showing" && this._popup && this.show(this._popup);
  }
  /**
   * @hidden
   */
  componentWillUnmount() {
    this.detachRepositionHandlers();
  }
  /**
   * @hidden
   */
  render() {
    const { children: o9, className: t6, popupClass: s10, unstyled: n10, show: i16, id: a9, positionMode: l7 } = this.props, h3 = n10 && n10.uPopup, c6 = this.props.appendTo ? this.props.appendTo : e$C ? this.props.anchor && this.props.anchor.ownerDocument ? this.props.anchor.ownerDocument.body : document.body : void 0;
    this.state.current === "reposition" && this.state.previous === "shown" && this._popup && this.setPosition(this._popup);
    const u5 = Object.assign(
      {},
      { position: l7, top: 0, left: -1e4 },
      this.props.style || {}
    ), m3 = this.state.current === "hiding";
    if ((i16 || m3) && c6) {
      const f4 = this.getCurrentZIndex(), g6 = /* @__PURE__ */ reactExports.createElement(t$o.Provider, { value: f4 }, /* @__PURE__ */ reactExports.createElement(
        "div",
        {
          onKeyDown: this.props.onKeyDown,
          className: r$r(l$l.animationContainer({ c: h3 }), t6),
          id: a9,
          ref: (r12) => this._popup = r12,
          style: {
            zIndex: f4,
            ...u5
          }
        },
        /* @__PURE__ */ reactExports.createElement(
          "div",
          {
            className: r$r(l$l.animationChild({ c: h3 })),
            style: { transitionDelay: "0ms" }
          },
          /* @__PURE__ */ reactExports.createElement(
            "div",
            {
              role: this.props.role,
              className: r$r(l$l.popup({ c: h3 }), s10)
            },
            o9
          )
        )
      ));
      return this.props.appendTo !== null ? reactDomExports.createPortal(g6, c6) : g6;
    }
    return null;
  }
  get animationDuration() {
    const o9 = this.props.animate;
    let t6 = 0, s10 = 0;
    return o9 && (o9 === true ? t6 = s10 = 300 : (t6 = o9.openDuration || 0, s10 = o9.closeDuration || 0)), { enter: t6, exit: s10 };
  }
  attachRepositionHandlers(o9) {
    this.detachRepositionHandlers(), this._scrollableParents = domUtils.scrollableParents(this.props.anchor || o9), this._scrollableParents && this._scrollableParents.map((t6) => t6.addEventListener("scroll", this.reposition)), window.addEventListener("resize", this.reposition);
  }
  detachRepositionHandlers() {
    this._scrollableParents && (this._scrollableParents.map((o9) => o9.removeEventListener("scroll", this.reposition)), this._scrollableParents = void 0), window.removeEventListener("resize", this.reposition);
  }
  reposition() {
    this.setState({ current: "reposition", previous: this.state.current });
  }
};
y$8.propTypes = {
  anchor: function(o9) {
    const t6 = o9.anchor;
    return t6 && typeof t6.nodeType != "number" ? new Error("Invalid prop `anchor` supplied to `Kendo React Popup`. Validation failed.") : null;
  },
  appendTo: function(o9) {
    const t6 = o9.appendTo;
    return t6 && typeof t6.nodeType != "number" ? new Error("Invalid prop `appendTo` supplied to `Kendo React Popup`. Validation failed.") : null;
  },
  className: o$r.oneOfType([o$r.string, o$r.arrayOf(o$r.string), o$r.object]),
  id: o$r.string,
  popupClass: o$r.oneOfType([o$r.string, o$r.arrayOf(o$r.string), o$r.object]),
  collision: o$r.shape({
    horizontal: o$r.oneOf([d$n.fit, d$n.flip, d$n.none]),
    vertical: o$r.oneOf([d$n.fit, d$n.flip, d$n.none])
  }),
  anchorAlign: o$r.shape({
    horizontal: o$r.oneOf([p$p.left, p$p.center, p$p.right]),
    vertical: o$r.oneOf([p$p.top, p$p.center, p$p.bottom])
  }),
  popupAlign: o$r.shape({
    horizontal: o$r.oneOf([p$p.left, p$p.center, p$p.right]),
    vertical: o$r.oneOf([p$p.top, p$p.center, p$p.bottom])
  }),
  offset: o$r.shape({
    left: o$r.number,
    top: o$r.number
  }),
  children: o$r.oneOfType([o$r.element, o$r.node]),
  show: o$r.bool,
  animate: o$r.oneOfType([
    o$r.bool,
    o$r.shape({
      openDuration: o$r.number,
      closeDuration: o$r.number
    })
  ]),
  margin: o$r.shape({
    horizontal: o$r.number,
    vertical: o$r.number
  }),
  positionMode: o$r.oneOf(["fixed", "absolute"]),
  scale: o$r.number,
  style: o$r.object,
  onClose: o$r.func,
  onPosition: o$r.func,
  onOpen: o$r.func,
  onKeyPress: o$r.func,
  onMouseDownOutside: o$r.func
}, y$8.defaultProps = {
  collision: {
    horizontal: d$n.fit,
    vertical: d$n.flip
  },
  anchorAlign: {
    horizontal: p$p.left,
    vertical: p$p.bottom
  },
  popupAlign: {
    horizontal: p$p.left,
    vertical: p$p.top
  },
  offset: K$6,
  animate: true,
  show: false,
  margin: {
    horizontal: 0,
    vertical: 0
  },
  positionMode: "absolute"
}, y$8.contextType = t$o, y$8.displayName = "PopupComponent";
let _$5 = y$8;
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const u$i = reactExports.createContext((o9) => o9), a$m = reactExports.forwardRef((o9, e3) => {
  const p6 = reactExports.useContext(u$i), r12 = n$t(), n10 = p6.call(void 0, o9);
  return /* @__PURE__ */ reactExports.createElement(
    _$5,
    {
      ref: e3,
      unstyled: r12,
      ...n10
    }
  );
});
a$m.displayName = "Popup";
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const e$q = reactExports.createContext(null);
e$q.displayName = "ChartContext";
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const v$8 = { horizontal: "fit", vertical: "fit" }, d$l = "k-chart-tooltip", C$e = "k-chart-tooltip-wrapper", r$f = class r7 extends reactExports.Component {
  constructor(s10, o9) {
    super(s10, o9), this.context = null, this.element = null, this.onChartMouseLeave = (e3) => {
      const { syntheticEvent: t6 } = e3;
      return !!a$q(t6.relatedTarget, this.element);
    }, this.onMouseLeave = (e3) => {
      const t6 = o$h(this, e3);
      this.context.childrenObserver.trigger("onMouseLeave", t6) && e3.preventDefault();
    }, this.popupRef = (e3) => {
      this.element = e3;
      const t6 = e3 && e3.closest(".k-animation-container");
      t6 && (t6.style.transition = "initial");
    }, this.chartObserver = new InstanceObserver(this, {
      onMouseLeave: "onChartMouseLeave"
    }), o9.observersStore.dispatch({
      type: "add",
      payload: this.chartObserver
    });
  }
  render() {
    const { popupShown: s10, popupAlign: o9, popupOffset: e3, popupStyles: t6, popupContent: a9, className: p6 } = this.props, c6 = [d$l, p6].join(" ").trim();
    return /* @__PURE__ */ reactExports.createElement(
      a$m,
      {
        animate: false,
        popupAlign: o9,
        offset: e3,
        show: s10,
        collision: v$8,
        className: C$e
      },
      /* @__PURE__ */ reactExports.createElement(
        "div",
        {
          className: c6,
          style: t6,
          onMouseLeave: this.onMouseLeave,
          ref: this.popupRef
        },
        a9()
      )
    );
  }
  componentWillUnmount() {
    this.context.observersStore.dispatch({
      type: "remove",
      payload: this.chartObserver
    });
  }
};
r$f.contextType = e$q;
let i$f = r$f;
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const T$8 = "k-chart-shared-tooltip", x$f = "k-chart-tooltip-inverse", a$l = class a3 extends reactExports.Component {
  constructor() {
    super(...arguments), this.context = null, this.state = {
      popupShown: false
    }, this.chartObserver = null;
  }
  componentDidMount() {
    this.chartObserver = new InstanceObserver(this, {
      showTooltip: "onShowTooltip",
      hideTooltip: "onHideTooltip"
    }), this.context.observersStore.dispatch({
      type: "add",
      payload: this.chartObserver
    });
  }
  render() {
    const { popupContext: t6, shared: e3, className: n10, ...r12 } = this.state, i16 = this.state.popupShown ? () => {
      const o9 = this.findRenderFunction();
      if (e3)
        return o9 !== null ? o9(t6) : /* @__PURE__ */ reactExports.createElement(E$a, { ...t6 });
      {
        const u5 = t6.point, l7 = this.findRenderFunctionByIndex(u5.series.index);
        return l7 !== null ? l7(t6) : o9 !== null ? o9(t6) : /* @__PURE__ */ reactExports.createElement(
          "span",
          {
            dangerouslySetInnerHTML: { __html: t6.point.formattedValue }
          }
        );
      }
    } : Function.prototype, s10 = r$r({
      [T$8]: e3,
      [x$f]: !!n10
    });
    return /* @__PURE__ */ reactExports.createElement(
      i$f,
      {
        ...r12,
        popupContent: i16,
        className: s10
      }
    );
  }
  componentWillUnmount() {
    this.context.observersStore.dispatch({
      type: "remove",
      payload: this.chartObserver
    });
  }
  onShowTooltip(t6) {
    const { anchor: e3, style: n10, shared: r12, className: i16, crosshair: s10 } = t6;
    let o9;
    s10 || (r12 ? o9 = this.createSharedTooltipContext(t6) : o9 = this.createTooltipContext(t6), this.setState({
      popupShown: true,
      popupAlign: e3.align,
      popupOffset: e3.point,
      popupContext: o9,
      popupStyles: n10,
      className: i16,
      shared: r12
    }));
  }
  onHideTooltip() {
    this.setState({
      popupShown: false,
      popupStyles: {},
      className: void 0
    });
  }
  createSharedTooltipContext(t6) {
    const { points: e3, categoryText: n10 } = t6, r12 = e3.filter((o9) => typeof o9.series.name != "undefined").length > 0, i16 = t6.series.length > 1;
    let s10 = 1;
    return r12 && s10++, i16 && s10++, {
      categoryText: n10,
      colorMarker: i16,
      colspan: s10,
      nameColumn: r12,
      points: t6.points.map((o9) => new h$a(o9, t6.format))
    };
  }
  createTooltipContext(t6) {
    const { point: e3, format: n10 } = t6;
    return { point: new h$a(e3, n10) };
  }
  findRenderFunctionByIndex(t6) {
    const e3 = this.context.optionsStore.getState().series;
    return e3 !== void 0 && Array.isArray(e3) && e3[t6] !== void 0 && e3[t6].hasOwnProperty("tooltip") && e3[t6].tooltip.hasOwnProperty("render") ? e3[t6].tooltip.render : null;
  }
  findRenderFunction() {
    const t6 = this.context.optionsStore.getState().tooltip;
    return t6 !== void 0 && t6.hasOwnProperty("render") ? t6.render : null;
  }
};
a$l.contextType = e$q;
let h$9 = a$l;
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const n$k = (e3) => e3.children;
n$k.displayName = "Container";
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const v$7 = "k-chart-crosshair-tooltip", C$d = "k-chart-tooltip-inverse", n$j = class n3 extends reactExports.Component {
  constructor(t6, o9) {
    super(t6, o9), this.context = null, this.state = {
      popupShown: false
    }, this.chartObserver = new InstanceObserver(this, {
      showTooltip: "onShowTooltip",
      hideTooltip: "onHideTooltip"
    }), o9.observersStore.dispatch({
      type: "add",
      payload: this.chartObserver
    });
  }
  render() {
    const { popupContend: t6, className: o9, ...e3 } = this.state, p6 = this.state.popupShown ? () => t6 : Function.prototype, s10 = r$r({
      [v$7]: true,
      [C$d]: !!o9
    });
    return /* @__PURE__ */ reactExports.createElement(
      i$f,
      {
        ...e3,
        popupContent: p6,
        className: s10
      }
    );
  }
  componentWillUnmount() {
    var t6;
    (t6 = this.context) == null || t6.observersStore.dispatch({
      type: "remove",
      payload: this.chartObserver
    });
  }
  onShowTooltip(t6) {
    const { anchor: o9, style: e3, className: p6, crosshair: s10, axisName: a9, axisIndex: c6, value: l7 } = t6, { name: h3, index: u5 } = this.props;
    s10 && a9 === h3 && c6 === u5 && this.setState({
      popupShown: true,
      popupAlign: o9.align,
      popupOffset: o9.point,
      popupContend: l7,
      popupStyles: e3,
      className: p6
    });
  }
  onHideTooltip() {
    this.setState({
      popupShown: false,
      popupStyles: {},
      className: void 0
    });
  }
};
n$j.contextType = e$q;
let i$e = n$j;
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const l$j = ["categoryAxis", "valueAxis", "xAxis", "yAxis"];
function x$e(n10) {
  const t6 = {};
  for (let o9 = 0; o9 < l$j.length; o9++) {
    const s10 = m$c(n10, l$j[o9]);
    for (let e3 = 0; e3 < s10.length; e3++) {
      const i16 = s10[e3];
      t6[i16.name + i16.index] = i16;
    }
  }
  return t6;
}
function m$c(n10, t6) {
  const o9 = [];
  if (n10[t6]) {
    const s10 = [].concat(n10[t6]);
    for (let e3 = 0; e3 < s10.length; e3++) {
      const i16 = (s10[e3].crosshair || {}).tooltip;
      i16 && i16.visible && o9.push({
        index: e3,
        name: t6
      });
    }
  }
  return o9;
}
const c$h = class c2 extends reactExports.Component {
  constructor() {
    super(...arguments), this.context = null, this.state = {
      tooltips: {}
    }, this.storeUnsubscriber = Function.prototype, this.subscriber = () => {
      var t6;
      this.setState({
        tooltips: x$e((t6 = this.context) == null ? void 0 : t6.optionsStore.getState())
      });
    };
  }
  componentDidMount() {
    this.storeUnsubscriber = this.context.optionsStore.subscribe(this.subscriber);
  }
  render() {
    const { tooltips: t6 } = this.state, o9 = Object.keys(t6).map((s10) => /* @__PURE__ */ reactExports.createElement(i$e, { ...t6[s10], key: s10 }));
    return /* @__PURE__ */ reactExports.createElement(n$k, null, o9);
  }
  componentWillUnmount() {
    this.storeUnsubscriber();
  }
};
c$h.contextType = e$q;
let p$o = c$h;
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const e$p = {
  name: "@progress/kendo-react-charts",
  productName: "KendoReact",
  productCodes: ["KENDOUIREACT", "KENDOUICOMPLETE"],
  publishDate: 1728906733,
  version: "",
  licensingDocsUrl: "https://www.telerik.com/kendo-react-ui/components/my-license/"
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const d$k = class d extends reactExports.Component {
  constructor(t6) {
    super(t6), this.chartInstance = null, this.surface = null, this._element = null, this.optionsStore = {}, this.optionsUnsubscriber = Function.prototype, this.themeStore = {}, this.themeUnsubscriber = Function.prototype, this.observersStore = {}, this.suppressTransitions = false, this.showLicenseWatermark = false, this.onRender = (e3) => {
      this.chartInstance !== null && (this.surface = e3.sender.surface, this.trigger("render", e3));
    }, this.onDrilldown = (e3) => {
      var a9;
      const { series: s10 } = this.optionsStore.getState(), r12 = s10.find((n10) => n10.name === e3.series.name);
      if (!r12.drilldownSeriesFactory)
        return true;
      const i16 = "onDrilldown";
      if (this.props.hasOwnProperty(i16)) {
        const n10 = { seriesName: r12.name, drilldownValue: e3.value }, h3 = [...((a9 = this.props.drilldownState) == null ? void 0 : a9.steps) || [], n10], c6 = this.props.getTarget(), p6 = {
          ...e3,
          currentState: this.props.drilldownState,
          nextState: { steps: h3 }
        }, o9 = new n$l(p6, c6);
        this.props[i16].call(void 0, o9);
      }
      return true;
    }, this.onLegendItemClick = (e3) => {
      if (this.chartInstance !== null)
        if (this.props.onLegendItemClick)
          this.trigger("legendItemClick", e3);
        else {
          const { series: s10 } = this.optionsStore.getState();
          if (!s10)
            return;
          let r12 = {};
          const { seriesIndex: i16, pointIndex: a9 } = e3, n10 = s10[i16];
          if (a9 === void 0)
            r12 = Object.assign({}, n10, { visible: u$m(n10.visible) });
          else {
            const h3 = n10.pointVisibility = n10.pointVisibility || [];
            h3[a9] = u$m(h3[a9]), r12 = Object.assign({}, n10);
          }
          this.optionsStore.dispatch({
            chartCollectionIdxKey: `series_${i16}`,
            payload: r12
          }), this.suppressTransitions = true;
        }
    }, this.onWindowResize = () => {
      this.chartInstance !== null && this.chartInstance.resize();
    }, this.onChartMouseLeave = (e3) => {
      const s10 = o$h(this, e3);
      this.triggerDomEvent("onMouseLeave", s10) ? e3.preventDefault() : this.chartInstance !== null && this.chartInstance.hideElements();
    }, this.onChildMouseLeave = (e3) => {
      const { syntheticEvent: s10 } = e3;
      return this.chartInstance && !a$q(s10.relatedTarget, this.element) && this.chartInstance.hideElements(), false;
    }, l$p(e$p), this.showLicenseWatermark = n$w(e$p), this.optionsStore = T$9(u$k), this.observersStore = T$9(p$r), this.childrenObserver = new InstanceObserver(this, { onMouseLeave: "onChildMouseLeave" }), this.state = {
      optionsStore: this.optionsStore,
      observersStore: this.observersStore,
      childrenObserver: this.childrenObserver,
      drilldownState: { steps: [] }
    }, this.themeStore = T$9(a$n), this.chartObserver = new InstanceObserver(this, {
      render: "onRender",
      legendItemClick: "onLegendItemClick",
      drilldown: "onDrilldown"
    });
  }
  /**
   * @hidden
   */
  get element() {
    return this._element;
  }
  /**
   * @hidden
   */
  static getDerivedStateFromProps(t6, e3) {
    return {
      ...e3,
      drilldownState: t6.drilldownState || []
    };
  }
  /**
   * @hidden
   */
  componentDidMount() {
    var e3;
    const t6 = ((e3 = this._element) == null ? void 0 : e3.ownerDocument) || document;
    C$f(this.themeStore, this.instantiateCoreChart.bind(this), t6), this.optionsUnsubscriber = this.optionsStore.subscribe(this.refresh.bind(this)), this.themeUnsubscriber = this.themeStore.subscribe(this.refresh.bind(this)), window.addEventListener("resize", this.onWindowResize);
  }
  /**
   * @hidden
   */
  componentWillUnmount() {
    this.optionsUnsubscriber(), this.themeUnsubscriber(), this.chartInstance !== null && (this.chartInstance.destroy(), this.chartInstance = null), window.removeEventListener("resize", this.onWindowResize);
  }
  /**
   * @hidden
   */
  componentDidUpdate(t6) {
    const { dir: e3, children: s10, ...r12 } = this.props;
    if (this.chartInstance !== null) {
      const i16 = a$s(this), a9 = this.chartInstance.chartService, n10 = i16.locale !== a9._intlService.locale, h3 = Object.entries(t6).filter((c6) => c6[0] !== "dir" && c6[0] !== "children").some((c6) => {
        const [p6, o9] = c6;
        return !(r12.hasOwnProperty(p6) && r12[p6] === o9);
      });
      n10 && (this.chartInstance.chartService._intlService = i16, this.chartInstance.chartService.format._intlService = i16, h3 || this.chartInstance.noTransitionsRedraw()), h3 && this.refresh(), t6.dir !== e3 && this.chartInstance.setDirection(this.getDirection(e3));
    }
  }
  /**
   * @hidden
   */
  render() {
    const { style: t6 = {}, className: e3, wrapper: s10, children: r12 } = this.props, i16 = Object.assign({}, t6, { position: "relative" }), a9 = reactExports.createElement(
      s10,
      {
        className: e3,
        style: i16,
        key: "chartElement"
      },
      /* @__PURE__ */ reactExports.createElement("div", { onMouseLeave: this.onChartMouseLeave, ref: (n10) => this._element = n10, className: "k-chart-surface" }, r12),
      /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, this.showLicenseWatermark && /* @__PURE__ */ reactExports.createElement(v$e, null))
    );
    return /* @__PURE__ */ reactExports.createElement(e$q.Provider, { value: this.state }, /* @__PURE__ */ reactExports.createElement(h$9, { key: "seriesTooltip" }), /* @__PURE__ */ reactExports.createElement(p$o, { key: "crosshairTooltips" }), a9);
  }
  /**
   * @hidden
   */
  getDirection(t6) {
    return (t6 !== void 0 ? t6 : e$C && window.getComputedStyle(this.element).direction || "ltr") === "rtl";
  }
  /**
   * @hidden
   */
  getChartOptions() {
    const {
      renderAs: t6,
      pannable: e3,
      zoomable: s10,
      paneDefaults: r12,
      panes: i16,
      transitions: a9,
      seriesColors: n10,
      seriesDefaults: h3,
      axisDefaults: c6,
      deriveOptionsFromParent: p6
    } = this.props;
    let o9 = {};
    return t6 !== void 0 && (o9.renderAs = t6), e3 !== void 0 && (o9.pannable = e3), s10 !== void 0 && (o9.zoomable = s10), r12 !== void 0 && (o9.paneDefaults = r12), i16 !== void 0 && (o9.panes = i16), a9 !== void 0 && (o9.transitions = a9), n10 !== void 0 && (o9.seriesColors = n10), h3 !== void 0 && (o9.seriesDefaults = h3), c6 !== void 0 && (o9.axisDefaults = c6), o9 = Object.assign(o9, this.optionsStore.getState()), p6 && (o9 = p6(o9)), o9;
  }
  /**
   * @hidden
   */
  refresh() {
    if (this.chartInstance !== null) {
      const t6 = this.themeStore.getState(), e3 = this.getChartOptions(), s10 = e3.transitions;
      this.suppressTransitions && (e3.transitions = false), this.props.onRefresh ? this.props.onRefresh.call(void 0, e3, t6, this.chartInstance) : this.chartInstance.setOptions(e3, t6), this.suppressTransitions && (e3.transitions = s10, this.suppressTransitions = false);
    }
  }
  /**
   * @hidden
   */
  instantiateCoreChart() {
    const { dir: t6, chartConstructor: e3 } = this.props, s10 = this.getChartOptions();
    this.chartInstance = new e3(this.element, s10, this.themeStore.getState(), {
      rtl: this.getDirection(t6),
      intlService: a$s(this),
      observer: this.chartObserver,
      sender: this
    });
  }
  /* Triggers public dom event handlers */
  /**
   * @hidden
   */
  trigger(t6, e3) {
    const s10 = this.props.getTarget(), r12 = Q$6(t6, e3, s10), i16 = "on" + t6.charAt(0).toUpperCase() + t6.slice(1), a9 = this.observersStore.getState();
    let n10 = false;
    for (let h3 = 0; h3 < a9.length; h3++)
      a9[h3].trigger(t6, e3) && (n10 = true);
    return n10 === false && r12 && this.props.hasOwnProperty(i16) ? (this.props[i16].call(void 0, r12), r12.isDefaultPrevented && r12.isDefaultPrevented()) : n10;
  }
  /* Used by (event)InstanceObserver to check the wrapper for supported events */
  /**
   * @hidden
   */
  requiresHandlers(t6) {
    for (let e3 = 0; e3 < t6.length; e3++) {
      const s10 = t6[e3], r12 = "on" + s10.charAt(0).toUpperCase() + s10.slice(1);
      if (this.props.hasOwnProperty(r12))
        return true;
    }
    return false;
  }
  /* Triggers private dom event handlers */
  /**
   * @hidden
   */
  triggerDomEvent(t6, e3) {
    const s10 = this.observersStore.getState();
    let r12 = false;
    for (let i16 = 0; i16 < s10.length; i16++)
      s10[i16].trigger(t6, e3) && (r12 = true);
    return r12;
  }
};
d$k.propTypes = {
  dir: o$r.string,
  renderAs: o$r.oneOf(["svg", "canvas"])
}, d$k.defaultProps = {
  renderAs: "svg"
};
let u$h = d$k;
p$t(u$h);
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const c$g = class c3 extends reactExports.Component {
  constructor(e3, t6) {
    super(e3, t6), this.context = null, this.state = {
      donutCenterStyles: null
    }, this.chartObserver = new InstanceObserver(this, {
      render: "onRender"
    }), t6.observersStore.dispatch({
      type: "add",
      payload: this.chartObserver
    });
  }
  render() {
    const { render: e3 } = this.props, { donutCenterStyles: t6 } = this.state;
    let r12 = null;
    return e3 && t6 && (r12 = /* @__PURE__ */ reactExports.createElement("div", { className: "k-chart-donut-center", style: t6 }, /* @__PURE__ */ reactExports.createElement(e3, null))), r12;
  }
  onRender(e3) {
    var l7;
    const t6 = (l7 = this.context) == null ? void 0 : l7.optionsStore.getState().series, r12 = Array.isArray(t6) ? t6[0] : null, i16 = e3.sender._plotArea.charts;
    if (!r12 || r12.type !== "donut" || i16[0].points.length === 0)
      return;
    const s10 = i16[0].points[0].sector, n10 = s10.innerRadius, h3 = s10.center.y - n10, p6 = s10.center.x - n10, a9 = n10 * 2;
    this.setState({
      donutCenterStyles: {
        height: a9,
        left: p6,
        top: h3,
        width: a9
      }
    });
  }
};
c$g.contextType = e$q;
let d$j = c$g;
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let f$d = class f extends reactExports.Component {
  constructor() {
    super(...arguments), this._baseChart = null, this.getTarget = () => this;
  }
  /**
   * @hidden
   */
  get chartInstance() {
    return this._baseChart !== null ? this._baseChart.chartInstance : null;
  }
  /**
   * The Drawing `Surface` of the Chart.
   */
  get surface() {
    return this._baseChart !== null ? this._baseChart.surface : null;
  }
  /**
   * The DOM element of the Chart.
   */
  get element() {
    return this._baseChart !== null ? this._baseChart.element : null;
  }
  /**
   * @hidden
   */
  render() {
    const { donutCenterRender: e3, children: r12, className: a9, ...s10 } = this.props;
    return /* @__PURE__ */ reactExports.createElement(
      u$h,
      {
        ...s10,
        ref: (n10) => this._baseChart = n10,
        chartConstructor: Chart$1,
        getTarget: this.getTarget,
        wrapper: "div",
        className: r$r("k-chart k-widget", a9)
      },
      r12,
      /* @__PURE__ */ reactExports.createElement(d$j, { render: e3 })
    );
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const p$n = class p extends reactExports.Component {
  constructor(t6, r12) {
    super(t6, r12), this.optionsStore = r12.optionsStore;
  }
  renderChildren(t6, r12) {
    const { children: o9 } = t6.props, { _chartKey: c6, _parentStore: e3 } = this.props, n10 = {
      ...t6.props,
      _chartCollectionIdxKey: `${c6}_${r12}`,
      _parentStore: e3
    };
    return reactExports.cloneElement(t6, n10, o9);
  }
  render() {
    const { _chartKey: t6, _parentStore: r12, children: o9 } = this.props;
    return (r12 || this.optionsStore).dispatch({
      chartKey: t6,
      payload: []
    }), reactExports.Children.map(o9, (e3, n10) => reactExports.isValidElement(e3) ? this.renderChildren(e3, n10) : e3);
  }
};
p$n.contextType = e$q;
let a$k = p$n;
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const s$h = class s3 extends reactExports.Component {
  constructor(t6, e3) {
    super(t6, e3), this.optionsStore = e3.optionsStore, this.childStore = T$9(u$k);
  }
  render() {
    const { children: t6 } = this.props;
    return t6 !== void 0 ? reactExports.Children.map(t6, (e3) => reactExports.isValidElement(e3) ? this.renderChildren(e3) : e3) : null;
  }
  componentDidMount() {
    this.dispatch();
  }
  componentDidUpdate() {
    this.dispatch();
  }
  dispatch() {
    const { _chartKey: t6, _chartCollectionIdxKey: e3, _parentStore: o9, children: a9, ...n10 } = this.props;
    (o9 || this.optionsStore).dispatch({
      chartKey: t6,
      chartCollectionIdxKey: e3,
      payload: Object.assign({}, n10, this.childStore.getState())
    });
  }
  renderChildren(t6) {
    const { children: e3 } = t6.props, o9 = {
      ...t6.props,
      _parentStore: this.childStore
    };
    return reactExports.cloneElement(t6, o9, e3);
  }
};
s$h.contextType = e$q;
let i$d = s$h;
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const u$g = "", c$f = "0", t$h = "_";
function s$g(n10, r12) {
  if (i$c(n10))
    return r12[Number(n10)];
  {
    const e3 = r12[Number(f$c(n10))];
    return e3.items ? s$g(g$d(n10), e3.items) : void 0;
  }
}
function f$c(n10) {
  return o$g(n10) ? n10 : n10.split(t$h)[0];
}
function g$d(n10) {
  if (o$g(n10))
    return n10;
  {
    const r12 = n10.indexOf(t$h);
    return n10.substring(r12 + 1);
  }
}
function b$b(n10) {
  return l$i("0", n10);
}
function x$d(n10, r12) {
  return r12.indexOf(n10) === 0 ? r12.length === n10.length || r12.charAt(n10.length) === t$h : false;
}
function l$i(n10, r12) {
  return r12 ? r12 + t$h + n10 : n10;
}
function O$9(n10) {
  const r12 = n10.lastIndexOf(t$h);
  return r12 < 0 ? u$g : n10.substring(0, r12);
}
function o$g(n10) {
  return n10 === u$g || n10.indexOf(t$h) < 0;
}
function i$c(n10) {
  return n10 !== u$g && n10.indexOf(t$h) < 0;
}
function E$9(n10) {
  return S$9(n10) === 1;
}
function p$m(n10) {
  return a$j(n10) === c$f;
}
function a$j(n10) {
  const r12 = n10.lastIndexOf(t$h);
  return r12 < 0 ? n10 : n10.substring(r12 + 1);
}
function L$a(n10, r12, e3) {
  return i$c(r12) ? n10 ? Number(r12) < e3 - 1 ? (Number(r12) + 1).toString() : "0" : Number(r12) > 0 ? (Number(r12) - 1).toString() : (e3 - 1).toString() : r12;
}
function S$9(n10) {
  return n10.split(t$h).length - 1;
}
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const r$e = class r8 extends reactExports.Component {
  /**
   * @hidden
   */
  render() {
    return null;
  }
};
r$e.propTypes = {
  text: o$r.string,
  url: o$r.string,
  icon: o$r.string,
  disabled: o$r.bool,
  cssClass: o$r.string,
  cssStyle: o$r.object,
  render: o$r.any,
  linkRender: o$r.any,
  contentRender: o$r.any,
  data: o$r.any
};
let s$f = r$e;
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
function b$a(t6, n10) {
  if (t6 && t6.length > 0)
    return {
      items: c$e(t6),
      inputItems: t6
    };
  if (s$e(n10).length > 0) {
    const e3 = h$8(s$e(n10));
    return { items: c$e(e3), inputItems: e3 };
  } else
    return { items: [], inputItems: [] };
}
function g$c(t6, n10) {
  let e3 = {};
  const { text: i16, url: o9, icon: r12, svgIcon: d8, disabled: l7, cssClass: u5, cssStyle: f4, render: m3, linkRender: p6, contentRender: I3, data: a9 } = t6 || n10.props;
  return i16 !== void 0 && (e3.text = i16), o9 !== void 0 && (e3.url = o9), r12 !== void 0 && (e3.icon = r12), d8 !== void 0 && (e3.svgIcon = d8), l7 !== void 0 && (e3.disabled = l7), u5 !== void 0 && (e3.cssClass = u5), f4 !== void 0 && (e3.cssStyle = f4), m3 !== void 0 && (e3.render = m3), p6 !== void 0 && (e3.linkRender = p6), I3 !== void 0 && (e3.contentRender = I3), a9 !== void 0 && (e3.data = a9), e3;
}
function s$e(t6) {
  return reactExports.Children.toArray(t6).filter((n10) => n10 && n10.type === s$f);
}
function h$8(t6) {
  const n10 = [];
  for (let e3 = 0; e3 < t6.length; e3++) {
    const i16 = t6[e3], o9 = g$c(void 0, i16), r12 = h$8(s$e(i16.props.children));
    r12.length > 0 && (o9.items = r12), n10.push(o9);
  }
  return n10;
}
function c$e(t6, n10) {
  const e3 = [];
  for (let i16 = 0; i16 < t6.length; i16++) {
    const o9 = t6[i16], r12 = g$c(o9);
    r12.id = l$i(i16.toString(), n10), r12.isLastFromSiblings = i16 === t6.length - 1, r12.items = x$c(o9, r12), e3.push(r12);
  }
  return e3;
}
function x$c(t6, n10) {
  return t6.contentRender ? [{
    contentParentItemId: n10.id,
    id: l$i(c$f, n10.id),
    isLastFromSiblings: true,
    contentRender: t6.contentRender,
    items: []
  }] : t6.items ? c$e(t6.items, n10.id) : [];
}
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const Q$5 = /\S/;
function V$7(a9, n10, G2, S2, g6, s10) {
  const H3 = l7();
  switch (G2) {
    case e$B.left:
      return x3();
    case e$B.right:
      return B2();
    case e$B.up:
      return A2();
    case e$B.down:
      return z3();
    case e$B.enter:
    case e$B.space:
      return R2();
    case e$B.home:
      return W3();
    case e$B.end:
      return Z2();
    case e$B.esc:
      return _2();
    default:
      return X2() ? M3() : n10;
  }
  function x3() {
    return g6 ? s10 ? F2() : U3() : s10 ? C2() : K3();
  }
  function B2() {
    return g6 ? s10 ? U3() : F2() : s10 ? K3() : C2();
  }
  function z3() {
    return g6 ? u5() : i$c(n10) ? c6() : u5();
  }
  function A2() {
    return g6 ? h3() : i$c(n10) ? E2() : h3();
  }
  function R2() {
    return H3.disabled ? n10 : d8() ? b$b(n10) : f$c(n10);
  }
  function W3() {
    return y4()[0].id;
  }
  function Z2() {
    const e3 = y4();
    return e3[e3.length - 1].id;
  }
  function _2() {
    return i$c(n10) ? n10 : O$9(n10);
  }
  function M3() {
    const e3 = S2.toLowerCase(), t6 = y4(), o9 = Number(a$j(n10)), p6 = t6.slice(o9 + 1).concat(t6.slice(0, o9 + 1)).find((j2) => (j2.text || "").toLowerCase().startsWith(e3));
    return p6 ? p6.id : n10;
  }
  function K3() {
    return i$c(n10) ? h3() : E$9(n10) ? c6(h3(f$c(n10))) : O$9(n10);
  }
  function U3() {
    return i$c(n10) ? E2() : O$9(n10);
  }
  function C2() {
    return i$c(n10) ? u5() : c6(
      d8() ? n10 : u5(f$c(n10))
    );
  }
  function F2() {
    return c6(
      i$c(n10) || d8() ? n10 : u5(f$c(n10))
    );
  }
  function c6(e3) {
    return v3(true, e3);
  }
  function E2(e3) {
    return v3(false, e3);
  }
  function X2() {
    return S2.length === 1 && Q$5.test(S2);
  }
  function l7(e3, t6) {
    return e3 === void 0 && (e3 = n10), t6 === void 0 && (t6 = a9), s$g(e3, t6);
  }
  function d8(e3) {
    return l7(e3).items.length > 0;
  }
  function h3(e3) {
    return L3(false, e3);
  }
  function u5(e3) {
    return L3(true, e3);
  }
  function $2(e3) {
    const t6 = l7(e3).items;
    return t6[t6.length - 1].id;
  }
  function y4() {
    return i$c(n10) ? a9 : l7(O$9(n10), a9).items;
  }
  function v3(e3, t6) {
    t6 === void 0 && (t6 = n10);
    const o9 = l7(t6);
    return d8(t6) && !o9.disabled ? e3 ? b$b(t6) : $2(t6) : t6;
  }
  function L3(e3, t6) {
    if (t6 === void 0 && (t6 = n10), i$c(t6))
      return L$a(e3, t6, a9.length);
    {
      const o9 = O$9(t6), w3 = a$j(t6), p6 = l7(o9).items.length;
      return l$i(L$a(e3, w3, p6), o9);
    }
  }
}
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
function n$i(e3) {
  return e3.hoverOpenDelay !== void 0 ? e3.hoverOpenDelay : e3.openOnClick ? 0 : 100;
}
function l$h(e3) {
  return e3.hoverCloseDelay !== void 0 ? e3.hoverCloseDelay : 100;
}
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const o$f = {
  vertical: "top",
  horizontal: "left"
}, t$g = {
  vertical: "top",
  horizontal: "right"
}, i$b = {
  vertical: "flip",
  horizontal: "fit"
}, l$g = {
  vertical: "fit",
  horizontal: "flip"
}, n$h = {
  downward: {
    anchorAlign: {
      vertical: "bottom",
      horizontal: "right"
    },
    popupAlign: t$g,
    collision: i$b
  },
  leftward: {
    anchorAlign: {
      vertical: "top",
      horizontal: "left"
    },
    popupAlign: t$g,
    collision: l$g
  }
}, r$d = {
  downward: {
    anchorAlign: {
      vertical: "bottom",
      horizontal: "left"
    },
    popupAlign: o$f,
    collision: i$b
  },
  rightward: {
    anchorAlign: {
      vertical: "top",
      horizontal: "right"
    },
    popupAlign: o$f,
    collision: l$g
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
function a$i(r12, n10, t6) {
  const e3 = w$b(r12, n10, t6);
  return t6 ? e3 === "downward" ? n$h.downward : n$h.leftward : e3 === "downward" ? r$d.downward : r$d.rightward;
}
function w$b(r12, n10, t6) {
  return i$c(r12) ? n10 ? t6 ? "leftward" : "rightward" : "downward" : t6 ? "leftward" : "rightward";
}
function f$b(r12) {
  return r12 ? "rtl" : "ltr";
}
function P$c(r12, n10) {
  return `${r12}_${n10}`;
}
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const s$d = class s4 extends reactExports.Component {
  /**
   * @hidden
   */
  render() {
    return this.props.url ? /* @__PURE__ */ reactExports.createElement(
      "a",
      {
        className: this.getMenuItemClassName(),
        role: "presentation",
        href: this.props.url,
        tabIndex: -1
      },
      this.props.children
    ) : /* @__PURE__ */ reactExports.createElement(
      "span",
      {
        id: this.props.id,
        className: r$r(this.getMenuItemClassName(), this.props.className),
        style: this.props.style,
        role: "presentation"
      },
      this.props.children
    );
  }
  getMenuItemClassName() {
    return r$r(
      "k-link",
      "k-menu-link",
      {
        "k-active": this.props.opened
      }
    );
  }
};
s$d.propTypes = {
  opened: o$r.bool,
  url: o$r.string
};
let p$l = s$d;
const caretAltUpIcon = {
  name: "caret-alt-up",
  content: '<path d="m256 160 128 192H128z" />',
  viewBox: "0 0 512 512"
};
const caretAltRightIcon = {
  name: "caret-alt-right",
  content: '<path d="M352 256 160 384V128z" />',
  viewBox: "0 0 512 512"
};
const caretAltDownIcon = {
  name: "caret-alt-down",
  content: '<path d="M256 352 128 160h256z" />',
  viewBox: "0 0 512 512"
};
const caretAltLeftIcon = {
  name: "caret-alt-left",
  content: '<path d="m160 256 192-128v256z" />',
  viewBox: "0 0 512 512"
};
const caretAltToRightIcon = {
  name: "caret-alt-to-right",
  content: '<path d="m128 128 192 128-192 128zm224 256V128h-32v256z" />',
  viewBox: "0 0 512 512"
};
const caretAltToLeftIcon = {
  name: "caret-alt-to-left",
  content: '<path d="M352 384 160 256l192-128zM128 128v256h32V128z" />',
  viewBox: "0 0 512 512"
};
const moreVerticalIcon = {
  name: "more-vertical",
  content: '<path d="M240 128c26.4 0 48-21.6 48-48s-21.6-48-48-48-48 21.6-48 48 21.6 48 48 48m0 64c-26.4 0-48 21.6-48 48s21.6 48 48 48 48-21.6 48-48-21.6-48-48-48m0 160c-26.4 0-48 21.6-48 48s21.6 48 48 48 48-21.6 48-48-21.6-48-48-48" />',
  viewBox: "0 0 512 512"
};
const calendarIcon = {
  name: "calendar",
  content: '<path d="M416 416H288V288h128zm64-352v384c0 17.6-14.4 32-32 32H64c-17.6 0-32-14.4-32-32V64c0-17.6 14.4-32 32-32h64V0h64v32h128V0h64v32h64c17.6 0 32 14.4 32 32m-32 128H64v255.9l.1.1 383.9-.1zm0-127.9q-.15-.15 0 0l-64-.1v32h-64V64H192v32h-64V64H64.1l-.1.1V160h384z" />',
  viewBox: "0 0 512 512"
};
const cancelIcon = {
  name: "cancel",
  content: '<path d="M256 32c-50.3 0-96.8 16.6-134.1 44.6-17.2 12.8-32.4 28.1-45.3 45.3C48.6 159.2 32 205.7 32 256c0 123.7 100.3 224 224 224 50.3 0 96.8-16.6 134.1-44.6 17.2-12.8 32.4-28.1 45.3-45.3 28-37.4 44.6-83.8 44.6-134.1 0-123.7-100.3-224-224-224m0 384c-88.2 0-160-71.8-160-160 0-32.6 9.8-62.9 26.6-88.2l221.6 221.6C318.9 406.2 288.6 416 256 416m133.4-71.8L167.8 122.6C193.1 105.8 223.4 96 256 96c88.2 0 160 71.8 160 160 0 32.6-9.8 62.9-26.6 88.2" />',
  viewBox: "0 0 512 512"
};
const xIcon = {
  name: "x",
  content: '<path d="M416 141.3 301.3 256 416 370.7 370.7 416 256 301.3 141.3 416 96 370.7 210.7 256 96 141.3 141.3 96 256 210.7 370.7 96z" />',
  viewBox: "0 0 512 512"
};
const xCircleIcon = {
  name: "x-circle",
  content: '<path d="M256 32C132.3 32 32 132.3 32 256s100.3 224 224 224 224-100.3 224-224S379.7 32 256 32m128 306.7L338.7 384 256 301.3 173.3 384 128 338.7l82.7-82.7-82.7-82.7 45.3-45.3 82.7 82.7 82.7-82.7 45.3 45.3-82.7 82.7z" />',
  viewBox: "0 0 512 512"
};
const plusIcon = {
  name: "plus",
  content: '<path d="M288 224V96h-64v128H96v64h128v128h64V288h128v-64z" />',
  viewBox: "0 0 512 512"
};
const minusIcon = {
  name: "minus",
  content: '<path d="M96 224v64h320v-64z" />',
  viewBox: "0 0 512 512"
};
const sortAscSmallIcon = {
  name: "sort-asc-small",
  content: '<path d="M256 192v224h-32V192h-96L240 64l112 128z" />',
  viewBox: "0 0 512 512"
};
const sortDescSmallIcon = {
  name: "sort-desc-small",
  content: '<path d="M352 288 240 416 128 288h96V64h32v224z" />',
  viewBox: "0 0 512 512"
};
const filterIcon = {
  name: "filter",
  content: '<path d="M64 64v32l160 160v224l64-64V256L448 96V64z" />',
  viewBox: "0 0 512 512"
};
const filterClearIcon = {
  name: "filter-clear",
  content: '<path d="m143.5 64 168.2 168.2L288 256v160l-64 64V256L64 96V64zm236.1 100.4L448 96V64H279.3l-64-64L192 22l298 298 22-23.3z" />',
  viewBox: "0 0 512 512"
};
const searchIcon = {
  name: "search",
  content: '<path d="M365.3 320h-22.7l-26.7-26.7C338.5 265.7 352 230.4 352 192c0-88.4-71.6-160-160-160S32 103.6 32 192s71.6 160 160 160c38.4 0 73.7-13.5 101.3-36.1l26.7 26.7v22.7L434.7 480l45.3-45.3zM64 192c0-70.7 57.3-128 128-128s128 57.3 128 128-57.3 128-128 128S64 262.7 64 192" />',
  viewBox: "0 0 512 512"
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const l$f = "caret-alt-down", p$k = "caret-alt-right", d$i = "caret-alt-left", r$c = class r9 extends reactExports.Component {
  /**
   * @hidden
   */
  render() {
    return /* @__PURE__ */ reactExports.createElement(v$c, { "aria-hidden": true, ...this.getIcon() });
  }
  getIcon() {
    switch (w$b(
      this.props.itemId,
      this.props.verticalMenu === true,
      this.props.dir === "rtl"
    )) {
      case "downward":
        return { name: l$f, icon: caretAltDownIcon };
      case "rightward":
        return { name: p$k, icon: caretAltRightIcon };
      case "leftward":
        return { name: d$i, icon: caretAltLeftIcon };
      default:
        return {};
    }
  }
};
r$c.propTypes = {
  itemId: o$r.string,
  dir: o$r.string,
  verticalMenu: o$r.bool
};
let o$e = r$c;
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let g$b = class g2 extends reactExports.Component {
  constructor() {
    super(...arguments), this.onMouseOver = (e3) => {
      this.props.onMouseOver(this.props.parentItemId), e3.stopPropagation();
    }, this.onMouseLeave = (e3) => {
      this.props.onMouseLeave(this.props.parentItemId), e3.stopPropagation();
    };
  }
  render() {
    const e3 = this.props.parentItemId;
    return /* @__PURE__ */ reactExports.createElement(
      "ul",
      {
        className: this.props.className,
        role: this.props.role ? this.props.role : e3 !== void 0 ? "menu" : "menubar",
        id: e3 !== void 0 ? P$c(this.props.menuGuid, e3) : void 0,
        onMouseOver: e3 !== void 0 ? this.onMouseOver : void 0,
        onMouseLeave: e3 !== void 0 ? this.onMouseLeave : void 0,
        "aria-orientation": this.props["aria-orientation"]
      },
      this.renderChildItems()
    );
  }
  renderChildItems() {
    return this.props.items.length > 0 ? this.props.items.map((e3, t6) => /* @__PURE__ */ reactExports.createElement(
      v$6,
      {
        item: e3,
        isMenuVertical: this.props.isMenuVertical,
        isDirectionRightToLeft: this.props.isDirectionRightToLeft,
        focusedItemId: this.props.focusedItemId,
        lastItemIdToBeOpened: this.props.lastItemIdToBeOpened,
        tabbableItemId: this.props.tabbableItemId,
        itemRender: this.props.itemRender,
        linkRender: this.props.linkRender,
        menuGuid: this.props.menuGuid,
        onMouseOver: this.props.onMouseOver,
        onMouseLeave: this.props.onMouseLeave,
        onMouseDown: this.props.onMouseDown,
        onBlur: this.props.onBlur,
        onFocus: this.props.onFocus,
        onClick: this.props.onClick,
        onOriginalItemNeeded: this.props.onOriginalItemNeeded,
        key: t6
      }
    )) : null;
  }
};
let v$6 = class v extends reactExports.Component {
  constructor(e3) {
    super(e3), this.isFirstRender = true, this.onMouseOver = (t6) => {
      this.props.onMouseOver(this.props.item.id), t6.stopPropagation();
    }, this.onMouseLeave = (t6) => {
      this.props.onMouseLeave(this.props.item.id), t6.stopPropagation();
    }, this.state = { opened: false };
  }
  componentDidMount() {
    const e3 = this.props.focusedItemId, t6 = this.props.item.id;
    e3 && e3 === t6 && this.itemElement.focus({ preventScroll: true }), this.isFirstRender = false;
  }
  componentDidUpdate(e3) {
    const t6 = this.props.focusedItemId, o9 = this.props.item.id;
    if (t6) {
      const i16 = o$k(document);
      e3.focusedItemId !== t6 && t6 === o9 && // https://github.com/telerik/kendo-react/issues/216 :
      // No need to focus the wrapping menu item DOM element
      // when a child DOM element was clicked.
      !this.itemElement.contains(i16) && this.itemElement.focus({ preventScroll: true });
    }
  }
  render() {
    const e3 = this.props.item, t6 = e3.id, o9 = P$c(this.props.menuGuid, t6);
    return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(
      "li",
      {
        id: P$c(this.props.menuGuid, t6),
        className: this.getMenuItemClassName(e3),
        style: e3.cssStyle,
        tabIndex: t6 === this.props.tabbableItemId ? 0 : -1,
        onMouseOver: this.onMouseOver,
        onMouseLeave: this.onMouseLeave,
        onMouseDown: (i16) => this.props.onMouseDown(i16),
        onBlur: (i16) => this.props.onBlur(t6, i16),
        onFocus: () => this.props.onFocus(t6),
        onClick: (i16) => this.props.onClick(i16, t6),
        role: "menuitem",
        "aria-disabled": e3.disabled ? true : void 0,
        "aria-haspopup": e3.items.length > 0 ? true : void 0,
        "aria-expanded": e3.items.length > 0 ? this.Opened : void 0,
        "aria-label": e3.text,
        "aria-owns": this.Opened ? o9 : void 0,
        ref: (i16) => this.itemElement = i16,
        key: "0"
      },
      this.contentRender ? this.renderContent() : this.renderMenuItemLink()
    ), this.renderPopupIfOpened());
  }
  renderContent() {
    const e3 = this.props.item.contentParentItemId;
    return /* @__PURE__ */ reactExports.createElement("div", { className: "k-content", role: "presentation" }, /* @__PURE__ */ reactExports.createElement(this.contentRender, { item: this.props.onOriginalItemNeeded(e3), itemId: e3 }));
  }
  renderMenuItemLink() {
    const e3 = this.props.item;
    if (this.linkRender)
      return /* @__PURE__ */ reactExports.createElement(
        this.linkRender,
        {
          item: this.props.onOriginalItemNeeded(e3.id),
          itemId: e3.id,
          opened: this.Opened,
          dir: f$b(this.props.isDirectionRightToLeft)
        }
      );
    const t6 = this.itemRender ? /* @__PURE__ */ reactExports.createElement(this.itemRender, { item: this.props.onOriginalItemNeeded(e3.id), itemId: e3.id, key: "1" }) : /* @__PURE__ */ reactExports.createElement("span", { className: "k-menu-link-text" }, e3.text);
    return /* @__PURE__ */ reactExports.createElement(p$l, { url: e3.url, opened: this.Opened }, this.renderMenuIconIfApplicable(), t6, this.renderArrowIfApplicable());
  }
  renderPopupIfOpened() {
    if (this.Opened) {
      const e3 = this.props.item.id, { anchorAlign: t6, popupAlign: o9, collision: i16 } = a$i(
        e3,
        this.props.isMenuVertical,
        this.props.isDirectionRightToLeft
      );
      return /* @__PURE__ */ reactExports.createElement(
        a$m,
        {
          anchor: this.itemElement,
          show: true,
          popupClass: this.getPopupClassName(),
          anchorAlign: t6,
          popupAlign: o9,
          collision: i16,
          animate: false,
          key: "1"
        },
        /* @__PURE__ */ reactExports.createElement(
          g$b,
          {
            parentItemId: e3,
            items: this.props.item.items,
            menuGuid: this.props.menuGuid,
            focusedItemId: this.props.focusedItemId,
            lastItemIdToBeOpened: this.props.lastItemIdToBeOpened,
            tabbableItemId: this.props.tabbableItemId,
            itemRender: this.props.itemRender,
            linkRender: this.props.linkRender,
            isMenuVertical: this.props.isMenuVertical,
            isDirectionRightToLeft: this.props.isDirectionRightToLeft,
            className: "k-group k-menu-group k-reset k-menu-group-md",
            onMouseOver: this.props.onMouseOver,
            onMouseLeave: this.props.onMouseLeave,
            onMouseDown: this.props.onMouseDown,
            onBlur: this.props.onBlur,
            onFocus: this.props.onFocus,
            onClick: this.props.onClick,
            onOriginalItemNeeded: this.props.onOriginalItemNeeded
          }
        )
      );
    }
    return null;
  }
  renderMenuIconIfApplicable() {
    const { icon: e3, svgIcon: t6 } = this.props.item;
    return e3 || t6 ? /* @__PURE__ */ reactExports.createElement(v$c, { name: e3, icon: t6, key: "0" }) : null;
  }
  renderArrowIfApplicable() {
    return this.props.item.items.length > 0 ? /* @__PURE__ */ reactExports.createElement("span", { className: "k-menu-expand-arrow", "aria-hidden": true }, /* @__PURE__ */ reactExports.createElement(
      o$e,
      {
        itemId: this.props.item.id,
        verticalMenu: this.props.isMenuVertical,
        dir: f$b(this.props.isDirectionRightToLeft),
        key: "2"
      }
    )) : null;
  }
  get itemRender() {
    return this.props.item.render || this.props.itemRender;
  }
  get linkRender() {
    return this.props.item.linkRender || this.props.linkRender;
  }
  get contentRender() {
    return this.props.item.contentParentItemId ? this.props.item.contentRender : null;
  }
  get Opened() {
    const e3 = this.props;
    return e3.item.items.length > 0 && x$d(e3.item.id, e3.lastItemIdToBeOpened) && // HACK: Wait for the second render because otherwise the scenario of
    // popup inside popup throws an error (for example, hover of item with id '0_0').
    !this.isFirstRender;
  }
  getPopupClassName() {
    return r$r("k-menu-popup", { "k-rtl": this.props.isDirectionRightToLeft });
  }
  getMenuItemClassName(e3) {
    return r$r(
      "k-item",
      "k-menu-item",
      {
        "k-first": p$m(e3.id),
        "k-last": e3.isLastFromSiblings,
        "k-disabled": e3.disabled
      },
      e3.cssClass
    );
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let e$o = class e2 {
  constructor() {
    this.phase = "Initialized";
  }
  getIsDirectionRightToLeft() {
    return this.isDirectionRightToLeft;
  }
  setIsDirectionRightToLeft(i16) {
    this.phase = this.phase === "NotInitialized" ? "Initialized" : "NewValueReceived", this.previousIsDirectionRightToLeft = this.isDirectionRightToLeft, this.isDirectionRightToLeft = i16;
  }
  hasDirectionChanged() {
    return this.phase === "NewValueReceived" ? this.previousIsDirectionRightToLeft !== this.isDirectionRightToLeft : false;
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let n$g = class n4 {
  constructor(e3, s10, i16) {
    this.openOnClick = e3, this.resetMenu = s10, this.openItem = i16, this.mouseDown = false, this.openOnClick = e3, this.isMouseOverEnabled = !e3;
  }
  set OpenOnClick(e3) {
    !!e3 != !!this.openOnClick && (this.mouseDown = false, this.isMouseOverEnabled = !e3), this.openOnClick = e3;
  }
  handleItemSelectedViaKeyboard() {
    this.openOnClick && (this.isMouseOverEnabled = false, this.resetMenu());
  }
  get IsMouseOverEnabled() {
    return this.isMouseOverEnabled;
  }
  handleItemMouseDown() {
    this.mouseDown = true;
  }
  handleItemFocus() {
    this.openOnClick && !this.mouseDown && (this.isMouseOverEnabled = true), this.mouseDown = false;
  }
  handleItemClick(e3, s10) {
    this.openOnClick && (this.isMouseOverEnabled ? s10 && (this.isMouseOverEnabled = false, this.resetMenu()) : (this.isMouseOverEnabled = true, this.openItem(e3)));
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const e$n = {
  name: "@progress/kendo-react-layout",
  productName: "KendoReact",
  productCodes: ["KENDOUIREACT", "KENDOUICOMPLETE"],
  publishDate: 1728906453,
  version: "",
  licensingDocsUrl: "https://www.telerik.com/kendo-react-ui/components/my-license/"
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const h$7 = {
  focusedItemId: u$g,
  hoveredItemId: u$g,
  tabbableItemId: c$f
}, a$h = class a4 extends reactExports.Component {
  constructor(t6) {
    super(t6), this.menuWrapperEl = null, this.directionHolder = new e$o(), this.inputItems = [], this.items = [], this.reset = () => {
      this.clearItemHoverAndLeaveRequestsIfApplicable(), this.setState(h$7);
    }, this.onKeyDown = (e3) => {
      if (this.state.focusedItemId !== u$g) {
        const s10 = s$g(this.state.focusedItemId, this.items), o9 = V$7(
          this.items,
          s10.id,
          e3.keyCode,
          e3.key,
          this.props.vertical,
          this.directionHolder.getIsDirectionRightToLeft()
        );
        s10.id !== o9 && (e3.preventDefault(), this.setFocusedItemId(o9)), (e3.keyCode === e$B.enter || e3.keyCode === e$B.space) && !s10.disabled && (this.mouseOverHandler.handleItemSelectedViaKeyboard(), this.dispatchSelectEventIfWired(e3, s10.id), !e3.isDefaultPrevented() && s10.items.length === 0 && s10.url && window.location.assign(s10.url));
      }
      e3.keyCode === e$B.esc && this.props.onClose && this.props.onClose.call(void 0, e3);
    }, this.onItemMouseOver = (e3) => {
      this.mouseOverHandler.IsMouseOverEnabled && (this.clearItemHoverAndLeaveRequestsIfApplicable(), this.itemHoverRequest = window.setTimeout(() => {
        this.setHoveredItemId(e3), this.itemHoverRequest = null;
      }, n$i(this.props)));
    }, this.onItemMouseLeave = (e3) => {
      this.mouseOverHandler.IsMouseOverEnabled && this.isItemWithDefaultClose(e3) && (this.clearItemHoverAndLeaveRequestsIfApplicable(), this.itemLeaveRequest = window.setTimeout(() => {
        this.setHoveredItemId(u$g), this.itemLeaveRequest = null;
      }, l$h(this.props)));
    }, this.onItemMouseDown = () => {
      this.mouseOverHandler.handleItemMouseDown();
    }, this.onItemFocus = (e3) => {
      this.setFocusedItemId(e3), this.mouseOverHandler.handleItemFocus();
    }, this.onItemClick = (e3, s10) => {
      const o9 = s$g(s10, this.items);
      o9.disabled || (this.setFocusedItemId(s10), this.mouseOverHandler.handleItemClick(s10, this.isItemWithDefaultClose(s10)), this.dispatchSelectEventIfWired(e3, s10), !e3.isDefaultPrevented() && o9.url && window.location.assign(o9.url));
    }, this.onItemBlur = (e3, s10) => {
      if (this.isItemWithDefaultClose(e3) && this.setFocusedItemId(u$g), s10.relatedTarget && s10.relatedTarget.nodeName === "LI") {
        const o9 = s10.relatedTarget.getAttribute("id");
        if (o9 && o9.includes(this.menuItemId))
          return;
      }
      this.props.onClose && this.props.onClose.call(void 0, s10);
    }, this.getInputItem = (e3) => s$g(e3, this.inputItems), l$p(e$n), this.mouseOverHandler = new n$g(this.props.openOnClick, this.reset, this.onItemMouseOver), this.state = Object.assign({}, h$7, { isFirstRender: true });
  }
  get menuItemId() {
    return this.props.id;
  }
  get element() {
    return this.menuWrapperEl;
  }
  /**
   * @hidden
   */
  render() {
    this.prepareItems(), this.state.isFirstRender || this.directionHolder.setIsDirectionRightToLeft(this.checkIsDirectionRightToLeft());
    const t6 = this.state.hoveredItemId ? this.state.hoveredItemId : this.state.focusedItemId ? O$9(this.state.focusedItemId) : u$g;
    return /* @__PURE__ */ reactExports.createElement(
      "div",
      {
        id: this.props.id,
        onKeyDown: this.onKeyDown,
        style: this.props.style,
        className: this.directionHolder.getIsDirectionRightToLeft() ? "k-rtl" : void 0,
        ref: (e3) => this.menuWrapperEl = e3
      },
      /* @__PURE__ */ reactExports.createElement(
        g$b,
        {
          className: this.getMenuClassName(),
          "aria-orientation": this.props.vertical ? "vertical" : void 0,
          items: this.items,
          isMenuVertical: this.props.vertical,
          isDirectionRightToLeft: this.directionHolder.getIsDirectionRightToLeft(),
          focusedItemId: this.state.focusedItemId,
          lastItemIdToBeOpened: t6,
          tabbableItemId: this.state.tabbableItemId,
          itemRender: this.props.itemRender,
          linkRender: this.props.linkRender,
          menuGuid: this.menuItemId,
          onMouseLeave: this.onItemMouseLeave,
          onMouseOver: this.onItemMouseOver,
          onMouseDown: this.onItemMouseDown,
          onFocus: this.onItemFocus,
          onClick: this.onItemClick,
          onBlur: this.onItemBlur,
          onOriginalItemNeeded: this.getInputItem,
          role: this.props.role
        }
      )
    );
  }
  /**
   * @hidden
   */
  componentDidMount() {
    this.setState({ isFirstRender: false });
  }
  /**
   * @hidden
   */
  componentDidUpdate(t6) {
    (!!t6.vertical != !!this.props.vertical || this.directionHolder.hasDirectionChanged()) && this.reset(), this.mouseOverHandler.OpenOnClick = this.props.openOnClick;
  }
  /**
   * @hidden
   */
  componentWillUnmount() {
    this.clearItemHoverAndLeaveRequestsIfApplicable();
  }
  setFocusedItemId(t6) {
    this.setState((e3) => {
      const s10 = t6 === u$g ? e3.tabbableItemId : f$c(t6);
      return { hoveredItemId: t6 === u$g || o$g(e3.hoveredItemId) && o$g(t6) ? e3.hoveredItemId : u$g, focusedItemId: t6, tabbableItemId: s10 };
    });
  }
  setHoveredItemId(t6) {
    this.setState((e3) => o$g(t6) && o$g(e3.focusedItemId) ? {
      hoveredItemId: t6,
      focusedItemId: e3.focusedItemId,
      tabbableItemId: e3.tabbableItemId
    } : { hoveredItemId: t6, focusedItemId: u$g, tabbableItemId: c$f });
  }
  getMenuClassName() {
    return r$r(
      "k-reset",
      "k-header",
      "k-menu",
      { "k-menu-horizontal": !this.props.vertical },
      { "k-menu-vertical": this.props.vertical },
      this.props.className
    );
  }
  clearItemHoverAndLeaveRequestsIfApplicable() {
    this.itemHoverRequest && (clearTimeout(this.itemHoverRequest), this.itemHoverRequest = null), this.itemLeaveRequest && (clearTimeout(this.itemLeaveRequest), this.itemLeaveRequest = null);
  }
  isItemWithDefaultClose(t6) {
    return !this.props.customCloseItemIds || this.props.customCloseItemIds.indexOf(t6) === -1;
  }
  checkIsDirectionRightToLeft() {
    return !!(this.props.dir !== void 0 ? this.props.dir === "rtl" : this.menuWrapperEl && getComputedStyle(this.menuWrapperEl).direction === "rtl");
  }
  prepareItems() {
    const { items: t6, inputItems: e3 } = b$a(this.props.items, this.props.children);
    this.items = t6, this.inputItems = e3;
  }
  dispatchSelectEventIfWired(t6, e3) {
    c$o(this.props.onSelect, t6, this, { item: this.getInputItem(e3), itemId: e3 });
  }
};
a$h.propTypes = {
  vertical: o$r.bool,
  items: o$r.arrayOf(o$r.object),
  style: o$r.object,
  dir: o$r.string,
  hoverOpenDelay: o$r.number,
  hoverCloseDelay: o$r.number,
  openOnClick: o$r.bool,
  itemRender: o$r.any,
  linkRender: o$r.any,
  customCloseItemIds: o$r.arrayOf(o$r.string),
  onSelect: o$r.func,
  role: o$r.string
}, a$h.defaultProps = { vertical: false };
let I$c = a$h;
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const o$d = class o3 extends reactExports.Component {
  constructor() {
    super(...arguments), this.itemRef = null, this.focus = () => {
      this.itemRef && this.itemRef.focus();
    }, this.blur = () => {
      this.itemRef && this.itemRef.blur();
    }, this.onClick = () => {
      this.props.onSelect && this.props.onSelect(this.props.index), this.itemRef && (this.itemRef.tabIndex = 0, this.itemRef.focus());
    };
  }
  /**
   * @hidden
   */
  render() {
    const { id: c6, active: e3, disabled: s10, title: a9 = "Untitled", index: n10, renderAllContent: p6, first: f4, last: m3 } = this.props, l7 = p6 ? `${this.props.contentPanelId}-${n10.toString()}` : this.props.contentPanelId, d8 = {
      id: `${c6}-${n10.toString()}`,
      "aria-selected": e3,
      "aria-controls": e3 ? l7 : void 0,
      "aria-disabled": s10,
      role: "tab",
      onClick: s10 ? void 0 : this.onClick
    }, h3 = r$r("k-item", "k-tabstrip-item", {
      "k-disabled": s10,
      "k-active": e3,
      "k-first": f4,
      "k-last": m3
    });
    return /* @__PURE__ */ reactExports.createElement(
      "li",
      {
        ...d8,
        className: h3,
        ref: (u5) => this.itemRef = u5,
        onBlur: this.blur,
        "aria-controls": l7
      },
      /* @__PURE__ */ reactExports.createElement("span", { className: "k-link" }, a9)
    );
  }
};
o$d.propTypes = {
  active: o$r.bool,
  disabled: o$r.bool,
  index: o$r.number,
  onSelect: o$r.func,
  title: o$r.oneOfType([o$r.string, o$r.element]),
  first: o$r.bool,
  last: o$r.bool
};
let r$b = o$d;
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const e$m = {
  name: "@progress/kendo-react-buttons",
  productName: "KendoReact",
  productCodes: ["KENDOUIREACT", "KENDOUICOMPLETE"],
  publishDate: 1728906392,
  version: "",
  licensingDocsUrl: "https://www.telerik.com/kendo-react-ui/components/my-license/"
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
function R$6({ imageUrl: h3, name: e3, iconClass: s10, svgIcon: c6, imageAlt: a9, buttonClasses: o9 }) {
  return h3 ? /* @__PURE__ */ reactExports.createElement(
    "img",
    {
      role: "presentation",
      className: r$r(G$9.icon({ c: o9 })),
      alt: a9,
      src: h3
    }
  ) : e3 || c6 ? /* @__PURE__ */ reactExports.createElement(v$c, { className: r$r(G$9.icon({ c: o9 })), name: e3, icon: c6 }) : s10 ? /* @__PURE__ */ reactExports.createElement("span", { role: "presentation", className: r$r(G$9.icon({ c: o9 }), s10) }) : null;
}
const l$e = class l3 extends reactExports.Component {
  constructor(e3) {
    super(e3), this._element = null, this.handleClick = (s10) => {
      this.toggleIfApplicable(), this.props.onClick && this.props.onClick.call(void 0, s10);
    }, l$p(e$m), this.state = { selected: this.props.togglable === true && this.props.selected === true };
  }
  /**
   * Gets the DOM element of the Button component.
   */
  get element() {
    return this._element;
  }
  /**
   * Returns `true` when the component is togglable and selected ([see example]({% slug toggleable_button %})).
   * Otherwise, returns `false`.
   */
  get selected() {
    return this._selectedTemp !== void 0 ? this._selectedTemp : this.state.selected;
  }
  /**
   * @hidden
   */
  static getDerivedStateFromProps(e3, s10) {
    return e3.togglable && e3.selected !== void 0 && e3.selected !== s10.selected ? { selected: e3.selected } : null;
  }
  /**
   * @hidden
   */
  render() {
    const {
      children: e3,
      togglable: s10,
      icon: c6,
      iconClass: a9,
      svgIcon: o9,
      imageUrl: u5,
      imageAlt: b2,
      className: C2,
      startIcon: g6,
      endIcon: f4,
      onClick: S2,
      size: k3 = l3.defaultProps.size,
      rounded: E2 = l3.defaultProps.rounded,
      fillMode: P2 = l3.defaultProps.fillMode,
      themeColor: y4 = l3.defaultProps.themeColor,
      ...I3
    } = this.props, N3 = o9 !== void 0 || c6 !== void 0 || a9 !== void 0 || u5 !== void 0, T3 = e3 !== void 0, d8 = this.context && this.context.uButton, x3 = R$6({
      name: c6,
      svgIcon: o9,
      iconClass: a9,
      imageUrl: u5,
      imageAlt: b2,
      buttonClasses: d8
    }), v3 = (m3) => reactExports.cloneElement(m3, { className: r$r(G$9.icon({ c: d8 })) });
    return /* @__PURE__ */ reactExports.createElement(
      "button",
      {
        ref: (m3) => this._element = m3,
        "aria-pressed": s10 ? this.state.selected : void 0,
        ...I3,
        onClick: this.handleClick,
        className: r$r(
          G$9.wrapper({
            c: d8,
            isRtl: this.props.dir === "rtl",
            selected: this.state.selected,
            disabled: this.props.disabled,
            size: k3,
            fillMode: P2,
            rounded: E2,
            themeColor: y4,
            iconButton: !T3 && N3
          }),
          C2
        )
      },
      g6 && v3(g6),
      x3,
      e3 && /* @__PURE__ */ reactExports.createElement("span", { className: r$r(G$9.text({ c: d8 })) }, e3),
      f4 && v3(f4)
    );
  }
  toggleIfApplicable() {
    if (this.props.togglable && this.props.selected === void 0) {
      const e3 = !this.state.selected;
      this._selectedTemp = e3, this.setState({ selected: e3 }, () => this._selectedTemp = void 0);
    }
  }
};
l$e.propTypes = {
  children: o$r.node,
  selected: o$r.bool,
  togglable: o$r.bool,
  icon: o$r.string,
  svgIcon: t$k,
  iconClass: o$r.string,
  imageUrl: o$r.string,
  imageAlt: o$r.string,
  size: o$r.oneOf([null, "small", "medium", "large"]),
  rounded: o$r.oneOf([null, "small", "medium", "large", "full"]),
  fillMode: o$r.oneOf([null, "flat", "link", "outline", "solid", "clear"]),
  // eslint-disable-next-line max-len
  themeColor: o$r.oneOf([
    null,
    "base",
    "primary",
    "secondary",
    "tertiary",
    "info",
    "success",
    "warning",
    "error",
    "dark",
    "light",
    "inverse"
  ])
}, l$e.defaultProps = {
  togglable: false,
  size: "medium",
  rounded: "medium",
  fillMode: "solid",
  themeColor: "base"
};
let p$j = l$e;
p$j.contextType = e$y;
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const x$b = (e3) => {
  const a9 = n$t(), n10 = a9 && a9.uDropDownButton, I3 = reactExports.useCallback(
    (o9) => {
      e3.onClick(o9, e3.index);
    },
    [e3]
  ), d8 = e3.dataItem.render || e3.item || (e3.item === void 0 ? e3.render : null), m3 = e3.dataItem.text !== void 0 ? e3.dataItem.text : e3.textField ? e3.dataItem[e3.textField] : e3.dataItem, l7 = /* @__PURE__ */ reactExports.createElement(
    "li",
    {
      id: e3.id,
      className: r$r(F$4.li({
        c: n10,
        focused: e3.focused
      }), e3.className),
      tabIndex: -1,
      onClick: I3,
      onMouseDown: e3.onDown,
      onPointerDown: e3.onDown,
      role: "menuitem",
      "aria-disabled": e3.dataItem.disabled || void 0
    },
    /* @__PURE__ */ reactExports.createElement(
      "span",
      {
        tabIndex: -1,
        className: r$r(F$4.link({
          c: n10,
          selected: e3.dataItem.selected,
          disabled: e3.dataItem.disabled
        })),
        key: "icon"
      },
      d8 ? /* @__PURE__ */ reactExports.createElement(d8, { item: e3.dataItem, itemIndex: e3.index }) : /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, (e3.dataItem.icon || e3.dataItem.iconClass || e3.dataItem.svgIcon) && /* @__PURE__ */ reactExports.createElement(v$c, { className: e3.dataItem.iconClass, name: e3.dataItem.icon, icon: e3.dataItem.svgIcon }), e3.dataItem.imageUrl && /* @__PURE__ */ reactExports.createElement(
        "img",
        {
          role: "presentation",
          alt: "",
          src: e3.dataItem.imageUrl,
          className: "k-icon"
        }
      ), m3 && /* @__PURE__ */ reactExports.createElement("span", { className: "k-menu-link-text" }, m3))
    )
  );
  return e3.item !== void 0 && /* to be removed in 5.0.0 */
  e3.render !== void 0 ? e3.render.call(void 0, l7, e3) : l7;
};
x$b.displayName = "KendoReactButtonItem";
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const s$c = class s5 extends reactExports.Component {
  /**
   * @hidden
   */
  render() {
    return null;
  }
};
s$c.propTypes = {
  text: o$r.string,
  icon: o$r.string,
  iconClass: o$r.string,
  imageUrl: o$r.string,
  disabled: o$r.bool,
  render: o$r.any
};
let e$l = s$c;
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const i$a = (s10, t6, a9, r12) => {
  if (a9)
    return s10;
  const n10 = Math.min(r12 - 1, Math.max(0, s10));
  switch (t6) {
    case e$B.enter:
    case e$B.space:
    case e$B.esc:
      return -1;
    case e$B.up:
    case e$B.left:
      return n10 - 1 < 0 ? r12 - 1 : n10 - 1;
    case e$B.down:
    case e$B.right:
      return n10 + 1 >= r12 ? 0 : n10 + 1;
    case e$B.home:
      return 0;
    case e$B.end:
      return r12 - 1;
    default:
      return s10;
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
function n$f(i16) {
  let t6 = { horizontal: "left", vertical: "bottom" };
  return i16 && (t6.horizontal = "right"), t6;
}
function o$c(i16) {
  let t6 = { horizontal: "left", vertical: "top" };
  return i16 && (t6.horizontal = "right"), t6;
}
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const l$d = class l4 extends reactExports.Component {
  constructor(i16) {
    super(i16), this.state = {
      focused: false,
      focusedIndex: -1,
      opened: false
    }, this.wrapper = null, this.mainButton = null, this.list = null, this.skipFocus = false, this.buttonsData = [], this.onKeyDown = (t6) => {
      const { focusedIndex: e3 } = this.state;
      if (t6.altKey) {
        !this.opened && t6.keyCode === e$B.down ? (t6.preventDefault(), this.setState({ focusedIndex: 0 }), this.setOpen(true, t6)) : this.opened && t6.keyCode === e$B.up && (t6.preventDefault(), this.setState({ focusedIndex: -1 }), this.setOpen(false, t6));
        return;
      }
      let o9;
      if (t6.keyCode === e$B.enter || t6.keyCode === e$B.space) {
        if (t6.preventDefault(), this.dispatchClickEvent(t6, e3), e3 >= 0) {
          o9 = {
            focusedIndex: this.opened ? -1 : 0
          };
          const n10 = !this.opened;
          this.setOpen(n10, t6);
        }
      } else if (this.opened && t6.keyCode === e$B.esc) {
        this.setState({ focusedIndex: -1 }), this.setOpen(false, t6);
        return;
      }
      if (this.opened) {
        const n10 = i$a(e3, t6.keyCode, t6.altKey, this.buttonsData.length);
        n10 !== e3 && (o9 = o9 || {}, o9.focusedIndex = n10);
        const a9 = t6.keyCode === e$B.up || t6.keyCode === e$B.down || t6.keyCode === e$B.left || t6.keyCode === e$B.right;
        !t6.altKey && (a9 || t6.keyCode === e$B.home || t6.keyCode === e$B.end) && t6.preventDefault();
      }
      o9 && this.setState(o9);
    }, this.switchFocus = (t6) => {
      this.skipFocus = true, t6(), window.setTimeout(() => this.skipFocus = false, 0);
    }, this.onFocus = (t6) => {
      this.skipFocus || (c$o(this.props.onFocus, t6, this, void 0), this.setState({ focused: true }));
    }, this.setOpen = (t6, e3) => {
      this.opened !== t6 && (this.openedDuringOnChange = t6, this.setState({ opened: t6 }), e3 ? this.dispatchPopupEvent(e3, t6) : this.openedDuringOnChange = void 0);
    }, this.onItemClick = (t6, e3) => {
      this.opened && this.setState({ focusedIndex: 0 }), this.dispatchClickEvent(t6, e3), this.setOpen(false, t6);
    }, this.onBlur = (t6) => {
      this.skipFocus || (this.setState({
        focused: false,
        focusedIndex: -1
      }), c$o(this.props.onBlur, t6, this, void 0), setTimeout(() => {
        this.setOpen(false, t6);
      }, 0));
    }, this.onPopupClose = (t6) => {
      var o9;
      const e3 = o$k(document);
      this.element && this.element.removeAttribute("tabindex"), (e3 === this.list || (o9 = this.list) != null && o9.contains(e3)) && this.switchFocus(() => {
        this.element && this.element.focus({ preventScroll: true });
      }), this.props.popupSettings && this.props.popupSettings.onClose && this.props.popupSettings.onClose.call(void 0, t6);
    }, this.listRef = (t6) => {
      this.list = t6, t6 && this.state.focused && this.switchFocus(() => {
        t6.focus({ preventScroll: true }), this.element && (this.element.tabIndex = -1);
      });
    }, this.onSplitPartClick = (t6) => {
      if (this.buttonsData.length) {
        const e3 = !this.opened;
        this.setState({
          focusedIndex: e3 ? 0 : -1,
          focused: true
        }), this.setOpen(e3, t6);
      }
    }, this.onDownSplitPart = (t6) => {
      t6.preventDefault();
      const e3 = o$k(document);
      this.element && e3 !== this.element && e3 !== this.list && this.element.focus();
    }, this.onItemDown = (t6) => {
      o$k(document) === this.list && t6.preventDefault();
    }, this.dispatchPopupEvent = (t6, e3) => {
      c$o(e3 ? this.props.onOpen : this.props.onClose, t6, this, void 0), this.openedDuringOnChange = void 0;
    }, l$p(e$m);
  }
  get guid() {
    return this.props.id ? this.props.id + "-accessibility-id" : this.props.id;
  }
  get opened() {
    return this.openedDuringOnChange !== void 0 ? this.openedDuringOnChange : this.props.opened === void 0 ? this.state.opened : this.props.opened;
  }
  /**
   * @hidden
   */
  render() {
    this.buttonsData = this.props.items || reactExports.Children.toArray(this.props.children).filter((p6) => p6 && p6.type === e$l).map((p6) => p6.props);
    const i16 = this.isRtl(), t6 = i16 ? "rtl" : void 0, { id: e3, style: o9, tabIndex: n10, disabled: a9 } = this.props;
    return /* @__PURE__ */ reactExports.createElement(
      "div",
      {
        id: e3,
        style: o9,
        className: r$r(
          "k-split-button",
          "k-button-group",
          {
            "k-focus": this.state.focused
          },
          `k-rounded-${e$v.roundedMap[this.props.rounded || "medium"]}`,
          this.props.className
        ),
        onKeyDown: this.onKeyDown,
        onFocus: this.onFocus,
        onBlur: this.onBlur,
        dir: t6,
        ref: (p6) => this.wrapper = p6
      },
      /* @__PURE__ */ reactExports.createElement(
        p$j,
        {
          ref: (p6) => this.mainButton = p6 && p6.element,
          type: "button",
          size: this.props.size,
          rounded: this.props.rounded,
          fillMode: this.props.fillMode,
          themeColor: this.props.themeColor,
          onClick: (p6) => this.onItemClick(p6, -1),
          disabled: a9 || void 0,
          tabIndex: n10,
          accessKey: this.props.accessKey,
          className: this.props.buttonClass,
          icon: this.props.icon,
          svgIcon: this.props.svgIcon,
          iconClass: this.props.iconClass,
          imageUrl: this.props.imageUrl,
          dir: t6,
          "aria-disabled": a9,
          "aria-haspopup": true,
          "aria-expanded": this.opened || void 0,
          "aria-label": this.props.ariaLabel,
          "aria-controls": this.opened ? this.guid : void 0,
          id: "button-" + this.guid,
          title: this.props.title
        },
        this.props.text
      ),
      /* @__PURE__ */ reactExports.createElement(
        p$j,
        {
          type: "button",
          size: this.props.size,
          rounded: this.props.rounded,
          fillMode: this.props.fillMode,
          themeColor: this.props.themeColor,
          icon: "caret-alt-down",
          svgIcon: caretAltDownIcon,
          className: "k-split-button-arrow",
          disabled: a9 || void 0,
          tabIndex: -1,
          onClick: this.onSplitPartClick,
          onMouseDown: this.onDownSplitPart,
          onPointerDown: this.onDownSplitPart,
          dir: t6,
          "aria-label": "menu toggling button"
        }
      ),
      this.renderPopup(i16)
    );
  }
  /**
   * @hidden
   */
  componentDidMount() {
    (this.props.dir === void 0 && this.isRtl() || this.opened) && this.forceUpdate();
  }
  /**
   * The DOM element of main button.
   */
  get element() {
    return this.mainButton;
  }
  dispatchClickEvent(i16, t6) {
    this.isItemDisabled(t6) || (t6 === -1 ? c$o(this.props.onButtonClick, i16, this, void 0) : c$o(this.props.onItemClick, i16, this, {
      item: this.buttonsData[t6],
      itemIndex: t6
    }));
  }
  renderPopup(i16) {
    const { popupSettings: t6 = {} } = this.props, { focusedIndex: e3 } = this.state;
    return /* @__PURE__ */ reactExports.createElement(
      a$m,
      {
        anchor: this.wrapper,
        show: this.opened,
        animate: t6.animate,
        popupClass: r$r("k-menu-popup", t6.popupClass),
        anchorAlign: t6.anchorAlign || n$f(i16),
        popupAlign: t6.popupAlign || o$c(i16),
        style: i16 ? { direction: "rtl" } : void 0,
        onClose: this.onPopupClose
      },
      /* @__PURE__ */ reactExports.createElement(
        "ul",
        {
          role: "menu",
          id: this.guid,
          "aria-labelledby": "button-" + this.guid,
          tabIndex: -1,
          ref: this.listRef,
          "aria-activedescendant": e3 >= 0 ? `${this.guid}-${e3}` : void 0,
          className: r$r("k-menu-group", {
            [`k-menu-group-${e$v.sizeMap[this.props.size] || this.props.size}`]: this.props.size
          })
        },
        this.renderChildItems()
      )
    );
  }
  renderChildItems() {
    const { item: i16, itemRender: t6, textField: e3 } = this.props;
    return this.buttonsData.length > 0 ? this.buttonsData.map((o9, n10) => /* @__PURE__ */ reactExports.createElement(
      x$b,
      {
        className: "k-menu-item",
        dataItem: o9,
        textField: e3,
        focused: this.state.focusedIndex === n10,
        onClick: this.onItemClick,
        onDown: this.onItemDown,
        render: t6,
        item: i16,
        key: n10,
        index: n10,
        id: `${this.guid}-${n10}`
      }
    )) : null;
  }
  isItemDisabled(i16) {
    return this.buttonsData[i16] ? this.buttonsData[i16].disabled : this.props.disabled;
  }
  isRtl() {
    return this.props.dir !== void 0 ? this.props.dir === "rtl" : !!this.wrapper && getComputedStyle(this.wrapper).direction === "rtl";
  }
};
l$d.propTypes = {
  accessKey: o$r.string,
  ariaLabel: o$r.string,
  title: o$r.string,
  onButtonClick: o$r.func,
  onFocus: o$r.func,
  onBlur: o$r.func,
  onItemClick: o$r.func,
  onOpen: o$r.func,
  onClose: o$r.func,
  text: o$r.string,
  items: o$r.arrayOf(o$r.any),
  textField: o$r.string,
  tabIndex: o$r.number,
  disabled: o$r.bool,
  icon: o$r.string,
  svgIcon: t$k,
  iconClass: o$r.string,
  imageUrl: o$r.string,
  popupSettings: o$r.object,
  itemRender: o$r.any,
  item: o$r.func,
  className: o$r.string,
  buttonClass: o$r.string,
  dir: o$r.string
}, l$d.defaultProps = {
  size: "medium",
  rounded: "medium",
  fillMode: "solid",
  themeColor: "base"
};
let g$a = l$d;
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const s$b = class s6 extends reactExports.Component {
  /**
   * @hidden
   */
  render() {
    return null;
  }
};
s$b.propTypes = {
  text: o$r.string,
  icon: o$r.string,
  iconClass: o$r.string,
  imageUrl: o$r.string,
  selected: o$r.bool,
  disabled: o$r.bool,
  render: o$r.any
};
let r$a = s$b;
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const c$d = class c4 extends reactExports.Component {
  constructor(i16) {
    super(i16), this.state = {
      opened: false,
      focused: false,
      focusedIndex: -1
    }, this.mainButton = null, this.list = null, this.skipFocus = false, this.buttonsData = [], this.onKeyDown = (t6) => {
      const { focusedIndex: e3 } = this.state;
      if (t6.altKey) {
        !this.opened && t6.keyCode === e$B.down ? (t6.preventDefault(), this.setOpen(true, t6), this.setState({ focusedIndex: 0 })) : this.opened && t6.keyCode === e$B.up && (t6.preventDefault(), this.setState({ focusedIndex: -1 }), this.setOpen(false, t6));
        return;
      }
      const o9 = { ...this.state };
      if (t6.keyCode === e$B.enter || t6.keyCode === e$B.space) {
        t6.preventDefault(), e3 >= 0 && this.dispatchClickEvent(t6, e3);
        const n10 = !this.opened;
        this.setState({
          focused: true,
          focusedIndex: n10 ? 0 : -1
        }), this.setOpen(n10, t6);
        return;
      }
      if (this.opened && t6.keyCode === e$B.esc) {
        this.setState({ focusedIndex: -1 }), this.setOpen(false, t6);
        return;
      }
      if (this.opened) {
        const n10 = i$a(e3, t6.keyCode, t6.altKey, this.buttonsData.length);
        o9.focusedIndex = n10;
        const h3 = t6.keyCode === e$B.up || t6.keyCode === e$B.down || t6.keyCode === e$B.left || t6.keyCode === e$B.right;
        !t6.altKey && (h3 || t6.keyCode === e$B.home || t6.keyCode === e$B.end) && t6.preventDefault();
      }
      this.setState(o9);
    }, this.switchFocus = (t6) => {
      this.skipFocus = true, t6(), window.setTimeout(() => this.skipFocus = false, 0);
    }, this.handleFocus = (t6) => {
      this.skipFocus || (this.setState({ focused: true, focusedIndex: this.opened ? 0 : -1 }), c$o(this.props.onFocus, t6, this, void 0));
    }, this.handleButtonBlur = (t6) => {
      this.opened || (this.setState({ focused: false }), c$o(this.props.onBlur, t6, this, void 0));
    }, this.handleMenuBlur = (t6) => {
      this.skipFocus || (this.setState({ focused: false, focusedIndex: -1 }), c$o(this.props.onBlur, t6, this, void 0), setTimeout(() => {
        this.setOpen(false, t6);
      }, 0));
    }, this.setOpen = (t6, e3) => {
      this.opened !== t6 && (this.openedDuringOnChange = t6, this.setState({ opened: t6 }), e3 ? this.dispatchPopupEvent(e3, t6) : this.openedDuringOnChange = void 0);
    }, this.onItemClick = (t6, e3) => {
      this.setState({ focusedIndex: -1 }), this.dispatchClickEvent(t6, e3), this.setOpen(false, t6);
    }, this.onItemDown = (t6) => {
      o$k(document) === this.list && t6.preventDefault();
    }, this.mouseDown = (t6) => {
      t6.preventDefault();
      const e3 = o$k(document);
      this.element && e3 !== this.element && e3 !== this.list && this.element.focus();
    }, this.onPopupClose = (t6) => {
      var o9;
      const e3 = o$k(document);
      this.element && this.element.removeAttribute("tabindex"), (e3 === this.list || (o9 = this.list) != null && o9.contains(e3)) && this.switchFocus(() => {
        this.element && this.element.focus({ preventScroll: true });
      }), this.props.popupSettings && this.props.popupSettings.onClose && this.props.popupSettings.onClose.call(void 0, t6);
    }, this.listRef = (t6) => {
      this.list = t6, t6 && this.state.focused && this.switchFocus(() => {
        t6.focus({ preventScroll: true }), this.element && (this.element.tabIndex = -1);
      });
    }, this.onClickMainButton = (t6) => {
      if (!this.buttonsData.length)
        return;
      const e3 = !this.opened;
      this.setState({
        focused: true,
        focusedIndex: e3 ? 0 : -1
      }), this.setOpen(e3, t6);
    }, this.dispatchPopupEvent = (t6, e3) => {
      c$o(e3 ? this.props.onOpen : this.props.onClose, t6, this, void 0), this.openedDuringOnChange = void 0;
    }, l$p(e$m);
  }
  get guid() {
    return this.props.id + "-accessibility-id";
  }
  get opened() {
    return this.openedDuringOnChange !== void 0 ? this.openedDuringOnChange : this.props.opened === void 0 ? this.state.opened : this.props.opened;
  }
  /**
   * @hidden
   */
  render() {
    const i16 = this.isRtl(), t6 = this.context && this.context.uDropDownButton, e3 = i16 ? "rtl" : void 0, {
      id: o9,
      style: n10,
      tabIndex: h3,
      disabled: g6,
      size: C2,
      rounded: y4,
      fillMode: D2,
      themeColor: b2,
      ariaLabel: I3,
      title: k3,
      accessKey: x3,
      icon: w3,
      svgIcon: B2,
      iconClass: S2,
      buttonClass: O2,
      className: F2,
      imageUrl: E2,
      startIcon: v3,
      endIcon: K3
    } = this.props;
    return this.buttonsData = this.props.items || reactExports.Children.toArray(this.props.children).filter((a9) => a9 && a9.type === r$a).map((a9) => a9.props), /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(
      p$j,
      {
        id: o9,
        size: C2,
        style: n10,
        rounded: y4,
        fillMode: D2,
        themeColor: b2,
        onClick: this.onClickMainButton,
        onMouseDown: this.mouseDown,
        onKeyDown: this.onKeyDown,
        onFocus: this.handleFocus,
        onBlur: this.handleButtonBlur,
        "aria-disabled": g6 ? "true" : void 0,
        tabIndex: h3,
        accessKey: x3,
        icon: w3,
        svgIcon: B2,
        iconClass: S2,
        className: r$r(
          O2,
          F2,
          F$4.wrapper({
            c: t6,
            focused: this.state.focused,
            disabled: g6
          })
        ),
        imageUrl: E2,
        dir: e3,
        ref: (a9) => this.mainButton = a9 && a9.element,
        type: "button",
        "aria-expanded": this.opened ? "true" : "false",
        "aria-label": I3,
        "aria-controls": this.opened ? this.guid : void 0,
        title: k3,
        startIcon: v3,
        endIcon: K3
      },
      this.props.text
    ), this.renderPopup(i16));
  }
  /**
   * @hidden
   */
  componentDidMount() {
    (this.props.dir === void 0 && this.isRtl() || this.opened) && this.forceUpdate();
  }
  /**
   * The DOM element of main button.
   */
  get element() {
    return this.mainButton;
  }
  dispatchClickEvent(i16, t6) {
    this.isItemDisabled(t6) || c$o(this.props.onItemClick, i16, this, {
      item: this.buttonsData[t6],
      itemIndex: t6
    });
  }
  renderPopup(i16) {
    const { popupSettings: t6 = {}, id: e3 } = this.props, o9 = this.context && this.context.uDropDownButton, { focusedIndex: n10 } = this.state;
    return /* @__PURE__ */ reactExports.createElement(
      a$m,
      {
        anchor: this.mainButton,
        show: this.opened,
        animate: t6.animate,
        popupClass: r$r(F$4.popup({ c: o9 }), t6.popupClass),
        anchorAlign: t6.anchorAlign || n$f(i16),
        popupAlign: t6.popupAlign || o$c(i16),
        style: i16 ? { direction: "rtl" } : void 0,
        onClose: this.onPopupClose
      },
      /* @__PURE__ */ reactExports.createElement(
        "ul",
        {
          role: "list",
          id: this.guid,
          tabIndex: -1,
          "aria-activedescendant": n10 >= 0 ? `${this.guid}-${n10}` : void 0,
          ref: this.listRef,
          onKeyDown: this.onKeyDown,
          onBlur: this.handleMenuBlur,
          className: r$r(
            F$4.ul({
              c: o9,
              size: this.props.size
            })
          )
        },
        this.renderChildItems()
      )
    );
  }
  renderChildItems() {
    const { item: i16, itemRender: t6, textField: e3 } = this.props, o9 = this.context && this.context.uDropDownButton;
    return this.buttonsData.length > 0 ? this.buttonsData.map((n10, h3) => /* @__PURE__ */ reactExports.createElement(
      x$b,
      {
        className: r$r(F$4.item({ c: o9 })),
        dataItem: n10,
        textField: e3,
        focused: this.state.focusedIndex === h3,
        onClick: this.onItemClick,
        onDown: this.onItemDown,
        render: t6,
        item: i16,
        index: h3,
        key: h3,
        id: `${this.guid}-${h3}`
      }
    )) : null;
  }
  isItemDisabled(i16) {
    return this.buttonsData[i16] ? this.buttonsData[i16].disabled : this.props.disabled;
  }
  isRtl() {
    return this.props.dir !== void 0 ? this.props.dir === "rtl" : !!this.mainButton && getComputedStyle(this.mainButton).direction === "rtl";
  }
};
c$d.propTypes = {
  accessKey: o$r.string,
  ariaLabel: o$r.string,
  title: o$r.string,
  onFocus: o$r.func,
  onBlur: o$r.func,
  onItemClick: o$r.func,
  onOpen: o$r.func,
  onClose: o$r.func,
  items: o$r.arrayOf(o$r.any),
  textField: o$r.string,
  tabIndex: o$r.number,
  disabled: o$r.bool,
  icon: o$r.string,
  svgIcon: t$k,
  iconClass: o$r.string,
  imageUrl: o$r.string,
  popupSettings: o$r.object,
  itemRender: o$r.func,
  item: o$r.func,
  className: o$r.string,
  buttonClass: o$r.string,
  dir: o$r.string
}, c$d.defaultProps = {
  size: "medium",
  rounded: "medium",
  fillMode: "solid",
  themeColor: "base"
};
let f$a = c$d;
f$a.contextType = e$y;
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const p$i = m$l(f$a);
p$i.displayName = "KendoReactDropDownButton";
const n$e = m$l(g$a);
n$e.displayName = "KendoReactSplitButton";
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const r$9 = "prevArrow.title", t$f = "nextArrow.title", e$k = {
  [r$9]: "Previous tab arrow",
  [t$f]: "Next tab arrow"
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const B$7 = (w3) => Array.apply(null, Array(w3)), O$8 = (w3) => w3.preventDefault(), u$f = "smooth", d$h = "prev", b$9 = "next", T$7 = class T extends reactExports.Component {
  constructor(s10) {
    super(s10), this.itemsNavRef = reactExports.createRef(), this.isRtl = () => this.props.dir === "rtl", this.onWheel = (t6) => {
      t6.stopPropagation();
      const l7 = t6.deltaY < 0 ? d$h : b$9;
      this.setNewScrollPosition(l7, t6);
    }, this.arrowClickPrev = (t6) => {
      this.handleArrowClick(d$h, t6);
    }, this.arrowClickNext = (t6) => {
      this.handleArrowClick(b$9, t6);
    }, this.handleArrowClick = (t6, l7) => {
      this.setNewScrollPosition(t6, l7);
    }, this.setNewScrollPosition = (t6, l7) => {
      const e3 = this.itemsNavRef.current;
      if (!e3)
        return;
      const c6 = this.horizontalScroll(), n10 = c6 ? e3.scrollWidth - e3.offsetWidth : e3.scrollHeight - e3.offsetHeight, r12 = (l7.type === "click" ? this.props.buttonScrollSpeed : this.props.mouseScrollSpeed) || 0;
      let o9 = c6 ? e3.scrollLeft : e3.scrollTop, i16 = c6 ? e3.scrollWidth - e3.scrollLeft : e3.scrollHeight - e3.scrollTop, m3 = e3.scrollWidth - e3.scrollLeft * -1;
      this.isRtl() && this.horizontalScroll() ? (t6 === d$h && o9 < 0 && (o9 += r12, m3 += r12), t6 === b$9 && o9 < n10 && (o9 -= r12, m3 -= r12), o9 = Math.min(0, Math.min(n10, o9))) : (t6 === d$h && o9 > 0 && (o9 -= r12, i16 += r12), t6 === b$9 && o9 < n10 && (o9 += r12, i16 -= r12), o9 = Math.max(0, Math.min(n10, o9)));
      const h3 = o9 === 0, v3 = l7.type === "click" ? u$f : void 0;
      if (c6) {
        const S2 = this.isRtl() ? Math.round(m3) <= e3.clientWidth || Math.floor(m3) <= e3.clientWidth : Math.round(i16) <= e3.clientWidth || Math.floor(i16) <= e3.clientWidth;
        this.setState({
          disabledPrev: h3,
          disabledNext: S2
        }), e3.scrollTo({ left: o9, behavior: v3 });
      } else
        this.setState({
          disabledPrev: h3,
          disabledNext: Math.round(i16) <= e3.clientHeight || Math.floor(i16) <= e3.clientHeight
        }), e3.scrollTo({ top: o9, behavior: v3 });
    }, this.renderArrow = (t6, l7) => {
      const e3 = this.horizontalScroll(), c6 = s$k(this), n10 = {
        prev: {
          arrowTab: "k-tabstrip-prev",
          fontIcon: e3 ? this.isRtl() ? "caret-alt-right" : "caret-alt-left" : "caret-alt-up",
          svgIcon: e3 ? this.isRtl() ? caretAltRightIcon : caretAltLeftIcon : caretAltUpIcon,
          title: c6.toLanguageString(r$9, e$k[r$9])
        },
        next: {
          arrowTab: "k-tabstrip-next",
          fontIcon: e3 ? this.isRtl() ? "caret-alt-left" : "caret-alt-right" : "caret-alt-down",
          svgIcon: e3 ? this.isRtl() ? caretAltLeftIcon : caretAltRightIcon : caretAltDownIcon,
          title: c6.toLanguageString(t$f, e$k[t$f])
        }
      }, r12 = (t6 === d$h ? this.props.prevButton : this.props.nextButton) || p$j, o9 = t6 === d$h ? this.arrowClickPrev : this.arrowClickNext;
      return /* @__PURE__ */ reactExports.createElement(
        r12,
        {
          disabled: l7,
          className: `${n10[t6].arrowTab}`,
          onClick: o9,
          icon: n10[t6].fontIcon,
          svgIcon: n10[t6].svgIcon,
          onMouseDown: O$8,
          tabIndex: -1,
          fillMode: "flat",
          title: n10[t6].title
        }
      );
    }, this.state = {
      disabledPrev: this.props.selected === 0,
      disabledNext: this.props.selected === reactExports.Children.count(this.props.children) - 1
    };
  }
  /**
   * @hidden
   */
  componentDidMount() {
    this.props.scrollable && this.scrollToSelected();
  }
  /**
   * @hidden
   */
  componentDidUpdate(s10) {
    const { scrollable: t6, selected: l7 } = this.props;
    t6 && s10.selected !== l7 && (this.scrollToSelected(), this.setState({
      disabledPrev: l7 === 0,
      disabledNext: l7 === reactExports.Children.count(this.props.children) - 1
    }));
  }
  /**
   * @hidden
   */
  render() {
    const {
      selected: s10,
      tabPosition: t6,
      tabAlignment: l7,
      children: e3,
      onSelect: c6,
      onKeyDown: n10,
      navItemId: r12,
      contentPanelId: o9,
      renderAllContent: i16,
      scrollable: m3,
      scrollButtonsPosition: h3
    } = this.props, v3 = reactExports.Children.count(e3), S2 = reactExports.Children.toArray(e3);
    let g6;
    e3 && (g6 = B$7(v3).map((U3, p6, M3) => {
      const E2 = {
        active: s10 === p6,
        disabled: S2[p6].props.disabled,
        index: p6,
        title: S2[p6].props.title,
        first: p6 === 0,
        last: p6 === M3.length - 1,
        contentPanelId: o9,
        renderAllContent: i16,
        id: r12,
        onSelect: c6
      };
      return /* @__PURE__ */ reactExports.createElement(r$b, { key: p6, ...E2 });
    }));
    const L3 = r$r("k-tabstrip-items-wrapper", {
      "k-hstack": t6 === "top" || t6 === "bottom",
      "k-vstack": t6 === "left" || t6 === "right"
    }), P2 = r$r("k-tabstrip-items", "k-reset", `k-tabstrip-items-${l7}`);
    return /* @__PURE__ */ reactExports.createElement("div", { className: L3 }, m3 ? /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, (h3 === "around" || h3 === "before") && this.renderArrow(d$h, this.state.disabledPrev), h3 === "before" && this.renderArrow(b$9, this.state.disabledNext), /* @__PURE__ */ reactExports.createElement(
      "ul",
      {
        ref: this.itemsNavRef,
        className: P2,
        role: "tablist",
        tabIndex: this.props.tabIndex,
        onKeyDown: n10,
        onWheel: this.onWheel,
        "aria-orientation": t6 === "left" || t6 === "right" ? "vertical" : void 0
      },
      g6
    ), h3 === "after" && this.renderArrow(d$h, this.state.disabledPrev), (h3 === "around" || h3 === "after") && this.renderArrow(b$9, this.state.disabledNext)) : /* @__PURE__ */ reactExports.createElement("ul", { className: P2, role: "tablist", tabIndex: this.props.tabIndex, onKeyDown: n10 }, g6));
  }
  scrollToSelected() {
    const s10 = this.itemsNavRef.current, t6 = s10 && s10.children[this.props.selected || 0];
    if (t6 instanceof HTMLElement && s10 instanceof HTMLElement) {
      const l7 = this.horizontalScroll(), e3 = l7 ? s10.offsetWidth : s10.offsetHeight, c6 = l7 ? t6.offsetWidth : t6.offsetHeight, n10 = l7 ? "left" : "top";
      let r12 = l7 ? s10.scrollLeft : s10.scrollTop, o9 = 0;
      if (this.isRtl()) {
        const i16 = t6.offsetLeft;
        r12 = r12 * -1, i16 < 0 ? (o9 = i16 - c6 + s10.offsetLeft, s10.scrollTo({ [n10]: o9, behavior: u$f })) : i16 + c6 > e3 - r12 && (o9 = r12 + i16 - c6, s10.scrollTo({ [n10]: o9, behavior: u$f }));
      } else {
        const i16 = l7 ? t6.offsetLeft - s10.offsetLeft : t6.offsetTop - s10.offsetTop;
        r12 + e3 < i16 + c6 ? (o9 = i16 + c6 - e3, s10.scrollTo({ [n10]: o9, behavior: u$f })) : r12 > i16 && (o9 = i16, s10.scrollTo({ [n10]: o9, behavior: u$f }));
      }
    }
  }
  horizontalScroll() {
    return /top|bottom/.test(this.props.tabPosition || "top");
  }
};
T$7.propTypes = {
  children: o$r.oneOfType([o$r.element, o$r.arrayOf(o$r.element)]),
  onSelect: o$r.func,
  onKeyDown: o$r.func,
  selected: o$r.number,
  tabIndex: o$r.number
};
let R$5 = T$7;
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const s$a = class s7 extends reactExports.Component {
  constructor() {
    super(...arguments), this.elementRef = reactExports.createRef();
  }
  /**
   * The element that is being animated.
   */
  get element() {
    return this.elementRef.current;
  }
  /**
   * @hidden
   */
  render() {
    const {
      children: g6,
      style: y4,
      appear: S2,
      enter: v3,
      exit: b2,
      transitionName: a9,
      transitionEnterDuration: m3,
      transitionExitDuration: c6,
      className: R2,
      onEnter: E2,
      onEntering: d8,
      onEntered: x3,
      onExit: u5,
      onExiting: p6,
      onExited: h3,
      onAfterExited: f4,
      mountOnEnter: A2,
      unmountOnExit: N3,
      animationEnteringStyle: O2,
      animationEnteredStyle: D2,
      animationExitingStyle: T3,
      animationExitedStyle: j2,
      ...q2
    } = this.props, e3 = this.context && this.context.uAnimation, C2 = r$r(R2, x$h.childContainer({ c: e3 })), P2 = {
      transitionDelay: "0ms",
      ...y4
    }, $2 = {
      entering: { transitionDuration: `${m3}ms`, ...O2 },
      entered: { ...D2 },
      exiting: { transitionDuration: `${c6}ms`, ...T3 },
      exited: { ...j2 }
    }, U3 = {
      in: this.props.in,
      appear: S2,
      enter: v3,
      exit: b2,
      mountOnEnter: A2,
      unmountOnExit: N3,
      timeout: {
        enter: m3,
        exit: c6
      },
      onEnter: () => {
        E2 && E2.call(void 0, { animatedElement: this.element, target: this });
      },
      onEntering: () => {
        d8 && d8.call(void 0, { animatedElement: this.element, target: this });
      },
      onEntered: () => {
        x3 && x3.call(void 0, { animatedElement: this.element, target: this });
      },
      onExit: () => {
        u5 && u5.call(void 0, { animatedElement: this.element, target: this });
      },
      onExiting: () => {
        p6 && p6.call(void 0, { animatedElement: this.element, target: this });
      },
      onExited: () => {
        f4 && f4.call(void 0, { animatedElement: this.element, target: this }), h3 && h3.call(void 0, { animatedElement: this.element, target: this });
      },
      classNames: {
        appear: r$r(x$h.appear({ c: e3, transitionName: a9 })),
        appearActive: r$r(x$h.appearActive({ c: e3, transitionName: a9 })),
        enter: r$r(x$h.enter({ c: e3, transitionName: a9 })),
        enterActive: r$r(x$h.enterActive({ c: e3, transitionName: a9 })),
        exit: r$r(x$h.exit({ c: e3, transitionName: a9 })),
        exitActive: r$r(x$h.exitActive({ c: e3, transitionName: a9 }))
      }
    };
    return /* @__PURE__ */ reactExports.createElement(z$9, { ...U3, ...q2, nodeRef: this.elementRef }, (k3) => /* @__PURE__ */ reactExports.createElement(
      "div",
      {
        style: {
          ...P2,
          ...$2[k3]
        },
        className: C2,
        ref: this.elementRef
      },
      g6
    ));
  }
};
s$a.propTypes = {
  in: o$r.bool,
  children: o$r.oneOfType([
    o$r.arrayOf(o$r.node),
    o$r.node
  ]),
  transitionName: o$r.string.isRequired,
  className: o$r.string,
  appear: o$r.bool,
  enter: o$r.bool,
  exit: o$r.bool,
  transitionEnterDuration: o$r.number.isRequired,
  transitionExitDuration: o$r.number.isRequired,
  mountOnEnter: o$r.bool,
  unmountOnExit: o$r.bool,
  animationEnteringStyle: o$r.object,
  animationEnteredStyle: o$r.object,
  animationExitingStyle: o$r.object,
  animationExitedStyle: o$r.object
}, s$a.defaultProps = {
  mountOnEnter: true,
  unmountOnExit: false,
  onEnter: n$x,
  onEntering: n$x,
  onEntered: n$x,
  onExit: n$x,
  onExiting: n$x,
  onExited: n$x,
  onAfterExited: n$x,
  animationEnteringStyle: {},
  animationEnteredStyle: {},
  animationExitingStyle: {},
  animationExitedStyle: {}
};
let l$c = s$a;
l$c.contextType = e$y;
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const e$j = {
  name: "@progress/kendo-react-animation",
  productName: "KendoReact",
  productCodes: ["KENDOUIREACT", "KENDOUICOMPLETE"],
  publishDate: 1728906391,
  version: "",
  licensingDocsUrl: "https://www.telerik.com/kendo-react-ui/components/my-license/"
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const o$b = class o4 extends reactExports.Component {
  constructor(n10) {
    super(n10), l$p(e$j);
  }
  /**
   * @hidden
   */
  render() {
    const {
      id: n10,
      style: i16,
      children: s10,
      component: a9,
      className: c6,
      childFactory: l7,
      stackChildren: T3,
      componentChildStyle: m3,
      componentChildClassName: p6,
      ...d8
    } = this.props, u5 = this.context && this.context.uAnimation, h3 = {
      id: n10,
      style: i16,
      component: a9,
      childFactory: l7,
      className: r$r(x$h.child({ c: u5 }), c6)
    }, y4 = reactExports.Children.map(s10 || null, (f4) => /* @__PURE__ */ reactExports.createElement(
      l$c,
      {
        ...d8,
        style: m3,
        className: p6
      },
      f4
    ));
    return /* @__PURE__ */ reactExports.createElement(q$5, { ...h3 }, y4);
  }
};
o$b.propTypes = {
  children: o$r.oneOfType([
    o$r.arrayOf(o$r.node),
    o$r.node
  ]),
  childFactory: o$r.any,
  className: o$r.string,
  component: o$r.string,
  id: o$r.string,
  style: o$r.any,
  transitionName: o$r.string.isRequired,
  appear: o$r.bool.isRequired,
  enter: o$r.bool.isRequired,
  exit: o$r.bool.isRequired,
  transitionEnterDuration: o$r.number.isRequired,
  transitionExitDuration: o$r.number.isRequired
}, o$b.defaultProps = {
  component: "div"
};
let r$8 = o$b;
r$8.contextType = e$y;
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const n$d = class n5 extends reactExports.Component {
  /**
   * @hidden
   */
  render() {
    const {
      children: i16,
      ...o9
    } = this.props, s10 = {
      transitionName: "fade"
    };
    return /* @__PURE__ */ reactExports.createElement(r$8, { ...s10, ...o9 }, i16);
  }
};
n$d.propTypes = {
  children: o$r.oneOfType([
    o$r.arrayOf(o$r.node),
    o$r.node
  ]),
  childFactory: o$r.any,
  className: o$r.string,
  component: o$r.string,
  id: o$r.string,
  style: o$r.any
}, n$d.defaultProps = {
  appear: false,
  enter: true,
  exit: false,
  transitionEnterDuration: 500,
  transitionExitDuration: 500
};
let e$i = n$d;
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const l$b = class l5 extends reactExports.Component {
  constructor() {
    super(...arguments), this.contentId = this.props.contentPanelId, this.childFactory = (e3) => reactExports.cloneElement(e3, {
      ...e3.props,
      in: e3.props.children.props.id === String(this.contentId + this.props.selected)
    });
  }
  /**
   * @hidden
   */
  render() {
    const { children: e3, selected: t6, contentPanelId: r12, keepTabsMounted: s10, navItemId: o9, renderAllContent: p6 } = this.props, a9 = e3 && typeof t6 == "number" && reactExports.Children.toArray(e3)[t6], m3 = r$r(
      "k-tabstrip-content",
      "k-active",
      a9 && a9.props.contentClassName
    );
    return p6 ? this.renderAllContent(e3) : /* @__PURE__ */ reactExports.createElement(
      "div",
      {
        className: m3,
        style: this.props.style,
        id: r12,
        role: "tabpanel",
        "aria-hidden": s10,
        "aria-labelledby": `${o9}-${(t6 == null ? void 0 : t6.toString()) || ""}`,
        tabIndex: 0
      },
      this.renderContent(e3)
    );
  }
  renderContent(e3) {
    return this.props.keepTabsMounted ? reactExports.Children.map(this.props.children, (t6, r12) => this.renderChild(t6, r12)) : this.renderChild(
      reactExports.Children.toArray(e3)[this.props.selected],
      this.props.selected
    );
  }
  renderAllContent(e3) {
    return reactExports.Children.map(e3, (t6, r12) => {
      const s10 = t6, o9 = r12 === this.props.selected, p6 = r$r(
        "k-tabstrip-content",
        { "k-active": o9 },
        s10.props.contentClassName
      );
      return /* @__PURE__ */ reactExports.createElement(
        "div",
        {
          className: p6,
          style: this.props.style,
          id: `${this.props.contentPanelId}-${r12}`,
          role: "tabpanel",
          "aria-hidden": !o9,
          hidden: !o9,
          "aria-labelledby": `${this.props.navItemId}-${r12}`
        },
        this.props.animation ? /* @__PURE__ */ reactExports.createElement(
          e$i,
          {
            key: `${r12}-${o9}`,
            appear: true,
            enter: true,
            exit: false
          },
          s10.props.children
        ) : s10.props.children
      );
    });
  }
  renderChild(e3, t6) {
    const r12 = t6 === this.props.selected, s10 = {
      style: {
        display: r12 ? void 0 : "none"
      }
    }, o9 = {
      position: "initial",
      display: r12 ? void 0 : "none"
    };
    return e3.props.disabled ? null : this.props.animation ? /* @__PURE__ */ reactExports.createElement(
      e$i,
      {
        appear: true,
        exit: this.props.keepTabsMounted,
        style: o9,
        childFactory: this.props.keepTabsMounted ? this.childFactory : void 0
      },
      /* @__PURE__ */ reactExports.createElement("div", { ...s10, id: String(this.contentId + t6), key: t6 }, e3.props.children)
    ) : /* @__PURE__ */ reactExports.createElement("div", { ...s10, key: t6 }, e3.props.children);
  }
};
l$b.propTypes = {
  animation: o$r.bool,
  children: o$r.oneOfType([
    o$r.element,
    o$r.arrayOf(o$r.element)
  ]),
  selected: o$r.number,
  style: o$r.object
};
let h$6 = l$b;
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const d$g = class d2 extends reactExports.Component {
  constructor(s10) {
    super(s10), this.tabStripRef = reactExports.createRef(), this.showLicenseWatermark = false, this.onSelect = (n10) => {
      this.props.selected !== n10 && this.props.onSelect && this.props.onSelect({
        selected: n10
      });
    }, this.onKeyDown = (n10) => {
      this.navigation.triggerKeyboardEvent(n10);
    }, this.onKeyboardSelect = (n10) => {
      const i16 = this.children();
      i16 && i16[n10].props.disabled || this.onSelect(n10);
    }, this.renderContent = (n10) => {
      const { selected: i16, children: t6, tabContentStyle: e3 } = n10, r12 = reactExports.Children.count(t6);
      return i16 < r12 && i16 > -1 ? /* @__PURE__ */ reactExports.createElement(h$6, { index: i16, ...n10, style: e3 }) : null;
    }, l$p(e$n), this.showLicenseWatermark = n$w(e$n);
  }
  get contentPanelId() {
    return this.props.id + "-content-panel-id";
  }
  get navItemId() {
    return this.props.id + "-nav-item-id";
  }
  /** @hidden */
  componentDidMount() {
    var i16;
    const s10 = this.tabStripRef.current, n10 = s10 && getComputedStyle(s10).direction === "rtl" || false;
    s10 && (this.navigation = new l$m({
      tabIndex: 0,
      root: this.tabStripRef,
      rovingTabIndex: true,
      focusClass: "k-focus",
      selectors: [".k-tabstrip .k-tabstrip-item"],
      keyboardEvents: {
        keydown: {
          ArrowLeft: (t6, e3, r12) => {
            r12.preventDefault();
            const o9 = e3.elements.indexOf(t6), c6 = o9 !== 0 ? o9 - 1 : e3.elements.length - 1, p6 = o9 !== e3.elements.length - 1 ? o9 + 1 : 0;
            n10 ? (e3.focusNext(t6), this.onKeyboardSelect(p6)) : (e3.focusPrevious(t6), this.onKeyboardSelect(c6));
          },
          ArrowRight: (t6, e3, r12) => {
            r12.preventDefault();
            const o9 = e3.elements.indexOf(t6), c6 = o9 !== 0 ? o9 - 1 : e3.elements.length - 1, p6 = o9 !== e3.elements.length - 1 ? o9 + 1 : 0;
            n10 ? (e3.focusPrevious(t6), this.onKeyboardSelect(c6)) : (e3.focusNext(t6), this.onKeyboardSelect(p6));
          },
          ArrowDown: (t6, e3, r12) => {
            r12.preventDefault();
            const o9 = e3.elements.indexOf(t6), c6 = o9 !== e3.elements.length - 1 ? o9 + 1 : 0;
            e3.focusNext(t6), this.onKeyboardSelect(c6);
          },
          ArrowUp: (t6, e3, r12) => {
            r12.preventDefault();
            const o9 = e3.elements.indexOf(t6), c6 = o9 !== 0 ? o9 - 1 : e3.elements.length - 1;
            e3.focusPrevious(t6), this.onKeyboardSelect(c6);
          },
          Home: (t6, e3, r12) => {
            r12.preventDefault(), e3.focusElement(e3.first, t6), this.onKeyboardSelect(0);
          },
          End: (t6, e3, r12) => {
            r12.preventDefault(), e3.focusElement(e3.last, t6), this.onKeyboardSelect(e3.elements.length - 1);
          }
        }
      }
    }), (i16 = this.navigation) == null || i16.initializeRovingTab(this.props.selected));
  }
  /** @hidden */
  componentWillUnmount() {
    var s10;
    (s10 = this.navigation) == null || s10.removeFocusListener();
  }
  /**
   * @hidden
   */
  render() {
    const s10 = {
      ...this.props,
      children: this.children(),
      contentPanelId: this.contentPanelId,
      renderAllContent: this.props.renderAllContent,
      navItemId: this.navItemId,
      onKeyDown: this.onKeyDown,
      onSelect: this.onSelect
    }, { tabPosition: n10, tabIndex: i16 } = s10, t6 = n10 === "bottom", e3 = r$r(
      "k-tabstrip k-pos-relative",
      {
        "k-tabstrip-left": n10 === "left",
        "k-tabstrip-right": n10 === "right",
        "k-tabstrip-bottom": n10 === "bottom",
        "k-tabstrip-top": n10 === "top",
        "k-tabstrip-scrollable": this.props.scrollable
      },
      this.props.className
    );
    return /* @__PURE__ */ reactExports.createElement(
      "div",
      {
        id: this.props.id,
        ref: this.tabStripRef,
        dir: this.props.dir,
        className: e3,
        style: this.props.style
      },
      !t6 && /* @__PURE__ */ reactExports.createElement(R$5, { ...s10, tabIndex: i16 }),
      this.renderContent(s10),
      t6 && /* @__PURE__ */ reactExports.createElement(R$5, { ...s10, tabIndex: i16 }),
      this.showLicenseWatermark && /* @__PURE__ */ reactExports.createElement(v$e, null)
    );
  }
  children() {
    return reactExports.Children.toArray(this.props.children).filter((s10) => s10);
  }
};
d$g.propTypes = {
  animation: o$r.bool,
  children: o$r.node,
  onSelect: o$r.func,
  selected: o$r.number,
  style: o$r.object,
  tabContentStyle: o$r.object,
  tabPosition: o$r.string,
  tabAlignment: o$r.string,
  tabIndex: o$r.number,
  className: o$r.string,
  dir: o$r.string
}, d$g.defaultProps = {
  animation: true,
  tabPosition: "top",
  tabAlignment: "start",
  keepTabsMounted: false,
  buttonScrollSpeed: 100,
  scrollButtonsPosition: "around",
  mouseScrollSpeed: 10,
  renderAllContent: false
};
let f$9 = d$g;
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const s$9 = (e3) => {
  const a9 = reactExports.useRef(null), c6 = reactExports.useCallback((n10) => {
    e3.onClick && e3.onClick.call(void 0, {
      syntheticEvent: n10,
      item: e3.item,
      title: e3.title
    });
  }, [e3.item, e3.title, e3.onClick]);
  return reactExports.useEffect(() => {
    a9.current && e3.focused && a9.current.focus();
  }, [e3.focused]), /* @__PURE__ */ reactExports.createElement(
    "span",
    {
      style: e3.style,
      tabIndex: e3.tabIndex,
      className: r$r(
        "k-actionsheet-item",
        "k-cursor-pointer",
        e3.disabled && "k-disabled",
        e3.className
      ),
      ref: a9,
      role: "button",
      "aria-disabled": e3.disabled,
      onClick: c6
    },
    /* @__PURE__ */ reactExports.createElement("span", { className: "k-actionsheet-action" }, e3.icon && /* @__PURE__ */ reactExports.createElement("span", { className: "k-icon-wrap" }, e3.icon), (e3.title || e3.description) && /* @__PURE__ */ reactExports.createElement("span", { className: "k-actionsheet-item-text" }, e3.title && /* @__PURE__ */ reactExports.createElement("span", { className: "k-actionsheet-item-title" }, e3.title), e3.description && /* @__PURE__ */ reactExports.createElement("span", { className: "k-actionsheet-item-description" }, e3.description)))
  );
};
s$9.propTypes = {
  className: o$r.string,
  style: o$r.object,
  description: o$r.string,
  disabled: o$r.bool,
  group: o$r.oneOf(["top", "bottom"]),
  icon: o$r.element,
  title: o$r.string
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const c$c = "ActionSheetHeader", e$h = (a9) => /* @__PURE__ */ reactExports.createElement(
  "div",
  {
    className: r$r(
      "k-actionsheet-titlebar",
      a9.className
    )
  },
  a9.children
);
e$h.propTypes = {
  className: o$r.string
};
e$h.displayName = c$c;
e$h.propTypes = {
  children: o$r.any
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const a$g = "ActionSheetFooter", e$g = (o9) => /* @__PURE__ */ reactExports.createElement(
  "div",
  {
    className: r$r(
      "k-actionsheet-footer",
      o9.className
    )
  },
  o9.children
);
e$g.propTypes = {
  className: o$r.string
};
e$g.displayName = a$g;
e$g.propTypes = {
  children: o$r.any
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const a$f = "ActionSheetContent", t$e = (e3) => /* @__PURE__ */ reactExports.createElement(
  "div",
  {
    className: r$r(
      "k-actionsheet-content",
      { "!k-overflow-hidden": e3.overflowHidden },
      e3.className
    )
  },
  e3.children
);
t$e.propTypes = {
  className: o$r.string
};
t$e.displayName = a$f;
t$e.propTypes = {
  children: o$r.any
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const m$b = class m extends reactExports.Component {
  /** @hidden */
  constructor(o9) {
    super(o9), this.actionSheetRef = reactExports.createRef(), this.actionSheetTitleClass = "k-actionsheet-title", this.ariaLabeledBy = this.actionSheetTitleClass, this.animationDuration = 300, this.bottomPosition = { bottom: "0", width: "100%" }, this.handleKeyDown = (t6) => {
      this.props.navigatable && this.navigation.triggerKeyboardEvent(t6);
    }, this.onTab = (t6, a9, i16) => {
      i16.preventDefault(), i16.shiftKey ? a9.focusPrevious(t6) : a9.focusNext(t6);
    }, this.handleOverlayClick = (t6) => {
      this.props.onOverlayClick && this.props.onOverlayClick.call(void 0, t6), this.props.onClose && this.props.onClose.call(void 0, t6), this.props.animation || this.hideActionSheet();
    }, this.handleItemClick = (t6) => {
      this.props.onItemClick && this.props.onItemClick.call(void 0, t6), this.props.onItemSelect && this.props.onItemSelect.call(void 0, t6), this.props.animation || this.hideActionSheet();
    }, this.onEnter = (t6, a9, i16) => {
      if (t6.ariaDisabled)
        return;
      const h3 = t6.className && t6.className.indexOf ? t6.className.indexOf("k-actionsheet-item") !== -1 : false, l7 = a9.elements.filter((s10) => s10.className.indexOf("k-actionsheet-item") !== -1);
      if (h3 && this.props.onItemClick) {
        i16.preventDefault();
        const s10 = this.props.items[l7.indexOf(t6)];
        this.props.onItemClick.call(void 0, {
          syntheticEvent: i16,
          item: s10,
          title: s10 && s10.title
        });
      }
      if (h3 && this.props.onItemSelect) {
        i16.preventDefault();
        const s10 = this.props.items[l7.indexOf(t6)];
        this.props.onItemSelect.call(void 0, {
          syntheticEvent: i16,
          item: s10,
          title: s10 && s10.title
        });
      }
      this.props.animation || this.hideActionSheet();
    }, this.onEscape = (t6, a9, i16) => {
      this.props.onOverlayClick && (i16.preventDefault(), this.props.onOverlayClick.call(void 0, i16)), this.props.onClose && (i16.preventDefault(), this.props.onClose.call(void 0, i16)), this.props.animation || this.hideActionSheet();
    }, this.hideActionSheet = () => {
      this.setState({ show: false });
    }, this.children = (t6) => {
      const a9 = {};
      return reactExports.Children.forEach(t6, (i16) => {
        i16 && (a9[i16.type.displayName] = i16);
      }), a9;
    }, this.state = {
      show: false,
      slide: false
    }, l$p(e$n);
  }
  /** @hidden */
  componentDidMount() {
    this.props.expand && !this.state.show && this.setState({ show: true });
  }
  /** @hidden */
  componentDidUpdate(o9, t6) {
    const a9 = this.actionSheetRef.current;
    if (this.props.expand && !this.state.show && this.setState({ show: true }), this.props.expand && this.state.show && !this.state.slide && this.setState({ slide: true }), !this.props.expand && this.state.show && this.state.slide && this.setState({ slide: false }), t6 !== this.state && this.state.slide && a9 && !this.props.className && (a9.style.setProperty("--kendo-actionsheet-height", "auto"), a9.style.setProperty("--kendo-actionsheet-max-height", "none")), a9 && this.props.navigatable) {
      const h3 = [
        ".k-actionsheet-item",
        ...[
          ".k-actionsheet-footer",
          ".k-actionsheet-content",
          ".k-actionsheet-titlebar"
        ].map((l7) => s$u.concat(this.props.navigatableElements).map(
          (s10) => `${l7} ${s10}`
        )).flat()
      ];
      this.navigation = new l$m({
        tabIndex: this.props.tabIndex || 0,
        root: this.actionSheetRef,
        rovingTabIndex: false,
        selectors: h3,
        keyboardEvents: {
          keydown: {
            Tab: this.onTab,
            Enter: this.onEnter,
            Escape: this.onEscape
          }
        }
      }), this.navigation.focusElement(this.navigation.first, null);
    }
  }
  /** @hidden */
  render() {
    const {
      title: o9,
      subTitle: t6,
      animationStyles: a9,
      animation: i16,
      expand: h3,
      tabIndex: l7,
      items: s10
    } = this.props, r12 = s10 == null ? void 0 : s10.filter((n10) => !n10.group || n10.group === "top"), d8 = s10 == null ? void 0 : s10.filter((n10) => n10.group === "bottom"), y4 = r12 && r12.length > 0 && d8 && d8.length > 0, f4 = this.children(this.props.children), u5 = this.props.animationDuration || this.animationDuration, k3 = this.state.slide && /* @__PURE__ */ reactExports.createElement(
      "div",
      {
        className: r$r("k-actionsheet", this.props.className, {
          "k-actionsheet-bottom": !this.props.className
        }),
        role: "dialog",
        "aria-modal": "true",
        "aria-hidden": false,
        "aria-labelledby": this.ariaLabeledBy,
        ref: this.actionSheetRef,
        onKeyDown: this.handleKeyDown
      },
      f4[c$c] && !o9 && !t6 && f4[c$c],
      (o9 || t6) && /* @__PURE__ */ reactExports.createElement("div", { className: "k-actionsheet-titlebar k-text-center" }, /* @__PURE__ */ reactExports.createElement("div", { className: "k-actionsheet-titlebar-group k-hbox" }, /* @__PURE__ */ reactExports.createElement("div", { className: this.actionSheetTitleClass, id: this.ariaLabeledBy }, o9 && /* @__PURE__ */ reactExports.createElement("div", null, o9), t6 && /* @__PURE__ */ reactExports.createElement("div", { className: "k-actionsheet-subtitle" }, t6)))),
      f4[a$f] || /* @__PURE__ */ reactExports.createElement("div", { className: "k-actionsheet-content" }, /* @__PURE__ */ reactExports.createElement("div", { className: "k-list-ul", role: "group" }, r12 && r12.map((n10, c6) => /* @__PURE__ */ reactExports.createElement(
        s$9,
        {
          ...n10,
          id: c6,
          key: c6,
          item: n10,
          tabIndex: l7 || 0,
          onClick: this.handleItemClick
        }
      ))), y4 && /* @__PURE__ */ reactExports.createElement("hr", { className: "k-hr" }), /* @__PURE__ */ reactExports.createElement("div", { className: "k-list-ul", role: "group" }, d8 && d8.map((n10, c6) => /* @__PURE__ */ reactExports.createElement(
        s$9,
        {
          ...n10,
          id: c6 + ((r12 == null ? void 0 : r12.length) || 0),
          key: c6,
          item: n10,
          tabIndex: l7 || 0,
          onClick: this.handleItemClick
        }
      )))),
      f4[a$g]
    );
    return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, h3 || this.state.show ? /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("div", { className: "k-actionsheet-container" }, /* @__PURE__ */ reactExports.createElement(
      "div",
      {
        className: "k-overlay",
        onClick: this.handleOverlayClick
      }
    ), i16 ? /* @__PURE__ */ reactExports.createElement(
      r$8,
      {
        transitionName: this.state.slide ? "slide-up" : "slide-down",
        onExited: this.hideActionSheet,
        transitionEnterDuration: u5,
        transitionExitDuration: u5,
        animationEnteringStyle: a9 || this.bottomPosition,
        animationEnteredStyle: a9 || this.bottomPosition,
        animationExitingStyle: a9 || this.bottomPosition,
        exit: true,
        enter: true,
        appear: false
      },
      k3
    ) : k3)) : null);
  }
};
m$b.displayName = "KendoReactActionSheet", m$b.propTypes = {
  items: o$r.array,
  subTitle: o$r.string,
  title: o$r.string,
  navigatable: o$r.bool,
  navigatableElements: o$r.array
}, m$b.defaultProps = {
  navigatable: true,
  navigatableElements: []
};
let b$8 = m$b;
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const e$f = m$l(I$c);
e$f.displayName = "KendoReactMenu";
m$l(f$9);
e$f.displayName = "KendoReactMenu";
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const c$b = (t6) => {
  let l7 = (e3) => /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null);
  t6.drilldownSeriesFactory && (l7 = t6.drilldownSeriesFactory);
  const n10 = (e3) => {
    var a9, o9;
    return e3 && ((o9 = (a9 = e3.drilldownState) == null ? void 0 : a9.steps) == null ? void 0 : o9.find(({ seriesName: i16 }) => i16 === t6.name));
  };
  return /* @__PURE__ */ reactExports.createElement(e$q.Consumer, null, (e3) => n10(e3) ? /* @__PURE__ */ reactExports.createElement(
    l7,
    {
      _chartCollectionIdxKey: t6._chartCollectionIdxKey,
      drilldownValue: n10(e3).drilldownValue
    }
  ) : /* @__PURE__ */ reactExports.createElement(i$d, { ...t6 }));
};
c$b.displayName = "ChartSeriesItem";
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const r$7 = (e3) => /* @__PURE__ */ reactExports.createElement(a$k, { ...e3, _chartKey: "series" });
r$7.propTypes = {
  children: function(e3, t6, o9) {
    return i$r(e3, t6, o9, c$b);
  }
};
r$7.displayName = "ChartSeries";
const Rectangle = ({
  data: data2,
  parentSize = JSON.parse(localStorage.getItem("formDimension")),
  posn = [0, 0]
}) => {
  const { Points, Size: Size2, FCol, Radius, Visible, FStyle, FillCol, Event, CSS } = data2 == null ? void 0 : data2.Properties;
  const { socket } = useAppData();
  const customStyles = parseFlexStyles(CSS);
  const pointsArray = Points && Points[0].map((y4, i16) => [Points[1][i16], y4]);
  const sizeArray = Size2 && Size2[0].map((y4, i16) => [Size2[1][i16], y4]);
  const hasFCol = data2 == null ? void 0 : data2.Properties.hasOwnProperty("FCol");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      id: data2 == null ? void 0 : data2.ID,
      style: {
        position: "absolute",
        top: 0,
        left: 0,
        display: Visible == 0 ? "none" : "block",
        ...customStyles
      },
      onMouseDown: (e3) => {
        handleMouseDown(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseUp: (e3) => {
        handleMouseUp(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseEnter: (e3) => {
        handleMouseEnter(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseMove: (e3) => {
        handleMouseMove(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseLeave: (e3) => {
        handleMouseLeave(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onWheel: (e3) => {
        handleMouseWheel(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onDoubleClick: (e3) => {
        handleMouseDoubleClick(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { height: parentSize && parentSize[0], width: parentSize && parentSize[1], children: pointsArray == null ? void 0 : pointsArray.map((rectanglePoints, index2) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          "rect",
          {
            id: index2,
            rx: Radius && Radius[index2 * 0],
            ry: Radius && Radius[index2 * 0],
            x: rectanglePoints[0],
            y: rectanglePoints[1],
            width: sizeArray && sizeArray[index2][0] + 1,
            height: sizeArray && sizeArray[index2][1] + 1,
            fill: !FStyle ? "none" : FStyle[index2] == "-1" ? "none" : rgbColor(FillCol && FillCol[index2]),
            stroke: hasFCol ? FCol && rgbColor(FCol[index2]) : "rgb(0,0,0)",
            strokeWidth: "1px"
          }
        );
      }) })
    }
  );
};
const Ecllipse = ({ data: data2 }) => {
  const parentSize = JSON.parse(localStorage.getItem("formDimension"));
  const { FillCol, Start, FCol, Size: Size2, End, Points, Event, CSS } = data2 == null ? void 0 : data2.Properties;
  const customStyles = parseFlexStyles(CSS);
  const { socket } = useAppData();
  const generatePieChartPaths = (startAngles, Points2) => {
    const cx = Size2 && Size2[1] / 2 + 10;
    const cy = Size2 && Size2[0] / 2 + 10;
    const rx = Size2 && Size2[1] / 2;
    const ry = Size2 && Size2[0] / 2;
    const paths2 = [];
    for (let i16 = 0; i16 < (startAngles == null ? void 0 : startAngles.length); i16++) {
      const startAngle = -startAngles[i16];
      const endAngle = i16 === (startAngles == null ? void 0 : startAngles.length) - 1 ? 2 * Math.PI : -startAngles[i16 + 1];
      const startX = cx + rx * Math.cos(startAngle);
      const startY = cy + ry * Math.sin(startAngle);
      const endX = cx + rx * Math.cos(endAngle);
      const endY = cy + ry * Math.sin(endAngle);
      const path = `
                M ${cx},${cy}
                L ${startX},${startY}
                A ${rx},${ry} 0 0,0 ${endX},${endY}
                Z
            `;
      paths2.push({
        d: path,
        fill: rgbColor(FillCol && FillCol[i16]),
        stroke: "black",
        strokeWidth: "1"
      });
    }
    return paths2;
  };
  const generatePieChartPathsWithEnd = (startAngles, endAngles, Points2) => {
    const cx = (Size2 && Size2[1] / 2) + 10;
    const cy = (Size2 && Size2[0] / 2) + 250;
    const rx = Size2 && Size2[1] / 2;
    const ry = Size2 && Size2[0] / 2;
    console.log({ Start });
    console.log({ End });
    const paths2 = [];
    for (let i16 = 0; i16 < startAngles.length; i16++) {
      const startAngle = -startAngles[i16];
      const endAngle = -endAngles[i16];
      const startX = cx + rx * Math.cos(startAngle);
      const startY = cy + ry * Math.sin(startAngle);
      const endX = cx + rx * Math.cos(endAngle);
      const endY = cy + ry * Math.sin(endAngle);
      const largeArcFlag = endAngle - startAngle <= Math.PI ? "0" : "1";
      const path = `
      M ${cx},${cy}
      L ${startX},${startY}
      A ${rx},${ry} 0 ${largeArcFlag},0 ${endX},${endY}
      Z
    `;
      paths2.push({
        d: path,
        fill: rgbColor(FillCol && FillCol[i16]),
        stroke: "black",
        strokeWidth: "1"
      });
    }
    return paths2;
  };
  const paths = !End ? generatePieChartPaths(Start) : generatePieChartPathsWithEnd(Start, End);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      style: {
        position: "absolute",
        top: 0,
        left: 0,
        ...customStyles
      },
      onMouseDown: (e3) => {
        handleMouseDown(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseUp: (e3) => {
        handleMouseUp(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseEnter: (e3) => {
        handleMouseEnter(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseMove: (e3) => {
        handleMouseMove(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseLeave: (e3) => {
        handleMouseLeave(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onWheel: (e3) => {
        handleMouseWheel(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onDoubleClick: (e3) => {
        handleMouseDoubleClick(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { height: parentSize && parentSize[0], width: parentSize && parentSize[1], children: paths.map((path, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          d: path.d,
          fill: path.fill,
          stroke: path.stroke,
          strokeWidth: path.strokeWidth
        },
        index2
      )) })
    }
  );
};
const Circle = ({ data: data2 }) => {
  const parentSize = JSON.parse(localStorage.getItem("formDimension"));
  const { FillCol, Start, FCol, Points, Radius, Event, CSS } = data2 == null ? void 0 : data2.Properties;
  const customStyles = parseFlexStyles(CSS);
  const { socket } = useAppData();
  const generatePieChartPaths = (startAngles) => {
    const cx = Points && Points[1][0];
    const cy = Points && Points[0][0];
    const rx = Radius && Radius[0];
    const ry = Radius && Radius[0];
    const paths2 = [];
    for (let i16 = 0; i16 < (startAngles == null ? void 0 : startAngles.length); i16++) {
      const startAngle = -startAngles[i16];
      const endAngle = i16 === (startAngles == null ? void 0 : startAngles.length) - 1 ? 2 * Math.PI : -startAngles[i16 + 1];
      const startX = cx + rx * Math.cos(startAngle);
      const startY = cy + ry * Math.sin(startAngle);
      const endX = cx + rx * Math.cos(endAngle);
      const endY = cy + ry * Math.sin(endAngle);
      const path = `
                M ${cx},${cy}
                L ${startX},${startY}
                A ${rx},${ry} 0 0,0 ${endX},${endY}
                Z
            `;
      paths2.push({
        d: path,
        fill: "none",
        stroke: FCol && rgbColor(FCol[i16]),
        strokeWidth: "1"
      });
    }
    return paths2;
  };
  const paths = generatePieChartPaths(Start);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      style: {
        position: "absolute",
        top: 0,
        left: 0,
        ...customStyles
      },
      onMouseDown: (e3) => {
        handleMouseDown(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseUp: (e3) => {
        handleMouseUp(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseEnter: (e3) => {
        handleMouseEnter(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseMove: (e3) => {
        handleMouseMove(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseLeave: (e3) => {
        handleMouseLeave(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onWheel: (e3) => {
        handleMouseWheel(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onDoubleClick: (e3) => {
        handleMouseDoubleClick(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { height: parentSize && parentSize[0], width: parentSize && parentSize[1], children: paths.map((path, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          d: path.d,
          fill: path.fill,
          stroke: path.stroke,
          strokeWidth: path.strokeWidth
        },
        index2
      )) })
    }
  );
};
function useForceRerender$1() {
  const [_state, setState] = reactExports.useState(true);
  const reRender = () => {
    setState((prev) => !prev);
  };
  return { reRender };
}
const getNestingLevel = (array) => {
  if (!Array.isArray(array)) {
    return 0;
  }
  return 1 + Math.max(0, ...array.map(getNestingLevel));
};
const flattenArrayOneLevel = (array) => {
  return array.reduce((acc, val) => acc.concat(val), []);
};
const flattenIfThreeLevels = (arr) => {
  if (getNestingLevel(arr) === 3) {
    return flattenArrayOneLevel(arr);
  } else {
    return arr;
  }
};
const Text = ({ data: data2, fontProperties }) => {
  const { Visible, Points, Text: Text2, FCol, BCol, Event, CSS } = data2 == null ? void 0 : data2.Properties;
  console.log("254", { data: data2, fontProperties });
  const { socket, fontScale } = useAppData();
  const customStyles = parseFlexStyles(CSS);
  useForceRerender$1();
  const parentSize = JSON.parse(localStorage.getItem("formDimension"));
  const newPoints = flattenIfThreeLevels(Points);
  const pointsArray = newPoints && newPoints[0].map((y4, i16) => [newPoints[1][i16], y4]);
  const calculateTextDimensions = (text, fontSize = 12) => {
    const container = document.createElement("span");
    container.style.visibility = "hidden";
    container.style.position = "fixed";
    container.style.top = "0";
    container.style.left = "0";
    container.style.fontSize = fontSize + "px";
    container.style.lineHeight = "1";
    const span = document.createElement("p");
    span.textContent = text;
    span.style.display = "block";
    container.appendChild(span);
    document.body.appendChild(container);
    const width = span.offsetWidth;
    const height = span.offsetHeight;
    document.body.removeChild(container);
    return { height, width };
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      style: {
        position: "absolute",
        display: Visible == 0 ? "none" : "block",
        top: 0,
        left: 0
      },
      onMouseDown: (e3) => {
        handleMouseDown(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseUp: (e3) => {
        handleMouseUp(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseEnter: (e3) => {
        handleMouseEnter(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseMove: (e3) => {
        handleMouseMove(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseLeave: (e3) => {
        handleMouseLeave(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onWheel: (e3) => {
        handleMouseWheel(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onDoubleClick: (e3) => {
        handleMouseDoubleClick(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "svg",
        {
          height: parentSize && parentSize[0],
          width: parentSize && parentSize[1],
          children: Text2 == null ? void 0 : Text2.map((text, index2) => {
            var _a, _b;
            const dimensions = calculateTextDimensions(
              text,
              (fontProperties == null ? void 0 : fontProperties.Size) ? fontProperties.Size * fontScale : 12 * fontScale
            );
            const textWidth = dimensions == null ? void 0 : dimensions.width;
            const textHeight = dimensions == null ? void 0 : dimensions.height;
            const points2 = pointsArray[index2] || [
              (_a = pointsArray == null ? void 0 : pointsArray[index2 - 1]) == null ? void 0 : _a[0],
              ((_b = pointsArray == null ? void 0 : pointsArray[index2 - 1]) == null ? void 0 : _b[1]) + 10
            ];
            return /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "rect",
                {
                  x: points2 && points2[0],
                  y: points2 && points2[1],
                  width: textWidth,
                  height: textHeight,
                  transform: `translate(${points2 && points2[0]}, ${points2 && points2[1]}) rotate(${(fontProperties == null ? void 0 : fontProperties.Rotate) * (180 / Math.PI)}) translate(${points2 && -points2[0]}, ${points2 && -points2[1]})`,
                  fill: BCol ? rgbColor(BCol) : "transparent"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "text",
                {
                  id: `${data2 == null ? void 0 : data2.ID}-t${index2 + 1}`,
                  "alignment-baseline": "middle",
                  dy: "0.6em",
                  x: points2 && points2[0],
                  y: points2 && points2[1],
                  "font-family": fontProperties == null ? void 0 : fontProperties.PName,
                  "font-size": (fontProperties == null ? void 0 : fontProperties.Size) ? `${fontProperties.Size * fontScale}px` : `${12 * fontScale}px`,
                  fill: FCol ? rgbColor(FCol[index2]) : "black",
                  "font-style": !(fontProperties == null ? void 0 : fontProperties.Italic) ? "none" : (fontProperties == null ? void 0 : fontProperties.Italic) == 1 ? "italic" : "none",
                  "font-weight": !(fontProperties == null ? void 0 : fontProperties.Weight) ? 0 : fontProperties == null ? void 0 : fontProperties.Weight,
                  "text-decoration": !(fontProperties == null ? void 0 : fontProperties.Underline) ? "none" : (fontProperties == null ? void 0 : fontProperties.Underline) == 1 ? "underline" : "none",
                  transform: `translate(${points2 && points2[0]}, ${points2 && points2[1]}) rotate(${(fontProperties == null ? void 0 : fontProperties.Rotate) * (180 / Math.PI)}) translate(${points2 && -points2[0]}, ${points2 && -points2[1]})`,
                  style: { ...customStyles },
                  children: text
                }
              )
            ] }, index2);
          })
        }
      )
    }
  ) });
};
const Timer = ({ data: data2 }) => {
  const { socket } = useAppData();
  const { Interval, FireOnce, Active, Event } = data2 == null ? void 0 : data2.Properties;
  let eventFire = !FireOnce ? 0 : FireOnce;
  const hasActive = data2 == null ? void 0 : data2.Properties.hasOwnProperty("Active");
  let activeTimer = hasActive ? Active : 1;
  reactExports.useEffect(() => {
    let intervalId;
    let timeoutId;
    const timerEvent = JSON.stringify({
      Event: { EventName: "Timer", ID: data2 == null ? void 0 : data2.ID, Info: [] }
    });
    if (activeTimer == 1) {
      if (eventFire == 1) {
        if (intervalId)
          clearInterval(intervalId);
        timeoutId = setTimeout(() => {
          socket.send(timerEvent);
        }, Interval && Interval);
        localStorage.setItem(
          data2.ID,
          JSON.stringify({ Event: { EventName: "Timer", ID: data2 == null ? void 0 : data2.ID, FireOnce: 2 } })
        );
      } else if (eventFire == 2) {
        if (intervalId)
          clearInterval(intervalId);
        if (timeoutId)
          clearTimeout(timeoutId);
        clearInterval(intervalId);
        clearTimeout(timeoutId);
      } else if (eventFire == 0) {
        localStorage.setItem(
          data2.ID,
          JSON.stringify({ Event: { EventName: "Timer", ID: data2 == null ? void 0 : data2.ID, FireOnce: 0 } })
        );
        intervalId = setInterval(() => {
          socket.send(timerEvent);
        }, Interval && Interval);
      }
      return () => {
        clearInterval(intervalId);
        clearTimeout(timeoutId);
      };
    }
  }, [data2]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
};
const ListView = ({ data: data2 }) => {
  var _a, _b, _c, _d, _e2, _f, _g;
  const { findDesiredData, socket } = useAppData();
  const {
    View,
    Border,
    ColTitles,
    ImageIndex,
    ImageListObj,
    Items,
    ReportInfo,
    Event,
    CSS
  } = data2 && (data2 == null ? void 0 : data2.Properties);
  const customStyles = parseFlexStyles(CSS);
  const styles = setStyle$1(data2 == null ? void 0 : data2.Properties);
  reactExports.useEffect(() => {
    localStorage.setItem(
      data2.ID,
      JSON.stringify({
        Event: {
          SelItems: new Array(Items == null ? void 0 : Items.length).fill(0)
        }
      })
    );
  }, [data2 == null ? void 0 : data2.Properties]);
  const handleListViewEvent = (index2, shiftState, eventName) => {
    const event = JSON.stringify({
      Event: {
        EventName: eventName,
        ID: data2 == null ? void 0 : data2.ID,
        Info: [index2 + 1, 1, shiftState, 4]
      }
    });
    const SelItems = new Array(Items == null ? void 0 : Items.length).fill(0);
    SelItems[index2] = 1;
    const storedFocusedIndex = JSON.stringify({
      Event: {
        SelItems
      }
    });
    localStorage.setItem(data2 == null ? void 0 : data2.ID, storedFocusedIndex);
    const exists = Event && Event.some((item) => item[0] === eventName);
    if (!exists)
      return;
    console.log(event);
    socket.send(event);
  };
  const handleEvent = (nativeEvent, index2, eventName) => {
    if (eventName === "ItemDblClick") {
      handleMouseDoubleClick(e, socket, Event, data2 == null ? void 0 : data2.ID);
    }
    const isAltPressed = (nativeEvent == null ? void 0 : nativeEvent.altKey) ? 4 : 0;
    const isCtrlPressed = (nativeEvent == null ? void 0 : nativeEvent.ctrlKey) ? 2 : 0;
    const isShiftPressed = (nativeEvent == null ? void 0 : nativeEvent.shiftKey) ? 1 : 0;
    nativeEvent == null ? void 0 : nativeEvent.button;
    let shiftState = isAltPressed + isCtrlPressed + isShiftPressed;
    handleListViewEvent(index2, shiftState, eventName);
  };
  const ImageListView = ({
    orientation = "row",
    Images = [],
    parentOrientation = "row",
    height,
    width,
    imageHeight,
    imageWidth,
    style: style2 = ""
  }) => {
    const listViewItems = !Items ? [] : Items;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: `d-flex flex-wrap flex-${parentOrientation}`,
        style: {
          ...styles,
          border: !Border ? null : "1px solid black",
          ...style2,
          ...customStyles
        },
        onMouseDown: (e22) => {
          handleMouseDown(e22, socket, Event, data2 == null ? void 0 : data2.ID);
        },
        onMouseUp: (e22) => {
          handleMouseUp(e22, socket, Event, data2 == null ? void 0 : data2.ID);
        },
        onMouseEnter: (e22) => {
          handleMouseEnter(e22, socket, Event, data2 == null ? void 0 : data2.ID);
        },
        onMouseMove: (e22) => {
          handleMouseMove(e22, socket, Event, data2 == null ? void 0 : data2.ID);
        },
        onMouseLeave: (e22) => {
          handleMouseLeave(e22, socket, Event, data2 == null ? void 0 : data2.ID);
        },
        onWheel: (e22) => {
          handleMouseWheel(e22, socket, Event, data2 == null ? void 0 : data2.ID);
        },
        onDoubleClick: (e22) => {
          handleMouseDoubleClick(e22, socket, Event, data2 == null ? void 0 : data2.ID);
        },
        onKeyDown: () => {
          handleKeyPressUtils(e, socket, Event, data2 == null ? void 0 : data2.ID);
        },
        children: listViewItems == null ? void 0 : listViewItems.map((item, index2) => {
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              onDoubleClick: (e22) => handleEvent(e22.nativeEvent, index2, "ItemDblClick"),
              onClick: (e22) => handleEvent(e22.nativeEvent, index2, "ItemDown"),
              style: { width: "60px" },
              className: `d-flex flex-${orientation}`,
              children: [
                Images.length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "img",
                  {
                    style: { width: imageWidth, height: imageHeight },
                    src: `${getCurrentUrl()}${Images[ImageIndex[index2] - 1]}`
                  }
                ) : null,
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: "12px" }, children: item })
              ]
            }
          );
        })
      }
    );
  };
  if (View && View == "Icon") {
    const ImageData = findDesiredData(ImageListObj && ImageListObj[0]);
    const Images = (_a = ImageData == null ? void 0 : ImageData.Properties) == null ? void 0 : _a.Files;
    const ImageSize = ImageData && ((_b = ImageData == null ? void 0 : ImageData.Properties) == null ? void 0 : _b.Size);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      ImageListView,
      {
        style: { overflowY: "scroll" },
        orientation: "column",
        height: `${ImageSize && ImageSize[0] + 15}px`,
        width: `${ImageSize && ImageSize[1] + 30}px`,
        Images,
        imageHeight: `${ImageSize && ImageSize[0]}px`,
        imageWidth: `${ImageSize && ImageSize[1]}px`
      }
    );
  }
  if (View && View == "SmallIcon") {
    const ImageData = findDesiredData(ImageListObj && ImageListObj[1]);
    const Images = (_c = ImageData == null ? void 0 : ImageData.Properties) == null ? void 0 : _c.Files;
    const ImageSize = (_d = ImageData == null ? void 0 : ImageData.Properties) == null ? void 0 : _d.Size;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      ImageListView,
      {
        imageHeight: `${ImageSize && ImageSize[0]}px`,
        imageWidth: `${ImageSize && ImageSize[1]}px`,
        orientation: "row",
        height: `${ImageSize && ImageSize[0] + 15}px`,
        width: `${ImageSize && ImageSize[1] + 30}px`,
        Images
      }
    );
  }
  if (View && View == "List") {
    const ImageData = findDesiredData(ImageListObj && ImageListObj[1]);
    const Images = (_e2 = ImageData == null ? void 0 : ImageData.Properties) == null ? void 0 : _e2.Files;
    const ImageSize = (_f = ImageData == null ? void 0 : ImageData.Properties) == null ? void 0 : _f.Size;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      ImageListView,
      {
        imageHeight: `${ImageSize && ImageSize[0]}px`,
        imageWidth: `${ImageSize && ImageSize[1]}px`,
        parentOrientation: "column",
        orientation: "row",
        height: `${ImageSize && ImageSize[0]}px`,
        width: `${ImageSize && ImageSize[1] + 30}px`,
        Images
      }
    );
  }
  if (View && View == "Report") {
    const ImageData = findDesiredData(ImageListObj && ImageListObj[1]);
    const Images = (_g = ImageData == null ? void 0 : ImageData.Properties) == null ? void 0 : _g.Files;
    const reportsData = createListViewObjects(
      !Images ? [] : Images,
      !Items ? [] : Items,
      !ReportInfo ? [] : ReportInfo,
      !ImageIndex ? [] : ImageIndex
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          ...styles,
          border: !Border ? null : "1px solid black",
          overflowY: "scroll",
          ...customStyles
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "d-flex align-items-center", children: ColTitles == null ? void 0 : ColTitles.map((title2, index2, array) => {
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                style: {
                  borderRight: index2 !== array.length - 1 ? "1px solid #F0F0F0" : "none",
                  flex: 1,
                  fontSize: "12px",
                  paddingLeft: "5px"
                },
                onMouseDown: (e22) => {
                  handleMouseDown(e22, socket, Event, data2 == null ? void 0 : data2.ID);
                },
                onMouseUp: (e22) => {
                  handleMouseUp(e22, socket, Event, data2 == null ? void 0 : data2.ID);
                },
                onMouseEnter: (e22) => {
                  handleMouseEnter(e22, socket, Event, data2 == null ? void 0 : data2.ID);
                },
                onMouseMove: (e22) => {
                  handleMouseMove(e22, socket, Event, data2 == null ? void 0 : data2.ID);
                },
                onMouseLeave: (e22) => {
                  handleMouseLeave(e22, socket, Event, data2 == null ? void 0 : data2.ID);
                },
                onWheel: (e22) => {
                  handleMouseWheel(e22, socket, Event, data2 == null ? void 0 : data2.ID);
                },
                onDoubleClick: (e22) => {
                  handleMouseDoubleClick(e22, socket, Event, data2 == null ? void 0 : data2.ID);
                },
                onKeyDown: () => {
                  handleKeyPressUtils(e, socket, Event, data2 == null ? void 0 : data2.ID);
                },
                children: title2
              }
            );
          }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-1", children: reportsData == null ? void 0 : reportsData.map((report, index2) => {
            return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "d-flex align-items-center", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  style: { flex: 1, paddingLeft: "5px", cursor: "pointer" },
                  onKeyDown: () => {
                    handleKeyPressUtils(e, socket, Event, data2 == null ? void 0 : data2.ID);
                  },
                  onDoubleClick: (e22) => handleEvent(e22.nativeEvent, index2, "ItemDblClick"),
                  onMouseDown: (e22) => {
                    handleMouseDown(e22, socket, Event, data2 == null ? void 0 : data2.ID);
                  },
                  onMouseUp: (e22) => {
                    handleMouseUp(e22, socket, Event, data2 == null ? void 0 : data2.ID);
                  },
                  onMouseEnter: (e22) => {
                    handleMouseEnter(e22, socket, Event, data2 == null ? void 0 : data2.ID);
                  },
                  onMouseMove: (e22) => {
                    handleMouseMove(e22, socket, Event, data2 == null ? void 0 : data2.ID);
                  },
                  onMouseLeave: (e22) => {
                    handleMouseLeave(e22, socket, Event, data2 == null ? void 0 : data2.ID);
                  },
                  onWheel: (e22) => {
                    handleMouseWheel(e22, socket, Event, data2 == null ? void 0 : data2.ID);
                  },
                  onClick: (e22) => handleEvent(e22.nativeEvent, index2, "ItemDown"),
                  children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "d-flex align-items-center", children: [
                    (report == null ? void 0 : report.image) ? /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: `${getCurrentUrl()}${report.image}` }) : null,
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: "12px" }, children: report == null ? void 0 : report.title })
                  ] })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  style: {
                    flex: 1,
                    fontSize: "12px",
                    paddingLeft: "5px",
                    cursor: "pointer"
                  },
                  onDoubleClick: (e22) => handleEvent(e22.nativeEvent, index2, "ItemDblClick"),
                  onMouseDown: (e22) => {
                    handleMouseDown(e22, socket, Event, data2 == null ? void 0 : data2.ID);
                  },
                  onMouseUp: (e22) => {
                    handleMouseUp(e22, socket, Event, data2 == null ? void 0 : data2.ID);
                  },
                  onMouseEnter: (e22) => {
                    handleMouseEnter(e22, socket, Event, data2 == null ? void 0 : data2.ID);
                  },
                  onMouseMove: (e22) => {
                    handleMouseMove(e22, socket, Event, data2 == null ? void 0 : data2.ID);
                  },
                  onMouseLeave: (e22) => {
                    handleMouseLeave(e22, socket, Event, data2 == null ? void 0 : data2.ID);
                  },
                  onWheel: (e22) => {
                    handleMouseWheel(e22, socket, Event, data2 == null ? void 0 : data2.ID);
                  },
                  onClick: (e22) => handleEvent(e22.nativeEvent, index2, "ItemDown"),
                  onKeyDown: () => {
                    handleKeyPressUtils(e, socket, Event, data2 == null ? void 0 : data2.ID);
                  },
                  children: report == null ? void 0 : report.description
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  style: {
                    flex: 1,
                    fontSize: "12px",
                    paddingLeft: "5px",
                    cursor: "pointer"
                  },
                  onKeyDown: () => {
                    handleKeyPressUtils(e, socket, Event, data2 == null ? void 0 : data2.ID);
                  },
                  onDoubleClick: (e22) => handleEvent(e22.nativeEvent, index2, "ItemDblClick"),
                  onMouseDown: (e22) => {
                    handleMouseDown(e22, socket, Event, data2 == null ? void 0 : data2.ID);
                  },
                  onMouseUp: (e22) => {
                    handleMouseUp(e22, socket, Event, data2 == null ? void 0 : data2.ID);
                  },
                  onMouseEnter: (e22) => {
                    handleMouseEnter(e22, socket, Event, data2 == null ? void 0 : data2.ID);
                  },
                  onMouseMove: (e22) => {
                    handleMouseMove(e22, socket, Event, data2 == null ? void 0 : data2.ID);
                  },
                  onMouseLeave: (e22) => {
                    handleMouseLeave(e22, socket, Event, data2 == null ? void 0 : data2.ID);
                  },
                  onWheel: (e22) => {
                    handleMouseWheel(e22, socket, Event, data2 == null ? void 0 : data2.ID);
                  },
                  onClick: (e22) => handleEvent(e22.nativeEvent, index2, "ItemDown"),
                  children: report == null ? void 0 : report.index
                }
              )
            ] });
          }) })
        ]
      }
    );
  }
};
const Image$1 = ({ data: data2 }) => {
  const { findDesiredData, socket } = useAppData();
  const { Points, Picture, Visible, Event, CSS } = data2 == null ? void 0 : data2.Properties;
  const customStyles = parseFlexStyles(CSS);
  const pointsArray = Points && Points[0].map((y4, i16) => [Points[1][i16], y4]);
  const parentSize = JSON.parse(localStorage.getItem("formDimension"));
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      id: data2 == null ? void 0 : data2.ID,
      style: {
        position: "absolute",
        top: 0,
        left: 0,
        display: Visible == 0 ? "none" : "block",
        ...customStyles
      },
      onMouseDown: (e3) => {
        handleMouseDown(e3, socket, Event, data2.ID);
      },
      onMouseUp: (e3) => {
        handleMouseUp(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseEnter: (e3) => {
        handleMouseEnter(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseMove: (e3) => {
        handleMouseMove(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseLeave: (e3) => {
        handleMouseLeave(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onWheel: (e3) => {
        handleMouseWheel(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onDoubleClick: (e3) => {
        handleMouseDoubleClick(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { height: parentSize && parentSize[0], width: parentSize && parentSize[1], children: pointsArray.map((imagePoints, index2) => {
        const imageObject = findDesiredData(Picture && Picture[index2]);
        const ImageUrl = renderImage(imageObject);
        return /* @__PURE__ */ jsxRuntimeExports.jsx("image", { href: ImageUrl, x: imagePoints[0], y: imagePoints[1] });
      }) })
    }
  );
};
var reactApexcharts_min = {};
var apexcharts_common = { exports: {} };
/*!
 * ApexCharts v3.52.0
 * (c) 2018-2024 ApexCharts
 * Released under the MIT License.
 */
(function(module, exports) {
  function t6(t7, e4) {
    var i17 = Object.keys(t7);
    if (Object.getOwnPropertySymbols) {
      var a10 = Object.getOwnPropertySymbols(t7);
      e4 && (a10 = a10.filter(function(e5) {
        return Object.getOwnPropertyDescriptor(t7, e5).enumerable;
      })), i17.push.apply(i17, a10);
    }
    return i17;
  }
  function e3(e4) {
    for (var i17 = 1; i17 < arguments.length; i17++) {
      var a10 = null != arguments[i17] ? arguments[i17] : {};
      i17 % 2 ? t6(Object(a10), true).forEach(function(t7) {
        o9(e4, t7, a10[t7]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(a10)) : t6(Object(a10)).forEach(function(t7) {
        Object.defineProperty(e4, t7, Object.getOwnPropertyDescriptor(a10, t7));
      });
    }
    return e4;
  }
  function i16(t7) {
    return i16 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t8) {
      return typeof t8;
    } : function(t8) {
      return t8 && "function" == typeof Symbol && t8.constructor === Symbol && t8 !== Symbol.prototype ? "symbol" : typeof t8;
    }, i16(t7);
  }
  function a9(t7, e4) {
    if (!(t7 instanceof e4))
      throw new TypeError("Cannot call a class as a function");
  }
  function s10(t7, e4) {
    for (var i17 = 0; i17 < e4.length; i17++) {
      var a10 = e4[i17];
      a10.enumerable = a10.enumerable || false, a10.configurable = true, "value" in a10 && (a10.writable = true), Object.defineProperty(t7, a10.key, a10);
    }
  }
  function r12(t7, e4, i17) {
    return e4 && s10(t7.prototype, e4), i17 && s10(t7, i17), t7;
  }
  function o9(t7, e4, i17) {
    return e4 in t7 ? Object.defineProperty(t7, e4, { value: i17, enumerable: true, configurable: true, writable: true }) : t7[e4] = i17, t7;
  }
  function n10(t7, e4) {
    if ("function" != typeof e4 && null !== e4)
      throw new TypeError("Super expression must either be null or a function");
    t7.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t7, writable: true, configurable: true } }), e4 && h3(t7, e4);
  }
  function l7(t7) {
    return l7 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t8) {
      return t8.__proto__ || Object.getPrototypeOf(t8);
    }, l7(t7);
  }
  function h3(t7, e4) {
    return h3 = Object.setPrototypeOf || function(t8, e5) {
      return t8.__proto__ = e5, t8;
    }, h3(t7, e4);
  }
  function c6(t7) {
    if (void 0 === t7)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return t7;
  }
  function d8(t7) {
    var e4 = function() {
      if ("undefined" == typeof Reflect || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if ("function" == typeof Proxy)
        return true;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), true;
      } catch (t8) {
        return false;
      }
    }();
    return function() {
      var i17, a10 = l7(t7);
      if (e4) {
        var s11 = l7(this).constructor;
        i17 = Reflect.construct(a10, arguments, s11);
      } else
        i17 = a10.apply(this, arguments);
      return function(t8, e5) {
        if (e5 && ("object" == typeof e5 || "function" == typeof e5))
          return e5;
        if (void 0 !== e5)
          throw new TypeError("Derived constructors may only return object or undefined");
        return c6(t8);
      }(this, i17);
    };
  }
  function g6(t7, e4) {
    return function(t8) {
      if (Array.isArray(t8))
        return t8;
    }(t7) || function(t8, e5) {
      var i17 = null == t8 ? null : "undefined" != typeof Symbol && t8[Symbol.iterator] || t8["@@iterator"];
      if (null == i17)
        return;
      var a10, s11, r13 = [], o10 = true, n11 = false;
      try {
        for (i17 = i17.call(t8); !(o10 = (a10 = i17.next()).done) && (r13.push(a10.value), !e5 || r13.length !== e5); o10 = true)
          ;
      } catch (t9) {
        n11 = true, s11 = t9;
      } finally {
        try {
          o10 || null == i17.return || i17.return();
        } finally {
          if (n11)
            throw s11;
        }
      }
      return r13;
    }(t7, e4) || p6(t7, e4) || function() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }();
  }
  function u5(t7) {
    return function(t8) {
      if (Array.isArray(t8))
        return f4(t8);
    }(t7) || function(t8) {
      if ("undefined" != typeof Symbol && null != t8[Symbol.iterator] || null != t8["@@iterator"])
        return Array.from(t8);
    }(t7) || p6(t7) || function() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }();
  }
  function p6(t7, e4) {
    if (t7) {
      if ("string" == typeof t7)
        return f4(t7, e4);
      var i17 = Object.prototype.toString.call(t7).slice(8, -1);
      return "Object" === i17 && t7.constructor && (i17 = t7.constructor.name), "Map" === i17 || "Set" === i17 ? Array.from(t7) : "Arguments" === i17 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i17) ? f4(t7, e4) : void 0;
    }
  }
  function f4(t7, e4) {
    (null == e4 || e4 > t7.length) && (e4 = t7.length);
    for (var i17 = 0, a10 = new Array(e4); i17 < e4; i17++)
      a10[i17] = t7[i17];
    return a10;
  }
  var x3 = function() {
    function t7() {
      a9(this, t7);
    }
    return r12(t7, [{ key: "shadeRGBColor", value: function(t8, e4) {
      var i17 = e4.split(","), a10 = t8 < 0 ? 0 : 255, s11 = t8 < 0 ? -1 * t8 : t8, r13 = parseInt(i17[0].slice(4), 10), o10 = parseInt(i17[1], 10), n11 = parseInt(i17[2], 10);
      return "rgb(" + (Math.round((a10 - r13) * s11) + r13) + "," + (Math.round((a10 - o10) * s11) + o10) + "," + (Math.round((a10 - n11) * s11) + n11) + ")";
    } }, { key: "shadeHexColor", value: function(t8, e4) {
      var i17 = parseInt(e4.slice(1), 16), a10 = t8 < 0 ? 0 : 255, s11 = t8 < 0 ? -1 * t8 : t8, r13 = i17 >> 16, o10 = i17 >> 8 & 255, n11 = 255 & i17;
      return "#" + (16777216 + 65536 * (Math.round((a10 - r13) * s11) + r13) + 256 * (Math.round((a10 - o10) * s11) + o10) + (Math.round((a10 - n11) * s11) + n11)).toString(16).slice(1);
    } }, { key: "shadeColor", value: function(e4, i17) {
      return t7.isColorHex(i17) ? this.shadeHexColor(e4, i17) : this.shadeRGBColor(e4, i17);
    } }], [{ key: "bind", value: function(t8, e4) {
      return function() {
        return t8.apply(e4, arguments);
      };
    } }, { key: "isObject", value: function(t8) {
      return t8 && "object" === i16(t8) && !Array.isArray(t8) && null != t8;
    } }, { key: "is", value: function(t8, e4) {
      return Object.prototype.toString.call(e4) === "[object " + t8 + "]";
    } }, { key: "listToArray", value: function(t8) {
      var e4, i17 = [];
      for (e4 = 0; e4 < t8.length; e4++)
        i17[e4] = t8[e4];
      return i17;
    } }, { key: "extend", value: function(t8, e4) {
      var i17 = this;
      "function" != typeof Object.assign && (Object.assign = function(t9) {
        if (null == t9)
          throw new TypeError("Cannot convert undefined or null to object");
        for (var e5 = Object(t9), i18 = 1; i18 < arguments.length; i18++) {
          var a11 = arguments[i18];
          if (null != a11)
            for (var s11 in a11)
              a11.hasOwnProperty(s11) && (e5[s11] = a11[s11]);
        }
        return e5;
      });
      var a10 = Object.assign({}, t8);
      return this.isObject(t8) && this.isObject(e4) && Object.keys(e4).forEach(function(s11) {
        i17.isObject(e4[s11]) && s11 in t8 ? a10[s11] = i17.extend(t8[s11], e4[s11]) : Object.assign(a10, o9({}, s11, e4[s11]));
      }), a10;
    } }, { key: "extendArray", value: function(e4, i17) {
      var a10 = [];
      return e4.map(function(e5) {
        a10.push(t7.extend(i17, e5));
      }), e4 = a10;
    } }, { key: "monthMod", value: function(t8) {
      return t8 % 12;
    } }, { key: "clone", value: function(e4) {
      if (t7.is("Array", e4)) {
        for (var a10 = [], s11 = 0; s11 < e4.length; s11++)
          a10[s11] = this.clone(e4[s11]);
        return a10;
      }
      if (t7.is("Null", e4))
        return null;
      if (t7.is("Date", e4))
        return e4;
      if ("object" === i16(e4)) {
        var r13 = {};
        for (var o10 in e4)
          e4.hasOwnProperty(o10) && (r13[o10] = this.clone(e4[o10]));
        return r13;
      }
      return e4;
    } }, { key: "log10", value: function(t8) {
      return Math.log(t8) / Math.LN10;
    } }, { key: "roundToBase10", value: function(t8) {
      return Math.pow(10, Math.floor(Math.log10(t8)));
    } }, { key: "roundToBase", value: function(t8, e4) {
      return Math.pow(e4, Math.floor(Math.log(t8) / Math.log(e4)));
    } }, { key: "parseNumber", value: function(t8) {
      return null === t8 ? t8 : parseFloat(t8);
    } }, { key: "stripNumber", value: function(t8) {
      var e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2;
      return Number.isInteger(t8) ? t8 : parseFloat(t8.toPrecision(e4));
    } }, { key: "randomId", value: function() {
      return (Math.random() + 1).toString(36).substring(4);
    } }, { key: "noExponents", value: function(t8) {
      var e4 = String(t8).split(/[eE]/);
      if (1 === e4.length)
        return e4[0];
      var i17 = "", a10 = t8 < 0 ? "-" : "", s11 = e4[0].replace(".", ""), r13 = Number(e4[1]) + 1;
      if (r13 < 0) {
        for (i17 = a10 + "0."; r13++; )
          i17 += "0";
        return i17 + s11.replace(/^-/, "");
      }
      for (r13 -= s11.length; r13--; )
        i17 += "0";
      return s11 + i17;
    } }, { key: "getDimensions", value: function(t8) {
      var e4 = getComputedStyle(t8, null), i17 = t8.clientHeight, a10 = t8.clientWidth;
      return i17 -= parseFloat(e4.paddingTop) + parseFloat(e4.paddingBottom), [a10 -= parseFloat(e4.paddingLeft) + parseFloat(e4.paddingRight), i17];
    } }, { key: "getBoundingClientRect", value: function(t8) {
      var e4 = t8.getBoundingClientRect();
      return { top: e4.top, right: e4.right, bottom: e4.bottom, left: e4.left, width: t8.clientWidth, height: t8.clientHeight, x: e4.left, y: e4.top };
    } }, { key: "getLargestStringFromArr", value: function(t8) {
      return t8.reduce(function(t9, e4) {
        return Array.isArray(e4) && (e4 = e4.reduce(function(t10, e5) {
          return t10.length > e5.length ? t10 : e5;
        })), t9.length > e4.length ? t9 : e4;
      }, 0);
    } }, { key: "hexToRgba", value: function() {
      var t8 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "#999999", e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0.6;
      "#" !== t8.substring(0, 1) && (t8 = "#999999");
      var i17 = t8.replace("#", "");
      i17 = i17.match(new RegExp("(.{" + i17.length / 3 + "})", "g"));
      for (var a10 = 0; a10 < i17.length; a10++)
        i17[a10] = parseInt(1 === i17[a10].length ? i17[a10] + i17[a10] : i17[a10], 16);
      return void 0 !== e4 && i17.push(e4), "rgba(" + i17.join(",") + ")";
    } }, { key: "getOpacityFromRGBA", value: function(t8) {
      return parseFloat(t8.replace(/^.*,(.+)\)/, "$1"));
    } }, { key: "rgb2hex", value: function(t8) {
      return (t8 = t8.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i)) && 4 === t8.length ? "#" + ("0" + parseInt(t8[1], 10).toString(16)).slice(-2) + ("0" + parseInt(t8[2], 10).toString(16)).slice(-2) + ("0" + parseInt(t8[3], 10).toString(16)).slice(-2) : "";
    } }, { key: "isColorHex", value: function(t8) {
      return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)|(^#[0-9A-F]{8}$)/i.test(t8);
    } }, { key: "getPolygonPos", value: function(t8, e4) {
      for (var i17 = [], a10 = 2 * Math.PI / e4, s11 = 0; s11 < e4; s11++) {
        var r13 = {};
        r13.x = t8 * Math.sin(s11 * a10), r13.y = -t8 * Math.cos(s11 * a10), i17.push(r13);
      }
      return i17;
    } }, { key: "polarToCartesian", value: function(t8, e4, i17, a10) {
      var s11 = (a10 - 90) * Math.PI / 180;
      return { x: t8 + i17 * Math.cos(s11), y: e4 + i17 * Math.sin(s11) };
    } }, { key: "escapeString", value: function(t8) {
      var e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "x", i17 = t8.toString().slice();
      return i17 = i17.replace(/[` ~!@#$%^&*()|+\=?;:'",.<>{}[\]\\/]/gi, e4);
    } }, { key: "negToZero", value: function(t8) {
      return t8 < 0 ? 0 : t8;
    } }, { key: "moveIndexInArray", value: function(t8, e4, i17) {
      if (i17 >= t8.length)
        for (var a10 = i17 - t8.length + 1; a10--; )
          t8.push(void 0);
      return t8.splice(i17, 0, t8.splice(e4, 1)[0]), t8;
    } }, { key: "extractNumber", value: function(t8) {
      return parseFloat(t8.replace(/[^\d.]*/g, ""));
    } }, { key: "findAncestor", value: function(t8, e4) {
      for (; (t8 = t8.parentElement) && !t8.classList.contains(e4); )
        ;
      return t8;
    } }, { key: "setELstyles", value: function(t8, e4) {
      for (var i17 in e4)
        e4.hasOwnProperty(i17) && (t8.style.key = e4[i17]);
    } }, { key: "preciseAddition", value: function(t8, e4) {
      var i17 = (String(t8).split(".")[1] || "").length, a10 = (String(e4).split(".")[1] || "").length, s11 = Math.pow(10, Math.max(i17, a10));
      return (Math.round(t8 * s11) + Math.round(e4 * s11)) / s11;
    } }, { key: "isNumber", value: function(t8) {
      return !isNaN(t8) && parseFloat(Number(t8)) === t8 && !isNaN(parseInt(t8, 10));
    } }, { key: "isFloat", value: function(t8) {
      return Number(t8) === t8 && t8 % 1 != 0;
    } }, { key: "isSafari", value: function() {
      return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    } }, { key: "isFirefox", value: function() {
      return navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
    } }, { key: "isIE11", value: function() {
      if (-1 !== window.navigator.userAgent.indexOf("MSIE") || window.navigator.appVersion.indexOf("Trident/") > -1)
        return true;
    } }, { key: "isIE", value: function() {
      var t8 = window.navigator.userAgent, e4 = t8.indexOf("MSIE ");
      if (e4 > 0)
        return parseInt(t8.substring(e4 + 5, t8.indexOf(".", e4)), 10);
      if (t8.indexOf("Trident/") > 0) {
        var i17 = t8.indexOf("rv:");
        return parseInt(t8.substring(i17 + 3, t8.indexOf(".", i17)), 10);
      }
      var a10 = t8.indexOf("Edge/");
      return a10 > 0 && parseInt(t8.substring(a10 + 5, t8.indexOf(".", a10)), 10);
    } }, { key: "getGCD", value: function(t8, e4) {
      var i17 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 7, a10 = Math.pow(10, i17 - Math.floor(Math.log10(Math.max(t8, e4))));
      for (t8 = Math.round(Math.abs(t8) * a10), e4 = Math.round(Math.abs(e4) * a10); e4; ) {
        var s11 = e4;
        e4 = t8 % e4, t8 = s11;
      }
      return t8 / a10;
    } }, { key: "getPrimeFactors", value: function(t8) {
      for (var e4 = [], i17 = 2; t8 >= 2; )
        t8 % i17 == 0 ? (e4.push(i17), t8 /= i17) : i17++;
      return e4;
    } }, { key: "mod", value: function(t8, e4) {
      var i17 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 7, a10 = Math.pow(10, i17 - Math.floor(Math.log10(Math.max(t8, e4))));
      return (t8 = Math.round(Math.abs(t8) * a10)) % (e4 = Math.round(Math.abs(e4) * a10)) / a10;
    } }]), t7;
  }(), b2 = function() {
    function t7(e4) {
      a9(this, t7), this.ctx = e4, this.w = e4.w, this.setEasingFunctions();
    }
    return r12(t7, [{ key: "setEasingFunctions", value: function() {
      var t8;
      if (!this.w.globals.easing) {
        switch (this.w.config.chart.animations.easing) {
          case "linear":
            t8 = "-";
            break;
          case "easein":
            t8 = "<";
            break;
          case "easeout":
            t8 = ">";
            break;
          case "easeinout":
          default:
            t8 = "<>";
            break;
          case "swing":
            t8 = function(t9) {
              var e4 = 1.70158;
              return (t9 -= 1) * t9 * ((e4 + 1) * t9 + e4) + 1;
            };
            break;
          case "bounce":
            t8 = function(t9) {
              return t9 < 1 / 2.75 ? 7.5625 * t9 * t9 : t9 < 2 / 2.75 ? 7.5625 * (t9 -= 1.5 / 2.75) * t9 + 0.75 : t9 < 2.5 / 2.75 ? 7.5625 * (t9 -= 2.25 / 2.75) * t9 + 0.9375 : 7.5625 * (t9 -= 2.625 / 2.75) * t9 + 0.984375;
            };
            break;
          case "elastic":
            t8 = function(t9) {
              return t9 === !!t9 ? t9 : Math.pow(2, -10 * t9) * Math.sin((t9 - 0.075) * (2 * Math.PI) / 0.3) + 1;
            };
        }
        this.w.globals.easing = t8;
      }
    } }, { key: "animateLine", value: function(t8, e4, i17, a10) {
      t8.attr(e4).animate(a10).attr(i17);
    } }, { key: "animateMarker", value: function(t8, e4, i17, a10) {
      t8.attr({ opacity: 0 }).animate(e4, i17).attr({ opacity: 1 }).afterAll(function() {
        a10();
      });
    } }, { key: "animateRect", value: function(t8, e4, i17, a10, s11) {
      t8.attr(e4).animate(a10).attr(i17).afterAll(function() {
        return s11();
      });
    } }, { key: "animatePathsGradually", value: function(t8) {
      var e4 = t8.el, i17 = t8.realIndex, a10 = t8.j, s11 = t8.fill, r13 = t8.pathFrom, o10 = t8.pathTo, n11 = t8.speed, l8 = t8.delay, h4 = this.w, c7 = 0;
      h4.config.chart.animations.animateGradually.enabled && (c7 = h4.config.chart.animations.animateGradually.delay), h4.config.chart.animations.dynamicAnimation.enabled && h4.globals.dataChanged && "bar" !== h4.config.chart.type && (c7 = 0), this.morphSVG(e4, i17, a10, "line" !== h4.config.chart.type || h4.globals.comboCharts ? s11 : "stroke", r13, o10, n11, l8 * c7);
    } }, { key: "showDelayedElements", value: function() {
      this.w.globals.delayedElements.forEach(function(t8) {
        var e4 = t8.el;
        e4.classList.remove("apexcharts-element-hidden"), e4.classList.add("apexcharts-hidden-element-shown");
      });
    } }, { key: "animationCompleted", value: function(t8) {
      var e4 = this.w;
      e4.globals.animationEnded || (e4.globals.animationEnded = true, this.showDelayedElements(), "function" == typeof e4.config.chart.events.animationEnd && e4.config.chart.events.animationEnd(this.ctx, { el: t8, w: e4 }));
    } }, { key: "morphSVG", value: function(t8, e4, i17, a10, s11, r13, o10, n11) {
      var l8 = this, h4 = this.w;
      s11 || (s11 = t8.attr("pathFrom")), r13 || (r13 = t8.attr("pathTo"));
      var c7 = function(t9) {
        return "radar" === h4.config.chart.type && (o10 = 1), "M 0 ".concat(h4.globals.gridHeight);
      };
      (!s11 || s11.indexOf("undefined") > -1 || s11.indexOf("NaN") > -1) && (s11 = c7()), (!r13 || r13.indexOf("undefined") > -1 || r13.indexOf("NaN") > -1) && (r13 = c7()), h4.globals.shouldAnimate || (o10 = 1), t8.plot(s11).animate(1, h4.globals.easing, n11).plot(s11).animate(o10, h4.globals.easing, n11).plot(r13).afterAll(function() {
        x3.isNumber(i17) ? i17 === h4.globals.series[h4.globals.maxValsInArrayIndex].length - 2 && h4.globals.shouldAnimate && l8.animationCompleted(t8) : "none" !== a10 && h4.globals.shouldAnimate && (!h4.globals.comboCharts && e4 === h4.globals.series.length - 1 || h4.globals.comboCharts) && l8.animationCompleted(t8), l8.showDelayedElements();
      });
    } }]), t7;
  }(), v3 = function() {
    function t7(e4) {
      a9(this, t7), this.ctx = e4, this.w = e4.w;
    }
    return r12(t7, [{ key: "getDefaultFilter", value: function(t8, e4) {
      var i17 = this.w;
      t8.unfilter(true), new window.SVG.Filter().size("120%", "180%", "-5%", "-40%"), "none" !== i17.config.states.normal.filter ? this.applyFilter(t8, e4, i17.config.states.normal.filter.type, i17.config.states.normal.filter.value) : i17.config.chart.dropShadow.enabled && this.dropShadow(t8, i17.config.chart.dropShadow, e4);
    } }, { key: "addNormalFilter", value: function(t8, e4) {
      var i17 = this.w;
      i17.config.chart.dropShadow.enabled && !t8.node.classList.contains("apexcharts-marker") && this.dropShadow(t8, i17.config.chart.dropShadow, e4);
    } }, { key: "addLightenFilter", value: function(t8, e4, i17) {
      var a10 = this, s11 = this.w, r13 = i17.intensity;
      t8.unfilter(true);
      new window.SVG.Filter();
      t8.filter(function(t9) {
        var i18 = s11.config.chart.dropShadow;
        (i18.enabled ? a10.addShadow(t9, e4, i18) : t9).componentTransfer({ rgb: { type: "linear", slope: 1.5, intercept: r13 } });
      }), t8.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t8.filterer.node);
    } }, { key: "addDarkenFilter", value: function(t8, e4, i17) {
      var a10 = this, s11 = this.w, r13 = i17.intensity;
      t8.unfilter(true);
      new window.SVG.Filter();
      t8.filter(function(t9) {
        var i18 = s11.config.chart.dropShadow;
        (i18.enabled ? a10.addShadow(t9, e4, i18) : t9).componentTransfer({ rgb: { type: "linear", slope: r13 } });
      }), t8.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t8.filterer.node);
    } }, { key: "applyFilter", value: function(t8, e4, i17) {
      var a10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0.5;
      switch (i17) {
        case "none":
          this.addNormalFilter(t8, e4);
          break;
        case "lighten":
          this.addLightenFilter(t8, e4, { intensity: a10 });
          break;
        case "darken":
          this.addDarkenFilter(t8, e4, { intensity: a10 });
      }
    } }, { key: "addShadow", value: function(t8, e4, i17) {
      var a10, s11 = this.w, r13 = i17.blur, o10 = i17.top, n11 = i17.left, l8 = i17.color, h4 = i17.opacity;
      if ((null === (a10 = s11.config.chart.dropShadow.enabledOnSeries) || void 0 === a10 ? void 0 : a10.length) > 0 && -1 === s11.config.chart.dropShadow.enabledOnSeries.indexOf(e4))
        return t8;
      var c7 = t8.flood(Array.isArray(l8) ? l8[e4] : l8, h4).composite(t8.sourceAlpha, "in").offset(n11, o10).gaussianBlur(r13).merge(t8.source);
      return t8.blend(t8.source, c7);
    } }, { key: "dropShadow", value: function(t8, e4) {
      var i17, a10, s11 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, r13 = e4.top, o10 = e4.left, n11 = e4.blur, l8 = e4.color, h4 = e4.opacity, c7 = e4.noUserSpaceOnUse, d9 = this.w;
      if (t8.unfilter(true), x3.isIE() && "radialBar" === d9.config.chart.type)
        return t8;
      if ((null === (i17 = d9.config.chart.dropShadow.enabledOnSeries) || void 0 === i17 ? void 0 : i17.length) > 0 && -1 === (null === (a10 = d9.config.chart.dropShadow.enabledOnSeries) || void 0 === a10 ? void 0 : a10.indexOf(s11)))
        return t8;
      return l8 = Array.isArray(l8) ? l8[s11] : l8, t8.filter(function(t9) {
        var e5 = null;
        e5 = x3.isSafari() || x3.isFirefox() || x3.isIE() ? t9.flood(l8, h4).composite(t9.sourceAlpha, "in").offset(o10, r13).gaussianBlur(n11) : t9.flood(l8, h4).composite(t9.sourceAlpha, "in").offset(o10, r13).gaussianBlur(n11).merge(t9.source), t9.blend(t9.source, e5);
      }), c7 || t8.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t8.filterer.node), t8;
    } }, { key: "setSelectionFilter", value: function(t8, e4, i17) {
      var a10 = this.w;
      if (void 0 !== a10.globals.selectedDataPoints[e4] && a10.globals.selectedDataPoints[e4].indexOf(i17) > -1) {
        t8.node.setAttribute("selected", true);
        var s11 = a10.config.states.active.filter;
        "none" !== s11 && this.applyFilter(t8, e4, s11.type, s11.value);
      }
    } }, { key: "_scaleFilterSize", value: function(t8) {
      !function(e4) {
        for (var i17 in e4)
          e4.hasOwnProperty(i17) && t8.setAttribute(i17, e4[i17]);
      }({ width: "200%", height: "200%", x: "-50%", y: "-50%" });
    } }]), t7;
  }(), m3 = function() {
    function t7(e4) {
      a9(this, t7), this.ctx = e4, this.w = e4.w;
    }
    return r12(t7, [{ key: "roundPathCorners", value: function(t8, e4) {
      function i17(t9, e5, i18) {
        var s12 = e5.x - t9.x, r14 = e5.y - t9.y, o11 = Math.sqrt(s12 * s12 + r14 * r14);
        return a10(t9, e5, Math.min(1, i18 / o11));
      }
      function a10(t9, e5, i18) {
        return { x: t9.x + (e5.x - t9.x) * i18, y: t9.y + (e5.y - t9.y) * i18 };
      }
      function s11(t9, e5) {
        t9.length > 2 && (t9[t9.length - 2] = e5.x, t9[t9.length - 1] = e5.y);
      }
      function r13(t9) {
        return { x: parseFloat(t9[t9.length - 2]), y: parseFloat(t9[t9.length - 1]) };
      }
      t8.indexOf("NaN") > -1 && (t8 = "");
      var o10 = t8.split(/[,\s]/).reduce(function(t9, e5) {
        var i18 = e5.match("([a-zA-Z])(.+)");
        return i18 ? (t9.push(i18[1]), t9.push(i18[2])) : t9.push(e5), t9;
      }, []).reduce(function(t9, e5) {
        return parseFloat(e5) == e5 && t9.length ? t9[t9.length - 1].push(e5) : t9.push([e5]), t9;
      }, []), n11 = [];
      if (o10.length > 1) {
        var l8 = r13(o10[0]), h4 = null;
        "Z" == o10[o10.length - 1][0] && o10[0].length > 2 && (h4 = ["L", l8.x, l8.y], o10[o10.length - 1] = h4), n11.push(o10[0]);
        for (var c7 = 1; c7 < o10.length; c7++) {
          var d9 = n11[n11.length - 1], g7 = o10[c7], u6 = g7 == h4 ? o10[1] : o10[c7 + 1];
          if (u6 && d9 && d9.length > 2 && "L" == g7[0] && u6.length > 2 && "L" == u6[0]) {
            var p7, f5, x4 = r13(d9), b3 = r13(g7), v5 = r13(u6);
            p7 = i17(b3, x4, e4), f5 = i17(b3, v5, e4), s11(g7, p7), g7.origPoint = b3, n11.push(g7);
            var m4 = a10(p7, b3, 0.5), y5 = a10(b3, f5, 0.5), w4 = ["C", m4.x, m4.y, y5.x, y5.y, f5.x, f5.y];
            w4.origPoint = b3, n11.push(w4);
          } else
            n11.push(g7);
        }
        if (h4) {
          var k4 = r13(n11[n11.length - 1]);
          n11.push(["Z"]), s11(n11[0], k4);
        }
      } else
        n11 = o10;
      return n11.reduce(function(t9, e5) {
        return t9 + e5.join(" ") + " ";
      }, "");
    } }, { key: "drawLine", value: function(t8, e4, i17, a10) {
      var s11 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "#a8a8a8", r13 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0, o10 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null, n11 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : "butt";
      return this.w.globals.dom.Paper.line().attr({ x1: t8, y1: e4, x2: i17, y2: a10, stroke: s11, "stroke-dasharray": r13, "stroke-width": o10, "stroke-linecap": n11 });
    } }, { key: "drawRect", value: function() {
      var t8 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, i17 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, a10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, s11 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, r13 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "#fefefe", o10 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 1, n11 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null, l8 = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : null, h4 = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : 0, c7 = this.w.globals.dom.Paper.rect();
      return c7.attr({ x: t8, y: e4, width: i17 > 0 ? i17 : 0, height: a10 > 0 ? a10 : 0, rx: s11, ry: s11, opacity: o10, "stroke-width": null !== n11 ? n11 : 0, stroke: null !== l8 ? l8 : "none", "stroke-dasharray": h4 }), c7.node.setAttribute("fill", r13), c7;
    } }, { key: "drawPolygon", value: function(t8) {
      var e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "#e1e1e1", i17 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, a10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "none";
      return this.w.globals.dom.Paper.polygon(t8).attr({ fill: a10, stroke: e4, "stroke-width": i17 });
    } }, { key: "drawCircle", value: function(t8) {
      var e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
      t8 < 0 && (t8 = 0);
      var i17 = this.w.globals.dom.Paper.circle(2 * t8);
      return null !== e4 && i17.attr(e4), i17;
    } }, { key: "drawPath", value: function(t8) {
      var e4 = t8.d, i17 = void 0 === e4 ? "" : e4, a10 = t8.stroke, s11 = void 0 === a10 ? "#a8a8a8" : a10, r13 = t8.strokeWidth, o10 = void 0 === r13 ? 1 : r13, n11 = t8.fill, l8 = t8.fillOpacity, h4 = void 0 === l8 ? 1 : l8, c7 = t8.strokeOpacity, d9 = void 0 === c7 ? 1 : c7, g7 = t8.classes, u6 = t8.strokeLinecap, p7 = void 0 === u6 ? null : u6, f5 = t8.strokeDashArray, x4 = void 0 === f5 ? 0 : f5, b3 = this.w;
      return null === p7 && (p7 = b3.config.stroke.lineCap), (i17.indexOf("undefined") > -1 || i17.indexOf("NaN") > -1) && (i17 = "M 0 ".concat(b3.globals.gridHeight)), b3.globals.dom.Paper.path(i17).attr({ fill: n11, "fill-opacity": h4, stroke: s11, "stroke-opacity": d9, "stroke-linecap": p7, "stroke-width": o10, "stroke-dasharray": x4, class: g7 });
    } }, { key: "group", value: function() {
      var t8 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, e4 = this.w.globals.dom.Paper.group();
      return null !== t8 && e4.attr(t8), e4;
    } }, { key: "move", value: function(t8, e4) {
      var i17 = ["M", t8, e4].join(" ");
      return i17;
    } }, { key: "line", value: function(t8, e4) {
      var i17 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, a10 = null;
      return null === i17 ? a10 = [" L", t8, e4].join(" ") : "H" === i17 ? a10 = [" H", t8].join(" ") : "V" === i17 && (a10 = [" V", e4].join(" ")), a10;
    } }, { key: "curve", value: function(t8, e4, i17, a10, s11, r13) {
      var o10 = ["C", t8, e4, i17, a10, s11, r13].join(" ");
      return o10;
    } }, { key: "quadraticCurve", value: function(t8, e4, i17, a10) {
      return ["Q", t8, e4, i17, a10].join(" ");
    } }, { key: "arc", value: function(t8, e4, i17, a10, s11, r13, o10) {
      var n11 = "A";
      arguments.length > 7 && void 0 !== arguments[7] && arguments[7] && (n11 = "a");
      var l8 = [n11, t8, e4, i17, a10, s11, r13, o10].join(" ");
      return l8;
    } }, { key: "renderPaths", value: function(t8) {
      var i17, a10 = t8.j, s11 = t8.realIndex, r13 = t8.pathFrom, o10 = t8.pathTo, n11 = t8.stroke, l8 = t8.strokeWidth, h4 = t8.strokeLinecap, c7 = t8.fill, d9 = t8.animationDelay, g7 = t8.initialSpeed, u6 = t8.dataChangeSpeed, p7 = t8.className, f5 = t8.shouldClipToGrid, x4 = void 0 === f5 || f5, m4 = t8.bindEventsOnPaths, y5 = void 0 === m4 || m4, w4 = t8.drawShadow, k4 = void 0 === w4 || w4, A3 = this.w, S3 = new v3(this.ctx), C3 = new b2(this.ctx), L4 = this.w.config.chart.animations.enabled, P3 = L4 && this.w.config.chart.animations.dynamicAnimation.enabled, M4 = !!(L4 && !A3.globals.resized || P3 && A3.globals.dataChanged && A3.globals.shouldAnimate);
      M4 ? i17 = r13 : (i17 = o10, A3.globals.animationEnded = true);
      var I4 = A3.config.stroke.dashArray, T4 = 0;
      T4 = Array.isArray(I4) ? I4[s11] : A3.config.stroke.dashArray;
      var z4 = this.drawPath({ d: i17, stroke: n11, strokeWidth: l8, fill: c7, fillOpacity: 1, classes: p7, strokeLinecap: h4, strokeDashArray: T4 });
      if (z4.attr("index", s11), x4 && z4.attr({ "clip-path": "url(#gridRectMask".concat(A3.globals.cuid, ")") }), "none" !== A3.config.states.normal.filter.type)
        S3.getDefaultFilter(z4, s11);
      else if (A3.config.chart.dropShadow.enabled && k4) {
        var X3 = A3.config.chart.dropShadow;
        S3.dropShadow(z4, X3, s11);
      }
      y5 && (z4.node.addEventListener("mouseenter", this.pathMouseEnter.bind(this, z4)), z4.node.addEventListener("mouseleave", this.pathMouseLeave.bind(this, z4)), z4.node.addEventListener("mousedown", this.pathMouseDown.bind(this, z4))), z4.attr({ pathTo: o10, pathFrom: r13 });
      var E3 = { el: z4, j: a10, realIndex: s11, pathFrom: r13, pathTo: o10, fill: c7, strokeWidth: l8, delay: d9 };
      return !L4 || A3.globals.resized || A3.globals.dataChanged ? !A3.globals.resized && A3.globals.dataChanged || C3.showDelayedElements() : C3.animatePathsGradually(e3(e3({}, E3), {}, { speed: g7 })), A3.globals.dataChanged && P3 && M4 && C3.animatePathsGradually(e3(e3({}, E3), {}, { speed: u6 })), z4;
    } }, { key: "drawPattern", value: function(t8, e4, i17) {
      var a10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "#a8a8a8", s11 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
      return this.w.globals.dom.Paper.pattern(e4, i17, function(r13) {
        "horizontalLines" === t8 ? r13.line(0, 0, i17, 0).stroke({ color: a10, width: s11 + 1 }) : "verticalLines" === t8 ? r13.line(0, 0, 0, e4).stroke({ color: a10, width: s11 + 1 }) : "slantedLines" === t8 ? r13.line(0, 0, e4, i17).stroke({ color: a10, width: s11 }) : "squares" === t8 ? r13.rect(e4, i17).fill("none").stroke({ color: a10, width: s11 }) : "circles" === t8 && r13.circle(e4).fill("none").stroke({ color: a10, width: s11 });
      });
    } }, { key: "drawGradient", value: function(t8, e4, i17, a10, s11) {
      var r13, o10 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null, n11 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null, l8 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null, h4 = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0, c7 = this.w;
      e4.length < 9 && 0 === e4.indexOf("#") && (e4 = x3.hexToRgba(e4, a10)), i17.length < 9 && 0 === i17.indexOf("#") && (i17 = x3.hexToRgba(i17, s11));
      var d9 = 0, g7 = 1, u6 = 1, p7 = null;
      null !== n11 && (d9 = void 0 !== n11[0] ? n11[0] / 100 : 0, g7 = void 0 !== n11[1] ? n11[1] / 100 : 1, u6 = void 0 !== n11[2] ? n11[2] / 100 : 1, p7 = void 0 !== n11[3] ? n11[3] / 100 : null);
      var f5 = !("donut" !== c7.config.chart.type && "pie" !== c7.config.chart.type && "polarArea" !== c7.config.chart.type && "bubble" !== c7.config.chart.type);
      if (r13 = null === l8 || 0 === l8.length ? c7.globals.dom.Paper.gradient(f5 ? "radial" : "linear", function(t9) {
        t9.at(d9, e4, a10), t9.at(g7, i17, s11), t9.at(u6, i17, s11), null !== p7 && t9.at(p7, e4, a10);
      }) : c7.globals.dom.Paper.gradient(f5 ? "radial" : "linear", function(t9) {
        (Array.isArray(l8[h4]) ? l8[h4] : l8).forEach(function(e5) {
          t9.at(e5.offset / 100, e5.color, e5.opacity);
        });
      }), f5) {
        var b3 = c7.globals.gridWidth / 2, v5 = c7.globals.gridHeight / 2;
        "bubble" !== c7.config.chart.type ? r13.attr({ gradientUnits: "userSpaceOnUse", cx: b3, cy: v5, r: o10 }) : r13.attr({ cx: 0.5, cy: 0.5, r: 0.8, fx: 0.2, fy: 0.2 });
      } else
        "vertical" === t8 ? r13.from(0, 0).to(0, 1) : "diagonal" === t8 ? r13.from(0, 0).to(1, 1) : "horizontal" === t8 ? r13.from(0, 1).to(1, 1) : "diagonal2" === t8 && r13.from(1, 0).to(0, 1);
      return r13;
    } }, { key: "getTextBasedOnMaxWidth", value: function(t8) {
      var e4 = t8.text, i17 = t8.maxWidth, a10 = t8.fontSize, s11 = t8.fontFamily, r13 = this.getTextRects(e4, a10, s11), o10 = r13.width / e4.length, n11 = Math.floor(i17 / o10);
      return i17 < r13.width ? e4.slice(0, n11 - 3) + "..." : e4;
    } }, { key: "drawText", value: function(t8) {
      var i17 = this, a10 = t8.x, s11 = t8.y, r13 = t8.text, o10 = t8.textAnchor, n11 = t8.fontSize, l8 = t8.fontFamily, h4 = t8.fontWeight, c7 = t8.foreColor, d9 = t8.opacity, g7 = t8.maxWidth, u6 = t8.cssClass, p7 = void 0 === u6 ? "" : u6, f5 = t8.isPlainText, x4 = void 0 === f5 || f5, b3 = t8.dominantBaseline, v5 = void 0 === b3 ? "auto" : b3, m4 = this.w;
      void 0 === r13 && (r13 = "");
      var y5 = r13;
      o10 || (o10 = "start"), c7 && c7.length || (c7 = m4.config.chart.foreColor), l8 = l8 || m4.config.chart.fontFamily, h4 = h4 || "regular";
      var w4, k4 = { maxWidth: g7, fontSize: n11 = n11 || "11px", fontFamily: l8 };
      return Array.isArray(r13) ? w4 = m4.globals.dom.Paper.text(function(t9) {
        for (var a11 = 0; a11 < r13.length; a11++)
          y5 = r13[a11], g7 && (y5 = i17.getTextBasedOnMaxWidth(e3({ text: r13[a11] }, k4))), 0 === a11 ? t9.tspan(y5) : t9.tspan(y5).newLine();
      }) : (g7 && (y5 = this.getTextBasedOnMaxWidth(e3({ text: r13 }, k4))), w4 = x4 ? m4.globals.dom.Paper.plain(r13) : m4.globals.dom.Paper.text(function(t9) {
        return t9.tspan(y5);
      })), w4.attr({ x: a10, y: s11, "text-anchor": o10, "dominant-baseline": v5, "font-size": n11, "font-family": l8, "font-weight": h4, fill: c7, class: "apexcharts-text " + p7 }), w4.node.style.fontFamily = l8, w4.node.style.opacity = d9, w4;
    } }, { key: "getMarkerPath", value: function(t8, e4, i17, a10) {
      var s11 = "";
      switch (i17) {
        case "cross":
          s11 = "M ".concat(t8 - (a10 /= 1.4), " ").concat(e4 - a10, " L ").concat(t8 + a10, " ").concat(e4 + a10, "  M ").concat(t8 - a10, " ").concat(e4 + a10, " L ").concat(t8 + a10, " ").concat(e4 - a10);
          break;
        case "plus":
          s11 = "M ".concat(t8 - (a10 /= 1.12), " ").concat(e4, " L ").concat(t8 + a10, " ").concat(e4, "  M ").concat(t8, " ").concat(e4 - a10, " L ").concat(t8, " ").concat(e4 + a10);
          break;
        case "star":
        case "sparkle":
          var r13 = 5;
          a10 *= 1.15, "sparkle" === i17 && (a10 /= 1.1, r13 = 4);
          for (var o10 = Math.PI / r13, n11 = 0; n11 <= 2 * r13; n11++) {
            var l8 = n11 * o10, h4 = n11 % 2 == 0 ? a10 : a10 / 2;
            s11 += (0 === n11 ? "M" : "L") + (t8 + h4 * Math.sin(l8)) + "," + (e4 - h4 * Math.cos(l8));
          }
          s11 += "Z";
          break;
        case "triangle":
          s11 = "M ".concat(t8, " ").concat(e4 - a10, " \n             L ").concat(t8 + a10, " ").concat(e4 + a10, " \n             L ").concat(t8 - a10, " ").concat(e4 + a10, " \n             Z");
          break;
        case "square":
        case "rect":
          s11 = "M ".concat(t8 - (a10 /= 1.125), " ").concat(e4 - a10, " \n           L ").concat(t8 + a10, " ").concat(e4 - a10, " \n           L ").concat(t8 + a10, " ").concat(e4 + a10, " \n           L ").concat(t8 - a10, " ").concat(e4 + a10, " \n           Z");
          break;
        case "diamond":
          a10 *= 1.05, s11 = "M ".concat(t8, " ").concat(e4 - a10, " \n             L ").concat(t8 + a10, " ").concat(e4, " \n             L ").concat(t8, " ").concat(e4 + a10, " \n             L ").concat(t8 - a10, " ").concat(e4, " \n            Z");
          break;
        case "line":
          s11 = "M ".concat(t8 - (a10 /= 1.1), " ").concat(e4, " \n           L ").concat(t8 + a10, " ").concat(e4);
          break;
        default:
          a10 *= 2, s11 = "M ".concat(t8, ", ").concat(e4, " \n           m -").concat(a10 / 2, ", 0 \n           a ").concat(a10 / 2, ",").concat(a10 / 2, " 0 1,0 ").concat(a10, ",0 \n           a ").concat(a10 / 2, ",").concat(a10 / 2, " 0 1,0 -").concat(a10, ",0");
      }
      return s11;
    } }, { key: "drawMarkerShape", value: function(t8, e4, i17, a10, s11) {
      var r13 = this.drawPath({ d: this.getMarkerPath(t8, e4, i17, a10, s11), stroke: s11.pointStrokeColor, strokeDashArray: s11.pointStrokeDashArray, strokeWidth: s11.pointStrokeWidth, fill: s11.pointFillColor, fillOpacity: s11.pointFillOpacity, strokeOpacity: s11.pointStrokeOpacity });
      return r13.attr({ cx: t8, cy: e4, shape: s11.shape, class: s11.class ? s11.class : "" }), r13;
    } }, { key: "drawMarker", value: function(t8, i17, a10) {
      t8 = t8 || 0;
      var s11 = a10.pSize || 0;
      return x3.isNumber(i17) || (s11 = 0, i17 = 0), this.drawMarkerShape(t8, i17, null == a10 ? void 0 : a10.shape, s11, e3(e3({}, a10), "line" === a10.shape || "plus" === a10.shape || "cross" === a10.shape ? { pointStrokeColor: a10.pointFillColor, pointStrokeOpacity: a10.pointFillOpacity } : {}));
    } }, { key: "pathMouseEnter", value: function(t8, e4) {
      var i17 = this.w, a10 = new v3(this.ctx), s11 = parseInt(t8.node.getAttribute("index"), 10), r13 = parseInt(t8.node.getAttribute("j"), 10);
      if ("function" == typeof i17.config.chart.events.dataPointMouseEnter && i17.config.chart.events.dataPointMouseEnter(e4, this.ctx, { seriesIndex: s11, dataPointIndex: r13, w: i17 }), this.ctx.events.fireEvent("dataPointMouseEnter", [e4, this.ctx, { seriesIndex: s11, dataPointIndex: r13, w: i17 }]), ("none" === i17.config.states.active.filter.type || "true" !== t8.node.getAttribute("selected")) && "none" !== i17.config.states.hover.filter.type && !i17.globals.isTouchDevice) {
        var o10 = i17.config.states.hover.filter;
        a10.applyFilter(t8, s11, o10.type, o10.value);
      }
    } }, { key: "pathMouseLeave", value: function(t8, e4) {
      var i17 = this.w, a10 = new v3(this.ctx), s11 = parseInt(t8.node.getAttribute("index"), 10), r13 = parseInt(t8.node.getAttribute("j"), 10);
      "function" == typeof i17.config.chart.events.dataPointMouseLeave && i17.config.chart.events.dataPointMouseLeave(e4, this.ctx, { seriesIndex: s11, dataPointIndex: r13, w: i17 }), this.ctx.events.fireEvent("dataPointMouseLeave", [e4, this.ctx, { seriesIndex: s11, dataPointIndex: r13, w: i17 }]), "none" !== i17.config.states.active.filter.type && "true" === t8.node.getAttribute("selected") || "none" !== i17.config.states.hover.filter.type && a10.getDefaultFilter(t8, s11);
    } }, { key: "pathMouseDown", value: function(t8, e4) {
      var i17 = this.w, a10 = new v3(this.ctx), s11 = parseInt(t8.node.getAttribute("index"), 10), r13 = parseInt(t8.node.getAttribute("j"), 10), o10 = "false";
      if ("true" === t8.node.getAttribute("selected")) {
        if (t8.node.setAttribute("selected", "false"), i17.globals.selectedDataPoints[s11].indexOf(r13) > -1) {
          var n11 = i17.globals.selectedDataPoints[s11].indexOf(r13);
          i17.globals.selectedDataPoints[s11].splice(n11, 1);
        }
      } else {
        if (!i17.config.states.active.allowMultipleDataPointsSelection && i17.globals.selectedDataPoints.length > 0) {
          i17.globals.selectedDataPoints = [];
          var l8 = i17.globals.dom.Paper.select(".apexcharts-series path").members, h4 = i17.globals.dom.Paper.select(".apexcharts-series circle, .apexcharts-series rect").members, c7 = function(t9) {
            Array.prototype.forEach.call(t9, function(t10) {
              t10.node.setAttribute("selected", "false"), a10.getDefaultFilter(t10, s11);
            });
          };
          c7(l8), c7(h4);
        }
        t8.node.setAttribute("selected", "true"), o10 = "true", void 0 === i17.globals.selectedDataPoints[s11] && (i17.globals.selectedDataPoints[s11] = []), i17.globals.selectedDataPoints[s11].push(r13);
      }
      if ("true" === o10) {
        var d9 = i17.config.states.active.filter;
        if ("none" !== d9)
          a10.applyFilter(t8, s11, d9.type, d9.value);
        else if ("none" !== i17.config.states.hover.filter && !i17.globals.isTouchDevice) {
          var g7 = i17.config.states.hover.filter;
          a10.applyFilter(t8, s11, g7.type, g7.value);
        }
      } else if ("none" !== i17.config.states.active.filter.type)
        if ("none" === i17.config.states.hover.filter.type || i17.globals.isTouchDevice)
          a10.getDefaultFilter(t8, s11);
        else {
          g7 = i17.config.states.hover.filter;
          a10.applyFilter(t8, s11, g7.type, g7.value);
        }
      "function" == typeof i17.config.chart.events.dataPointSelection && i17.config.chart.events.dataPointSelection(e4, this.ctx, { selectedDataPoints: i17.globals.selectedDataPoints, seriesIndex: s11, dataPointIndex: r13, w: i17 }), e4 && this.ctx.events.fireEvent("dataPointSelection", [e4, this.ctx, { selectedDataPoints: i17.globals.selectedDataPoints, seriesIndex: s11, dataPointIndex: r13, w: i17 }]);
    } }, { key: "rotateAroundCenter", value: function(t8) {
      var e4 = {};
      return t8 && "function" == typeof t8.getBBox && (e4 = t8.getBBox()), { x: e4.x + e4.width / 2, y: e4.y + e4.height / 2 };
    } }, { key: "getTextRects", value: function(t8, e4, i17, a10) {
      var s11 = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4], r13 = this.w, o10 = this.drawText({ x: -200, y: -200, text: t8, textAnchor: "start", fontSize: e4, fontFamily: i17, foreColor: "#fff", opacity: 0 });
      a10 && o10.attr("transform", a10), r13.globals.dom.Paper.add(o10);
      var n11 = o10.bbox();
      return s11 || (n11 = o10.node.getBoundingClientRect()), o10.remove(), { width: n11.width, height: n11.height };
    } }, { key: "placeTextWithEllipsis", value: function(t8, e4, i17) {
      if ("function" == typeof t8.getComputedTextLength && (t8.textContent = e4, e4.length > 0 && t8.getComputedTextLength() >= i17 / 1.1)) {
        for (var a10 = e4.length - 3; a10 > 0; a10 -= 3)
          if (t8.getSubStringLength(0, a10) <= i17 / 1.1)
            return void (t8.textContent = e4.substring(0, a10) + "...");
        t8.textContent = ".";
      }
    } }], [{ key: "setAttrs", value: function(t8, e4) {
      for (var i17 in e4)
        e4.hasOwnProperty(i17) && t8.setAttribute(i17, e4[i17]);
    } }]), t7;
  }(), y4 = function() {
    function t7(e4) {
      a9(this, t7), this.ctx = e4, this.w = e4.w;
    }
    return r12(t7, [{ key: "getStackedSeriesTotals", value: function() {
      var t8 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], e4 = this.w, i17 = [];
      if (0 === e4.globals.series.length)
        return i17;
      for (var a10 = 0; a10 < e4.globals.series[e4.globals.maxValsInArrayIndex].length; a10++) {
        for (var s11 = 0, r13 = 0; r13 < e4.globals.series.length; r13++)
          void 0 !== e4.globals.series[r13][a10] && -1 === t8.indexOf(r13) && (s11 += e4.globals.series[r13][a10]);
        i17.push(s11);
      }
      return i17;
    } }, { key: "getSeriesTotalByIndex", value: function() {
      var t8 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
      return null === t8 ? this.w.config.series.reduce(function(t9, e4) {
        return t9 + e4;
      }, 0) : this.w.globals.series[t8].reduce(function(t9, e4) {
        return t9 + e4;
      }, 0);
    } }, { key: "getStackedSeriesTotalsByGroups", value: function() {
      var t8 = this, e4 = this.w, i17 = [];
      return e4.globals.seriesGroups.forEach(function(a10) {
        var s11 = [];
        e4.config.series.forEach(function(t9, i18) {
          a10.indexOf(e4.globals.seriesNames[i18]) > -1 && s11.push(i18);
        });
        var r13 = e4.globals.series.map(function(t9, e5) {
          return -1 === s11.indexOf(e5) ? e5 : -1;
        }).filter(function(t9) {
          return -1 !== t9;
        });
        i17.push(t8.getStackedSeriesTotals(r13));
      }), i17;
    } }, { key: "setSeriesYAxisMappings", value: function() {
      var t8 = this.w.globals, e4 = this.w.config, i17 = [], a10 = [], s11 = [], r13 = t8.series.length > e4.yaxis.length || e4.yaxis.some(function(t9) {
        return Array.isArray(t9.seriesName);
      });
      e4.series.forEach(function(t9, e5) {
        s11.push(e5), a10.push(null);
      }), e4.yaxis.forEach(function(t9, e5) {
        i17[e5] = [];
      });
      var o10 = [];
      e4.yaxis.forEach(function(t9, a11) {
        var n12 = false;
        if (t9.seriesName) {
          var l9 = [];
          Array.isArray(t9.seriesName) ? l9 = t9.seriesName : l9.push(t9.seriesName), l9.forEach(function(t10) {
            e4.series.forEach(function(e5, o11) {
              if (e5.name === t10) {
                var l10 = o11;
                a11 === o11 || r13 ? !r13 || s11.indexOf(o11) > -1 ? i17[a11].push([a11, o11]) : console.warn("Series '" + e5.name + "' referenced more than once in what looks like the new style. That is, when using either seriesName: [], or when there are more series than yaxes.") : (i17[o11].push([o11, a11]), l10 = a11), n12 = true, -1 !== (l10 = s11.indexOf(l10)) && s11.splice(l10, 1);
              }
            });
          });
        }
        n12 || o10.push(a11);
      }), i17 = i17.map(function(t9, e5) {
        var i18 = [];
        return t9.forEach(function(t10) {
          a10[t10[1]] = t10[0], i18.push(t10[1]);
        }), i18;
      });
      for (var n11 = e4.yaxis.length - 1, l8 = 0; l8 < o10.length && (n11 = o10[l8], i17[n11] = [], s11); l8++) {
        var h4 = s11[0];
        s11.shift(), i17[n11].push(h4), a10[h4] = n11;
      }
      s11.forEach(function(t9) {
        i17[n11].push(t9), a10[t9] = n11;
      }), t8.seriesYAxisMap = i17.map(function(t9) {
        return t9;
      }), t8.seriesYAxisReverseMap = a10.map(function(t9) {
        return t9;
      }), t8.seriesYAxisMap.forEach(function(t9, i18) {
        t9.forEach(function(t10) {
          e4.series[t10] && void 0 === e4.series[t10].group && (e4.series[t10].group = "apexcharts-axis-".concat(i18.toString()));
        });
      });
    } }, { key: "isSeriesNull", value: function() {
      var t8 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
      return 0 === (null === t8 ? this.w.config.series.filter(function(t9) {
        return null !== t9;
      }) : this.w.config.series[t8].data.filter(function(t9) {
        return null !== t9;
      })).length;
    } }, { key: "seriesHaveSameValues", value: function(t8) {
      return this.w.globals.series[t8].every(function(t9, e4, i17) {
        return t9 === i17[0];
      });
    } }, { key: "getCategoryLabels", value: function(t8) {
      var e4 = this.w, i17 = t8.slice();
      return e4.config.xaxis.convertedCatToNumeric && (i17 = t8.map(function(t9, i18) {
        return e4.config.xaxis.labels.formatter(t9 - e4.globals.minX + 1);
      })), i17;
    } }, { key: "getLargestSeries", value: function() {
      var t8 = this.w;
      t8.globals.maxValsInArrayIndex = t8.globals.series.map(function(t9) {
        return t9.length;
      }).indexOf(Math.max.apply(Math, t8.globals.series.map(function(t9) {
        return t9.length;
      })));
    } }, { key: "getLargestMarkerSize", value: function() {
      var t8 = this.w, e4 = 0;
      return t8.globals.markers.size.forEach(function(t9) {
        e4 = Math.max(e4, t9);
      }), t8.config.markers.discrete && t8.config.markers.discrete.length && t8.config.markers.discrete.forEach(function(t9) {
        e4 = Math.max(e4, t9.size);
      }), e4 > 0 && (e4 += t8.config.markers.hover.sizeOffset + 1), t8.globals.markers.largestSize = e4, e4;
    } }, { key: "getSeriesTotals", value: function() {
      var t8 = this.w;
      t8.globals.seriesTotals = t8.globals.series.map(function(t9, e4) {
        var i17 = 0;
        if (Array.isArray(t9))
          for (var a10 = 0; a10 < t9.length; a10++)
            i17 += t9[a10];
        else
          i17 += t9;
        return i17;
      });
    } }, { key: "getSeriesTotalsXRange", value: function(t8, e4) {
      var i17 = this.w;
      return i17.globals.series.map(function(a10, s11) {
        for (var r13 = 0, o10 = 0; o10 < a10.length; o10++)
          i17.globals.seriesX[s11][o10] > t8 && i17.globals.seriesX[s11][o10] < e4 && (r13 += a10[o10]);
        return r13;
      });
    } }, { key: "getPercentSeries", value: function() {
      var t8 = this.w;
      t8.globals.seriesPercent = t8.globals.series.map(function(e4, i17) {
        var a10 = [];
        if (Array.isArray(e4))
          for (var s11 = 0; s11 < e4.length; s11++) {
            var r13 = t8.globals.stackedSeriesTotals[s11], o10 = 0;
            r13 && (o10 = 100 * e4[s11] / r13), a10.push(o10);
          }
        else {
          var n11 = 100 * e4 / t8.globals.seriesTotals.reduce(function(t9, e5) {
            return t9 + e5;
          }, 0);
          a10.push(n11);
        }
        return a10;
      });
    } }, { key: "getCalculatedRatios", value: function() {
      var t8, e4, i17, a10 = this, s11 = this.w, r13 = s11.globals, o10 = [], n11 = 0, l8 = [], h4 = 0.1, c7 = 0;
      if (r13.yRange = [], r13.isMultipleYAxis)
        for (var d9 = 0; d9 < r13.minYArr.length; d9++)
          r13.yRange.push(Math.abs(r13.minYArr[d9] - r13.maxYArr[d9])), l8.push(0);
      else
        r13.yRange.push(Math.abs(r13.minY - r13.maxY));
      r13.xRange = Math.abs(r13.maxX - r13.minX), r13.zRange = Math.abs(r13.maxZ - r13.minZ);
      for (var g7 = 0; g7 < r13.yRange.length; g7++)
        o10.push(r13.yRange[g7] / r13.gridHeight);
      if (e4 = r13.xRange / r13.gridWidth, t8 = r13.yRange / r13.gridWidth, i17 = r13.xRange / r13.gridHeight, (n11 = r13.zRange / r13.gridHeight * 16) || (n11 = 1), r13.minY !== Number.MIN_VALUE && 0 !== Math.abs(r13.minY) && (r13.hasNegs = true), s11.globals.seriesYAxisReverseMap.length > 0) {
        var u6 = function(t9, e5) {
          var i18 = s11.config.yaxis[s11.globals.seriesYAxisReverseMap[e5]], r14 = t9 < 0 ? -1 : 1;
          return t9 = Math.abs(t9), i18.logarithmic && (t9 = a10.getBaseLog(i18.logBase, t9)), -r14 * t9 / o10[e5];
        };
        if (r13.isMultipleYAxis) {
          l8 = [];
          for (var p7 = 0; p7 < o10.length; p7++)
            l8.push(u6(r13.minYArr[p7], p7));
        } else
          (l8 = []).push(u6(r13.minY, 0)), r13.minY !== Number.MIN_VALUE && 0 !== Math.abs(r13.minY) && (h4 = -r13.minY / t8, c7 = r13.minX / e4);
      } else
        (l8 = []).push(0), h4 = 0, c7 = 0;
      return { yRatio: o10, invertedYRatio: t8, zRatio: n11, xRatio: e4, invertedXRatio: i17, baseLineInvertedY: h4, baseLineY: l8, baseLineX: c7 };
    } }, { key: "getLogSeries", value: function(t8) {
      var e4 = this, i17 = this.w;
      return i17.globals.seriesLog = t8.map(function(t9, a10) {
        var s11 = i17.globals.seriesYAxisReverseMap[a10];
        return i17.config.yaxis[s11] && i17.config.yaxis[s11].logarithmic ? t9.map(function(t10) {
          return null === t10 ? null : e4.getLogVal(i17.config.yaxis[s11].logBase, t10, a10);
        }) : t9;
      }), i17.globals.invalidLogScale ? t8 : i17.globals.seriesLog;
    } }, { key: "getBaseLog", value: function(t8, e4) {
      return Math.log(e4) / Math.log(t8);
    } }, { key: "getLogVal", value: function(t8, e4, i17) {
      if (e4 <= 0)
        return 0;
      var a10 = this.w, s11 = 0 === a10.globals.minYArr[i17] ? -1 : this.getBaseLog(t8, a10.globals.minYArr[i17]), r13 = (0 === a10.globals.maxYArr[i17] ? 0 : this.getBaseLog(t8, a10.globals.maxYArr[i17])) - s11;
      return e4 < 1 ? e4 / r13 : (this.getBaseLog(t8, e4) - s11) / r13;
    } }, { key: "getLogYRatios", value: function(t8) {
      var e4 = this, i17 = this.w, a10 = this.w.globals;
      return a10.yLogRatio = t8.slice(), a10.logYRange = a10.yRange.map(function(t9, s11) {
        var r13 = i17.globals.seriesYAxisReverseMap[s11];
        if (i17.config.yaxis[r13] && e4.w.config.yaxis[r13].logarithmic) {
          var o10, n11 = -Number.MAX_VALUE, l8 = Number.MIN_VALUE;
          return a10.seriesLog.forEach(function(t10, e5) {
            t10.forEach(function(t11) {
              i17.config.yaxis[e5] && i17.config.yaxis[e5].logarithmic && (n11 = Math.max(t11, n11), l8 = Math.min(t11, l8));
            });
          }), o10 = Math.pow(a10.yRange[s11], Math.abs(l8 - n11) / a10.yRange[s11]), a10.yLogRatio[s11] = o10 / a10.gridHeight, o10;
        }
      }), a10.invalidLogScale ? t8.slice() : a10.yLogRatio;
    } }, { key: "drawSeriesByGroup", value: function(t8, e4, i17, a10) {
      var s11 = this.w, r13 = [];
      return t8.series.length > 0 && e4.forEach(function(e5) {
        var o10 = [], n11 = [];
        t8.i.forEach(function(i18, a11) {
          s11.config.series[i18].group === e5 && (o10.push(t8.series[a11]), n11.push(i18));
        }), o10.length > 0 && r13.push(a10.draw(o10, i17, n11));
      }), r13;
    } }], [{ key: "checkComboSeries", value: function(t8, e4) {
      var i17 = false, a10 = 0, s11 = 0;
      return void 0 === e4 && (e4 = "line"), t8.length && void 0 !== t8[0].type && t8.forEach(function(t9) {
        "bar" !== t9.type && "column" !== t9.type && "candlestick" !== t9.type && "boxPlot" !== t9.type || a10++, void 0 !== t9.type && t9.type !== e4 && s11++;
      }), s11 > 0 && (i17 = true), { comboBarCount: a10, comboCharts: i17 };
    } }, { key: "extendArrayProps", value: function(t8, e4, i17) {
      var a10, s11, r13, o10, n11, l8;
      (null !== (a10 = e4) && void 0 !== a10 && a10.yaxis && (e4 = t8.extendYAxis(e4, i17)), null !== (s11 = e4) && void 0 !== s11 && s11.annotations) && (e4.annotations.yaxis && (e4 = t8.extendYAxisAnnotations(e4)), null !== (r13 = e4) && void 0 !== r13 && null !== (o10 = r13.annotations) && void 0 !== o10 && o10.xaxis && (e4 = t8.extendXAxisAnnotations(e4)), null !== (n11 = e4) && void 0 !== n11 && null !== (l8 = n11.annotations) && void 0 !== l8 && l8.points && (e4 = t8.extendPointAnnotations(e4)));
      return e4;
    } }]), t7;
  }(), w3 = function() {
    function t7(e4) {
      a9(this, t7), this.w = e4.w, this.annoCtx = e4;
    }
    return r12(t7, [{ key: "setOrientations", value: function(t8) {
      var e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, i17 = this.w;
      if ("vertical" === t8.label.orientation) {
        var a10 = null !== e4 ? e4 : 0, s11 = i17.globals.dom.baseEl.querySelector(".apexcharts-xaxis-annotations .apexcharts-xaxis-annotation-label[rel='".concat(a10, "']"));
        if (null !== s11) {
          var r13 = s11.getBoundingClientRect();
          s11.setAttribute("x", parseFloat(s11.getAttribute("x")) - r13.height + 4), "top" === t8.label.position ? s11.setAttribute("y", parseFloat(s11.getAttribute("y")) + r13.width) : s11.setAttribute("y", parseFloat(s11.getAttribute("y")) - r13.width);
          var o10 = this.annoCtx.graphics.rotateAroundCenter(s11), n11 = o10.x, l8 = o10.y;
          s11.setAttribute("transform", "rotate(-90 ".concat(n11, " ").concat(l8, ")"));
        }
      }
    } }, { key: "addBackgroundToAnno", value: function(t8, e4) {
      var i17 = this.w;
      if (!t8 || void 0 === e4.label.text || void 0 !== e4.label.text && !String(e4.label.text).trim())
        return null;
      var a10 = i17.globals.dom.baseEl.querySelector(".apexcharts-grid").getBoundingClientRect(), s11 = t8.getBoundingClientRect(), r13 = e4.label.style.padding.left, o10 = e4.label.style.padding.right, n11 = e4.label.style.padding.top, l8 = e4.label.style.padding.bottom;
      "vertical" === e4.label.orientation && (n11 = e4.label.style.padding.left, l8 = e4.label.style.padding.right, r13 = e4.label.style.padding.top, o10 = e4.label.style.padding.bottom);
      var h4 = s11.left - a10.left - r13, c7 = s11.top - a10.top - n11, d9 = this.annoCtx.graphics.drawRect(h4 - i17.globals.barPadForNumericAxis, c7, s11.width + r13 + o10, s11.height + n11 + l8, e4.label.borderRadius, e4.label.style.background, 1, e4.label.borderWidth, e4.label.borderColor, 0);
      return e4.id && d9.node.classList.add(e4.id), d9;
    } }, { key: "annotationsBackground", value: function() {
      var t8 = this, e4 = this.w, i17 = function(i18, a10, s11) {
        var r13 = e4.globals.dom.baseEl.querySelector(".apexcharts-".concat(s11, "-annotations .apexcharts-").concat(s11, "-annotation-label[rel='").concat(a10, "']"));
        if (r13) {
          var o10 = r13.parentNode, n11 = t8.addBackgroundToAnno(r13, i18);
          n11 && (o10.insertBefore(n11.node, r13), i18.label.mouseEnter && n11.node.addEventListener("mouseenter", i18.label.mouseEnter.bind(t8, i18)), i18.label.mouseLeave && n11.node.addEventListener("mouseleave", i18.label.mouseLeave.bind(t8, i18)), i18.label.click && n11.node.addEventListener("click", i18.label.click.bind(t8, i18)));
        }
      };
      e4.config.annotations.xaxis.map(function(t9, e5) {
        i17(t9, e5, "xaxis");
      }), e4.config.annotations.yaxis.map(function(t9, e5) {
        i17(t9, e5, "yaxis");
      }), e4.config.annotations.points.map(function(t9, e5) {
        i17(t9, e5, "point");
      });
    } }, { key: "getY1Y2", value: function(t8, e4) {
      var i17, a10 = "y1" === t8 ? e4.y : e4.y2, s11 = false, r13 = this.w;
      if (this.annoCtx.invertAxis) {
        var o10 = r13.globals.labels;
        r13.config.xaxis.convertedCatToNumeric && (o10 = r13.globals.categoryLabels);
        var n11 = o10.indexOf(a10), l8 = r13.globals.dom.baseEl.querySelector(".apexcharts-yaxis-texts-g text:nth-child(" + (n11 + 1) + ")");
        i17 = l8 ? parseFloat(l8.getAttribute("y")) : (r13.globals.gridHeight / o10.length - 1) * (n11 + 1) - r13.globals.barHeight, void 0 !== e4.seriesIndex && r13.globals.barHeight && (i17 = i17 - r13.globals.barHeight / 2 * (r13.globals.series.length - 1) + r13.globals.barHeight * e4.seriesIndex);
      } else {
        var h4, c7 = r13.globals.seriesYAxisMap[e4.yAxisIndex][0];
        if (r13.config.yaxis[e4.yAxisIndex].logarithmic)
          h4 = (a10 = new y4(this.annoCtx.ctx).getLogVal(r13.config.yaxis[e4.yAxisIndex].logBase, a10, c7)) / r13.globals.yLogRatio[c7];
        else
          h4 = (a10 - r13.globals.minYArr[c7]) / (r13.globals.yRange[c7] / r13.globals.gridHeight);
        h4 > r13.globals.gridHeight ? (h4 = r13.globals.gridHeight, s11 = true) : h4 < 0 && (h4 = 0, s11 = true), i17 = r13.globals.gridHeight - h4, !e4.marker || void 0 !== e4.y && null !== e4.y || (i17 = 0), r13.config.yaxis[e4.yAxisIndex] && r13.config.yaxis[e4.yAxisIndex].reversed && (i17 = h4);
      }
      return "string" == typeof a10 && a10.indexOf("px") > -1 && (i17 = parseFloat(a10)), { yP: i17, clipped: s11 };
    } }, { key: "getX1X2", value: function(t8, e4) {
      var i17, a10 = "x1" === t8 ? e4.x : e4.x2, s11 = this.w, r13 = this.annoCtx.invertAxis ? s11.globals.minY : s11.globals.minX, o10 = this.annoCtx.invertAxis ? s11.globals.maxY : s11.globals.maxX, n11 = this.annoCtx.invertAxis ? s11.globals.yRange[0] : s11.globals.xRange, l8 = false;
      return i17 = this.annoCtx.inversedReversedAxis ? (o10 - a10) / (n11 / s11.globals.gridWidth) : (a10 - r13) / (n11 / s11.globals.gridWidth), "category" !== s11.config.xaxis.type && !s11.config.xaxis.convertedCatToNumeric || this.annoCtx.invertAxis || s11.globals.dataFormatXNumeric || s11.config.chart.sparkline.enabled || (i17 = this.getStringX(a10)), "string" == typeof a10 && a10.indexOf("px") > -1 && (i17 = parseFloat(a10)), null == a10 && e4.marker && (i17 = s11.globals.gridWidth), void 0 !== e4.seriesIndex && s11.globals.barWidth && !this.annoCtx.invertAxis && (i17 = i17 - s11.globals.barWidth / 2 * (s11.globals.series.length - 1) + s11.globals.barWidth * e4.seriesIndex), i17 > s11.globals.gridWidth ? (i17 = s11.globals.gridWidth, l8 = true) : i17 < 0 && (i17 = 0, l8 = true), { x: i17, clipped: l8 };
    } }, { key: "getStringX", value: function(t8) {
      var e4 = this.w, i17 = t8;
      e4.config.xaxis.convertedCatToNumeric && e4.globals.categoryLabels.length && (t8 = e4.globals.categoryLabels.indexOf(t8) + 1);
      var a10 = e4.globals.labels.indexOf(t8), s11 = e4.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g text:nth-child(" + (a10 + 1) + ")");
      return s11 && (i17 = parseFloat(s11.getAttribute("x"))), i17;
    } }]), t7;
  }(), k3 = function() {
    function t7(e4) {
      a9(this, t7), this.w = e4.w, this.annoCtx = e4, this.invertAxis = this.annoCtx.invertAxis, this.helpers = new w3(this.annoCtx);
    }
    return r12(t7, [{ key: "addXaxisAnnotation", value: function(t8, e4, i17) {
      var a10, s11 = this.w, r13 = this.helpers.getX1X2("x1", t8), o10 = r13.x, n11 = r13.clipped, l8 = true, h4 = t8.label.text, c7 = t8.strokeDashArray;
      if (x3.isNumber(o10)) {
        if (null === t8.x2 || void 0 === t8.x2) {
          if (!n11) {
            var d9 = this.annoCtx.graphics.drawLine(o10 + t8.offsetX, 0 + t8.offsetY, o10 + t8.offsetX, s11.globals.gridHeight + t8.offsetY, t8.borderColor, c7, t8.borderWidth);
            e4.appendChild(d9.node), t8.id && d9.node.classList.add(t8.id);
          }
        } else {
          var g7 = this.helpers.getX1X2("x2", t8);
          if (a10 = g7.x, l8 = g7.clipped, !n11 || !l8) {
            if (a10 < o10) {
              var u6 = o10;
              o10 = a10, a10 = u6;
            }
            var p7 = this.annoCtx.graphics.drawRect(o10 + t8.offsetX, 0 + t8.offsetY, a10 - o10, s11.globals.gridHeight + t8.offsetY, 0, t8.fillColor, t8.opacity, 1, t8.borderColor, c7);
            p7.node.classList.add("apexcharts-annotation-rect"), p7.attr("clip-path", "url(#gridRectMask".concat(s11.globals.cuid, ")")), e4.appendChild(p7.node), t8.id && p7.node.classList.add(t8.id);
          }
        }
        if (!n11 || !l8) {
          var f5 = this.annoCtx.graphics.getTextRects(h4, parseFloat(t8.label.style.fontSize)), b3 = "top" === t8.label.position ? 4 : "center" === t8.label.position ? s11.globals.gridHeight / 2 + ("vertical" === t8.label.orientation ? f5.width / 2 : 0) : s11.globals.gridHeight, v5 = this.annoCtx.graphics.drawText({ x: o10 + t8.label.offsetX, y: b3 + t8.label.offsetY - ("vertical" === t8.label.orientation ? "top" === t8.label.position ? f5.width / 2 - 12 : -f5.width / 2 : 0), text: h4, textAnchor: t8.label.textAnchor, fontSize: t8.label.style.fontSize, fontFamily: t8.label.style.fontFamily, fontWeight: t8.label.style.fontWeight, foreColor: t8.label.style.color, cssClass: "apexcharts-xaxis-annotation-label ".concat(t8.label.style.cssClass, " ").concat(t8.id ? t8.id : "") });
          v5.attr({ rel: i17 }), e4.appendChild(v5.node), this.annoCtx.helpers.setOrientations(t8, i17);
        }
      }
    } }, { key: "drawXAxisAnnotations", value: function() {
      var t8 = this, e4 = this.w, i17 = this.annoCtx.graphics.group({ class: "apexcharts-xaxis-annotations" });
      return e4.config.annotations.xaxis.map(function(e5, a10) {
        t8.addXaxisAnnotation(e5, i17.node, a10);
      }), i17;
    } }]), t7;
  }(), A2 = function() {
    function t7(e4) {
      a9(this, t7), this.ctx = e4, this.w = e4.w, this.months31 = [1, 3, 5, 7, 8, 10, 12], this.months30 = [2, 4, 6, 9, 11], this.daysCntOfYear = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
    }
    return r12(t7, [{ key: "isValidDate", value: function(t8) {
      return "number" != typeof t8 && !isNaN(this.parseDate(t8));
    } }, { key: "getTimeStamp", value: function(t8) {
      return Date.parse(t8) ? this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(t8).toISOString().substr(0, 25)).getTime() : new Date(t8).getTime() : t8;
    } }, { key: "getDate", value: function(t8) {
      return this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(t8).toUTCString()) : new Date(t8);
    } }, { key: "parseDate", value: function(t8) {
      var e4 = Date.parse(t8);
      if (!isNaN(e4))
        return this.getTimeStamp(t8);
      var i17 = Date.parse(t8.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
      return i17 = this.getTimeStamp(i17);
    } }, { key: "parseDateWithTimezone", value: function(t8) {
      return Date.parse(t8.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
    } }, { key: "formatDate", value: function(t8, e4) {
      var i17 = this.w.globals.locale, a10 = this.w.config.xaxis.labels.datetimeUTC, s11 = ["\0"].concat(u5(i17.months)), r13 = [""].concat(u5(i17.shortMonths)), o10 = [""].concat(u5(i17.days)), n11 = [""].concat(u5(i17.shortDays));
      function l8(t9, e5) {
        var i18 = t9 + "";
        for (e5 = e5 || 2; i18.length < e5; )
          i18 = "0" + i18;
        return i18;
      }
      var h4 = a10 ? t8.getUTCFullYear() : t8.getFullYear();
      e4 = (e4 = (e4 = e4.replace(/(^|[^\\])yyyy+/g, "$1" + h4)).replace(/(^|[^\\])yy/g, "$1" + h4.toString().substr(2, 2))).replace(/(^|[^\\])y/g, "$1" + h4);
      var c7 = (a10 ? t8.getUTCMonth() : t8.getMonth()) + 1;
      e4 = (e4 = (e4 = (e4 = e4.replace(/(^|[^\\])MMMM+/g, "$1" + s11[0])).replace(/(^|[^\\])MMM/g, "$1" + r13[0])).replace(/(^|[^\\])MM/g, "$1" + l8(c7))).replace(/(^|[^\\])M/g, "$1" + c7);
      var d9 = a10 ? t8.getUTCDate() : t8.getDate();
      e4 = (e4 = (e4 = (e4 = e4.replace(/(^|[^\\])dddd+/g, "$1" + o10[0])).replace(/(^|[^\\])ddd/g, "$1" + n11[0])).replace(/(^|[^\\])dd/g, "$1" + l8(d9))).replace(/(^|[^\\])d/g, "$1" + d9);
      var g7 = a10 ? t8.getUTCHours() : t8.getHours(), p7 = g7 > 12 ? g7 - 12 : 0 === g7 ? 12 : g7;
      e4 = (e4 = (e4 = (e4 = e4.replace(/(^|[^\\])HH+/g, "$1" + l8(g7))).replace(/(^|[^\\])H/g, "$1" + g7)).replace(/(^|[^\\])hh+/g, "$1" + l8(p7))).replace(/(^|[^\\])h/g, "$1" + p7);
      var f5 = a10 ? t8.getUTCMinutes() : t8.getMinutes();
      e4 = (e4 = e4.replace(/(^|[^\\])mm+/g, "$1" + l8(f5))).replace(/(^|[^\\])m/g, "$1" + f5);
      var x4 = a10 ? t8.getUTCSeconds() : t8.getSeconds();
      e4 = (e4 = e4.replace(/(^|[^\\])ss+/g, "$1" + l8(x4))).replace(/(^|[^\\])s/g, "$1" + x4);
      var b3 = a10 ? t8.getUTCMilliseconds() : t8.getMilliseconds();
      e4 = e4.replace(/(^|[^\\])fff+/g, "$1" + l8(b3, 3)), b3 = Math.round(b3 / 10), e4 = e4.replace(/(^|[^\\])ff/g, "$1" + l8(b3)), b3 = Math.round(b3 / 10);
      var v5 = g7 < 12 ? "AM" : "PM";
      e4 = (e4 = (e4 = e4.replace(/(^|[^\\])f/g, "$1" + b3)).replace(/(^|[^\\])TT+/g, "$1" + v5)).replace(/(^|[^\\])T/g, "$1" + v5.charAt(0));
      var m4 = v5.toLowerCase();
      e4 = (e4 = e4.replace(/(^|[^\\])tt+/g, "$1" + m4)).replace(/(^|[^\\])t/g, "$1" + m4.charAt(0));
      var y5 = -t8.getTimezoneOffset(), w4 = a10 || !y5 ? "Z" : y5 > 0 ? "+" : "-";
      if (!a10) {
        var k4 = (y5 = Math.abs(y5)) % 60;
        w4 += l8(Math.floor(y5 / 60)) + ":" + l8(k4);
      }
      e4 = e4.replace(/(^|[^\\])K/g, "$1" + w4);
      var A3 = (a10 ? t8.getUTCDay() : t8.getDay()) + 1;
      return e4 = (e4 = (e4 = (e4 = (e4 = e4.replace(new RegExp(o10[0], "g"), o10[A3])).replace(new RegExp(n11[0], "g"), n11[A3])).replace(new RegExp(s11[0], "g"), s11[c7])).replace(new RegExp(r13[0], "g"), r13[c7])).replace(/\\(.)/g, "$1");
    } }, { key: "getTimeUnitsfromTimestamp", value: function(t8, e4, i17) {
      var a10 = this.w;
      void 0 !== a10.config.xaxis.min && (t8 = a10.config.xaxis.min), void 0 !== a10.config.xaxis.max && (e4 = a10.config.xaxis.max);
      var s11 = this.getDate(t8), r13 = this.getDate(e4), o10 = this.formatDate(s11, "yyyy MM dd HH mm ss fff").split(" "), n11 = this.formatDate(r13, "yyyy MM dd HH mm ss fff").split(" ");
      return { minMillisecond: parseInt(o10[6], 10), maxMillisecond: parseInt(n11[6], 10), minSecond: parseInt(o10[5], 10), maxSecond: parseInt(n11[5], 10), minMinute: parseInt(o10[4], 10), maxMinute: parseInt(n11[4], 10), minHour: parseInt(o10[3], 10), maxHour: parseInt(n11[3], 10), minDate: parseInt(o10[2], 10), maxDate: parseInt(n11[2], 10), minMonth: parseInt(o10[1], 10) - 1, maxMonth: parseInt(n11[1], 10) - 1, minYear: parseInt(o10[0], 10), maxYear: parseInt(n11[0], 10) };
    } }, { key: "isLeapYear", value: function(t8) {
      return t8 % 4 == 0 && t8 % 100 != 0 || t8 % 400 == 0;
    } }, { key: "calculcateLastDaysOfMonth", value: function(t8, e4, i17) {
      return this.determineDaysOfMonths(t8, e4) - i17;
    } }, { key: "determineDaysOfYear", value: function(t8) {
      var e4 = 365;
      return this.isLeapYear(t8) && (e4 = 366), e4;
    } }, { key: "determineRemainingDaysOfYear", value: function(t8, e4, i17) {
      var a10 = this.daysCntOfYear[e4] + i17;
      return e4 > 1 && this.isLeapYear() && a10++, a10;
    } }, { key: "determineDaysOfMonths", value: function(t8, e4) {
      var i17 = 30;
      switch (t8 = x3.monthMod(t8), true) {
        case this.months30.indexOf(t8) > -1:
          2 === t8 && (i17 = this.isLeapYear(e4) ? 29 : 28);
          break;
        case this.months31.indexOf(t8) > -1:
        default:
          i17 = 31;
      }
      return i17;
    } }]), t7;
  }(), S2 = function() {
    function t7(e4) {
      a9(this, t7), this.ctx = e4, this.w = e4.w, this.tooltipKeyFormat = "dd MMM";
    }
    return r12(t7, [{ key: "xLabelFormat", value: function(t8, e4, i17, a10) {
      var s11 = this.w;
      if ("datetime" === s11.config.xaxis.type && void 0 === s11.config.xaxis.labels.formatter && void 0 === s11.config.tooltip.x.formatter) {
        var r13 = new A2(this.ctx);
        return r13.formatDate(r13.getDate(e4), s11.config.tooltip.x.format);
      }
      return t8(e4, i17, a10);
    } }, { key: "defaultGeneralFormatter", value: function(t8) {
      return Array.isArray(t8) ? t8.map(function(t9) {
        return t9;
      }) : t8;
    } }, { key: "defaultYFormatter", value: function(t8, e4, i17) {
      var a10 = this.w;
      if (x3.isNumber(t8))
        if (0 !== a10.globals.yValueDecimal)
          t8 = t8.toFixed(void 0 !== e4.decimalsInFloat ? e4.decimalsInFloat : a10.globals.yValueDecimal);
        else {
          var s11 = t8.toFixed(0);
          t8 = t8 == s11 ? s11 : t8.toFixed(1);
        }
      return t8;
    } }, { key: "setLabelFormatters", value: function() {
      var t8 = this, e4 = this.w;
      return e4.globals.xaxisTooltipFormatter = function(e5) {
        return t8.defaultGeneralFormatter(e5);
      }, e4.globals.ttKeyFormatter = function(e5) {
        return t8.defaultGeneralFormatter(e5);
      }, e4.globals.ttZFormatter = function(t9) {
        return t9;
      }, e4.globals.legendFormatter = function(e5) {
        return t8.defaultGeneralFormatter(e5);
      }, void 0 !== e4.config.xaxis.labels.formatter ? e4.globals.xLabelFormatter = e4.config.xaxis.labels.formatter : e4.globals.xLabelFormatter = function(t9) {
        if (x3.isNumber(t9)) {
          if (!e4.config.xaxis.convertedCatToNumeric && "numeric" === e4.config.xaxis.type) {
            if (x3.isNumber(e4.config.xaxis.decimalsInFloat))
              return t9.toFixed(e4.config.xaxis.decimalsInFloat);
            var i17 = e4.globals.maxX - e4.globals.minX;
            return i17 > 0 && i17 < 100 ? t9.toFixed(1) : t9.toFixed(0);
          }
          if (e4.globals.isBarHorizontal) {
            if (e4.globals.maxY - e4.globals.minYArr < 4)
              return t9.toFixed(1);
          }
          return t9.toFixed(0);
        }
        return t9;
      }, "function" == typeof e4.config.tooltip.x.formatter ? e4.globals.ttKeyFormatter = e4.config.tooltip.x.formatter : e4.globals.ttKeyFormatter = e4.globals.xLabelFormatter, "function" == typeof e4.config.xaxis.tooltip.formatter && (e4.globals.xaxisTooltipFormatter = e4.config.xaxis.tooltip.formatter), (Array.isArray(e4.config.tooltip.y) || void 0 !== e4.config.tooltip.y.formatter) && (e4.globals.ttVal = e4.config.tooltip.y), void 0 !== e4.config.tooltip.z.formatter && (e4.globals.ttZFormatter = e4.config.tooltip.z.formatter), void 0 !== e4.config.legend.formatter && (e4.globals.legendFormatter = e4.config.legend.formatter), e4.config.yaxis.forEach(function(i17, a10) {
        void 0 !== i17.labels.formatter ? e4.globals.yLabelFormatters[a10] = i17.labels.formatter : e4.globals.yLabelFormatters[a10] = function(s11) {
          return e4.globals.xyCharts ? Array.isArray(s11) ? s11.map(function(e5) {
            return t8.defaultYFormatter(e5, i17, a10);
          }) : t8.defaultYFormatter(s11, i17, a10) : s11;
        };
      }), e4.globals;
    } }, { key: "heatmapLabelFormatters", value: function() {
      var t8 = this.w;
      if ("heatmap" === t8.config.chart.type) {
        t8.globals.yAxisScale[0].result = t8.globals.seriesNames.slice();
        var e4 = t8.globals.seriesNames.reduce(function(t9, e5) {
          return t9.length > e5.length ? t9 : e5;
        }, 0);
        t8.globals.yAxisScale[0].niceMax = e4, t8.globals.yAxisScale[0].niceMin = e4;
      }
    } }]), t7;
  }(), C2 = function() {
    function t7(e4) {
      a9(this, t7), this.ctx = e4, this.w = e4.w;
    }
    return r12(t7, [{ key: "getLabel", value: function(t8, e4, i17, a10) {
      var s11 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : [], r13 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "12px", o10 = !(arguments.length > 6 && void 0 !== arguments[6]) || arguments[6], n11 = this.w, l8 = void 0 === t8[a10] ? "" : t8[a10], h4 = l8, c7 = n11.globals.xLabelFormatter, d9 = n11.config.xaxis.labels.formatter, g7 = false, u6 = new S2(this.ctx), p7 = l8;
      o10 && (h4 = u6.xLabelFormat(c7, l8, p7, { i: a10, dateFormatter: new A2(this.ctx).formatDate, w: n11 }), void 0 !== d9 && (h4 = d9(l8, t8[a10], { i: a10, dateFormatter: new A2(this.ctx).formatDate, w: n11 })));
      var f5, x4;
      e4.length > 0 ? (f5 = e4[a10].unit, x4 = null, e4.forEach(function(t9) {
        "month" === t9.unit ? x4 = "year" : "day" === t9.unit ? x4 = "month" : "hour" === t9.unit ? x4 = "day" : "minute" === t9.unit && (x4 = "hour");
      }), g7 = x4 === f5, i17 = e4[a10].position, h4 = e4[a10].value) : "datetime" === n11.config.xaxis.type && void 0 === d9 && (h4 = ""), void 0 === h4 && (h4 = ""), h4 = Array.isArray(h4) ? h4 : h4.toString();
      var b3 = new m3(this.ctx), v5 = {};
      v5 = n11.globals.rotateXLabels && o10 ? b3.getTextRects(h4, parseInt(r13, 10), null, "rotate(".concat(n11.config.xaxis.labels.rotate, " 0 0)"), false) : b3.getTextRects(h4, parseInt(r13, 10));
      var y5 = !n11.config.xaxis.labels.showDuplicates && this.ctx.timeScale;
      return !Array.isArray(h4) && ("NaN" === String(h4) || s11.indexOf(h4) >= 0 && y5) && (h4 = ""), { x: i17, text: h4, textRect: v5, isBold: g7 };
    } }, { key: "checkLabelBasedOnTickamount", value: function(t8, e4, i17) {
      var a10 = this.w, s11 = a10.config.xaxis.tickAmount;
      return "dataPoints" === s11 && (s11 = Math.round(a10.globals.gridWidth / 120)), s11 > i17 || t8 % Math.round(i17 / (s11 + 1)) == 0 || (e4.text = ""), e4;
    } }, { key: "checkForOverflowingLabels", value: function(t8, e4, i17, a10, s11) {
      var r13 = this.w;
      if (0 === t8 && r13.globals.skipFirstTimelinelabel && (e4.text = ""), t8 === i17 - 1 && r13.globals.skipLastTimelinelabel && (e4.text = ""), r13.config.xaxis.labels.hideOverlappingLabels && a10.length > 0) {
        var o10 = s11[s11.length - 1];
        e4.x < o10.textRect.width / (r13.globals.rotateXLabels ? Math.abs(r13.config.xaxis.labels.rotate) / 12 : 1.01) + o10.x && (e4.text = "");
      }
      return e4;
    } }, { key: "checkForReversedLabels", value: function(t8, e4) {
      var i17 = this.w;
      return i17.config.yaxis[t8] && i17.config.yaxis[t8].reversed && e4.reverse(), e4;
    } }, { key: "yAxisAllSeriesCollapsed", value: function(t8) {
      var e4 = this.w.globals;
      return !e4.seriesYAxisMap[t8].some(function(t9) {
        return -1 === e4.collapsedSeriesIndices.indexOf(t9);
      });
    } }, { key: "translateYAxisIndex", value: function(t8) {
      var e4 = this.w, i17 = e4.globals, a10 = e4.config.yaxis;
      return i17.series.length > a10.length || a10.some(function(t9) {
        return Array.isArray(t9.seriesName);
      }) ? t8 : i17.seriesYAxisReverseMap[t8];
    } }, { key: "isYAxisHidden", value: function(t8) {
      var e4 = this.w, i17 = e4.config.yaxis[t8];
      if (!i17.show || this.yAxisAllSeriesCollapsed(t8))
        return true;
      if (!i17.showForNullSeries) {
        var a10 = e4.globals.seriesYAxisMap[t8], s11 = new y4(this.ctx);
        return a10.every(function(t9) {
          return s11.isSeriesNull(t9);
        });
      }
      return false;
    } }, { key: "getYAxisForeColor", value: function(t8, e4) {
      var i17 = this.w;
      return Array.isArray(t8) && i17.globals.yAxisScale[e4] && this.ctx.theme.pushExtraColors(t8, i17.globals.yAxisScale[e4].result.length, false), t8;
    } }, { key: "drawYAxisTicks", value: function(t8, e4, i17, a10, s11, r13, o10) {
      var n11 = this.w, l8 = new m3(this.ctx), h4 = n11.globals.translateY + n11.config.yaxis[s11].labels.offsetY;
      if (n11.globals.isBarHorizontal ? h4 = 0 : "heatmap" === n11.config.chart.type && (h4 += r13 / 2), a10.show && e4 > 0) {
        true === n11.config.yaxis[s11].opposite && (t8 += a10.width);
        for (var c7 = e4; c7 >= 0; c7--) {
          var d9 = l8.drawLine(t8 + i17.offsetX - a10.width + a10.offsetX, h4 + a10.offsetY, t8 + i17.offsetX + a10.offsetX, h4 + a10.offsetY, a10.color);
          o10.add(d9), h4 += r13;
        }
      }
    } }]), t7;
  }(), L3 = function() {
    function t7(e4) {
      a9(this, t7), this.w = e4.w, this.annoCtx = e4, this.helpers = new w3(this.annoCtx), this.axesUtils = new C2(this.annoCtx);
    }
    return r12(t7, [{ key: "addYaxisAnnotation", value: function(t8, e4, i17) {
      var a10, s11 = this.w, r13 = t8.strokeDashArray, o10 = this.helpers.getY1Y2("y1", t8), n11 = o10.yP, l8 = o10.clipped, h4 = true, c7 = false, d9 = t8.label.text;
      if (null === t8.y2 || void 0 === t8.y2) {
        if (!l8) {
          c7 = true;
          var g7 = this.annoCtx.graphics.drawLine(0 + t8.offsetX, n11 + t8.offsetY, this._getYAxisAnnotationWidth(t8), n11 + t8.offsetY, t8.borderColor, r13, t8.borderWidth);
          e4.appendChild(g7.node), t8.id && g7.node.classList.add(t8.id);
        }
      } else {
        if (a10 = (o10 = this.helpers.getY1Y2("y2", t8)).yP, h4 = o10.clipped, a10 > n11) {
          var u6 = n11;
          n11 = a10, a10 = u6;
        }
        if (!l8 || !h4) {
          c7 = true;
          var p7 = this.annoCtx.graphics.drawRect(0 + t8.offsetX, a10 + t8.offsetY, this._getYAxisAnnotationWidth(t8), n11 - a10, 0, t8.fillColor, t8.opacity, 1, t8.borderColor, r13);
          p7.node.classList.add("apexcharts-annotation-rect"), p7.attr("clip-path", "url(#gridRectMask".concat(s11.globals.cuid, ")")), e4.appendChild(p7.node), t8.id && p7.node.classList.add(t8.id);
        }
      }
      if (c7) {
        var f5 = "right" === t8.label.position ? s11.globals.gridWidth : "center" === t8.label.position ? s11.globals.gridWidth / 2 : 0, x4 = this.annoCtx.graphics.drawText({ x: f5 + t8.label.offsetX, y: (null != a10 ? a10 : n11) + t8.label.offsetY - 3, text: d9, textAnchor: t8.label.textAnchor, fontSize: t8.label.style.fontSize, fontFamily: t8.label.style.fontFamily, fontWeight: t8.label.style.fontWeight, foreColor: t8.label.style.color, cssClass: "apexcharts-yaxis-annotation-label ".concat(t8.label.style.cssClass, " ").concat(t8.id ? t8.id : "") });
        x4.attr({ rel: i17 }), e4.appendChild(x4.node);
      }
    } }, { key: "_getYAxisAnnotationWidth", value: function(t8) {
      var e4 = this.w;
      e4.globals.gridWidth;
      return (t8.width.indexOf("%") > -1 ? e4.globals.gridWidth * parseInt(t8.width, 10) / 100 : parseInt(t8.width, 10)) + t8.offsetX;
    } }, { key: "drawYAxisAnnotations", value: function() {
      var t8 = this, e4 = this.w, i17 = this.annoCtx.graphics.group({ class: "apexcharts-yaxis-annotations" });
      return e4.config.annotations.yaxis.forEach(function(e5, a10) {
        e5.yAxisIndex = t8.axesUtils.translateYAxisIndex(e5.yAxisIndex), t8.axesUtils.isYAxisHidden(e5.yAxisIndex) && t8.axesUtils.yAxisAllSeriesCollapsed(e5.yAxisIndex) || t8.addYaxisAnnotation(e5, i17.node, a10);
      }), i17;
    } }]), t7;
  }(), P2 = function() {
    function t7(e4) {
      a9(this, t7), this.w = e4.w, this.annoCtx = e4, this.helpers = new w3(this.annoCtx);
    }
    return r12(t7, [{ key: "addPointAnnotation", value: function(t8, e4, i17) {
      if (!(this.w.globals.collapsedSeriesIndices.indexOf(t8.seriesIndex) > -1)) {
        var a10 = this.helpers.getX1X2("x1", t8), s11 = a10.x, r13 = a10.clipped, o10 = (a10 = this.helpers.getY1Y2("y1", t8)).yP, n11 = a10.clipped;
        if (x3.isNumber(s11) && !n11 && !r13) {
          var l8 = { pSize: t8.marker.size, pointStrokeWidth: t8.marker.strokeWidth, pointFillColor: t8.marker.fillColor, pointStrokeColor: t8.marker.strokeColor, shape: t8.marker.shape, pRadius: t8.marker.radius, class: "apexcharts-point-annotation-marker ".concat(t8.marker.cssClass, " ").concat(t8.id ? t8.id : "") }, h4 = this.annoCtx.graphics.drawMarker(s11 + t8.marker.offsetX, o10 + t8.marker.offsetY, l8);
          e4.appendChild(h4.node);
          var c7 = t8.label.text ? t8.label.text : "", d9 = this.annoCtx.graphics.drawText({ x: s11 + t8.label.offsetX, y: o10 + t8.label.offsetY - t8.marker.size - parseFloat(t8.label.style.fontSize) / 1.6, text: c7, textAnchor: t8.label.textAnchor, fontSize: t8.label.style.fontSize, fontFamily: t8.label.style.fontFamily, fontWeight: t8.label.style.fontWeight, foreColor: t8.label.style.color, cssClass: "apexcharts-point-annotation-label ".concat(t8.label.style.cssClass, " ").concat(t8.id ? t8.id : "") });
          if (d9.attr({ rel: i17 }), e4.appendChild(d9.node), t8.customSVG.SVG) {
            var g7 = this.annoCtx.graphics.group({ class: "apexcharts-point-annotations-custom-svg " + t8.customSVG.cssClass });
            g7.attr({ transform: "translate(".concat(s11 + t8.customSVG.offsetX, ", ").concat(o10 + t8.customSVG.offsetY, ")") }), g7.node.innerHTML = t8.customSVG.SVG, e4.appendChild(g7.node);
          }
          if (t8.image.path) {
            var u6 = t8.image.width ? t8.image.width : 20, p7 = t8.image.height ? t8.image.height : 20;
            h4 = this.annoCtx.addImage({ x: s11 + t8.image.offsetX - u6 / 2, y: o10 + t8.image.offsetY - p7 / 2, width: u6, height: p7, path: t8.image.path, appendTo: ".apexcharts-point-annotations" });
          }
          t8.mouseEnter && h4.node.addEventListener("mouseenter", t8.mouseEnter.bind(this, t8)), t8.mouseLeave && h4.node.addEventListener("mouseleave", t8.mouseLeave.bind(this, t8)), t8.click && h4.node.addEventListener("click", t8.click.bind(this, t8));
        }
      }
    } }, { key: "drawPointAnnotations", value: function() {
      var t8 = this, e4 = this.w, i17 = this.annoCtx.graphics.group({ class: "apexcharts-point-annotations" });
      return e4.config.annotations.points.map(function(e5, a10) {
        t8.addPointAnnotation(e5, i17.node, a10);
      }), i17;
    } }]), t7;
  }();
  var M3 = { name: "en", options: { months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], toolbar: { exportToSVG: "Download SVG", exportToPNG: "Download PNG", exportToCSV: "Download CSV", menu: "Menu", selection: "Selection", selectionZoom: "Selection Zoom", zoomIn: "Zoom In", zoomOut: "Zoom Out", pan: "Panning", reset: "Reset Zoom" } } }, I3 = function() {
    function t7() {
      a9(this, t7), this.yAxis = { show: true, showAlways: false, showForNullSeries: true, seriesName: void 0, opposite: false, reversed: false, logarithmic: false, logBase: 10, tickAmount: void 0, stepSize: void 0, forceNiceScale: false, max: void 0, min: void 0, floating: false, decimalsInFloat: void 0, labels: { show: true, minWidth: 0, maxWidth: 160, offsetX: 0, offsetY: 0, align: void 0, rotate: 0, padding: 20, style: { colors: [], fontSize: "11px", fontWeight: 400, fontFamily: void 0, cssClass: "" }, formatter: void 0 }, axisBorder: { show: false, color: "#e0e0e0", width: 1, offsetX: 0, offsetY: 0 }, axisTicks: { show: false, color: "#e0e0e0", width: 6, offsetX: 0, offsetY: 0 }, title: { text: void 0, rotate: -90, offsetY: 0, offsetX: 0, style: { color: void 0, fontSize: "11px", fontWeight: 900, fontFamily: void 0, cssClass: "" } }, tooltip: { enabled: false, offsetX: 0 }, crosshairs: { show: true, position: "front", stroke: { color: "#b6b6b6", width: 1, dashArray: 0 } } }, this.pointAnnotation = { id: void 0, x: 0, y: null, yAxisIndex: 0, seriesIndex: void 0, mouseEnter: void 0, mouseLeave: void 0, click: void 0, marker: { size: 4, fillColor: "#fff", strokeWidth: 2, strokeColor: "#333", shape: "circle", offsetX: 0, offsetY: 0, cssClass: "" }, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: "middle", offsetX: 0, offsetY: 0, mouseEnter: void 0, mouseLeave: void 0, click: void 0, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } }, customSVG: { SVG: void 0, cssClass: void 0, offsetX: 0, offsetY: 0 }, image: { path: void 0, width: 20, height: 20, offsetX: 0, offsetY: 0 } }, this.yAxisAnnotation = { id: void 0, y: 0, y2: null, strokeDashArray: 1, fillColor: "#c2c2c2", borderColor: "#c2c2c2", borderWidth: 1, opacity: 0.3, offsetX: 0, offsetY: 0, width: "100%", yAxisIndex: 0, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: "end", position: "right", offsetX: 0, offsetY: -3, mouseEnter: void 0, mouseLeave: void 0, click: void 0, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } } }, this.xAxisAnnotation = { id: void 0, x: 0, x2: null, strokeDashArray: 1, fillColor: "#c2c2c2", borderColor: "#c2c2c2", borderWidth: 1, opacity: 0.3, offsetX: 0, offsetY: 0, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: "middle", orientation: "vertical", position: "top", offsetX: 0, offsetY: 0, mouseEnter: void 0, mouseLeave: void 0, click: void 0, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } } }, this.text = { x: 0, y: 0, text: "", textAnchor: "start", foreColor: void 0, fontSize: "13px", fontFamily: void 0, fontWeight: 400, appendTo: ".apexcharts-annotations", backgroundColor: "transparent", borderColor: "#c2c2c2", borderRadius: 0, borderWidth: 0, paddingLeft: 4, paddingRight: 4, paddingTop: 2, paddingBottom: 2 };
    }
    return r12(t7, [{ key: "init", value: function() {
      return { annotations: { yaxis: [this.yAxisAnnotation], xaxis: [this.xAxisAnnotation], points: [this.pointAnnotation], texts: [], images: [], shapes: [] }, chart: { animations: { enabled: true, easing: "easeinout", speed: 800, animateGradually: { delay: 150, enabled: true }, dynamicAnimation: { enabled: true, speed: 350 } }, background: "", locales: [M3], defaultLocale: "en", dropShadow: { enabled: false, enabledOnSeries: void 0, top: 2, left: 2, blur: 4, color: "#000", opacity: 0.35 }, events: { animationEnd: void 0, beforeMount: void 0, mounted: void 0, updated: void 0, click: void 0, mouseMove: void 0, mouseLeave: void 0, xAxisLabelClick: void 0, legendClick: void 0, markerClick: void 0, selection: void 0, dataPointSelection: void 0, dataPointMouseEnter: void 0, dataPointMouseLeave: void 0, beforeZoom: void 0, beforeResetZoom: void 0, zoomed: void 0, scrolled: void 0, brushScrolled: void 0 }, foreColor: "#373d3f", fontFamily: "Helvetica, Arial, sans-serif", height: "auto", parentHeightOffset: 15, redrawOnParentResize: true, redrawOnWindowResize: true, id: void 0, group: void 0, nonce: void 0, offsetX: 0, offsetY: 0, selection: { enabled: false, type: "x", fill: { color: "#24292e", opacity: 0.1 }, stroke: { width: 1, color: "#24292e", opacity: 0.4, dashArray: 3 }, xaxis: { min: void 0, max: void 0 }, yaxis: { min: void 0, max: void 0 } }, sparkline: { enabled: false }, brush: { enabled: false, autoScaleYaxis: true, target: void 0, targets: void 0 }, stacked: false, stackOnlyBar: true, stackType: "normal", toolbar: { show: true, offsetX: 0, offsetY: 0, tools: { download: true, selection: true, zoom: true, zoomin: true, zoomout: true, pan: true, reset: true, customIcons: [] }, export: { csv: { filename: void 0, columnDelimiter: ",", headerCategory: "category", headerValue: "value", categoryFormatter: void 0, valueFormatter: void 0 }, png: { filename: void 0 }, svg: { filename: void 0 } }, autoSelected: "zoom" }, type: "line", width: "100%", zoom: { enabled: true, type: "x", autoScaleYaxis: false, zoomedArea: { fill: { color: "#90CAF9", opacity: 0.4 }, stroke: { color: "#0D47A1", opacity: 0.4, width: 1 } } } }, plotOptions: { line: { isSlopeChart: false }, area: { fillTo: "origin" }, bar: { horizontal: false, columnWidth: "70%", barHeight: "70%", distributed: false, borderRadius: 0, borderRadiusApplication: "around", borderRadiusWhenStacked: "last", rangeBarOverlap: true, rangeBarGroupRows: false, hideZeroBarsWhenGrouped: false, isDumbbell: false, dumbbellColors: void 0, isFunnel: false, isFunnel3d: true, colors: { ranges: [], backgroundBarColors: [], backgroundBarOpacity: 1, backgroundBarRadius: 0 }, dataLabels: { position: "top", maxItems: 100, hideOverflowingLabels: true, orientation: "horizontal", total: { enabled: false, formatter: void 0, offsetX: 0, offsetY: 0, style: { color: "#373d3f", fontSize: "12px", fontFamily: void 0, fontWeight: 600 } } } }, bubble: { zScaling: true, minBubbleRadius: void 0, maxBubbleRadius: void 0 }, candlestick: { colors: { upward: "#00B746", downward: "#EF403C" }, wick: { useFillColor: true } }, boxPlot: { colors: { upper: "#00E396", lower: "#008FFB" } }, heatmap: { radius: 2, enableShades: true, shadeIntensity: 0.5, reverseNegativeShade: false, distributed: false, useFillColorAsStroke: false, colorScale: { inverse: false, ranges: [], min: void 0, max: void 0 } }, treemap: { enableShades: true, shadeIntensity: 0.5, distributed: false, reverseNegativeShade: false, useFillColorAsStroke: false, borderRadius: 4, dataLabels: { format: "scale" }, colorScale: { inverse: false, ranges: [], min: void 0, max: void 0 } }, radialBar: { inverseOrder: false, startAngle: 0, endAngle: 360, offsetX: 0, offsetY: 0, hollow: { margin: 5, size: "50%", background: "transparent", image: void 0, imageWidth: 150, imageHeight: 150, imageOffsetX: 0, imageOffsetY: 0, imageClipped: true, position: "front", dropShadow: { enabled: false, top: 0, left: 0, blur: 3, color: "#000", opacity: 0.5 } }, track: { show: true, startAngle: void 0, endAngle: void 0, background: "#f2f2f2", strokeWidth: "97%", opacity: 1, margin: 5, dropShadow: { enabled: false, top: 0, left: 0, blur: 3, color: "#000", opacity: 0.5 } }, dataLabels: { show: true, name: { show: true, fontSize: "16px", fontFamily: void 0, fontWeight: 600, color: void 0, offsetY: 0, formatter: function(t8) {
        return t8;
      } }, value: { show: true, fontSize: "14px", fontFamily: void 0, fontWeight: 400, color: void 0, offsetY: 16, formatter: function(t8) {
        return t8 + "%";
      } }, total: { show: false, label: "Total", fontSize: "16px", fontWeight: 600, fontFamily: void 0, color: void 0, formatter: function(t8) {
        return t8.globals.seriesTotals.reduce(function(t9, e4) {
          return t9 + e4;
        }, 0) / t8.globals.series.length + "%";
      } } }, barLabels: { enabled: false, offsetX: 0, offsetY: 0, useSeriesColors: true, fontFamily: void 0, fontWeight: 600, fontSize: "16px", formatter: function(t8) {
        return t8;
      }, onClick: void 0 } }, pie: { customScale: 1, offsetX: 0, offsetY: 0, startAngle: 0, endAngle: 360, expandOnClick: true, dataLabels: { offset: 0, minAngleToShowLabel: 10 }, donut: { size: "65%", background: "transparent", labels: { show: false, name: { show: true, fontSize: "16px", fontFamily: void 0, fontWeight: 600, color: void 0, offsetY: -10, formatter: function(t8) {
        return t8;
      } }, value: { show: true, fontSize: "20px", fontFamily: void 0, fontWeight: 400, color: void 0, offsetY: 10, formatter: function(t8) {
        return t8;
      } }, total: { show: false, showAlways: false, label: "Total", fontSize: "16px", fontWeight: 400, fontFamily: void 0, color: void 0, formatter: function(t8) {
        return t8.globals.seriesTotals.reduce(function(t9, e4) {
          return t9 + e4;
        }, 0);
      } } } } }, polarArea: { rings: { strokeWidth: 1, strokeColor: "#e8e8e8" }, spokes: { strokeWidth: 1, connectorColors: "#e8e8e8" } }, radar: { size: void 0, offsetX: 0, offsetY: 0, polygons: { strokeWidth: 1, strokeColors: "#e8e8e8", connectorColors: "#e8e8e8", fill: { colors: void 0 } } } }, colors: void 0, dataLabels: { enabled: true, enabledOnSeries: void 0, formatter: function(t8) {
        return null !== t8 ? t8 : "";
      }, textAnchor: "middle", distributed: false, offsetX: 0, offsetY: 0, style: { fontSize: "12px", fontFamily: void 0, fontWeight: 600, colors: void 0 }, background: { enabled: true, foreColor: "#fff", borderRadius: 2, padding: 4, opacity: 0.9, borderWidth: 1, borderColor: "#fff", dropShadow: { enabled: false, top: 1, left: 1, blur: 1, color: "#000", opacity: 0.45 } }, dropShadow: { enabled: false, top: 1, left: 1, blur: 1, color: "#000", opacity: 0.45 } }, fill: { type: "solid", colors: void 0, opacity: 0.85, gradient: { shade: "dark", type: "horizontal", shadeIntensity: 0.5, gradientToColors: void 0, inverseColors: true, opacityFrom: 1, opacityTo: 1, stops: [0, 50, 100], colorStops: [] }, image: { src: [], width: void 0, height: void 0 }, pattern: { style: "squares", width: 6, height: 6, strokeWidth: 2 } }, forecastDataPoints: { count: 0, fillOpacity: 0.5, strokeWidth: void 0, dashArray: 4 }, grid: { show: true, borderColor: "#e0e0e0", strokeDashArray: 0, position: "back", xaxis: { lines: { show: false } }, yaxis: { lines: { show: true } }, row: { colors: void 0, opacity: 0.5 }, column: { colors: void 0, opacity: 0.5 }, padding: { top: 0, right: 10, bottom: 0, left: 12 } }, labels: [], legend: { show: true, showForSingleSeries: false, showForNullSeries: true, showForZeroSeries: true, floating: false, position: "bottom", horizontalAlign: "center", inverseOrder: false, fontSize: "12px", fontFamily: void 0, fontWeight: 400, width: void 0, height: void 0, formatter: void 0, tooltipHoverFormatter: void 0, offsetX: -20, offsetY: 4, customLegendItems: [], labels: { colors: void 0, useSeriesColors: false }, markers: { size: 7, fillColors: void 0, strokeWidth: 1, shape: void 0, offsetX: 0, offsetY: 0, customHTML: void 0, onClick: void 0 }, itemMargin: { horizontal: 5, vertical: 4 }, onItemClick: { toggleDataSeries: true }, onItemHover: { highlightDataSeries: true } }, markers: { discrete: [], size: 0, colors: void 0, strokeColors: "#fff", strokeWidth: 2, strokeOpacity: 0.9, strokeDashArray: 0, fillOpacity: 1, shape: "circle", offsetX: 0, offsetY: 0, showNullDataPoints: true, onClick: void 0, onDblClick: void 0, hover: { size: void 0, sizeOffset: 3 } }, noData: { text: void 0, align: "center", verticalAlign: "middle", offsetX: 0, offsetY: 0, style: { color: void 0, fontSize: "14px", fontFamily: void 0 } }, responsive: [], series: void 0, states: { normal: { filter: { type: "none", value: 0 } }, hover: { filter: { type: "lighten", value: 0.1 } }, active: { allowMultipleDataPointsSelection: false, filter: { type: "darken", value: 0.5 } } }, title: { text: void 0, align: "left", margin: 5, offsetX: 0, offsetY: 0, floating: false, style: { fontSize: "14px", fontWeight: 900, fontFamily: void 0, color: void 0 } }, subtitle: { text: void 0, align: "left", margin: 5, offsetX: 0, offsetY: 30, floating: false, style: { fontSize: "12px", fontWeight: 400, fontFamily: void 0, color: void 0 } }, stroke: { show: true, curve: "smooth", lineCap: "butt", width: 2, colors: void 0, dashArray: 0, fill: { type: "solid", colors: void 0, opacity: 0.85, gradient: { shade: "dark", type: "horizontal", shadeIntensity: 0.5, gradientToColors: void 0, inverseColors: true, opacityFrom: 1, opacityTo: 1, stops: [0, 50, 100], colorStops: [] } } }, tooltip: { enabled: true, enabledOnSeries: void 0, shared: true, hideEmptySeries: false, followCursor: false, intersect: false, inverseOrder: false, custom: void 0, fillSeriesColor: false, theme: "light", cssClass: "", style: { fontSize: "12px", fontFamily: void 0 }, onDatasetHover: { highlightDataSeries: false }, x: { show: true, format: "dd MMM", formatter: void 0 }, y: { formatter: void 0, title: { formatter: function(t8) {
        return t8 ? t8 + ": " : "";
      } } }, z: { formatter: void 0, title: "Size: " }, marker: { show: true, fillColors: void 0 }, items: { display: "flex" }, fixed: { enabled: false, position: "topRight", offsetX: 0, offsetY: 0 } }, xaxis: { type: "category", categories: [], convertedCatToNumeric: false, offsetX: 0, offsetY: 0, overwriteCategories: void 0, labels: { show: true, rotate: -45, rotateAlways: false, hideOverlappingLabels: true, trim: false, minHeight: void 0, maxHeight: 120, showDuplicates: true, style: { colors: [], fontSize: "12px", fontWeight: 400, fontFamily: void 0, cssClass: "" }, offsetX: 0, offsetY: 0, format: void 0, formatter: void 0, datetimeUTC: true, datetimeFormatter: { year: "yyyy", month: "MMM 'yy", day: "dd MMM", hour: "HH:mm", minute: "HH:mm:ss", second: "HH:mm:ss" } }, group: { groups: [], style: { colors: [], fontSize: "12px", fontWeight: 400, fontFamily: void 0, cssClass: "" } }, axisBorder: { show: true, color: "#e0e0e0", width: "100%", height: 1, offsetX: 0, offsetY: 0 }, axisTicks: { show: true, color: "#e0e0e0", height: 6, offsetX: 0, offsetY: 0 }, stepSize: void 0, tickAmount: void 0, tickPlacement: "on", min: void 0, max: void 0, range: void 0, floating: false, decimalsInFloat: void 0, position: "bottom", title: { text: void 0, offsetX: 0, offsetY: 0, style: { color: void 0, fontSize: "12px", fontWeight: 900, fontFamily: void 0, cssClass: "" } }, crosshairs: { show: true, width: 1, position: "back", opacity: 0.9, stroke: { color: "#b6b6b6", width: 1, dashArray: 3 }, fill: { type: "solid", color: "#B1B9C4", gradient: { colorFrom: "#D8E3F0", colorTo: "#BED1E6", stops: [0, 100], opacityFrom: 0.4, opacityTo: 0.5 } }, dropShadow: { enabled: false, left: 0, top: 0, blur: 1, opacity: 0.4 } }, tooltip: { enabled: true, offsetY: 0, formatter: void 0, style: { fontSize: "12px", fontFamily: void 0 } } }, yaxis: this.yAxis, theme: { mode: "", palette: "palette1", monochrome: { enabled: false, color: "#008FFB", shadeTo: "light", shadeIntensity: 0.65 } } };
    } }]), t7;
  }(), T3 = function() {
    function t7(e4) {
      a9(this, t7), this.ctx = e4, this.w = e4.w, this.graphics = new m3(this.ctx), this.w.globals.isBarHorizontal && (this.invertAxis = true), this.helpers = new w3(this), this.xAxisAnnotations = new k3(this), this.yAxisAnnotations = new L3(this), this.pointsAnnotations = new P2(this), this.w.globals.isBarHorizontal && this.w.config.yaxis[0].reversed && (this.inversedReversedAxis = true), this.xDivision = this.w.globals.gridWidth / this.w.globals.dataPoints;
    }
    return r12(t7, [{ key: "drawAxesAnnotations", value: function() {
      var t8 = this.w;
      if (t8.globals.axisCharts) {
        for (var e4 = this.yAxisAnnotations.drawYAxisAnnotations(), i17 = this.xAxisAnnotations.drawXAxisAnnotations(), a10 = this.pointsAnnotations.drawPointAnnotations(), s11 = t8.config.chart.animations.enabled, r13 = [e4, i17, a10], o10 = [i17.node, e4.node, a10.node], n11 = 0; n11 < 3; n11++)
          t8.globals.dom.elGraphical.add(r13[n11]), !s11 || t8.globals.resized || t8.globals.dataChanged || "scatter" !== t8.config.chart.type && "bubble" !== t8.config.chart.type && t8.globals.dataPoints > 1 && o10[n11].classList.add("apexcharts-element-hidden"), t8.globals.delayedElements.push({ el: o10[n11], index: 0 });
        this.helpers.annotationsBackground();
      }
    } }, { key: "drawImageAnnos", value: function() {
      var t8 = this;
      this.w.config.annotations.images.map(function(e4, i17) {
        t8.addImage(e4, i17);
      });
    } }, { key: "drawTextAnnos", value: function() {
      var t8 = this;
      this.w.config.annotations.texts.map(function(e4, i17) {
        t8.addText(e4, i17);
      });
    } }, { key: "addXaxisAnnotation", value: function(t8, e4, i17) {
      this.xAxisAnnotations.addXaxisAnnotation(t8, e4, i17);
    } }, { key: "addYaxisAnnotation", value: function(t8, e4, i17) {
      this.yAxisAnnotations.addYaxisAnnotation(t8, e4, i17);
    } }, { key: "addPointAnnotation", value: function(t8, e4, i17) {
      this.pointsAnnotations.addPointAnnotation(t8, e4, i17);
    } }, { key: "addText", value: function(t8, e4) {
      var i17 = t8.x, a10 = t8.y, s11 = t8.text, r13 = t8.textAnchor, o10 = t8.foreColor, n11 = t8.fontSize, l8 = t8.fontFamily, h4 = t8.fontWeight, c7 = t8.cssClass, d9 = t8.backgroundColor, g7 = t8.borderWidth, u6 = t8.strokeDashArray, p7 = t8.borderRadius, f5 = t8.borderColor, x4 = t8.appendTo, b3 = void 0 === x4 ? ".apexcharts-svg" : x4, v5 = t8.paddingLeft, m4 = void 0 === v5 ? 4 : v5, y5 = t8.paddingRight, w4 = void 0 === y5 ? 4 : y5, k4 = t8.paddingBottom, A3 = void 0 === k4 ? 2 : k4, S3 = t8.paddingTop, C3 = void 0 === S3 ? 2 : S3, L4 = this.w, P3 = this.graphics.drawText({ x: i17, y: a10, text: s11, textAnchor: r13 || "start", fontSize: n11 || "12px", fontWeight: h4 || "regular", fontFamily: l8 || L4.config.chart.fontFamily, foreColor: o10 || L4.config.chart.foreColor, cssClass: c7 }), M4 = L4.globals.dom.baseEl.querySelector(b3);
      M4 && M4.appendChild(P3.node);
      var I4 = P3.bbox();
      if (s11) {
        var T4 = this.graphics.drawRect(I4.x - m4, I4.y - C3, I4.width + m4 + w4, I4.height + A3 + C3, p7, d9 || "transparent", 1, g7, f5, u6);
        M4.insertBefore(T4.node, P3.node);
      }
    } }, { key: "addImage", value: function(t8, e4) {
      var i17 = this.w, a10 = t8.path, s11 = t8.x, r13 = void 0 === s11 ? 0 : s11, o10 = t8.y, n11 = void 0 === o10 ? 0 : o10, l8 = t8.width, h4 = void 0 === l8 ? 20 : l8, c7 = t8.height, d9 = void 0 === c7 ? 20 : c7, g7 = t8.appendTo, u6 = void 0 === g7 ? ".apexcharts-svg" : g7, p7 = i17.globals.dom.Paper.image(a10);
      p7.size(h4, d9).move(r13, n11);
      var f5 = i17.globals.dom.baseEl.querySelector(u6);
      return f5 && f5.appendChild(p7.node), p7;
    } }, { key: "addXaxisAnnotationExternal", value: function(t8, e4, i17) {
      return this.addAnnotationExternal({ params: t8, pushToMemory: e4, context: i17, type: "xaxis", contextMethod: i17.addXaxisAnnotation }), i17;
    } }, { key: "addYaxisAnnotationExternal", value: function(t8, e4, i17) {
      return this.addAnnotationExternal({ params: t8, pushToMemory: e4, context: i17, type: "yaxis", contextMethod: i17.addYaxisAnnotation }), i17;
    } }, { key: "addPointAnnotationExternal", value: function(t8, e4, i17) {
      return void 0 === this.invertAxis && (this.invertAxis = i17.w.globals.isBarHorizontal), this.addAnnotationExternal({ params: t8, pushToMemory: e4, context: i17, type: "point", contextMethod: i17.addPointAnnotation }), i17;
    } }, { key: "addAnnotationExternal", value: function(t8) {
      var e4 = t8.params, i17 = t8.pushToMemory, a10 = t8.context, s11 = t8.type, r13 = t8.contextMethod, o10 = a10, n11 = o10.w, l8 = n11.globals.dom.baseEl.querySelector(".apexcharts-".concat(s11, "-annotations")), h4 = l8.childNodes.length + 1, c7 = new I3(), d9 = Object.assign({}, "xaxis" === s11 ? c7.xAxisAnnotation : "yaxis" === s11 ? c7.yAxisAnnotation : c7.pointAnnotation), g7 = x3.extend(d9, e4);
      switch (s11) {
        case "xaxis":
          this.addXaxisAnnotation(g7, l8, h4);
          break;
        case "yaxis":
          this.addYaxisAnnotation(g7, l8, h4);
          break;
        case "point":
          this.addPointAnnotation(g7, l8, h4);
      }
      var u6 = n11.globals.dom.baseEl.querySelector(".apexcharts-".concat(s11, "-annotations .apexcharts-").concat(s11, "-annotation-label[rel='").concat(h4, "']")), p7 = this.helpers.addBackgroundToAnno(u6, g7);
      return p7 && l8.insertBefore(p7.node, u6), i17 && n11.globals.memory.methodsToExec.push({ context: o10, id: g7.id ? g7.id : x3.randomId(), method: r13, label: "addAnnotation", params: e4 }), a10;
    } }, { key: "clearAnnotations", value: function(t8) {
      var e4 = t8.w, i17 = e4.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-annotations, .apexcharts-xaxis-annotations, .apexcharts-point-annotations");
      e4.globals.memory.methodsToExec.map(function(t9, i18) {
        "addText" !== t9.label && "addAnnotation" !== t9.label || e4.globals.memory.methodsToExec.splice(i18, 1);
      }), i17 = x3.listToArray(i17), Array.prototype.forEach.call(i17, function(t9) {
        for (; t9.firstChild; )
          t9.removeChild(t9.firstChild);
      });
    } }, { key: "removeAnnotation", value: function(t8, e4) {
      var i17 = t8.w, a10 = i17.globals.dom.baseEl.querySelectorAll(".".concat(e4));
      a10 && (i17.globals.memory.methodsToExec.map(function(t9, a11) {
        t9.id === e4 && i17.globals.memory.methodsToExec.splice(a11, 1);
      }), Array.prototype.forEach.call(a10, function(t9) {
        t9.parentElement.removeChild(t9);
      }));
    } }]), t7;
  }(), z3 = function(t7) {
    var e4, i17 = t7.isTimeline, a10 = t7.ctx, s11 = t7.seriesIndex, r13 = t7.dataPointIndex, o10 = t7.y1, n11 = t7.y2, l8 = t7.w, h4 = l8.globals.seriesRangeStart[s11][r13], c7 = l8.globals.seriesRangeEnd[s11][r13], d9 = l8.globals.labels[r13], g7 = l8.config.series[s11].name ? l8.config.series[s11].name : "", u6 = l8.globals.ttKeyFormatter, p7 = l8.config.tooltip.y.title.formatter, f5 = { w: l8, seriesIndex: s11, dataPointIndex: r13, start: h4, end: c7 };
    ("function" == typeof p7 && (g7 = p7(g7, f5)), null !== (e4 = l8.config.series[s11].data[r13]) && void 0 !== e4 && e4.x && (d9 = l8.config.series[s11].data[r13].x), i17) || "datetime" === l8.config.xaxis.type && (d9 = new S2(a10).xLabelFormat(l8.globals.ttKeyFormatter, d9, d9, { i: void 0, dateFormatter: new A2(a10).formatDate, w: l8 }));
    "function" == typeof u6 && (d9 = u6(d9, f5)), Number.isFinite(o10) && Number.isFinite(n11) && (h4 = o10, c7 = n11);
    var x4 = "", b3 = "", v5 = l8.globals.colors[s11];
    if (void 0 === l8.config.tooltip.x.formatter)
      if ("datetime" === l8.config.xaxis.type) {
        var m4 = new A2(a10);
        x4 = m4.formatDate(m4.getDate(h4), l8.config.tooltip.x.format), b3 = m4.formatDate(m4.getDate(c7), l8.config.tooltip.x.format);
      } else
        x4 = h4, b3 = c7;
    else
      x4 = l8.config.tooltip.x.formatter(h4), b3 = l8.config.tooltip.x.formatter(c7);
    return { start: h4, end: c7, startVal: x4, endVal: b3, ylabel: d9, color: v5, seriesName: g7 };
  }, X2 = function(t7) {
    var e4 = t7.color, i17 = t7.seriesName, a10 = t7.ylabel, s11 = t7.start, r13 = t7.end, o10 = t7.seriesIndex, n11 = t7.dataPointIndex, l8 = t7.ctx.tooltip.tooltipLabels.getFormatters(o10);
    s11 = l8.yLbFormatter(s11), r13 = l8.yLbFormatter(r13);
    var h4 = l8.yLbFormatter(t7.w.globals.series[o10][n11]), c7 = '<span class="value start-value">\n  '.concat(s11, '\n  </span> <span class="separator">-</span> <span class="value end-value">\n  ').concat(r13, "\n  </span>");
    return '<div class="apexcharts-tooltip-rangebar"><div> <span class="series-name" style="color: ' + e4 + '">' + (i17 || "") + '</span></div><div> <span class="category">' + a10 + ": </span> " + (t7.w.globals.comboCharts ? "rangeArea" === t7.w.config.series[o10].type || "rangeBar" === t7.w.config.series[o10].type ? c7 : "<span>".concat(h4, "</span>") : c7) + " </div></div>";
  }, E2 = function() {
    function t7(e4) {
      a9(this, t7), this.opts = e4;
    }
    return r12(t7, [{ key: "hideYAxis", value: function() {
      this.opts.yaxis[0].show = false, this.opts.yaxis[0].title.text = "", this.opts.yaxis[0].axisBorder.show = false, this.opts.yaxis[0].axisTicks.show = false, this.opts.yaxis[0].floating = true;
    } }, { key: "line", value: function() {
      return { chart: { animations: { easing: "swing" } }, dataLabels: { enabled: false }, stroke: { width: 5, curve: "straight" }, markers: { size: 0, hover: { sizeOffset: 6 } }, xaxis: { crosshairs: { width: 1 } } };
    } }, { key: "sparkline", value: function(t8) {
      this.hideYAxis();
      return x3.extend(t8, { grid: { show: false, padding: { left: 0, right: 0, top: 0, bottom: 0 } }, legend: { show: false }, xaxis: { labels: { show: false }, tooltip: { enabled: false }, axisBorder: { show: false }, axisTicks: { show: false } }, chart: { toolbar: { show: false }, zoom: { enabled: false } }, dataLabels: { enabled: false } });
    } }, { key: "slope", value: function() {
      return this.hideYAxis(), { chart: { toolbar: { show: false }, zoom: { enabled: false } }, dataLabels: { enabled: true, formatter: function(t8, e4) {
        var i17 = e4.w.config.series[e4.seriesIndex].name;
        return null !== t8 ? i17 + ": " + t8 : "";
      }, background: { enabled: false }, offsetX: -5 }, grid: { xaxis: { lines: { show: true } }, yaxis: { lines: { show: false } } }, xaxis: { position: "top", labels: { style: { fontSize: 14, fontWeight: 900 } }, tooltip: { enabled: false }, crosshairs: { show: false } }, markers: { size: 8, hover: { sizeOffset: 1 } }, legend: { show: false }, tooltip: { shared: false, intersect: true, followCursor: true }, stroke: { width: 5, curve: "straight" } };
    } }, { key: "bar", value: function() {
      return { chart: { stacked: false, animations: { easing: "swing" } }, plotOptions: { bar: { dataLabels: { position: "center" } } }, dataLabels: { style: { colors: ["#fff"] }, background: { enabled: false } }, stroke: { width: 0, lineCap: "round" }, fill: { opacity: 0.85 }, legend: { markers: { shape: "square" } }, tooltip: { shared: false, intersect: true }, xaxis: { tooltip: { enabled: false }, tickPlacement: "between", crosshairs: { width: "barWidth", position: "back", fill: { type: "gradient" }, dropShadow: { enabled: false }, stroke: { width: 0 } } } };
    } }, { key: "funnel", value: function() {
      return this.hideYAxis(), e3(e3({}, this.bar()), {}, { chart: { animations: { easing: "linear", speed: 800, animateGradually: { enabled: false } } }, plotOptions: { bar: { horizontal: true, borderRadiusApplication: "around", borderRadius: 0, dataLabels: { position: "center" } } }, grid: { show: false, padding: { left: 0, right: 0 } }, xaxis: { labels: { show: false }, tooltip: { enabled: false }, axisBorder: { show: false }, axisTicks: { show: false } } });
    } }, { key: "candlestick", value: function() {
      var t8 = this;
      return { stroke: { width: 1, colors: ["#333"] }, fill: { opacity: 1 }, dataLabels: { enabled: false }, tooltip: { shared: true, custom: function(e4) {
        var i17 = e4.seriesIndex, a10 = e4.dataPointIndex, s11 = e4.w;
        return t8._getBoxTooltip(s11, i17, a10, ["Open", "High", "", "Low", "Close"], "candlestick");
      } }, states: { active: { filter: { type: "none" } } }, xaxis: { crosshairs: { width: 1 } } };
    } }, { key: "boxPlot", value: function() {
      var t8 = this;
      return { chart: { animations: { dynamicAnimation: { enabled: false } } }, stroke: { width: 1, colors: ["#24292e"] }, dataLabels: { enabled: false }, tooltip: { shared: true, custom: function(e4) {
        var i17 = e4.seriesIndex, a10 = e4.dataPointIndex, s11 = e4.w;
        return t8._getBoxTooltip(s11, i17, a10, ["Minimum", "Q1", "Median", "Q3", "Maximum"], "boxPlot");
      } }, markers: { size: 7, strokeWidth: 1, strokeColors: "#111" }, xaxis: { crosshairs: { width: 1 } } };
    } }, { key: "rangeBar", value: function() {
      return { chart: { animations: { animateGradually: false } }, stroke: { width: 0, lineCap: "square" }, plotOptions: { bar: { borderRadius: 0, dataLabels: { position: "center" } } }, dataLabels: { enabled: false, formatter: function(t8, e4) {
        e4.ctx;
        var i17 = e4.seriesIndex, a10 = e4.dataPointIndex, s11 = e4.w, r13 = function() {
          var t9 = s11.globals.seriesRangeStart[i17][a10];
          return s11.globals.seriesRangeEnd[i17][a10] - t9;
        };
        return s11.globals.comboCharts ? "rangeBar" === s11.config.series[i17].type || "rangeArea" === s11.config.series[i17].type ? r13() : t8 : r13();
      }, background: { enabled: false }, style: { colors: ["#fff"] } }, markers: { size: 10 }, tooltip: { shared: false, followCursor: true, custom: function(t8) {
        return t8.w.config.plotOptions && t8.w.config.plotOptions.bar && t8.w.config.plotOptions.bar.horizontal ? function(t9) {
          var i17 = z3(e3(e3({}, t9), {}, { isTimeline: true })), a10 = i17.color, s11 = i17.seriesName, r13 = i17.ylabel, o10 = i17.startVal, n11 = i17.endVal;
          return X2(e3(e3({}, t9), {}, { color: a10, seriesName: s11, ylabel: r13, start: o10, end: n11 }));
        }(t8) : function(t9) {
          var i17 = z3(t9), a10 = i17.color, s11 = i17.seriesName, r13 = i17.ylabel, o10 = i17.start, n11 = i17.end;
          return X2(e3(e3({}, t9), {}, { color: a10, seriesName: s11, ylabel: r13, start: o10, end: n11 }));
        }(t8);
      } }, xaxis: { tickPlacement: "between", tooltip: { enabled: false }, crosshairs: { stroke: { width: 0 } } } };
    } }, { key: "dumbbell", value: function(t8) {
      var e4, i17;
      return null !== (e4 = t8.plotOptions.bar) && void 0 !== e4 && e4.barHeight || (t8.plotOptions.bar.barHeight = 2), null !== (i17 = t8.plotOptions.bar) && void 0 !== i17 && i17.columnWidth || (t8.plotOptions.bar.columnWidth = 2), t8;
    } }, { key: "area", value: function() {
      return { stroke: { width: 4, fill: { type: "solid", gradient: { inverseColors: false, shade: "light", type: "vertical", opacityFrom: 0.65, opacityTo: 0.5, stops: [0, 100, 100] } } }, fill: { type: "gradient", gradient: { inverseColors: false, shade: "light", type: "vertical", opacityFrom: 0.65, opacityTo: 0.5, stops: [0, 100, 100] } }, markers: { size: 0, hover: { sizeOffset: 6 } }, tooltip: { followCursor: false } };
    } }, { key: "rangeArea", value: function() {
      return { stroke: { curve: "straight", width: 0 }, fill: { type: "solid", opacity: 0.6 }, markers: { size: 0 }, states: { hover: { filter: { type: "none" } }, active: { filter: { type: "none" } } }, tooltip: { intersect: false, shared: true, followCursor: true, custom: function(t8) {
        return function(t9) {
          var i17 = z3(t9), a10 = i17.color, s11 = i17.seriesName, r13 = i17.ylabel, o10 = i17.start, n11 = i17.end;
          return X2(e3(e3({}, t9), {}, { color: a10, seriesName: s11, ylabel: r13, start: o10, end: n11 }));
        }(t8);
      } } };
    } }, { key: "brush", value: function(t8) {
      return x3.extend(t8, { chart: { toolbar: { autoSelected: "selection", show: false }, zoom: { enabled: false } }, dataLabels: { enabled: false }, stroke: { width: 1 }, tooltip: { enabled: false }, xaxis: { tooltip: { enabled: false } } });
    } }, { key: "stacked100", value: function(t8) {
      t8.dataLabels = t8.dataLabels || {}, t8.dataLabels.formatter = t8.dataLabels.formatter || void 0;
      var e4 = t8.dataLabels.formatter;
      return t8.yaxis.forEach(function(e5, i17) {
        t8.yaxis[i17].min = 0, t8.yaxis[i17].max = 100;
      }), "bar" === t8.chart.type && (t8.dataLabels.formatter = e4 || function(t9) {
        return "number" == typeof t9 && t9 ? t9.toFixed(0) + "%" : t9;
      }), t8;
    } }, { key: "stackedBars", value: function() {
      var t8 = this.bar();
      return e3(e3({}, t8), {}, { plotOptions: e3(e3({}, t8.plotOptions), {}, { bar: e3(e3({}, t8.plotOptions.bar), {}, { borderRadiusApplication: "end", borderRadiusWhenStacked: "last" }) }) });
    } }, { key: "convertCatToNumeric", value: function(t8) {
      return t8.xaxis.convertedCatToNumeric = true, t8;
    } }, { key: "convertCatToNumericXaxis", value: function(t8, e4, i17) {
      t8.xaxis.type = "numeric", t8.xaxis.labels = t8.xaxis.labels || {}, t8.xaxis.labels.formatter = t8.xaxis.labels.formatter || function(t9) {
        return x3.isNumber(t9) ? Math.floor(t9) : t9;
      };
      var a10 = t8.xaxis.labels.formatter, s11 = t8.xaxis.categories && t8.xaxis.categories.length ? t8.xaxis.categories : t8.labels;
      return i17 && i17.length && (s11 = i17.map(function(t9) {
        return Array.isArray(t9) ? t9 : String(t9);
      })), s11 && s11.length && (t8.xaxis.labels.formatter = function(t9) {
        return x3.isNumber(t9) ? a10(s11[Math.floor(t9) - 1]) : a10(t9);
      }), t8.xaxis.categories = [], t8.labels = [], t8.xaxis.tickAmount = t8.xaxis.tickAmount || "dataPoints", t8;
    } }, { key: "bubble", value: function() {
      return { dataLabels: { style: { colors: ["#fff"] } }, tooltip: { shared: false, intersect: true }, xaxis: { crosshairs: { width: 0 } }, fill: { type: "solid", gradient: { shade: "light", inverse: true, shadeIntensity: 0.55, opacityFrom: 0.4, opacityTo: 0.8 } } };
    } }, { key: "scatter", value: function() {
      return { dataLabels: { enabled: false }, tooltip: { shared: false, intersect: true }, markers: { size: 6, strokeWidth: 1, hover: { sizeOffset: 2 } } };
    } }, { key: "heatmap", value: function() {
      return { chart: { stacked: false }, fill: { opacity: 1 }, dataLabels: { style: { colors: ["#fff"] } }, stroke: { colors: ["#fff"] }, tooltip: { followCursor: true, marker: { show: false }, x: { show: false } }, legend: { position: "top", markers: { shape: "square" } }, grid: { padding: { right: 20 } } };
    } }, { key: "treemap", value: function() {
      return { chart: { zoom: { enabled: false } }, dataLabels: { style: { fontSize: 14, fontWeight: 600, colors: ["#fff"] } }, stroke: { show: true, width: 2, colors: ["#fff"] }, legend: { show: false }, fill: { opacity: 1, gradient: { stops: [0, 100] } }, tooltip: { followCursor: true, x: { show: false } }, grid: { padding: { left: 0, right: 0 } }, xaxis: { crosshairs: { show: false }, tooltip: { enabled: false } } };
    } }, { key: "pie", value: function() {
      return { chart: { toolbar: { show: false } }, plotOptions: { pie: { donut: { labels: { show: false } } } }, dataLabels: { formatter: function(t8) {
        return t8.toFixed(1) + "%";
      }, style: { colors: ["#fff"] }, background: { enabled: false }, dropShadow: { enabled: true } }, stroke: { colors: ["#fff"] }, fill: { opacity: 1, gradient: { shade: "light", stops: [0, 100] } }, tooltip: { theme: "dark", fillSeriesColor: true }, legend: { position: "right" } };
    } }, { key: "donut", value: function() {
      return { chart: { toolbar: { show: false } }, dataLabels: { formatter: function(t8) {
        return t8.toFixed(1) + "%";
      }, style: { colors: ["#fff"] }, background: { enabled: false }, dropShadow: { enabled: true } }, stroke: { colors: ["#fff"] }, fill: { opacity: 1, gradient: { shade: "light", shadeIntensity: 0.35, stops: [80, 100], opacityFrom: 1, opacityTo: 1 } }, tooltip: { theme: "dark", fillSeriesColor: true }, legend: { position: "right" } };
    } }, { key: "polarArea", value: function() {
      return { chart: { toolbar: { show: false } }, dataLabels: { formatter: function(t8) {
        return t8.toFixed(1) + "%";
      }, enabled: false }, stroke: { show: true, width: 2 }, fill: { opacity: 0.7 }, tooltip: { theme: "dark", fillSeriesColor: true }, legend: { position: "right" } };
    } }, { key: "radar", value: function() {
      return this.opts.yaxis[0].labels.offsetY = this.opts.yaxis[0].labels.offsetY ? this.opts.yaxis[0].labels.offsetY : 6, { dataLabels: { enabled: false, style: { fontSize: "11px" } }, stroke: { width: 2 }, markers: { size: 5, strokeWidth: 1, strokeOpacity: 1 }, fill: { opacity: 0.2 }, tooltip: { shared: false, intersect: true, followCursor: true }, grid: { show: false }, xaxis: { labels: { formatter: function(t8) {
        return t8;
      }, style: { colors: ["#a8a8a8"], fontSize: "11px" } }, tooltip: { enabled: false }, crosshairs: { show: false } } };
    } }, { key: "radialBar", value: function() {
      return { chart: { animations: { dynamicAnimation: { enabled: true, speed: 800 } }, toolbar: { show: false } }, fill: { gradient: { shade: "dark", shadeIntensity: 0.4, inverseColors: false, type: "diagonal2", opacityFrom: 1, opacityTo: 1, stops: [70, 98, 100] } }, legend: { show: false, position: "right" }, tooltip: { enabled: false, fillSeriesColor: true } };
    } }, { key: "_getBoxTooltip", value: function(t8, e4, i17, a10, s11) {
      var r13 = t8.globals.seriesCandleO[e4][i17], o10 = t8.globals.seriesCandleH[e4][i17], n11 = t8.globals.seriesCandleM[e4][i17], l8 = t8.globals.seriesCandleL[e4][i17], h4 = t8.globals.seriesCandleC[e4][i17];
      return t8.config.series[e4].type && t8.config.series[e4].type !== s11 ? '<div class="apexcharts-custom-tooltip">\n          '.concat(t8.config.series[e4].name ? t8.config.series[e4].name : "series-" + (e4 + 1), ": <strong>").concat(t8.globals.series[e4][i17], "</strong>\n        </div>") : '<div class="apexcharts-tooltip-box apexcharts-tooltip-'.concat(t8.config.chart.type, '">') + "<div>".concat(a10[0], ': <span class="value">') + r13 + "</span></div>" + "<div>".concat(a10[1], ': <span class="value">') + o10 + "</span></div>" + (n11 ? "<div>".concat(a10[2], ': <span class="value">') + n11 + "</span></div>" : "") + "<div>".concat(a10[3], ': <span class="value">') + l8 + "</span></div>" + "<div>".concat(a10[4], ': <span class="value">') + h4 + "</span></div></div>";
    } }]), t7;
  }(), Y2 = function() {
    function t7(e4) {
      a9(this, t7), this.opts = e4;
    }
    return r12(t7, [{ key: "init", value: function(t8) {
      var e4 = t8.responsiveOverride, a10 = this.opts, s11 = new I3(), r13 = new E2(a10);
      this.chartType = a10.chart.type, a10 = this.extendYAxis(a10), a10 = this.extendAnnotations(a10);
      var o10 = s11.init(), n11 = {};
      if (a10 && "object" === i16(a10)) {
        var l8, h4, c7, d9, g7, u6, p7, f5, b3, v5, m4 = {};
        m4 = -1 !== ["line", "area", "bar", "candlestick", "boxPlot", "rangeBar", "rangeArea", "bubble", "scatter", "heatmap", "treemap", "pie", "polarArea", "donut", "radar", "radialBar"].indexOf(a10.chart.type) ? r13[a10.chart.type]() : r13.line(), null !== (l8 = a10.plotOptions) && void 0 !== l8 && null !== (h4 = l8.bar) && void 0 !== h4 && h4.isFunnel && (m4 = r13.funnel()), a10.chart.stacked && "bar" === a10.chart.type && (m4 = r13.stackedBars()), null !== (c7 = a10.chart.brush) && void 0 !== c7 && c7.enabled && (m4 = r13.brush(m4)), null !== (d9 = a10.plotOptions) && void 0 !== d9 && null !== (g7 = d9.line) && void 0 !== g7 && g7.isSlopeChart && (m4 = r13.slope()), a10.chart.stacked && "100%" === a10.chart.stackType && (a10 = r13.stacked100(a10)), null !== (u6 = a10.plotOptions) && void 0 !== u6 && null !== (p7 = u6.bar) && void 0 !== p7 && p7.isDumbbell && (a10 = r13.dumbbell(a10)), this.checkForDarkTheme(window.Apex), this.checkForDarkTheme(a10), a10.xaxis = a10.xaxis || window.Apex.xaxis || {}, e4 || (a10.xaxis.convertedCatToNumeric = false), (null !== (f5 = (a10 = this.checkForCatToNumericXAxis(this.chartType, m4, a10)).chart.sparkline) && void 0 !== f5 && f5.enabled || null !== (b3 = window.Apex.chart) && void 0 !== b3 && null !== (v5 = b3.sparkline) && void 0 !== v5 && v5.enabled) && (m4 = r13.sparkline(m4)), n11 = x3.extend(o10, m4);
      }
      var y5 = x3.extend(n11, window.Apex);
      return o10 = x3.extend(y5, a10), o10 = this.handleUserInputErrors(o10);
    } }, { key: "checkForCatToNumericXAxis", value: function(t8, e4, i17) {
      var a10, s11, r13 = new E2(i17), o10 = ("bar" === t8 || "boxPlot" === t8) && (null === (a10 = i17.plotOptions) || void 0 === a10 || null === (s11 = a10.bar) || void 0 === s11 ? void 0 : s11.horizontal), n11 = "pie" === t8 || "polarArea" === t8 || "donut" === t8 || "radar" === t8 || "radialBar" === t8 || "heatmap" === t8, l8 = "datetime" !== i17.xaxis.type && "numeric" !== i17.xaxis.type, h4 = i17.xaxis.tickPlacement ? i17.xaxis.tickPlacement : e4.xaxis && e4.xaxis.tickPlacement;
      return o10 || n11 || !l8 || "between" === h4 || (i17 = r13.convertCatToNumeric(i17)), i17;
    } }, { key: "extendYAxis", value: function(t8, e4) {
      var i17 = new I3();
      (void 0 === t8.yaxis || !t8.yaxis || Array.isArray(t8.yaxis) && 0 === t8.yaxis.length) && (t8.yaxis = {}), t8.yaxis.constructor !== Array && window.Apex.yaxis && window.Apex.yaxis.constructor !== Array && (t8.yaxis = x3.extend(t8.yaxis, window.Apex.yaxis)), t8.yaxis.constructor !== Array ? t8.yaxis = [x3.extend(i17.yAxis, t8.yaxis)] : t8.yaxis = x3.extendArray(t8.yaxis, i17.yAxis);
      var a10 = false;
      t8.yaxis.forEach(function(t9) {
        t9.logarithmic && (a10 = true);
      });
      var s11 = t8.series;
      return e4 && !s11 && (s11 = e4.config.series), a10 && s11.length !== t8.yaxis.length && s11.length && (t8.yaxis = s11.map(function(e5, a11) {
        if (e5.name || (s11[a11].name = "series-".concat(a11 + 1)), t8.yaxis[a11])
          return t8.yaxis[a11].seriesName = s11[a11].name, t8.yaxis[a11];
        var r13 = x3.extend(i17.yAxis, t8.yaxis[0]);
        return r13.show = false, r13;
      })), a10 && s11.length > 1 && s11.length !== t8.yaxis.length && console.warn("A multi-series logarithmic chart should have equal number of series and y-axes"), t8;
    } }, { key: "extendAnnotations", value: function(t8) {
      return void 0 === t8.annotations && (t8.annotations = {}, t8.annotations.yaxis = [], t8.annotations.xaxis = [], t8.annotations.points = []), t8 = this.extendYAxisAnnotations(t8), t8 = this.extendXAxisAnnotations(t8), t8 = this.extendPointAnnotations(t8);
    } }, { key: "extendYAxisAnnotations", value: function(t8) {
      var e4 = new I3();
      return t8.annotations.yaxis = x3.extendArray(void 0 !== t8.annotations.yaxis ? t8.annotations.yaxis : [], e4.yAxisAnnotation), t8;
    } }, { key: "extendXAxisAnnotations", value: function(t8) {
      var e4 = new I3();
      return t8.annotations.xaxis = x3.extendArray(void 0 !== t8.annotations.xaxis ? t8.annotations.xaxis : [], e4.xAxisAnnotation), t8;
    } }, { key: "extendPointAnnotations", value: function(t8) {
      var e4 = new I3();
      return t8.annotations.points = x3.extendArray(void 0 !== t8.annotations.points ? t8.annotations.points : [], e4.pointAnnotation), t8;
    } }, { key: "checkForDarkTheme", value: function(t8) {
      t8.theme && "dark" === t8.theme.mode && (t8.tooltip || (t8.tooltip = {}), "light" !== t8.tooltip.theme && (t8.tooltip.theme = "dark"), t8.chart.foreColor || (t8.chart.foreColor = "#f6f7f8"), t8.theme.palette || (t8.theme.palette = "palette4"));
    } }, { key: "handleUserInputErrors", value: function(t8) {
      var e4 = t8;
      if (e4.tooltip.shared && e4.tooltip.intersect)
        throw new Error("tooltip.shared cannot be enabled when tooltip.intersect is true. Turn off any other option by setting it to false.");
      if ("bar" === e4.chart.type && e4.plotOptions.bar.horizontal) {
        if (e4.yaxis.length > 1)
          throw new Error("Multiple Y Axis for bars are not supported. Switch to column chart by setting plotOptions.bar.horizontal=false");
        e4.yaxis[0].reversed && (e4.yaxis[0].opposite = true), e4.xaxis.tooltip.enabled = false, e4.yaxis[0].tooltip.enabled = false, e4.chart.zoom.enabled = false;
      }
      return "bar" !== e4.chart.type && "rangeBar" !== e4.chart.type || e4.tooltip.shared && "barWidth" === e4.xaxis.crosshairs.width && e4.series.length > 1 && (e4.xaxis.crosshairs.width = "tickWidth"), "candlestick" !== e4.chart.type && "boxPlot" !== e4.chart.type || e4.yaxis[0].reversed && (console.warn("Reversed y-axis in ".concat(e4.chart.type, " chart is not supported.")), e4.yaxis[0].reversed = false), e4;
    } }]), t7;
  }(), F2 = function() {
    function t7() {
      a9(this, t7);
    }
    return r12(t7, [{ key: "initGlobalVars", value: function(t8) {
      t8.series = [], t8.seriesCandleO = [], t8.seriesCandleH = [], t8.seriesCandleM = [], t8.seriesCandleL = [], t8.seriesCandleC = [], t8.seriesRangeStart = [], t8.seriesRangeEnd = [], t8.seriesRange = [], t8.seriesPercent = [], t8.seriesGoals = [], t8.seriesX = [], t8.seriesZ = [], t8.seriesNames = [], t8.seriesTotals = [], t8.seriesLog = [], t8.seriesColors = [], t8.stackedSeriesTotals = [], t8.seriesXvalues = [], t8.seriesYvalues = [], t8.labels = [], t8.hasXaxisGroups = false, t8.groups = [], t8.barGroups = [], t8.lineGroups = [], t8.areaGroups = [], t8.hasSeriesGroups = false, t8.seriesGroups = [], t8.categoryLabels = [], t8.timescaleLabels = [], t8.noLabelsProvided = false, t8.resizeTimer = null, t8.selectionResizeTimer = null, t8.delayedElements = [], t8.pointsArray = [], t8.dataLabelsRects = [], t8.isXNumeric = false, t8.skipLastTimelinelabel = false, t8.skipFirstTimelinelabel = false, t8.isDataXYZ = false, t8.isMultiLineX = false, t8.isMultipleYAxis = false, t8.maxY = -Number.MAX_VALUE, t8.minY = Number.MIN_VALUE, t8.minYArr = [], t8.maxYArr = [], t8.maxX = -Number.MAX_VALUE, t8.minX = Number.MAX_VALUE, t8.initialMaxX = -Number.MAX_VALUE, t8.initialMinX = Number.MAX_VALUE, t8.maxDate = 0, t8.minDate = Number.MAX_VALUE, t8.minZ = Number.MAX_VALUE, t8.maxZ = -Number.MAX_VALUE, t8.minXDiff = Number.MAX_VALUE, t8.yAxisScale = [], t8.xAxisScale = null, t8.xAxisTicksPositions = [], t8.yLabelsCoords = [], t8.yTitleCoords = [], t8.barPadForNumericAxis = 0, t8.padHorizontal = 0, t8.xRange = 0, t8.yRange = [], t8.zRange = 0, t8.dataPoints = 0, t8.xTickAmount = 0, t8.multiAxisTickAmount = 0;
    } }, { key: "globalVars", value: function(t8) {
      return { chartID: null, cuid: null, events: { beforeMount: [], mounted: [], updated: [], clicked: [], selection: [], dataPointSelection: [], zoomed: [], scrolled: [] }, colors: [], clientX: null, clientY: null, fill: { colors: [] }, stroke: { colors: [] }, dataLabels: { style: { colors: [] } }, radarPolygons: { fill: { colors: [] } }, markers: { colors: [], size: t8.markers.size, largestSize: 0 }, animationEnded: false, isTouchDevice: "ontouchstart" in window || navigator.msMaxTouchPoints, isDirty: false, isExecCalled: false, initialConfig: null, initialSeries: [], lastXAxis: [], lastYAxis: [], columnSeries: null, labels: [], timescaleLabels: [], noLabelsProvided: false, allSeriesCollapsed: false, collapsedSeries: [], collapsedSeriesIndices: [], ancillaryCollapsedSeries: [], ancillaryCollapsedSeriesIndices: [], risingSeries: [], dataFormatXNumeric: false, capturedSeriesIndex: -1, capturedDataPointIndex: -1, selectedDataPoints: [], goldenPadding: 35, invalidLogScale: false, ignoreYAxisIndexes: [], maxValsInArrayIndex: 0, radialSize: 0, selection: void 0, zoomEnabled: "zoom" === t8.chart.toolbar.autoSelected && t8.chart.toolbar.tools.zoom && t8.chart.zoom.enabled, panEnabled: "pan" === t8.chart.toolbar.autoSelected && t8.chart.toolbar.tools.pan, selectionEnabled: "selection" === t8.chart.toolbar.autoSelected && t8.chart.toolbar.tools.selection, yaxis: null, mousedown: false, lastClientPosition: {}, visibleXRange: void 0, yValueDecimal: 0, total: 0, SVGNS: "http://www.w3.org/2000/svg", svgWidth: 0, svgHeight: 0, noData: false, locale: {}, dom: {}, memory: { methodsToExec: [] }, shouldAnimate: true, skipLastTimelinelabel: false, skipFirstTimelinelabel: false, delayedElements: [], axisCharts: true, isDataXYZ: false, isSlopeChart: t8.plotOptions.line.isSlopeChart, resized: false, resizeTimer: null, comboCharts: false, dataChanged: false, previousPaths: [], allSeriesHasEqualX: true, pointsArray: [], dataLabelsRects: [], lastDrawnDataLabelsIndexes: [], hasNullValues: false, easing: null, zoomed: false, gridWidth: 0, gridHeight: 0, rotateXLabels: false, defaultLabels: false, xLabelFormatter: void 0, yLabelFormatters: [], xaxisTooltipFormatter: void 0, ttKeyFormatter: void 0, ttVal: void 0, ttZFormatter: void 0, LINE_HEIGHT_RATIO: 1.618, xAxisLabelsHeight: 0, xAxisGroupLabelsHeight: 0, xAxisLabelsWidth: 0, yAxisLabelsWidth: 0, scaleX: 1, scaleY: 1, translateX: 0, translateY: 0, translateYAxisX: [], yAxisWidths: [], translateXAxisY: 0, translateXAxisX: 0, tooltip: null, niceScaleAllowedMagMsd: [[1, 1, 2, 5, 5, 5, 10, 10, 10, 10, 10], [1, 1, 2, 5, 5, 5, 10, 10, 10, 10, 10]], niceScaleDefaultTicks: [1, 2, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 12, 12, 12, 12, 12, 12, 12, 12, 12, 24], seriesYAxisMap: [], seriesYAxisReverseMap: [] };
    } }, { key: "init", value: function(t8) {
      var e4 = this.globalVars(t8);
      return this.initGlobalVars(e4), e4.initialConfig = x3.extend({}, t8), e4.initialSeries = x3.clone(t8.series), e4.lastXAxis = x3.clone(e4.initialConfig.xaxis), e4.lastYAxis = x3.clone(e4.initialConfig.yaxis), e4;
    } }]), t7;
  }(), R2 = function() {
    function t7(e4) {
      a9(this, t7), this.opts = e4;
    }
    return r12(t7, [{ key: "init", value: function() {
      var t8 = new Y2(this.opts).init({ responsiveOverride: false });
      return { config: t8, globals: new F2().init(t8) };
    } }]), t7;
  }(), H3 = function() {
    function t7(e4) {
      a9(this, t7), this.ctx = e4, this.w = e4.w, this.opts = null, this.seriesIndex = 0;
    }
    return r12(t7, [{ key: "clippedImgArea", value: function(t8) {
      var e4 = this.w, i17 = e4.config, a10 = parseInt(e4.globals.gridWidth, 10), s11 = parseInt(e4.globals.gridHeight, 10), r13 = a10 > s11 ? a10 : s11, o10 = t8.image, n11 = 0, l8 = 0;
      void 0 === t8.width && void 0 === t8.height ? void 0 !== i17.fill.image.width && void 0 !== i17.fill.image.height ? (n11 = i17.fill.image.width + 1, l8 = i17.fill.image.height) : (n11 = r13 + 1, l8 = r13) : (n11 = t8.width, l8 = t8.height);
      var h4 = document.createElementNS(e4.globals.SVGNS, "pattern");
      m3.setAttrs(h4, { id: t8.patternID, patternUnits: t8.patternUnits ? t8.patternUnits : "userSpaceOnUse", width: n11 + "px", height: l8 + "px" });
      var c7 = document.createElementNS(e4.globals.SVGNS, "image");
      h4.appendChild(c7), c7.setAttributeNS(window.SVG.xlink, "href", o10), m3.setAttrs(c7, { x: 0, y: 0, preserveAspectRatio: "none", width: n11 + "px", height: l8 + "px" }), c7.style.opacity = t8.opacity, e4.globals.dom.elDefs.node.appendChild(h4);
    } }, { key: "getSeriesIndex", value: function(t8) {
      var e4 = this.w, i17 = e4.config.chart.type;
      return ("bar" === i17 || "rangeBar" === i17) && e4.config.plotOptions.bar.distributed || "heatmap" === i17 || "treemap" === i17 ? this.seriesIndex = t8.seriesNumber : this.seriesIndex = t8.seriesNumber % e4.globals.series.length, this.seriesIndex;
    } }, { key: "fillPath", value: function(t8) {
      var e4 = this.w;
      this.opts = t8;
      var i17, a10, s11, r13 = this.w.config;
      this.seriesIndex = this.getSeriesIndex(t8);
      var o10 = this.getFillColors()[this.seriesIndex];
      void 0 !== e4.globals.seriesColors[this.seriesIndex] && (o10 = e4.globals.seriesColors[this.seriesIndex]), "function" == typeof o10 && (o10 = o10({ seriesIndex: this.seriesIndex, dataPointIndex: t8.dataPointIndex, value: t8.value, w: e4 }));
      var n11 = t8.fillType ? t8.fillType : this.getFillType(this.seriesIndex), l8 = Array.isArray(r13.fill.opacity) ? r13.fill.opacity[this.seriesIndex] : r13.fill.opacity;
      t8.color && (o10 = t8.color), o10 || (o10 = "#fff", console.warn("undefined color - ApexCharts"));
      var h4 = o10;
      if (-1 === o10.indexOf("rgb") ? o10.length < 9 && (h4 = x3.hexToRgba(o10, l8)) : o10.indexOf("rgba") > -1 && (l8 = x3.getOpacityFromRGBA(o10)), t8.opacity && (l8 = t8.opacity), "pattern" === n11 && (a10 = this.handlePatternFill({ fillConfig: t8.fillConfig, patternFill: a10, fillColor: o10, fillOpacity: l8, defaultColor: h4 })), "gradient" === n11 && (s11 = this.handleGradientFill({ fillConfig: t8.fillConfig, fillColor: o10, fillOpacity: l8, i: this.seriesIndex })), "image" === n11) {
        var c7 = r13.fill.image.src, d9 = t8.patternID ? t8.patternID : "";
        this.clippedImgArea({ opacity: l8, image: Array.isArray(c7) ? t8.seriesNumber < c7.length ? c7[t8.seriesNumber] : c7[0] : c7, width: t8.width ? t8.width : void 0, height: t8.height ? t8.height : void 0, patternUnits: t8.patternUnits, patternID: "pattern".concat(e4.globals.cuid).concat(t8.seriesNumber + 1).concat(d9) }), i17 = "url(#pattern".concat(e4.globals.cuid).concat(t8.seriesNumber + 1).concat(d9, ")");
      } else
        i17 = "gradient" === n11 ? s11 : "pattern" === n11 ? a10 : h4;
      return t8.solid && (i17 = h4), i17;
    } }, { key: "getFillType", value: function(t8) {
      var e4 = this.w;
      return Array.isArray(e4.config.fill.type) ? e4.config.fill.type[t8] : e4.config.fill.type;
    } }, { key: "getFillColors", value: function() {
      var t8 = this.w, e4 = t8.config, i17 = this.opts, a10 = [];
      return t8.globals.comboCharts ? "line" === t8.config.series[this.seriesIndex].type ? Array.isArray(t8.globals.stroke.colors) ? a10 = t8.globals.stroke.colors : a10.push(t8.globals.stroke.colors) : Array.isArray(t8.globals.fill.colors) ? a10 = t8.globals.fill.colors : a10.push(t8.globals.fill.colors) : "line" === e4.chart.type ? Array.isArray(t8.globals.stroke.colors) ? a10 = t8.globals.stroke.colors : a10.push(t8.globals.stroke.colors) : Array.isArray(t8.globals.fill.colors) ? a10 = t8.globals.fill.colors : a10.push(t8.globals.fill.colors), void 0 !== i17.fillColors && (a10 = [], Array.isArray(i17.fillColors) ? a10 = i17.fillColors.slice() : a10.push(i17.fillColors)), a10;
    } }, { key: "handlePatternFill", value: function(t8) {
      var e4 = t8.fillConfig, i17 = t8.patternFill, a10 = t8.fillColor, s11 = t8.fillOpacity, r13 = t8.defaultColor, o10 = this.w.config.fill;
      e4 && (o10 = e4);
      var n11 = this.opts, l8 = new m3(this.ctx), h4 = Array.isArray(o10.pattern.strokeWidth) ? o10.pattern.strokeWidth[this.seriesIndex] : o10.pattern.strokeWidth, c7 = a10;
      Array.isArray(o10.pattern.style) ? i17 = void 0 !== o10.pattern.style[n11.seriesNumber] ? l8.drawPattern(o10.pattern.style[n11.seriesNumber], o10.pattern.width, o10.pattern.height, c7, h4, s11) : r13 : i17 = l8.drawPattern(o10.pattern.style, o10.pattern.width, o10.pattern.height, c7, h4, s11);
      return i17;
    } }, { key: "handleGradientFill", value: function(t8) {
      var i17 = t8.fillColor, a10 = t8.fillOpacity, s11 = t8.fillConfig, r13 = t8.i, o10 = this.w.config.fill;
      s11 && (o10 = e3(e3({}, o10), s11));
      var n11, l8 = this.opts, h4 = new m3(this.ctx), c7 = new x3(), d9 = o10.gradient.type, g7 = i17, u6 = void 0 === o10.gradient.opacityFrom ? a10 : Array.isArray(o10.gradient.opacityFrom) ? o10.gradient.opacityFrom[r13] : o10.gradient.opacityFrom;
      g7.indexOf("rgba") > -1 && (u6 = x3.getOpacityFromRGBA(g7));
      var p7 = void 0 === o10.gradient.opacityTo ? a10 : Array.isArray(o10.gradient.opacityTo) ? o10.gradient.opacityTo[r13] : o10.gradient.opacityTo;
      if (void 0 === o10.gradient.gradientToColors || 0 === o10.gradient.gradientToColors.length)
        n11 = "dark" === o10.gradient.shade ? c7.shadeColor(-1 * parseFloat(o10.gradient.shadeIntensity), i17.indexOf("rgb") > -1 ? x3.rgb2hex(i17) : i17) : c7.shadeColor(parseFloat(o10.gradient.shadeIntensity), i17.indexOf("rgb") > -1 ? x3.rgb2hex(i17) : i17);
      else if (o10.gradient.gradientToColors[l8.seriesNumber]) {
        var f5 = o10.gradient.gradientToColors[l8.seriesNumber];
        n11 = f5, f5.indexOf("rgba") > -1 && (p7 = x3.getOpacityFromRGBA(f5));
      } else
        n11 = i17;
      if (o10.gradient.gradientFrom && (g7 = o10.gradient.gradientFrom), o10.gradient.gradientTo && (n11 = o10.gradient.gradientTo), o10.gradient.inverseColors) {
        var b3 = g7;
        g7 = n11, n11 = b3;
      }
      return g7.indexOf("rgb") > -1 && (g7 = x3.rgb2hex(g7)), n11.indexOf("rgb") > -1 && (n11 = x3.rgb2hex(n11)), h4.drawGradient(d9, g7, n11, u6, p7, l8.size, o10.gradient.stops, o10.gradient.colorStops, r13);
    } }]), t7;
  }(), D2 = function() {
    function t7(e4, i17) {
      a9(this, t7), this.ctx = e4, this.w = e4.w;
    }
    return r12(t7, [{ key: "setGlobalMarkerSize", value: function() {
      var t8 = this.w;
      if (t8.globals.markers.size = Array.isArray(t8.config.markers.size) ? t8.config.markers.size : [t8.config.markers.size], t8.globals.markers.size.length > 0) {
        if (t8.globals.markers.size.length < t8.globals.series.length + 1)
          for (var e4 = 0; e4 <= t8.globals.series.length; e4++)
            void 0 === t8.globals.markers.size[e4] && t8.globals.markers.size.push(t8.globals.markers.size[0]);
      } else
        t8.globals.markers.size = t8.config.series.map(function(e5) {
          return t8.config.markers.size;
        });
    } }, { key: "plotChartMarkers", value: function(t8, e4, i17, a10) {
      var s11, r13 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4], o10 = this.w, n11 = e4, l8 = t8, h4 = null, c7 = new m3(this.ctx), d9 = o10.config.markers.discrete && o10.config.markers.discrete.length;
      if ((o10.globals.markers.size[e4] > 0 || r13 || d9) && (h4 = c7.group({ class: r13 || d9 ? "" : "apexcharts-series-markers" })).attr("clip-path", "url(#gridRectMarkerMask".concat(o10.globals.cuid, ")")), Array.isArray(l8.x))
        for (var g7 = 0; g7 < l8.x.length; g7++) {
          var u6 = i17;
          1 === i17 && 0 === g7 && (u6 = 0), 1 === i17 && 1 === g7 && (u6 = 1);
          var p7 = "apexcharts-marker";
          if ("line" !== o10.config.chart.type && "area" !== o10.config.chart.type || o10.globals.comboCharts || o10.config.tooltip.intersect || (p7 += " no-pointer-events"), (Array.isArray(o10.config.markers.size) ? o10.globals.markers.size[e4] > 0 : o10.config.markers.size > 0) || r13 || d9) {
            x3.isNumber(l8.y[g7]) ? p7 += " w".concat(x3.randomId()) : p7 = "apexcharts-nullpoint";
            var f5 = this.getMarkerConfig({ cssClass: p7, seriesIndex: e4, dataPointIndex: u6 });
            o10.config.series[n11].data[u6] && (o10.config.series[n11].data[u6].fillColor && (f5.pointFillColor = o10.config.series[n11].data[u6].fillColor), o10.config.series[n11].data[u6].strokeColor && (f5.pointStrokeColor = o10.config.series[n11].data[u6].strokeColor)), void 0 !== a10 && (f5.pSize = a10), (l8.x[g7] < -o10.globals.markers.largestSize || l8.x[g7] > o10.globals.gridWidth + o10.globals.markers.largestSize || l8.y[g7] < -o10.globals.markers.largestSize || l8.y[g7] > o10.globals.gridHeight + o10.globals.markers.largestSize) && (f5.pSize = 0), (s11 = c7.drawMarker(l8.x[g7], l8.y[g7], f5)).attr("rel", u6), s11.attr("j", u6), s11.attr("index", e4), s11.node.setAttribute("default-marker-size", f5.pSize), new v3(this.ctx).setSelectionFilter(s11, e4, u6), this.addEvents(s11), h4 && h4.add(s11);
          } else
            void 0 === o10.globals.pointsArray[e4] && (o10.globals.pointsArray[e4] = []), o10.globals.pointsArray[e4].push([l8.x[g7], l8.y[g7]]);
        }
      return h4;
    } }, { key: "getMarkerConfig", value: function(t8) {
      var e4 = t8.cssClass, i17 = t8.seriesIndex, a10 = t8.dataPointIndex, s11 = void 0 === a10 ? null : a10, r13 = t8.radius, o10 = void 0 === r13 ? null : r13, n11 = t8.size, l8 = void 0 === n11 ? null : n11, h4 = t8.strokeWidth, c7 = void 0 === h4 ? null : h4, d9 = this.w, g7 = this.getMarkerStyle(i17), u6 = null === l8 ? d9.globals.markers.size[i17] : l8, p7 = d9.config.markers;
      return null !== s11 && p7.discrete.length && p7.discrete.map(function(t9) {
        t9.seriesIndex === i17 && t9.dataPointIndex === s11 && (g7.pointStrokeColor = t9.strokeColor, g7.pointFillColor = t9.fillColor, u6 = t9.size, g7.pointShape = t9.shape);
      }), { pSize: null === o10 ? u6 : o10, pRadius: null !== o10 ? o10 : p7.radius, pointStrokeWidth: null !== c7 ? c7 : Array.isArray(p7.strokeWidth) ? p7.strokeWidth[i17] : p7.strokeWidth, pointStrokeColor: g7.pointStrokeColor, pointFillColor: g7.pointFillColor, shape: g7.pointShape || (Array.isArray(p7.shape) ? p7.shape[i17] : p7.shape), class: e4, pointStrokeOpacity: Array.isArray(p7.strokeOpacity) ? p7.strokeOpacity[i17] : p7.strokeOpacity, pointStrokeDashArray: Array.isArray(p7.strokeDashArray) ? p7.strokeDashArray[i17] : p7.strokeDashArray, pointFillOpacity: Array.isArray(p7.fillOpacity) ? p7.fillOpacity[i17] : p7.fillOpacity, seriesIndex: i17 };
    } }, { key: "addEvents", value: function(t8) {
      var e4 = this.w, i17 = new m3(this.ctx);
      t8.node.addEventListener("mouseenter", i17.pathMouseEnter.bind(this.ctx, t8)), t8.node.addEventListener("mouseleave", i17.pathMouseLeave.bind(this.ctx, t8)), t8.node.addEventListener("mousedown", i17.pathMouseDown.bind(this.ctx, t8)), t8.node.addEventListener("click", e4.config.markers.onClick), t8.node.addEventListener("dblclick", e4.config.markers.onDblClick), t8.node.addEventListener("touchstart", i17.pathMouseDown.bind(this.ctx, t8), { passive: true });
    } }, { key: "getMarkerStyle", value: function(t8) {
      var e4 = this.w, i17 = e4.globals.markers.colors, a10 = e4.config.markers.strokeColor || e4.config.markers.strokeColors;
      return { pointStrokeColor: Array.isArray(a10) ? a10[t8] : a10, pointFillColor: Array.isArray(i17) ? i17[t8] : i17 };
    } }]), t7;
  }(), O2 = function() {
    function t7(e4) {
      a9(this, t7), this.ctx = e4, this.w = e4.w, this.initialAnim = this.w.config.chart.animations.enabled;
    }
    return r12(t7, [{ key: "draw", value: function(t8, e4, i17) {
      var a10 = this.w, s11 = new m3(this.ctx), r13 = i17.realIndex, o10 = i17.pointsPos, n11 = i17.zRatio, l8 = i17.elParent, h4 = s11.group({ class: "apexcharts-series-markers apexcharts-series-".concat(a10.config.chart.type) });
      if (h4.attr("clip-path", "url(#gridRectMarkerMask".concat(a10.globals.cuid, ")")), Array.isArray(o10.x))
        for (var c7 = 0; c7 < o10.x.length; c7++) {
          var d9 = e4 + 1, g7 = true;
          0 === e4 && 0 === c7 && (d9 = 0), 0 === e4 && 1 === c7 && (d9 = 1);
          var u6 = a10.globals.markers.size[r13];
          if (n11 !== 1 / 0) {
            var p7 = a10.config.plotOptions.bubble;
            u6 = a10.globals.seriesZ[r13][d9], p7.zScaling && (u6 /= n11), p7.minBubbleRadius && u6 < p7.minBubbleRadius && (u6 = p7.minBubbleRadius), p7.maxBubbleRadius && u6 > p7.maxBubbleRadius && (u6 = p7.maxBubbleRadius);
          }
          var f5 = o10.x[c7], x4 = o10.y[c7];
          if (u6 = u6 || 0, null !== x4 && void 0 !== a10.globals.series[r13][d9] || (g7 = false), g7) {
            var b3 = this.drawPoint(f5, x4, u6, r13, d9, e4);
            h4.add(b3);
          }
          l8.add(h4);
        }
    } }, { key: "drawPoint", value: function(t8, e4, i17, a10, s11, r13) {
      var o10 = this.w, n11 = a10, l8 = new b2(this.ctx), h4 = new v3(this.ctx), c7 = new H3(this.ctx), d9 = new D2(this.ctx), g7 = new m3(this.ctx), u6 = d9.getMarkerConfig({ cssClass: "apexcharts-marker", seriesIndex: n11, dataPointIndex: s11, radius: "bubble" === o10.config.chart.type || o10.globals.comboCharts && o10.config.series[a10] && "bubble" === o10.config.series[a10].type ? i17 : null }), p7 = c7.fillPath({ seriesNumber: a10, dataPointIndex: s11, color: u6.pointFillColor, patternUnits: "objectBoundingBox", value: o10.globals.series[a10][r13] }), f5 = g7.drawMarker(t8, e4, u6);
      if (o10.config.series[n11].data[s11] && o10.config.series[n11].data[s11].fillColor && (p7 = o10.config.series[n11].data[s11].fillColor), f5.attr({ fill: p7 }), o10.config.chart.dropShadow.enabled) {
        var x4 = o10.config.chart.dropShadow;
        h4.dropShadow(f5, x4, a10);
      }
      if (!this.initialAnim || o10.globals.dataChanged || o10.globals.resized)
        o10.globals.animationEnded = true;
      else {
        var y5 = o10.config.chart.animations.speed;
        l8.animateMarker(f5, y5, o10.globals.easing, function() {
          window.setTimeout(function() {
            l8.animationCompleted(f5);
          }, 100);
        });
      }
      return f5.attr({ rel: s11, j: s11, index: a10, "default-marker-size": u6.pSize }), h4.setSelectionFilter(f5, a10, s11), d9.addEvents(f5), f5.node.classList.add("apexcharts-marker"), f5;
    } }, { key: "centerTextInBubble", value: function(t8) {
      var e4 = this.w;
      return { y: t8 += parseInt(e4.config.dataLabels.style.fontSize, 10) / 4 };
    } }]), t7;
  }(), N3 = function() {
    function t7(e4) {
      a9(this, t7), this.ctx = e4, this.w = e4.w;
    }
    return r12(t7, [{ key: "dataLabelsCorrection", value: function(t8, e4, i17, a10, s11, r13, o10) {
      var n11 = this.w, l8 = false, h4 = new m3(this.ctx).getTextRects(i17, o10), c7 = h4.width, d9 = h4.height;
      e4 < 0 && (e4 = 0), e4 > n11.globals.gridHeight + d9 && (e4 = n11.globals.gridHeight + d9 / 2), void 0 === n11.globals.dataLabelsRects[a10] && (n11.globals.dataLabelsRects[a10] = []), n11.globals.dataLabelsRects[a10].push({ x: t8, y: e4, width: c7, height: d9 });
      var g7 = n11.globals.dataLabelsRects[a10].length - 2, u6 = void 0 !== n11.globals.lastDrawnDataLabelsIndexes[a10] ? n11.globals.lastDrawnDataLabelsIndexes[a10][n11.globals.lastDrawnDataLabelsIndexes[a10].length - 1] : 0;
      if (void 0 !== n11.globals.dataLabelsRects[a10][g7]) {
        var p7 = n11.globals.dataLabelsRects[a10][u6];
        (t8 > p7.x + p7.width || e4 > p7.y + p7.height || e4 + d9 < p7.y || t8 + c7 < p7.x) && (l8 = true);
      }
      return (0 === s11 || r13) && (l8 = true), { x: t8, y: e4, textRects: h4, drawnextLabel: l8 };
    } }, { key: "drawDataLabel", value: function(t8) {
      var e4 = this, i17 = t8.type, a10 = t8.pos, s11 = t8.i, r13 = t8.j, o10 = t8.isRangeStart, n11 = t8.strokeWidth, l8 = void 0 === n11 ? 2 : n11, h4 = this.w, c7 = new m3(this.ctx), d9 = h4.config.dataLabels, g7 = 0, u6 = 0, p7 = r13, f5 = null;
      if (-1 !== h4.globals.collapsedSeriesIndices.indexOf(s11) || !d9.enabled || !Array.isArray(a10.x))
        return f5;
      f5 = c7.group({ class: "apexcharts-data-labels" });
      for (var x4 = 0; x4 < a10.x.length; x4++)
        if (g7 = a10.x[x4] + d9.offsetX, u6 = a10.y[x4] + d9.offsetY + l8, !isNaN(g7)) {
          1 === r13 && 0 === x4 && (p7 = 0), 1 === r13 && 1 === x4 && (p7 = 1);
          var b3 = h4.globals.series[s11][p7];
          "rangeArea" === i17 && (b3 = o10 ? h4.globals.seriesRangeStart[s11][p7] : h4.globals.seriesRangeEnd[s11][p7]);
          var v5 = "", y5 = function(t9) {
            return h4.config.dataLabels.formatter(t9, { ctx: e4.ctx, seriesIndex: s11, dataPointIndex: p7, w: h4 });
          };
          if ("bubble" === h4.config.chart.type)
            v5 = y5(b3 = h4.globals.seriesZ[s11][p7]), u6 = a10.y[x4], u6 = new O2(this.ctx).centerTextInBubble(u6, s11, p7).y;
          else
            void 0 !== b3 && (v5 = y5(b3));
          var w4 = h4.config.dataLabels.textAnchor;
          h4.globals.isSlopeChart && (w4 = 0 === p7 ? "end" : p7 === h4.config.series[s11].data.length - 1 ? "start" : "middle"), this.plotDataLabelsText({ x: g7, y: u6, text: v5, i: s11, j: p7, parent: f5, offsetCorrection: true, dataLabelsConfig: h4.config.dataLabels, textAnchor: w4 });
        }
      return f5;
    } }, { key: "plotDataLabelsText", value: function(t8) {
      var e4 = this.w, i17 = new m3(this.ctx), a10 = t8.x, s11 = t8.y, r13 = t8.i, o10 = t8.j, n11 = t8.text, l8 = t8.textAnchor, h4 = t8.fontSize, c7 = t8.parent, d9 = t8.dataLabelsConfig, g7 = t8.color, u6 = t8.alwaysDrawDataLabel, p7 = t8.offsetCorrection, f5 = t8.className, x4 = null;
      if (Array.isArray(e4.config.dataLabels.enabledOnSeries) && e4.config.dataLabels.enabledOnSeries.indexOf(r13) < 0)
        return x4;
      var b3 = { x: a10, y: s11, drawnextLabel: true, textRects: null };
      p7 && (b3 = this.dataLabelsCorrection(a10, s11, n11, r13, o10, u6, parseInt(d9.style.fontSize, 10))), e4.globals.zoomed || (a10 = b3.x, s11 = b3.y), b3.textRects && (a10 < -20 - b3.textRects.width || a10 > e4.globals.gridWidth + b3.textRects.width + 30) && (n11 = "");
      var y5 = e4.globals.dataLabels.style.colors[r13];
      (("bar" === e4.config.chart.type || "rangeBar" === e4.config.chart.type) && e4.config.plotOptions.bar.distributed || e4.config.dataLabels.distributed) && (y5 = e4.globals.dataLabels.style.colors[o10]), "function" == typeof y5 && (y5 = y5({ series: e4.globals.series, seriesIndex: r13, dataPointIndex: o10, w: e4 })), g7 && (y5 = g7);
      var w4 = d9.offsetX, k4 = d9.offsetY;
      if ("bar" !== e4.config.chart.type && "rangeBar" !== e4.config.chart.type || (w4 = 0, k4 = 0), e4.globals.isSlopeChart && (0 !== o10 && (w4 = -2 * d9.offsetX + 5), 0 !== o10 && o10 !== e4.config.series[r13].data.length - 1 && (w4 = 0)), b3.drawnextLabel) {
        if ((x4 = i17.drawText({ width: 100, height: parseInt(d9.style.fontSize, 10), x: a10 + w4, y: s11 + k4, foreColor: y5, textAnchor: l8 || d9.textAnchor, text: n11, fontSize: h4 || d9.style.fontSize, fontFamily: d9.style.fontFamily, fontWeight: d9.style.fontWeight || "normal" })).attr({ class: f5 || "apexcharts-datalabel", cx: a10, cy: s11 }), d9.dropShadow.enabled) {
          var A3 = d9.dropShadow;
          new v3(this.ctx).dropShadow(x4, A3);
        }
        c7.add(x4), void 0 === e4.globals.lastDrawnDataLabelsIndexes[r13] && (e4.globals.lastDrawnDataLabelsIndexes[r13] = []), e4.globals.lastDrawnDataLabelsIndexes[r13].push(o10);
      }
      return x4;
    } }, { key: "addBackgroundToDataLabel", value: function(t8, e4) {
      var i17 = this.w, a10 = i17.config.dataLabels.background, s11 = a10.padding, r13 = a10.padding / 2, o10 = e4.width, n11 = e4.height, l8 = new m3(this.ctx).drawRect(e4.x - s11, e4.y - r13 / 2, o10 + 2 * s11, n11 + r13, a10.borderRadius, "transparent" !== i17.config.chart.background && i17.config.chart.background ? i17.config.chart.background : "#fff", a10.opacity, a10.borderWidth, a10.borderColor);
      a10.dropShadow.enabled && new v3(this.ctx).dropShadow(l8, a10.dropShadow);
      return l8;
    } }, { key: "dataLabelsBackground", value: function() {
      var t8 = this.w;
      if ("bubble" !== t8.config.chart.type)
        for (var e4 = t8.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels text"), i17 = 0; i17 < e4.length; i17++) {
          var a10 = e4[i17], s11 = a10.getBBox(), r13 = null;
          if (s11.width && s11.height && (r13 = this.addBackgroundToDataLabel(a10, s11)), r13) {
            a10.parentNode.insertBefore(r13.node, a10);
            var o10 = a10.getAttribute("fill");
            t8.config.chart.animations.enabled && !t8.globals.resized && !t8.globals.dataChanged ? r13.animate().attr({ fill: o10 }) : r13.attr({ fill: o10 }), a10.setAttribute("fill", t8.config.dataLabels.background.foreColor);
          }
        }
    } }, { key: "bringForward", value: function() {
      for (var t8 = this.w, e4 = t8.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels"), i17 = t8.globals.dom.baseEl.querySelector(".apexcharts-plot-series:last-child"), a10 = 0; a10 < e4.length; a10++)
        i17 && i17.insertBefore(e4[a10], i17.nextSibling);
    } }]), t7;
  }(), W3 = function() {
    function t7(e4) {
      a9(this, t7), this.ctx = e4, this.w = e4.w, this.legendInactiveClass = "legend-mouseover-inactive";
    }
    return r12(t7, [{ key: "getAllSeriesEls", value: function() {
      return this.w.globals.dom.baseEl.getElementsByClassName("apexcharts-series");
    } }, { key: "getSeriesByName", value: function(t8) {
      return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner .apexcharts-series[seriesName='".concat(x3.escapeString(t8), "']"));
    } }, { key: "isSeriesHidden", value: function(t8) {
      var e4 = this.getSeriesByName(t8), i17 = parseInt(e4.getAttribute("data:realIndex"), 10);
      return { isHidden: e4.classList.contains("apexcharts-series-collapsed"), realIndex: i17 };
    } }, { key: "addCollapsedClassToSeries", value: function(t8, e4) {
      var i17 = this.w;
      function a10(i18) {
        for (var a11 = 0; a11 < i18.length; a11++)
          i18[a11].index === e4 && t8.node.classList.add("apexcharts-series-collapsed");
      }
      a10(i17.globals.collapsedSeries), a10(i17.globals.ancillaryCollapsedSeries);
    } }, { key: "toggleSeries", value: function(t8) {
      var e4 = this.isSeriesHidden(t8);
      return this.ctx.legend.legendHelpers.toggleDataSeries(e4.realIndex, e4.isHidden), e4.isHidden;
    } }, { key: "showSeries", value: function(t8) {
      var e4 = this.isSeriesHidden(t8);
      e4.isHidden && this.ctx.legend.legendHelpers.toggleDataSeries(e4.realIndex, true);
    } }, { key: "hideSeries", value: function(t8) {
      var e4 = this.isSeriesHidden(t8);
      e4.isHidden || this.ctx.legend.legendHelpers.toggleDataSeries(e4.realIndex, false);
    } }, { key: "resetSeries", value: function() {
      var t8 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], e4 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i17 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], a10 = this.w, s11 = x3.clone(a10.globals.initialSeries);
      a10.globals.previousPaths = [], i17 ? (a10.globals.collapsedSeries = [], a10.globals.ancillaryCollapsedSeries = [], a10.globals.collapsedSeriesIndices = [], a10.globals.ancillaryCollapsedSeriesIndices = []) : s11 = this.emptyCollapsedSeries(s11), a10.config.series = s11, t8 && (e4 && (a10.globals.zoomed = false, this.ctx.updateHelpers.revertDefaultAxisMinMax()), this.ctx.updateHelpers._updateSeries(s11, a10.config.chart.animations.dynamicAnimation.enabled));
    } }, { key: "emptyCollapsedSeries", value: function(t8) {
      for (var e4 = this.w, i17 = 0; i17 < t8.length; i17++)
        e4.globals.collapsedSeriesIndices.indexOf(i17) > -1 && (t8[i17].data = []);
      return t8;
    } }, { key: "toggleSeriesOnHover", value: function(t8, e4) {
      var i17 = this.w;
      e4 || (e4 = t8.target);
      var a10 = i17.globals.dom.baseEl.querySelectorAll(".apexcharts-series, .apexcharts-datalabels, .apexcharts-yaxis");
      if ("mousemove" === t8.type) {
        var s11 = parseInt(e4.getAttribute("rel"), 10) - 1, r13 = null, o10 = null, n11 = null;
        if (i17.globals.axisCharts || "radialBar" === i17.config.chart.type)
          if (i17.globals.axisCharts) {
            r13 = i17.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(s11, "']")), o10 = i17.globals.dom.baseEl.querySelector(".apexcharts-datalabels[data\\:realIndex='".concat(s11, "']"));
            var l8 = i17.globals.seriesYAxisReverseMap[s11];
            n11 = i17.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(l8, "']"));
          } else
            r13 = i17.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(s11 + 1, "']"));
        else
          r13 = i17.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(s11 + 1, "'] path"));
        for (var h4 = 0; h4 < a10.length; h4++)
          a10[h4].classList.add(this.legendInactiveClass);
        null !== r13 && (i17.globals.axisCharts || r13.parentNode.classList.remove(this.legendInactiveClass), r13.classList.remove(this.legendInactiveClass), null !== o10 && o10.classList.remove(this.legendInactiveClass), null !== n11 && n11.classList.remove(this.legendInactiveClass));
      } else if ("mouseout" === t8.type)
        for (var c7 = 0; c7 < a10.length; c7++)
          a10[c7].classList.remove(this.legendInactiveClass);
    } }, { key: "highlightRangeInSeries", value: function(t8, e4) {
      var i17 = this, a10 = this.w, s11 = a10.globals.dom.baseEl.getElementsByClassName("apexcharts-heatmap-rect"), r13 = function(t9) {
        for (var e5 = 0; e5 < s11.length; e5++)
          s11[e5].classList[t9](i17.legendInactiveClass);
      };
      if ("mousemove" === t8.type) {
        var o10 = parseInt(e4.getAttribute("rel"), 10) - 1;
        r13("add"), function(t9) {
          for (var e5 = 0; e5 < s11.length; e5++) {
            var a11 = parseInt(s11[e5].getAttribute("val"), 10);
            a11 >= t9.from && a11 <= t9.to && s11[e5].classList.remove(i17.legendInactiveClass);
          }
        }(a10.config.plotOptions.heatmap.colorScale.ranges[o10]);
      } else
        "mouseout" === t8.type && r13("remove");
    } }, { key: "getActiveConfigSeriesIndex", value: function() {
      var t8 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "asc", e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [], i17 = this.w, a10 = 0;
      if (i17.config.series.length > 1) {
        for (var s11 = i17.config.series.map(function(t9, a11) {
          return t9.data && t9.data.length > 0 && -1 === i17.globals.collapsedSeriesIndices.indexOf(a11) && (!i17.globals.comboCharts || 0 === e4.length || e4.length && e4.indexOf(i17.config.series[a11].type) > -1) ? a11 : -1;
        }), r13 = "asc" === t8 ? 0 : s11.length - 1; "asc" === t8 ? r13 < s11.length : r13 >= 0; "asc" === t8 ? r13++ : r13--)
          if (-1 !== s11[r13]) {
            a10 = s11[r13];
            break;
          }
      }
      return a10;
    } }, { key: "getBarSeriesIndices", value: function() {
      return this.w.globals.comboCharts ? this.w.config.series.map(function(t8, e4) {
        return "bar" === t8.type || "column" === t8.type ? e4 : -1;
      }).filter(function(t8) {
        return -1 !== t8;
      }) : this.w.config.series.map(function(t8, e4) {
        return e4;
      });
    } }, { key: "getPreviousPaths", value: function() {
      var t8 = this.w;
      function e4(e5, i18, a11) {
        for (var s12 = e5[i18].childNodes, r13 = { type: a11, paths: [], realIndex: e5[i18].getAttribute("data:realIndex") }, o10 = 0; o10 < s12.length; o10++)
          if (s12[o10].hasAttribute("pathTo")) {
            var n11 = s12[o10].getAttribute("pathTo");
            r13.paths.push({ d: n11 });
          }
        t8.globals.previousPaths.push(r13);
      }
      t8.globals.previousPaths = [];
      ["line", "area", "bar", "rangebar", "rangeArea", "candlestick", "radar"].forEach(function(i18) {
        for (var a11, s12 = (a11 = i18, t8.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(a11, "-series .apexcharts-series"))), r13 = 0; r13 < s12.length; r13++)
          e4(s12, r13, i18);
      }), this.handlePrevBubbleScatterPaths("bubble"), this.handlePrevBubbleScatterPaths("scatter");
      var i17 = t8.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t8.config.chart.type, " .apexcharts-series"));
      if (i17.length > 0)
        for (var a10 = function(e5) {
          for (var i18 = t8.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t8.config.chart.type, " .apexcharts-series[data\\:realIndex='").concat(e5, "'] rect")), a11 = [], s12 = function(t9) {
            var e6 = function(e7) {
              return i18[t9].getAttribute(e7);
            }, s13 = { x: parseFloat(e6("x")), y: parseFloat(e6("y")), width: parseFloat(e6("width")), height: parseFloat(e6("height")) };
            a11.push({ rect: s13, color: i18[t9].getAttribute("color") });
          }, r13 = 0; r13 < i18.length; r13++)
            s12(r13);
          t8.globals.previousPaths.push(a11);
        }, s11 = 0; s11 < i17.length; s11++)
          a10(s11);
      t8.globals.axisCharts || (t8.globals.previousPaths = t8.globals.series);
    } }, { key: "handlePrevBubbleScatterPaths", value: function(t8) {
      var e4 = this.w, i17 = e4.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t8, "-series .apexcharts-series"));
      if (i17.length > 0)
        for (var a10 = 0; a10 < i17.length; a10++) {
          for (var s11 = e4.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t8, "-series .apexcharts-series[data\\:realIndex='").concat(a10, "'] circle")), r13 = [], o10 = 0; o10 < s11.length; o10++)
            r13.push({ x: s11[o10].getAttribute("cx"), y: s11[o10].getAttribute("cy"), r: s11[o10].getAttribute("r") });
          e4.globals.previousPaths.push(r13);
        }
    } }, { key: "clearPreviousPaths", value: function() {
      var t8 = this.w;
      t8.globals.previousPaths = [], t8.globals.allSeriesCollapsed = false;
    } }, { key: "handleNoData", value: function() {
      var t8 = this.w, e4 = t8.config.noData, i17 = new m3(this.ctx), a10 = t8.globals.svgWidth / 2, s11 = t8.globals.svgHeight / 2, r13 = "middle";
      if (t8.globals.noData = true, t8.globals.animationEnded = true, "left" === e4.align ? (a10 = 10, r13 = "start") : "right" === e4.align && (a10 = t8.globals.svgWidth - 10, r13 = "end"), "top" === e4.verticalAlign ? s11 = 50 : "bottom" === e4.verticalAlign && (s11 = t8.globals.svgHeight - 50), a10 += e4.offsetX, s11 = s11 + parseInt(e4.style.fontSize, 10) + 2 + e4.offsetY, void 0 !== e4.text && "" !== e4.text) {
        var o10 = i17.drawText({ x: a10, y: s11, text: e4.text, textAnchor: r13, fontSize: e4.style.fontSize, fontFamily: e4.style.fontFamily, foreColor: e4.style.color, opacity: 1, class: "apexcharts-text-nodata" });
        t8.globals.dom.Paper.add(o10);
      }
    } }, { key: "setNullSeriesToZeroValues", value: function(t8) {
      for (var e4 = this.w, i17 = 0; i17 < t8.length; i17++)
        if (0 === t8[i17].length)
          for (var a10 = 0; a10 < t8[e4.globals.maxValsInArrayIndex].length; a10++)
            t8[i17].push(0);
      return t8;
    } }, { key: "hasAllSeriesEqualX", value: function() {
      for (var t8 = true, e4 = this.w, i17 = this.filteredSeriesX(), a10 = 0; a10 < i17.length - 1; a10++)
        if (i17[a10][0] !== i17[a10 + 1][0]) {
          t8 = false;
          break;
        }
      return e4.globals.allSeriesHasEqualX = t8, t8;
    } }, { key: "filteredSeriesX", value: function() {
      var t8 = this.w.globals.seriesX.map(function(t9) {
        return t9.length > 0 ? t9 : [];
      });
      return t8;
    } }]), t7;
  }(), B2 = function() {
    function t7(e4) {
      a9(this, t7), this.ctx = e4, this.w = e4.w, this.twoDSeries = [], this.threeDSeries = [], this.twoDSeriesX = [], this.seriesGoals = [], this.coreUtils = new y4(this.ctx);
    }
    return r12(t7, [{ key: "isMultiFormat", value: function() {
      return this.isFormatXY() || this.isFormat2DArray();
    } }, { key: "isFormatXY", value: function() {
      var t8 = this.w.config.series.slice(), e4 = new W3(this.ctx);
      if (this.activeSeriesIndex = e4.getActiveConfigSeriesIndex(), void 0 !== t8[this.activeSeriesIndex].data && t8[this.activeSeriesIndex].data.length > 0 && null !== t8[this.activeSeriesIndex].data[0] && void 0 !== t8[this.activeSeriesIndex].data[0].x && null !== t8[this.activeSeriesIndex].data[0])
        return true;
    } }, { key: "isFormat2DArray", value: function() {
      var t8 = this.w.config.series.slice(), e4 = new W3(this.ctx);
      if (this.activeSeriesIndex = e4.getActiveConfigSeriesIndex(), void 0 !== t8[this.activeSeriesIndex].data && t8[this.activeSeriesIndex].data.length > 0 && void 0 !== t8[this.activeSeriesIndex].data[0] && null !== t8[this.activeSeriesIndex].data[0] && t8[this.activeSeriesIndex].data[0].constructor === Array)
        return true;
    } }, { key: "handleFormat2DArray", value: function(t8, e4) {
      for (var i17 = this.w.config, a10 = this.w.globals, s11 = "boxPlot" === i17.chart.type || "boxPlot" === i17.series[e4].type, r13 = 0; r13 < t8[e4].data.length; r13++)
        if (void 0 !== t8[e4].data[r13][1] && (Array.isArray(t8[e4].data[r13][1]) && 4 === t8[e4].data[r13][1].length && !s11 ? this.twoDSeries.push(x3.parseNumber(t8[e4].data[r13][1][3])) : t8[e4].data[r13].length >= 5 ? this.twoDSeries.push(x3.parseNumber(t8[e4].data[r13][4])) : this.twoDSeries.push(x3.parseNumber(t8[e4].data[r13][1])), a10.dataFormatXNumeric = true), "datetime" === i17.xaxis.type) {
          var o10 = new Date(t8[e4].data[r13][0]);
          o10 = new Date(o10).getTime(), this.twoDSeriesX.push(o10);
        } else
          this.twoDSeriesX.push(t8[e4].data[r13][0]);
      for (var n11 = 0; n11 < t8[e4].data.length; n11++)
        void 0 !== t8[e4].data[n11][2] && (this.threeDSeries.push(t8[e4].data[n11][2]), a10.isDataXYZ = true);
    } }, { key: "handleFormatXY", value: function(t8, e4) {
      var i17 = this.w.config, a10 = this.w.globals, s11 = new A2(this.ctx), r13 = e4;
      a10.collapsedSeriesIndices.indexOf(e4) > -1 && (r13 = this.activeSeriesIndex);
      for (var o10 = 0; o10 < t8[e4].data.length; o10++)
        void 0 !== t8[e4].data[o10].y && (Array.isArray(t8[e4].data[o10].y) ? this.twoDSeries.push(x3.parseNumber(t8[e4].data[o10].y[t8[e4].data[o10].y.length - 1])) : this.twoDSeries.push(x3.parseNumber(t8[e4].data[o10].y))), void 0 !== t8[e4].data[o10].goals && Array.isArray(t8[e4].data[o10].goals) ? (void 0 === this.seriesGoals[e4] && (this.seriesGoals[e4] = []), this.seriesGoals[e4].push(t8[e4].data[o10].goals)) : (void 0 === this.seriesGoals[e4] && (this.seriesGoals[e4] = []), this.seriesGoals[e4].push(null));
      for (var n11 = 0; n11 < t8[r13].data.length; n11++) {
        var l8 = "string" == typeof t8[r13].data[n11].x, h4 = Array.isArray(t8[r13].data[n11].x), c7 = !h4 && !!s11.isValidDate(t8[r13].data[n11].x);
        if (l8 || c7)
          if (l8 || i17.xaxis.convertedCatToNumeric) {
            var d9 = a10.isBarHorizontal && a10.isRangeData;
            "datetime" !== i17.xaxis.type || d9 ? (this.fallbackToCategory = true, this.twoDSeriesX.push(t8[r13].data[n11].x), isNaN(t8[r13].data[n11].x) || "category" === this.w.config.xaxis.type || "string" == typeof t8[r13].data[n11].x || (a10.isXNumeric = true)) : this.twoDSeriesX.push(s11.parseDate(t8[r13].data[n11].x));
          } else
            "datetime" === i17.xaxis.type ? this.twoDSeriesX.push(s11.parseDate(t8[r13].data[n11].x.toString())) : (a10.dataFormatXNumeric = true, a10.isXNumeric = true, this.twoDSeriesX.push(parseFloat(t8[r13].data[n11].x)));
        else
          h4 ? (this.fallbackToCategory = true, this.twoDSeriesX.push(t8[r13].data[n11].x)) : (a10.isXNumeric = true, a10.dataFormatXNumeric = true, this.twoDSeriesX.push(t8[r13].data[n11].x));
      }
      if (t8[e4].data[0] && void 0 !== t8[e4].data[0].z) {
        for (var g7 = 0; g7 < t8[e4].data.length; g7++)
          this.threeDSeries.push(t8[e4].data[g7].z);
        a10.isDataXYZ = true;
      }
    } }, { key: "handleRangeData", value: function(t8, e4) {
      var i17 = this.w.globals, a10 = {};
      return this.isFormat2DArray() ? a10 = this.handleRangeDataFormat("array", t8, e4) : this.isFormatXY() && (a10 = this.handleRangeDataFormat("xy", t8, e4)), i17.seriesRangeStart.push(void 0 === a10.start ? [] : a10.start), i17.seriesRangeEnd.push(void 0 === a10.end ? [] : a10.end), i17.seriesRange.push(a10.rangeUniques), i17.seriesRange.forEach(function(t9, e5) {
        t9 && t9.forEach(function(t10, e6) {
          t10.y.forEach(function(e7, i18) {
            for (var a11 = 0; a11 < t10.y.length; a11++)
              if (i18 !== a11) {
                var s11 = e7.y1, r13 = e7.y2, o10 = t10.y[a11].y1;
                s11 <= t10.y[a11].y2 && o10 <= r13 && (t10.overlaps.indexOf(e7.rangeName) < 0 && t10.overlaps.push(e7.rangeName), t10.overlaps.indexOf(t10.y[a11].rangeName) < 0 && t10.overlaps.push(t10.y[a11].rangeName));
              }
          });
        });
      }), a10;
    } }, { key: "handleCandleStickBoxData", value: function(t8, e4) {
      var i17 = this.w.globals, a10 = {};
      return this.isFormat2DArray() ? a10 = this.handleCandleStickBoxDataFormat("array", t8, e4) : this.isFormatXY() && (a10 = this.handleCandleStickBoxDataFormat("xy", t8, e4)), i17.seriesCandleO[e4] = a10.o, i17.seriesCandleH[e4] = a10.h, i17.seriesCandleM[e4] = a10.m, i17.seriesCandleL[e4] = a10.l, i17.seriesCandleC[e4] = a10.c, a10;
    } }, { key: "handleRangeDataFormat", value: function(t8, e4, i17) {
      var a10 = [], s11 = [], r13 = e4[i17].data.filter(function(t9, e5, i18) {
        return e5 === i18.findIndex(function(e6) {
          return e6.x === t9.x;
        });
      }).map(function(t9, e5) {
        return { x: t9.x, overlaps: [], y: [] };
      });
      if ("array" === t8)
        for (var o10 = 0; o10 < e4[i17].data.length; o10++)
          Array.isArray(e4[i17].data[o10]) ? (a10.push(e4[i17].data[o10][1][0]), s11.push(e4[i17].data[o10][1][1])) : (a10.push(e4[i17].data[o10]), s11.push(e4[i17].data[o10]));
      else if ("xy" === t8)
        for (var n11 = function(t9) {
          var o11 = Array.isArray(e4[i17].data[t9].y), n12 = x3.randomId(), l9 = e4[i17].data[t9].x, h4 = { y1: o11 ? e4[i17].data[t9].y[0] : e4[i17].data[t9].y, y2: o11 ? e4[i17].data[t9].y[1] : e4[i17].data[t9].y, rangeName: n12 };
          e4[i17].data[t9].rangeName = n12;
          var c7 = r13.findIndex(function(t10) {
            return t10.x === l9;
          });
          r13[c7].y.push(h4), a10.push(h4.y1), s11.push(h4.y2);
        }, l8 = 0; l8 < e4[i17].data.length; l8++)
          n11(l8);
      return { start: a10, end: s11, rangeUniques: r13 };
    } }, { key: "handleCandleStickBoxDataFormat", value: function(t8, e4, i17) {
      var a10 = this.w, s11 = "boxPlot" === a10.config.chart.type || "boxPlot" === a10.config.series[i17].type, r13 = [], o10 = [], n11 = [], l8 = [], h4 = [];
      if ("array" === t8)
        if (s11 && 6 === e4[i17].data[0].length || !s11 && 5 === e4[i17].data[0].length)
          for (var c7 = 0; c7 < e4[i17].data.length; c7++)
            r13.push(e4[i17].data[c7][1]), o10.push(e4[i17].data[c7][2]), s11 ? (n11.push(e4[i17].data[c7][3]), l8.push(e4[i17].data[c7][4]), h4.push(e4[i17].data[c7][5])) : (l8.push(e4[i17].data[c7][3]), h4.push(e4[i17].data[c7][4]));
        else
          for (var d9 = 0; d9 < e4[i17].data.length; d9++)
            Array.isArray(e4[i17].data[d9][1]) && (r13.push(e4[i17].data[d9][1][0]), o10.push(e4[i17].data[d9][1][1]), s11 ? (n11.push(e4[i17].data[d9][1][2]), l8.push(e4[i17].data[d9][1][3]), h4.push(e4[i17].data[d9][1][4])) : (l8.push(e4[i17].data[d9][1][2]), h4.push(e4[i17].data[d9][1][3])));
      else if ("xy" === t8)
        for (var g7 = 0; g7 < e4[i17].data.length; g7++)
          Array.isArray(e4[i17].data[g7].y) && (r13.push(e4[i17].data[g7].y[0]), o10.push(e4[i17].data[g7].y[1]), s11 ? (n11.push(e4[i17].data[g7].y[2]), l8.push(e4[i17].data[g7].y[3]), h4.push(e4[i17].data[g7].y[4])) : (l8.push(e4[i17].data[g7].y[2]), h4.push(e4[i17].data[g7].y[3])));
      return { o: r13, h: o10, m: n11, l: l8, c: h4 };
    } }, { key: "parseDataAxisCharts", value: function(t8) {
      var e4 = this, i17 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.ctx, a10 = this.w.config, s11 = this.w.globals, r13 = new A2(i17), o10 = a10.labels.length > 0 ? a10.labels.slice() : a10.xaxis.categories.slice();
      s11.isRangeBar = "rangeBar" === a10.chart.type && s11.isBarHorizontal, s11.hasXaxisGroups = "category" === a10.xaxis.type && a10.xaxis.group.groups.length > 0, s11.hasXaxisGroups && (s11.groups = a10.xaxis.group.groups), t8.forEach(function(t9, e5) {
        void 0 !== t9.name ? s11.seriesNames.push(t9.name) : s11.seriesNames.push("series-" + parseInt(e5 + 1, 10));
      }), this.coreUtils.setSeriesYAxisMappings();
      var n11 = [], l8 = u5(new Set(a10.series.map(function(t9) {
        return t9.group;
      })));
      a10.series.forEach(function(t9, e5) {
        var i18 = l8.indexOf(t9.group);
        n11[i18] || (n11[i18] = []), n11[i18].push(s11.seriesNames[e5]);
      }), s11.seriesGroups = n11;
      for (var h4 = function() {
        for (var t9 = 0; t9 < o10.length; t9++)
          if ("string" == typeof o10[t9]) {
            if (!r13.isValidDate(o10[t9]))
              throw new Error("You have provided invalid Date format. Please provide a valid JavaScript Date");
            e4.twoDSeriesX.push(r13.parseDate(o10[t9]));
          } else
            e4.twoDSeriesX.push(o10[t9]);
      }, c7 = 0; c7 < t8.length; c7++) {
        if (this.twoDSeries = [], this.twoDSeriesX = [], this.threeDSeries = [], void 0 === t8[c7].data)
          return void console.error("It is a possibility that you may have not included 'data' property in series.");
        if ("rangeBar" !== a10.chart.type && "rangeArea" !== a10.chart.type && "rangeBar" !== t8[c7].type && "rangeArea" !== t8[c7].type || (s11.isRangeData = true, "rangeBar" !== a10.chart.type && "rangeArea" !== a10.chart.type || this.handleRangeData(t8, c7)), this.isMultiFormat())
          this.isFormat2DArray() ? this.handleFormat2DArray(t8, c7) : this.isFormatXY() && this.handleFormatXY(t8, c7), "candlestick" !== a10.chart.type && "candlestick" !== t8[c7].type && "boxPlot" !== a10.chart.type && "boxPlot" !== t8[c7].type || this.handleCandleStickBoxData(t8, c7), s11.series.push(this.twoDSeries), s11.labels.push(this.twoDSeriesX), s11.seriesX.push(this.twoDSeriesX), s11.seriesGoals = this.seriesGoals, c7 !== this.activeSeriesIndex || this.fallbackToCategory || (s11.isXNumeric = true);
        else {
          "datetime" === a10.xaxis.type ? (s11.isXNumeric = true, h4(), s11.seriesX.push(this.twoDSeriesX)) : "numeric" === a10.xaxis.type && (s11.isXNumeric = true, o10.length > 0 && (this.twoDSeriesX = o10, s11.seriesX.push(this.twoDSeriesX))), s11.labels.push(this.twoDSeriesX);
          var d9 = t8[c7].data.map(function(t9) {
            return x3.parseNumber(t9);
          });
          s11.series.push(d9);
        }
        s11.seriesZ.push(this.threeDSeries), void 0 !== t8[c7].color ? s11.seriesColors.push(t8[c7].color) : s11.seriesColors.push(void 0);
      }
      return this.w;
    } }, { key: "parseDataNonAxisCharts", value: function(t8) {
      var e4 = this.w.globals, i17 = this.w.config;
      e4.series = t8.slice(), e4.seriesNames = i17.labels.slice();
      for (var a10 = 0; a10 < e4.series.length; a10++)
        void 0 === e4.seriesNames[a10] && e4.seriesNames.push("series-" + (a10 + 1));
      return this.w;
    } }, { key: "handleExternalLabelsData", value: function(t8) {
      var e4 = this.w.config, i17 = this.w.globals;
      if (e4.xaxis.categories.length > 0)
        i17.labels = e4.xaxis.categories;
      else if (e4.labels.length > 0)
        i17.labels = e4.labels.slice();
      else if (this.fallbackToCategory) {
        if (i17.labels = i17.labels[0], i17.seriesRange.length && (i17.seriesRange.map(function(t9) {
          t9.forEach(function(t10) {
            i17.labels.indexOf(t10.x) < 0 && t10.x && i17.labels.push(t10.x);
          });
        }), i17.labels = Array.from(new Set(i17.labels.map(JSON.stringify)), JSON.parse)), e4.xaxis.convertedCatToNumeric)
          new E2(e4).convertCatToNumericXaxis(e4, this.ctx, i17.seriesX[0]), this._generateExternalLabels(t8);
      } else
        this._generateExternalLabels(t8);
    } }, { key: "_generateExternalLabels", value: function(t8) {
      var e4 = this.w.globals, i17 = this.w.config, a10 = [];
      if (e4.axisCharts) {
        if (e4.series.length > 0)
          if (this.isFormatXY())
            for (var s11 = i17.series.map(function(t9, e5) {
              return t9.data.filter(function(t10, e6, i18) {
                return i18.findIndex(function(e7) {
                  return e7.x === t10.x;
                }) === e6;
              });
            }), r13 = s11.reduce(function(t9, e5, i18, a11) {
              return a11[t9].length > e5.length ? t9 : i18;
            }, 0), o10 = 0; o10 < s11[r13].length; o10++)
              a10.push(o10 + 1);
          else
            for (var n11 = 0; n11 < e4.series[e4.maxValsInArrayIndex].length; n11++)
              a10.push(n11 + 1);
        e4.seriesX = [];
        for (var l8 = 0; l8 < t8.length; l8++)
          e4.seriesX.push(a10);
        this.w.globals.isBarHorizontal || (e4.isXNumeric = true);
      }
      if (0 === a10.length) {
        a10 = e4.axisCharts ? [] : e4.series.map(function(t9, e5) {
          return e5 + 1;
        });
        for (var h4 = 0; h4 < t8.length; h4++)
          e4.seriesX.push(a10);
      }
      e4.labels = a10, i17.xaxis.convertedCatToNumeric && (e4.categoryLabels = a10.map(function(t9) {
        return i17.xaxis.labels.formatter(t9);
      })), e4.noLabelsProvided = true;
    } }, { key: "parseData", value: function(t8) {
      var e4 = this.w, i17 = e4.config, a10 = e4.globals;
      if (this.excludeCollapsedSeriesInYAxis(), this.fallbackToCategory = false, this.ctx.core.resetGlobals(), this.ctx.core.isMultipleY(), a10.axisCharts ? (this.parseDataAxisCharts(t8), this.coreUtils.getLargestSeries()) : this.parseDataNonAxisCharts(t8), i17.chart.stacked) {
        var s11 = new W3(this.ctx);
        a10.series = s11.setNullSeriesToZeroValues(a10.series);
      }
      this.coreUtils.getSeriesTotals(), a10.axisCharts && (a10.stackedSeriesTotals = this.coreUtils.getStackedSeriesTotals(), a10.stackedSeriesTotalsByGroups = this.coreUtils.getStackedSeriesTotalsByGroups()), this.coreUtils.getPercentSeries(), a10.dataFormatXNumeric || a10.isXNumeric && ("numeric" !== i17.xaxis.type || 0 !== i17.labels.length || 0 !== i17.xaxis.categories.length) || this.handleExternalLabelsData(t8);
      for (var r13 = this.coreUtils.getCategoryLabels(a10.labels), o10 = 0; o10 < r13.length; o10++)
        if (Array.isArray(r13[o10])) {
          a10.isMultiLineX = true;
          break;
        }
    } }, { key: "excludeCollapsedSeriesInYAxis", value: function() {
      var t8 = this.w, e4 = [];
      t8.globals.seriesYAxisMap.forEach(function(i17, a10) {
        var s11 = 0;
        i17.forEach(function(e5) {
          -1 !== t8.globals.collapsedSeriesIndices.indexOf(e5) && s11++;
        }), s11 > 0 && s11 == i17.length && e4.push(a10);
      }), t8.globals.ignoreYAxisIndexes = e4.map(function(t9) {
        return t9;
      });
    } }]), t7;
  }(), G2 = function() {
    function t7(e4) {
      a9(this, t7), this.ctx = e4, this.w = e4.w;
    }
    return r12(t7, [{ key: "scaleSvgNode", value: function(t8, e4) {
      var i17 = parseFloat(t8.getAttributeNS(null, "width")), a10 = parseFloat(t8.getAttributeNS(null, "height"));
      t8.setAttributeNS(null, "width", i17 * e4), t8.setAttributeNS(null, "height", a10 * e4), t8.setAttributeNS(null, "viewBox", "0 0 " + i17 + " " + a10);
    } }, { key: "fixSvgStringForIe11", value: function(t8) {
      if (!x3.isIE11())
        return t8.replace(/&nbsp;/g, "&#160;");
      var e4 = 0, i17 = t8.replace(/xmlns="http:\/\/www.w3.org\/2000\/svg"/g, function(t9) {
        return 2 === ++e4 ? 'xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.dev"' : t9;
      });
      return i17 = (i17 = i17.replace(/xmlns:NS\d+=""/g, "")).replace(/NS\d+:(\w+:\w+=")/g, "$1");
    } }, { key: "getSvgString", value: function(t8) {
      null == t8 && (t8 = 1);
      var e4 = this.w.globals.dom.Paper.svg();
      if (1 !== t8) {
        var i17 = this.w.globals.dom.Paper.node.cloneNode(true);
        this.scaleSvgNode(i17, t8), e4 = new XMLSerializer().serializeToString(i17);
      }
      return this.fixSvgStringForIe11(e4);
    } }, { key: "cleanup", value: function() {
      var t8 = this.w, e4 = t8.globals.dom.baseEl.getElementsByClassName("apexcharts-xcrosshairs"), i17 = t8.globals.dom.baseEl.getElementsByClassName("apexcharts-ycrosshairs"), a10 = t8.globals.dom.baseEl.querySelectorAll(".apexcharts-zoom-rect, .apexcharts-selection-rect");
      Array.prototype.forEach.call(a10, function(t9) {
        t9.setAttribute("width", 0);
      }), e4 && e4[0] && (e4[0].setAttribute("x", -500), e4[0].setAttribute("x1", -500), e4[0].setAttribute("x2", -500)), i17 && i17[0] && (i17[0].setAttribute("y", -100), i17[0].setAttribute("y1", -100), i17[0].setAttribute("y2", -100));
    } }, { key: "svgUrl", value: function() {
      this.cleanup();
      var t8 = this.getSvgString(), e4 = new Blob([t8], { type: "image/svg+xml;charset=utf-8" });
      return URL.createObjectURL(e4);
    } }, { key: "dataURI", value: function(t8) {
      var e4 = this;
      return new Promise(function(i17) {
        var a10 = e4.w, s11 = t8 ? t8.scale || t8.width / a10.globals.svgWidth : 1;
        e4.cleanup();
        var r13 = document.createElement("canvas");
        r13.width = a10.globals.svgWidth * s11, r13.height = parseInt(a10.globals.dom.elWrap.style.height, 10) * s11;
        var o10 = "transparent" !== a10.config.chart.background && a10.config.chart.background ? a10.config.chart.background : "#fff", n11 = r13.getContext("2d");
        n11.fillStyle = o10, n11.fillRect(0, 0, r13.width * s11, r13.height * s11);
        var l8 = e4.getSvgString(s11);
        if (window.canvg && x3.isIE11()) {
          var h4 = window.canvg.Canvg.fromString(n11, l8, { ignoreClear: true, ignoreDimensions: true });
          h4.start();
          var c7 = r13.msToBlob();
          h4.stop(), i17({ blob: c7 });
        } else {
          var d9 = "data:image/svg+xml," + encodeURIComponent(l8), g7 = new Image();
          g7.crossOrigin = "anonymous", g7.onload = function() {
            if (n11.drawImage(g7, 0, 0), r13.msToBlob) {
              var t9 = r13.msToBlob();
              i17({ blob: t9 });
            } else {
              var e5 = r13.toDataURL("image/png");
              i17({ imgURI: e5 });
            }
          }, g7.src = d9;
        }
      });
    } }, { key: "exportToSVG", value: function() {
      this.triggerDownload(this.svgUrl(), this.w.config.chart.toolbar.export.svg.filename, ".svg");
    } }, { key: "exportToPng", value: function() {
      var t8 = this;
      this.dataURI().then(function(e4) {
        var i17 = e4.imgURI, a10 = e4.blob;
        a10 ? navigator.msSaveOrOpenBlob(a10, t8.w.globals.chartID + ".png") : t8.triggerDownload(i17, t8.w.config.chart.toolbar.export.png.filename, ".png");
      });
    } }, { key: "exportToCSV", value: function(t8) {
      var e4 = this, i17 = t8.series, a10 = t8.fileName, s11 = t8.columnDelimiter, r13 = void 0 === s11 ? "," : s11, o10 = t8.lineDelimiter, n11 = void 0 === o10 ? "\n" : o10, l8 = this.w;
      i17 || (i17 = l8.config.series);
      var h4, c7, d9 = [], g7 = [], p7 = "", f5 = l8.globals.series.map(function(t9, e5) {
        return -1 === l8.globals.collapsedSeriesIndices.indexOf(e5) ? t9 : [];
      }), b3 = function(t9) {
        return "function" == typeof l8.config.chart.toolbar.export.csv.categoryFormatter ? l8.config.chart.toolbar.export.csv.categoryFormatter(t9) : "datetime" === l8.config.xaxis.type && String(t9).length >= 10 ? new Date(t9).toDateString() : x3.isNumber(t9) ? t9 : t9.split(r13).join("");
      }, v5 = function(t9) {
        return "function" == typeof l8.config.chart.toolbar.export.csv.valueFormatter ? l8.config.chart.toolbar.export.csv.valueFormatter(t9) : t9;
      }, m4 = Math.max.apply(Math, u5(i17.map(function(t9) {
        return t9.data ? t9.data.length : 0;
      }))), y5 = new B2(this.ctx), w4 = new C2(this.ctx), k4 = function(t9) {
        var i18 = "";
        if (l8.globals.axisCharts) {
          if ("category" === l8.config.xaxis.type || l8.config.xaxis.convertedCatToNumeric)
            if (l8.globals.isBarHorizontal) {
              var a11 = l8.globals.yLabelFormatters[0], s12 = new W3(e4.ctx).getActiveConfigSeriesIndex();
              i18 = a11(l8.globals.labels[t9], { seriesIndex: s12, dataPointIndex: t9, w: l8 });
            } else
              i18 = w4.getLabel(l8.globals.labels, l8.globals.timescaleLabels, 0, t9).text;
          "datetime" === l8.config.xaxis.type && (l8.config.xaxis.categories.length ? i18 = l8.config.xaxis.categories[t9] : l8.config.labels.length && (i18 = l8.config.labels[t9]));
        } else
          i18 = l8.config.labels[t9];
        return null === i18 ? "nullvalue" : (Array.isArray(i18) && (i18 = i18.join(" ")), x3.isNumber(i18) ? i18 : i18.split(r13).join(""));
      }, A3 = function(t9, e5) {
        if (d9.length && 0 === e5 && g7.push(d9.join(r13)), t9.data) {
          t9.data = t9.data.length && t9.data || u5(Array(m4)).map(function() {
            return "";
          });
          for (var a11 = 0; a11 < t9.data.length; a11++) {
            d9 = [];
            var s12 = k4(a11);
            if ("nullvalue" !== s12) {
              if (s12 || (y5.isFormatXY() ? s12 = i17[e5].data[a11].x : y5.isFormat2DArray() && (s12 = i17[e5].data[a11] ? i17[e5].data[a11][0] : "")), 0 === e5) {
                d9.push(b3(s12));
                for (var o11 = 0; o11 < l8.globals.series.length; o11++) {
                  var n12, h5 = y5.isFormatXY() ? null === (n12 = i17[o11].data[a11]) || void 0 === n12 ? void 0 : n12.y : f5[o11][a11];
                  d9.push(v5(h5));
                }
              }
              ("candlestick" === l8.config.chart.type || t9.type && "candlestick" === t9.type) && (d9.pop(), d9.push(l8.globals.seriesCandleO[e5][a11]), d9.push(l8.globals.seriesCandleH[e5][a11]), d9.push(l8.globals.seriesCandleL[e5][a11]), d9.push(l8.globals.seriesCandleC[e5][a11])), ("boxPlot" === l8.config.chart.type || t9.type && "boxPlot" === t9.type) && (d9.pop(), d9.push(l8.globals.seriesCandleO[e5][a11]), d9.push(l8.globals.seriesCandleH[e5][a11]), d9.push(l8.globals.seriesCandleM[e5][a11]), d9.push(l8.globals.seriesCandleL[e5][a11]), d9.push(l8.globals.seriesCandleC[e5][a11])), "rangeBar" === l8.config.chart.type && (d9.pop(), d9.push(l8.globals.seriesRangeStart[e5][a11]), d9.push(l8.globals.seriesRangeEnd[e5][a11])), d9.length && g7.push(d9.join(r13));
            }
          }
        }
      };
      d9.push(l8.config.chart.toolbar.export.csv.headerCategory), "boxPlot" === l8.config.chart.type ? (d9.push("minimum"), d9.push("q1"), d9.push("median"), d9.push("q3"), d9.push("maximum")) : "candlestick" === l8.config.chart.type ? (d9.push("open"), d9.push("high"), d9.push("low"), d9.push("close")) : "rangeBar" === l8.config.chart.type ? (d9.push("minimum"), d9.push("maximum")) : i17.map(function(t9, e5) {
        var i18 = (t9.name ? t9.name : "series-".concat(e5)) + "";
        l8.globals.axisCharts && d9.push(i18.split(r13).join("") ? i18.split(r13).join("") : "series-".concat(e5));
      }), l8.globals.axisCharts || (d9.push(l8.config.chart.toolbar.export.csv.headerValue), g7.push(d9.join(r13))), l8.globals.allSeriesHasEqualX || !l8.globals.axisCharts || l8.config.xaxis.categories.length || l8.config.labels.length ? i17.map(function(t9, e5) {
        l8.globals.axisCharts ? A3(t9, e5) : ((d9 = []).push(b3(l8.globals.labels[e5])), d9.push(v5(f5[e5])), g7.push(d9.join(r13)));
      }) : (h4 = /* @__PURE__ */ new Set(), c7 = {}, i17.forEach(function(t9, e5) {
        null == t9 || t9.data.forEach(function(t10) {
          var a11, s12;
          if (y5.isFormatXY())
            a11 = t10.x, s12 = t10.y;
          else {
            if (!y5.isFormat2DArray())
              return;
            a11 = t10[0], s12 = t10[1];
          }
          c7[a11] || (c7[a11] = Array(i17.length).fill("")), c7[a11][e5] = v5(s12), h4.add(a11);
        });
      }), d9.length && g7.push(d9.join(r13)), Array.from(h4).sort().forEach(function(t9) {
        g7.push([b3(t9), c7[t9].join(r13)]);
      })), p7 += g7.join(n11), this.triggerDownload("data:text/csv; charset=utf-8," + encodeURIComponent("\uFEFF" + p7), a10 || l8.config.chart.toolbar.export.csv.filename, ".csv");
    } }, { key: "triggerDownload", value: function(t8, e4, i17) {
      var a10 = document.createElement("a");
      a10.href = t8, a10.download = (e4 || this.w.globals.chartID) + i17, document.body.appendChild(a10), a10.click(), document.body.removeChild(a10);
    } }]), t7;
  }(), V3 = function() {
    function t7(e4, i17) {
      a9(this, t7), this.ctx = e4, this.elgrid = i17, this.w = e4.w;
      var s11 = this.w;
      this.axesUtils = new C2(e4), this.xaxisLabels = s11.globals.labels.slice(), s11.globals.timescaleLabels.length > 0 && !s11.globals.isBarHorizontal && (this.xaxisLabels = s11.globals.timescaleLabels.slice()), s11.config.xaxis.overwriteCategories && (this.xaxisLabels = s11.config.xaxis.overwriteCategories), this.drawnLabels = [], this.drawnLabelsRects = [], "top" === s11.config.xaxis.position ? this.offY = 0 : this.offY = s11.globals.gridHeight, this.offY = this.offY + s11.config.xaxis.axisBorder.offsetY, this.isCategoryBarHorizontal = "bar" === s11.config.chart.type && s11.config.plotOptions.bar.horizontal, this.xaxisFontSize = s11.config.xaxis.labels.style.fontSize, this.xaxisFontFamily = s11.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = s11.config.xaxis.labels.style.colors, this.xaxisBorderWidth = s11.config.xaxis.axisBorder.width, this.isCategoryBarHorizontal && (this.xaxisBorderWidth = s11.config.yaxis[0].axisBorder.width.toString()), this.xaxisBorderWidth.indexOf("%") > -1 ? this.xaxisBorderWidth = s11.globals.gridWidth * parseInt(this.xaxisBorderWidth, 10) / 100 : this.xaxisBorderWidth = parseInt(this.xaxisBorderWidth, 10), this.xaxisBorderHeight = s11.config.xaxis.axisBorder.height, this.yaxis = s11.config.yaxis[0];
    }
    return r12(t7, [{ key: "drawXaxis", value: function() {
      var t8 = this.w, e4 = new m3(this.ctx), i17 = e4.group({ class: "apexcharts-xaxis", transform: "translate(".concat(t8.config.xaxis.offsetX, ", ").concat(t8.config.xaxis.offsetY, ")") }), a10 = e4.group({ class: "apexcharts-xaxis-texts-g", transform: "translate(".concat(t8.globals.translateXAxisX, ", ").concat(t8.globals.translateXAxisY, ")") });
      i17.add(a10);
      for (var s11 = [], r13 = 0; r13 < this.xaxisLabels.length; r13++)
        s11.push(this.xaxisLabels[r13]);
      if (this.drawXAxisLabelAndGroup(true, e4, a10, s11, t8.globals.isXNumeric, function(t9, e5) {
        return e5;
      }), t8.globals.hasXaxisGroups) {
        var o10 = t8.globals.groups;
        s11 = [];
        for (var n11 = 0; n11 < o10.length; n11++)
          s11.push(o10[n11].title);
        var l8 = {};
        t8.config.xaxis.group.style && (l8.xaxisFontSize = t8.config.xaxis.group.style.fontSize, l8.xaxisFontFamily = t8.config.xaxis.group.style.fontFamily, l8.xaxisForeColors = t8.config.xaxis.group.style.colors, l8.fontWeight = t8.config.xaxis.group.style.fontWeight, l8.cssClass = t8.config.xaxis.group.style.cssClass), this.drawXAxisLabelAndGroup(false, e4, a10, s11, false, function(t9, e5) {
          return o10[t9].cols * e5;
        }, l8);
      }
      if (void 0 !== t8.config.xaxis.title.text) {
        var h4 = e4.group({ class: "apexcharts-xaxis-title" }), c7 = e4.drawText({ x: t8.globals.gridWidth / 2 + t8.config.xaxis.title.offsetX, y: this.offY + parseFloat(this.xaxisFontSize) + ("bottom" === t8.config.xaxis.position ? t8.globals.xAxisLabelsHeight : -t8.globals.xAxisLabelsHeight - 10) + t8.config.xaxis.title.offsetY, text: t8.config.xaxis.title.text, textAnchor: "middle", fontSize: t8.config.xaxis.title.style.fontSize, fontFamily: t8.config.xaxis.title.style.fontFamily, fontWeight: t8.config.xaxis.title.style.fontWeight, foreColor: t8.config.xaxis.title.style.color, cssClass: "apexcharts-xaxis-title-text " + t8.config.xaxis.title.style.cssClass });
        h4.add(c7), i17.add(h4);
      }
      if (t8.config.xaxis.axisBorder.show) {
        var d9 = t8.globals.barPadForNumericAxis, g7 = e4.drawLine(t8.globals.padHorizontal + t8.config.xaxis.axisBorder.offsetX - d9, this.offY, this.xaxisBorderWidth + d9, this.offY, t8.config.xaxis.axisBorder.color, 0, this.xaxisBorderHeight);
        this.elgrid && this.elgrid.elGridBorders && t8.config.grid.show ? this.elgrid.elGridBorders.add(g7) : i17.add(g7);
      }
      return i17;
    } }, { key: "drawXAxisLabelAndGroup", value: function(t8, e4, i17, a10, s11, r13) {
      var o10, n11 = this, l8 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : {}, h4 = [], c7 = [], d9 = this.w, g7 = l8.xaxisFontSize || this.xaxisFontSize, u6 = l8.xaxisFontFamily || this.xaxisFontFamily, p7 = l8.xaxisForeColors || this.xaxisForeColors, f5 = l8.fontWeight || d9.config.xaxis.labels.style.fontWeight, x4 = l8.cssClass || d9.config.xaxis.labels.style.cssClass, b3 = d9.globals.padHorizontal, v5 = a10.length, m4 = "category" === d9.config.xaxis.type ? d9.globals.dataPoints : v5;
      if (0 === m4 && v5 > m4 && (m4 = v5), s11) {
        var y5 = m4 > 1 ? m4 - 1 : m4;
        o10 = d9.globals.gridWidth / Math.min(y5, v5 - 1), b3 = b3 + r13(0, o10) / 2 + d9.config.xaxis.labels.offsetX;
      } else
        o10 = d9.globals.gridWidth / m4, b3 = b3 + r13(0, o10) + d9.config.xaxis.labels.offsetX;
      for (var w4 = function(s12) {
        var l9 = b3 - r13(s12, o10) / 2 + d9.config.xaxis.labels.offsetX;
        0 === s12 && 1 === v5 && o10 / 2 === b3 && 1 === m4 && (l9 = d9.globals.gridWidth / 2);
        var y6 = n11.axesUtils.getLabel(a10, d9.globals.timescaleLabels, l9, s12, h4, g7, t8), w5 = 28;
        d9.globals.rotateXLabels && t8 && (w5 = 22), d9.config.xaxis.title.text && "top" === d9.config.xaxis.position && (w5 += parseFloat(d9.config.xaxis.title.style.fontSize) + 2), t8 || (w5 = w5 + parseFloat(g7) + (d9.globals.xAxisLabelsHeight - d9.globals.xAxisGroupLabelsHeight) + (d9.globals.rotateXLabels ? 10 : 0)), y6 = void 0 !== d9.config.xaxis.tickAmount && "dataPoints" !== d9.config.xaxis.tickAmount && "datetime" !== d9.config.xaxis.type ? n11.axesUtils.checkLabelBasedOnTickamount(s12, y6, v5) : n11.axesUtils.checkForOverflowingLabels(s12, y6, v5, h4, c7);
        if (d9.config.xaxis.labels.show) {
          var k5 = e4.drawText({ x: y6.x, y: n11.offY + d9.config.xaxis.labels.offsetY + w5 - ("top" === d9.config.xaxis.position ? d9.globals.xAxisHeight + d9.config.xaxis.axisTicks.height - 2 : 0), text: y6.text, textAnchor: "middle", fontWeight: y6.isBold ? 600 : f5, fontSize: g7, fontFamily: u6, foreColor: Array.isArray(p7) ? t8 && d9.config.xaxis.convertedCatToNumeric ? p7[d9.globals.minX + s12 - 1] : p7[s12] : p7, isPlainText: false, cssClass: (t8 ? "apexcharts-xaxis-label " : "apexcharts-xaxis-group-label ") + x4 });
          if (i17.add(k5), k5.on("click", function(t9) {
            if ("function" == typeof d9.config.chart.events.xAxisLabelClick) {
              var e5 = Object.assign({}, d9, { labelIndex: s12 });
              d9.config.chart.events.xAxisLabelClick(t9, n11.ctx, e5);
            }
          }), t8) {
            var A3 = document.createElementNS(d9.globals.SVGNS, "title");
            A3.textContent = Array.isArray(y6.text) ? y6.text.join(" ") : y6.text, k5.node.appendChild(A3), "" !== y6.text && (h4.push(y6.text), c7.push(y6));
          }
        }
        s12 < v5 - 1 && (b3 += r13(s12 + 1, o10));
      }, k4 = 0; k4 <= v5 - 1; k4++)
        w4(k4);
    } }, { key: "drawXaxisInversed", value: function(t8) {
      var e4, i17, a10 = this, s11 = this.w, r13 = new m3(this.ctx), o10 = s11.config.yaxis[0].opposite ? s11.globals.translateYAxisX[t8] : 0, n11 = r13.group({ class: "apexcharts-yaxis apexcharts-xaxis-inversed", rel: t8 }), l8 = r13.group({ class: "apexcharts-yaxis-texts-g apexcharts-xaxis-inversed-texts-g", transform: "translate(" + o10 + ", 0)" });
      n11.add(l8);
      var h4 = [];
      if (s11.config.yaxis[t8].show)
        for (var c7 = 0; c7 < this.xaxisLabels.length; c7++)
          h4.push(this.xaxisLabels[c7]);
      e4 = s11.globals.gridHeight / h4.length, i17 = -e4 / 2.2;
      var d9 = s11.globals.yLabelFormatters[0], g7 = s11.config.yaxis[0].labels;
      if (g7.show)
        for (var u6 = function(o11) {
          var n12 = void 0 === h4[o11] ? "" : h4[o11];
          n12 = d9(n12, { seriesIndex: t8, dataPointIndex: o11, w: s11 });
          var c8 = a10.axesUtils.getYAxisForeColor(g7.style.colors, t8), u7 = 0;
          Array.isArray(n12) && (u7 = n12.length / 2 * parseInt(g7.style.fontSize, 10));
          var p8 = g7.offsetX - 15, f6 = "end";
          a10.yaxis.opposite && (f6 = "start"), "left" === s11.config.yaxis[0].labels.align ? (p8 = g7.offsetX, f6 = "start") : "center" === s11.config.yaxis[0].labels.align ? (p8 = g7.offsetX, f6 = "middle") : "right" === s11.config.yaxis[0].labels.align && (f6 = "end");
          var x5 = r13.drawText({ x: p8, y: i17 + e4 + g7.offsetY - u7, text: n12, textAnchor: f6, foreColor: Array.isArray(c8) ? c8[o11] : c8, fontSize: g7.style.fontSize, fontFamily: g7.style.fontFamily, fontWeight: g7.style.fontWeight, isPlainText: false, cssClass: "apexcharts-yaxis-label " + g7.style.cssClass, maxWidth: g7.maxWidth });
          l8.add(x5), x5.on("click", function(t9) {
            if ("function" == typeof s11.config.chart.events.xAxisLabelClick) {
              var e5 = Object.assign({}, s11, { labelIndex: o11 });
              s11.config.chart.events.xAxisLabelClick(t9, a10.ctx, e5);
            }
          });
          var b4 = document.createElementNS(s11.globals.SVGNS, "title");
          if (b4.textContent = Array.isArray(n12) ? n12.join(" ") : n12, x5.node.appendChild(b4), 0 !== s11.config.yaxis[t8].labels.rotate) {
            var v6 = r13.rotateAroundCenter(x5.node);
            x5.node.setAttribute("transform", "rotate(".concat(s11.config.yaxis[t8].labels.rotate, " 0 ").concat(v6.y, ")"));
          }
          i17 += e4;
        }, p7 = 0; p7 <= h4.length - 1; p7++)
          u6(p7);
      if (void 0 !== s11.config.yaxis[0].title.text) {
        var f5 = r13.group({ class: "apexcharts-yaxis-title apexcharts-xaxis-title-inversed", transform: "translate(" + o10 + ", 0)" }), x4 = r13.drawText({ x: s11.config.yaxis[0].title.offsetX, y: s11.globals.gridHeight / 2 + s11.config.yaxis[0].title.offsetY, text: s11.config.yaxis[0].title.text, textAnchor: "middle", foreColor: s11.config.yaxis[0].title.style.color, fontSize: s11.config.yaxis[0].title.style.fontSize, fontWeight: s11.config.yaxis[0].title.style.fontWeight, fontFamily: s11.config.yaxis[0].title.style.fontFamily, cssClass: "apexcharts-yaxis-title-text " + s11.config.yaxis[0].title.style.cssClass });
        f5.add(x4), n11.add(f5);
      }
      var b3 = 0;
      this.isCategoryBarHorizontal && s11.config.yaxis[0].opposite && (b3 = s11.globals.gridWidth);
      var v5 = s11.config.xaxis.axisBorder;
      if (v5.show) {
        var y5 = r13.drawLine(s11.globals.padHorizontal + v5.offsetX + b3, 1 + v5.offsetY, s11.globals.padHorizontal + v5.offsetX + b3, s11.globals.gridHeight + v5.offsetY, v5.color, 0);
        this.elgrid && this.elgrid.elGridBorders && s11.config.grid.show ? this.elgrid.elGridBorders.add(y5) : n11.add(y5);
      }
      return s11.config.yaxis[0].axisTicks.show && this.axesUtils.drawYAxisTicks(b3, h4.length, s11.config.yaxis[0].axisBorder, s11.config.yaxis[0].axisTicks, 0, e4, n11), n11;
    } }, { key: "drawXaxisTicks", value: function(t8, e4, i17) {
      var a10 = this.w, s11 = t8;
      if (!(t8 < 0 || t8 - 2 > a10.globals.gridWidth)) {
        var r13 = this.offY + a10.config.xaxis.axisTicks.offsetY;
        if (e4 = e4 + r13 + a10.config.xaxis.axisTicks.height, "top" === a10.config.xaxis.position && (e4 = r13 - a10.config.xaxis.axisTicks.height), a10.config.xaxis.axisTicks.show) {
          var o10 = new m3(this.ctx).drawLine(t8 + a10.config.xaxis.axisTicks.offsetX, r13 + a10.config.xaxis.offsetY, s11 + a10.config.xaxis.axisTicks.offsetX, e4 + a10.config.xaxis.offsetY, a10.config.xaxis.axisTicks.color);
          i17.add(o10), o10.node.classList.add("apexcharts-xaxis-tick");
        }
      }
    } }, { key: "getXAxisTicksPositions", value: function() {
      var t8 = this.w, e4 = [], i17 = this.xaxisLabels.length, a10 = t8.globals.padHorizontal;
      if (t8.globals.timescaleLabels.length > 0)
        for (var s11 = 0; s11 < i17; s11++)
          a10 = this.xaxisLabels[s11].position, e4.push(a10);
      else
        for (var r13 = i17, o10 = 0; o10 < r13; o10++) {
          var n11 = r13;
          t8.globals.isXNumeric && "bar" !== t8.config.chart.type && (n11 -= 1), a10 += t8.globals.gridWidth / n11, e4.push(a10);
        }
      return e4;
    } }, { key: "xAxisLabelCorrections", value: function() {
      var t8 = this.w, e4 = new m3(this.ctx), i17 = t8.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g"), a10 = t8.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-texts-g text:not(.apexcharts-xaxis-group-label)"), s11 = t8.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-inversed text"), r13 = t8.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-inversed-texts-g text tspan");
      if (t8.globals.rotateXLabels || t8.config.xaxis.labels.rotateAlways)
        for (var o10 = 0; o10 < a10.length; o10++) {
          var n11 = e4.rotateAroundCenter(a10[o10]);
          n11.y = n11.y - 1, n11.x = n11.x + 1, a10[o10].setAttribute("transform", "rotate(".concat(t8.config.xaxis.labels.rotate, " ").concat(n11.x, " ").concat(n11.y, ")")), a10[o10].setAttribute("text-anchor", "end");
          i17.setAttribute("transform", "translate(0, ".concat(-10, ")"));
          var l8 = a10[o10].childNodes;
          t8.config.xaxis.labels.trim && Array.prototype.forEach.call(l8, function(i18) {
            e4.placeTextWithEllipsis(i18, i18.textContent, t8.globals.xAxisLabelsHeight - ("bottom" === t8.config.legend.position ? 20 : 10));
          });
        }
      else
        !function() {
          for (var i18 = t8.globals.gridWidth / (t8.globals.labels.length + 1), s12 = 0; s12 < a10.length; s12++) {
            var r14 = a10[s12].childNodes;
            t8.config.xaxis.labels.trim && "datetime" !== t8.config.xaxis.type && Array.prototype.forEach.call(r14, function(t9) {
              e4.placeTextWithEllipsis(t9, t9.textContent, i18);
            });
          }
        }();
      if (s11.length > 0) {
        var h4 = s11[s11.length - 1].getBBox(), c7 = s11[0].getBBox();
        h4.x < -20 && s11[s11.length - 1].parentNode.removeChild(s11[s11.length - 1]), c7.x + c7.width > t8.globals.gridWidth && !t8.globals.isBarHorizontal && s11[0].parentNode.removeChild(s11[0]);
        for (var d9 = 0; d9 < r13.length; d9++)
          e4.placeTextWithEllipsis(r13[d9], r13[d9].textContent, t8.config.yaxis[0].labels.maxWidth - (t8.config.yaxis[0].title.text ? 2 * parseFloat(t8.config.yaxis[0].title.style.fontSize) : 0) - 15);
      }
    } }]), t7;
  }(), j2 = function() {
    function t7(e4) {
      a9(this, t7), this.ctx = e4, this.w = e4.w;
      var i17 = this.w;
      this.xaxisLabels = i17.globals.labels.slice(), this.axesUtils = new C2(e4), this.isRangeBar = i17.globals.seriesRange.length && i17.globals.isBarHorizontal, i17.globals.timescaleLabels.length > 0 && (this.xaxisLabels = i17.globals.timescaleLabels.slice());
    }
    return r12(t7, [{ key: "drawGridArea", value: function() {
      var t8 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, e4 = this.w, i17 = new m3(this.ctx);
      null === t8 && (t8 = i17.group({ class: "apexcharts-grid" }));
      var a10 = i17.drawLine(e4.globals.padHorizontal, 1, e4.globals.padHorizontal, e4.globals.gridHeight, "transparent"), s11 = i17.drawLine(e4.globals.padHorizontal, e4.globals.gridHeight, e4.globals.gridWidth, e4.globals.gridHeight, "transparent");
      return t8.add(s11), t8.add(a10), t8;
    } }, { key: "drawGrid", value: function() {
      var t8 = null;
      return this.w.globals.axisCharts && (t8 = this.renderGrid(), this.drawGridArea(t8.el)), t8;
    } }, { key: "createGridMask", value: function() {
      var t8 = this.w, e4 = t8.globals, i17 = new m3(this.ctx), a10 = Array.isArray(t8.config.stroke.width) ? 0 : t8.config.stroke.width;
      if (Array.isArray(t8.config.stroke.width)) {
        var s11 = 0;
        t8.config.stroke.width.forEach(function(t9) {
          s11 = Math.max(s11, t9);
        }), a10 = s11;
      }
      e4.dom.elGridRectMask = document.createElementNS(e4.SVGNS, "clipPath"), e4.dom.elGridRectMask.setAttribute("id", "gridRectMask".concat(e4.cuid)), e4.dom.elGridRectMarkerMask = document.createElementNS(e4.SVGNS, "clipPath"), e4.dom.elGridRectMarkerMask.setAttribute("id", "gridRectMarkerMask".concat(e4.cuid)), e4.dom.elForecastMask = document.createElementNS(e4.SVGNS, "clipPath"), e4.dom.elForecastMask.setAttribute("id", "forecastMask".concat(e4.cuid)), e4.dom.elNonForecastMask = document.createElementNS(e4.SVGNS, "clipPath"), e4.dom.elNonForecastMask.setAttribute("id", "nonForecastMask".concat(e4.cuid));
      var r13 = t8.config.chart.type, o10 = 0, n11 = 0;
      ("bar" === r13 || "rangeBar" === r13 || "candlestick" === r13 || "boxPlot" === r13 || t8.globals.comboBarCount > 0) && t8.globals.isXNumeric && !t8.globals.isBarHorizontal && (o10 = t8.config.grid.padding.left, n11 = t8.config.grid.padding.right, e4.barPadForNumericAxis > o10 && (o10 = e4.barPadForNumericAxis, n11 = e4.barPadForNumericAxis)), e4.dom.elGridRect = i17.drawRect(-a10 / 2 - o10 - 2, -a10 / 2 - 2, e4.gridWidth + a10 + n11 + o10 + 4, e4.gridHeight + a10 + 4, 0, "#fff");
      var l8 = t8.globals.markers.largestSize + 1;
      e4.dom.elGridRectMarker = i17.drawRect(2 * -l8, 2 * -l8, e4.gridWidth + 4 * l8, e4.gridHeight + 4 * l8, 0, "#fff"), e4.dom.elGridRectMask.appendChild(e4.dom.elGridRect.node), e4.dom.elGridRectMarkerMask.appendChild(e4.dom.elGridRectMarker.node);
      var h4 = e4.dom.baseEl.querySelector("defs");
      h4.appendChild(e4.dom.elGridRectMask), h4.appendChild(e4.dom.elForecastMask), h4.appendChild(e4.dom.elNonForecastMask), h4.appendChild(e4.dom.elGridRectMarkerMask);
    } }, { key: "_drawGridLines", value: function(t8) {
      var e4 = t8.i, i17 = t8.x1, a10 = t8.y1, s11 = t8.x2, r13 = t8.y2, o10 = t8.xCount, n11 = t8.parent, l8 = this.w;
      if (!(0 === e4 && l8.globals.skipFirstTimelinelabel || e4 === o10 - 1 && l8.globals.skipLastTimelinelabel && !l8.config.xaxis.labels.formatter || "radar" === l8.config.chart.type)) {
        l8.config.grid.xaxis.lines.show && this._drawGridLine({ i: e4, x1: i17, y1: a10, x2: s11, y2: r13, xCount: o10, parent: n11 });
        var h4 = 0;
        if (l8.globals.hasXaxisGroups && "between" === l8.config.xaxis.tickPlacement) {
          var c7 = l8.globals.groups;
          if (c7) {
            for (var d9 = 0, g7 = 0; d9 < e4 && g7 < c7.length; g7++)
              d9 += c7[g7].cols;
            d9 === e4 && (h4 = 0.6 * l8.globals.xAxisLabelsHeight);
          }
        }
        new V3(this.ctx).drawXaxisTicks(i17, h4, l8.globals.dom.elGraphical);
      }
    } }, { key: "_drawGridLine", value: function(t8) {
      var e4 = t8.i, i17 = t8.x1, a10 = t8.y1, s11 = t8.x2, r13 = t8.y2, o10 = t8.xCount, n11 = t8.parent, l8 = this.w, h4 = false, c7 = n11.node.classList.contains("apexcharts-gridlines-horizontal"), d9 = l8.config.grid.strokeDashArray, g7 = l8.globals.barPadForNumericAxis;
      (0 === a10 && 0 === r13 || 0 === i17 && 0 === s11) && (h4 = true), a10 === l8.globals.gridHeight && r13 === l8.globals.gridHeight && (h4 = true), !l8.globals.isBarHorizontal || 0 !== e4 && e4 !== o10 - 1 || (h4 = true);
      var u6 = new m3(this).drawLine(i17 - (c7 ? g7 : 0), a10, s11 + (c7 ? g7 : 0), r13, l8.config.grid.borderColor, d9);
      u6.node.classList.add("apexcharts-gridline"), h4 && l8.config.grid.show ? this.elGridBorders.add(u6) : n11.add(u6);
    } }, { key: "_drawGridBandRect", value: function(t8) {
      var e4 = t8.c, i17 = t8.x1, a10 = t8.y1, s11 = t8.x2, r13 = t8.y2, o10 = t8.type, n11 = this.w, l8 = new m3(this.ctx), h4 = n11.globals.barPadForNumericAxis;
      if ("column" !== o10 || "datetime" !== n11.config.xaxis.type) {
        var c7 = n11.config.grid[o10].colors[e4], d9 = l8.drawRect(i17 - ("row" === o10 ? h4 : 0), a10, s11 + ("row" === o10 ? 2 * h4 : 0), r13, 0, c7, n11.config.grid[o10].opacity);
        this.elg.add(d9), d9.attr("clip-path", "url(#gridRectMask".concat(n11.globals.cuid, ")")), d9.node.classList.add("apexcharts-grid-".concat(o10));
      }
    } }, { key: "_drawXYLines", value: function(t8) {
      var e4 = this, i17 = t8.xCount, a10 = t8.tickAmount, s11 = this.w;
      if (s11.config.grid.xaxis.lines.show || s11.config.xaxis.axisTicks.show) {
        var r13, o10 = s11.globals.padHorizontal, n11 = s11.globals.gridHeight;
        s11.globals.timescaleLabels.length ? function(t9) {
          for (var a11 = t9.xC, s12 = t9.x1, r14 = t9.y1, o11 = t9.x2, n12 = t9.y2, l9 = 0; l9 < a11; l9++)
            s12 = e4.xaxisLabels[l9].position, o11 = e4.xaxisLabels[l9].position, e4._drawGridLines({ i: l9, x1: s12, y1: r14, x2: o11, y2: n12, xCount: i17, parent: e4.elgridLinesV });
        }({ xC: i17, x1: o10, y1: 0, x2: r13, y2: n11 }) : (s11.globals.isXNumeric && (i17 = s11.globals.xAxisScale.result.length), function(t9) {
          for (var a11 = t9.xC, r14 = t9.x1, o11 = t9.y1, n12 = t9.x2, l9 = t9.y2, h5 = 0; h5 < a11 + (s11.globals.isXNumeric ? 0 : 1); h5++)
            0 === h5 && 1 === a11 && 1 === s11.globals.dataPoints && (n12 = r14 = s11.globals.gridWidth / 2), e4._drawGridLines({ i: h5, x1: r14, y1: o11, x2: n12, y2: l9, xCount: i17, parent: e4.elgridLinesV }), n12 = r14 += s11.globals.gridWidth / (s11.globals.isXNumeric ? a11 - 1 : a11);
        }({ xC: i17, x1: o10, y1: 0, x2: r13, y2: n11 }));
      }
      if (s11.config.grid.yaxis.lines.show) {
        var l8 = 0, h4 = 0, c7 = s11.globals.gridWidth, d9 = a10 + 1;
        this.isRangeBar && (d9 = s11.globals.labels.length);
        for (var g7 = 0; g7 < d9 + (this.isRangeBar ? 1 : 0); g7++)
          this._drawGridLine({ i: g7, xCount: d9 + (this.isRangeBar ? 1 : 0), x1: 0, y1: l8, x2: c7, y2: h4, parent: this.elgridLinesH }), h4 = l8 += s11.globals.gridHeight / (this.isRangeBar ? d9 : a10);
      }
    } }, { key: "_drawInvertedXYLines", value: function(t8) {
      var e4 = t8.xCount, i17 = this.w;
      if (i17.config.grid.xaxis.lines.show || i17.config.xaxis.axisTicks.show)
        for (var a10, s11 = i17.globals.padHorizontal, r13 = i17.globals.gridHeight, o10 = 0; o10 < e4 + 1; o10++) {
          i17.config.grid.xaxis.lines.show && this._drawGridLine({ i: o10, xCount: e4 + 1, x1: s11, y1: 0, x2: a10, y2: r13, parent: this.elgridLinesV }), new V3(this.ctx).drawXaxisTicks(s11, 0, i17.globals.dom.elGraphical), a10 = s11 += i17.globals.gridWidth / e4;
        }
      if (i17.config.grid.yaxis.lines.show)
        for (var n11 = 0, l8 = 0, h4 = i17.globals.gridWidth, c7 = 0; c7 < i17.globals.dataPoints + 1; c7++)
          this._drawGridLine({ i: c7, xCount: i17.globals.dataPoints + 1, x1: 0, y1: n11, x2: h4, y2: l8, parent: this.elgridLinesH }), l8 = n11 += i17.globals.gridHeight / i17.globals.dataPoints;
    } }, { key: "renderGrid", value: function() {
      var t8 = this.w, e4 = t8.globals, i17 = new m3(this.ctx);
      this.elg = i17.group({ class: "apexcharts-grid" }), this.elgridLinesH = i17.group({ class: "apexcharts-gridlines-horizontal" }), this.elgridLinesV = i17.group({ class: "apexcharts-gridlines-vertical" }), this.elGridBorders = i17.group({ class: "apexcharts-grid-borders" }), this.elg.add(this.elgridLinesH), this.elg.add(this.elgridLinesV), t8.config.grid.show || (this.elgridLinesV.hide(), this.elgridLinesH.hide(), this.elGridBorders.hide());
      for (var a10 = 0; a10 < e4.seriesYAxisMap.length && -1 !== e4.ignoreYAxisIndexes.indexOf(a10); )
        a10++;
      a10 === e4.seriesYAxisMap.length && (a10 = 0);
      var s11, r13 = e4.yAxisScale[a10].result.length - 1;
      if (!e4.isBarHorizontal || this.isRangeBar) {
        var o10, n11, l8;
        if (s11 = this.xaxisLabels.length, this.isRangeBar)
          r13 = e4.labels.length, t8.config.xaxis.tickAmount && t8.config.xaxis.labels.formatter && (s11 = t8.config.xaxis.tickAmount), (null === (o10 = e4.yAxisScale) || void 0 === o10 || null === (n11 = o10[a10]) || void 0 === n11 || null === (l8 = n11.result) || void 0 === l8 ? void 0 : l8.length) > 0 && "datetime" !== t8.config.xaxis.type && (s11 = e4.yAxisScale[a10].result.length - 1);
        this._drawXYLines({ xCount: s11, tickAmount: r13 });
      } else
        s11 = r13, r13 = e4.xTickAmount, this._drawInvertedXYLines({ xCount: s11, tickAmount: r13 });
      return this.drawGridBands(s11, r13), { el: this.elg, elGridBorders: this.elGridBorders, xAxisTickWidth: e4.gridWidth / s11 };
    } }, { key: "drawGridBands", value: function(t8, e4) {
      var i17 = this.w;
      if (void 0 !== i17.config.grid.row.colors && i17.config.grid.row.colors.length > 0)
        for (var a10 = 0, s11 = i17.globals.gridHeight / e4, r13 = i17.globals.gridWidth, o10 = 0, n11 = 0; o10 < e4; o10++, n11++)
          n11 >= i17.config.grid.row.colors.length && (n11 = 0), this._drawGridBandRect({ c: n11, x1: 0, y1: a10, x2: r13, y2: s11, type: "row" }), a10 += i17.globals.gridHeight / e4;
      if (void 0 !== i17.config.grid.column.colors && i17.config.grid.column.colors.length > 0)
        for (var l8 = i17.globals.isBarHorizontal || "on" !== i17.config.xaxis.tickPlacement || "category" !== i17.config.xaxis.type && !i17.config.xaxis.convertedCatToNumeric ? t8 : t8 - 1, h4 = i17.globals.padHorizontal, c7 = i17.globals.padHorizontal + i17.globals.gridWidth / l8, d9 = i17.globals.gridHeight, g7 = 0, u6 = 0; g7 < t8; g7++, u6++)
          u6 >= i17.config.grid.column.colors.length && (u6 = 0), this._drawGridBandRect({ c: u6, x1: h4, y1: 0, x2: c7, y2: d9, type: "column" }), h4 += i17.globals.gridWidth / l8;
    } }]), t7;
  }(), _2 = function() {
    function t7(e4) {
      a9(this, t7), this.ctx = e4, this.w = e4.w;
    }
    return r12(t7, [{ key: "niceScale", value: function(t8, e4) {
      var i17, a10, s11, r13, o10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, n11 = 1e-11, l8 = this.w, h4 = l8.globals;
      h4.isBarHorizontal ? (i17 = l8.config.xaxis, a10 = Math.max((h4.svgWidth - 100) / 25, 2)) : (i17 = l8.config.yaxis[o10], a10 = Math.max((h4.svgHeight - 100) / 15, 2)), s11 = void 0 !== i17.min && null !== i17.min, r13 = void 0 !== i17.max && null !== i17.min;
      var c7 = void 0 !== i17.stepSize && null !== i17.stepSize, d9 = void 0 !== i17.tickAmount && null !== i17.tickAmount, g7 = d9 ? i17.tickAmount : i17.forceNiceScale ? h4.niceScaleDefaultTicks[Math.min(Math.round(a10 / 2), h4.niceScaleDefaultTicks.length - 1)] : 10;
      if (h4.isMultipleYAxis && !d9 && h4.multiAxisTickAmount > 0 && (g7 = h4.multiAxisTickAmount, d9 = true), g7 = "dataPoints" === g7 ? h4.dataPoints - 1 : Math.abs(Math.round(g7)), (t8 === Number.MIN_VALUE && 0 === e4 || !x3.isNumber(t8) && !x3.isNumber(e4) || t8 === Number.MIN_VALUE && e4 === -Number.MAX_VALUE) && (t8 = x3.isNumber(i17.min) ? i17.min : 0, e4 = x3.isNumber(i17.max) ? i17.max : t8 + g7, h4.allSeriesCollapsed = false), t8 > e4) {
        console.warn("axis.min cannot be greater than axis.max: swapping min and max");
        var u6 = e4;
        e4 = t8, t8 = u6;
      } else
        t8 === e4 && (t8 = 0 === t8 ? 0 : t8 - 1, e4 = 0 === e4 ? 2 : e4 + 1);
      var p7 = [];
      g7 < 1 && (g7 = 1);
      var f5 = g7, b3 = Math.abs(e4 - t8);
      if (i17.forceNiceScale) {
        !s11 && t8 > 0 && t8 / b3 < 0.15 && (t8 = 0, s11 = true), !r13 && e4 < 0 && -e4 / b3 < 0.15 && (e4 = 0, r13 = true), b3 = Math.abs(e4 - t8);
      }
      var v5 = b3 / f5, m4 = v5, y5 = Math.floor(Math.log10(m4)), w4 = Math.pow(10, y5), k4 = Math.ceil(m4 / w4);
      if (v5 = m4 = (k4 = h4.niceScaleAllowedMagMsd[0 === h4.yValueDecimal ? 0 : 1][k4]) * w4, h4.isBarHorizontal && i17.stepSize && "datetime" !== i17.type ? (v5 = i17.stepSize, c7 = true) : c7 && (v5 = i17.stepSize), c7 && i17.forceNiceScale) {
        var A3 = Math.floor(Math.log10(v5));
        v5 *= Math.pow(10, y5 - A3);
      }
      if (s11 && r13) {
        var S3 = b3 / f5;
        if (d9)
          if (c7)
            if (0 != x3.mod(b3, v5)) {
              var C3 = x3.getGCD(v5, S3);
              v5 = S3 / C3 < 10 ? C3 : S3;
            } else
              0 == x3.mod(v5, S3) ? v5 = S3 : (S3 = v5, d9 = false);
          else
            v5 = S3;
        else if (c7)
          0 == x3.mod(b3, v5) ? S3 = v5 : v5 = S3;
        else if (0 == x3.mod(b3, v5))
          S3 = v5;
        else {
          S3 = b3 / (f5 = Math.ceil(b3 / v5));
          var L4 = x3.getGCD(b3, v5);
          b3 / L4 < a10 && (S3 = L4), v5 = S3;
        }
        f5 = Math.round(b3 / v5);
      } else {
        if (s11 || r13) {
          if (r13)
            if (d9)
              t8 = e4 - v5 * f5;
            else {
              var P3 = t8;
              t8 = v5 * Math.floor(t8 / v5), Math.abs(e4 - t8) / x3.getGCD(b3, v5) > a10 && (t8 = e4 - v5 * g7, t8 += v5 * Math.floor((P3 - t8) / v5));
            }
          else if (s11)
            if (d9)
              e4 = t8 + v5 * f5;
            else {
              var M4 = e4;
              e4 = v5 * Math.ceil(e4 / v5), Math.abs(e4 - t8) / x3.getGCD(b3, v5) > a10 && (e4 = t8 + v5 * g7, e4 += v5 * Math.ceil((M4 - e4) / v5));
            }
        } else if (d9) {
          var I4 = v5 / (e4 - t8 > e4 ? 1 : 2), T4 = I4 * Math.floor(t8 / I4);
          Math.abs(T4 - t8) <= I4 / 2 ? e4 = (t8 = T4) + v5 * f5 : t8 = (e4 = I4 * Math.ceil(e4 / I4)) - v5 * f5;
        } else
          t8 = v5 * Math.floor(t8 / v5), e4 = v5 * Math.ceil(e4 / v5);
        b3 = Math.abs(e4 - t8), v5 = x3.getGCD(b3, v5), f5 = Math.round(b3 / v5);
      }
      if (d9 || s11 || r13 || (f5 = Math.ceil((b3 - n11) / (v5 + n11))) > 16 && x3.getPrimeFactors(f5).length < 2 && f5++, !d9 && i17.forceNiceScale && 0 === h4.yValueDecimal && f5 > b3 && (f5 = b3, v5 = Math.round(b3 / f5)), f5 > a10 && (!d9 && !c7 || i17.forceNiceScale)) {
        var z4 = x3.getPrimeFactors(f5), X3 = z4.length - 1, E3 = f5;
        t:
          for (var Y3 = 0; Y3 < X3; Y3++)
            for (var F3 = 0; F3 <= X3 - Y3; F3++) {
              for (var R3 = Math.min(F3 + Y3, X3), H4 = E3, D3 = 1, O3 = F3; O3 <= R3; O3++)
                D3 *= z4[O3];
              if ((H4 /= D3) < a10) {
                E3 = H4;
                break t;
              }
            }
        v5 = E3 === f5 ? b3 : b3 / E3, f5 = Math.round(b3 / v5);
      }
      h4.isMultipleYAxis && 0 == h4.multiAxisTickAmount && h4.ignoreYAxisIndexes.indexOf(o10) < 0 && (h4.multiAxisTickAmount = f5);
      var N4 = t8 - v5, W4 = v5 * n11;
      do {
        N4 += v5, p7.push(x3.stripNumber(N4, 7));
      } while (e4 - N4 > W4);
      return { result: p7, niceMin: p7[0], niceMax: p7[p7.length - 1] };
    } }, { key: "linearScale", value: function(t8, e4) {
      var i17 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 10, a10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, s11 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : void 0, r13 = Math.abs(e4 - t8), o10 = [];
      if (t8 === e4)
        return { result: o10 = [t8], niceMin: o10[0], niceMax: o10[o10.length - 1] };
      "dataPoints" === (i17 = this._adjustTicksForSmallRange(i17, a10, r13)) && (i17 = this.w.globals.dataPoints - 1), s11 || (s11 = r13 / i17), s11 = Math.round(10 * (s11 + Number.EPSILON)) / 10, i17 === Number.MAX_VALUE && (i17 = 5, s11 = 1);
      for (var n11 = t8; i17 >= 0; )
        o10.push(n11), n11 = x3.preciseAddition(n11, s11), i17 -= 1;
      return { result: o10, niceMin: o10[0], niceMax: o10[o10.length - 1] };
    } }, { key: "logarithmicScaleNice", value: function(t8, e4, i17) {
      e4 <= 0 && (e4 = Math.max(t8, i17)), t8 <= 0 && (t8 = Math.min(e4, i17));
      for (var a10 = [], s11 = Math.ceil(Math.log(e4) / Math.log(i17) + 1), r13 = Math.floor(Math.log(t8) / Math.log(i17)); r13 < s11; r13++)
        a10.push(Math.pow(i17, r13));
      return { result: a10, niceMin: a10[0], niceMax: a10[a10.length - 1] };
    } }, { key: "logarithmicScale", value: function(t8, e4, i17) {
      e4 <= 0 && (e4 = Math.max(t8, i17)), t8 <= 0 && (t8 = Math.min(e4, i17));
      for (var a10 = [], s11 = Math.log(e4) / Math.log(i17), r13 = Math.log(t8) / Math.log(i17), o10 = s11 - r13, n11 = Math.round(o10), l8 = o10 / n11, h4 = 0, c7 = r13; h4 < n11; h4++, c7 += l8)
        a10.push(Math.pow(i17, c7));
      return a10.push(Math.pow(i17, s11)), { result: a10, niceMin: t8, niceMax: e4 };
    } }, { key: "_adjustTicksForSmallRange", value: function(t8, e4, i17) {
      var a10 = t8;
      if (void 0 !== e4 && this.w.config.yaxis[e4].labels.formatter && void 0 === this.w.config.yaxis[e4].tickAmount) {
        var s11 = Number(this.w.config.yaxis[e4].labels.formatter(1));
        x3.isNumber(s11) && 0 === this.w.globals.yValueDecimal && (a10 = Math.ceil(i17));
      }
      return a10 < t8 ? a10 : t8;
    } }, { key: "setYScaleForIndex", value: function(t8, e4, i17) {
      var a10 = this.w.globals, s11 = this.w.config, r13 = a10.isBarHorizontal ? s11.xaxis : s11.yaxis[t8];
      void 0 === a10.yAxisScale[t8] && (a10.yAxisScale[t8] = []);
      var o10 = Math.abs(i17 - e4);
      r13.logarithmic && o10 <= 5 && (a10.invalidLogScale = true), r13.logarithmic && o10 > 5 ? (a10.allSeriesCollapsed = false, a10.yAxisScale[t8] = r13.forceNiceScale ? this.logarithmicScaleNice(e4, i17, r13.logBase) : this.logarithmicScale(e4, i17, r13.logBase)) : i17 !== -Number.MAX_VALUE && x3.isNumber(i17) && e4 !== Number.MAX_VALUE && x3.isNumber(e4) ? (a10.allSeriesCollapsed = false, a10.yAxisScale[t8] = this.niceScale(e4, i17, t8)) : a10.yAxisScale[t8] = this.niceScale(Number.MIN_VALUE, 0, t8);
    } }, { key: "setXScale", value: function(t8, e4) {
      var i17 = this.w, a10 = i17.globals, s11 = Math.abs(e4 - t8);
      if (e4 !== -Number.MAX_VALUE && x3.isNumber(e4)) {
        var r13 = a10.xTickAmount + 1;
        s11 < 10 && s11 > 1 && (r13 = s11), a10.xAxisScale = this.linearScale(t8, e4, r13, 0, i17.config.xaxis.stepSize);
      } else
        a10.xAxisScale = this.linearScale(0, 10, 10);
      return a10.xAxisScale;
    } }, { key: "setSeriesYAxisMappings", value: function() {
      var t8 = this.w.globals, e4 = this.w.config, i17 = [], a10 = [], s11 = [], r13 = t8.series.length > e4.yaxis.length || e4.yaxis.some(function(t9) {
        return Array.isArray(t9.seriesName);
      });
      e4.series.forEach(function(t9, e5) {
        s11.push(e5), a10.push(null);
      }), e4.yaxis.forEach(function(t9, e5) {
        i17[e5] = [];
      });
      var o10 = [];
      e4.yaxis.forEach(function(t9, a11) {
        var n12 = false;
        if (t9.seriesName) {
          var l9 = [];
          Array.isArray(t9.seriesName) ? l9 = t9.seriesName : l9.push(t9.seriesName), l9.forEach(function(t10) {
            e4.series.forEach(function(e5, o11) {
              if (e5.name === t10) {
                var l10 = o11;
                a11 === o11 || r13 ? !r13 || s11.indexOf(o11) > -1 ? i17[a11].push([a11, o11]) : console.warn("Series '" + e5.name + "' referenced more than once in what looks like the new style. That is, when using either seriesName: [], or when there are more series than yaxes.") : (i17[o11].push([o11, a11]), l10 = a11), n12 = true, -1 !== (l10 = s11.indexOf(l10)) && s11.splice(l10, 1);
              }
            });
          });
        }
        n12 || o10.push(a11);
      }), i17 = i17.map(function(t9, e5) {
        var i18 = [];
        return t9.forEach(function(t10) {
          a10[t10[1]] = t10[0], i18.push(t10[1]);
        }), i18;
      });
      for (var n11 = e4.yaxis.length - 1, l8 = 0; l8 < o10.length && (n11 = o10[l8], i17[n11] = [], s11); l8++) {
        var h4 = s11[0];
        s11.shift(), i17[n11].push(h4), a10[h4] = n11;
      }
      s11.forEach(function(t9) {
        i17[n11].push(t9), a10[t9] = n11;
      }), t8.seriesYAxisMap = i17.map(function(t9) {
        return t9;
      }), t8.seriesYAxisReverseMap = a10.map(function(t9) {
        return t9;
      });
    } }, { key: "scaleMultipleYAxes", value: function() {
      var t8 = this, e4 = this.w.config, i17 = this.w.globals;
      this.setSeriesYAxisMappings();
      var a10 = i17.seriesYAxisMap, s11 = i17.minYArr, r13 = i17.maxYArr;
      i17.allSeriesCollapsed = true, i17.barGroups = [], a10.forEach(function(a11, o10) {
        var n11 = [];
        a11.forEach(function(t9) {
          var i18 = e4.series[t9].group;
          n11.indexOf(i18) < 0 && n11.push(i18);
        }), a11.length > 0 ? function() {
          var l8, h4, c7 = Number.MAX_VALUE, d9 = -Number.MAX_VALUE, g7 = c7, u6 = d9;
          if (e4.chart.stacked)
            !function() {
              var t9 = i17.seriesX[a11[0]], s12 = [], r14 = [], p8 = [];
              n11.forEach(function() {
                s12.push(t9.map(function() {
                  return Number.MIN_VALUE;
                })), r14.push(t9.map(function() {
                  return Number.MIN_VALUE;
                })), p8.push(t9.map(function() {
                  return Number.MIN_VALUE;
                }));
              });
              for (var f6 = function(t10) {
                !l8 && e4.series[a11[t10]].type && (l8 = e4.series[a11[t10]].type);
                var c8 = a11[t10];
                h4 = e4.series[c8].group ? e4.series[c8].group : "axis-".concat(o10), !(i17.collapsedSeriesIndices.indexOf(c8) < 0 && i17.ancillaryCollapsedSeriesIndices.indexOf(c8) < 0) || (i17.allSeriesCollapsed = false, n11.forEach(function(t11, a12) {
                  if (e4.series[c8].group === t11)
                    for (var o11 = 0; o11 < i17.series[c8].length; o11++) {
                      var n12 = i17.series[c8][o11];
                      n12 >= 0 ? r14[a12][o11] += n12 : p8[a12][o11] += n12, s12[a12][o11] += n12, g7 = Math.min(g7, n12), u6 = Math.max(u6, n12);
                    }
                })), "bar" !== l8 && "column" !== l8 || i17.barGroups.push(h4);
              }, x4 = 0; x4 < a11.length; x4++)
                f6(x4);
              l8 || (l8 = e4.chart.type), "bar" === l8 || "column" === l8 ? n11.forEach(function(t10, e5) {
                c7 = Math.min(c7, Math.min.apply(null, p8[e5])), d9 = Math.max(d9, Math.max.apply(null, r14[e5]));
              }) : (n11.forEach(function(t10, e5) {
                g7 = Math.min(g7, Math.min.apply(null, s12[e5])), u6 = Math.max(u6, Math.max.apply(null, s12[e5]));
              }), c7 = g7, d9 = u6), c7 === Number.MIN_VALUE && d9 === Number.MIN_VALUE && (d9 = -Number.MAX_VALUE);
            }();
          else
            for (var p7 = 0; p7 < a11.length; p7++) {
              var f5 = a11[p7];
              c7 = Math.min(c7, s11[f5]), d9 = Math.max(d9, r13[f5]), !(i17.collapsedSeriesIndices.indexOf(f5) < 0 && i17.ancillaryCollapsedSeriesIndices.indexOf(f5) < 0) || (i17.allSeriesCollapsed = false);
            }
          void 0 !== e4.yaxis[o10].min && (c7 = "function" == typeof e4.yaxis[o10].min ? e4.yaxis[o10].min(c7) : e4.yaxis[o10].min), void 0 !== e4.yaxis[o10].max && (d9 = "function" == typeof e4.yaxis[o10].max ? e4.yaxis[o10].max(d9) : e4.yaxis[o10].max), i17.barGroups = i17.barGroups.filter(function(t9, e5, i18) {
            return i18.indexOf(t9) === e5;
          }), t8.setYScaleForIndex(o10, c7, d9), a11.forEach(function(t9) {
            s11[t9] = i17.yAxisScale[o10].niceMin, r13[t9] = i17.yAxisScale[o10].niceMax;
          });
        }() : t8.setYScaleForIndex(o10, 0, -Number.MAX_VALUE);
      });
    } }]), t7;
  }(), U3 = function() {
    function t7(e4) {
      a9(this, t7), this.ctx = e4, this.w = e4.w, this.scales = new _2(e4);
    }
    return r12(t7, [{ key: "init", value: function() {
      this.setYRange(), this.setXRange(), this.setZRange();
    } }, { key: "getMinYMaxY", value: function(t8) {
      var e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE, i17 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : -Number.MAX_VALUE, a10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null, s11 = this.w.config, r13 = this.w.globals, o10 = -Number.MAX_VALUE, n11 = Number.MIN_VALUE;
      null === a10 && (a10 = t8 + 1);
      var l8 = r13.series, h4 = l8, c7 = l8;
      "candlestick" === s11.chart.type ? (h4 = r13.seriesCandleL, c7 = r13.seriesCandleH) : "boxPlot" === s11.chart.type ? (h4 = r13.seriesCandleO, c7 = r13.seriesCandleC) : r13.isRangeData && (h4 = r13.seriesRangeStart, c7 = r13.seriesRangeEnd);
      var d9 = false;
      if (r13.seriesX.length >= a10) {
        var g7, u6 = null === (g7 = r13.brushSource) || void 0 === g7 ? void 0 : g7.w.config.chart.brush;
        (s11.chart.zoom.enabled && s11.chart.zoom.autoScaleYaxis || null != u6 && u6.enabled && null != u6 && u6.autoScaleYaxis) && (d9 = true);
      }
      for (var p7 = t8; p7 < a10; p7++) {
        r13.dataPoints = Math.max(r13.dataPoints, l8[p7].length);
        var f5 = s11.series[p7].type;
        r13.categoryLabels.length && (r13.dataPoints = r13.categoryLabels.filter(function(t9) {
          return void 0 !== t9;
        }).length), r13.labels.length && "datetime" !== s11.xaxis.type && 0 !== r13.series.reduce(function(t9, e5) {
          return t9 + e5.length;
        }, 0) && (r13.dataPoints = Math.max(r13.dataPoints, r13.labels.length));
        var b3 = 0, v5 = l8[p7].length - 1;
        if (d9) {
          if (s11.xaxis.min)
            for (; b3 < v5 && r13.seriesX[p7][b3] < s11.xaxis.min; b3++)
              ;
          if (s11.xaxis.max)
            for (; v5 > b3 && r13.seriesX[p7][v5] > s11.xaxis.max; v5--)
              ;
        }
        for (var m4 = b3; m4 <= v5 && m4 < r13.series[p7].length; m4++) {
          var y5 = l8[p7][m4];
          if (null !== y5 && x3.isNumber(y5)) {
            switch (void 0 !== c7[p7][m4] && (o10 = Math.max(o10, c7[p7][m4]), e4 = Math.min(e4, c7[p7][m4])), void 0 !== h4[p7][m4] && (e4 = Math.min(e4, h4[p7][m4]), i17 = Math.max(i17, h4[p7][m4])), f5) {
              case "candlestick":
                void 0 !== r13.seriesCandleC[p7][m4] && (o10 = Math.max(o10, r13.seriesCandleH[p7][m4]), e4 = Math.min(e4, r13.seriesCandleL[p7][m4]));
                break;
              case "boxPlot":
                void 0 !== r13.seriesCandleC[p7][m4] && (o10 = Math.max(o10, r13.seriesCandleC[p7][m4]), e4 = Math.min(e4, r13.seriesCandleO[p7][m4]));
            }
            f5 && "candlestick" !== f5 && "boxPlot" !== f5 && "rangeArea" !== f5 && "rangeBar" !== f5 && (o10 = Math.max(o10, r13.series[p7][m4]), e4 = Math.min(e4, r13.series[p7][m4])), i17 = o10, r13.seriesGoals[p7] && r13.seriesGoals[p7][m4] && Array.isArray(r13.seriesGoals[p7][m4]) && r13.seriesGoals[p7][m4].forEach(function(t9) {
              n11 !== Number.MIN_VALUE && (n11 = Math.min(n11, t9.value), e4 = n11), o10 = Math.max(o10, t9.value), i17 = o10;
            }), x3.isFloat(y5) && (y5 = x3.noExponents(y5), r13.yValueDecimal = Math.max(r13.yValueDecimal, y5.toString().split(".")[1].length)), n11 > h4[p7][m4] && h4[p7][m4] < 0 && (n11 = h4[p7][m4]);
          } else
            r13.hasNullValues = true;
        }
        "bar" !== f5 && "column" !== f5 || (n11 < 0 && o10 < 0 && (o10 = 0, i17 = Math.max(i17, 0)), n11 === Number.MIN_VALUE && (n11 = 0, e4 = Math.min(e4, 0)));
      }
      return "rangeBar" === s11.chart.type && r13.seriesRangeStart.length && r13.isBarHorizontal && (n11 = e4), "bar" === s11.chart.type && (n11 < 0 && o10 < 0 && (o10 = 0), n11 === Number.MIN_VALUE && (n11 = 0)), { minY: n11, maxY: o10, lowestY: e4, highestY: i17 };
    } }, { key: "setYRange", value: function() {
      var t8 = this.w.globals, e4 = this.w.config;
      t8.maxY = -Number.MAX_VALUE, t8.minY = Number.MIN_VALUE;
      var i17, a10 = Number.MAX_VALUE;
      if (t8.isMultipleYAxis) {
        a10 = Number.MAX_VALUE;
        for (var s11 = 0; s11 < t8.series.length; s11++)
          i17 = this.getMinYMaxY(s11), t8.minYArr[s11] = i17.lowestY, t8.maxYArr[s11] = i17.highestY, a10 = Math.min(a10, i17.lowestY);
      }
      if (i17 = this.getMinYMaxY(0, a10, null, t8.series.length), "bar" === e4.chart.type ? (t8.minY = i17.minY, t8.maxY = i17.maxY) : (t8.minY = i17.lowestY, t8.maxY = i17.highestY), a10 = i17.lowestY, e4.chart.stacked && this._setStackedMinMax(), "line" === e4.chart.type || "area" === e4.chart.type || "scatter" === e4.chart.type || "candlestick" === e4.chart.type || "boxPlot" === e4.chart.type || "rangeBar" === e4.chart.type && !t8.isBarHorizontal ? t8.minY === Number.MIN_VALUE && a10 !== -Number.MAX_VALUE && a10 !== t8.maxY && (t8.minY = a10) : t8.minY = i17.minY, e4.yaxis.forEach(function(e5, i18) {
        void 0 !== e5.max && ("number" == typeof e5.max ? t8.maxYArr[i18] = e5.max : "function" == typeof e5.max && (t8.maxYArr[i18] = e5.max(t8.isMultipleYAxis ? t8.maxYArr[i18] : t8.maxY)), t8.maxY = t8.maxYArr[i18]), void 0 !== e5.min && ("number" == typeof e5.min ? t8.minYArr[i18] = e5.min : "function" == typeof e5.min && (t8.minYArr[i18] = e5.min(t8.isMultipleYAxis ? t8.minYArr[i18] === Number.MIN_VALUE ? 0 : t8.minYArr[i18] : t8.minY)), t8.minY = t8.minYArr[i18]);
      }), t8.isBarHorizontal) {
        ["min", "max"].forEach(function(i18) {
          void 0 !== e4.xaxis[i18] && "number" == typeof e4.xaxis[i18] && ("min" === i18 ? t8.minY = e4.xaxis[i18] : t8.maxY = e4.xaxis[i18]);
        });
      }
      return t8.isMultipleYAxis ? (this.scales.scaleMultipleYAxes(), t8.minY = a10) : (this.scales.setYScaleForIndex(0, t8.minY, t8.maxY), t8.minY = t8.yAxisScale[0].niceMin, t8.maxY = t8.yAxisScale[0].niceMax, t8.minYArr[0] = t8.minY, t8.maxYArr[0] = t8.maxY), t8.barGroups = [], t8.lineGroups = [], t8.areaGroups = [], e4.series.forEach(function(i18) {
        switch (i18.type || e4.chart.type) {
          case "bar":
          case "column":
            t8.barGroups.push(i18.group);
            break;
          case "line":
            t8.lineGroups.push(i18.group);
            break;
          case "area":
            t8.areaGroups.push(i18.group);
        }
      }), t8.barGroups = t8.barGroups.filter(function(t9, e5, i18) {
        return i18.indexOf(t9) === e5;
      }), t8.lineGroups = t8.lineGroups.filter(function(t9, e5, i18) {
        return i18.indexOf(t9) === e5;
      }), t8.areaGroups = t8.areaGroups.filter(function(t9, e5, i18) {
        return i18.indexOf(t9) === e5;
      }), { minY: t8.minY, maxY: t8.maxY, minYArr: t8.minYArr, maxYArr: t8.maxYArr, yAxisScale: t8.yAxisScale };
    } }, { key: "setXRange", value: function() {
      var t8 = this.w.globals, e4 = this.w.config, i17 = "numeric" === e4.xaxis.type || "datetime" === e4.xaxis.type || "category" === e4.xaxis.type && !t8.noLabelsProvided || t8.noLabelsProvided || t8.isXNumeric;
      if (t8.isXNumeric && function() {
        for (var e5 = 0; e5 < t8.series.length; e5++)
          if (t8.labels[e5])
            for (var i18 = 0; i18 < t8.labels[e5].length; i18++)
              null !== t8.labels[e5][i18] && x3.isNumber(t8.labels[e5][i18]) && (t8.maxX = Math.max(t8.maxX, t8.labels[e5][i18]), t8.initialMaxX = Math.max(t8.maxX, t8.labels[e5][i18]), t8.minX = Math.min(t8.minX, t8.labels[e5][i18]), t8.initialMinX = Math.min(t8.minX, t8.labels[e5][i18]));
      }(), t8.noLabelsProvided && 0 === e4.xaxis.categories.length && (t8.maxX = t8.labels[t8.labels.length - 1], t8.initialMaxX = t8.labels[t8.labels.length - 1], t8.minX = 1, t8.initialMinX = 1), t8.isXNumeric || t8.noLabelsProvided || t8.dataFormatXNumeric) {
        var a10;
        if (void 0 === e4.xaxis.tickAmount ? (a10 = Math.round(t8.svgWidth / 150), "numeric" === e4.xaxis.type && t8.dataPoints < 30 && (a10 = t8.dataPoints - 1), a10 > t8.dataPoints && 0 !== t8.dataPoints && (a10 = t8.dataPoints - 1)) : "dataPoints" === e4.xaxis.tickAmount ? (t8.series.length > 1 && (a10 = t8.series[t8.maxValsInArrayIndex].length - 1), t8.isXNumeric && (a10 = t8.maxX - t8.minX - 1)) : a10 = e4.xaxis.tickAmount, t8.xTickAmount = a10, void 0 !== e4.xaxis.max && "number" == typeof e4.xaxis.max && (t8.maxX = e4.xaxis.max), void 0 !== e4.xaxis.min && "number" == typeof e4.xaxis.min && (t8.minX = e4.xaxis.min), void 0 !== e4.xaxis.range && (t8.minX = t8.maxX - e4.xaxis.range), t8.minX !== Number.MAX_VALUE && t8.maxX !== -Number.MAX_VALUE)
          if (e4.xaxis.convertedCatToNumeric && !t8.dataFormatXNumeric) {
            for (var s11 = [], r13 = t8.minX - 1; r13 < t8.maxX; r13++)
              s11.push(r13 + 1);
            t8.xAxisScale = { result: s11, niceMin: s11[0], niceMax: s11[s11.length - 1] };
          } else
            t8.xAxisScale = this.scales.setXScale(t8.minX, t8.maxX);
        else
          t8.xAxisScale = this.scales.linearScale(0, a10, a10, 0, e4.xaxis.stepSize), t8.noLabelsProvided && t8.labels.length > 0 && (t8.xAxisScale = this.scales.linearScale(1, t8.labels.length, a10 - 1, 0, e4.xaxis.stepSize), t8.seriesX = t8.labels.slice());
        i17 && (t8.labels = t8.xAxisScale.result.slice());
      }
      return t8.isBarHorizontal && t8.labels.length && (t8.xTickAmount = t8.labels.length), this._handleSingleDataPoint(), this._getMinXDiff(), { minX: t8.minX, maxX: t8.maxX };
    } }, { key: "setZRange", value: function() {
      var t8 = this.w.globals;
      if (t8.isDataXYZ) {
        for (var e4 = 0; e4 < t8.series.length; e4++)
          if (void 0 !== t8.seriesZ[e4])
            for (var i17 = 0; i17 < t8.seriesZ[e4].length; i17++)
              null !== t8.seriesZ[e4][i17] && x3.isNumber(t8.seriesZ[e4][i17]) && (t8.maxZ = Math.max(t8.maxZ, t8.seriesZ[e4][i17]), t8.minZ = Math.min(t8.minZ, t8.seriesZ[e4][i17]));
      }
    } }, { key: "_handleSingleDataPoint", value: function() {
      var t8 = this.w.globals, e4 = this.w.config;
      if (t8.minX === t8.maxX) {
        var i17 = new A2(this.ctx);
        if ("datetime" === e4.xaxis.type) {
          var a10 = i17.getDate(t8.minX);
          e4.xaxis.labels.datetimeUTC ? a10.setUTCDate(a10.getUTCDate() - 2) : a10.setDate(a10.getDate() - 2), t8.minX = new Date(a10).getTime();
          var s11 = i17.getDate(t8.maxX);
          e4.xaxis.labels.datetimeUTC ? s11.setUTCDate(s11.getUTCDate() + 2) : s11.setDate(s11.getDate() + 2), t8.maxX = new Date(s11).getTime();
        } else
          ("numeric" === e4.xaxis.type || "category" === e4.xaxis.type && !t8.noLabelsProvided) && (t8.minX = t8.minX - 2, t8.initialMinX = t8.minX, t8.maxX = t8.maxX + 2, t8.initialMaxX = t8.maxX);
      }
    } }, { key: "_getMinXDiff", value: function() {
      var t8 = this.w.globals;
      t8.isXNumeric && t8.seriesX.forEach(function(e4, i17) {
        1 === e4.length && e4.push(t8.seriesX[t8.maxValsInArrayIndex][t8.seriesX[t8.maxValsInArrayIndex].length - 1]);
        var a10 = e4.slice();
        a10.sort(function(t9, e5) {
          return t9 - e5;
        }), a10.forEach(function(e5, i18) {
          if (i18 > 0) {
            var s11 = e5 - a10[i18 - 1];
            s11 > 0 && (t8.minXDiff = Math.min(s11, t8.minXDiff));
          }
        }), 1 !== t8.dataPoints && t8.minXDiff !== Number.MAX_VALUE || (t8.minXDiff = 0.5);
      });
    } }, { key: "_setStackedMinMax", value: function() {
      var t8 = this, e4 = this.w.globals;
      if (e4.series.length) {
        var i17 = e4.seriesGroups;
        i17.length || (i17 = [this.w.globals.seriesNames.map(function(t9) {
          return t9;
        })]);
        var a10 = {}, s11 = {};
        i17.forEach(function(i18) {
          a10[i18] = [], s11[i18] = [], t8.w.config.series.map(function(t9, a11) {
            return i18.indexOf(e4.seriesNames[a11]) > -1 ? a11 : null;
          }).filter(function(t9) {
            return null !== t9;
          }).forEach(function(r13) {
            for (var o10 = 0; o10 < e4.series[e4.maxValsInArrayIndex].length; o10++) {
              var n11, l8, h4, c7;
              void 0 === a10[i18][o10] && (a10[i18][o10] = 0, s11[i18][o10] = 0), (t8.w.config.chart.stacked && !e4.comboCharts || t8.w.config.chart.stacked && e4.comboCharts && (!t8.w.config.chart.stackOnlyBar || "bar" === (null === (n11 = t8.w.config.series) || void 0 === n11 || null === (l8 = n11[r13]) || void 0 === l8 ? void 0 : l8.type) || "column" === (null === (h4 = t8.w.config.series) || void 0 === h4 || null === (c7 = h4[r13]) || void 0 === c7 ? void 0 : c7.type))) && null !== e4.series[r13][o10] && x3.isNumber(e4.series[r13][o10]) && (e4.series[r13][o10] > 0 ? a10[i18][o10] += parseFloat(e4.series[r13][o10]) + 1e-4 : s11[i18][o10] += parseFloat(e4.series[r13][o10]));
            }
          });
        }), Object.entries(a10).forEach(function(t9) {
          var i18 = g6(t9, 1)[0];
          a10[i18].forEach(function(t10, r13) {
            e4.maxY = Math.max(e4.maxY, a10[i18][r13]), e4.minY = Math.min(e4.minY, s11[i18][r13]);
          });
        });
      }
    } }]), t7;
  }(), q2 = function() {
    function t7(e4, i17) {
      a9(this, t7), this.ctx = e4, this.elgrid = i17, this.w = e4.w;
      var s11 = this.w;
      this.xaxisFontSize = s11.config.xaxis.labels.style.fontSize, this.axisFontFamily = s11.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = s11.config.xaxis.labels.style.colors, this.isCategoryBarHorizontal = "bar" === s11.config.chart.type && s11.config.plotOptions.bar.horizontal, this.xAxisoffX = 0, "bottom" === s11.config.xaxis.position && (this.xAxisoffX = s11.globals.gridHeight), this.drawnLabels = [], this.axesUtils = new C2(e4);
    }
    return r12(t7, [{ key: "drawYaxis", value: function(t8) {
      var e4 = this, i17 = this.w, a10 = new m3(this.ctx), s11 = i17.config.yaxis[t8].labels.style, r13 = s11.fontSize, o10 = s11.fontFamily, n11 = s11.fontWeight, l8 = a10.group({ class: "apexcharts-yaxis", rel: t8, transform: "translate(" + i17.globals.translateYAxisX[t8] + ", 0)" });
      if (this.axesUtils.isYAxisHidden(t8))
        return l8;
      var h4 = a10.group({ class: "apexcharts-yaxis-texts-g" });
      l8.add(h4);
      var c7 = i17.globals.yAxisScale[t8].result.length - 1, d9 = i17.globals.gridHeight / c7, g7 = i17.globals.yLabelFormatters[t8], u6 = i17.globals.yAxisScale[t8].result.slice();
      u6 = this.axesUtils.checkForReversedLabels(t8, u6);
      var p7 = "";
      if (i17.config.yaxis[t8].labels.show) {
        var f5 = i17.globals.translateY + i17.config.yaxis[t8].labels.offsetY;
        i17.globals.isBarHorizontal ? f5 = 0 : "heatmap" === i17.config.chart.type && (f5 -= d9 / 2), f5 += parseInt(i17.config.yaxis[t8].labels.style.fontSize, 10) / 3;
        for (var b3 = function(l9) {
          var b4 = u6[l9];
          b4 = g7(b4, l9, i17);
          var v6 = i17.config.yaxis[t8].labels.padding;
          i17.config.yaxis[t8].opposite && 0 !== i17.config.yaxis.length && (v6 *= -1);
          var m4 = "end";
          i17.config.yaxis[t8].opposite && (m4 = "start"), "left" === i17.config.yaxis[t8].labels.align ? m4 = "start" : "center" === i17.config.yaxis[t8].labels.align ? m4 = "middle" : "right" === i17.config.yaxis[t8].labels.align && (m4 = "end");
          var y6 = e4.axesUtils.getYAxisForeColor(s11.colors, t8), w5 = x3.listToArray(i17.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(t8, "'] .apexcharts-yaxis-label tspan"))).map(function(t9) {
            return t9.textContent;
          }), k5 = a10.drawText({ x: v6, y: f5, text: w5.indexOf(b4) >= 0 ? "" : b4, textAnchor: m4, fontSize: r13, fontFamily: o10, fontWeight: n11, maxWidth: i17.config.yaxis[t8].labels.maxWidth, foreColor: Array.isArray(y6) ? y6[l9] : y6, isPlainText: false, cssClass: "apexcharts-yaxis-label " + s11.cssClass });
          l9 === c7 && (p7 = k5), h4.add(k5);
          var A4 = document.createElementNS(i17.globals.SVGNS, "title");
          if (A4.textContent = Array.isArray(b4) ? b4.join(" ") : b4, k5.node.appendChild(A4), 0 !== i17.config.yaxis[t8].labels.rotate) {
            var S4 = a10.rotateAroundCenter(p7.node), C4 = a10.rotateAroundCenter(k5.node);
            k5.node.setAttribute("transform", "rotate(".concat(i17.config.yaxis[t8].labels.rotate, " ").concat(S4.x, " ").concat(C4.y, ")"));
          }
          f5 += d9;
        }, v5 = c7; v5 >= 0; v5--)
          b3(v5);
      }
      if (void 0 !== i17.config.yaxis[t8].title.text) {
        var y5 = a10.group({ class: "apexcharts-yaxis-title" }), w4 = 0;
        i17.config.yaxis[t8].opposite && (w4 = i17.globals.translateYAxisX[t8]);
        var k4 = a10.drawText({ x: w4, y: i17.globals.gridHeight / 2 + i17.globals.translateY + i17.config.yaxis[t8].title.offsetY, text: i17.config.yaxis[t8].title.text, textAnchor: "end", foreColor: i17.config.yaxis[t8].title.style.color, fontSize: i17.config.yaxis[t8].title.style.fontSize, fontWeight: i17.config.yaxis[t8].title.style.fontWeight, fontFamily: i17.config.yaxis[t8].title.style.fontFamily, cssClass: "apexcharts-yaxis-title-text " + i17.config.yaxis[t8].title.style.cssClass });
        y5.add(k4), l8.add(y5);
      }
      var A3 = i17.config.yaxis[t8].axisBorder, S3 = 31 + A3.offsetX;
      if (i17.config.yaxis[t8].opposite && (S3 = -31 - A3.offsetX), A3.show) {
        var C3 = a10.drawLine(S3, i17.globals.translateY + A3.offsetY - 2, S3, i17.globals.gridHeight + i17.globals.translateY + A3.offsetY + 2, A3.color, 0, A3.width);
        l8.add(C3);
      }
      return i17.config.yaxis[t8].axisTicks.show && this.axesUtils.drawYAxisTicks(S3, c7, A3, i17.config.yaxis[t8].axisTicks, t8, d9, l8), l8;
    } }, { key: "drawYaxisInversed", value: function(t8) {
      var e4 = this.w, i17 = new m3(this.ctx), a10 = i17.group({ class: "apexcharts-xaxis apexcharts-yaxis-inversed" }), s11 = i17.group({ class: "apexcharts-xaxis-texts-g", transform: "translate(".concat(e4.globals.translateXAxisX, ", ").concat(e4.globals.translateXAxisY, ")") });
      a10.add(s11);
      var r13 = e4.globals.yAxisScale[t8].result.length - 1, o10 = e4.globals.gridWidth / r13 + 0.1, n11 = o10 + e4.config.xaxis.labels.offsetX, l8 = e4.globals.xLabelFormatter, h4 = e4.globals.yAxisScale[t8].result.slice(), c7 = e4.globals.timescaleLabels;
      c7.length > 0 && (this.xaxisLabels = c7.slice(), r13 = (h4 = c7.slice()).length), h4 = this.axesUtils.checkForReversedLabels(t8, h4);
      var d9 = c7.length;
      if (e4.config.xaxis.labels.show)
        for (var g7 = d9 ? 0 : r13; d9 ? g7 < d9 : g7 >= 0; d9 ? g7++ : g7--) {
          var u6 = h4[g7];
          u6 = l8(u6, g7, e4);
          var p7 = e4.globals.gridWidth + e4.globals.padHorizontal - (n11 - o10 + e4.config.xaxis.labels.offsetX);
          if (c7.length) {
            var f5 = this.axesUtils.getLabel(h4, c7, p7, g7, this.drawnLabels, this.xaxisFontSize);
            p7 = f5.x, u6 = f5.text, this.drawnLabels.push(f5.text), 0 === g7 && e4.globals.skipFirstTimelinelabel && (u6 = ""), g7 === h4.length - 1 && e4.globals.skipLastTimelinelabel && (u6 = "");
          }
          var x4 = i17.drawText({ x: p7, y: this.xAxisoffX + e4.config.xaxis.labels.offsetY + 30 - ("top" === e4.config.xaxis.position ? e4.globals.xAxisHeight + e4.config.xaxis.axisTicks.height - 2 : 0), text: u6, textAnchor: "middle", foreColor: Array.isArray(this.xaxisForeColors) ? this.xaxisForeColors[t8] : this.xaxisForeColors, fontSize: this.xaxisFontSize, fontFamily: this.xaxisFontFamily, fontWeight: e4.config.xaxis.labels.style.fontWeight, isPlainText: false, cssClass: "apexcharts-xaxis-label " + e4.config.xaxis.labels.style.cssClass });
          s11.add(x4), x4.tspan(u6);
          var b3 = document.createElementNS(e4.globals.SVGNS, "title");
          b3.textContent = u6, x4.node.appendChild(b3), n11 += o10;
        }
      return this.inversedYAxisTitleText(a10), this.inversedYAxisBorder(a10), a10;
    } }, { key: "inversedYAxisBorder", value: function(t8) {
      var e4 = this.w, i17 = new m3(this.ctx), a10 = e4.config.xaxis.axisBorder;
      if (a10.show) {
        var s11 = 0;
        "bar" === e4.config.chart.type && e4.globals.isXNumeric && (s11 -= 15);
        var r13 = i17.drawLine(e4.globals.padHorizontal + s11 + a10.offsetX, this.xAxisoffX, e4.globals.gridWidth, this.xAxisoffX, a10.color, 0, a10.height);
        this.elgrid && this.elgrid.elGridBorders && e4.config.grid.show ? this.elgrid.elGridBorders.add(r13) : t8.add(r13);
      }
    } }, { key: "inversedYAxisTitleText", value: function(t8) {
      var e4 = this.w, i17 = new m3(this.ctx);
      if (void 0 !== e4.config.xaxis.title.text) {
        var a10 = i17.group({ class: "apexcharts-xaxis-title apexcharts-yaxis-title-inversed" }), s11 = i17.drawText({ x: e4.globals.gridWidth / 2 + e4.config.xaxis.title.offsetX, y: this.xAxisoffX + parseFloat(this.xaxisFontSize) + parseFloat(e4.config.xaxis.title.style.fontSize) + e4.config.xaxis.title.offsetY + 20, text: e4.config.xaxis.title.text, textAnchor: "middle", fontSize: e4.config.xaxis.title.style.fontSize, fontFamily: e4.config.xaxis.title.style.fontFamily, fontWeight: e4.config.xaxis.title.style.fontWeight, foreColor: e4.config.xaxis.title.style.color, cssClass: "apexcharts-xaxis-title-text " + e4.config.xaxis.title.style.cssClass });
        a10.add(s11), t8.add(a10);
      }
    } }, { key: "yAxisTitleRotate", value: function(t8, e4) {
      var i17 = this.w, a10 = new m3(this.ctx), s11 = { width: 0, height: 0 }, r13 = { width: 0, height: 0 }, o10 = i17.globals.dom.baseEl.querySelector(" .apexcharts-yaxis[rel='".concat(t8, "'] .apexcharts-yaxis-texts-g"));
      null !== o10 && (s11 = o10.getBoundingClientRect());
      var n11 = i17.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(t8, "'] .apexcharts-yaxis-title text"));
      if (null !== n11 && (r13 = n11.getBoundingClientRect()), null !== n11) {
        var l8 = this.xPaddingForYAxisTitle(t8, s11, r13, e4);
        n11.setAttribute("x", l8.xPos - (e4 ? 10 : 0));
      }
      if (null !== n11) {
        var h4 = a10.rotateAroundCenter(n11);
        n11.setAttribute("transform", "rotate(".concat(e4 ? -1 * i17.config.yaxis[t8].title.rotate : i17.config.yaxis[t8].title.rotate, " ").concat(h4.x, " ").concat(h4.y, ")"));
      }
    } }, { key: "xPaddingForYAxisTitle", value: function(t8, e4, i17, a10) {
      var s11 = this.w, r13 = 0, o10 = 0, n11 = 10;
      return void 0 === s11.config.yaxis[t8].title.text || t8 < 0 ? { xPos: o10, padd: 0 } : (a10 ? (o10 = e4.width + s11.config.yaxis[t8].title.offsetX + i17.width / 2 + n11 / 2, 0 === (r13 += 1) && (o10 -= n11 / 2)) : (o10 = -1 * e4.width + s11.config.yaxis[t8].title.offsetX + n11 / 2 + i17.width / 2, s11.globals.isBarHorizontal && (n11 = 25, o10 = -1 * e4.width - s11.config.yaxis[t8].title.offsetX - n11)), { xPos: o10, padd: n11 });
    } }, { key: "setYAxisXPosition", value: function(t8, e4) {
      var i17 = this.w, a10 = 0, s11 = 0, r13 = 18, o10 = 1;
      i17.config.yaxis.length > 1 && (this.multipleYs = true), i17.config.yaxis.map(function(n11, l8) {
        var h4 = i17.globals.ignoreYAxisIndexes.indexOf(l8) > -1 || !n11.show || n11.floating || 0 === t8[l8].width, c7 = t8[l8].width + e4[l8].width;
        n11.opposite ? i17.globals.isBarHorizontal ? (s11 = i17.globals.gridWidth + i17.globals.translateX - 1, i17.globals.translateYAxisX[l8] = s11 - n11.labels.offsetX) : (s11 = i17.globals.gridWidth + i17.globals.translateX + o10, h4 || (o10 = o10 + c7 + 20), i17.globals.translateYAxisX[l8] = s11 - n11.labels.offsetX + 20) : (a10 = i17.globals.translateX - r13, h4 || (r13 = r13 + c7 + 20), i17.globals.translateYAxisX[l8] = a10 + n11.labels.offsetX);
      });
    } }, { key: "setYAxisTextAlignments", value: function() {
      var t8 = this.w, e4 = t8.globals.dom.baseEl.getElementsByClassName("apexcharts-yaxis");
      (e4 = x3.listToArray(e4)).forEach(function(e5, i17) {
        var a10 = t8.config.yaxis[i17];
        if (a10 && !a10.floating && void 0 !== a10.labels.align) {
          var s11 = t8.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(i17, "'] .apexcharts-yaxis-texts-g")), r13 = t8.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(i17, "'] .apexcharts-yaxis-label"));
          r13 = x3.listToArray(r13);
          var o10 = s11.getBoundingClientRect();
          "left" === a10.labels.align ? (r13.forEach(function(t9, e6) {
            t9.setAttribute("text-anchor", "start");
          }), a10.opposite || s11.setAttribute("transform", "translate(-".concat(o10.width, ", 0)"))) : "center" === a10.labels.align ? (r13.forEach(function(t9, e6) {
            t9.setAttribute("text-anchor", "middle");
          }), s11.setAttribute("transform", "translate(".concat(o10.width / 2 * (a10.opposite ? 1 : -1), ", 0)"))) : "right" === a10.labels.align && (r13.forEach(function(t9, e6) {
            t9.setAttribute("text-anchor", "end");
          }), a10.opposite && s11.setAttribute("transform", "translate(".concat(o10.width, ", 0)")));
        }
      });
    } }]), t7;
  }(), Z2 = function() {
    function t7(e4) {
      a9(this, t7), this.ctx = e4, this.w = e4.w, this.documentEvent = x3.bind(this.documentEvent, this);
    }
    return r12(t7, [{ key: "addEventListener", value: function(t8, e4) {
      var i17 = this.w;
      i17.globals.events.hasOwnProperty(t8) ? i17.globals.events[t8].push(e4) : i17.globals.events[t8] = [e4];
    } }, { key: "removeEventListener", value: function(t8, e4) {
      var i17 = this.w;
      if (i17.globals.events.hasOwnProperty(t8)) {
        var a10 = i17.globals.events[t8].indexOf(e4);
        -1 !== a10 && i17.globals.events[t8].splice(a10, 1);
      }
    } }, { key: "fireEvent", value: function(t8, e4) {
      var i17 = this.w;
      if (i17.globals.events.hasOwnProperty(t8)) {
        e4 && e4.length || (e4 = []);
        for (var a10 = i17.globals.events[t8], s11 = a10.length, r13 = 0; r13 < s11; r13++)
          a10[r13].apply(null, e4);
      }
    } }, { key: "setupEventHandlers", value: function() {
      var t8 = this, e4 = this.w, i17 = this.ctx, a10 = e4.globals.dom.baseEl.querySelector(e4.globals.chartClass);
      this.ctx.eventList.forEach(function(t9) {
        a10.addEventListener(t9, function(t10) {
          var a11 = Object.assign({}, e4, { seriesIndex: e4.globals.axisCharts ? e4.globals.capturedSeriesIndex : 0, dataPointIndex: e4.globals.capturedDataPointIndex });
          "mousemove" === t10.type || "touchmove" === t10.type ? "function" == typeof e4.config.chart.events.mouseMove && e4.config.chart.events.mouseMove(t10, i17, a11) : "mouseleave" === t10.type || "touchleave" === t10.type ? "function" == typeof e4.config.chart.events.mouseLeave && e4.config.chart.events.mouseLeave(t10, i17, a11) : ("mouseup" === t10.type && 1 === t10.which || "touchend" === t10.type) && ("function" == typeof e4.config.chart.events.click && e4.config.chart.events.click(t10, i17, a11), i17.ctx.events.fireEvent("click", [t10, i17, a11]));
        }, { capture: false, passive: true });
      }), this.ctx.eventList.forEach(function(i18) {
        e4.globals.dom.baseEl.addEventListener(i18, t8.documentEvent, { passive: true });
      }), this.ctx.core.setupBrushHandler();
    } }, { key: "documentEvent", value: function(t8) {
      var e4 = this.w, i17 = t8.target.className;
      if ("click" === t8.type) {
        var a10 = e4.globals.dom.baseEl.querySelector(".apexcharts-menu");
        a10 && a10.classList.contains("apexcharts-menu-open") && "apexcharts-menu-icon" !== i17 && a10.classList.remove("apexcharts-menu-open");
      }
      e4.globals.clientX = "touchmove" === t8.type ? t8.touches[0].clientX : t8.clientX, e4.globals.clientY = "touchmove" === t8.type ? t8.touches[0].clientY : t8.clientY;
    } }]), t7;
  }(), $2 = function() {
    function t7(e4) {
      a9(this, t7), this.ctx = e4, this.w = e4.w;
    }
    return r12(t7, [{ key: "setCurrentLocaleValues", value: function(t8) {
      var e4 = this.w.config.chart.locales;
      window.Apex.chart && window.Apex.chart.locales && window.Apex.chart.locales.length > 0 && (e4 = this.w.config.chart.locales.concat(window.Apex.chart.locales));
      var i17 = e4.filter(function(e5) {
        return e5.name === t8;
      })[0];
      if (!i17)
        throw new Error("Wrong locale name provided. Please make sure you set the correct locale name in options");
      var a10 = x3.extend(M3, i17);
      this.w.globals.locale = a10.options;
    } }]), t7;
  }(), J2 = function() {
    function t7(e4) {
      a9(this, t7), this.ctx = e4, this.w = e4.w;
    }
    return r12(t7, [{ key: "drawAxis", value: function(t8, e4) {
      var i17, a10, s11 = this, r13 = this.w.globals, o10 = this.w.config, n11 = new V3(this.ctx, e4), l8 = new q2(this.ctx, e4);
      r13.axisCharts && "radar" !== t8 && (r13.isBarHorizontal ? (a10 = l8.drawYaxisInversed(0), i17 = n11.drawXaxisInversed(0), r13.dom.elGraphical.add(i17), r13.dom.elGraphical.add(a10)) : (i17 = n11.drawXaxis(), r13.dom.elGraphical.add(i17), o10.yaxis.map(function(t9, e5) {
        if (-1 === r13.ignoreYAxisIndexes.indexOf(e5) && (a10 = l8.drawYaxis(e5), r13.dom.Paper.add(a10), "back" === s11.w.config.grid.position)) {
          var i18 = r13.dom.Paper.children()[1];
          i18.remove(), r13.dom.Paper.add(i18);
        }
      })));
    } }]), t7;
  }(), Q2 = function() {
    function t7(e4) {
      a9(this, t7), this.ctx = e4, this.w = e4.w;
    }
    return r12(t7, [{ key: "drawXCrosshairs", value: function() {
      var t8 = this.w, e4 = new m3(this.ctx), i17 = new v3(this.ctx), a10 = t8.config.xaxis.crosshairs.fill.gradient, s11 = t8.config.xaxis.crosshairs.dropShadow, r13 = t8.config.xaxis.crosshairs.fill.type, o10 = a10.colorFrom, n11 = a10.colorTo, l8 = a10.opacityFrom, h4 = a10.opacityTo, c7 = a10.stops, d9 = s11.enabled, g7 = s11.left, u6 = s11.top, p7 = s11.blur, f5 = s11.color, b3 = s11.opacity, y5 = t8.config.xaxis.crosshairs.fill.color;
      if (t8.config.xaxis.crosshairs.show) {
        "gradient" === r13 && (y5 = e4.drawGradient("vertical", o10, n11, l8, h4, null, c7, null));
        var w4 = e4.drawRect();
        1 === t8.config.xaxis.crosshairs.width && (w4 = e4.drawLine());
        var k4 = t8.globals.gridHeight;
        (!x3.isNumber(k4) || k4 < 0) && (k4 = 0);
        var A3 = t8.config.xaxis.crosshairs.width;
        (!x3.isNumber(A3) || A3 < 0) && (A3 = 0), w4.attr({ class: "apexcharts-xcrosshairs", x: 0, y: 0, y2: k4, width: A3, height: k4, fill: y5, filter: "none", "fill-opacity": t8.config.xaxis.crosshairs.opacity, stroke: t8.config.xaxis.crosshairs.stroke.color, "stroke-width": t8.config.xaxis.crosshairs.stroke.width, "stroke-dasharray": t8.config.xaxis.crosshairs.stroke.dashArray }), d9 && (w4 = i17.dropShadow(w4, { left: g7, top: u6, blur: p7, color: f5, opacity: b3 })), t8.globals.dom.elGraphical.add(w4);
      }
    } }, { key: "drawYCrosshairs", value: function() {
      var t8 = this.w, e4 = new m3(this.ctx), i17 = t8.config.yaxis[0].crosshairs, a10 = t8.globals.barPadForNumericAxis;
      if (t8.config.yaxis[0].crosshairs.show) {
        var s11 = e4.drawLine(-a10, 0, t8.globals.gridWidth + a10, 0, i17.stroke.color, i17.stroke.dashArray, i17.stroke.width);
        s11.attr({ class: "apexcharts-ycrosshairs" }), t8.globals.dom.elGraphical.add(s11);
      }
      var r13 = e4.drawLine(-a10, 0, t8.globals.gridWidth + a10, 0, i17.stroke.color, 0, 0);
      r13.attr({ class: "apexcharts-ycrosshairs-hidden" }), t8.globals.dom.elGraphical.add(r13);
    } }]), t7;
  }(), K3 = function() {
    function t7(e4) {
      a9(this, t7), this.ctx = e4, this.w = e4.w;
    }
    return r12(t7, [{ key: "checkResponsiveConfig", value: function(t8) {
      var e4 = this, i17 = this.w, a10 = i17.config;
      if (0 !== a10.responsive.length) {
        var s11 = a10.responsive.slice();
        s11.sort(function(t9, e5) {
          return t9.breakpoint > e5.breakpoint ? 1 : e5.breakpoint > t9.breakpoint ? -1 : 0;
        }).reverse();
        var r13 = new Y2({}), o10 = function() {
          var t9 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, a11 = s11[0].breakpoint, o11 = window.innerWidth > 0 ? window.innerWidth : screen.width;
          if (o11 > a11) {
            var n12 = x3.clone(i17.globals.initialConfig);
            n12.series = x3.clone(i17.config.series);
            var l8 = y4.extendArrayProps(r13, n12, i17);
            t9 = x3.extend(l8, t9), t9 = x3.extend(i17.config, t9), e4.overrideResponsiveOptions(t9);
          } else
            for (var h4 = 0; h4 < s11.length; h4++)
              o11 < s11[h4].breakpoint && (t9 = y4.extendArrayProps(r13, s11[h4].options, i17), t9 = x3.extend(i17.config, t9), e4.overrideResponsiveOptions(t9));
        };
        if (t8) {
          var n11 = y4.extendArrayProps(r13, t8, i17);
          n11 = x3.extend(i17.config, n11), o10(n11 = x3.extend(n11, t8));
        } else
          o10({});
      }
    } }, { key: "overrideResponsiveOptions", value: function(t8) {
      var e4 = new Y2(t8).init({ responsiveOverride: true });
      this.w.config = e4;
    } }]), t7;
  }(), tt = function() {
    function t7(e4) {
      a9(this, t7), this.ctx = e4, this.colors = [], this.w = e4.w;
      var i17 = this.w;
      this.isColorFn = false, this.isHeatmapDistributed = "treemap" === i17.config.chart.type && i17.config.plotOptions.treemap.distributed || "heatmap" === i17.config.chart.type && i17.config.plotOptions.heatmap.distributed, this.isBarDistributed = i17.config.plotOptions.bar.distributed && ("bar" === i17.config.chart.type || "rangeBar" === i17.config.chart.type);
    }
    return r12(t7, [{ key: "init", value: function() {
      this.setDefaultColors();
    } }, { key: "setDefaultColors", value: function() {
      var t8, e4 = this, i17 = this.w, a10 = new x3();
      if (i17.globals.dom.elWrap.classList.add("apexcharts-theme-".concat(i17.config.theme.mode)), void 0 === i17.config.colors || 0 === (null === (t8 = i17.config.colors) || void 0 === t8 ? void 0 : t8.length) ? i17.globals.colors = this.predefined() : (i17.globals.colors = i17.config.colors, Array.isArray(i17.config.colors) && i17.config.colors.length > 0 && "function" == typeof i17.config.colors[0] && (i17.globals.colors = i17.config.series.map(function(t9, a11) {
        var s12 = i17.config.colors[a11];
        return s12 || (s12 = i17.config.colors[0]), "function" == typeof s12 ? (e4.isColorFn = true, s12({ value: i17.globals.axisCharts ? i17.globals.series[a11][0] ? i17.globals.series[a11][0] : 0 : i17.globals.series[a11], seriesIndex: a11, dataPointIndex: a11, w: i17 })) : s12;
      }))), i17.globals.seriesColors.map(function(t9, e5) {
        t9 && (i17.globals.colors[e5] = t9);
      }), i17.config.theme.monochrome.enabled) {
        var s11 = [], r13 = i17.globals.series.length;
        (this.isBarDistributed || this.isHeatmapDistributed) && (r13 = i17.globals.series[0].length * i17.globals.series.length);
        for (var o10 = i17.config.theme.monochrome.color, n11 = 1 / (r13 / i17.config.theme.monochrome.shadeIntensity), l8 = i17.config.theme.monochrome.shadeTo, h4 = 0, c7 = 0; c7 < r13; c7++) {
          var d9 = void 0;
          "dark" === l8 ? (d9 = a10.shadeColor(-1 * h4, o10), h4 += n11) : (d9 = a10.shadeColor(h4, o10), h4 += n11), s11.push(d9);
        }
        i17.globals.colors = s11.slice();
      }
      var g7 = i17.globals.colors.slice();
      this.pushExtraColors(i17.globals.colors);
      ["fill", "stroke"].forEach(function(t9) {
        void 0 === i17.config[t9].colors ? i17.globals[t9].colors = e4.isColorFn ? i17.config.colors : g7 : i17.globals[t9].colors = i17.config[t9].colors.slice(), e4.pushExtraColors(i17.globals[t9].colors);
      }), void 0 === i17.config.dataLabels.style.colors ? i17.globals.dataLabels.style.colors = g7 : i17.globals.dataLabels.style.colors = i17.config.dataLabels.style.colors.slice(), this.pushExtraColors(i17.globals.dataLabels.style.colors, 50), void 0 === i17.config.plotOptions.radar.polygons.fill.colors ? i17.globals.radarPolygons.fill.colors = ["dark" === i17.config.theme.mode ? "#424242" : "none"] : i17.globals.radarPolygons.fill.colors = i17.config.plotOptions.radar.polygons.fill.colors.slice(), this.pushExtraColors(i17.globals.radarPolygons.fill.colors, 20), void 0 === i17.config.markers.colors ? i17.globals.markers.colors = g7 : i17.globals.markers.colors = i17.config.markers.colors.slice(), this.pushExtraColors(i17.globals.markers.colors);
    } }, { key: "pushExtraColors", value: function(t8, e4) {
      var i17 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, a10 = this.w, s11 = e4 || a10.globals.series.length;
      if (null === i17 && (i17 = this.isBarDistributed || this.isHeatmapDistributed || "heatmap" === a10.config.chart.type && a10.config.plotOptions.heatmap.colorScale.inverse), i17 && a10.globals.series.length && (s11 = a10.globals.series[a10.globals.maxValsInArrayIndex].length * a10.globals.series.length), t8.length < s11)
        for (var r13 = s11 - t8.length, o10 = 0; o10 < r13; o10++)
          t8.push(t8[o10]);
    } }, { key: "updateThemeOptions", value: function(t8) {
      t8.chart = t8.chart || {}, t8.tooltip = t8.tooltip || {};
      var e4 = t8.theme.mode, i17 = "dark" === e4 ? "palette4" : "light" === e4 ? "palette1" : t8.theme.palette || "palette1", a10 = "dark" === e4 ? "#f6f7f8" : "light" === e4 ? "#373d3f" : t8.chart.foreColor || "#373d3f";
      return t8.tooltip.theme = e4 || "light", t8.chart.foreColor = a10, t8.theme.palette = i17, t8;
    } }, { key: "predefined", value: function() {
      switch (this.w.config.theme.palette) {
        case "palette1":
        default:
          this.colors = ["#008FFB", "#00E396", "#FEB019", "#FF4560", "#775DD0"];
          break;
        case "palette2":
          this.colors = ["#3f51b5", "#03a9f4", "#4caf50", "#f9ce1d", "#FF9800"];
          break;
        case "palette3":
          this.colors = ["#33b2df", "#546E7A", "#d4526e", "#13d8aa", "#A5978B"];
          break;
        case "palette4":
          this.colors = ["#4ecdc4", "#c7f464", "#81D4FA", "#fd6a6a", "#546E7A"];
          break;
        case "palette5":
          this.colors = ["#2b908f", "#f9a3a4", "#90ee7e", "#fa4443", "#69d2e7"];
          break;
        case "palette6":
          this.colors = ["#449DD1", "#F86624", "#EA3546", "#662E9B", "#C5D86D"];
          break;
        case "palette7":
          this.colors = ["#D7263D", "#1B998B", "#2E294E", "#F46036", "#E2C044"];
          break;
        case "palette8":
          this.colors = ["#662E9B", "#F86624", "#F9C80E", "#EA3546", "#43BCCD"];
          break;
        case "palette9":
          this.colors = ["#5C4742", "#A5978B", "#8D5B4C", "#5A2A27", "#C4BBAF"];
          break;
        case "palette10":
          this.colors = ["#A300D6", "#7D02EB", "#5653FE", "#2983FF", "#00B1F2"];
      }
      return this.colors;
    } }]), t7;
  }(), et = function() {
    function t7(e4) {
      a9(this, t7), this.ctx = e4, this.w = e4.w;
    }
    return r12(t7, [{ key: "draw", value: function() {
      this.drawTitleSubtitle("title"), this.drawTitleSubtitle("subtitle");
    } }, { key: "drawTitleSubtitle", value: function(t8) {
      var e4 = this.w, i17 = "title" === t8 ? e4.config.title : e4.config.subtitle, a10 = e4.globals.svgWidth / 2, s11 = i17.offsetY, r13 = "middle";
      if ("left" === i17.align ? (a10 = 10, r13 = "start") : "right" === i17.align && (a10 = e4.globals.svgWidth - 10, r13 = "end"), a10 += i17.offsetX, s11 = s11 + parseInt(i17.style.fontSize, 10) + i17.margin / 2, void 0 !== i17.text) {
        var o10 = new m3(this.ctx).drawText({ x: a10, y: s11, text: i17.text, textAnchor: r13, fontSize: i17.style.fontSize, fontFamily: i17.style.fontFamily, fontWeight: i17.style.fontWeight, foreColor: i17.style.color, opacity: 1 });
        o10.node.setAttribute("class", "apexcharts-".concat(t8, "-text")), e4.globals.dom.Paper.add(o10);
      }
    } }]), t7;
  }(), it = function() {
    function t7(e4) {
      a9(this, t7), this.w = e4.w, this.dCtx = e4;
    }
    return r12(t7, [{ key: "getTitleSubtitleCoords", value: function(t8) {
      var e4 = this.w, i17 = 0, a10 = 0, s11 = "title" === t8 ? e4.config.title.floating : e4.config.subtitle.floating, r13 = e4.globals.dom.baseEl.querySelector(".apexcharts-".concat(t8, "-text"));
      if (null !== r13 && !s11) {
        var o10 = r13.getBoundingClientRect();
        i17 = o10.width, a10 = e4.globals.axisCharts ? o10.height + 5 : o10.height;
      }
      return { width: i17, height: a10 };
    } }, { key: "getLegendsRect", value: function() {
      var t8 = this.w, e4 = t8.globals.dom.elLegendWrap;
      t8.config.legend.height || "top" !== t8.config.legend.position && "bottom" !== t8.config.legend.position || (e4.style.maxHeight = t8.globals.svgHeight / 2 + "px");
      var i17 = Object.assign({}, x3.getBoundingClientRect(e4));
      return null !== e4 && !t8.config.legend.floating && t8.config.legend.show ? this.dCtx.lgRect = { x: i17.x, y: i17.y, height: i17.height, width: 0 === i17.height ? 0 : i17.width } : this.dCtx.lgRect = { x: 0, y: 0, height: 0, width: 0 }, "left" !== t8.config.legend.position && "right" !== t8.config.legend.position || 1.5 * this.dCtx.lgRect.width > t8.globals.svgWidth && (this.dCtx.lgRect.width = t8.globals.svgWidth / 1.5), this.dCtx.lgRect;
    } }, { key: "getDatalabelsRect", value: function() {
      var t8 = this, e4 = this.w, i17 = [];
      e4.config.series.forEach(function(s12, r14) {
        s12.data.forEach(function(s13, o11) {
          var n11;
          n11 = e4.globals.series[r14][o11], a10 = e4.config.dataLabels.formatter(n11, { ctx: t8.dCtx.ctx, seriesIndex: r14, dataPointIndex: o11, w: e4 }), i17.push(a10);
        });
      });
      var a10 = x3.getLargestStringFromArr(i17), s11 = new m3(this.dCtx.ctx), r13 = e4.config.dataLabels.style, o10 = s11.getTextRects(a10, parseInt(r13.fontSize), r13.fontFamily);
      return { width: 1.05 * o10.width, height: o10.height };
    } }, { key: "getLargestStringFromMultiArr", value: function(t8, e4) {
      var i17 = t8;
      if (this.w.globals.isMultiLineX) {
        var a10 = e4.map(function(t9, e5) {
          return Array.isArray(t9) ? t9.length : 1;
        }), s11 = Math.max.apply(Math, u5(a10));
        i17 = e4[a10.indexOf(s11)];
      }
      return i17;
    } }]), t7;
  }(), at = function() {
    function t7(e4) {
      a9(this, t7), this.w = e4.w, this.dCtx = e4;
    }
    return r12(t7, [{ key: "getxAxisLabelsCoords", value: function() {
      var t8, e4 = this.w, i17 = e4.globals.labels.slice();
      if (e4.config.xaxis.convertedCatToNumeric && 0 === i17.length && (i17 = e4.globals.categoryLabels), e4.globals.timescaleLabels.length > 0) {
        var a10 = this.getxAxisTimeScaleLabelsCoords();
        t8 = { width: a10.width, height: a10.height }, e4.globals.rotateXLabels = false;
      } else {
        this.dCtx.lgWidthForSideLegends = "left" !== e4.config.legend.position && "right" !== e4.config.legend.position || e4.config.legend.floating ? 0 : this.dCtx.lgRect.width;
        var s11 = e4.globals.xLabelFormatter, r13 = x3.getLargestStringFromArr(i17), o10 = this.dCtx.dimHelpers.getLargestStringFromMultiArr(r13, i17);
        e4.globals.isBarHorizontal && (o10 = r13 = e4.globals.yAxisScale[0].result.reduce(function(t9, e5) {
          return t9.length > e5.length ? t9 : e5;
        }, 0));
        var n11 = new S2(this.dCtx.ctx), l8 = r13;
        r13 = n11.xLabelFormat(s11, r13, l8, { i: void 0, dateFormatter: new A2(this.dCtx.ctx).formatDate, w: e4 }), o10 = n11.xLabelFormat(s11, o10, l8, { i: void 0, dateFormatter: new A2(this.dCtx.ctx).formatDate, w: e4 }), (e4.config.xaxis.convertedCatToNumeric && void 0 === r13 || "" === String(r13).trim()) && (o10 = r13 = "1");
        var h4 = new m3(this.dCtx.ctx), c7 = h4.getTextRects(r13, e4.config.xaxis.labels.style.fontSize), d9 = c7;
        if (r13 !== o10 && (d9 = h4.getTextRects(o10, e4.config.xaxis.labels.style.fontSize)), (t8 = { width: c7.width >= d9.width ? c7.width : d9.width, height: c7.height >= d9.height ? c7.height : d9.height }).width * i17.length > e4.globals.svgWidth - this.dCtx.lgWidthForSideLegends - this.dCtx.yAxisWidth - this.dCtx.gridPad.left - this.dCtx.gridPad.right && 0 !== e4.config.xaxis.labels.rotate || e4.config.xaxis.labels.rotateAlways) {
          if (!e4.globals.isBarHorizontal) {
            e4.globals.rotateXLabels = true;
            var g7 = function(t9) {
              return h4.getTextRects(t9, e4.config.xaxis.labels.style.fontSize, e4.config.xaxis.labels.style.fontFamily, "rotate(".concat(e4.config.xaxis.labels.rotate, " 0 0)"), false);
            };
            c7 = g7(r13), r13 !== o10 && (d9 = g7(o10)), t8.height = (c7.height > d9.height ? c7.height : d9.height) / 1.5, t8.width = c7.width > d9.width ? c7.width : d9.width;
          }
        } else
          e4.globals.rotateXLabels = false;
      }
      return e4.config.xaxis.labels.show || (t8 = { width: 0, height: 0 }), { width: t8.width, height: t8.height };
    } }, { key: "getxAxisGroupLabelsCoords", value: function() {
      var t8, e4 = this.w;
      if (!e4.globals.hasXaxisGroups)
        return { width: 0, height: 0 };
      var i17, a10 = (null === (t8 = e4.config.xaxis.group.style) || void 0 === t8 ? void 0 : t8.fontSize) || e4.config.xaxis.labels.style.fontSize, s11 = e4.globals.groups.map(function(t9) {
        return t9.title;
      }), r13 = x3.getLargestStringFromArr(s11), o10 = this.dCtx.dimHelpers.getLargestStringFromMultiArr(r13, s11), n11 = new m3(this.dCtx.ctx), l8 = n11.getTextRects(r13, a10), h4 = l8;
      return r13 !== o10 && (h4 = n11.getTextRects(o10, a10)), i17 = { width: l8.width >= h4.width ? l8.width : h4.width, height: l8.height >= h4.height ? l8.height : h4.height }, e4.config.xaxis.labels.show || (i17 = { width: 0, height: 0 }), { width: i17.width, height: i17.height };
    } }, { key: "getxAxisTitleCoords", value: function() {
      var t8 = this.w, e4 = 0, i17 = 0;
      if (void 0 !== t8.config.xaxis.title.text) {
        var a10 = new m3(this.dCtx.ctx).getTextRects(t8.config.xaxis.title.text, t8.config.xaxis.title.style.fontSize);
        e4 = a10.width, i17 = a10.height;
      }
      return { width: e4, height: i17 };
    } }, { key: "getxAxisTimeScaleLabelsCoords", value: function() {
      var t8, e4 = this.w;
      this.dCtx.timescaleLabels = e4.globals.timescaleLabels.slice();
      var i17 = this.dCtx.timescaleLabels.map(function(t9) {
        return t9.value;
      }), a10 = i17.reduce(function(t9, e5) {
        return void 0 === t9 ? (console.error("You have possibly supplied invalid Date format. Please supply a valid JavaScript Date"), 0) : t9.length > e5.length ? t9 : e5;
      }, 0);
      return 1.05 * (t8 = new m3(this.dCtx.ctx).getTextRects(a10, e4.config.xaxis.labels.style.fontSize)).width * i17.length > e4.globals.gridWidth && 0 !== e4.config.xaxis.labels.rotate && (e4.globals.overlappingXLabels = true), t8;
    } }, { key: "additionalPaddingXLabels", value: function(t8) {
      var e4 = this, i17 = this.w, a10 = i17.globals, s11 = i17.config, r13 = s11.xaxis.type, o10 = t8.width;
      a10.skipLastTimelinelabel = false, a10.skipFirstTimelinelabel = false;
      var n11 = i17.config.yaxis[0].opposite && i17.globals.isBarHorizontal, l8 = function(t9, n12) {
        s11.yaxis.length > 1 && function(t10) {
          return -1 !== a10.collapsedSeriesIndices.indexOf(t10);
        }(n12) || function(t10) {
          if (e4.dCtx.timescaleLabels && e4.dCtx.timescaleLabels.length) {
            var n13 = e4.dCtx.timescaleLabels[0], l9 = e4.dCtx.timescaleLabels[e4.dCtx.timescaleLabels.length - 1].position + o10 / 1.75 - e4.dCtx.yAxisWidthRight, h4 = n13.position - o10 / 1.75 + e4.dCtx.yAxisWidthLeft, c7 = "right" === i17.config.legend.position && e4.dCtx.lgRect.width > 0 ? e4.dCtx.lgRect.width : 0;
            l9 > a10.svgWidth - a10.translateX - c7 && (a10.skipLastTimelinelabel = true), h4 < -(t10.show && !t10.floating || "bar" !== s11.chart.type && "candlestick" !== s11.chart.type && "rangeBar" !== s11.chart.type && "boxPlot" !== s11.chart.type ? 10 : o10 / 1.75) && (a10.skipFirstTimelinelabel = true);
          } else
            "datetime" === r13 ? e4.dCtx.gridPad.right < o10 && !a10.rotateXLabels && (a10.skipLastTimelinelabel = true) : "datetime" !== r13 && e4.dCtx.gridPad.right < o10 / 2 - e4.dCtx.yAxisWidthRight && !a10.rotateXLabels && !i17.config.xaxis.labels.trim && (e4.dCtx.xPadRight = o10 / 2 + 1);
        }(t9);
      };
      s11.yaxis.forEach(function(t9, i18) {
        n11 ? (e4.dCtx.gridPad.left < o10 && (e4.dCtx.xPadLeft = o10 / 2 + 1), e4.dCtx.xPadRight = o10 / 2 + 1) : l8(t9, i18);
      });
    } }]), t7;
  }(), st = function() {
    function t7(e4) {
      a9(this, t7), this.w = e4.w, this.dCtx = e4;
    }
    return r12(t7, [{ key: "getyAxisLabelsCoords", value: function() {
      var t8 = this, e4 = this.w, i17 = [], a10 = 10, s11 = new C2(this.dCtx.ctx);
      return e4.config.yaxis.map(function(r13, o10) {
        var n11 = { seriesIndex: o10, dataPointIndex: -1, w: e4 }, l8 = e4.globals.yAxisScale[o10], h4 = 0;
        if (!s11.isYAxisHidden(o10) && r13.labels.show && void 0 !== r13.labels.minWidth && (h4 = r13.labels.minWidth), !s11.isYAxisHidden(o10) && r13.labels.show && l8.result.length) {
          var c7 = e4.globals.yLabelFormatters[o10], d9 = l8.niceMin === Number.MIN_VALUE ? 0 : l8.niceMin, g7 = l8.result.reduce(function(t9, e5) {
            var i18, a11;
            return (null === (i18 = String(c7(t9, n11))) || void 0 === i18 ? void 0 : i18.length) > (null === (a11 = String(c7(e5, n11))) || void 0 === a11 ? void 0 : a11.length) ? t9 : e5;
          }, d9), u6 = g7 = c7(g7, n11);
          if (void 0 !== g7 && 0 !== g7.length || (g7 = l8.niceMax), e4.globals.isBarHorizontal) {
            a10 = 0;
            var p7 = e4.globals.labels.slice();
            g7 = x3.getLargestStringFromArr(p7), g7 = c7(g7, { seriesIndex: o10, dataPointIndex: -1, w: e4 }), u6 = t8.dCtx.dimHelpers.getLargestStringFromMultiArr(g7, p7);
          }
          var f5 = new m3(t8.dCtx.ctx), b3 = "rotate(".concat(r13.labels.rotate, " 0 0)"), v5 = f5.getTextRects(g7, r13.labels.style.fontSize, r13.labels.style.fontFamily, b3, false), y5 = v5;
          g7 !== u6 && (y5 = f5.getTextRects(u6, r13.labels.style.fontSize, r13.labels.style.fontFamily, b3, false)), i17.push({ width: (h4 > y5.width || h4 > v5.width ? h4 : y5.width > v5.width ? y5.width : v5.width) + a10, height: y5.height > v5.height ? y5.height : v5.height });
        } else
          i17.push({ width: 0, height: 0 });
      }), i17;
    } }, { key: "getyAxisTitleCoords", value: function() {
      var t8 = this, e4 = this.w, i17 = [];
      return e4.config.yaxis.map(function(e5, a10) {
        if (e5.show && void 0 !== e5.title.text) {
          var s11 = new m3(t8.dCtx.ctx), r13 = "rotate(".concat(e5.title.rotate, " 0 0)"), o10 = s11.getTextRects(e5.title.text, e5.title.style.fontSize, e5.title.style.fontFamily, r13, false);
          i17.push({ width: o10.width, height: o10.height });
        } else
          i17.push({ width: 0, height: 0 });
      }), i17;
    } }, { key: "getTotalYAxisWidth", value: function() {
      var t8 = this.w, e4 = 0, i17 = 0, a10 = 0, s11 = t8.globals.yAxisScale.length > 1 ? 10 : 0, r13 = new C2(this.dCtx.ctx), o10 = function(o11, n11) {
        var l8 = t8.config.yaxis[n11].floating, h4 = 0;
        o11.width > 0 && !l8 ? (h4 = o11.width + s11, function(e5) {
          return t8.globals.ignoreYAxisIndexes.indexOf(e5) > -1;
        }(n11) && (h4 = h4 - o11.width - s11)) : h4 = l8 || r13.isYAxisHidden(n11) ? 0 : 5, t8.config.yaxis[n11].opposite ? a10 += h4 : i17 += h4, e4 += h4;
      };
      return t8.globals.yLabelsCoords.map(function(t9, e5) {
        o10(t9, e5);
      }), t8.globals.yTitleCoords.map(function(t9, e5) {
        o10(t9, e5);
      }), t8.globals.isBarHorizontal && !t8.config.yaxis[0].floating && (e4 = t8.globals.yLabelsCoords[0].width + t8.globals.yTitleCoords[0].width + 15), this.dCtx.yAxisWidthLeft = i17, this.dCtx.yAxisWidthRight = a10, e4;
    } }]), t7;
  }(), rt = function() {
    function t7(e4) {
      a9(this, t7), this.w = e4.w, this.dCtx = e4;
    }
    return r12(t7, [{ key: "gridPadForColumnsInNumericAxis", value: function(t8) {
      var e4 = this.w, i17 = e4.config, a10 = e4.globals;
      if (a10.noData || a10.collapsedSeries.length + a10.ancillaryCollapsedSeries.length === i17.series.length)
        return 0;
      var s11 = function(t9) {
        return "bar" === t9 || "rangeBar" === t9 || "candlestick" === t9 || "boxPlot" === t9;
      }, r13 = i17.chart.type, o10 = 0, n11 = s11(r13) ? i17.series.length : 1;
      a10.comboBarCount > 0 && (n11 = a10.comboBarCount), a10.collapsedSeries.forEach(function(t9) {
        s11(t9.type) && (n11 -= 1);
      }), i17.chart.stacked && (n11 = 1);
      var l8 = s11(r13) || a10.comboBarCount > 0, h4 = Math.abs(a10.initialMaxX - a10.initialMinX);
      if (l8 && a10.isXNumeric && !a10.isBarHorizontal && n11 > 0 && 0 !== h4) {
        var c7, d9;
        h4 <= 3 && (h4 = a10.dataPoints), c7 = h4 / t8, a10.minXDiff && a10.minXDiff / c7 > 0 && (d9 = a10.minXDiff / c7), d9 > t8 / 2 && (d9 /= 2), (o10 = d9 * parseInt(i17.plotOptions.bar.columnWidth, 10) / 100) < 1 && (o10 = 1), a10.barPadForNumericAxis = o10;
      }
      return o10;
    } }, { key: "gridPadFortitleSubtitle", value: function() {
      var t8 = this, e4 = this.w, i17 = e4.globals, a10 = this.dCtx.isSparkline || !e4.globals.axisCharts ? 0 : 10;
      ["title", "subtitle"].forEach(function(i18) {
        void 0 !== e4.config[i18].text ? a10 += e4.config[i18].margin : a10 += t8.dCtx.isSparkline || !e4.globals.axisCharts ? 0 : 5;
      }), !e4.config.legend.show || "bottom" !== e4.config.legend.position || e4.config.legend.floating || e4.globals.axisCharts || (a10 += 10);
      var s11 = this.dCtx.dimHelpers.getTitleSubtitleCoords("title"), r13 = this.dCtx.dimHelpers.getTitleSubtitleCoords("subtitle");
      i17.gridHeight = i17.gridHeight - s11.height - r13.height - a10, i17.translateY = i17.translateY + s11.height + r13.height + a10;
    } }, { key: "setGridXPosForDualYAxis", value: function(t8, e4) {
      var i17 = this.w, a10 = new C2(this.dCtx.ctx);
      i17.config.yaxis.map(function(s11, r13) {
        -1 !== i17.globals.ignoreYAxisIndexes.indexOf(r13) || s11.floating || a10.isYAxisHidden(r13) || (s11.opposite && (i17.globals.translateX = i17.globals.translateX - (e4[r13].width + t8[r13].width) - parseInt(i17.config.yaxis[r13].labels.style.fontSize, 10) / 1.2 - 12), i17.globals.translateX < 2 && (i17.globals.translateX = 2));
      });
    } }]), t7;
  }(), ot = function() {
    function t7(e4) {
      a9(this, t7), this.ctx = e4, this.w = e4.w, this.lgRect = {}, this.yAxisWidth = 0, this.yAxisWidthLeft = 0, this.yAxisWidthRight = 0, this.xAxisHeight = 0, this.isSparkline = this.w.config.chart.sparkline.enabled, this.dimHelpers = new it(this), this.dimYAxis = new st(this), this.dimXAxis = new at(this), this.dimGrid = new rt(this), this.lgWidthForSideLegends = 0, this.gridPad = this.w.config.grid.padding, this.xPadRight = 0, this.xPadLeft = 0;
    }
    return r12(t7, [{ key: "plotCoords", value: function() {
      var t8 = this, e4 = this.w, i17 = e4.globals;
      this.lgRect = this.dimHelpers.getLegendsRect(), this.datalabelsCoords = { width: 0, height: 0 };
      var a10 = Array.isArray(e4.config.stroke.width) ? Math.max.apply(Math, u5(e4.config.stroke.width)) : e4.config.stroke.width;
      this.isSparkline && ((e4.config.markers.discrete.length > 0 || e4.config.markers.size > 0) && Object.entries(this.gridPad).forEach(function(e5) {
        var i18 = g6(e5, 2), a11 = i18[0], s12 = i18[1];
        t8.gridPad[a11] = Math.max(s12, t8.w.globals.markers.largestSize / 1.5);
      }), this.gridPad.top = Math.max(a10 / 2, this.gridPad.top), this.gridPad.bottom = Math.max(a10 / 2, this.gridPad.bottom)), i17.axisCharts ? this.setDimensionsForAxisCharts() : this.setDimensionsForNonAxisCharts(), this.dimGrid.gridPadFortitleSubtitle(), i17.gridHeight = i17.gridHeight - this.gridPad.top - this.gridPad.bottom, i17.gridWidth = i17.gridWidth - this.gridPad.left - this.gridPad.right - this.xPadRight - this.xPadLeft;
      var s11 = this.dimGrid.gridPadForColumnsInNumericAxis(i17.gridWidth);
      i17.gridWidth = i17.gridWidth - 2 * s11, i17.translateX = i17.translateX + this.gridPad.left + this.xPadLeft + (s11 > 0 ? s11 : 0), i17.translateY = i17.translateY + this.gridPad.top;
    } }, { key: "setDimensionsForAxisCharts", value: function() {
      var t8 = this, e4 = this.w, i17 = e4.globals, a10 = this.dimYAxis.getyAxisLabelsCoords(), s11 = this.dimYAxis.getyAxisTitleCoords();
      i17.isSlopeChart && (this.datalabelsCoords = this.dimHelpers.getDatalabelsRect()), e4.globals.yLabelsCoords = [], e4.globals.yTitleCoords = [], e4.config.yaxis.map(function(t9, i18) {
        e4.globals.yLabelsCoords.push({ width: a10[i18].width, index: i18 }), e4.globals.yTitleCoords.push({ width: s11[i18].width, index: i18 });
      }), this.yAxisWidth = this.dimYAxis.getTotalYAxisWidth();
      var r13 = this.dimXAxis.getxAxisLabelsCoords(), o10 = this.dimXAxis.getxAxisGroupLabelsCoords(), n11 = this.dimXAxis.getxAxisTitleCoords();
      this.conditionalChecksForAxisCoords(r13, n11, o10), i17.translateXAxisY = e4.globals.rotateXLabels ? this.xAxisHeight / 8 : -4, i17.translateXAxisX = e4.globals.rotateXLabels && e4.globals.isXNumeric && e4.config.xaxis.labels.rotate <= -45 ? -this.xAxisWidth / 4 : 0, e4.globals.isBarHorizontal && (i17.rotateXLabels = false, i17.translateXAxisY = parseInt(e4.config.xaxis.labels.style.fontSize, 10) / 1.5 * -1), i17.translateXAxisY = i17.translateXAxisY + e4.config.xaxis.labels.offsetY, i17.translateXAxisX = i17.translateXAxisX + e4.config.xaxis.labels.offsetX;
      var l8 = this.yAxisWidth, h4 = this.xAxisHeight;
      i17.xAxisLabelsHeight = this.xAxisHeight - n11.height, i17.xAxisGroupLabelsHeight = i17.xAxisLabelsHeight - r13.height, i17.xAxisLabelsWidth = this.xAxisWidth, i17.xAxisHeight = this.xAxisHeight;
      var c7 = 10;
      ("radar" === e4.config.chart.type || this.isSparkline) && (l8 = 0, h4 = i17.goldenPadding), this.isSparkline && (this.lgRect = { height: 0, width: 0 }), (this.isSparkline || "treemap" === e4.config.chart.type) && (l8 = 0, h4 = 0, c7 = 0), this.isSparkline || this.dimXAxis.additionalPaddingXLabels(r13);
      var d9 = function() {
        i17.translateX = l8 + t8.datalabelsCoords.width, i17.gridHeight = i17.svgHeight - t8.lgRect.height - h4 - (t8.isSparkline || "treemap" === e4.config.chart.type ? 0 : e4.globals.rotateXLabels ? 10 : 15), i17.gridWidth = i17.svgWidth - l8 - 2 * t8.datalabelsCoords.width;
      };
      switch ("top" === e4.config.xaxis.position && (c7 = i17.xAxisHeight - e4.config.xaxis.axisTicks.height - 5), e4.config.legend.position) {
        case "bottom":
          i17.translateY = c7, d9();
          break;
        case "top":
          i17.translateY = this.lgRect.height + c7, d9();
          break;
        case "left":
          i17.translateY = c7, i17.translateX = this.lgRect.width + l8 + this.datalabelsCoords.width, i17.gridHeight = i17.svgHeight - h4 - 12, i17.gridWidth = i17.svgWidth - this.lgRect.width - l8 - 2 * this.datalabelsCoords.width;
          break;
        case "right":
          i17.translateY = c7, i17.translateX = l8 + this.datalabelsCoords.width, i17.gridHeight = i17.svgHeight - h4 - 12, i17.gridWidth = i17.svgWidth - this.lgRect.width - l8 - 2 * this.datalabelsCoords.width - 5;
          break;
        default:
          throw new Error("Legend position not supported");
      }
      this.dimGrid.setGridXPosForDualYAxis(s11, a10), new q2(this.ctx).setYAxisXPosition(a10, s11);
    } }, { key: "setDimensionsForNonAxisCharts", value: function() {
      var t8 = this.w, e4 = t8.globals, i17 = t8.config, a10 = 0;
      t8.config.legend.show && !t8.config.legend.floating && (a10 = 20);
      var s11 = "pie" === i17.chart.type || "polarArea" === i17.chart.type || "donut" === i17.chart.type ? "pie" : "radialBar", r13 = i17.plotOptions[s11].offsetY, o10 = i17.plotOptions[s11].offsetX;
      if (!i17.legend.show || i17.legend.floating) {
        e4.gridHeight = e4.svgHeight - i17.grid.padding.top - i17.grid.padding.bottom;
        var n11 = e4.dom.elWrap.getBoundingClientRect().width;
        return e4.gridWidth = Math.min(n11, e4.gridHeight) - i17.grid.padding.left - i17.grid.padding.right, e4.translateY = r13, void (e4.translateX = o10 + (e4.svgWidth - e4.gridWidth) / 2);
      }
      switch (i17.legend.position) {
        case "bottom":
          e4.gridHeight = e4.svgHeight - this.lgRect.height - e4.goldenPadding, e4.gridWidth = e4.svgWidth, e4.translateY = r13 - 10, e4.translateX = o10 + (e4.svgWidth - e4.gridWidth) / 2;
          break;
        case "top":
          e4.gridHeight = e4.svgHeight - this.lgRect.height - e4.goldenPadding, e4.gridWidth = e4.svgWidth, e4.translateY = this.lgRect.height + r13 + 10, e4.translateX = o10 + (e4.svgWidth - e4.gridWidth) / 2;
          break;
        case "left":
          e4.gridWidth = e4.svgWidth - this.lgRect.width - a10, e4.gridHeight = "auto" !== i17.chart.height ? e4.svgHeight : e4.gridWidth, e4.translateY = r13, e4.translateX = o10 + this.lgRect.width + a10;
          break;
        case "right":
          e4.gridWidth = e4.svgWidth - this.lgRect.width - a10 - 5, e4.gridHeight = "auto" !== i17.chart.height ? e4.svgHeight : e4.gridWidth, e4.translateY = r13, e4.translateX = o10 + 10;
          break;
        default:
          throw new Error("Legend position not supported");
      }
    } }, { key: "conditionalChecksForAxisCoords", value: function(t8, e4, i17) {
      var a10 = this.w, s11 = a10.globals.hasXaxisGroups ? 2 : 1, r13 = i17.height + t8.height + e4.height, o10 = a10.globals.isMultiLineX ? 1.2 : a10.globals.LINE_HEIGHT_RATIO, n11 = a10.globals.rotateXLabels ? 22 : 10, l8 = a10.globals.rotateXLabels && "bottom" === a10.config.legend.position ? 10 : 0;
      this.xAxisHeight = r13 * o10 + s11 * n11 + l8, this.xAxisWidth = t8.width, this.xAxisHeight - e4.height > a10.config.xaxis.labels.maxHeight && (this.xAxisHeight = a10.config.xaxis.labels.maxHeight), a10.config.xaxis.labels.minHeight && this.xAxisHeight < a10.config.xaxis.labels.minHeight && (this.xAxisHeight = a10.config.xaxis.labels.minHeight), a10.config.xaxis.floating && (this.xAxisHeight = 0);
      var h4 = 0, c7 = 0;
      a10.config.yaxis.forEach(function(t9) {
        h4 += t9.labels.minWidth, c7 += t9.labels.maxWidth;
      }), this.yAxisWidth < h4 && (this.yAxisWidth = h4), this.yAxisWidth > c7 && (this.yAxisWidth = c7);
    } }]), t7;
  }(), nt = function() {
    function t7(e4) {
      a9(this, t7), this.w = e4.w, this.lgCtx = e4;
    }
    return r12(t7, [{ key: "getLegendStyles", value: function() {
      var t8, e4, i17, a10 = document.createElement("style");
      a10.setAttribute("type", "text/css");
      var s11 = (null === (t8 = this.lgCtx.ctx) || void 0 === t8 || null === (e4 = t8.opts) || void 0 === e4 || null === (i17 = e4.chart) || void 0 === i17 ? void 0 : i17.nonce) || this.w.config.chart.nonce;
      s11 && a10.setAttribute("nonce", s11);
      var r13 = document.createTextNode("\n      .apexcharts-legend {\n        display: flex;\n        overflow: auto;\n        padding: 0 10px;\n      }\n      .apexcharts-legend.apx-legend-position-bottom, .apexcharts-legend.apx-legend-position-top {\n        flex-wrap: wrap\n      }\n      .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {\n        flex-direction: column;\n        bottom: 0;\n      }\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-left, .apexcharts-legend.apx-legend-position-top.apexcharts-align-left, .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {\n        justify-content: flex-start;\n      }\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-center, .apexcharts-legend.apx-legend-position-top.apexcharts-align-center {\n        justify-content: center;\n      }\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-right, .apexcharts-legend.apx-legend-position-top.apexcharts-align-right {\n        justify-content: flex-end;\n      }\n      .apexcharts-legend-series {\n        cursor: pointer;\n        line-height: normal;\n        display: flex;\n        align-items: center;\n      }\n      .apexcharts-legend-text {\n        position: relative;\n        font-size: 14px;\n      }\n      .apexcharts-legend-text *, .apexcharts-legend-marker * {\n        pointer-events: none;\n      }\n      .apexcharts-legend-marker {\n        position: relative;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        cursor: pointer;\n        margin-right: 1px;\n      }\n\n      .apexcharts-legend-series.apexcharts-no-click {\n        cursor: auto;\n      }\n      .apexcharts-legend .apexcharts-hidden-zero-series, .apexcharts-legend .apexcharts-hidden-null-series {\n        display: none !important;\n      }\n      .apexcharts-inactive-legend {\n        opacity: 0.45;\n      }");
      return a10.appendChild(r13), a10;
    } }, { key: "getLegendDimensions", value: function() {
      var t8 = this.w.globals.dom.baseEl.querySelector(".apexcharts-legend"), e4 = t8.offsetWidth;
      return { clwh: t8.offsetHeight, clww: e4 };
    } }, { key: "appendToForeignObject", value: function() {
      this.w.globals.dom.elLegendForeign.appendChild(this.getLegendStyles());
    } }, { key: "toggleDataSeries", value: function(t8, e4) {
      var i17 = this, a10 = this.w;
      if (a10.globals.axisCharts || "radialBar" === a10.config.chart.type) {
        a10.globals.resized = true;
        var s11 = null, r13 = null;
        if (a10.globals.risingSeries = [], a10.globals.axisCharts ? (s11 = a10.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(t8, "']")), r13 = parseInt(s11.getAttribute("data:realIndex"), 10)) : (s11 = a10.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(t8 + 1, "']")), r13 = parseInt(s11.getAttribute("rel"), 10) - 1), e4)
          [{ cs: a10.globals.collapsedSeries, csi: a10.globals.collapsedSeriesIndices }, { cs: a10.globals.ancillaryCollapsedSeries, csi: a10.globals.ancillaryCollapsedSeriesIndices }].forEach(function(t9) {
            i17.riseCollapsedSeries(t9.cs, t9.csi, r13);
          });
        else
          this.hideSeries({ seriesEl: s11, realIndex: r13 });
      } else {
        var o10 = a10.globals.dom.Paper.select(" .apexcharts-series[rel='".concat(t8 + 1, "'] path")), n11 = a10.config.chart.type;
        if ("pie" === n11 || "polarArea" === n11 || "donut" === n11) {
          var l8 = a10.config.plotOptions.pie.donut.labels;
          new m3(this.lgCtx.ctx).pathMouseDown(o10.members[0], null), this.lgCtx.ctx.pie.printDataLabelsInner(o10.members[0].node, l8);
        }
        o10.fire("click");
      }
    } }, { key: "hideSeries", value: function(t8) {
      var e4 = t8.seriesEl, i17 = t8.realIndex, a10 = this.w, s11 = a10.globals, r13 = x3.clone(a10.config.series);
      if (s11.axisCharts) {
        var o10 = a10.config.yaxis[s11.seriesYAxisReverseMap[i17]];
        if (o10 && o10.show && o10.showAlways)
          s11.ancillaryCollapsedSeriesIndices.indexOf(i17) < 0 && (s11.ancillaryCollapsedSeries.push({ index: i17, data: r13[i17].data.slice(), type: e4.parentNode.className.baseVal.split("-")[1] }), s11.ancillaryCollapsedSeriesIndices.push(i17));
        else if (s11.collapsedSeriesIndices.indexOf(i17) < 0) {
          s11.collapsedSeries.push({ index: i17, data: r13[i17].data.slice(), type: e4.parentNode.className.baseVal.split("-")[1] }), s11.collapsedSeriesIndices.push(i17);
          var n11 = s11.risingSeries.indexOf(i17);
          s11.risingSeries.splice(n11, 1);
        }
      } else
        s11.collapsedSeries.push({ index: i17, data: r13[i17] }), s11.collapsedSeriesIndices.push(i17);
      for (var l8 = e4.childNodes, h4 = 0; h4 < l8.length; h4++)
        l8[h4].classList.contains("apexcharts-series-markers-wrap") && (l8[h4].classList.contains("apexcharts-hide") ? l8[h4].classList.remove("apexcharts-hide") : l8[h4].classList.add("apexcharts-hide"));
      s11.allSeriesCollapsed = s11.collapsedSeries.length + s11.ancillaryCollapsedSeries.length === a10.config.series.length, r13 = this._getSeriesBasedOnCollapsedState(r13), this.lgCtx.ctx.updateHelpers._updateSeries(r13, a10.config.chart.animations.dynamicAnimation.enabled);
    } }, { key: "riseCollapsedSeries", value: function(t8, e4, i17) {
      var a10 = this.w, s11 = x3.clone(a10.config.series);
      if (t8.length > 0) {
        for (var r13 = 0; r13 < t8.length; r13++)
          t8[r13].index === i17 && (a10.globals.axisCharts ? (s11[i17].data = t8[r13].data.slice(), t8.splice(r13, 1), e4.splice(r13, 1), a10.globals.risingSeries.push(i17)) : (s11[i17] = t8[r13].data, t8.splice(r13, 1), e4.splice(r13, 1), a10.globals.risingSeries.push(i17)));
        s11 = this._getSeriesBasedOnCollapsedState(s11), this.lgCtx.ctx.updateHelpers._updateSeries(s11, a10.config.chart.animations.dynamicAnimation.enabled);
      }
    } }, { key: "_getSeriesBasedOnCollapsedState", value: function(t8) {
      var e4 = this.w, i17 = 0;
      return e4.globals.axisCharts ? t8.forEach(function(a10, s11) {
        e4.globals.collapsedSeriesIndices.indexOf(s11) < 0 && e4.globals.ancillaryCollapsedSeriesIndices.indexOf(s11) < 0 || (t8[s11].data = [], i17++);
      }) : t8.forEach(function(a10, s11) {
        !e4.globals.collapsedSeriesIndices.indexOf(s11) < 0 && (t8[s11] = 0, i17++);
      }), e4.globals.allSeriesCollapsed = i17 === t8.length, t8;
    } }]), t7;
  }(), lt = function() {
    function t7(e4) {
      a9(this, t7), this.ctx = e4, this.w = e4.w, this.onLegendClick = this.onLegendClick.bind(this), this.onLegendHovered = this.onLegendHovered.bind(this), this.isBarsDistributed = "bar" === this.w.config.chart.type && this.w.config.plotOptions.bar.distributed && 1 === this.w.config.series.length, this.legendHelpers = new nt(this);
    }
    return r12(t7, [{ key: "init", value: function() {
      var t8 = this.w, e4 = t8.globals, i17 = t8.config;
      if ((i17.legend.showForSingleSeries && 1 === e4.series.length || this.isBarsDistributed || e4.series.length > 1 || !e4.axisCharts) && i17.legend.show) {
        for (; e4.dom.elLegendWrap.firstChild; )
          e4.dom.elLegendWrap.removeChild(e4.dom.elLegendWrap.firstChild);
        this.drawLegends(), x3.isIE11() ? document.getElementsByTagName("head")[0].appendChild(this.legendHelpers.getLegendStyles()) : this.legendHelpers.appendToForeignObject(), "bottom" === i17.legend.position || "top" === i17.legend.position ? this.legendAlignHorizontal() : "right" !== i17.legend.position && "left" !== i17.legend.position || this.legendAlignVertical();
      }
    } }, { key: "createLegendMarker", value: function(t8) {
      var i17 = t8.i, a10 = t8.fillcolor, s11 = this.w, r13 = document.createElement("span");
      r13.classList.add("apexcharts-legend-marker");
      var o10 = s11.config.legend.markers.shape || s11.config.markers.shape, n11 = o10;
      Array.isArray(o10) && (n11 = o10[i17]);
      var l8 = Array.isArray(s11.config.legend.markers.size) ? parseFloat(s11.config.legend.markers.size[i17]) : parseFloat(s11.config.legend.markers.size), h4 = Array.isArray(s11.config.legend.markers.offsetX) ? parseFloat(s11.config.legend.markers.offsetX[i17]) : parseFloat(s11.config.legend.markers.offsetX), c7 = Array.isArray(s11.config.legend.markers.offsetY) ? parseFloat(s11.config.legend.markers.offsetY[i17]) : parseFloat(s11.config.legend.markers.offsetY), d9 = Array.isArray(s11.config.legend.markers.strokeWidth) ? parseFloat(s11.config.legend.markers.strokeWidth[i17]) : parseFloat(s11.config.legend.markers.strokeWidth), g7 = r13.style;
      if (g7.height = 2 * (l8 + d9) + "px", g7.width = 2 * (l8 + d9) + "px", g7.left = h4 + "px", g7.top = c7 + "px", s11.config.legend.markers.customHTML)
        g7.background = "transparent", g7.color = a10[i17], Array.isArray(s11.config.legend.markers.customHTML) ? s11.config.legend.markers.customHTML[i17] && (r13.innerHTML = s11.config.legend.markers.customHTML[i17]()) : r13.innerHTML = s11.config.legend.markers.customHTML();
      else {
        var u6 = new D2(this.ctx).getMarkerConfig({ cssClass: "apexcharts-legend-marker apexcharts-marker apexcharts-marker-".concat(n11), seriesIndex: i17, strokeWidth: d9, size: l8 }), p7 = SVG(r13).size("100%", "100%"), f5 = new m3(this.ctx).drawMarker(0, 0, e3(e3({}, u6), {}, { pointFillColor: Array.isArray(a10) ? a10[i17] : u6.pointFillColor, shape: n11 }));
        SVG.select(".apexcharts-legend-marker.apexcharts-marker").members.forEach(function(t9) {
          t9.node.classList.contains("apexcharts-marker-triangle") ? t9.node.style.transform = "translate(50%, 45%)" : t9.node.style.transform = "translate(50%, 50%)";
        }), p7.add(f5);
      }
      return r13;
    } }, { key: "drawLegends", value: function() {
      var t8 = this, e4 = this.w, i17 = e4.config.legend.fontFamily, a10 = e4.globals.seriesNames, s11 = e4.config.legend.markers.fillColors ? e4.config.legend.markers.fillColors.slice() : e4.globals.colors.slice();
      if ("heatmap" === e4.config.chart.type) {
        var r13 = e4.config.plotOptions.heatmap.colorScale.ranges;
        a10 = r13.map(function(t9) {
          return t9.name ? t9.name : t9.from + " - " + t9.to;
        }), s11 = r13.map(function(t9) {
          return t9.color;
        });
      } else
        this.isBarsDistributed && (a10 = e4.globals.labels.slice());
      e4.config.legend.customLegendItems.length && (a10 = e4.config.legend.customLegendItems);
      for (var o10 = e4.globals.legendFormatter, n11 = e4.config.legend.inverseOrder, l8 = n11 ? a10.length - 1 : 0; n11 ? l8 >= 0 : l8 <= a10.length - 1; n11 ? l8-- : l8++) {
        var h4, c7 = o10(a10[l8], { seriesIndex: l8, w: e4 }), d9 = false, g7 = false;
        if (e4.globals.collapsedSeries.length > 0)
          for (var u6 = 0; u6 < e4.globals.collapsedSeries.length; u6++)
            e4.globals.collapsedSeries[u6].index === l8 && (d9 = true);
        if (e4.globals.ancillaryCollapsedSeriesIndices.length > 0)
          for (var p7 = 0; p7 < e4.globals.ancillaryCollapsedSeriesIndices.length; p7++)
            e4.globals.ancillaryCollapsedSeriesIndices[p7] === l8 && (g7 = true);
        var f5 = this.createLegendMarker({ i: l8, fillcolor: s11 });
        m3.setAttrs(f5, { rel: l8 + 1, "data:collapsed": d9 || g7 }), (d9 || g7) && f5.classList.add("apexcharts-inactive-legend");
        var b3 = document.createElement("div"), v5 = document.createElement("span");
        v5.classList.add("apexcharts-legend-text"), v5.innerHTML = Array.isArray(c7) ? c7.join(" ") : c7;
        var w4 = e4.config.legend.labels.useSeriesColors ? e4.globals.colors[l8] : Array.isArray(e4.config.legend.labels.colors) ? null === (h4 = e4.config.legend.labels.colors) || void 0 === h4 ? void 0 : h4[l8] : e4.config.legend.labels.colors;
        w4 || (w4 = e4.config.chart.foreColor), v5.style.color = w4, v5.style.fontSize = parseFloat(e4.config.legend.fontSize) + "px", v5.style.fontWeight = e4.config.legend.fontWeight, v5.style.fontFamily = i17 || e4.config.chart.fontFamily, m3.setAttrs(v5, { rel: l8 + 1, i: l8, "data:default-text": encodeURIComponent(c7), "data:collapsed": d9 || g7 }), b3.appendChild(f5), b3.appendChild(v5);
        var k4 = new y4(this.ctx);
        if (!e4.config.legend.showForZeroSeries)
          0 === k4.getSeriesTotalByIndex(l8) && k4.seriesHaveSameValues(l8) && !k4.isSeriesNull(l8) && -1 === e4.globals.collapsedSeriesIndices.indexOf(l8) && -1 === e4.globals.ancillaryCollapsedSeriesIndices.indexOf(l8) && b3.classList.add("apexcharts-hidden-zero-series");
        e4.config.legend.showForNullSeries || k4.isSeriesNull(l8) && -1 === e4.globals.collapsedSeriesIndices.indexOf(l8) && -1 === e4.globals.ancillaryCollapsedSeriesIndices.indexOf(l8) && b3.classList.add("apexcharts-hidden-null-series"), e4.globals.dom.elLegendWrap.appendChild(b3), e4.globals.dom.elLegendWrap.classList.add("apexcharts-align-".concat(e4.config.legend.horizontalAlign)), e4.globals.dom.elLegendWrap.classList.add("apx-legend-position-" + e4.config.legend.position), b3.classList.add("apexcharts-legend-series"), b3.style.margin = "".concat(e4.config.legend.itemMargin.vertical, "px ").concat(e4.config.legend.itemMargin.horizontal, "px"), e4.globals.dom.elLegendWrap.style.width = e4.config.legend.width ? e4.config.legend.width + "px" : "", e4.globals.dom.elLegendWrap.style.height = e4.config.legend.height ? e4.config.legend.height + "px" : "", m3.setAttrs(b3, { rel: l8 + 1, seriesName: x3.escapeString(a10[l8]), "data:collapsed": d9 || g7 }), (d9 || g7) && b3.classList.add("apexcharts-inactive-legend"), e4.config.legend.onItemClick.toggleDataSeries || b3.classList.add("apexcharts-no-click");
      }
      e4.globals.dom.elWrap.addEventListener("click", t8.onLegendClick, true), e4.config.legend.onItemHover.highlightDataSeries && 0 === e4.config.legend.customLegendItems.length && (e4.globals.dom.elWrap.addEventListener("mousemove", t8.onLegendHovered, true), e4.globals.dom.elWrap.addEventListener("mouseout", t8.onLegendHovered, true));
    } }, { key: "setLegendWrapXY", value: function(t8, e4) {
      var i17 = this.w, a10 = i17.globals.dom.elLegendWrap, s11 = a10.getBoundingClientRect(), r13 = 0, o10 = 0;
      if ("bottom" === i17.config.legend.position)
        o10 += i17.globals.svgHeight - s11.height / 2;
      else if ("top" === i17.config.legend.position) {
        var n11 = new ot(this.ctx), l8 = n11.dimHelpers.getTitleSubtitleCoords("title").height, h4 = n11.dimHelpers.getTitleSubtitleCoords("subtitle").height;
        o10 = o10 + (l8 > 0 ? l8 - 10 : 0) + (h4 > 0 ? h4 - 10 : 0);
      }
      a10.style.position = "absolute", r13 = r13 + t8 + i17.config.legend.offsetX, o10 = o10 + e4 + i17.config.legend.offsetY, a10.style.left = r13 + "px", a10.style.top = o10 + "px", "bottom" === i17.config.legend.position ? (a10.style.top = "auto", a10.style.bottom = 5 - i17.config.legend.offsetY + "px") : "right" === i17.config.legend.position && (a10.style.left = "auto", a10.style.right = 25 + i17.config.legend.offsetX + "px");
      ["width", "height"].forEach(function(t9) {
        a10.style[t9] && (a10.style[t9] = parseInt(i17.config.legend[t9], 10) + "px");
      });
    } }, { key: "legendAlignHorizontal", value: function() {
      var t8 = this.w;
      t8.globals.dom.elLegendWrap.style.right = 0;
      var e4 = this.legendHelpers.getLegendDimensions(), i17 = new ot(this.ctx), a10 = i17.dimHelpers.getTitleSubtitleCoords("title"), s11 = i17.dimHelpers.getTitleSubtitleCoords("subtitle"), r13 = 0;
      "bottom" === t8.config.legend.position ? r13 = -e4.clwh / 1.8 : "top" === t8.config.legend.position && (r13 = a10.height + s11.height + t8.config.title.margin + t8.config.subtitle.margin - 10), this.setLegendWrapXY(20, r13);
    } }, { key: "legendAlignVertical", value: function() {
      var t8 = this.w, e4 = this.legendHelpers.getLegendDimensions(), i17 = 0;
      "left" === t8.config.legend.position && (i17 = 20), "right" === t8.config.legend.position && (i17 = t8.globals.svgWidth - e4.clww - 10), this.setLegendWrapXY(i17, 20);
    } }, { key: "onLegendHovered", value: function(t8) {
      var e4 = this.w, i17 = t8.target.classList.contains("apexcharts-legend-series") || t8.target.classList.contains("apexcharts-legend-text") || t8.target.classList.contains("apexcharts-legend-marker");
      if ("heatmap" === e4.config.chart.type || this.isBarsDistributed) {
        if (i17) {
          var a10 = parseInt(t8.target.getAttribute("rel"), 10) - 1;
          this.ctx.events.fireEvent("legendHover", [this.ctx, a10, this.w]), new W3(this.ctx).highlightRangeInSeries(t8, t8.target);
        }
      } else
        !t8.target.classList.contains("apexcharts-inactive-legend") && i17 && new W3(this.ctx).toggleSeriesOnHover(t8, t8.target);
    } }, { key: "onLegendClick", value: function(t8) {
      var e4 = this.w;
      if (!e4.config.legend.customLegendItems.length && (t8.target.classList.contains("apexcharts-legend-series") || t8.target.classList.contains("apexcharts-legend-text") || t8.target.classList.contains("apexcharts-legend-marker"))) {
        var i17 = parseInt(t8.target.getAttribute("rel"), 10) - 1, a10 = "true" === t8.target.getAttribute("data:collapsed"), s11 = this.w.config.chart.events.legendClick;
        "function" == typeof s11 && s11(this.ctx, i17, this.w), this.ctx.events.fireEvent("legendClick", [this.ctx, i17, this.w]);
        var r13 = this.w.config.legend.markers.onClick;
        "function" == typeof r13 && t8.target.classList.contains("apexcharts-legend-marker") && (r13(this.ctx, i17, this.w), this.ctx.events.fireEvent("legendMarkerClick", [this.ctx, i17, this.w])), "treemap" !== e4.config.chart.type && "heatmap" !== e4.config.chart.type && !this.isBarsDistributed && e4.config.legend.onItemClick.toggleDataSeries && this.legendHelpers.toggleDataSeries(i17, a10);
      }
    } }]), t7;
  }(), ht = function() {
    function t7(e4) {
      a9(this, t7), this.ctx = e4, this.w = e4.w;
      var i17 = this.w;
      this.ev = this.w.config.chart.events, this.selectedClass = "apexcharts-selected", this.localeValues = this.w.globals.locale.toolbar, this.minX = i17.globals.minX, this.maxX = i17.globals.maxX;
    }
    return r12(t7, [{ key: "createToolbar", value: function() {
      var t8 = this, e4 = this.w, i17 = function() {
        return document.createElement("div");
      }, a10 = i17();
      if (a10.setAttribute("class", "apexcharts-toolbar"), a10.style.top = e4.config.chart.toolbar.offsetY + "px", a10.style.right = 3 - e4.config.chart.toolbar.offsetX + "px", e4.globals.dom.elWrap.appendChild(a10), this.elZoom = i17(), this.elZoomIn = i17(), this.elZoomOut = i17(), this.elPan = i17(), this.elSelection = i17(), this.elZoomReset = i17(), this.elMenuIcon = i17(), this.elMenu = i17(), this.elCustomIcons = [], this.t = e4.config.chart.toolbar.tools, Array.isArray(this.t.customIcons))
        for (var s11 = 0; s11 < this.t.customIcons.length; s11++)
          this.elCustomIcons.push(i17());
      var r13 = [], o10 = function(i18, a11, s12) {
        var o11 = i18.toLowerCase();
        t8.t[o11] && e4.config.chart.zoom.enabled && r13.push({ el: a11, icon: "string" == typeof t8.t[o11] ? t8.t[o11] : s12, title: t8.localeValues[i18], class: "apexcharts-".concat(o11, "-icon") });
      };
      o10("zoomIn", this.elZoomIn, '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n'), o10("zoomOut", this.elZoomOut, '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n');
      var n11 = function(i18) {
        t8.t[i18] && e4.config.chart[i18].enabled && r13.push({ el: "zoom" === i18 ? t8.elZoom : t8.elSelection, icon: "string" == typeof t8.t[i18] ? t8.t[i18] : "zoom" === i18 ? '<svg xmlns="http://www.w3.org/2000/svg" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>\n    <path d="M0 0h24v24H0V0z" fill="none"/>\n    <path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z"/>\n</svg>' : '<svg fill="#6E8192" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2z"/>\n</svg>', title: t8.localeValues["zoom" === i18 ? "selectionZoom" : "selection"], class: e4.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-".concat(i18, "-icon") });
      };
      n11("zoom"), n11("selection"), this.t.pan && e4.config.chart.zoom.enabled && r13.push({ el: this.elPan, icon: "string" == typeof this.t.pan ? this.t.pan : '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <defs>\n        <path d="M0 0h24v24H0z" id="a"/>\n    </defs>\n    <clipPath id="b">\n        <use overflow="visible" xlink:href="#a"/>\n    </clipPath>\n    <path clip-path="url(#b)" d="M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5z"/>\n</svg>', title: this.localeValues.pan, class: e4.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-pan-icon" }), o10("reset", this.elZoomReset, '<svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>\n    <path d="M0 0h24v24H0z" fill="none"/>\n</svg>'), this.t.download && r13.push({ el: this.elMenuIcon, icon: "string" == typeof this.t.download ? this.t.download : '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>', title: this.localeValues.menu, class: "apexcharts-menu-icon" });
      for (var l8 = 0; l8 < this.elCustomIcons.length; l8++)
        r13.push({ el: this.elCustomIcons[l8], icon: this.t.customIcons[l8].icon, title: this.t.customIcons[l8].title, index: this.t.customIcons[l8].index, class: "apexcharts-toolbar-custom-icon " + this.t.customIcons[l8].class });
      r13.forEach(function(t9, e5) {
        t9.index && x3.moveIndexInArray(r13, e5, t9.index);
      });
      for (var h4 = 0; h4 < r13.length; h4++)
        m3.setAttrs(r13[h4].el, { class: r13[h4].class, title: r13[h4].title }), r13[h4].el.innerHTML = r13[h4].icon, a10.appendChild(r13[h4].el);
      this._createHamburgerMenu(a10), e4.globals.zoomEnabled ? this.elZoom.classList.add(this.selectedClass) : e4.globals.panEnabled ? this.elPan.classList.add(this.selectedClass) : e4.globals.selectionEnabled && this.elSelection.classList.add(this.selectedClass), this.addToolbarEventListeners();
    } }, { key: "_createHamburgerMenu", value: function(t8) {
      this.elMenuItems = [], t8.appendChild(this.elMenu), m3.setAttrs(this.elMenu, { class: "apexcharts-menu" });
      for (var e4 = [{ name: "exportSVG", title: this.localeValues.exportToSVG }, { name: "exportPNG", title: this.localeValues.exportToPNG }, { name: "exportCSV", title: this.localeValues.exportToCSV }], i17 = 0; i17 < e4.length; i17++)
        this.elMenuItems.push(document.createElement("div")), this.elMenuItems[i17].innerHTML = e4[i17].title, m3.setAttrs(this.elMenuItems[i17], { class: "apexcharts-menu-item ".concat(e4[i17].name), title: e4[i17].title }), this.elMenu.appendChild(this.elMenuItems[i17]);
    } }, { key: "addToolbarEventListeners", value: function() {
      var t8 = this;
      this.elZoomReset.addEventListener("click", this.handleZoomReset.bind(this)), this.elSelection.addEventListener("click", this.toggleZoomSelection.bind(this, "selection")), this.elZoom.addEventListener("click", this.toggleZoomSelection.bind(this, "zoom")), this.elZoomIn.addEventListener("click", this.handleZoomIn.bind(this)), this.elZoomOut.addEventListener("click", this.handleZoomOut.bind(this)), this.elPan.addEventListener("click", this.togglePanning.bind(this)), this.elMenuIcon.addEventListener("click", this.toggleMenu.bind(this)), this.elMenuItems.forEach(function(e5) {
        e5.classList.contains("exportSVG") ? e5.addEventListener("click", t8.handleDownload.bind(t8, "svg")) : e5.classList.contains("exportPNG") ? e5.addEventListener("click", t8.handleDownload.bind(t8, "png")) : e5.classList.contains("exportCSV") && e5.addEventListener("click", t8.handleDownload.bind(t8, "csv"));
      });
      for (var e4 = 0; e4 < this.t.customIcons.length; e4++)
        this.elCustomIcons[e4].addEventListener("click", this.t.customIcons[e4].click.bind(this, this.ctx, this.ctx.w));
    } }, { key: "toggleZoomSelection", value: function(t8) {
      this.ctx.getSyncedCharts().forEach(function(e4) {
        e4.ctx.toolbar.toggleOtherControls();
        var i17 = "selection" === t8 ? e4.ctx.toolbar.elSelection : e4.ctx.toolbar.elZoom, a10 = "selection" === t8 ? "selectionEnabled" : "zoomEnabled";
        e4.w.globals[a10] = !e4.w.globals[a10], i17.classList.contains(e4.ctx.toolbar.selectedClass) ? i17.classList.remove(e4.ctx.toolbar.selectedClass) : i17.classList.add(e4.ctx.toolbar.selectedClass);
      });
    } }, { key: "getToolbarIconsReference", value: function() {
      var t8 = this.w;
      this.elZoom || (this.elZoom = t8.globals.dom.baseEl.querySelector(".apexcharts-zoom-icon")), this.elPan || (this.elPan = t8.globals.dom.baseEl.querySelector(".apexcharts-pan-icon")), this.elSelection || (this.elSelection = t8.globals.dom.baseEl.querySelector(".apexcharts-selection-icon"));
    } }, { key: "enableZoomPanFromToolbar", value: function(t8) {
      this.toggleOtherControls(), "pan" === t8 ? this.w.globals.panEnabled = true : this.w.globals.zoomEnabled = true;
      var e4 = "pan" === t8 ? this.elPan : this.elZoom, i17 = "pan" === t8 ? this.elZoom : this.elPan;
      e4 && e4.classList.add(this.selectedClass), i17 && i17.classList.remove(this.selectedClass);
    } }, { key: "togglePanning", value: function() {
      this.ctx.getSyncedCharts().forEach(function(t8) {
        t8.ctx.toolbar.toggleOtherControls(), t8.w.globals.panEnabled = !t8.w.globals.panEnabled, t8.ctx.toolbar.elPan.classList.contains(t8.ctx.toolbar.selectedClass) ? t8.ctx.toolbar.elPan.classList.remove(t8.ctx.toolbar.selectedClass) : t8.ctx.toolbar.elPan.classList.add(t8.ctx.toolbar.selectedClass);
      });
    } }, { key: "toggleOtherControls", value: function() {
      var t8 = this, e4 = this.w;
      e4.globals.panEnabled = false, e4.globals.zoomEnabled = false, e4.globals.selectionEnabled = false, this.getToolbarIconsReference(), [this.elPan, this.elSelection, this.elZoom].forEach(function(e5) {
        e5 && e5.classList.remove(t8.selectedClass);
      });
    } }, { key: "handleZoomIn", value: function() {
      var t8 = this.w;
      t8.globals.isRangeBar && (this.minX = t8.globals.minY, this.maxX = t8.globals.maxY);
      var e4 = (this.minX + this.maxX) / 2, i17 = (this.minX + e4) / 2, a10 = (this.maxX + e4) / 2, s11 = this._getNewMinXMaxX(i17, a10);
      t8.globals.disableZoomIn || this.zoomUpdateOptions(s11.minX, s11.maxX);
    } }, { key: "handleZoomOut", value: function() {
      var t8 = this.w;
      if (t8.globals.isRangeBar && (this.minX = t8.globals.minY, this.maxX = t8.globals.maxY), !("datetime" === t8.config.xaxis.type && new Date(this.minX).getUTCFullYear() < 1e3)) {
        var e4 = (this.minX + this.maxX) / 2, i17 = this.minX - (e4 - this.minX), a10 = this.maxX - (e4 - this.maxX), s11 = this._getNewMinXMaxX(i17, a10);
        t8.globals.disableZoomOut || this.zoomUpdateOptions(s11.minX, s11.maxX);
      }
    } }, { key: "_getNewMinXMaxX", value: function(t8, e4) {
      var i17 = this.w.config.xaxis.convertedCatToNumeric;
      return { minX: i17 ? Math.floor(t8) : t8, maxX: i17 ? Math.floor(e4) : e4 };
    } }, { key: "zoomUpdateOptions", value: function(t8, e4) {
      var i17 = this.w;
      if (void 0 !== t8 || void 0 !== e4) {
        if (!(i17.config.xaxis.convertedCatToNumeric && (t8 < 1 && (t8 = 1, e4 = i17.globals.dataPoints), e4 - t8 < 2))) {
          var a10 = { min: t8, max: e4 }, s11 = this.getBeforeZoomRange(a10);
          s11 && (a10 = s11.xaxis);
          var r13 = { xaxis: a10 }, o10 = x3.clone(i17.globals.initialConfig.yaxis);
          i17.config.chart.group || (r13.yaxis = o10), this.w.globals.zoomed = true, this.ctx.updateHelpers._updateOptions(r13, false, this.w.config.chart.animations.dynamicAnimation.enabled), this.zoomCallback(a10, o10);
        }
      } else
        this.handleZoomReset();
    } }, { key: "zoomCallback", value: function(t8, e4) {
      "function" == typeof this.ev.zoomed && this.ev.zoomed(this.ctx, { xaxis: t8, yaxis: e4 });
    } }, { key: "getBeforeZoomRange", value: function(t8, e4) {
      var i17 = null;
      return "function" == typeof this.ev.beforeZoom && (i17 = this.ev.beforeZoom(this, { xaxis: t8, yaxis: e4 })), i17;
    } }, { key: "toggleMenu", value: function() {
      var t8 = this;
      window.setTimeout(function() {
        t8.elMenu.classList.contains("apexcharts-menu-open") ? t8.elMenu.classList.remove("apexcharts-menu-open") : t8.elMenu.classList.add("apexcharts-menu-open");
      }, 0);
    } }, { key: "handleDownload", value: function(t8) {
      var e4 = this.w, i17 = new G2(this.ctx);
      switch (t8) {
        case "svg":
          i17.exportToSVG(this.ctx);
          break;
        case "png":
          i17.exportToPng(this.ctx);
          break;
        case "csv":
          i17.exportToCSV({ series: e4.config.series, columnDelimiter: e4.config.chart.toolbar.export.csv.columnDelimiter });
      }
    } }, { key: "handleZoomReset", value: function(t8) {
      this.ctx.getSyncedCharts().forEach(function(t9) {
        var e4 = t9.w;
        if (e4.globals.lastXAxis.min = e4.globals.initialConfig.xaxis.min, e4.globals.lastXAxis.max = e4.globals.initialConfig.xaxis.max, t9.updateHelpers.revertDefaultAxisMinMax(), "function" == typeof e4.config.chart.events.beforeResetZoom) {
          var i17 = e4.config.chart.events.beforeResetZoom(t9, e4);
          i17 && t9.updateHelpers.revertDefaultAxisMinMax(i17);
        }
        "function" == typeof e4.config.chart.events.zoomed && t9.ctx.toolbar.zoomCallback({ min: e4.config.xaxis.min, max: e4.config.xaxis.max }), e4.globals.zoomed = false;
        var a10 = t9.ctx.series.emptyCollapsedSeries(x3.clone(e4.globals.initialSeries));
        t9.updateHelpers._updateSeries(a10, e4.config.chart.animations.dynamicAnimation.enabled);
      });
    } }, { key: "destroy", value: function() {
      this.elZoom = null, this.elZoomIn = null, this.elZoomOut = null, this.elPan = null, this.elSelection = null, this.elZoomReset = null, this.elMenuIcon = null;
    } }]), t7;
  }(), ct2 = function(t7) {
    n10(i17, ht);
    var e4 = d8(i17);
    function i17(t8) {
      var s11;
      return a9(this, i17), (s11 = e4.call(this, t8)).ctx = t8, s11.w = t8.w, s11.dragged = false, s11.graphics = new m3(s11.ctx), s11.eventList = ["mousedown", "mouseleave", "mousemove", "touchstart", "touchmove", "mouseup", "touchend"], s11.clientX = 0, s11.clientY = 0, s11.startX = 0, s11.endX = 0, s11.dragX = 0, s11.startY = 0, s11.endY = 0, s11.dragY = 0, s11.moveDirection = "none", s11;
    }
    return r12(i17, [{ key: "init", value: function(t8) {
      var e5 = this, i18 = t8.xyRatios, a10 = this.w, s11 = this;
      this.xyRatios = i18, this.zoomRect = this.graphics.drawRect(0, 0, 0, 0), this.selectionRect = this.graphics.drawRect(0, 0, 0, 0), this.gridRect = a10.globals.dom.baseEl.querySelector(".apexcharts-grid"), this.zoomRect.node.classList.add("apexcharts-zoom-rect"), this.selectionRect.node.classList.add("apexcharts-selection-rect"), a10.globals.dom.elGraphical.add(this.zoomRect), a10.globals.dom.elGraphical.add(this.selectionRect), "x" === a10.config.chart.selection.type ? this.slDraggableRect = this.selectionRect.draggable({ minX: 0, minY: 0, maxX: a10.globals.gridWidth, maxY: a10.globals.gridHeight }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : "y" === a10.config.chart.selection.type ? this.slDraggableRect = this.selectionRect.draggable({ minX: 0, maxX: a10.globals.gridWidth }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : this.slDraggableRect = this.selectionRect.draggable().on("dragmove", this.selectionDragging.bind(this, "dragging")), this.preselectedSelection(), this.hoverArea = a10.globals.dom.baseEl.querySelector("".concat(a10.globals.chartClass, " .apexcharts-svg")), this.hoverArea.classList.add("apexcharts-zoomable"), this.eventList.forEach(function(t9) {
        e5.hoverArea.addEventListener(t9, s11.svgMouseEvents.bind(s11, i18), { capture: false, passive: true });
      });
    } }, { key: "destroy", value: function() {
      this.slDraggableRect && (this.slDraggableRect.draggable(false), this.slDraggableRect.off(), this.selectionRect.off()), this.selectionRect = null, this.zoomRect = null, this.gridRect = null;
    } }, { key: "svgMouseEvents", value: function(t8, e5) {
      var i18 = this.w, a10 = this, s11 = this.ctx.toolbar, r13 = i18.globals.zoomEnabled ? i18.config.chart.zoom.type : i18.config.chart.selection.type, o10 = i18.config.chart.toolbar.autoSelected;
      if (e5.shiftKey ? (this.shiftWasPressed = true, s11.enableZoomPanFromToolbar("pan" === o10 ? "zoom" : "pan")) : this.shiftWasPressed && (s11.enableZoomPanFromToolbar(o10), this.shiftWasPressed = false), e5.target) {
        var n11, l8 = e5.target.classList;
        if (e5.target.parentNode && null !== e5.target.parentNode && (n11 = e5.target.parentNode.classList), !(l8.contains("apexcharts-selection-rect") || l8.contains("apexcharts-legend-marker") || l8.contains("apexcharts-legend-text") || n11 && n11.contains("apexcharts-toolbar"))) {
          if (a10.clientX = "touchmove" === e5.type || "touchstart" === e5.type ? e5.touches[0].clientX : "touchend" === e5.type ? e5.changedTouches[0].clientX : e5.clientX, a10.clientY = "touchmove" === e5.type || "touchstart" === e5.type ? e5.touches[0].clientY : "touchend" === e5.type ? e5.changedTouches[0].clientY : e5.clientY, "mousedown" === e5.type && 1 === e5.which) {
            var h4 = a10.gridRect.getBoundingClientRect();
            a10.startX = a10.clientX - h4.left, a10.startY = a10.clientY - h4.top, a10.dragged = false, a10.w.globals.mousedown = true;
          }
          if (("mousemove" === e5.type && 1 === e5.which || "touchmove" === e5.type) && (a10.dragged = true, i18.globals.panEnabled ? (i18.globals.selection = null, a10.w.globals.mousedown && a10.panDragging({ context: a10, zoomtype: r13, xyRatios: t8 })) : (a10.w.globals.mousedown && i18.globals.zoomEnabled || a10.w.globals.mousedown && i18.globals.selectionEnabled) && (a10.selection = a10.selectionDrawing({ context: a10, zoomtype: r13 }))), "mouseup" === e5.type || "touchend" === e5.type || "mouseleave" === e5.type) {
            var c7, d9 = null === (c7 = a10.gridRect) || void 0 === c7 ? void 0 : c7.getBoundingClientRect();
            d9 && a10.w.globals.mousedown && (a10.endX = a10.clientX - d9.left, a10.endY = a10.clientY - d9.top, a10.dragX = Math.abs(a10.endX - a10.startX), a10.dragY = Math.abs(a10.endY - a10.startY), (i18.globals.zoomEnabled || i18.globals.selectionEnabled) && a10.selectionDrawn({ context: a10, zoomtype: r13 }), i18.globals.panEnabled && i18.config.xaxis.convertedCatToNumeric && a10.delayedPanScrolled()), i18.globals.zoomEnabled && a10.hideSelectionRect(this.selectionRect), a10.dragged = false, a10.w.globals.mousedown = false;
          }
          this.makeSelectionRectDraggable();
        }
      }
    } }, { key: "makeSelectionRectDraggable", value: function() {
      var t8 = this.w;
      if (this.selectionRect) {
        var e5 = this.selectionRect.node.getBoundingClientRect();
        e5.width > 0 && e5.height > 0 && this.slDraggableRect.selectize({ points: "l, r", pointSize: 8, pointType: "rect" }).resize({ constraint: { minX: 0, minY: 0, maxX: t8.globals.gridWidth, maxY: t8.globals.gridHeight } }).on("resizing", this.selectionDragging.bind(this, "resizing"));
      }
    } }, { key: "preselectedSelection", value: function() {
      var t8 = this.w, e5 = this.xyRatios;
      if (!t8.globals.zoomEnabled) {
        if (void 0 !== t8.globals.selection && null !== t8.globals.selection)
          this.drawSelectionRect(t8.globals.selection);
        else if (void 0 !== t8.config.chart.selection.xaxis.min && void 0 !== t8.config.chart.selection.xaxis.max) {
          var i18 = (t8.config.chart.selection.xaxis.min - t8.globals.minX) / e5.xRatio, a10 = t8.globals.gridWidth - (t8.globals.maxX - t8.config.chart.selection.xaxis.max) / e5.xRatio - i18;
          t8.globals.isRangeBar && (i18 = (t8.config.chart.selection.xaxis.min - t8.globals.yAxisScale[0].niceMin) / e5.invertedYRatio, a10 = (t8.config.chart.selection.xaxis.max - t8.config.chart.selection.xaxis.min) / e5.invertedYRatio);
          var s11 = { x: i18, y: 0, width: a10, height: t8.globals.gridHeight, translateX: 0, translateY: 0, selectionEnabled: true };
          this.drawSelectionRect(s11), this.makeSelectionRectDraggable(), "function" == typeof t8.config.chart.events.selection && t8.config.chart.events.selection(this.ctx, { xaxis: { min: t8.config.chart.selection.xaxis.min, max: t8.config.chart.selection.xaxis.max }, yaxis: {} });
        }
      }
    } }, { key: "drawSelectionRect", value: function(t8) {
      var e5 = t8.x, i18 = t8.y, a10 = t8.width, s11 = t8.height, r13 = t8.translateX, o10 = void 0 === r13 ? 0 : r13, n11 = t8.translateY, l8 = void 0 === n11 ? 0 : n11, h4 = this.w, c7 = this.zoomRect, d9 = this.selectionRect;
      if (this.dragged || null !== h4.globals.selection) {
        var g7 = { transform: "translate(" + o10 + ", " + l8 + ")" };
        h4.globals.zoomEnabled && this.dragged && (a10 < 0 && (a10 = 1), c7.attr({ x: e5, y: i18, width: a10, height: s11, fill: h4.config.chart.zoom.zoomedArea.fill.color, "fill-opacity": h4.config.chart.zoom.zoomedArea.fill.opacity, stroke: h4.config.chart.zoom.zoomedArea.stroke.color, "stroke-width": h4.config.chart.zoom.zoomedArea.stroke.width, "stroke-opacity": h4.config.chart.zoom.zoomedArea.stroke.opacity }), m3.setAttrs(c7.node, g7)), h4.globals.selectionEnabled && (d9.attr({ x: e5, y: i18, width: a10 > 0 ? a10 : 0, height: s11 > 0 ? s11 : 0, fill: h4.config.chart.selection.fill.color, "fill-opacity": h4.config.chart.selection.fill.opacity, stroke: h4.config.chart.selection.stroke.color, "stroke-width": h4.config.chart.selection.stroke.width, "stroke-dasharray": h4.config.chart.selection.stroke.dashArray, "stroke-opacity": h4.config.chart.selection.stroke.opacity }), m3.setAttrs(d9.node, g7));
      }
    } }, { key: "hideSelectionRect", value: function(t8) {
      t8 && t8.attr({ x: 0, y: 0, width: 0, height: 0 });
    } }, { key: "selectionDrawing", value: function(t8) {
      var e5 = t8.context, i18 = t8.zoomtype, a10 = this.w, s11 = e5, r13 = this.gridRect.getBoundingClientRect(), o10 = s11.startX - 1, n11 = s11.startY, l8 = false, h4 = false, c7 = s11.clientX - r13.left - o10, d9 = s11.clientY - r13.top - n11, g7 = {};
      return Math.abs(c7 + o10) > a10.globals.gridWidth ? c7 = a10.globals.gridWidth - o10 : s11.clientX - r13.left < 0 && (c7 = o10), o10 > s11.clientX - r13.left && (l8 = true, c7 = Math.abs(c7)), n11 > s11.clientY - r13.top && (h4 = true, d9 = Math.abs(d9)), g7 = "x" === i18 ? { x: l8 ? o10 - c7 : o10, y: 0, width: c7, height: a10.globals.gridHeight } : "y" === i18 ? { x: 0, y: h4 ? n11 - d9 : n11, width: a10.globals.gridWidth, height: d9 } : { x: l8 ? o10 - c7 : o10, y: h4 ? n11 - d9 : n11, width: c7, height: d9 }, s11.drawSelectionRect(g7), s11.selectionDragging("resizing"), g7;
    } }, { key: "selectionDragging", value: function(t8, e5) {
      var i18 = this, a10 = this.w, s11 = this.xyRatios, r13 = this.selectionRect, o10 = 0;
      "resizing" === t8 && (o10 = 30);
      var n11 = function(t9) {
        return parseFloat(r13.node.getAttribute(t9));
      }, l8 = { x: n11("x"), y: n11("y"), width: n11("width"), height: n11("height") };
      a10.globals.selection = l8, "function" == typeof a10.config.chart.events.selection && a10.globals.selectionEnabled && (clearTimeout(this.w.globals.selectionResizeTimer), this.w.globals.selectionResizeTimer = window.setTimeout(function() {
        var t9, e6, o11, n12, l9 = i18.gridRect.getBoundingClientRect(), h4 = r13.node.getBoundingClientRect();
        a10.globals.isRangeBar ? (t9 = a10.globals.yAxisScale[0].niceMin + (h4.left - l9.left) * s11.invertedYRatio, e6 = a10.globals.yAxisScale[0].niceMin + (h4.right - l9.left) * s11.invertedYRatio, o11 = 0, n12 = 1) : (t9 = a10.globals.xAxisScale.niceMin + (h4.left - l9.left) * s11.xRatio, e6 = a10.globals.xAxisScale.niceMin + (h4.right - l9.left) * s11.xRatio, o11 = a10.globals.yAxisScale[0].niceMin + (l9.bottom - h4.bottom) * s11.yRatio[0], n12 = a10.globals.yAxisScale[0].niceMax - (h4.top - l9.top) * s11.yRatio[0]);
        var c7 = { xaxis: { min: t9, max: e6 }, yaxis: { min: o11, max: n12 } };
        a10.config.chart.events.selection(i18.ctx, c7), a10.config.chart.brush.enabled && void 0 !== a10.config.chart.events.brushScrolled && a10.config.chart.events.brushScrolled(i18.ctx, c7);
      }, o10));
    } }, { key: "selectionDrawn", value: function(t8) {
      var e5 = t8.context, i18 = t8.zoomtype, a10 = this.w, s11 = e5, r13 = this.xyRatios, o10 = this.ctx.toolbar;
      if (s11.startX > s11.endX) {
        var n11 = s11.startX;
        s11.startX = s11.endX, s11.endX = n11;
      }
      if (s11.startY > s11.endY) {
        var l8 = s11.startY;
        s11.startY = s11.endY, s11.endY = l8;
      }
      var h4 = void 0, c7 = void 0;
      a10.globals.isRangeBar ? (h4 = a10.globals.yAxisScale[0].niceMin + s11.startX * r13.invertedYRatio, c7 = a10.globals.yAxisScale[0].niceMin + s11.endX * r13.invertedYRatio) : (h4 = a10.globals.xAxisScale.niceMin + s11.startX * r13.xRatio, c7 = a10.globals.xAxisScale.niceMin + s11.endX * r13.xRatio);
      var d9 = [], g7 = [];
      if (a10.config.yaxis.forEach(function(t9, e6) {
        var i19 = a10.globals.seriesYAxisMap[e6][0];
        d9.push(a10.globals.yAxisScale[e6].niceMax - r13.yRatio[i19] * s11.startY), g7.push(a10.globals.yAxisScale[e6].niceMax - r13.yRatio[i19] * s11.endY);
      }), s11.dragged && (s11.dragX > 10 || s11.dragY > 10) && h4 !== c7) {
        if (a10.globals.zoomEnabled) {
          var u6 = x3.clone(a10.globals.initialConfig.yaxis), p7 = x3.clone(a10.globals.initialConfig.xaxis);
          if (a10.globals.zoomed = true, a10.config.xaxis.convertedCatToNumeric && (h4 = Math.floor(h4), c7 = Math.floor(c7), h4 < 1 && (h4 = 1, c7 = a10.globals.dataPoints), c7 - h4 < 2 && (c7 = h4 + 1)), "xy" !== i18 && "x" !== i18 || (p7 = { min: h4, max: c7 }), "xy" !== i18 && "y" !== i18 || u6.forEach(function(t9, e6) {
            u6[e6].min = g7[e6], u6[e6].max = d9[e6];
          }), o10) {
            var f5 = o10.getBeforeZoomRange(p7, u6);
            f5 && (p7 = f5.xaxis ? f5.xaxis : p7, u6 = f5.yaxis ? f5.yaxis : u6);
          }
          var b3 = { xaxis: p7 };
          a10.config.chart.group || (b3.yaxis = u6), s11.ctx.updateHelpers._updateOptions(b3, false, s11.w.config.chart.animations.dynamicAnimation.enabled), "function" == typeof a10.config.chart.events.zoomed && o10.zoomCallback(p7, u6);
        } else if (a10.globals.selectionEnabled) {
          var v5, m4 = null;
          v5 = { min: h4, max: c7 }, "xy" !== i18 && "y" !== i18 || (m4 = x3.clone(a10.config.yaxis)).forEach(function(t9, e6) {
            m4[e6].min = g7[e6], m4[e6].max = d9[e6];
          }), a10.globals.selection = s11.selection, "function" == typeof a10.config.chart.events.selection && a10.config.chart.events.selection(s11.ctx, { xaxis: v5, yaxis: m4 });
        }
      }
    } }, { key: "panDragging", value: function(t8) {
      var e5 = t8.context, i18 = this.w, a10 = e5;
      if (void 0 !== i18.globals.lastClientPosition.x) {
        var s11 = i18.globals.lastClientPosition.x - a10.clientX, r13 = i18.globals.lastClientPosition.y - a10.clientY;
        Math.abs(s11) > Math.abs(r13) && s11 > 0 ? this.moveDirection = "left" : Math.abs(s11) > Math.abs(r13) && s11 < 0 ? this.moveDirection = "right" : Math.abs(r13) > Math.abs(s11) && r13 > 0 ? this.moveDirection = "up" : Math.abs(r13) > Math.abs(s11) && r13 < 0 && (this.moveDirection = "down");
      }
      i18.globals.lastClientPosition = { x: a10.clientX, y: a10.clientY };
      var o10 = i18.globals.isRangeBar ? i18.globals.minY : i18.globals.minX, n11 = i18.globals.isRangeBar ? i18.globals.maxY : i18.globals.maxX;
      i18.config.xaxis.convertedCatToNumeric || a10.panScrolled(o10, n11);
    } }, { key: "delayedPanScrolled", value: function() {
      var t8 = this.w, e5 = t8.globals.minX, i18 = t8.globals.maxX, a10 = (t8.globals.maxX - t8.globals.minX) / 2;
      "left" === this.moveDirection ? (e5 = t8.globals.minX + a10, i18 = t8.globals.maxX + a10) : "right" === this.moveDirection && (e5 = t8.globals.minX - a10, i18 = t8.globals.maxX - a10), e5 = Math.floor(e5), i18 = Math.floor(i18), this.updateScrolledChart({ xaxis: { min: e5, max: i18 } }, e5, i18);
    } }, { key: "panScrolled", value: function(t8, e5) {
      var i18 = this.w, a10 = this.xyRatios, s11 = x3.clone(i18.globals.initialConfig.yaxis), r13 = a10.xRatio, o10 = i18.globals.minX, n11 = i18.globals.maxX;
      i18.globals.isRangeBar && (r13 = a10.invertedYRatio, o10 = i18.globals.minY, n11 = i18.globals.maxY), "left" === this.moveDirection ? (t8 = o10 + i18.globals.gridWidth / 15 * r13, e5 = n11 + i18.globals.gridWidth / 15 * r13) : "right" === this.moveDirection && (t8 = o10 - i18.globals.gridWidth / 15 * r13, e5 = n11 - i18.globals.gridWidth / 15 * r13), i18.globals.isRangeBar || (t8 < i18.globals.initialMinX || e5 > i18.globals.initialMaxX) && (t8 = o10, e5 = n11);
      var l8 = { xaxis: { min: t8, max: e5 } };
      i18.config.chart.group || (l8.yaxis = s11), this.updateScrolledChart(l8, t8, e5);
    } }, { key: "updateScrolledChart", value: function(t8, e5, i18) {
      var a10 = this.w;
      this.ctx.updateHelpers._updateOptions(t8, false, false), "function" == typeof a10.config.chart.events.scrolled && a10.config.chart.events.scrolled(this.ctx, { xaxis: { min: e5, max: i18 } });
    } }]), i17;
  }(), dt2 = function() {
    function t7(e4) {
      a9(this, t7), this.w = e4.w, this.ttCtx = e4, this.ctx = e4.ctx;
    }
    return r12(t7, [{ key: "getNearestValues", value: function(t8) {
      var e4 = t8.hoverArea, i17 = t8.elGrid, a10 = t8.clientX, s11 = t8.clientY, r13 = this.w, o10 = i17.getBoundingClientRect(), n11 = o10.width, l8 = o10.height, h4 = n11 / (r13.globals.dataPoints - 1), c7 = l8 / r13.globals.dataPoints, d9 = this.hasBars();
      !r13.globals.comboCharts && !d9 || r13.config.xaxis.convertedCatToNumeric || (h4 = n11 / r13.globals.dataPoints);
      var g7 = a10 - o10.left - r13.globals.barPadForNumericAxis, u6 = s11 - o10.top;
      g7 < 0 || u6 < 0 || g7 > n11 || u6 > l8 ? (e4.classList.remove("hovering-zoom"), e4.classList.remove("hovering-pan")) : r13.globals.zoomEnabled ? (e4.classList.remove("hovering-pan"), e4.classList.add("hovering-zoom")) : r13.globals.panEnabled && (e4.classList.remove("hovering-zoom"), e4.classList.add("hovering-pan"));
      var p7 = Math.round(g7 / h4), f5 = Math.floor(u6 / c7);
      d9 && !r13.config.xaxis.convertedCatToNumeric && (p7 = Math.ceil(g7 / h4), p7 -= 1);
      var b3 = null, v5 = null, m4 = r13.globals.seriesXvalues.map(function(t9) {
        return t9.filter(function(t10) {
          return x3.isNumber(t10);
        });
      }), y5 = r13.globals.seriesYvalues.map(function(t9) {
        return t9.filter(function(t10) {
          return x3.isNumber(t10);
        });
      });
      if (r13.globals.isXNumeric) {
        var w4 = this.ttCtx.getElGrid().getBoundingClientRect(), k4 = g7 * (w4.width / n11), A3 = u6 * (w4.height / l8);
        b3 = (v5 = this.closestInMultiArray(k4, A3, m4, y5)).index, p7 = v5.j, null !== b3 && (m4 = r13.globals.seriesXvalues[b3], p7 = (v5 = this.closestInArray(k4, m4)).index);
      }
      return r13.globals.capturedSeriesIndex = null === b3 ? -1 : b3, (!p7 || p7 < 1) && (p7 = 0), r13.globals.isBarHorizontal ? r13.globals.capturedDataPointIndex = f5 : r13.globals.capturedDataPointIndex = p7, { capturedSeries: b3, j: r13.globals.isBarHorizontal ? f5 : p7, hoverX: g7, hoverY: u6 };
    } }, { key: "closestInMultiArray", value: function(t8, e4, i17, a10) {
      var s11 = this.w, r13 = 0, o10 = null, n11 = -1;
      s11.globals.series.length > 1 ? r13 = this.getFirstActiveXArray(i17) : o10 = 0;
      var l8 = i17[r13][0], h4 = Math.abs(t8 - l8);
      if (i17.forEach(function(e5) {
        e5.forEach(function(e6, i18) {
          var a11 = Math.abs(t8 - e6);
          a11 <= h4 && (h4 = a11, n11 = i18);
        });
      }), -1 !== n11) {
        var c7 = a10[r13][n11], d9 = Math.abs(e4 - c7);
        o10 = r13, a10.forEach(function(t9, i18) {
          var a11 = Math.abs(e4 - t9[n11]);
          a11 <= d9 && (d9 = a11, o10 = i18);
        });
      }
      return { index: o10, j: n11 };
    } }, { key: "getFirstActiveXArray", value: function(t8) {
      for (var e4 = this.w, i17 = 0, a10 = t8.map(function(t9, e5) {
        return t9.length > 0 ? e5 : -1;
      }), s11 = 0; s11 < a10.length; s11++)
        if (-1 !== a10[s11] && -1 === e4.globals.collapsedSeriesIndices.indexOf(s11) && -1 === e4.globals.ancillaryCollapsedSeriesIndices.indexOf(s11)) {
          i17 = a10[s11];
          break;
        }
      return i17;
    } }, { key: "closestInArray", value: function(t8, e4) {
      for (var i17 = e4[0], a10 = null, s11 = Math.abs(t8 - i17), r13 = 0; r13 < e4.length; r13++) {
        var o10 = Math.abs(t8 - e4[r13]);
        o10 < s11 && (s11 = o10, a10 = r13);
      }
      return { index: a10 };
    } }, { key: "isXoverlap", value: function(t8) {
      var e4 = [], i17 = this.w.globals.seriesX.filter(function(t9) {
        return void 0 !== t9[0];
      });
      if (i17.length > 0)
        for (var a10 = 0; a10 < i17.length - 1; a10++)
          void 0 !== i17[a10][t8] && void 0 !== i17[a10 + 1][t8] && i17[a10][t8] !== i17[a10 + 1][t8] && e4.push("unEqual");
      return 0 === e4.length;
    } }, { key: "isInitialSeriesSameLen", value: function() {
      for (var t8 = true, e4 = this.w.globals.initialSeries, i17 = 0; i17 < e4.length - 1; i17++)
        if (e4[i17].data.length !== e4[i17 + 1].data.length) {
          t8 = false;
          break;
        }
      return t8;
    } }, { key: "getBarsHeight", value: function(t8) {
      return u5(t8).reduce(function(t9, e4) {
        return t9 + e4.getBBox().height;
      }, 0);
    } }, { key: "getElMarkers", value: function(t8) {
      return "number" == typeof t8 ? this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:realIndex='".concat(t8, "'] .apexcharts-series-markers-wrap > *")) : this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap > *");
    } }, { key: "getAllMarkers", value: function() {
      var t8 = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap");
      (t8 = u5(t8)).sort(function(t9, e5) {
        var i17 = Number(t9.getAttribute("data:realIndex")), a10 = Number(e5.getAttribute("data:realIndex"));
        return a10 < i17 ? 1 : a10 > i17 ? -1 : 0;
      });
      var e4 = [];
      return t8.forEach(function(t9) {
        e4.push(t9.querySelector(".apexcharts-marker"));
      }), e4;
    } }, { key: "hasMarkers", value: function(t8) {
      return this.getElMarkers(t8).length > 0;
    } }, { key: "getPathFromPoint", value: function(t8, e4) {
      var i17 = Number(t8.getAttribute("cx")), a10 = Number(t8.getAttribute("cy")), s11 = t8.getAttribute("shape");
      return new m3(this.ctx).getMarkerPath(i17, a10, s11, e4);
    } }, { key: "getElBars", value: function() {
      return this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-bar-series,  .apexcharts-candlestick-series, .apexcharts-boxPlot-series, .apexcharts-rangebar-series");
    } }, { key: "hasBars", value: function() {
      return this.getElBars().length > 0;
    } }, { key: "getHoverMarkerSize", value: function(t8) {
      var e4 = this.w, i17 = e4.config.markers.hover.size;
      return void 0 === i17 && (i17 = e4.globals.markers.size[t8] + e4.config.markers.hover.sizeOffset), i17;
    } }, { key: "toggleAllTooltipSeriesGroups", value: function(t8) {
      var e4 = this.w, i17 = this.ttCtx;
      0 === i17.allTooltipSeriesGroups.length && (i17.allTooltipSeriesGroups = e4.globals.dom.baseEl.querySelectorAll(".apexcharts-tooltip-series-group"));
      for (var a10 = i17.allTooltipSeriesGroups, s11 = 0; s11 < a10.length; s11++)
        "enable" === t8 ? (a10[s11].classList.add("apexcharts-active"), a10[s11].style.display = e4.config.tooltip.items.display) : (a10[s11].classList.remove("apexcharts-active"), a10[s11].style.display = "none");
    } }]), t7;
  }(), gt = function() {
    function t7(e4) {
      a9(this, t7), this.w = e4.w, this.ctx = e4.ctx, this.ttCtx = e4, this.tooltipUtil = new dt2(e4);
    }
    return r12(t7, [{ key: "drawSeriesTexts", value: function(t8) {
      var e4 = t8.shared, i17 = void 0 === e4 || e4, a10 = t8.ttItems, s11 = t8.i, r13 = void 0 === s11 ? 0 : s11, o10 = t8.j, n11 = void 0 === o10 ? null : o10, l8 = t8.y1, h4 = t8.y2, c7 = t8.e, d9 = this.w;
      void 0 !== d9.config.tooltip.custom ? this.handleCustomTooltip({ i: r13, j: n11, y1: l8, y2: h4, w: d9 }) : this.toggleActiveInactiveSeries(i17, r13);
      var g7 = this.getValuesToPrint({ i: r13, j: n11 });
      this.printLabels({ i: r13, j: n11, values: g7, ttItems: a10, shared: i17, e: c7 });
      var u6 = this.ttCtx.getElTooltip();
      this.ttCtx.tooltipRect.ttWidth = u6.getBoundingClientRect().width, this.ttCtx.tooltipRect.ttHeight = u6.getBoundingClientRect().height;
    } }, { key: "printLabels", value: function(t8) {
      var i17, a10 = this, s11 = t8.i, r13 = t8.j, o10 = t8.values, n11 = t8.ttItems, l8 = t8.shared, h4 = t8.e, c7 = this.w, d9 = [], g7 = function(t9) {
        return c7.globals.seriesGoals[t9] && c7.globals.seriesGoals[t9][r13] && Array.isArray(c7.globals.seriesGoals[t9][r13]);
      }, u6 = o10.xVal, p7 = o10.zVal, f5 = o10.xAxisTTVal, x4 = "", b3 = c7.globals.colors[s11];
      null !== r13 && c7.config.plotOptions.bar.distributed && (b3 = c7.globals.colors[r13]);
      for (var v5 = function(t9, o11) {
        var v6 = a10.getFormatters(s11);
        x4 = a10.getSeriesName({ fn: v6.yLbTitleFormatter, index: s11, seriesIndex: s11, j: r13 }), "treemap" === c7.config.chart.type && (x4 = v6.yLbTitleFormatter(String(c7.config.series[s11].data[r13].x), { series: c7.globals.series, seriesIndex: s11, dataPointIndex: r13, w: c7 }));
        var m5 = c7.config.tooltip.inverseOrder ? o11 : t9;
        if (c7.globals.axisCharts) {
          var y6 = function(t10) {
            var e4, i18, a11, s12;
            return c7.globals.isRangeData ? v6.yLbFormatter(null === (e4 = c7.globals.seriesRangeStart) || void 0 === e4 || null === (i18 = e4[t10]) || void 0 === i18 ? void 0 : i18[r13], { series: c7.globals.seriesRangeStart, seriesIndex: t10, dataPointIndex: r13, w: c7 }) + " - " + v6.yLbFormatter(null === (a11 = c7.globals.seriesRangeEnd) || void 0 === a11 || null === (s12 = a11[t10]) || void 0 === s12 ? void 0 : s12[r13], { series: c7.globals.seriesRangeEnd, seriesIndex: t10, dataPointIndex: r13, w: c7 }) : v6.yLbFormatter(c7.globals.series[t10][r13], { series: c7.globals.series, seriesIndex: t10, dataPointIndex: r13, w: c7 });
          };
          if (l8)
            v6 = a10.getFormatters(m5), x4 = a10.getSeriesName({ fn: v6.yLbTitleFormatter, index: m5, seriesIndex: s11, j: r13 }), b3 = c7.globals.colors[m5], i17 = y6(m5), g7(m5) && (d9 = c7.globals.seriesGoals[m5][r13].map(function(t10) {
              return { attrs: t10, val: v6.yLbFormatter(t10.value, { seriesIndex: m5, dataPointIndex: r13, w: c7 }) };
            }));
          else {
            var w4, k4 = null == h4 || null === (w4 = h4.target) || void 0 === w4 ? void 0 : w4.getAttribute("fill");
            k4 && (b3 = -1 !== k4.indexOf("url") ? document.querySelector(k4.substr(4).slice(0, -1)).childNodes[0].getAttribute("stroke") : k4), i17 = y6(s11), g7(s11) && Array.isArray(c7.globals.seriesGoals[s11][r13]) && (d9 = c7.globals.seriesGoals[s11][r13].map(function(t10) {
              return { attrs: t10, val: v6.yLbFormatter(t10.value, { seriesIndex: s11, dataPointIndex: r13, w: c7 }) };
            }));
          }
        }
        null === r13 && (i17 = v6.yLbFormatter(c7.globals.series[s11], e3(e3({}, c7), {}, { seriesIndex: s11, dataPointIndex: s11 }))), a10.DOMHandling({ i: s11, t: m5, j: r13, ttItems: n11, values: { val: i17, goalVals: d9, xVal: u6, xAxisTTVal: f5, zVal: p7 }, seriesName: x4, shared: l8, pColor: b3 });
      }, m4 = 0, y5 = c7.globals.series.length - 1; m4 < c7.globals.series.length; m4++, y5--)
        v5(m4, y5);
    } }, { key: "getFormatters", value: function(t8) {
      var e4, i17 = this.w, a10 = i17.globals.yLabelFormatters[t8];
      return void 0 !== i17.globals.ttVal ? Array.isArray(i17.globals.ttVal) ? (a10 = i17.globals.ttVal[t8] && i17.globals.ttVal[t8].formatter, e4 = i17.globals.ttVal[t8] && i17.globals.ttVal[t8].title && i17.globals.ttVal[t8].title.formatter) : (a10 = i17.globals.ttVal.formatter, "function" == typeof i17.globals.ttVal.title.formatter && (e4 = i17.globals.ttVal.title.formatter)) : e4 = i17.config.tooltip.y.title.formatter, "function" != typeof a10 && (a10 = i17.globals.yLabelFormatters[0] ? i17.globals.yLabelFormatters[0] : function(t9) {
        return t9;
      }), "function" != typeof e4 && (e4 = function(t9) {
        return t9;
      }), { yLbFormatter: a10, yLbTitleFormatter: e4 };
    } }, { key: "getSeriesName", value: function(t8) {
      var e4 = t8.fn, i17 = t8.index, a10 = t8.seriesIndex, s11 = t8.j, r13 = this.w;
      return e4(String(r13.globals.seriesNames[i17]), { series: r13.globals.series, seriesIndex: a10, dataPointIndex: s11, w: r13 });
    } }, { key: "DOMHandling", value: function(t8) {
      t8.i;
      var e4 = t8.t, i17 = t8.j, a10 = t8.ttItems, s11 = t8.values, r13 = t8.seriesName, o10 = t8.shared, n11 = t8.pColor, l8 = this.w, h4 = this.ttCtx, c7 = s11.val, d9 = s11.goalVals, g7 = s11.xVal, u6 = s11.xAxisTTVal, p7 = s11.zVal, f5 = null;
      f5 = a10[e4].children, l8.config.tooltip.fillSeriesColor && (a10[e4].style.backgroundColor = n11, f5[0].style.display = "none"), h4.showTooltipTitle && (null === h4.tooltipTitle && (h4.tooltipTitle = l8.globals.dom.baseEl.querySelector(".apexcharts-tooltip-title")), h4.tooltipTitle.innerHTML = g7), h4.isXAxisTooltipEnabled && (h4.xaxisTooltipText.innerHTML = "" !== u6 ? u6 : g7);
      var x4 = a10[e4].querySelector(".apexcharts-tooltip-text-y-label");
      x4 && (x4.innerHTML = r13 || "");
      var b3 = a10[e4].querySelector(".apexcharts-tooltip-text-y-value");
      b3 && (b3.innerHTML = void 0 !== c7 ? c7 : ""), f5[0] && f5[0].classList.contains("apexcharts-tooltip-marker") && (l8.config.tooltip.marker.fillColors && Array.isArray(l8.config.tooltip.marker.fillColors) && (n11 = l8.config.tooltip.marker.fillColors[e4]), f5[0].style.backgroundColor = n11), l8.config.tooltip.marker.show || (f5[0].style.display = "none");
      var v5 = a10[e4].querySelector(".apexcharts-tooltip-text-goals-label"), m4 = a10[e4].querySelector(".apexcharts-tooltip-text-goals-value");
      if (d9.length && l8.globals.seriesGoals[e4]) {
        var y5 = function() {
          var t9 = "<div >", e5 = "<div>";
          d9.forEach(function(i18, a11) {
            t9 += ' <div style="display: flex"><span class="apexcharts-tooltip-marker" style="background-color: '.concat(i18.attrs.strokeColor, '; height: 3px; border-radius: 0; top: 5px;"></span> ').concat(i18.attrs.name, "</div>"), e5 += "<div>".concat(i18.val, "</div>");
          }), v5.innerHTML = t9 + "</div>", m4.innerHTML = e5 + "</div>";
        };
        o10 ? l8.globals.seriesGoals[e4][i17] && Array.isArray(l8.globals.seriesGoals[e4][i17]) ? y5() : (v5.innerHTML = "", m4.innerHTML = "") : y5();
      } else
        v5.innerHTML = "", m4.innerHTML = "";
      null !== p7 && (a10[e4].querySelector(".apexcharts-tooltip-text-z-label").innerHTML = l8.config.tooltip.z.title, a10[e4].querySelector(".apexcharts-tooltip-text-z-value").innerHTML = void 0 !== p7 ? p7 : "");
      if (o10 && f5[0]) {
        if (l8.config.tooltip.hideEmptySeries) {
          var w4 = a10[e4].querySelector(".apexcharts-tooltip-marker"), k4 = a10[e4].querySelector(".apexcharts-tooltip-text");
          0 == parseFloat(c7) ? (w4.style.display = "none", k4.style.display = "none") : (w4.style.display = "block", k4.style.display = "block");
        }
        null == c7 || l8.globals.ancillaryCollapsedSeriesIndices.indexOf(e4) > -1 || l8.globals.collapsedSeriesIndices.indexOf(e4) > -1 || Array.isArray(h4.tConfig.enabledOnSeries) && -1 === h4.tConfig.enabledOnSeries.indexOf(e4) ? f5[0].parentNode.style.display = "none" : f5[0].parentNode.style.display = l8.config.tooltip.items.display;
      } else
        Array.isArray(h4.tConfig.enabledOnSeries) && -1 === h4.tConfig.enabledOnSeries.indexOf(e4) && (f5[0].parentNode.style.display = "none");
    } }, { key: "toggleActiveInactiveSeries", value: function(t8, e4) {
      var i17 = this.w;
      if (t8)
        this.tooltipUtil.toggleAllTooltipSeriesGroups("enable");
      else {
        this.tooltipUtil.toggleAllTooltipSeriesGroups("disable");
        var a10 = i17.globals.dom.baseEl.querySelector(".apexcharts-tooltip-series-group-".concat(e4));
        a10 && (a10.classList.add("apexcharts-active"), a10.style.display = i17.config.tooltip.items.display);
      }
    } }, { key: "getValuesToPrint", value: function(t8) {
      var e4 = t8.i, i17 = t8.j, a10 = this.w, s11 = this.ctx.series.filteredSeriesX(), r13 = "", o10 = "", n11 = null, l8 = null, h4 = { series: a10.globals.series, seriesIndex: e4, dataPointIndex: i17, w: a10 }, c7 = a10.globals.ttZFormatter;
      null === i17 ? l8 = a10.globals.series[e4] : a10.globals.isXNumeric && "treemap" !== a10.config.chart.type ? (r13 = s11[e4][i17], 0 === s11[e4].length && (r13 = s11[this.tooltipUtil.getFirstActiveXArray(s11)][i17])) : r13 = void 0 !== a10.globals.labels[i17] ? a10.globals.labels[i17] : "";
      var d9 = r13;
      a10.globals.isXNumeric && "datetime" === a10.config.xaxis.type ? r13 = new S2(this.ctx).xLabelFormat(a10.globals.ttKeyFormatter, d9, d9, { i: void 0, dateFormatter: new A2(this.ctx).formatDate, w: this.w }) : r13 = a10.globals.isBarHorizontal ? a10.globals.yLabelFormatters[0](d9, h4) : a10.globals.xLabelFormatter(d9, h4);
      return void 0 !== a10.config.tooltip.x.formatter && (r13 = a10.globals.ttKeyFormatter(d9, h4)), a10.globals.seriesZ.length > 0 && a10.globals.seriesZ[e4].length > 0 && (n11 = c7(a10.globals.seriesZ[e4][i17], a10)), o10 = "function" == typeof a10.config.xaxis.tooltip.formatter ? a10.globals.xaxisTooltipFormatter(d9, h4) : r13, { val: Array.isArray(l8) ? l8.join(" ") : l8, xVal: Array.isArray(r13) ? r13.join(" ") : r13, xAxisTTVal: Array.isArray(o10) ? o10.join(" ") : o10, zVal: n11 };
    } }, { key: "handleCustomTooltip", value: function(t8) {
      var e4 = t8.i, i17 = t8.j, a10 = t8.y1, s11 = t8.y2, r13 = t8.w, o10 = this.ttCtx.getElTooltip(), n11 = r13.config.tooltip.custom;
      Array.isArray(n11) && n11[e4] && (n11 = n11[e4]), o10.innerHTML = n11({ ctx: this.ctx, series: r13.globals.series, seriesIndex: e4, dataPointIndex: i17, y1: a10, y2: s11, w: r13 });
    } }]), t7;
  }(), ut = function() {
    function t7(e4) {
      a9(this, t7), this.ttCtx = e4, this.ctx = e4.ctx, this.w = e4.w;
    }
    return r12(t7, [{ key: "moveXCrosshairs", value: function(t8) {
      var e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, i17 = this.ttCtx, a10 = this.w, s11 = i17.getElXCrosshairs(), r13 = t8 - i17.xcrosshairsWidth / 2, o10 = a10.globals.labels.slice().length;
      if (null !== e4 && (r13 = a10.globals.gridWidth / o10 * e4), null === s11 || a10.globals.isBarHorizontal || (s11.setAttribute("x", r13), s11.setAttribute("x1", r13), s11.setAttribute("x2", r13), s11.setAttribute("y2", a10.globals.gridHeight), s11.classList.add("apexcharts-active")), r13 < 0 && (r13 = 0), r13 > a10.globals.gridWidth && (r13 = a10.globals.gridWidth), i17.isXAxisTooltipEnabled) {
        var n11 = r13;
        "tickWidth" !== a10.config.xaxis.crosshairs.width && "barWidth" !== a10.config.xaxis.crosshairs.width || (n11 = r13 + i17.xcrosshairsWidth / 2), this.moveXAxisTooltip(n11);
      }
    } }, { key: "moveYCrosshairs", value: function(t8) {
      var e4 = this.ttCtx;
      null !== e4.ycrosshairs && m3.setAttrs(e4.ycrosshairs, { y1: t8, y2: t8 }), null !== e4.ycrosshairsHidden && m3.setAttrs(e4.ycrosshairsHidden, { y1: t8, y2: t8 });
    } }, { key: "moveXAxisTooltip", value: function(t8) {
      var e4 = this.w, i17 = this.ttCtx;
      if (null !== i17.xaxisTooltip && 0 !== i17.xcrosshairsWidth) {
        i17.xaxisTooltip.classList.add("apexcharts-active");
        var a10 = i17.xaxisOffY + e4.config.xaxis.tooltip.offsetY + e4.globals.translateY + 1 + e4.config.xaxis.offsetY;
        if (t8 -= i17.xaxisTooltip.getBoundingClientRect().width / 2, !isNaN(t8)) {
          t8 += e4.globals.translateX;
          var s11;
          s11 = new m3(this.ctx).getTextRects(i17.xaxisTooltipText.innerHTML), i17.xaxisTooltipText.style.minWidth = s11.width + "px", i17.xaxisTooltip.style.left = t8 + "px", i17.xaxisTooltip.style.top = a10 + "px";
        }
      }
    } }, { key: "moveYAxisTooltip", value: function(t8) {
      var e4 = this.w, i17 = this.ttCtx;
      null === i17.yaxisTTEls && (i17.yaxisTTEls = e4.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
      var a10 = parseInt(i17.ycrosshairsHidden.getAttribute("y1"), 10), s11 = e4.globals.translateY + a10, r13 = i17.yaxisTTEls[t8].getBoundingClientRect().height, o10 = e4.globals.translateYAxisX[t8] - 2;
      e4.config.yaxis[t8].opposite && (o10 -= 26), s11 -= r13 / 2, -1 === e4.globals.ignoreYAxisIndexes.indexOf(t8) ? (i17.yaxisTTEls[t8].classList.add("apexcharts-active"), i17.yaxisTTEls[t8].style.top = s11 + "px", i17.yaxisTTEls[t8].style.left = o10 + e4.config.yaxis[t8].tooltip.offsetX + "px") : i17.yaxisTTEls[t8].classList.remove("apexcharts-active");
    } }, { key: "moveTooltip", value: function(t8, e4) {
      var i17 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, a10 = this.w, s11 = this.ttCtx, r13 = s11.getElTooltip(), o10 = s11.tooltipRect, n11 = null !== i17 ? parseFloat(i17) : 1, l8 = parseFloat(t8) + n11 + 5, h4 = parseFloat(e4) + n11 / 2;
      if (l8 > a10.globals.gridWidth / 2 && (l8 = l8 - o10.ttWidth - n11 - 10), l8 > a10.globals.gridWidth - o10.ttWidth - 10 && (l8 = a10.globals.gridWidth - o10.ttWidth), l8 < -20 && (l8 = -20), a10.config.tooltip.followCursor) {
        var c7 = s11.getElGrid().getBoundingClientRect();
        (l8 = s11.e.clientX - c7.left) > a10.globals.gridWidth / 2 && (l8 -= s11.tooltipRect.ttWidth), (h4 = s11.e.clientY + a10.globals.translateY - c7.top) > a10.globals.gridHeight / 2 && (h4 -= s11.tooltipRect.ttHeight);
      } else
        a10.globals.isBarHorizontal || o10.ttHeight / 2 + h4 > a10.globals.gridHeight && (h4 = a10.globals.gridHeight - o10.ttHeight + a10.globals.translateY);
      isNaN(l8) || (l8 += a10.globals.translateX, r13.style.left = l8 + "px", r13.style.top = h4 + "px");
    } }, { key: "moveMarkers", value: function(t8, e4) {
      var i17 = this.w, a10 = this.ttCtx;
      if (i17.globals.markers.size[t8] > 0)
        for (var s11 = i17.globals.dom.baseEl.querySelectorAll(" .apexcharts-series[data\\:realIndex='".concat(t8, "'] .apexcharts-marker")), r13 = 0; r13 < s11.length; r13++)
          parseInt(s11[r13].getAttribute("rel"), 10) === e4 && (a10.marker.resetPointsSize(), a10.marker.enlargeCurrentPoint(e4, s11[r13]));
      else
        a10.marker.resetPointsSize(), this.moveDynamicPointOnHover(e4, t8);
    } }, { key: "moveDynamicPointOnHover", value: function(t8, e4) {
      var i17, a10, s11, r13, o10 = this.w, n11 = this.ttCtx, l8 = new m3(this.ctx), h4 = o10.globals.pointsArray, c7 = n11.tooltipUtil.getHoverMarkerSize(e4), d9 = o10.config.series[e4].type;
      if (!d9 || "column" !== d9 && "candlestick" !== d9 && "boxPlot" !== d9) {
        s11 = null === (i17 = h4[e4][t8]) || void 0 === i17 ? void 0 : i17[0], r13 = (null === (a10 = h4[e4][t8]) || void 0 === a10 ? void 0 : a10[1]) || 0;
        var g7 = o10.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(e4, "'] .apexcharts-series-markers path"));
        if (g7 && r13 < o10.globals.gridHeight && r13 > 0) {
          var u6 = g7.getAttribute("shape"), p7 = l8.getMarkerPath(s11, r13, u6, 1.5 * c7);
          g7.setAttribute("d", p7);
        }
        this.moveXCrosshairs(s11), n11.fixedTooltip || this.moveTooltip(s11, r13, c7);
      }
    } }, { key: "moveDynamicPointsOnHover", value: function(t8) {
      var e4, i17 = this.ttCtx, a10 = i17.w, s11 = 0, r13 = 0, o10 = a10.globals.pointsArray, n11 = new W3(this.ctx), l8 = new m3(this.ctx);
      e4 = n11.getActiveConfigSeriesIndex("asc", ["line", "area", "scatter", "bubble"]);
      var h4 = i17.tooltipUtil.getHoverMarkerSize(e4);
      o10[e4] && (s11 = o10[e4][t8][0], r13 = o10[e4][t8][1]);
      var c7 = i17.tooltipUtil.getAllMarkers();
      if (null !== c7)
        for (var d9 = 0; d9 < a10.globals.series.length; d9++) {
          var g7 = o10[d9];
          if (a10.globals.comboCharts && void 0 === g7 && c7.splice(d9, 0, null), g7 && g7.length) {
            var u6 = o10[d9][t8][1], p7 = void 0;
            c7[d9].setAttribute("cx", s11);
            var f5 = c7[d9].getAttribute("shape");
            if ("rangeArea" === a10.config.chart.type && !a10.globals.comboCharts) {
              var x4 = t8 + a10.globals.series[d9].length;
              p7 = o10[d9][x4][1], u6 -= Math.abs(u6 - p7) / 2;
            }
            if (null !== u6 && !isNaN(u6) && u6 < a10.globals.gridHeight + h4 && u6 + h4 > 0) {
              var b3 = l8.getMarkerPath(s11, u6, f5, h4);
              c7[d9].setAttribute("d", b3);
            } else
              c7[d9].setAttribute("d", "");
          }
        }
      this.moveXCrosshairs(s11), i17.fixedTooltip || this.moveTooltip(s11, r13 || a10.globals.gridHeight, h4);
    } }, { key: "moveStickyTooltipOverBars", value: function(t8, e4) {
      var i17 = this.w, a10 = this.ttCtx, s11 = i17.globals.columnSeries ? i17.globals.columnSeries.length : i17.globals.series.length, r13 = s11 >= 2 && s11 % 2 == 0 ? Math.floor(s11 / 2) : Math.floor(s11 / 2) + 1;
      i17.globals.isBarHorizontal && (r13 = new W3(this.ctx).getActiveConfigSeriesIndex("desc") + 1);
      var o10 = i17.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[rel='".concat(r13, "'] path[j='").concat(t8, "'], .apexcharts-candlestick-series .apexcharts-series[rel='").concat(r13, "'] path[j='").concat(t8, "'], .apexcharts-boxPlot-series .apexcharts-series[rel='").concat(r13, "'] path[j='").concat(t8, "'], .apexcharts-rangebar-series .apexcharts-series[rel='").concat(r13, "'] path[j='").concat(t8, "']"));
      o10 || "number" != typeof e4 || (o10 = i17.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[data\\:realIndex='".concat(e4, "'] path[j='").concat(t8, "'],\n        .apexcharts-candlestick-series .apexcharts-series[data\\:realIndex='").concat(e4, "'] path[j='").concat(t8, "'],\n        .apexcharts-boxPlot-series .apexcharts-series[data\\:realIndex='").concat(e4, "'] path[j='").concat(t8, "'],\n        .apexcharts-rangebar-series .apexcharts-series[data\\:realIndex='").concat(e4, "'] path[j='").concat(t8, "']")));
      var n11 = o10 ? parseFloat(o10.getAttribute("cx")) : 0, l8 = o10 ? parseFloat(o10.getAttribute("cy")) : 0, h4 = o10 ? parseFloat(o10.getAttribute("barWidth")) : 0, c7 = a10.getElGrid().getBoundingClientRect(), d9 = o10 && (o10.classList.contains("apexcharts-candlestick-area") || o10.classList.contains("apexcharts-boxPlot-area"));
      i17.globals.isXNumeric ? (o10 && !d9 && (n11 -= s11 % 2 != 0 ? h4 / 2 : 0), o10 && d9 && i17.globals.comboCharts && (n11 -= h4 / 2)) : i17.globals.isBarHorizontal || (n11 = a10.xAxisTicksPositions[t8 - 1] + a10.dataPointsDividedWidth / 2, isNaN(n11) && (n11 = a10.xAxisTicksPositions[t8] - a10.dataPointsDividedWidth / 2)), i17.globals.isBarHorizontal ? l8 -= a10.tooltipRect.ttHeight : i17.config.tooltip.followCursor ? l8 = a10.e.clientY - c7.top - a10.tooltipRect.ttHeight / 2 : l8 + a10.tooltipRect.ttHeight + 15 > i17.globals.gridHeight && (l8 = i17.globals.gridHeight), i17.globals.isBarHorizontal || this.moveXCrosshairs(n11), a10.fixedTooltip || this.moveTooltip(n11, l8 || i17.globals.gridHeight);
    } }]), t7;
  }(), pt = function() {
    function t7(e4) {
      a9(this, t7), this.w = e4.w, this.ttCtx = e4, this.ctx = e4.ctx, this.tooltipPosition = new ut(e4);
    }
    return r12(t7, [{ key: "drawDynamicPoints", value: function() {
      var t8 = this.w, e4 = new m3(this.ctx), i17 = new D2(this.ctx), a10 = t8.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
      a10 = u5(a10), t8.config.chart.stacked && a10.sort(function(t9, e5) {
        return parseFloat(t9.getAttribute("data:realIndex")) - parseFloat(e5.getAttribute("data:realIndex"));
      });
      for (var s11 = 0; s11 < a10.length; s11++) {
        var r13 = a10[s11].querySelector(".apexcharts-series-markers-wrap");
        if (null !== r13) {
          var o10 = void 0, n11 = "apexcharts-marker w".concat((Math.random() + 1).toString(36).substring(4));
          "line" !== t8.config.chart.type && "area" !== t8.config.chart.type || t8.globals.comboCharts || t8.config.tooltip.intersect || (n11 += " no-pointer-events");
          var l8 = i17.getMarkerConfig({ cssClass: n11, seriesIndex: Number(r13.getAttribute("data:realIndex")) });
          (o10 = e4.drawMarker(0, 0, l8)).node.setAttribute("default-marker-size", 0);
          var h4 = document.createElementNS(t8.globals.SVGNS, "g");
          h4.classList.add("apexcharts-series-markers"), h4.appendChild(o10.node), r13.appendChild(h4);
        }
      }
    } }, { key: "enlargeCurrentPoint", value: function(t8, e4) {
      var i17 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, a10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null, s11 = this.w;
      "bubble" !== s11.config.chart.type && this.newPointSize(t8, e4);
      var r13 = e4.getAttribute("cx"), o10 = e4.getAttribute("cy");
      if (null !== i17 && null !== a10 && (r13 = i17, o10 = a10), this.tooltipPosition.moveXCrosshairs(r13), !this.fixedTooltip) {
        if ("radar" === s11.config.chart.type) {
          var n11 = this.ttCtx.getElGrid().getBoundingClientRect();
          r13 = this.ttCtx.e.clientX - n11.left;
        }
        this.tooltipPosition.moveTooltip(r13, o10, s11.config.markers.hover.size);
      }
    } }, { key: "enlargePoints", value: function(t8) {
      for (var e4 = this.w, i17 = this, a10 = this.ttCtx, s11 = t8, r13 = e4.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), o10 = e4.config.markers.hover.size, n11 = 0; n11 < r13.length; n11++) {
        var l8 = r13[n11].getAttribute("rel"), h4 = r13[n11].getAttribute("index");
        if (void 0 === o10 && (o10 = e4.globals.markers.size[h4] + e4.config.markers.hover.sizeOffset), s11 === parseInt(l8, 10)) {
          i17.newPointSize(s11, r13[n11]);
          var c7 = r13[n11].getAttribute("cx"), d9 = r13[n11].getAttribute("cy");
          i17.tooltipPosition.moveXCrosshairs(c7), a10.fixedTooltip || i17.tooltipPosition.moveTooltip(c7, d9, o10);
        } else
          i17.oldPointSize(r13[n11]);
      }
    } }, { key: "newPointSize", value: function(t8, e4) {
      var i17 = this.w, a10 = i17.config.markers.hover.size, s11 = 0 === t8 ? e4.parentNode.firstChild : e4.parentNode.lastChild;
      if ("0" !== s11.getAttribute("default-marker-size")) {
        var r13 = parseInt(s11.getAttribute("index"), 10);
        void 0 === a10 && (a10 = i17.globals.markers.size[r13] + i17.config.markers.hover.sizeOffset), a10 < 0 && (a10 = 0);
        var o10 = this.ttCtx.tooltipUtil.getPathFromPoint(e4, a10);
        e4.setAttribute("d", o10);
      }
    } }, { key: "oldPointSize", value: function(t8) {
      var e4 = parseFloat(t8.getAttribute("default-marker-size")), i17 = this.ttCtx.tooltipUtil.getPathFromPoint(t8, e4);
      t8.setAttribute("d", i17);
    } }, { key: "resetPointsSize", value: function() {
      for (var t8 = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), e4 = 0; e4 < t8.length; e4++) {
        var i17 = parseFloat(t8[e4].getAttribute("default-marker-size"));
        if (x3.isNumber(i17) && i17 >= 0) {
          var a10 = this.ttCtx.tooltipUtil.getPathFromPoint(t8[e4], i17);
          t8[e4].setAttribute("d", a10);
        } else
          t8[e4].setAttribute("d", "M0,0");
      }
    } }]), t7;
  }(), ft = function() {
    function t7(e4) {
      a9(this, t7), this.w = e4.w;
      var i17 = this.w;
      this.ttCtx = e4, this.isVerticalGroupedRangeBar = !i17.globals.isBarHorizontal && "rangeBar" === i17.config.chart.type && i17.config.plotOptions.bar.rangeBarGroupRows;
    }
    return r12(t7, [{ key: "getAttr", value: function(t8, e4) {
      return parseFloat(t8.target.getAttribute(e4));
    } }, { key: "handleHeatTreeTooltip", value: function(t8) {
      var e4 = t8.e, i17 = t8.opt, a10 = t8.x, s11 = t8.y, r13 = t8.type, o10 = this.ttCtx, n11 = this.w;
      if (e4.target.classList.contains("apexcharts-".concat(r13, "-rect"))) {
        var l8 = this.getAttr(e4, "i"), h4 = this.getAttr(e4, "j"), c7 = this.getAttr(e4, "cx"), d9 = this.getAttr(e4, "cy"), g7 = this.getAttr(e4, "width"), u6 = this.getAttr(e4, "height");
        if (o10.tooltipLabels.drawSeriesTexts({ ttItems: i17.ttItems, i: l8, j: h4, shared: false, e: e4 }), n11.globals.capturedSeriesIndex = l8, n11.globals.capturedDataPointIndex = h4, a10 = c7 + o10.tooltipRect.ttWidth / 2 + g7, s11 = d9 + o10.tooltipRect.ttHeight / 2 - u6 / 2, o10.tooltipPosition.moveXCrosshairs(c7 + g7 / 2), a10 > n11.globals.gridWidth / 2 && (a10 = c7 - o10.tooltipRect.ttWidth / 2 + g7), o10.w.config.tooltip.followCursor) {
          var p7 = n11.globals.dom.elWrap.getBoundingClientRect();
          a10 = n11.globals.clientX - p7.left - (a10 > n11.globals.gridWidth / 2 ? o10.tooltipRect.ttWidth : 0), s11 = n11.globals.clientY - p7.top - (s11 > n11.globals.gridHeight / 2 ? o10.tooltipRect.ttHeight : 0);
        }
      }
      return { x: a10, y: s11 };
    } }, { key: "handleMarkerTooltip", value: function(t8) {
      var e4, i17, a10 = t8.e, s11 = t8.opt, r13 = t8.x, o10 = t8.y, n11 = this.w, l8 = this.ttCtx;
      if (a10.target.classList.contains("apexcharts-marker")) {
        var h4 = parseInt(s11.paths.getAttribute("cx"), 10), c7 = parseInt(s11.paths.getAttribute("cy"), 10), d9 = parseFloat(s11.paths.getAttribute("val"));
        if (i17 = parseInt(s11.paths.getAttribute("rel"), 10), e4 = parseInt(s11.paths.parentNode.parentNode.parentNode.getAttribute("rel"), 10) - 1, l8.intersect) {
          var g7 = x3.findAncestor(s11.paths, "apexcharts-series");
          g7 && (e4 = parseInt(g7.getAttribute("data:realIndex"), 10));
        }
        if (l8.tooltipLabels.drawSeriesTexts({ ttItems: s11.ttItems, i: e4, j: i17, shared: !l8.showOnIntersect && n11.config.tooltip.shared, e: a10 }), "mouseup" === a10.type && l8.markerClick(a10, e4, i17), n11.globals.capturedSeriesIndex = e4, n11.globals.capturedDataPointIndex = i17, r13 = h4, o10 = c7 + n11.globals.translateY - 1.4 * l8.tooltipRect.ttHeight, l8.w.config.tooltip.followCursor) {
          var u6 = l8.getElGrid().getBoundingClientRect();
          o10 = l8.e.clientY + n11.globals.translateY - u6.top;
        }
        d9 < 0 && (o10 = c7), l8.marker.enlargeCurrentPoint(i17, s11.paths, r13, o10);
      }
      return { x: r13, y: o10 };
    } }, { key: "handleBarTooltip", value: function(t8) {
      var e4, i17, a10 = t8.e, s11 = t8.opt, r13 = this.w, o10 = this.ttCtx, n11 = o10.getElTooltip(), l8 = 0, h4 = 0, c7 = 0, d9 = this.getBarTooltipXY({ e: a10, opt: s11 });
      e4 = d9.i, d9.barHeight;
      var g7 = d9.j;
      r13.globals.capturedSeriesIndex = e4, r13.globals.capturedDataPointIndex = g7, r13.globals.isBarHorizontal && o10.tooltipUtil.hasBars() || !r13.config.tooltip.shared ? (h4 = d9.x, c7 = d9.y, i17 = Array.isArray(r13.config.stroke.width) ? r13.config.stroke.width[e4] : r13.config.stroke.width, l8 = h4) : r13.globals.comboCharts || r13.config.tooltip.shared || (l8 /= 2), isNaN(c7) && (c7 = r13.globals.svgHeight - o10.tooltipRect.ttHeight);
      var u6 = parseInt(s11.paths.parentNode.getAttribute("data:realIndex"), 10);
      if (r13.globals.isMultipleYAxis ? r13.config.yaxis[u6] && r13.config.yaxis[u6].reversed : r13.config.yaxis[0].reversed, h4 + o10.tooltipRect.ttWidth > r13.globals.gridWidth ? h4 -= o10.tooltipRect.ttWidth : h4 < 0 && (h4 = 0), o10.w.config.tooltip.followCursor) {
        var p7 = o10.getElGrid().getBoundingClientRect();
        c7 = o10.e.clientY - p7.top;
      }
      null === o10.tooltip && (o10.tooltip = r13.globals.dom.baseEl.querySelector(".apexcharts-tooltip")), r13.config.tooltip.shared || (r13.globals.comboBarCount > 0 ? o10.tooltipPosition.moveXCrosshairs(l8 + i17 / 2) : o10.tooltipPosition.moveXCrosshairs(l8)), !o10.fixedTooltip && (!r13.config.tooltip.shared || r13.globals.isBarHorizontal && o10.tooltipUtil.hasBars()) && (c7 = c7 + r13.globals.translateY - o10.tooltipRect.ttHeight / 2, n11.style.left = h4 + r13.globals.translateX + "px", n11.style.top = c7 + "px");
    } }, { key: "getBarTooltipXY", value: function(t8) {
      var e4 = this, i17 = t8.e, a10 = t8.opt, s11 = this.w, r13 = null, o10 = this.ttCtx, n11 = 0, l8 = 0, h4 = 0, c7 = 0, d9 = 0, g7 = i17.target.classList;
      if (g7.contains("apexcharts-bar-area") || g7.contains("apexcharts-candlestick-area") || g7.contains("apexcharts-boxPlot-area") || g7.contains("apexcharts-rangebar-area")) {
        var u6 = i17.target, p7 = u6.getBoundingClientRect(), f5 = a10.elGrid.getBoundingClientRect(), x4 = p7.height;
        d9 = p7.height;
        var b3 = p7.width, v5 = parseInt(u6.getAttribute("cx"), 10), m4 = parseInt(u6.getAttribute("cy"), 10);
        c7 = parseFloat(u6.getAttribute("barWidth"));
        var y5 = "touchmove" === i17.type ? i17.touches[0].clientX : i17.clientX;
        r13 = parseInt(u6.getAttribute("j"), 10), n11 = parseInt(u6.parentNode.getAttribute("rel"), 10) - 1;
        var w4 = u6.getAttribute("data-range-y1"), k4 = u6.getAttribute("data-range-y2");
        s11.globals.comboCharts && (n11 = parseInt(u6.parentNode.getAttribute("data:realIndex"), 10));
        var A3 = function(t9) {
          return s11.globals.isXNumeric ? v5 - b3 / 2 : e4.isVerticalGroupedRangeBar ? v5 + b3 / 2 : v5 - o10.dataPointsDividedWidth + b3 / 2;
        }, S3 = function() {
          return m4 - o10.dataPointsDividedHeight + x4 / 2 - o10.tooltipRect.ttHeight / 2;
        };
        o10.tooltipLabels.drawSeriesTexts({ ttItems: a10.ttItems, i: n11, j: r13, y1: w4 ? parseInt(w4, 10) : null, y2: k4 ? parseInt(k4, 10) : null, shared: !o10.showOnIntersect && s11.config.tooltip.shared, e: i17 }), s11.config.tooltip.followCursor ? s11.globals.isBarHorizontal ? (l8 = y5 - f5.left + 15, h4 = S3()) : (l8 = A3(), h4 = i17.clientY - f5.top - o10.tooltipRect.ttHeight / 2 - 15) : s11.globals.isBarHorizontal ? ((l8 = v5) < o10.xyRatios.baseLineInvertedY && (l8 = v5 - o10.tooltipRect.ttWidth), h4 = S3()) : (l8 = A3(), h4 = m4);
      }
      return { x: l8, y: h4, barHeight: d9, barWidth: c7, i: n11, j: r13 };
    } }]), t7;
  }(), xt = function() {
    function t7(e4) {
      a9(this, t7), this.w = e4.w, this.ttCtx = e4;
    }
    return r12(t7, [{ key: "drawXaxisTooltip", value: function() {
      var t8 = this.w, e4 = this.ttCtx, i17 = "bottom" === t8.config.xaxis.position;
      e4.xaxisOffY = i17 ? t8.globals.gridHeight + 1 : -t8.globals.xAxisHeight - t8.config.xaxis.axisTicks.height + 3;
      var a10 = i17 ? "apexcharts-xaxistooltip apexcharts-xaxistooltip-bottom" : "apexcharts-xaxistooltip apexcharts-xaxistooltip-top", s11 = t8.globals.dom.elWrap;
      e4.isXAxisTooltipEnabled && (null === t8.globals.dom.baseEl.querySelector(".apexcharts-xaxistooltip") && (e4.xaxisTooltip = document.createElement("div"), e4.xaxisTooltip.setAttribute("class", a10 + " apexcharts-theme-" + t8.config.tooltip.theme), s11.appendChild(e4.xaxisTooltip), e4.xaxisTooltipText = document.createElement("div"), e4.xaxisTooltipText.classList.add("apexcharts-xaxistooltip-text"), e4.xaxisTooltipText.style.fontFamily = t8.config.xaxis.tooltip.style.fontFamily || t8.config.chart.fontFamily, e4.xaxisTooltipText.style.fontSize = t8.config.xaxis.tooltip.style.fontSize, e4.xaxisTooltip.appendChild(e4.xaxisTooltipText)));
    } }, { key: "drawYaxisTooltip", value: function() {
      for (var t8 = this.w, e4 = this.ttCtx, i17 = 0; i17 < t8.config.yaxis.length; i17++) {
        var a10 = t8.config.yaxis[i17].opposite || t8.config.yaxis[i17].crosshairs.opposite;
        e4.yaxisOffX = a10 ? t8.globals.gridWidth + 1 : 1;
        var s11 = "apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i17, a10 ? " apexcharts-yaxistooltip-right" : " apexcharts-yaxistooltip-left"), r13 = t8.globals.dom.elWrap;
        null === t8.globals.dom.baseEl.querySelector(".apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i17)) && (e4.yaxisTooltip = document.createElement("div"), e4.yaxisTooltip.setAttribute("class", s11 + " apexcharts-theme-" + t8.config.tooltip.theme), r13.appendChild(e4.yaxisTooltip), 0 === i17 && (e4.yaxisTooltipText = []), e4.yaxisTooltipText[i17] = document.createElement("div"), e4.yaxisTooltipText[i17].classList.add("apexcharts-yaxistooltip-text"), e4.yaxisTooltip.appendChild(e4.yaxisTooltipText[i17]));
      }
    } }, { key: "setXCrosshairWidth", value: function() {
      var t8 = this.w, e4 = this.ttCtx, i17 = e4.getElXCrosshairs();
      if (e4.xcrosshairsWidth = parseInt(t8.config.xaxis.crosshairs.width, 10), t8.globals.comboCharts) {
        var a10 = t8.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
        if (null !== a10 && "barWidth" === t8.config.xaxis.crosshairs.width) {
          var s11 = parseFloat(a10.getAttribute("barWidth"));
          e4.xcrosshairsWidth = s11;
        } else if ("tickWidth" === t8.config.xaxis.crosshairs.width) {
          var r13 = t8.globals.labels.length;
          e4.xcrosshairsWidth = t8.globals.gridWidth / r13;
        }
      } else if ("tickWidth" === t8.config.xaxis.crosshairs.width) {
        var o10 = t8.globals.labels.length;
        e4.xcrosshairsWidth = t8.globals.gridWidth / o10;
      } else if ("barWidth" === t8.config.xaxis.crosshairs.width) {
        var n11 = t8.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
        if (null !== n11) {
          var l8 = parseFloat(n11.getAttribute("barWidth"));
          e4.xcrosshairsWidth = l8;
        } else
          e4.xcrosshairsWidth = 1;
      }
      t8.globals.isBarHorizontal && (e4.xcrosshairsWidth = 0), null !== i17 && e4.xcrosshairsWidth > 0 && i17.setAttribute("width", e4.xcrosshairsWidth);
    } }, { key: "handleYCrosshair", value: function() {
      var t8 = this.w, e4 = this.ttCtx;
      e4.ycrosshairs = t8.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs"), e4.ycrosshairsHidden = t8.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs-hidden");
    } }, { key: "drawYaxisTooltipText", value: function(t8, e4, i17) {
      var a10 = this.ttCtx, s11 = this.w, r13 = s11.globals, o10 = r13.seriesYAxisMap[t8];
      if (a10.yaxisTooltips[t8] && o10.length > 0) {
        var n11 = r13.yLabelFormatters[t8], l8 = a10.getElGrid().getBoundingClientRect(), h4 = o10[0], c7 = 0;
        i17.yRatio.length > 1 && (c7 = h4);
        var d9 = (e4 - l8.top) * i17.yRatio[c7], g7 = r13.maxYArr[h4] - r13.minYArr[h4], u6 = r13.minYArr[h4] + (g7 - d9);
        s11.config.yaxis[t8].reversed && (u6 = r13.maxYArr[h4] - (g7 - d9)), a10.tooltipPosition.moveYCrosshairs(e4 - l8.top), a10.yaxisTooltipText[t8].innerHTML = n11(u6), a10.tooltipPosition.moveYAxisTooltip(t8);
      }
    } }]), t7;
  }(), bt = function() {
    function t7(e4) {
      a9(this, t7), this.ctx = e4, this.w = e4.w;
      var i17 = this.w;
      this.tConfig = i17.config.tooltip, this.tooltipUtil = new dt2(this), this.tooltipLabels = new gt(this), this.tooltipPosition = new ut(this), this.marker = new pt(this), this.intersect = new ft(this), this.axesTooltip = new xt(this), this.showOnIntersect = this.tConfig.intersect, this.showTooltipTitle = this.tConfig.x.show, this.fixedTooltip = this.tConfig.fixed.enabled, this.xaxisTooltip = null, this.yaxisTTEls = null, this.isBarShared = !i17.globals.isBarHorizontal && this.tConfig.shared, this.lastHoverTime = Date.now();
    }
    return r12(t7, [{ key: "getElTooltip", value: function(t8) {
      return t8 || (t8 = this), t8.w.globals.dom.baseEl ? t8.w.globals.dom.baseEl.querySelector(".apexcharts-tooltip") : null;
    } }, { key: "getElXCrosshairs", value: function() {
      return this.w.globals.dom.baseEl.querySelector(".apexcharts-xcrosshairs");
    } }, { key: "getElGrid", value: function() {
      return this.w.globals.dom.baseEl.querySelector(".apexcharts-grid");
    } }, { key: "drawTooltip", value: function(t8) {
      var e4 = this.w;
      this.xyRatios = t8, this.isXAxisTooltipEnabled = e4.config.xaxis.tooltip.enabled && e4.globals.axisCharts, this.yaxisTooltips = e4.config.yaxis.map(function(t9, i18) {
        return !!(t9.show && t9.tooltip.enabled && e4.globals.axisCharts);
      }), this.allTooltipSeriesGroups = [], e4.globals.axisCharts || (this.showTooltipTitle = false);
      var i17 = document.createElement("div");
      if (i17.classList.add("apexcharts-tooltip"), e4.config.tooltip.cssClass && i17.classList.add(e4.config.tooltip.cssClass), i17.classList.add("apexcharts-theme-".concat(this.tConfig.theme)), e4.globals.dom.elWrap.appendChild(i17), e4.globals.axisCharts) {
        this.axesTooltip.drawXaxisTooltip(), this.axesTooltip.drawYaxisTooltip(), this.axesTooltip.setXCrosshairWidth(), this.axesTooltip.handleYCrosshair();
        var a10 = new V3(this.ctx);
        this.xAxisTicksPositions = a10.getXAxisTicksPositions();
      }
      if (!e4.globals.comboCharts && !this.tConfig.intersect && "rangeBar" !== e4.config.chart.type || this.tConfig.shared || (this.showOnIntersect = true), 0 !== e4.config.markers.size && 0 !== e4.globals.markers.largestSize || this.marker.drawDynamicPoints(this), e4.globals.collapsedSeries.length !== e4.globals.series.length) {
        this.dataPointsDividedHeight = e4.globals.gridHeight / e4.globals.dataPoints, this.dataPointsDividedWidth = e4.globals.gridWidth / e4.globals.dataPoints, this.showTooltipTitle && (this.tooltipTitle = document.createElement("div"), this.tooltipTitle.classList.add("apexcharts-tooltip-title"), this.tooltipTitle.style.fontFamily = this.tConfig.style.fontFamily || e4.config.chart.fontFamily, this.tooltipTitle.style.fontSize = this.tConfig.style.fontSize, i17.appendChild(this.tooltipTitle));
        var s11 = e4.globals.series.length;
        (e4.globals.xyCharts || e4.globals.comboCharts) && this.tConfig.shared && (s11 = this.showOnIntersect ? 1 : e4.globals.series.length), this.legendLabels = e4.globals.dom.baseEl.querySelectorAll(".apexcharts-legend-text"), this.ttItems = this.createTTElements(s11), this.addSVGEvents();
      }
    } }, { key: "createTTElements", value: function(t8) {
      for (var e4 = this, i17 = this.w, a10 = [], s11 = this.getElTooltip(), r13 = function(r14) {
        var o11 = document.createElement("div");
        o11.classList.add("apexcharts-tooltip-series-group", "apexcharts-tooltip-series-group-".concat(r14)), o11.style.order = i17.config.tooltip.inverseOrder ? t8 - r14 : r14 + 1;
        var n11 = document.createElement("span");
        n11.classList.add("apexcharts-tooltip-marker"), n11.style.backgroundColor = i17.globals.colors[r14], o11.appendChild(n11);
        var l8 = document.createElement("div");
        l8.classList.add("apexcharts-tooltip-text"), l8.style.fontFamily = e4.tConfig.style.fontFamily || i17.config.chart.fontFamily, l8.style.fontSize = e4.tConfig.style.fontSize, ["y", "goals", "z"].forEach(function(t9) {
          var e5 = document.createElement("div");
          e5.classList.add("apexcharts-tooltip-".concat(t9, "-group"));
          var i18 = document.createElement("span");
          i18.classList.add("apexcharts-tooltip-text-".concat(t9, "-label")), e5.appendChild(i18);
          var a11 = document.createElement("span");
          a11.classList.add("apexcharts-tooltip-text-".concat(t9, "-value")), e5.appendChild(a11), l8.appendChild(e5);
        }), o11.appendChild(l8), s11.appendChild(o11), a10.push(o11);
      }, o10 = 0; o10 < t8; o10++)
        r13(o10);
      return a10;
    } }, { key: "addSVGEvents", value: function() {
      var t8 = this.w, e4 = t8.config.chart.type, i17 = this.getElTooltip(), a10 = !("bar" !== e4 && "candlestick" !== e4 && "boxPlot" !== e4 && "rangeBar" !== e4), s11 = "area" === e4 || "line" === e4 || "scatter" === e4 || "bubble" === e4 || "radar" === e4, r13 = t8.globals.dom.Paper.node, o10 = this.getElGrid();
      o10 && (this.seriesBound = o10.getBoundingClientRect());
      var n11, l8 = [], h4 = [], c7 = { hoverArea: r13, elGrid: o10, tooltipEl: i17, tooltipY: l8, tooltipX: h4, ttItems: this.ttItems };
      if (t8.globals.axisCharts && (s11 ? n11 = t8.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:longestSeries='true'] .apexcharts-marker") : a10 ? n11 = t8.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-bar-area, .apexcharts-series .apexcharts-candlestick-area, .apexcharts-series .apexcharts-boxPlot-area, .apexcharts-series .apexcharts-rangebar-area") : "heatmap" !== e4 && "treemap" !== e4 || (n11 = t8.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-heatmap, .apexcharts-series .apexcharts-treemap")), n11 && n11.length))
        for (var d9 = 0; d9 < n11.length; d9++)
          l8.push(n11[d9].getAttribute("cy")), h4.push(n11[d9].getAttribute("cx"));
      if (t8.globals.xyCharts && !this.showOnIntersect || t8.globals.comboCharts && !this.showOnIntersect || a10 && this.tooltipUtil.hasBars() && this.tConfig.shared)
        this.addPathsEventListeners([r13], c7);
      else if (a10 && !t8.globals.comboCharts || s11 && this.showOnIntersect)
        this.addDatapointEventsListeners(c7);
      else if (!t8.globals.axisCharts || "heatmap" === e4 || "treemap" === e4) {
        var g7 = t8.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
        this.addPathsEventListeners(g7, c7);
      }
      if (this.showOnIntersect) {
        var u6 = t8.globals.dom.baseEl.querySelectorAll(".apexcharts-line-series .apexcharts-marker, .apexcharts-area-series .apexcharts-marker");
        u6.length > 0 && this.addPathsEventListeners(u6, c7), this.tooltipUtil.hasBars() && !this.tConfig.shared && this.addDatapointEventsListeners(c7);
      }
    } }, { key: "drawFixedTooltipRect", value: function() {
      var t8 = this.w, e4 = this.getElTooltip(), i17 = e4.getBoundingClientRect(), a10 = i17.width + 10, s11 = i17.height + 10, r13 = this.tConfig.fixed.offsetX, o10 = this.tConfig.fixed.offsetY, n11 = this.tConfig.fixed.position.toLowerCase();
      return n11.indexOf("right") > -1 && (r13 = r13 + t8.globals.svgWidth - a10 + 10), n11.indexOf("bottom") > -1 && (o10 = o10 + t8.globals.svgHeight - s11 - 10), e4.style.left = r13 + "px", e4.style.top = o10 + "px", { x: r13, y: o10, ttWidth: a10, ttHeight: s11 };
    } }, { key: "addDatapointEventsListeners", value: function(t8) {
      var e4 = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers .apexcharts-marker, .apexcharts-bar-area, .apexcharts-candlestick-area, .apexcharts-boxPlot-area, .apexcharts-rangebar-area");
      this.addPathsEventListeners(e4, t8);
    } }, { key: "addPathsEventListeners", value: function(t8, e4) {
      for (var i17 = this, a10 = function(a11) {
        var s12 = { paths: t8[a11], tooltipEl: e4.tooltipEl, tooltipY: e4.tooltipY, tooltipX: e4.tooltipX, elGrid: e4.elGrid, hoverArea: e4.hoverArea, ttItems: e4.ttItems };
        ["mousemove", "mouseup", "touchmove", "mouseout", "touchend"].map(function(e5) {
          return t8[a11].addEventListener(e5, i17.onSeriesHover.bind(i17, s12), { capture: false, passive: true });
        });
      }, s11 = 0; s11 < t8.length; s11++)
        a10(s11);
    } }, { key: "onSeriesHover", value: function(t8, e4) {
      var i17 = this, a10 = Date.now() - this.lastHoverTime;
      a10 >= 100 ? this.seriesHover(t8, e4) : (clearTimeout(this.seriesHoverTimeout), this.seriesHoverTimeout = setTimeout(function() {
        i17.seriesHover(t8, e4);
      }, 100 - a10));
    } }, { key: "seriesHover", value: function(t8, e4) {
      var i17 = this;
      this.lastHoverTime = Date.now();
      var a10 = [], s11 = this.w;
      s11.config.chart.group && (a10 = this.ctx.getGroupedCharts()), s11.globals.axisCharts && (s11.globals.minX === -1 / 0 && s11.globals.maxX === 1 / 0 || 0 === s11.globals.dataPoints) || (a10.length ? a10.forEach(function(a11) {
        var s12 = i17.getElTooltip(a11), r13 = { paths: t8.paths, tooltipEl: s12, tooltipY: t8.tooltipY, tooltipX: t8.tooltipX, elGrid: t8.elGrid, hoverArea: t8.hoverArea, ttItems: a11.w.globals.tooltip.ttItems };
        a11.w.globals.minX === i17.w.globals.minX && a11.w.globals.maxX === i17.w.globals.maxX && a11.w.globals.tooltip.seriesHoverByContext({ chartCtx: a11, ttCtx: a11.w.globals.tooltip, opt: r13, e: e4 });
      }) : this.seriesHoverByContext({ chartCtx: this.ctx, ttCtx: this.w.globals.tooltip, opt: t8, e: e4 }));
    } }, { key: "seriesHoverByContext", value: function(t8) {
      var e4 = t8.chartCtx, i17 = t8.ttCtx, a10 = t8.opt, s11 = t8.e, r13 = e4.w, o10 = this.getElTooltip();
      if (o10) {
        if (i17.tooltipRect = { x: 0, y: 0, ttWidth: o10.getBoundingClientRect().width, ttHeight: o10.getBoundingClientRect().height }, i17.e = s11, i17.tooltipUtil.hasBars() && !r13.globals.comboCharts && !i17.isBarShared) {
          if (this.tConfig.onDatasetHover.highlightDataSeries)
            new W3(e4).toggleSeriesOnHover(s11, s11.target.parentNode);
        }
        i17.fixedTooltip && i17.drawFixedTooltipRect(), r13.globals.axisCharts ? i17.axisChartsTooltips({ e: s11, opt: a10, tooltipRect: i17.tooltipRect }) : i17.nonAxisChartsTooltips({ e: s11, opt: a10, tooltipRect: i17.tooltipRect });
      }
    } }, { key: "axisChartsTooltips", value: function(t8) {
      var e4, i17, a10 = t8.e, s11 = t8.opt, r13 = this.w, o10 = s11.elGrid.getBoundingClientRect(), n11 = "touchmove" === a10.type ? a10.touches[0].clientX : a10.clientX, l8 = "touchmove" === a10.type ? a10.touches[0].clientY : a10.clientY;
      if (this.clientY = l8, this.clientX = n11, r13.globals.capturedSeriesIndex = -1, r13.globals.capturedDataPointIndex = -1, l8 < o10.top || l8 > o10.top + o10.height)
        this.handleMouseOut(s11);
      else {
        if (Array.isArray(this.tConfig.enabledOnSeries) && !r13.config.tooltip.shared) {
          var h4 = parseInt(s11.paths.getAttribute("index"), 10);
          if (this.tConfig.enabledOnSeries.indexOf(h4) < 0)
            return void this.handleMouseOut(s11);
        }
        var c7 = this.getElTooltip(), d9 = this.getElXCrosshairs(), g7 = r13.globals.xyCharts || "bar" === r13.config.chart.type && !r13.globals.isBarHorizontal && this.tooltipUtil.hasBars() && this.tConfig.shared || r13.globals.comboCharts && this.tooltipUtil.hasBars();
        if ("mousemove" === a10.type || "touchmove" === a10.type || "mouseup" === a10.type) {
          if (r13.globals.collapsedSeries.length + r13.globals.ancillaryCollapsedSeries.length === r13.globals.series.length)
            return;
          null !== d9 && d9.classList.add("apexcharts-active");
          var u6 = this.yaxisTooltips.filter(function(t9) {
            return true === t9;
          });
          if (null !== this.ycrosshairs && u6.length && this.ycrosshairs.classList.add("apexcharts-active"), g7 && !this.showOnIntersect)
            this.handleStickyTooltip(a10, n11, l8, s11);
          else if ("heatmap" === r13.config.chart.type || "treemap" === r13.config.chart.type) {
            var p7 = this.intersect.handleHeatTreeTooltip({ e: a10, opt: s11, x: e4, y: i17, type: r13.config.chart.type });
            e4 = p7.x, i17 = p7.y, c7.style.left = e4 + "px", c7.style.top = i17 + "px";
          } else
            this.tooltipUtil.hasBars() && this.intersect.handleBarTooltip({ e: a10, opt: s11 }), this.tooltipUtil.hasMarkers() && this.intersect.handleMarkerTooltip({ e: a10, opt: s11, x: e4, y: i17 });
          if (this.yaxisTooltips.length)
            for (var f5 = 0; f5 < r13.config.yaxis.length; f5++)
              this.axesTooltip.drawYaxisTooltipText(f5, l8, this.xyRatios);
          r13.globals.dom.baseEl.classList.add("apexcharts-tooltip-active"), s11.tooltipEl.classList.add("apexcharts-active");
        } else
          "mouseout" !== a10.type && "touchend" !== a10.type || this.handleMouseOut(s11);
      }
    } }, { key: "nonAxisChartsTooltips", value: function(t8) {
      var e4 = t8.e, i17 = t8.opt, a10 = t8.tooltipRect, s11 = this.w, r13 = i17.paths.getAttribute("rel"), o10 = this.getElTooltip(), n11 = s11.globals.dom.elWrap.getBoundingClientRect();
      if ("mousemove" === e4.type || "touchmove" === e4.type) {
        s11.globals.dom.baseEl.classList.add("apexcharts-tooltip-active"), o10.classList.add("apexcharts-active"), this.tooltipLabels.drawSeriesTexts({ ttItems: i17.ttItems, i: parseInt(r13, 10) - 1, shared: false });
        var l8 = s11.globals.clientX - n11.left - a10.ttWidth / 2, h4 = s11.globals.clientY - n11.top - a10.ttHeight - 10;
        if (o10.style.left = l8 + "px", o10.style.top = h4 + "px", s11.config.legend.tooltipHoverFormatter) {
          var c7 = r13 - 1, d9 = (0, s11.config.legend.tooltipHoverFormatter)(this.legendLabels[c7].getAttribute("data:default-text"), { seriesIndex: c7, dataPointIndex: c7, w: s11 });
          this.legendLabels[c7].innerHTML = d9;
        }
      } else
        "mouseout" !== e4.type && "touchend" !== e4.type || (o10.classList.remove("apexcharts-active"), s11.globals.dom.baseEl.classList.remove("apexcharts-tooltip-active"), s11.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(function(t9) {
          var e5 = t9.getAttribute("data:default-text");
          t9.innerHTML = decodeURIComponent(e5);
        }));
    } }, { key: "handleStickyTooltip", value: function(t8, e4, i17, a10) {
      var s11 = this.w, r13 = this.tooltipUtil.getNearestValues({ context: this, hoverArea: a10.hoverArea, elGrid: a10.elGrid, clientX: e4, clientY: i17 }), o10 = r13.j, n11 = r13.capturedSeries;
      s11.globals.collapsedSeriesIndices.includes(n11) && (n11 = null);
      var l8 = a10.elGrid.getBoundingClientRect();
      if (r13.hoverX < 0 || r13.hoverX > l8.width)
        this.handleMouseOut(a10);
      else if (null !== n11)
        this.handleStickyCapturedSeries(t8, n11, a10, o10);
      else if (this.tooltipUtil.isXoverlap(o10) || s11.globals.isBarHorizontal) {
        var h4 = s11.globals.series.findIndex(function(t9, e5) {
          return !s11.globals.collapsedSeriesIndices.includes(e5);
        });
        this.create(t8, this, h4, o10, a10.ttItems);
      }
    } }, { key: "handleStickyCapturedSeries", value: function(t8, e4, i17, a10) {
      var s11 = this.w;
      if (!this.tConfig.shared && null === s11.globals.series[e4][a10])
        return void this.handleMouseOut(i17);
      if (void 0 !== s11.globals.series[e4][a10])
        this.tConfig.shared && this.tooltipUtil.isXoverlap(a10) && this.tooltipUtil.isInitialSeriesSameLen() ? this.create(t8, this, e4, a10, i17.ttItems) : this.create(t8, this, e4, a10, i17.ttItems, false);
      else if (this.tooltipUtil.isXoverlap(a10)) {
        var r13 = s11.globals.series.findIndex(function(t9, e5) {
          return !s11.globals.collapsedSeriesIndices.includes(e5);
        });
        this.create(t8, this, r13, a10, i17.ttItems);
      }
    } }, { key: "deactivateHoverFilter", value: function() {
      for (var t8 = this.w, e4 = new m3(this.ctx), i17 = t8.globals.dom.Paper.select(".apexcharts-bar-area"), a10 = 0; a10 < i17.length; a10++)
        e4.pathMouseLeave(i17[a10]);
    } }, { key: "handleMouseOut", value: function(t8) {
      var e4 = this.w, i17 = this.getElXCrosshairs();
      if (e4.globals.dom.baseEl.classList.remove("apexcharts-tooltip-active"), t8.tooltipEl.classList.remove("apexcharts-active"), this.deactivateHoverFilter(), "bubble" !== e4.config.chart.type && this.marker.resetPointsSize(), null !== i17 && i17.classList.remove("apexcharts-active"), null !== this.ycrosshairs && this.ycrosshairs.classList.remove("apexcharts-active"), this.isXAxisTooltipEnabled && this.xaxisTooltip.classList.remove("apexcharts-active"), this.yaxisTooltips.length) {
        null === this.yaxisTTEls && (this.yaxisTTEls = e4.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
        for (var a10 = 0; a10 < this.yaxisTTEls.length; a10++)
          this.yaxisTTEls[a10].classList.remove("apexcharts-active");
      }
      e4.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(function(t9) {
        var e5 = t9.getAttribute("data:default-text");
        t9.innerHTML = decodeURIComponent(e5);
      });
    } }, { key: "markerClick", value: function(t8, e4, i17) {
      var a10 = this.w;
      "function" == typeof a10.config.chart.events.markerClick && a10.config.chart.events.markerClick(t8, this.ctx, { seriesIndex: e4, dataPointIndex: i17, w: a10 }), this.ctx.events.fireEvent("markerClick", [t8, this.ctx, { seriesIndex: e4, dataPointIndex: i17, w: a10 }]);
    } }, { key: "create", value: function(t8, i17, a10, s11, r13) {
      var o10, n11, l8, h4, c7, d9, g7, u6, p7, f5, x4, b3, v5, y5, w4, k4, A3 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null, S3 = this.w, C3 = i17;
      "mouseup" === t8.type && this.markerClick(t8, a10, s11), null === A3 && (A3 = this.tConfig.shared);
      var L4 = this.tooltipUtil.hasMarkers(a10), P3 = this.tooltipUtil.getElBars();
      if (S3.config.legend.tooltipHoverFormatter) {
        var M4 = S3.config.legend.tooltipHoverFormatter, I4 = Array.from(this.legendLabels);
        I4.forEach(function(t9) {
          var e4 = t9.getAttribute("data:default-text");
          t9.innerHTML = decodeURIComponent(e4);
        });
        for (var T4 = 0; T4 < I4.length; T4++) {
          var z4 = I4[T4], X3 = parseInt(z4.getAttribute("i"), 10), E3 = decodeURIComponent(z4.getAttribute("data:default-text")), Y3 = M4(E3, { seriesIndex: A3 ? X3 : a10, dataPointIndex: s11, w: S3 });
          if (A3)
            z4.innerHTML = S3.globals.collapsedSeriesIndices.indexOf(X3) < 0 ? Y3 : E3;
          else if (z4.innerHTML = X3 === a10 ? Y3 : E3, a10 === X3)
            break;
        }
      }
      var F3 = e3(e3({ ttItems: r13, i: a10, j: s11 }, void 0 !== (null === (o10 = S3.globals.seriesRange) || void 0 === o10 || null === (n11 = o10[a10]) || void 0 === n11 || null === (l8 = n11[s11]) || void 0 === l8 || null === (h4 = l8.y[0]) || void 0 === h4 ? void 0 : h4.y1) && { y1: null === (c7 = S3.globals.seriesRange) || void 0 === c7 || null === (d9 = c7[a10]) || void 0 === d9 || null === (g7 = d9[s11]) || void 0 === g7 || null === (u6 = g7.y[0]) || void 0 === u6 ? void 0 : u6.y1 }), void 0 !== (null === (p7 = S3.globals.seriesRange) || void 0 === p7 || null === (f5 = p7[a10]) || void 0 === f5 || null === (x4 = f5[s11]) || void 0 === x4 || null === (b3 = x4.y[0]) || void 0 === b3 ? void 0 : b3.y2) && { y2: null === (v5 = S3.globals.seriesRange) || void 0 === v5 || null === (y5 = v5[a10]) || void 0 === y5 || null === (w4 = y5[s11]) || void 0 === w4 || null === (k4 = w4.y[0]) || void 0 === k4 ? void 0 : k4.y2 });
      if (A3) {
        if (C3.tooltipLabels.drawSeriesTexts(e3(e3({}, F3), {}, { shared: !this.showOnIntersect && this.tConfig.shared })), L4)
          S3.globals.markers.largestSize > 0 ? C3.marker.enlargePoints(s11) : C3.tooltipPosition.moveDynamicPointsOnHover(s11);
        else if (this.tooltipUtil.hasBars() && (this.barSeriesHeight = this.tooltipUtil.getBarsHeight(P3), this.barSeriesHeight > 0)) {
          var R3 = new m3(this.ctx), H4 = S3.globals.dom.Paper.select(".apexcharts-bar-area[j='".concat(s11, "']"));
          this.deactivateHoverFilter(), this.tooltipPosition.moveStickyTooltipOverBars(s11, a10);
          for (var D3 = 0; D3 < H4.length; D3++)
            R3.pathMouseEnter(H4[D3]);
        }
      } else
        C3.tooltipLabels.drawSeriesTexts(e3({ shared: false }, F3)), this.tooltipUtil.hasBars() && C3.tooltipPosition.moveStickyTooltipOverBars(s11, a10), L4 && C3.tooltipPosition.moveMarkers(a10, s11);
    } }]), t7;
  }(), vt = function() {
    function t7(e4) {
      a9(this, t7), this.w = e4.w, this.barCtx = e4, this.totalFormatter = this.w.config.plotOptions.bar.dataLabels.total.formatter, this.totalFormatter || (this.totalFormatter = this.w.config.dataLabels.formatter);
    }
    return r12(t7, [{ key: "handleBarDataLabels", value: function(t8) {
      var e4, i17, a10 = t8.x, s11 = t8.y, r13 = t8.y1, o10 = t8.y2, n11 = t8.i, l8 = t8.j, h4 = t8.realIndex, c7 = t8.columnGroupIndex, d9 = t8.series, g7 = t8.barHeight, u6 = t8.barWidth, p7 = t8.barXPosition, f5 = t8.barYPosition, x4 = t8.visibleSeries, b3 = t8.renderedPath, v5 = this.w, y5 = new m3(this.barCtx.ctx), w4 = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[h4] : this.barCtx.strokeWidth;
      v5.globals.isXNumeric && !v5.globals.isBarHorizontal ? (e4 = a10 + parseFloat(u6 * (x4 + 1)), i17 = s11 + parseFloat(g7 * (x4 + 1)) - w4) : (e4 = a10 + parseFloat(u6 * x4), i17 = s11 + parseFloat(g7 * x4));
      var k4, A3 = null, S3 = a10, C3 = s11, L4 = {}, P3 = v5.config.dataLabels, M4 = this.barCtx.barOptions.dataLabels, I4 = this.barCtx.barOptions.dataLabels.total;
      void 0 !== f5 && this.barCtx.isRangeBar && (i17 = f5, C3 = f5), void 0 !== p7 && this.barCtx.isVerticalGroupedRangeBar && (e4 = p7, S3 = p7);
      var T4 = P3.offsetX, z4 = P3.offsetY, X3 = { width: 0, height: 0 };
      if (v5.config.dataLabels.enabled) {
        var E3 = v5.globals.series[n11][l8];
        X3 = y5.getTextRects(v5.globals.yLabelFormatters[0](E3), parseFloat(P3.style.fontSize));
      }
      var Y3 = { x: a10, y: s11, i: n11, j: l8, realIndex: h4, columnGroupIndex: c7, renderedPath: b3, bcx: e4, bcy: i17, barHeight: g7, barWidth: u6, textRects: X3, strokeWidth: w4, dataLabelsX: S3, dataLabelsY: C3, dataLabelsConfig: P3, barDataLabelsConfig: M4, barTotalDataLabelsConfig: I4, offX: T4, offY: z4 };
      return L4 = this.barCtx.isHorizontal ? this.calculateBarsDataLabelsPosition(Y3) : this.calculateColumnsDataLabelsPosition(Y3), b3.attr({ cy: L4.bcy, cx: L4.bcx, j: l8, val: v5.globals.series[n11][l8], barHeight: g7, barWidth: u6 }), k4 = this.drawCalculatedDataLabels({ x: L4.dataLabelsX, y: L4.dataLabelsY, val: this.barCtx.isRangeBar ? [r13, o10] : "100%" === v5.config.chart.stackType ? d9[n11][l8] : v5.globals.series[n11][l8], i: h4, j: l8, barWidth: u6, barHeight: g7, textRects: X3, dataLabelsConfig: P3 }), v5.config.chart.stacked && I4.enabled && (A3 = this.drawTotalDataLabels({ x: L4.totalDataLabelsX, y: L4.totalDataLabelsY, barWidth: u6, barHeight: g7, realIndex: h4, textAnchor: L4.totalDataLabelsAnchor, val: this.getStackedTotalDataLabel({ realIndex: h4, j: l8 }), dataLabelsConfig: P3, barTotalDataLabelsConfig: I4 })), { dataLabels: k4, totalDataLabels: A3 };
    } }, { key: "getStackedTotalDataLabel", value: function(t8) {
      var i17 = t8.realIndex, a10 = t8.j, s11 = this.w, r13 = this.barCtx.stackedSeriesTotals[a10];
      return this.totalFormatter && (r13 = this.totalFormatter(r13, e3(e3({}, s11), {}, { seriesIndex: i17, dataPointIndex: a10, w: s11 }))), r13;
    } }, { key: "calculateColumnsDataLabelsPosition", value: function(t8) {
      var e4 = this.w, i17 = t8.i, a10 = t8.j, s11 = t8.realIndex;
      t8.columnGroupIndex;
      var r13, o10, n11 = t8.y, l8 = t8.bcx, h4 = t8.barWidth, c7 = t8.barHeight, d9 = t8.textRects, g7 = t8.dataLabelsX, u6 = t8.dataLabelsY, p7 = t8.dataLabelsConfig, f5 = t8.barDataLabelsConfig, x4 = t8.barTotalDataLabelsConfig, b3 = t8.strokeWidth, v5 = t8.offX, y5 = t8.offY, w4 = l8;
      c7 = Math.abs(c7);
      var k4 = "vertical" === e4.config.plotOptions.bar.dataLabels.orientation, A3 = this.barCtx.barHelpers.getZeroValueEncounters({ i: i17, j: a10 }).zeroEncounters;
      l8 -= b3 / 2;
      var S3 = e4.globals.gridWidth / e4.globals.dataPoints;
      if (this.barCtx.isVerticalGroupedRangeBar ? g7 += h4 / 2 : (g7 = e4.globals.isXNumeric ? l8 - h4 / 2 + v5 : l8 - S3 + h4 / 2 + v5, A3 > 0 && e4.config.plotOptions.bar.hideZeroBarsWhenGrouped && (g7 -= h4 * A3)), k4) {
        g7 = g7 + d9.height / 2 - b3 / 2 - 2;
      }
      var C3 = e4.globals.series[i17][a10] < 0, L4 = n11;
      switch (this.barCtx.isReversed && (L4 = n11 + (C3 ? c7 : -c7)), f5.position) {
        case "center":
          u6 = k4 ? C3 ? L4 - c7 / 2 + y5 : L4 + c7 / 2 - y5 : C3 ? L4 - c7 / 2 + d9.height / 2 + y5 : L4 + c7 / 2 + d9.height / 2 - y5;
          break;
        case "bottom":
          u6 = k4 ? C3 ? L4 - c7 + y5 : L4 + c7 - y5 : C3 ? L4 - c7 + d9.height + b3 + y5 : L4 + c7 - d9.height / 2 + b3 - y5;
          break;
        case "top":
          u6 = k4 ? C3 ? L4 + y5 : L4 - y5 : C3 ? L4 - d9.height / 2 - y5 : L4 + d9.height + y5;
      }
      if (this.barCtx.lastActiveBarSerieIndex === s11 && x4.enabled) {
        var P3 = new m3(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({ realIndex: s11, j: a10 }), p7.fontSize);
        r13 = C3 ? L4 - P3.height / 2 - y5 - x4.offsetY + 18 : L4 + P3.height + y5 + x4.offsetY - 18;
        var M4 = S3;
        o10 = w4 + (e4.globals.isXNumeric ? -h4 * e4.globals.barGroups.length / 2 : e4.globals.barGroups.length * h4 / 2 - (e4.globals.barGroups.length - 1) * h4 - M4) + x4.offsetX;
      }
      return e4.config.chart.stacked || (u6 < 0 ? u6 = 0 + b3 : u6 + d9.height / 3 > e4.globals.gridHeight && (u6 = e4.globals.gridHeight - b3)), { bcx: l8, bcy: n11, dataLabelsX: g7, dataLabelsY: u6, totalDataLabelsX: o10, totalDataLabelsY: r13, totalDataLabelsAnchor: "middle" };
    } }, { key: "calculateBarsDataLabelsPosition", value: function(t8) {
      var e4 = this.w, i17 = t8.x, a10 = t8.i, s11 = t8.j, r13 = t8.realIndex;
      t8.columnGroupIndex;
      var o10 = t8.bcy, n11 = t8.barHeight, l8 = t8.barWidth, h4 = t8.textRects, c7 = t8.dataLabelsX, d9 = t8.strokeWidth, g7 = t8.dataLabelsConfig, u6 = t8.barDataLabelsConfig, p7 = t8.barTotalDataLabelsConfig, f5 = t8.offX, x4 = t8.offY, b3 = e4.globals.gridHeight / e4.globals.dataPoints;
      l8 = Math.abs(l8);
      var v5, y5, w4 = o10 - (this.barCtx.isRangeBar ? 0 : b3) + n11 / 2 + h4.height / 2 + x4 - 3, k4 = "start", A3 = e4.globals.series[a10][s11] < 0, S3 = i17;
      switch (this.barCtx.isReversed && (S3 = i17 + (A3 ? -l8 : l8), k4 = A3 ? "start" : "end"), u6.position) {
        case "center":
          c7 = A3 ? S3 + l8 / 2 - f5 : Math.max(h4.width / 2, S3 - l8 / 2) + f5;
          break;
        case "bottom":
          c7 = A3 ? S3 + l8 - d9 - Math.round(h4.width / 2) - f5 : S3 - l8 + d9 + Math.round(h4.width / 2) + f5;
          break;
        case "top":
          c7 = A3 ? S3 - d9 + Math.round(h4.width / 2) - f5 : S3 - d9 - Math.round(h4.width / 2) + f5;
      }
      if (this.barCtx.lastActiveBarSerieIndex === r13 && p7.enabled) {
        var C3 = new m3(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({ realIndex: r13, j: s11 }), g7.fontSize);
        A3 ? (v5 = S3 - d9 - f5 - p7.offsetX, k4 = "end") : v5 = S3 + f5 + p7.offsetX + (this.barCtx.isReversed ? -(l8 + d9) : d9), y5 = w4 - h4.height / 2 + C3.height / 2 + p7.offsetY + d9;
      }
      return e4.config.chart.stacked || (c7 < 0 ? c7 = c7 + h4.width + d9 : c7 + h4.width / 2 > e4.globals.gridWidth && (c7 = e4.globals.gridWidth - h4.width - d9)), { bcx: i17, bcy: o10, dataLabelsX: c7, dataLabelsY: w4, totalDataLabelsX: v5, totalDataLabelsY: y5, totalDataLabelsAnchor: k4 };
    } }, { key: "drawCalculatedDataLabels", value: function(t8) {
      var i17 = t8.x, a10 = t8.y, s11 = t8.val, r13 = t8.i, o10 = t8.j, n11 = t8.textRects, l8 = t8.barHeight, h4 = t8.barWidth, c7 = t8.dataLabelsConfig, d9 = this.w, g7 = "rotate(0)";
      "vertical" === d9.config.plotOptions.bar.dataLabels.orientation && (g7 = "rotate(-90, ".concat(i17, ", ").concat(a10, ")"));
      var u6 = new N3(this.barCtx.ctx), p7 = new m3(this.barCtx.ctx), f5 = c7.formatter, x4 = null, b3 = d9.globals.collapsedSeriesIndices.indexOf(r13) > -1;
      if (c7.enabled && !b3) {
        x4 = p7.group({ class: "apexcharts-data-labels", transform: g7 });
        var v5 = "";
        void 0 !== s11 && (v5 = f5(s11, e3(e3({}, d9), {}, { seriesIndex: r13, dataPointIndex: o10, w: d9 }))), !s11 && d9.config.plotOptions.bar.hideZeroBarsWhenGrouped && (v5 = "");
        var y5 = d9.globals.series[r13][o10] < 0, w4 = d9.config.plotOptions.bar.dataLabels.position;
        if ("vertical" === d9.config.plotOptions.bar.dataLabels.orientation && ("top" === w4 && (c7.textAnchor = y5 ? "end" : "start"), "center" === w4 && (c7.textAnchor = "middle"), "bottom" === w4 && (c7.textAnchor = y5 ? "end" : "start")), this.barCtx.isRangeBar && this.barCtx.barOptions.dataLabels.hideOverflowingLabels)
          h4 < p7.getTextRects(v5, parseFloat(c7.style.fontSize)).width && (v5 = "");
        d9.config.chart.stacked && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && (this.barCtx.isHorizontal ? n11.width / 1.6 > Math.abs(h4) && (v5 = "") : n11.height / 1.6 > Math.abs(l8) && (v5 = ""));
        var k4 = e3({}, c7);
        this.barCtx.isHorizontal && s11 < 0 && ("start" === c7.textAnchor ? k4.textAnchor = "end" : "end" === c7.textAnchor && (k4.textAnchor = "start")), u6.plotDataLabelsText({ x: i17, y: a10, text: v5, i: r13, j: o10, parent: x4, dataLabelsConfig: k4, alwaysDrawDataLabel: true, offsetCorrection: true });
      }
      return x4;
    } }, { key: "drawTotalDataLabels", value: function(t8) {
      var e4 = t8.x, i17 = t8.y, a10 = t8.val;
      t8.barWidth, t8.barHeight;
      var s11 = t8.realIndex, r13 = t8.textAnchor, o10 = t8.barTotalDataLabelsConfig;
      this.w;
      var n11, l8 = new m3(this.barCtx.ctx);
      return o10.enabled && void 0 !== e4 && void 0 !== i17 && this.barCtx.lastActiveBarSerieIndex === s11 && (n11 = l8.drawText({ x: e4, y: i17, foreColor: o10.style.color, text: a10, textAnchor: r13, fontFamily: o10.style.fontFamily, fontSize: o10.style.fontSize, fontWeight: o10.style.fontWeight })), n11;
    } }]), t7;
  }(), mt = function() {
    function t7(e4) {
      a9(this, t7), this.w = e4.w, this.barCtx = e4;
    }
    return r12(t7, [{ key: "initVariables", value: function(t8) {
      var e4 = this.w;
      this.barCtx.series = t8, this.barCtx.totalItems = 0, this.barCtx.seriesLen = 0, this.barCtx.visibleI = -1, this.barCtx.visibleItems = 1;
      for (var i17 = 0; i17 < t8.length; i17++)
        if (t8[i17].length > 0 && (this.barCtx.seriesLen = this.barCtx.seriesLen + 1, this.barCtx.totalItems += t8[i17].length), e4.globals.isXNumeric)
          for (var a10 = 0; a10 < t8[i17].length; a10++)
            e4.globals.seriesX[i17][a10] > e4.globals.minX && e4.globals.seriesX[i17][a10] < e4.globals.maxX && this.barCtx.visibleItems++;
        else
          this.barCtx.visibleItems = e4.globals.dataPoints;
      0 === this.barCtx.seriesLen && (this.barCtx.seriesLen = 1), this.barCtx.zeroSerieses = [], e4.globals.comboCharts || this.checkZeroSeries({ series: t8 });
    } }, { key: "initialPositions", value: function() {
      var t8, e4, i17, a10, s11, r13, o10, n11, l8 = this.w, h4 = l8.globals.dataPoints;
      this.barCtx.isRangeBar && (h4 = l8.globals.labels.length);
      var c7 = this.barCtx.seriesLen;
      if (l8.config.plotOptions.bar.rangeBarGroupRows && (c7 = 1), this.barCtx.isHorizontal)
        s11 = (i17 = l8.globals.gridHeight / h4) / c7, l8.globals.isXNumeric && (s11 = (i17 = l8.globals.gridHeight / this.barCtx.totalItems) / this.barCtx.seriesLen), s11 = s11 * parseInt(this.barCtx.barOptions.barHeight, 10) / 100, -1 === String(this.barCtx.barOptions.barHeight).indexOf("%") && (s11 = parseInt(this.barCtx.barOptions.barHeight, 10)), n11 = this.barCtx.baseLineInvertedY + l8.globals.padHorizontal + (this.barCtx.isReversed ? l8.globals.gridWidth : 0) - (this.barCtx.isReversed ? 2 * this.barCtx.baseLineInvertedY : 0), this.barCtx.isFunnel && (n11 = l8.globals.gridWidth / 2), e4 = (i17 - s11 * this.barCtx.seriesLen) / 2;
      else {
        if (a10 = l8.globals.gridWidth / this.barCtx.visibleItems, l8.config.xaxis.convertedCatToNumeric && (a10 = l8.globals.gridWidth / l8.globals.dataPoints), r13 = a10 / c7 * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100, l8.globals.isXNumeric) {
          var d9 = this.barCtx.xRatio;
          l8.globals.minXDiff && 0.5 !== l8.globals.minXDiff && l8.globals.minXDiff / d9 > 0 && (a10 = l8.globals.minXDiff / d9), (r13 = a10 / c7 * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100) < 1 && (r13 = 1);
        }
        -1 === String(this.barCtx.barOptions.columnWidth).indexOf("%") && (r13 = parseInt(this.barCtx.barOptions.columnWidth, 10)), o10 = l8.globals.gridHeight - this.barCtx.baseLineY[this.barCtx.translationsIndex] - (this.barCtx.isReversed ? l8.globals.gridHeight : 0) + (this.barCtx.isReversed ? 2 * this.barCtx.baseLineY[this.barCtx.translationsIndex] : 0), t8 = l8.globals.padHorizontal + (a10 - r13 * this.barCtx.seriesLen) / 2;
      }
      return l8.globals.barHeight = s11, l8.globals.barWidth = r13, { x: t8, y: e4, yDivision: i17, xDivision: a10, barHeight: s11, barWidth: r13, zeroH: o10, zeroW: n11 };
    } }, { key: "initializeStackedPrevVars", value: function(t8) {
      t8.w.globals.seriesGroups.forEach(function(e4) {
        t8[e4] || (t8[e4] = {}), t8[e4].prevY = [], t8[e4].prevX = [], t8[e4].prevYF = [], t8[e4].prevXF = [], t8[e4].prevYVal = [], t8[e4].prevXVal = [];
      });
    } }, { key: "initializeStackedXYVars", value: function(t8) {
      t8.w.globals.seriesGroups.forEach(function(e4) {
        t8[e4] || (t8[e4] = {}), t8[e4].xArrj = [], t8[e4].xArrjF = [], t8[e4].xArrjVal = [], t8[e4].yArrj = [], t8[e4].yArrjF = [], t8[e4].yArrjVal = [];
      });
    } }, { key: "getPathFillColor", value: function(t8, e4, i17, a10) {
      var s11, r13, o10, n11, l8, h4 = this.w, c7 = new H3(this.barCtx.ctx), d9 = null, g7 = this.barCtx.barOptions.distributed ? i17 : e4;
      this.barCtx.barOptions.colors.ranges.length > 0 && this.barCtx.barOptions.colors.ranges.map(function(a11) {
        t8[e4][i17] >= a11.from && t8[e4][i17] <= a11.to && (d9 = a11.color);
      });
      return null !== (s11 = h4.config.series[e4].data[i17]) && void 0 !== s11 && s11.fillColor && (d9 = h4.config.series[e4].data[i17].fillColor), c7.fillPath({ seriesNumber: this.barCtx.barOptions.distributed ? g7 : a10, dataPointIndex: i17, color: d9, value: t8[e4][i17], fillConfig: null === (r13 = h4.config.series[e4].data[i17]) || void 0 === r13 ? void 0 : r13.fill, fillType: null !== (o10 = h4.config.series[e4].data[i17]) && void 0 !== o10 && null !== (n11 = o10.fill) && void 0 !== n11 && n11.type ? null === (l8 = h4.config.series[e4].data[i17]) || void 0 === l8 ? void 0 : l8.fill.type : Array.isArray(h4.config.fill.type) ? h4.config.fill.type[a10] : h4.config.fill.type });
    } }, { key: "getStrokeWidth", value: function(t8, e4, i17) {
      var a10 = 0, s11 = this.w;
      return void 0 === this.barCtx.series[t8][e4] || null === this.barCtx.series[t8][e4] ? this.barCtx.isNullValue = true : this.barCtx.isNullValue = false, s11.config.stroke.show && (this.barCtx.isNullValue || (a10 = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[i17] : this.barCtx.strokeWidth)), a10;
    } }, { key: "shouldApplyRadius", value: function(t8) {
      var e4 = this.w, i17 = false;
      return e4.config.plotOptions.bar.borderRadius > 0 && (e4.config.chart.stacked && "last" === e4.config.plotOptions.bar.borderRadiusWhenStacked ? this.barCtx.lastActiveBarSerieIndex === t8 && (i17 = true) : i17 = true), i17;
    } }, { key: "barBackground", value: function(t8) {
      var e4 = t8.j, i17 = t8.i, a10 = t8.x1, s11 = t8.x2, r13 = t8.y1, o10 = t8.y2, n11 = t8.elSeries, l8 = this.w, h4 = new m3(this.barCtx.ctx), c7 = new W3(this.barCtx.ctx).getActiveConfigSeriesIndex();
      if (this.barCtx.barOptions.colors.backgroundBarColors.length > 0 && c7 === i17) {
        e4 >= this.barCtx.barOptions.colors.backgroundBarColors.length && (e4 %= this.barCtx.barOptions.colors.backgroundBarColors.length);
        var d9 = this.barCtx.barOptions.colors.backgroundBarColors[e4], g7 = h4.drawRect(void 0 !== a10 ? a10 : 0, void 0 !== r13 ? r13 : 0, void 0 !== s11 ? s11 : l8.globals.gridWidth, void 0 !== o10 ? o10 : l8.globals.gridHeight, this.barCtx.barOptions.colors.backgroundBarRadius, d9, this.barCtx.barOptions.colors.backgroundBarOpacity);
        n11.add(g7), g7.node.classList.add("apexcharts-backgroundBar");
      }
    } }, { key: "getColumnPaths", value: function(t8) {
      var e4, i17 = t8.barWidth, a10 = t8.barXPosition, s11 = t8.y1, r13 = t8.y2, o10 = t8.strokeWidth, n11 = t8.seriesGroup, l8 = t8.realIndex, h4 = t8.i, c7 = t8.j, d9 = t8.w, g7 = new m3(this.barCtx.ctx);
      (o10 = Array.isArray(o10) ? o10[l8] : o10) || (o10 = 0);
      var u6 = i17, p7 = a10;
      null !== (e4 = d9.config.series[l8].data[c7]) && void 0 !== e4 && e4.columnWidthOffset && (p7 = a10 - d9.config.series[l8].data[c7].columnWidthOffset / 2, u6 = i17 + d9.config.series[l8].data[c7].columnWidthOffset);
      var f5 = o10 / 2, x4 = p7 + f5, b3 = p7 + u6 - f5;
      s11 += 1e-3 - f5, r13 += 1e-3 + f5;
      var v5 = g7.move(x4, s11), y5 = g7.move(x4, s11), w4 = g7.line(b3, s11);
      if (d9.globals.previousPaths.length > 0 && (y5 = this.barCtx.getPreviousPath(l8, c7, false)), v5 = v5 + g7.line(x4, r13) + g7.line(b3, r13) + g7.line(b3, s11) + ("around" === d9.config.plotOptions.bar.borderRadiusApplication ? " Z" : " z"), y5 = y5 + g7.line(x4, s11) + w4 + w4 + w4 + w4 + w4 + g7.line(x4, s11) + ("around" === d9.config.plotOptions.bar.borderRadiusApplication ? " Z" : " z"), this.shouldApplyRadius(l8) && (v5 = g7.roundPathCorners(v5, d9.config.plotOptions.bar.borderRadius)), d9.config.chart.stacked) {
        var k4 = this.barCtx;
        (k4 = this.barCtx[n11]).yArrj.push(r13 - f5), k4.yArrjF.push(Math.abs(s11 - r13 + o10)), k4.yArrjVal.push(this.barCtx.series[h4][c7]);
      }
      return { pathTo: v5, pathFrom: y5 };
    } }, { key: "getBarpaths", value: function(t8) {
      var e4, i17 = t8.barYPosition, a10 = t8.barHeight, s11 = t8.x1, r13 = t8.x2, o10 = t8.strokeWidth, n11 = t8.seriesGroup, l8 = t8.realIndex, h4 = t8.i, c7 = t8.j, d9 = t8.w, g7 = new m3(this.barCtx.ctx);
      (o10 = Array.isArray(o10) ? o10[l8] : o10) || (o10 = 0);
      var u6 = i17, p7 = a10;
      null !== (e4 = d9.config.series[l8].data[c7]) && void 0 !== e4 && e4.barHeightOffset && (u6 = i17 - d9.config.series[l8].data[c7].barHeightOffset / 2, p7 = a10 + d9.config.series[l8].data[c7].barHeightOffset);
      var f5 = o10 / 2, x4 = u6 + f5, b3 = u6 + p7 - f5;
      s11 += 1e-3 - f5, r13 += 1e-3 + f5;
      var v5 = g7.move(s11, x4), y5 = g7.move(s11, x4);
      d9.globals.previousPaths.length > 0 && (y5 = this.barCtx.getPreviousPath(l8, c7, false));
      var w4 = g7.line(s11, b3);
      if (v5 = v5 + g7.line(r13, x4) + g7.line(r13, b3) + w4 + ("around" === d9.config.plotOptions.bar.borderRadiusApplication ? " Z" : " z"), y5 = y5 + g7.line(s11, x4) + w4 + w4 + w4 + w4 + w4 + g7.line(s11, x4) + ("around" === d9.config.plotOptions.bar.borderRadiusApplication ? " Z" : " z"), this.shouldApplyRadius(l8) && (v5 = g7.roundPathCorners(v5, d9.config.plotOptions.bar.borderRadius)), d9.config.chart.stacked) {
        var k4 = this.barCtx;
        (k4 = this.barCtx[n11]).xArrj.push(r13 + f5), k4.xArrjF.push(Math.abs(s11 - r13)), k4.xArrjVal.push(this.barCtx.series[h4][c7]);
      }
      return { pathTo: v5, pathFrom: y5 };
    } }, { key: "checkZeroSeries", value: function(t8) {
      for (var e4 = t8.series, i17 = this.w, a10 = 0; a10 < e4.length; a10++) {
        for (var s11 = 0, r13 = 0; r13 < e4[i17.globals.maxValsInArrayIndex].length; r13++)
          s11 += e4[a10][r13];
        0 === s11 && this.barCtx.zeroSerieses.push(a10);
      }
    } }, { key: "getXForValue", value: function(t8, e4) {
      var i17 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2] ? e4 : null;
      return null != t8 && (i17 = e4 + t8 / this.barCtx.invertedYRatio - 2 * (this.barCtx.isReversed ? t8 / this.barCtx.invertedYRatio : 0)), i17;
    } }, { key: "getYForValue", value: function(t8, e4, i17) {
      var a10 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3] ? e4 : null;
      return null != t8 && (a10 = e4 - t8 / this.barCtx.yRatio[i17] + 2 * (this.barCtx.isReversed ? t8 / this.barCtx.yRatio[i17] : 0)), a10;
    } }, { key: "getGoalValues", value: function(t8, i17, a10, s11, r13, n11) {
      var l8 = this, h4 = this.w, c7 = [], d9 = function(e4, s12) {
        var r14;
        c7.push((o9(r14 = {}, t8, "x" === t8 ? l8.getXForValue(e4, i17, false) : l8.getYForValue(e4, a10, n11, false)), o9(r14, "attrs", s12), r14));
      };
      if (h4.globals.seriesGoals[s11] && h4.globals.seriesGoals[s11][r13] && Array.isArray(h4.globals.seriesGoals[s11][r13]) && h4.globals.seriesGoals[s11][r13].forEach(function(t9) {
        d9(t9.value, t9);
      }), this.barCtx.barOptions.isDumbbell && h4.globals.seriesRange.length) {
        var g7 = this.barCtx.barOptions.dumbbellColors ? this.barCtx.barOptions.dumbbellColors : h4.globals.colors, u6 = { strokeHeight: "x" === t8 ? 0 : h4.globals.markers.size[s11], strokeWidth: "x" === t8 ? h4.globals.markers.size[s11] : 0, strokeDashArray: 0, strokeLineCap: "round", strokeColor: Array.isArray(g7[s11]) ? g7[s11][0] : g7[s11] };
        d9(h4.globals.seriesRangeStart[s11][r13], u6), d9(h4.globals.seriesRangeEnd[s11][r13], e3(e3({}, u6), {}, { strokeColor: Array.isArray(g7[s11]) ? g7[s11][1] : g7[s11] }));
      }
      return c7;
    } }, { key: "drawGoalLine", value: function(t8) {
      var e4 = t8.barXPosition, i17 = t8.barYPosition, a10 = t8.goalX, s11 = t8.goalY, r13 = t8.barWidth, o10 = t8.barHeight, n11 = new m3(this.barCtx.ctx), l8 = n11.group({ className: "apexcharts-bar-goals-groups" });
      l8.node.classList.add("apexcharts-element-hidden"), this.barCtx.w.globals.delayedElements.push({ el: l8.node }), l8.attr("clip-path", "url(#gridRectMarkerMask".concat(this.barCtx.w.globals.cuid, ")"));
      var h4 = null;
      return this.barCtx.isHorizontal ? Array.isArray(a10) && a10.forEach(function(t9) {
        if (t9.x >= -1 && t9.x <= n11.w.globals.gridWidth + 1) {
          var e5 = void 0 !== t9.attrs.strokeHeight ? t9.attrs.strokeHeight : o10 / 2, a11 = i17 + e5 + o10 / 2;
          h4 = n11.drawLine(t9.x, a11 - 2 * e5, t9.x, a11, t9.attrs.strokeColor ? t9.attrs.strokeColor : void 0, t9.attrs.strokeDashArray, t9.attrs.strokeWidth ? t9.attrs.strokeWidth : 2, t9.attrs.strokeLineCap), l8.add(h4);
        }
      }) : Array.isArray(s11) && s11.forEach(function(t9) {
        if (t9.y >= -1 && t9.y <= n11.w.globals.gridHeight + 1) {
          var i18 = void 0 !== t9.attrs.strokeWidth ? t9.attrs.strokeWidth : r13 / 2, a11 = e4 + i18 + r13 / 2;
          h4 = n11.drawLine(a11 - 2 * i18, t9.y, a11, t9.y, t9.attrs.strokeColor ? t9.attrs.strokeColor : void 0, t9.attrs.strokeDashArray, t9.attrs.strokeHeight ? t9.attrs.strokeHeight : 2, t9.attrs.strokeLineCap), l8.add(h4);
        }
      }), l8;
    } }, { key: "drawBarShadow", value: function(t8) {
      var e4 = t8.prevPaths, i17 = t8.currPaths, a10 = t8.color, s11 = this.w, r13 = e4.x, o10 = e4.x1, n11 = e4.barYPosition, l8 = i17.x, h4 = i17.x1, c7 = i17.barYPosition, d9 = n11 + i17.barHeight, g7 = new m3(this.barCtx.ctx), u6 = new x3(), p7 = g7.move(o10, d9) + g7.line(r13, d9) + g7.line(l8, c7) + g7.line(h4, c7) + g7.line(o10, d9) + ("around" === s11.config.plotOptions.bar.borderRadiusApplication ? " Z" : " z");
      return g7.drawPath({ d: p7, fill: u6.shadeColor(0.5, x3.rgb2hex(a10)), stroke: "none", strokeWidth: 0, fillOpacity: 1, classes: "apexcharts-bar-shadows" });
    } }, { key: "getZeroValueEncounters", value: function(t8) {
      var e4, i17 = t8.i, a10 = t8.j, s11 = this.w, r13 = 0, o10 = 0;
      return (s11.config.plotOptions.bar.horizontal ? s11.globals.series.map(function(t9, e5) {
        return e5;
      }) : (null === (e4 = s11.globals.columnSeries) || void 0 === e4 ? void 0 : e4.i.map(function(t9) {
        return t9;
      })) || []).forEach(function(t9) {
        var e5 = s11.globals.seriesPercent[t9][a10];
        e5 && r13++, t9 < i17 && 0 === e5 && o10++;
      }), { nonZeroColumns: r13, zeroEncounters: o10 };
    } }, { key: "getGroupIndex", value: function(t8) {
      var e4 = this.w, i17 = e4.globals.seriesGroups.findIndex(function(i18) {
        return i18.indexOf(e4.globals.seriesNames[t8]) > -1;
      }), a10 = this.barCtx.columnGroupIndices, s11 = a10.indexOf(i17);
      return s11 < 0 && (a10.push(i17), s11 = a10.length - 1), { groupIndex: i17, columnGroupIndex: s11 };
    } }]), t7;
  }(), yt = function() {
    function t7(e4, i17) {
      a9(this, t7), this.ctx = e4, this.w = e4.w;
      var s11 = this.w;
      this.barOptions = s11.config.plotOptions.bar, this.isHorizontal = this.barOptions.horizontal, this.strokeWidth = s11.config.stroke.width, this.isNullValue = false, this.isRangeBar = s11.globals.seriesRange.length && this.isHorizontal, this.isVerticalGroupedRangeBar = !s11.globals.isBarHorizontal && s11.globals.seriesRange.length && s11.config.plotOptions.bar.rangeBarGroupRows, this.isFunnel = this.barOptions.isFunnel, this.xyRatios = i17, null !== this.xyRatios && (this.xRatio = i17.xRatio, this.yRatio = i17.yRatio, this.invertedXRatio = i17.invertedXRatio, this.invertedYRatio = i17.invertedYRatio, this.baseLineY = i17.baseLineY, this.baseLineInvertedY = i17.baseLineInvertedY), this.yaxisIndex = 0, this.translationsIndex = 0, this.seriesLen = 0, this.pathArr = [];
      var r13 = new W3(this.ctx);
      this.lastActiveBarSerieIndex = r13.getActiveConfigSeriesIndex("desc", ["bar", "column"]), this.columnGroupIndices = [];
      var o10 = r13.getBarSeriesIndices(), n11 = new y4(this.ctx);
      this.stackedSeriesTotals = n11.getStackedSeriesTotals(this.w.config.series.map(function(t8, e5) {
        return -1 === o10.indexOf(e5) ? e5 : -1;
      }).filter(function(t8) {
        return -1 !== t8;
      })), this.barHelpers = new mt(this);
    }
    return r12(t7, [{ key: "draw", value: function(t8, i17) {
      var a10 = this.w, s11 = new m3(this.ctx), r13 = new y4(this.ctx, a10);
      t8 = r13.getLogSeries(t8), this.series = t8, this.yRatio = r13.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t8);
      var o10 = s11.group({ class: "apexcharts-bar-series apexcharts-plot-series" });
      a10.config.dataLabels.enabled && this.totalItems > this.barOptions.dataLabels.maxItems && console.warn("WARNING: DataLabels are enabled but there are too many to display. This may cause performance issue when rendering - ApexCharts");
      for (var n11 = 0, l8 = 0; n11 < t8.length; n11++, l8++) {
        var h4, c7, d9, g7, u6 = void 0, p7 = void 0, f5 = [], b3 = [], v5 = a10.globals.comboCharts ? i17[n11] : n11, w4 = this.barHelpers.getGroupIndex(v5).columnGroupIndex, k4 = s11.group({ class: "apexcharts-series", rel: n11 + 1, seriesName: x3.escapeString(a10.globals.seriesNames[v5]), "data:realIndex": v5 });
        this.ctx.series.addCollapsedClassToSeries(k4, v5), t8[n11].length > 0 && (this.visibleI = this.visibleI + 1);
        var A3 = 0, S3 = 0;
        this.yRatio.length > 1 && (this.yaxisIndex = a10.globals.seriesYAxisReverseMap[v5], this.translationsIndex = v5);
        var C3 = this.translationsIndex;
        this.isReversed = a10.config.yaxis[this.yaxisIndex] && a10.config.yaxis[this.yaxisIndex].reversed;
        var L4 = this.barHelpers.initialPositions();
        p7 = L4.y, A3 = L4.barHeight, c7 = L4.yDivision, g7 = L4.zeroW, u6 = L4.x, S3 = L4.barWidth, h4 = L4.xDivision, d9 = L4.zeroH, this.horizontal || b3.push(u6 + S3 / 2);
        var P3 = s11.group({ class: "apexcharts-datalabels", "data:realIndex": v5 });
        a10.globals.delayedElements.push({ el: P3.node }), P3.node.classList.add("apexcharts-element-hidden");
        var M4 = s11.group({ class: "apexcharts-bar-goals-markers" }), I4 = s11.group({ class: "apexcharts-bar-shadows" });
        a10.globals.delayedElements.push({ el: I4.node }), I4.node.classList.add("apexcharts-element-hidden");
        for (var T4 = 0; T4 < t8[n11].length; T4++) {
          var z4 = this.barHelpers.getStrokeWidth(n11, T4, v5), X3 = null, E3 = { indexes: { i: n11, j: T4, realIndex: v5, translationsIndex: C3, bc: l8 }, x: u6, y: p7, strokeWidth: z4, elSeries: k4 };
          this.isHorizontal ? (X3 = this.drawBarPaths(e3(e3({}, E3), {}, { barHeight: A3, zeroW: g7, yDivision: c7 })), S3 = this.series[n11][T4] / this.invertedYRatio) : (X3 = this.drawColumnPaths(e3(e3({}, E3), {}, { xDivision: h4, barWidth: S3, zeroH: d9 })), A3 = this.series[n11][T4] / this.yRatio[C3]);
          var Y3 = this.barHelpers.getPathFillColor(t8, n11, T4, v5);
          if (this.isFunnel && this.barOptions.isFunnel3d && this.pathArr.length && T4 > 0) {
            var F3 = this.barHelpers.drawBarShadow({ color: "string" == typeof Y3 && -1 === (null == Y3 ? void 0 : Y3.indexOf("url")) ? Y3 : x3.hexToRgba(a10.globals.colors[n11]), prevPaths: this.pathArr[this.pathArr.length - 1], currPaths: X3 });
            F3 && I4.add(F3);
          }
          this.pathArr.push(X3);
          var R3 = this.barHelpers.drawGoalLine({ barXPosition: X3.barXPosition, barYPosition: X3.barYPosition, goalX: X3.goalX, goalY: X3.goalY, barHeight: A3, barWidth: S3 });
          R3 && M4.add(R3), p7 = X3.y, u6 = X3.x, T4 > 0 && b3.push(u6 + S3 / 2), f5.push(p7), this.renderSeries({ realIndex: v5, pathFill: Y3, j: T4, i: n11, columnGroupIndex: w4, pathFrom: X3.pathFrom, pathTo: X3.pathTo, strokeWidth: z4, elSeries: k4, x: u6, y: p7, series: t8, barHeight: Math.abs(X3.barHeight ? X3.barHeight : A3), barWidth: Math.abs(X3.barWidth ? X3.barWidth : S3), elDataLabelsWrap: P3, elGoalsMarkers: M4, elBarShadows: I4, visibleSeries: this.visibleI, type: "bar" });
        }
        a10.globals.seriesXvalues[v5] = b3, a10.globals.seriesYvalues[v5] = f5, o10.add(k4);
      }
      return o10;
    } }, { key: "renderSeries", value: function(t8) {
      var e4 = t8.realIndex, i17 = t8.pathFill, a10 = t8.lineFill, s11 = t8.j, r13 = t8.i, o10 = t8.columnGroupIndex, n11 = t8.pathFrom, l8 = t8.pathTo, h4 = t8.strokeWidth, c7 = t8.elSeries, d9 = t8.x, g7 = t8.y, u6 = t8.y1, p7 = t8.y2, f5 = t8.series, x4 = t8.barHeight, b3 = t8.barWidth, y5 = t8.barXPosition, w4 = t8.barYPosition, k4 = t8.elDataLabelsWrap, A3 = t8.elGoalsMarkers, S3 = t8.elBarShadows, C3 = t8.visibleSeries, L4 = t8.type, P3 = this.w, M4 = new m3(this.ctx);
      if (!a10) {
        var I4 = "function" == typeof P3.globals.stroke.colors[e4] ? function(t9) {
          var e5, i18 = P3.config.stroke.colors;
          return Array.isArray(i18) && i18.length > 0 && ((e5 = i18[t9]) || (e5 = ""), "function" == typeof e5) ? e5({ value: P3.globals.series[t9][s11], dataPointIndex: s11, w: P3 }) : e5;
        }(e4) : P3.globals.stroke.colors[e4];
        a10 = this.barOptions.distributed ? P3.globals.stroke.colors[s11] : I4;
      }
      P3.config.series[r13].data[s11] && P3.config.series[r13].data[s11].strokeColor && (a10 = P3.config.series[r13].data[s11].strokeColor), this.isNullValue && (i17 = "none");
      var T4 = s11 / P3.config.chart.animations.animateGradually.delay * (P3.config.chart.animations.speed / P3.globals.dataPoints) / 2.4, z4 = M4.renderPaths({ i: r13, j: s11, realIndex: e4, pathFrom: n11, pathTo: l8, stroke: a10, strokeWidth: h4, strokeLineCap: P3.config.stroke.lineCap, fill: i17, animationDelay: T4, initialSpeed: P3.config.chart.animations.speed, dataChangeSpeed: P3.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-".concat(L4, "-area") });
      z4.attr("clip-path", "url(#gridRectMask".concat(P3.globals.cuid, ")"));
      var X3 = P3.config.forecastDataPoints;
      X3.count > 0 && s11 >= P3.globals.dataPoints - X3.count && (z4.node.setAttribute("stroke-dasharray", X3.dashArray), z4.node.setAttribute("stroke-width", X3.strokeWidth), z4.node.setAttribute("fill-opacity", X3.fillOpacity)), void 0 !== u6 && void 0 !== p7 && (z4.attr("data-range-y1", u6), z4.attr("data-range-y2", p7)), new v3(this.ctx).setSelectionFilter(z4, e4, s11), c7.add(z4);
      var E3 = new vt(this).handleBarDataLabels({ x: d9, y: g7, y1: u6, y2: p7, i: r13, j: s11, series: f5, realIndex: e4, columnGroupIndex: o10, barHeight: x4, barWidth: b3, barXPosition: y5, barYPosition: w4, renderedPath: z4, visibleSeries: C3 });
      return null !== E3.dataLabels && k4.add(E3.dataLabels), E3.totalDataLabels && k4.add(E3.totalDataLabels), c7.add(k4), A3 && c7.add(A3), S3 && c7.add(S3), c7;
    } }, { key: "drawBarPaths", value: function(t8) {
      var e4, i17 = t8.indexes, a10 = t8.barHeight, s11 = t8.strokeWidth, r13 = t8.zeroW, o10 = t8.x, n11 = t8.y, l8 = t8.yDivision, h4 = t8.elSeries, c7 = this.w, d9 = i17.i, g7 = i17.j;
      if (c7.globals.isXNumeric)
        e4 = (n11 = (c7.globals.seriesX[d9][g7] - c7.globals.minX) / this.invertedXRatio - a10) + a10 * this.visibleI;
      else if (c7.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
        var u6 = 0, p7 = 0;
        c7.globals.seriesPercent.forEach(function(t9, e5) {
          t9[g7] && u6++, e5 < d9 && 0 === t9[g7] && p7++;
        }), u6 > 0 && (a10 = this.seriesLen * a10 / u6), e4 = n11 + a10 * this.visibleI, e4 -= a10 * p7;
      } else
        e4 = n11 + a10 * this.visibleI;
      this.isFunnel && (r13 -= (this.barHelpers.getXForValue(this.series[d9][g7], r13) - r13) / 2), o10 = this.barHelpers.getXForValue(this.series[d9][g7], r13);
      var f5 = this.barHelpers.getBarpaths({ barYPosition: e4, barHeight: a10, x1: r13, x2: o10, strokeWidth: s11, series: this.series, realIndex: i17.realIndex, i: d9, j: g7, w: c7 });
      return c7.globals.isXNumeric || (n11 += l8), this.barHelpers.barBackground({ j: g7, i: d9, y1: e4 - a10 * this.visibleI, y2: a10 * this.seriesLen, elSeries: h4 }), { pathTo: f5.pathTo, pathFrom: f5.pathFrom, x1: r13, x: o10, y: n11, goalX: this.barHelpers.getGoalValues("x", r13, null, d9, g7), barYPosition: e4, barHeight: a10 };
    } }, { key: "drawColumnPaths", value: function(t8) {
      var e4, i17 = t8.indexes, a10 = t8.x, s11 = t8.y, r13 = t8.xDivision, o10 = t8.barWidth, n11 = t8.zeroH, l8 = t8.strokeWidth, h4 = t8.elSeries, c7 = this.w, d9 = i17.realIndex, g7 = i17.translationsIndex, u6 = i17.i, p7 = i17.j, f5 = i17.bc;
      if (c7.globals.isXNumeric) {
        var x4 = this.getBarXForNumericXAxis({ x: a10, j: p7, realIndex: d9, barWidth: o10 });
        a10 = x4.x, e4 = x4.barXPosition;
      } else if (c7.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
        var b3 = this.barHelpers.getZeroValueEncounters({ i: u6, j: p7 }), v5 = b3.nonZeroColumns, m4 = b3.zeroEncounters;
        v5 > 0 && (o10 = this.seriesLen * o10 / v5), e4 = a10 + o10 * this.visibleI, e4 -= o10 * m4;
      } else
        e4 = a10 + o10 * this.visibleI;
      s11 = this.barHelpers.getYForValue(this.series[u6][p7], n11, g7);
      var y5 = this.barHelpers.getColumnPaths({ barXPosition: e4, barWidth: o10, y1: n11, y2: s11, strokeWidth: l8, series: this.series, realIndex: d9, i: u6, j: p7, w: c7 });
      return c7.globals.isXNumeric || (a10 += r13), this.barHelpers.barBackground({ bc: f5, j: p7, i: u6, x1: e4 - l8 / 2 - o10 * this.visibleI, x2: o10 * this.seriesLen + l8 / 2, elSeries: h4 }), { pathTo: y5.pathTo, pathFrom: y5.pathFrom, x: a10, y: s11, goalY: this.barHelpers.getGoalValues("y", null, n11, u6, p7, g7), barXPosition: e4, barWidth: o10 };
    } }, { key: "getBarXForNumericXAxis", value: function(t8) {
      var e4 = t8.x, i17 = t8.barWidth, a10 = t8.realIndex, s11 = t8.j, r13 = this.w, o10 = a10;
      return r13.globals.seriesX[a10].length || (o10 = r13.globals.maxValsInArrayIndex), r13.globals.seriesX[o10][s11] && (e4 = (r13.globals.seriesX[o10][s11] - r13.globals.minX) / this.xRatio - i17 * this.seriesLen / 2), { barXPosition: e4 + i17 * this.visibleI, x: e4 };
    } }, { key: "getPreviousPath", value: function(t8, e4) {
      for (var i17, a10 = this.w, s11 = 0; s11 < a10.globals.previousPaths.length; s11++) {
        var r13 = a10.globals.previousPaths[s11];
        r13.paths && r13.paths.length > 0 && parseInt(r13.realIndex, 10) === parseInt(t8, 10) && void 0 !== a10.globals.previousPaths[s11].paths[e4] && (i17 = a10.globals.previousPaths[s11].paths[e4].d);
      }
      return i17;
    } }]), t7;
  }(), wt = function(t7) {
    n10(s11, yt);
    var i17 = d8(s11);
    function s11() {
      return a9(this, s11), i17.apply(this, arguments);
    }
    return r12(s11, [{ key: "draw", value: function(t8, i18) {
      var a10 = this, s12 = this.w;
      this.graphics = new m3(this.ctx), this.bar = new yt(this.ctx, this.xyRatios);
      var r13 = new y4(this.ctx, s12);
      t8 = r13.getLogSeries(t8), this.yRatio = r13.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t8), "100%" === s12.config.chart.stackType && (t8 = s12.globals.comboCharts ? i18.map(function(t9) {
        return s12.globals.seriesPercent[t9];
      }) : s12.globals.seriesPercent.slice()), this.series = t8, this.barHelpers.initializeStackedPrevVars(this);
      for (var o10 = this.graphics.group({ class: "apexcharts-bar-series apexcharts-plot-series" }), n11 = 0, l8 = 0, h4 = function(r14, h5) {
        var c8 = void 0, d10 = void 0, g7 = void 0, u6 = void 0, p7 = s12.globals.comboCharts ? i18[r14] : r14, f5 = a10.barHelpers.getGroupIndex(p7), b3 = f5.groupIndex, v5 = f5.columnGroupIndex;
        a10.groupCtx = a10[s12.globals.seriesGroups[b3]];
        var m4 = [], y5 = [], w4 = 0;
        a10.yRatio.length > 1 && (a10.yaxisIndex = s12.globals.seriesYAxisReverseMap[p7][0], w4 = p7), a10.isReversed = s12.config.yaxis[a10.yaxisIndex] && s12.config.yaxis[a10.yaxisIndex].reversed;
        var k4 = a10.graphics.group({ class: "apexcharts-series", seriesName: x3.escapeString(s12.globals.seriesNames[p7]), rel: r14 + 1, "data:realIndex": p7 });
        a10.ctx.series.addCollapsedClassToSeries(k4, p7);
        var A3 = a10.graphics.group({ class: "apexcharts-datalabels", "data:realIndex": p7 }), S3 = a10.graphics.group({ class: "apexcharts-bar-goals-markers" }), C3 = 0, L4 = 0, P3 = a10.initialPositions(n11, l8, c8, d10, g7, u6, w4);
        l8 = P3.y, C3 = P3.barHeight, d10 = P3.yDivision, u6 = P3.zeroW, n11 = P3.x, L4 = P3.barWidth, c8 = P3.xDivision, g7 = P3.zeroH, s12.globals.barHeight = C3, s12.globals.barWidth = L4, a10.barHelpers.initializeStackedXYVars(a10), 1 === a10.groupCtx.prevY.length && a10.groupCtx.prevY[0].every(function(t9) {
          return isNaN(t9);
        }) && (a10.groupCtx.prevY[0] = a10.groupCtx.prevY[0].map(function() {
          return g7;
        }), a10.groupCtx.prevYF[0] = a10.groupCtx.prevYF[0].map(function() {
          return 0;
        }));
        for (var M4 = 0; M4 < s12.globals.dataPoints; M4++) {
          var I4 = a10.barHelpers.getStrokeWidth(r14, M4, p7), T4 = { indexes: { i: r14, j: M4, realIndex: p7, translationsIndex: w4, bc: h5 }, strokeWidth: I4, x: n11, y: l8, elSeries: k4, columnGroupIndex: v5, seriesGroup: s12.globals.seriesGroups[b3] }, z4 = null;
          a10.isHorizontal ? (z4 = a10.drawStackedBarPaths(e3(e3({}, T4), {}, { zeroW: u6, barHeight: C3, yDivision: d10 })), L4 = a10.series[r14][M4] / a10.invertedYRatio) : (z4 = a10.drawStackedColumnPaths(e3(e3({}, T4), {}, { xDivision: c8, barWidth: L4, zeroH: g7 })), C3 = a10.series[r14][M4] / a10.yRatio[w4]);
          var X3 = a10.barHelpers.drawGoalLine({ barXPosition: z4.barXPosition, barYPosition: z4.barYPosition, goalX: z4.goalX, goalY: z4.goalY, barHeight: C3, barWidth: L4 });
          X3 && S3.add(X3), l8 = z4.y, n11 = z4.x, m4.push(n11), y5.push(l8);
          var E3 = a10.barHelpers.getPathFillColor(t8, r14, M4, p7);
          k4 = a10.renderSeries({ realIndex: p7, pathFill: E3, j: M4, i: r14, columnGroupIndex: v5, pathFrom: z4.pathFrom, pathTo: z4.pathTo, strokeWidth: I4, elSeries: k4, x: n11, y: l8, series: t8, barHeight: C3, barWidth: L4, elDataLabelsWrap: A3, elGoalsMarkers: S3, type: "bar", visibleSeries: v5 });
        }
        s12.globals.seriesXvalues[p7] = m4, s12.globals.seriesYvalues[p7] = y5, a10.groupCtx.prevY.push(a10.groupCtx.yArrj), a10.groupCtx.prevYF.push(a10.groupCtx.yArrjF), a10.groupCtx.prevYVal.push(a10.groupCtx.yArrjVal), a10.groupCtx.prevX.push(a10.groupCtx.xArrj), a10.groupCtx.prevXF.push(a10.groupCtx.xArrjF), a10.groupCtx.prevXVal.push(a10.groupCtx.xArrjVal), o10.add(k4);
      }, c7 = 0, d9 = 0; c7 < t8.length; c7++, d9++)
        h4(c7, d9);
      return o10;
    } }, { key: "initialPositions", value: function(t8, e4, i18, a10, s12, r13, o10) {
      var n11, l8, h4 = this.w;
      if (this.isHorizontal) {
        a10 = h4.globals.gridHeight / h4.globals.dataPoints;
        var c7 = h4.config.plotOptions.bar.barHeight;
        n11 = -1 === String(c7).indexOf("%") ? parseInt(c7, 10) : a10 * parseInt(c7, 10) / 100, r13 = h4.globals.padHorizontal + (this.isReversed ? h4.globals.gridWidth - this.baseLineInvertedY : this.baseLineInvertedY), e4 = (a10 - n11) / 2;
      } else {
        l8 = i18 = h4.globals.gridWidth / h4.globals.dataPoints;
        var d9 = h4.config.plotOptions.bar.columnWidth;
        h4.globals.isXNumeric && h4.globals.dataPoints > 1 ? l8 = (i18 = h4.globals.minXDiff / this.xRatio) * parseInt(this.barOptions.columnWidth, 10) / 100 : -1 === String(d9).indexOf("%") ? l8 = parseInt(d9, 10) : l8 *= parseInt(d9, 10) / 100, s12 = h4.globals.gridHeight - this.baseLineY[o10] - (this.isReversed ? h4.globals.gridHeight : 0), t8 = h4.globals.padHorizontal + (i18 - l8) / 2;
      }
      var g7 = h4.globals.barGroups.length || 1;
      return { x: t8, y: e4, yDivision: a10, xDivision: i18, barHeight: n11 / g7, barWidth: l8 / g7, zeroH: s12, zeroW: r13 };
    } }, { key: "drawStackedBarPaths", value: function(t8) {
      for (var e4, i18 = t8.indexes, a10 = t8.barHeight, s12 = t8.strokeWidth, r13 = t8.zeroW, o10 = t8.x, n11 = t8.y, l8 = t8.columnGroupIndex, h4 = t8.seriesGroup, c7 = t8.yDivision, d9 = t8.elSeries, g7 = this.w, u6 = n11 + l8 * a10, p7 = i18.i, f5 = i18.j, x4 = i18.realIndex, b3 = i18.translationsIndex, v5 = 0, m4 = 0; m4 < this.groupCtx.prevXF.length; m4++)
        v5 += this.groupCtx.prevXF[m4][f5];
      var y5;
      if ((y5 = h4.indexOf(g7.config.series[x4].name)) > 0) {
        var w4 = r13;
        this.groupCtx.prevXVal[y5 - 1][f5] < 0 ? w4 = this.series[p7][f5] >= 0 ? this.groupCtx.prevX[y5 - 1][f5] + v5 - 2 * (this.isReversed ? v5 : 0) : this.groupCtx.prevX[y5 - 1][f5] : this.groupCtx.prevXVal[y5 - 1][f5] >= 0 && (w4 = this.series[p7][f5] >= 0 ? this.groupCtx.prevX[y5 - 1][f5] : this.groupCtx.prevX[y5 - 1][f5] - v5 + 2 * (this.isReversed ? v5 : 0)), e4 = w4;
      } else
        e4 = r13;
      o10 = null === this.series[p7][f5] ? e4 : e4 + this.series[p7][f5] / this.invertedYRatio - 2 * (this.isReversed ? this.series[p7][f5] / this.invertedYRatio : 0);
      var k4 = this.barHelpers.getBarpaths({ barYPosition: u6, barHeight: a10, x1: e4, x2: o10, strokeWidth: s12, series: this.series, realIndex: i18.realIndex, seriesGroup: h4, i: p7, j: f5, w: g7 });
      return this.barHelpers.barBackground({ j: f5, i: p7, y1: u6, y2: a10, elSeries: d9 }), n11 += c7, { pathTo: k4.pathTo, pathFrom: k4.pathFrom, goalX: this.barHelpers.getGoalValues("x", r13, null, p7, f5, b3), barXPosition: e4, barYPosition: u6, x: o10, y: n11 };
    } }, { key: "drawStackedColumnPaths", value: function(t8) {
      var e4 = t8.indexes, i18 = t8.x, a10 = t8.y, s12 = t8.xDivision, r13 = t8.barWidth, o10 = t8.zeroH, n11 = t8.columnGroupIndex, l8 = t8.seriesGroup, h4 = t8.elSeries, c7 = this.w, d9 = e4.i, g7 = e4.j, u6 = e4.bc, p7 = e4.realIndex, f5 = e4.translationsIndex;
      if (c7.globals.isXNumeric) {
        var x4 = c7.globals.seriesX[p7][g7];
        x4 || (x4 = 0), i18 = (x4 - c7.globals.minX) / this.xRatio - r13 / 2 * c7.globals.barGroups.length;
      }
      for (var b3, v5 = i18 + n11 * r13, m4 = 0, y5 = 0; y5 < this.groupCtx.prevYF.length; y5++)
        m4 += isNaN(this.groupCtx.prevYF[y5][g7]) ? 0 : this.groupCtx.prevYF[y5][g7];
      var w4 = d9;
      if (l8 && (w4 = l8.indexOf(c7.globals.seriesNames[p7])), w4 > 0 && !c7.globals.isXNumeric || w4 > 0 && c7.globals.isXNumeric && c7.globals.seriesX[p7 - 1][g7] === c7.globals.seriesX[p7][g7]) {
        var k4, A3, S3, C3 = Math.min(this.yRatio.length + 1, p7 + 1);
        if (void 0 !== this.groupCtx.prevY[w4 - 1] && this.groupCtx.prevY[w4 - 1].length)
          for (var L4 = 1; L4 < C3; L4++) {
            var P3;
            if (!isNaN(null === (P3 = this.groupCtx.prevY[w4 - L4]) || void 0 === P3 ? void 0 : P3[g7])) {
              S3 = this.groupCtx.prevY[w4 - L4][g7];
              break;
            }
          }
        for (var M4 = 1; M4 < C3; M4++) {
          var I4, T4;
          if ((null === (I4 = this.groupCtx.prevYVal[w4 - M4]) || void 0 === I4 ? void 0 : I4[g7]) < 0) {
            A3 = this.series[d9][g7] >= 0 ? S3 - m4 + 2 * (this.isReversed ? m4 : 0) : S3;
            break;
          }
          if ((null === (T4 = this.groupCtx.prevYVal[w4 - M4]) || void 0 === T4 ? void 0 : T4[g7]) >= 0) {
            A3 = this.series[d9][g7] >= 0 ? S3 : S3 + m4 - 2 * (this.isReversed ? m4 : 0);
            break;
          }
        }
        void 0 === A3 && (A3 = c7.globals.gridHeight), b3 = null !== (k4 = this.groupCtx.prevYF[0]) && void 0 !== k4 && k4.every(function(t9) {
          return 0 === t9;
        }) && this.groupCtx.prevYF.slice(1, w4).every(function(t9) {
          return t9.every(function(t10) {
            return isNaN(t10);
          });
        }) ? o10 : A3;
      } else
        b3 = o10;
      a10 = this.series[d9][g7] ? b3 - this.series[d9][g7] / this.yRatio[f5] + 2 * (this.isReversed ? this.series[d9][g7] / this.yRatio[f5] : 0) : b3;
      var z4 = this.barHelpers.getColumnPaths({ barXPosition: v5, barWidth: r13, y1: b3, y2: a10, yRatio: this.yRatio[f5], strokeWidth: this.strokeWidth, series: this.series, seriesGroup: l8, realIndex: e4.realIndex, i: d9, j: g7, w: c7 });
      return this.barHelpers.barBackground({ bc: u6, j: g7, i: d9, x1: v5, x2: r13, elSeries: h4 }), { pathTo: z4.pathTo, pathFrom: z4.pathFrom, goalY: this.barHelpers.getGoalValues("y", null, o10, d9, g7), barXPosition: v5, x: c7.globals.isXNumeric ? i18 : i18 + s12, y: a10 };
    } }]), s11;
  }(), kt = function(t7) {
    n10(s11, yt);
    var i17 = d8(s11);
    function s11() {
      return a9(this, s11), i17.apply(this, arguments);
    }
    return r12(s11, [{ key: "draw", value: function(t8, i18, a10) {
      var s12 = this, r13 = this.w, o10 = new m3(this.ctx), n11 = r13.globals.comboCharts ? i18 : r13.config.chart.type, l8 = new H3(this.ctx);
      this.candlestickOptions = this.w.config.plotOptions.candlestick, this.boxOptions = this.w.config.plotOptions.boxPlot, this.isHorizontal = r13.config.plotOptions.bar.horizontal;
      var h4 = new y4(this.ctx, r13);
      t8 = h4.getLogSeries(t8), this.series = t8, this.yRatio = h4.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t8);
      for (var c7 = o10.group({ class: "apexcharts-".concat(n11, "-series apexcharts-plot-series") }), d9 = function(i19) {
        s12.isBoxPlot = "boxPlot" === r13.config.chart.type || "boxPlot" === r13.config.series[i19].type;
        var n12, h5, d10, g8, u6 = void 0, p7 = void 0, f5 = [], b3 = [], v5 = r13.globals.comboCharts ? a10[i19] : i19, m4 = s12.barHelpers.getGroupIndex(v5).columnGroupIndex, y5 = o10.group({ class: "apexcharts-series", seriesName: x3.escapeString(r13.globals.seriesNames[v5]), rel: i19 + 1, "data:realIndex": v5 });
        s12.ctx.series.addCollapsedClassToSeries(y5, v5), t8[i19].length > 0 && (s12.visibleI = s12.visibleI + 1);
        var w4, k4, A3 = 0;
        s12.yRatio.length > 1 && (s12.yaxisIndex = r13.globals.seriesYAxisReverseMap[v5][0], A3 = v5);
        var S3 = s12.barHelpers.initialPositions();
        p7 = S3.y, w4 = S3.barHeight, h5 = S3.yDivision, g8 = S3.zeroW, u6 = S3.x, k4 = S3.barWidth, n12 = S3.xDivision, d10 = S3.zeroH, b3.push(u6 + k4 / 2);
        for (var C3 = o10.group({ class: "apexcharts-datalabels", "data:realIndex": v5 }), L4 = function(a11) {
          var o11 = s12.barHelpers.getStrokeWidth(i19, a11, v5), c8 = null, x4 = { indexes: { i: i19, j: a11, realIndex: v5, translationsIndex: A3 }, x: u6, y: p7, strokeWidth: o11, elSeries: y5 };
          c8 = s12.isHorizontal ? s12.drawHorizontalBoxPaths(e3(e3({}, x4), {}, { yDivision: h5, barHeight: w4, zeroW: g8 })) : s12.drawVerticalBoxPaths(e3(e3({}, x4), {}, { xDivision: n12, barWidth: k4, zeroH: d10 })), p7 = c8.y, u6 = c8.x, a11 > 0 && b3.push(u6 + k4 / 2), f5.push(p7), c8.pathTo.forEach(function(e4, n13) {
            var h6 = !s12.isBoxPlot && s12.candlestickOptions.wick.useFillColor ? c8.color[n13] : r13.globals.stroke.colors[i19], d11 = l8.fillPath({ seriesNumber: v5, dataPointIndex: a11, color: c8.color[n13], value: t8[i19][a11] });
            s12.renderSeries({ realIndex: v5, pathFill: d11, lineFill: h6, j: a11, i: i19, pathFrom: c8.pathFrom, pathTo: e4, strokeWidth: o11, elSeries: y5, x: u6, y: p7, series: t8, columnGroupIndex: m4, barHeight: w4, barWidth: k4, elDataLabelsWrap: C3, visibleSeries: s12.visibleI, type: r13.config.chart.type });
          });
        }, P3 = 0; P3 < r13.globals.dataPoints; P3++)
          L4(P3);
        r13.globals.seriesXvalues[v5] = b3, r13.globals.seriesYvalues[v5] = f5, c7.add(y5);
      }, g7 = 0; g7 < t8.length; g7++)
        d9(g7);
      return c7;
    } }, { key: "drawVerticalBoxPaths", value: function(t8) {
      var e4 = t8.indexes, i18 = t8.x;
      t8.y;
      var a10 = t8.xDivision, s12 = t8.barWidth, r13 = t8.zeroH, o10 = t8.strokeWidth, n11 = this.w, l8 = new m3(this.ctx), h4 = e4.i, c7 = e4.j, d9 = true, g7 = n11.config.plotOptions.candlestick.colors.upward, u6 = n11.config.plotOptions.candlestick.colors.downward, p7 = "";
      this.isBoxPlot && (p7 = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]);
      var f5 = this.yRatio[e4.translationsIndex], x4 = e4.realIndex, b3 = this.getOHLCValue(x4, c7), v5 = r13, y5 = r13;
      b3.o > b3.c && (d9 = false);
      var w4 = Math.min(b3.o, b3.c), k4 = Math.max(b3.o, b3.c), A3 = b3.m;
      n11.globals.isXNumeric && (i18 = (n11.globals.seriesX[x4][c7] - n11.globals.minX) / this.xRatio - s12 / 2);
      var S3 = i18 + s12 * this.visibleI;
      void 0 === this.series[h4][c7] || null === this.series[h4][c7] ? (w4 = r13, k4 = r13) : (w4 = r13 - w4 / f5, k4 = r13 - k4 / f5, v5 = r13 - b3.h / f5, y5 = r13 - b3.l / f5, A3 = r13 - b3.m / f5);
      var C3 = l8.move(S3, r13), L4 = l8.move(S3 + s12 / 2, w4);
      return n11.globals.previousPaths.length > 0 && (L4 = this.getPreviousPath(x4, c7, true)), C3 = this.isBoxPlot ? [l8.move(S3, w4) + l8.line(S3 + s12 / 2, w4) + l8.line(S3 + s12 / 2, v5) + l8.line(S3 + s12 / 4, v5) + l8.line(S3 + s12 - s12 / 4, v5) + l8.line(S3 + s12 / 2, v5) + l8.line(S3 + s12 / 2, w4) + l8.line(S3 + s12, w4) + l8.line(S3 + s12, A3) + l8.line(S3, A3) + l8.line(S3, w4 + o10 / 2), l8.move(S3, A3) + l8.line(S3 + s12, A3) + l8.line(S3 + s12, k4) + l8.line(S3 + s12 / 2, k4) + l8.line(S3 + s12 / 2, y5) + l8.line(S3 + s12 - s12 / 4, y5) + l8.line(S3 + s12 / 4, y5) + l8.line(S3 + s12 / 2, y5) + l8.line(S3 + s12 / 2, k4) + l8.line(S3, k4) + l8.line(S3, A3) + "z"] : [l8.move(S3, k4) + l8.line(S3 + s12 / 2, k4) + l8.line(S3 + s12 / 2, v5) + l8.line(S3 + s12 / 2, k4) + l8.line(S3 + s12, k4) + l8.line(S3 + s12, w4) + l8.line(S3 + s12 / 2, w4) + l8.line(S3 + s12 / 2, y5) + l8.line(S3 + s12 / 2, w4) + l8.line(S3, w4) + l8.line(S3, k4 - o10 / 2)], L4 += l8.move(S3, w4), n11.globals.isXNumeric || (i18 += a10), { pathTo: C3, pathFrom: L4, x: i18, y: k4, barXPosition: S3, color: this.isBoxPlot ? p7 : d9 ? [g7] : [u6] };
    } }, { key: "drawHorizontalBoxPaths", value: function(t8) {
      var e4 = t8.indexes;
      t8.x;
      var i18 = t8.y, a10 = t8.yDivision, s12 = t8.barHeight, r13 = t8.zeroW, o10 = t8.strokeWidth, n11 = this.w, l8 = new m3(this.ctx), h4 = e4.i, c7 = e4.j, d9 = this.boxOptions.colors.lower;
      this.isBoxPlot && (d9 = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]);
      var g7 = this.invertedYRatio, u6 = e4.realIndex, p7 = this.getOHLCValue(u6, c7), f5 = r13, x4 = r13, b3 = Math.min(p7.o, p7.c), v5 = Math.max(p7.o, p7.c), y5 = p7.m;
      n11.globals.isXNumeric && (i18 = (n11.globals.seriesX[u6][c7] - n11.globals.minX) / this.invertedXRatio - s12 / 2);
      var w4 = i18 + s12 * this.visibleI;
      void 0 === this.series[h4][c7] || null === this.series[h4][c7] ? (b3 = r13, v5 = r13) : (b3 = r13 + b3 / g7, v5 = r13 + v5 / g7, f5 = r13 + p7.h / g7, x4 = r13 + p7.l / g7, y5 = r13 + p7.m / g7);
      var k4 = l8.move(r13, w4), A3 = l8.move(b3, w4 + s12 / 2);
      return n11.globals.previousPaths.length > 0 && (A3 = this.getPreviousPath(u6, c7, true)), k4 = [l8.move(b3, w4) + l8.line(b3, w4 + s12 / 2) + l8.line(f5, w4 + s12 / 2) + l8.line(f5, w4 + s12 / 2 - s12 / 4) + l8.line(f5, w4 + s12 / 2 + s12 / 4) + l8.line(f5, w4 + s12 / 2) + l8.line(b3, w4 + s12 / 2) + l8.line(b3, w4 + s12) + l8.line(y5, w4 + s12) + l8.line(y5, w4) + l8.line(b3 + o10 / 2, w4), l8.move(y5, w4) + l8.line(y5, w4 + s12) + l8.line(v5, w4 + s12) + l8.line(v5, w4 + s12 / 2) + l8.line(x4, w4 + s12 / 2) + l8.line(x4, w4 + s12 - s12 / 4) + l8.line(x4, w4 + s12 / 4) + l8.line(x4, w4 + s12 / 2) + l8.line(v5, w4 + s12 / 2) + l8.line(v5, w4) + l8.line(y5, w4) + "z"], A3 += l8.move(b3, w4), n11.globals.isXNumeric || (i18 += a10), { pathTo: k4, pathFrom: A3, x: v5, y: i18, barYPosition: w4, color: d9 };
    } }, { key: "getOHLCValue", value: function(t8, e4) {
      var i18 = this.w;
      return { o: this.isBoxPlot ? i18.globals.seriesCandleH[t8][e4] : i18.globals.seriesCandleO[t8][e4], h: this.isBoxPlot ? i18.globals.seriesCandleO[t8][e4] : i18.globals.seriesCandleH[t8][e4], m: i18.globals.seriesCandleM[t8][e4], l: this.isBoxPlot ? i18.globals.seriesCandleC[t8][e4] : i18.globals.seriesCandleL[t8][e4], c: this.isBoxPlot ? i18.globals.seriesCandleL[t8][e4] : i18.globals.seriesCandleC[t8][e4] };
    } }]), s11;
  }(), At = function() {
    function t7(e4) {
      a9(this, t7), this.ctx = e4, this.w = e4.w;
    }
    return r12(t7, [{ key: "checkColorRange", value: function() {
      var t8 = this.w, e4 = false, i17 = t8.config.plotOptions[t8.config.chart.type];
      return i17.colorScale.ranges.length > 0 && i17.colorScale.ranges.map(function(t9, i18) {
        t9.from <= 0 && (e4 = true);
      }), e4;
    } }, { key: "getShadeColor", value: function(t8, e4, i17, a10) {
      var s11 = this.w, r13 = 1, o10 = s11.config.plotOptions[t8].shadeIntensity, n11 = this.determineColor(t8, e4, i17);
      s11.globals.hasNegs || a10 ? r13 = s11.config.plotOptions[t8].reverseNegativeShade ? n11.percent < 0 ? n11.percent / 100 * (1.25 * o10) : (1 - n11.percent / 100) * (1.25 * o10) : n11.percent <= 0 ? 1 - (1 + n11.percent / 100) * o10 : (1 - n11.percent / 100) * o10 : (r13 = 1 - n11.percent / 100, "treemap" === t8 && (r13 = (1 - n11.percent / 100) * (1.25 * o10)));
      var l8 = n11.color, h4 = new x3();
      return s11.config.plotOptions[t8].enableShades && (l8 = "dark" === this.w.config.theme.mode ? x3.hexToRgba(h4.shadeColor(-1 * r13, n11.color), s11.config.fill.opacity) : x3.hexToRgba(h4.shadeColor(r13, n11.color), s11.config.fill.opacity)), { color: l8, colorProps: n11 };
    } }, { key: "determineColor", value: function(t8, e4, i17) {
      var a10 = this.w, s11 = a10.globals.series[e4][i17], r13 = a10.config.plotOptions[t8], o10 = r13.colorScale.inverse ? i17 : e4;
      r13.distributed && "treemap" === a10.config.chart.type && (o10 = i17);
      var n11 = a10.globals.colors[o10], l8 = null, h4 = Math.min.apply(Math, u5(a10.globals.series[e4])), c7 = Math.max.apply(Math, u5(a10.globals.series[e4]));
      r13.distributed || "heatmap" !== t8 || (h4 = a10.globals.minY, c7 = a10.globals.maxY), void 0 !== r13.colorScale.min && (h4 = r13.colorScale.min < a10.globals.minY ? r13.colorScale.min : a10.globals.minY, c7 = r13.colorScale.max > a10.globals.maxY ? r13.colorScale.max : a10.globals.maxY);
      var d9 = Math.abs(c7) + Math.abs(h4), g7 = 100 * s11 / (0 === d9 ? d9 - 1e-6 : d9);
      r13.colorScale.ranges.length > 0 && r13.colorScale.ranges.map(function(t9, e5) {
        if (s11 >= t9.from && s11 <= t9.to) {
          n11 = t9.color, l8 = t9.foreColor ? t9.foreColor : null, h4 = t9.from, c7 = t9.to;
          var i18 = Math.abs(c7) + Math.abs(h4);
          g7 = 100 * s11 / (0 === i18 ? i18 - 1e-6 : i18);
        }
      });
      return { color: n11, foreColor: l8, percent: g7 };
    } }, { key: "calculateDataLabels", value: function(t8) {
      var e4 = t8.text, i17 = t8.x, a10 = t8.y, s11 = t8.i, r13 = t8.j, o10 = t8.colorProps, n11 = t8.fontSize, l8 = this.w.config.dataLabels, h4 = new m3(this.ctx), c7 = new N3(this.ctx), d9 = null;
      if (l8.enabled) {
        d9 = h4.group({ class: "apexcharts-data-labels" });
        var g7 = l8.offsetX, u6 = l8.offsetY, p7 = i17 + g7, f5 = a10 + parseFloat(l8.style.fontSize) / 3 + u6;
        c7.plotDataLabelsText({ x: p7, y: f5, text: e4, i: s11, j: r13, color: o10.foreColor, parent: d9, fontSize: n11, dataLabelsConfig: l8 });
      }
      return d9;
    } }, { key: "addListeners", value: function(t8) {
      var e4 = new m3(this.ctx);
      t8.node.addEventListener("mouseenter", e4.pathMouseEnter.bind(this, t8)), t8.node.addEventListener("mouseleave", e4.pathMouseLeave.bind(this, t8)), t8.node.addEventListener("mousedown", e4.pathMouseDown.bind(this, t8));
    } }]), t7;
  }(), St = function() {
    function t7(e4, i17) {
      a9(this, t7), this.ctx = e4, this.w = e4.w, this.xRatio = i17.xRatio, this.yRatio = i17.yRatio, this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.helpers = new At(e4), this.rectRadius = this.w.config.plotOptions.heatmap.radius, this.strokeWidth = this.w.config.stroke.show ? this.w.config.stroke.width : 0;
    }
    return r12(t7, [{ key: "draw", value: function(t8) {
      var e4 = this.w, i17 = new m3(this.ctx), a10 = i17.group({ class: "apexcharts-heatmap" });
      a10.attr("clip-path", "url(#gridRectMask".concat(e4.globals.cuid, ")"));
      var s11 = e4.globals.gridWidth / e4.globals.dataPoints, r13 = e4.globals.gridHeight / e4.globals.series.length, o10 = 0, n11 = false;
      this.negRange = this.helpers.checkColorRange();
      var l8 = t8.slice();
      e4.config.yaxis[0].reversed && (n11 = true, l8.reverse());
      for (var h4 = n11 ? 0 : l8.length - 1; n11 ? h4 < l8.length : h4 >= 0; n11 ? h4++ : h4--) {
        var c7 = i17.group({ class: "apexcharts-series apexcharts-heatmap-series", seriesName: x3.escapeString(e4.globals.seriesNames[h4]), rel: h4 + 1, "data:realIndex": h4 });
        if (this.ctx.series.addCollapsedClassToSeries(c7, h4), e4.config.chart.dropShadow.enabled) {
          var d9 = e4.config.chart.dropShadow;
          new v3(this.ctx).dropShadow(c7, d9, h4);
        }
        for (var g7 = 0, u6 = e4.config.plotOptions.heatmap.shadeIntensity, p7 = 0; p7 < l8[h4].length; p7++) {
          var f5 = this.helpers.getShadeColor(e4.config.chart.type, h4, p7, this.negRange), b3 = f5.color, y5 = f5.colorProps;
          if ("image" === e4.config.fill.type)
            b3 = new H3(this.ctx).fillPath({ seriesNumber: h4, dataPointIndex: p7, opacity: e4.globals.hasNegs ? y5.percent < 0 ? 1 - (1 + y5.percent / 100) : u6 + y5.percent / 100 : y5.percent / 100, patternID: x3.randomId(), width: e4.config.fill.image.width ? e4.config.fill.image.width : s11, height: e4.config.fill.image.height ? e4.config.fill.image.height : r13 });
          var w4 = this.rectRadius, k4 = i17.drawRect(g7, o10, s11, r13, w4);
          if (k4.attr({ cx: g7, cy: o10 }), k4.node.classList.add("apexcharts-heatmap-rect"), c7.add(k4), k4.attr({ fill: b3, i: h4, index: h4, j: p7, val: t8[h4][p7], "stroke-width": this.strokeWidth, stroke: e4.config.plotOptions.heatmap.useFillColorAsStroke ? b3 : e4.globals.stroke.colors[0], color: b3 }), this.helpers.addListeners(k4), e4.config.chart.animations.enabled && !e4.globals.dataChanged) {
            var A3 = 1;
            e4.globals.resized || (A3 = e4.config.chart.animations.speed), this.animateHeatMap(k4, g7, o10, s11, r13, A3);
          }
          if (e4.globals.dataChanged) {
            var S3 = 1;
            if (this.dynamicAnim.enabled && e4.globals.shouldAnimate) {
              S3 = this.dynamicAnim.speed;
              var C3 = e4.globals.previousPaths[h4] && e4.globals.previousPaths[h4][p7] && e4.globals.previousPaths[h4][p7].color;
              C3 || (C3 = "rgba(255, 255, 255, 0)"), this.animateHeatColor(k4, x3.isColorHex(C3) ? C3 : x3.rgb2hex(C3), x3.isColorHex(b3) ? b3 : x3.rgb2hex(b3), S3);
            }
          }
          var L4 = (0, e4.config.dataLabels.formatter)(e4.globals.series[h4][p7], { value: e4.globals.series[h4][p7], seriesIndex: h4, dataPointIndex: p7, w: e4 }), P3 = this.helpers.calculateDataLabels({ text: L4, x: g7 + s11 / 2, y: o10 + r13 / 2, i: h4, j: p7, colorProps: y5, series: l8 });
          null !== P3 && c7.add(P3), g7 += s11;
        }
        o10 += r13, a10.add(c7);
      }
      var M4 = e4.globals.yAxisScale[0].result.slice();
      return e4.config.yaxis[0].reversed ? M4.unshift("") : M4.push(""), e4.globals.yAxisScale[0].result = M4, a10;
    } }, { key: "animateHeatMap", value: function(t8, e4, i17, a10, s11, r13) {
      var o10 = new b2(this.ctx);
      o10.animateRect(t8, { x: e4 + a10 / 2, y: i17 + s11 / 2, width: 0, height: 0 }, { x: e4, y: i17, width: a10, height: s11 }, r13, function() {
        o10.animationCompleted(t8);
      });
    } }, { key: "animateHeatColor", value: function(t8, e4, i17, a10) {
      t8.attr({ fill: e4 }).animate(a10).attr({ fill: i17 });
    } }]), t7;
  }(), Ct = function() {
    function t7(e4) {
      a9(this, t7), this.ctx = e4, this.w = e4.w;
    }
    return r12(t7, [{ key: "drawYAxisTexts", value: function(t8, e4, i17, a10) {
      var s11 = this.w, r13 = s11.config.yaxis[0], o10 = s11.globals.yLabelFormatters[0];
      return new m3(this.ctx).drawText({ x: t8 + r13.labels.offsetX, y: e4 + r13.labels.offsetY, text: o10(a10, i17), textAnchor: "middle", fontSize: r13.labels.style.fontSize, fontFamily: r13.labels.style.fontFamily, foreColor: Array.isArray(r13.labels.style.colors) ? r13.labels.style.colors[i17] : r13.labels.style.colors });
    } }]), t7;
  }(), Lt = function() {
    function t7(e4) {
      a9(this, t7), this.ctx = e4, this.w = e4.w;
      var i17 = this.w;
      this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animBeginArr = [0], this.animDur = 0, this.donutDataLabels = this.w.config.plotOptions.pie.donut.labels, this.lineColorArr = void 0 !== i17.globals.stroke.colors ? i17.globals.stroke.colors : i17.globals.colors, this.defaultSize = Math.min(i17.globals.gridWidth, i17.globals.gridHeight), this.centerY = this.defaultSize / 2, this.centerX = i17.globals.gridWidth / 2, "radialBar" === i17.config.chart.type ? this.fullAngle = 360 : this.fullAngle = Math.abs(i17.config.plotOptions.pie.endAngle - i17.config.plotOptions.pie.startAngle), this.initialAngle = i17.config.plotOptions.pie.startAngle % this.fullAngle, i17.globals.radialSize = this.defaultSize / 2.05 - i17.config.stroke.width - (i17.config.chart.sparkline.enabled ? 0 : i17.config.chart.dropShadow.blur), this.donutSize = i17.globals.radialSize * parseInt(i17.config.plotOptions.pie.donut.size, 10) / 100;
      var s11 = i17.config.plotOptions.pie.customScale, r13 = i17.globals.gridWidth / 2, o10 = i17.globals.gridHeight / 2;
      this.translateX = r13 - r13 * s11, this.translateY = o10 - o10 * s11, this.dataLabelsGroup = new m3(this.ctx).group({ class: "apexcharts-datalabels-group", transform: "translate(".concat(this.translateX, ", ").concat(this.translateY, ") scale(").concat(s11, ")") }), this.maxY = 0, this.sliceLabels = [], this.sliceSizes = [], this.prevSectorAngleArr = [];
    }
    return r12(t7, [{ key: "draw", value: function(t8) {
      var e4 = this, i17 = this.w, a10 = new m3(this.ctx), s11 = a10.group({ class: "apexcharts-pie" });
      if (i17.globals.noData)
        return s11;
      for (var r13 = 0, o10 = 0; o10 < t8.length; o10++)
        r13 += x3.negToZero(t8[o10]);
      var n11 = [], l8 = a10.group();
      0 === r13 && (r13 = 1e-5), t8.forEach(function(t9) {
        e4.maxY = Math.max(e4.maxY, t9);
      }), i17.config.yaxis[0].max && (this.maxY = i17.config.yaxis[0].max), "back" === i17.config.grid.position && "polarArea" === this.chartType && this.drawPolarElements(s11);
      for (var h4 = 0; h4 < t8.length; h4++) {
        var c7 = this.fullAngle * x3.negToZero(t8[h4]) / r13;
        n11.push(c7), "polarArea" === this.chartType ? (n11[h4] = this.fullAngle / t8.length, this.sliceSizes.push(i17.globals.radialSize * t8[h4] / this.maxY)) : this.sliceSizes.push(i17.globals.radialSize);
      }
      if (i17.globals.dataChanged) {
        for (var d9, g7 = 0, u6 = 0; u6 < i17.globals.previousPaths.length; u6++)
          g7 += x3.negToZero(i17.globals.previousPaths[u6]);
        for (var p7 = 0; p7 < i17.globals.previousPaths.length; p7++)
          d9 = this.fullAngle * x3.negToZero(i17.globals.previousPaths[p7]) / g7, this.prevSectorAngleArr.push(d9);
      }
      if (this.donutSize < 0 && (this.donutSize = 0), "donut" === this.chartType) {
        var f5 = a10.drawCircle(this.donutSize);
        f5.attr({ cx: this.centerX, cy: this.centerY, fill: i17.config.plotOptions.pie.donut.background ? i17.config.plotOptions.pie.donut.background : "transparent" }), l8.add(f5);
      }
      var b3 = this.drawArcs(n11, t8);
      if (this.sliceLabels.forEach(function(t9) {
        b3.add(t9);
      }), l8.attr({ transform: "translate(".concat(this.translateX, ", ").concat(this.translateY, ") scale(").concat(i17.config.plotOptions.pie.customScale, ")") }), l8.add(b3), s11.add(l8), this.donutDataLabels.show) {
        var v5 = this.renderInnerDataLabels(this.dataLabelsGroup, this.donutDataLabels, { hollowSize: this.donutSize, centerX: this.centerX, centerY: this.centerY, opacity: this.donutDataLabels.show });
        s11.add(v5);
      }
      return "front" === i17.config.grid.position && "polarArea" === this.chartType && this.drawPolarElements(s11), s11;
    } }, { key: "drawArcs", value: function(t8, e4) {
      var i17 = this.w, a10 = new v3(this.ctx), s11 = new m3(this.ctx), r13 = new H3(this.ctx), o10 = s11.group({ class: "apexcharts-slices" }), n11 = this.initialAngle, l8 = this.initialAngle, h4 = this.initialAngle, c7 = this.initialAngle;
      this.strokeWidth = i17.config.stroke.show ? i17.config.stroke.width : 0;
      for (var d9 = 0; d9 < t8.length; d9++) {
        var g7 = s11.group({ class: "apexcharts-series apexcharts-pie-series", seriesName: x3.escapeString(i17.globals.seriesNames[d9]), rel: d9 + 1, "data:realIndex": d9 });
        o10.add(g7), l8 = c7, h4 = (n11 = h4) + t8[d9], c7 = l8 + this.prevSectorAngleArr[d9];
        var u6 = h4 < n11 ? this.fullAngle + h4 - n11 : h4 - n11, p7 = r13.fillPath({ seriesNumber: d9, size: this.sliceSizes[d9], value: e4[d9] }), f5 = this.getChangedPath(l8, c7), b3 = s11.drawPath({ d: f5, stroke: Array.isArray(this.lineColorArr) ? this.lineColorArr[d9] : this.lineColorArr, strokeWidth: 0, fill: p7, fillOpacity: i17.config.fill.opacity, classes: "apexcharts-pie-area apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(d9) });
        if (b3.attr({ index: 0, j: d9 }), a10.setSelectionFilter(b3, 0, d9), i17.config.chart.dropShadow.enabled) {
          var y5 = i17.config.chart.dropShadow;
          a10.dropShadow(b3, y5, d9);
        }
        this.addListeners(b3, this.donutDataLabels), m3.setAttrs(b3.node, { "data:angle": u6, "data:startAngle": n11, "data:strokeWidth": this.strokeWidth, "data:value": e4[d9] });
        var w4 = { x: 0, y: 0 };
        "pie" === this.chartType || "polarArea" === this.chartType ? w4 = x3.polarToCartesian(this.centerX, this.centerY, i17.globals.radialSize / 1.25 + i17.config.plotOptions.pie.dataLabels.offset, (n11 + u6 / 2) % this.fullAngle) : "donut" === this.chartType && (w4 = x3.polarToCartesian(this.centerX, this.centerY, (i17.globals.radialSize + this.donutSize) / 2 + i17.config.plotOptions.pie.dataLabels.offset, (n11 + u6 / 2) % this.fullAngle)), g7.add(b3);
        var k4 = 0;
        if (!this.initialAnim || i17.globals.resized || i17.globals.dataChanged ? this.animBeginArr.push(0) : (0 === (k4 = u6 / this.fullAngle * i17.config.chart.animations.speed) && (k4 = 1), this.animDur = k4 + this.animDur, this.animBeginArr.push(this.animDur)), this.dynamicAnim && i17.globals.dataChanged ? this.animatePaths(b3, { size: this.sliceSizes[d9], endAngle: h4, startAngle: n11, prevStartAngle: l8, prevEndAngle: c7, animateStartingPos: true, i: d9, animBeginArr: this.animBeginArr, shouldSetPrevPaths: true, dur: i17.config.chart.animations.dynamicAnimation.speed }) : this.animatePaths(b3, { size: this.sliceSizes[d9], endAngle: h4, startAngle: n11, i: d9, totalItems: t8.length - 1, animBeginArr: this.animBeginArr, dur: k4 }), i17.config.plotOptions.pie.expandOnClick && "polarArea" !== this.chartType && b3.node.addEventListener("mouseup", this.pieClicked.bind(this, d9)), void 0 !== i17.globals.selectedDataPoints[0] && i17.globals.selectedDataPoints[0].indexOf(d9) > -1 && this.pieClicked(d9), i17.config.dataLabels.enabled) {
          var A3 = w4.x, S3 = w4.y, C3 = 100 * u6 / this.fullAngle + "%";
          if (0 !== u6 && i17.config.plotOptions.pie.dataLabels.minAngleToShowLabel < t8[d9]) {
            var L4 = i17.config.dataLabels.formatter;
            void 0 !== L4 && (C3 = L4(i17.globals.seriesPercent[d9][0], { seriesIndex: d9, w: i17 }));
            var P3 = i17.globals.dataLabels.style.colors[d9], M4 = s11.group({ class: "apexcharts-datalabels" }), I4 = s11.drawText({ x: A3, y: S3, text: C3, textAnchor: "middle", fontSize: i17.config.dataLabels.style.fontSize, fontFamily: i17.config.dataLabels.style.fontFamily, fontWeight: i17.config.dataLabels.style.fontWeight, foreColor: P3 });
            if (M4.add(I4), i17.config.dataLabels.dropShadow.enabled) {
              var T4 = i17.config.dataLabels.dropShadow;
              a10.dropShadow(I4, T4);
            }
            I4.node.classList.add("apexcharts-pie-label"), i17.config.chart.animations.animate && false === i17.globals.resized && (I4.node.classList.add("apexcharts-pie-label-delay"), I4.node.style.animationDelay = i17.config.chart.animations.speed / 940 + "s"), this.sliceLabels.push(M4);
          }
        }
      }
      return o10;
    } }, { key: "addListeners", value: function(t8, e4) {
      var i17 = new m3(this.ctx);
      t8.node.addEventListener("mouseenter", i17.pathMouseEnter.bind(this, t8)), t8.node.addEventListener("mouseleave", i17.pathMouseLeave.bind(this, t8)), t8.node.addEventListener("mouseleave", this.revertDataLabelsInner.bind(this, t8.node, e4)), t8.node.addEventListener("mousedown", i17.pathMouseDown.bind(this, t8)), this.donutDataLabels.total.showAlways || (t8.node.addEventListener("mouseenter", this.printDataLabelsInner.bind(this, t8.node, e4)), t8.node.addEventListener("mousedown", this.printDataLabelsInner.bind(this, t8.node, e4)));
    } }, { key: "animatePaths", value: function(t8, e4) {
      var i17 = this.w, a10 = e4.endAngle < e4.startAngle ? this.fullAngle + e4.endAngle - e4.startAngle : e4.endAngle - e4.startAngle, s11 = a10, r13 = e4.startAngle, o10 = e4.startAngle;
      void 0 !== e4.prevStartAngle && void 0 !== e4.prevEndAngle && (r13 = e4.prevEndAngle, s11 = e4.prevEndAngle < e4.prevStartAngle ? this.fullAngle + e4.prevEndAngle - e4.prevStartAngle : e4.prevEndAngle - e4.prevStartAngle), e4.i === i17.config.series.length - 1 && (a10 + o10 > this.fullAngle ? e4.endAngle = e4.endAngle - (a10 + o10) : a10 + o10 < this.fullAngle && (e4.endAngle = e4.endAngle + (this.fullAngle - (a10 + o10)))), a10 === this.fullAngle && (a10 = this.fullAngle - 0.01), this.animateArc(t8, r13, o10, a10, s11, e4);
    } }, { key: "animateArc", value: function(t8, e4, i17, a10, s11, r13) {
      var o10, n11 = this, l8 = this.w, h4 = new b2(this.ctx), c7 = r13.size;
      (isNaN(e4) || isNaN(s11)) && (e4 = i17, s11 = a10, r13.dur = 0);
      var d9 = a10, g7 = i17, u6 = e4 < i17 ? this.fullAngle + e4 - i17 : e4 - i17;
      l8.globals.dataChanged && r13.shouldSetPrevPaths && r13.prevEndAngle && (o10 = n11.getPiePath({ me: n11, startAngle: r13.prevStartAngle, angle: r13.prevEndAngle < r13.prevStartAngle ? this.fullAngle + r13.prevEndAngle - r13.prevStartAngle : r13.prevEndAngle - r13.prevStartAngle, size: c7 }), t8.attr({ d: o10 })), 0 !== r13.dur ? t8.animate(r13.dur, l8.globals.easing, r13.animBeginArr[r13.i]).afterAll(function() {
        "pie" !== n11.chartType && "donut" !== n11.chartType && "polarArea" !== n11.chartType || this.animate(l8.config.chart.animations.dynamicAnimation.speed).attr({ "stroke-width": n11.strokeWidth }), r13.i === l8.config.series.length - 1 && h4.animationCompleted(t8);
      }).during(function(l9) {
        d9 = u6 + (a10 - u6) * l9, r13.animateStartingPos && (d9 = s11 + (a10 - s11) * l9, g7 = e4 - s11 + (i17 - (e4 - s11)) * l9), o10 = n11.getPiePath({ me: n11, startAngle: g7, angle: d9, size: c7 }), t8.node.setAttribute("data:pathOrig", o10), t8.attr({ d: o10 });
      }) : (o10 = n11.getPiePath({ me: n11, startAngle: g7, angle: a10, size: c7 }), r13.isTrack || (l8.globals.animationEnded = true), t8.node.setAttribute("data:pathOrig", o10), t8.attr({ d: o10, "stroke-width": n11.strokeWidth }));
    } }, { key: "pieClicked", value: function(t8) {
      var e4, i17 = this.w, a10 = this, s11 = a10.sliceSizes[t8] + (i17.config.plotOptions.pie.expandOnClick ? 4 : 0), r13 = i17.globals.dom.Paper.select(".apexcharts-".concat(a10.chartType.toLowerCase(), "-slice-").concat(t8)).members[0];
      if ("true" !== r13.attr("data:pieClicked")) {
        var o10 = i17.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area");
        Array.prototype.forEach.call(o10, function(t9) {
          t9.setAttribute("data:pieClicked", "false");
          var e5 = t9.getAttribute("data:pathOrig");
          e5 && t9.setAttribute("d", e5);
        }), i17.globals.capturedDataPointIndex = t8, r13.attr("data:pieClicked", "true");
        var n11 = parseInt(r13.attr("data:startAngle"), 10), l8 = parseInt(r13.attr("data:angle"), 10);
        e4 = a10.getPiePath({ me: a10, startAngle: n11, angle: l8, size: s11 }), 360 !== l8 && r13.plot(e4);
      } else {
        r13.attr({ "data:pieClicked": "false" }), this.revertDataLabelsInner(r13.node, this.donutDataLabels);
        var h4 = r13.attr("data:pathOrig");
        r13.attr({ d: h4 });
      }
    } }, { key: "getChangedPath", value: function(t8, e4) {
      var i17 = "";
      return this.dynamicAnim && this.w.globals.dataChanged && (i17 = this.getPiePath({ me: this, startAngle: t8, angle: e4 - t8, size: this.size })), i17;
    } }, { key: "getPiePath", value: function(t8) {
      var e4, i17 = t8.me, a10 = t8.startAngle, s11 = t8.angle, r13 = t8.size, o10 = new m3(this.ctx), n11 = a10, l8 = Math.PI * (n11 - 90) / 180, h4 = s11 + a10;
      Math.ceil(h4) >= this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle && (h4 = this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle - 0.01), Math.ceil(h4) > this.fullAngle && (h4 -= this.fullAngle);
      var c7 = Math.PI * (h4 - 90) / 180, d9 = i17.centerX + r13 * Math.cos(l8), g7 = i17.centerY + r13 * Math.sin(l8), u6 = i17.centerX + r13 * Math.cos(c7), p7 = i17.centerY + r13 * Math.sin(c7), f5 = x3.polarToCartesian(i17.centerX, i17.centerY, i17.donutSize, h4), b3 = x3.polarToCartesian(i17.centerX, i17.centerY, i17.donutSize, n11), v5 = s11 > 180 ? 1 : 0, y5 = ["M", d9, g7, "A", r13, r13, 0, v5, 1, u6, p7];
      return e4 = "donut" === i17.chartType ? [].concat(y5, ["L", f5.x, f5.y, "A", i17.donutSize, i17.donutSize, 0, v5, 0, b3.x, b3.y, "L", d9, g7, "z"]).join(" ") : "pie" === i17.chartType || "polarArea" === i17.chartType ? [].concat(y5, ["L", i17.centerX, i17.centerY, "L", d9, g7]).join(" ") : [].concat(y5).join(" "), o10.roundPathCorners(e4, 2 * this.strokeWidth);
    } }, { key: "drawPolarElements", value: function(t8) {
      var e4 = this.w, i17 = new _2(this.ctx), a10 = new m3(this.ctx), s11 = new Ct(this.ctx), r13 = a10.group(), o10 = a10.group(), n11 = i17.niceScale(0, Math.ceil(this.maxY), 0), l8 = n11.result.reverse(), h4 = n11.result.length;
      this.maxY = n11.niceMax;
      for (var c7 = e4.globals.radialSize, d9 = c7 / (h4 - 1), g7 = 0; g7 < h4 - 1; g7++) {
        var u6 = a10.drawCircle(c7);
        if (u6.attr({ cx: this.centerX, cy: this.centerY, fill: "none", "stroke-width": e4.config.plotOptions.polarArea.rings.strokeWidth, stroke: e4.config.plotOptions.polarArea.rings.strokeColor }), e4.config.yaxis[0].show) {
          var p7 = s11.drawYAxisTexts(this.centerX, this.centerY - c7 + parseInt(e4.config.yaxis[0].labels.style.fontSize, 10) / 2, g7, l8[g7]);
          o10.add(p7);
        }
        r13.add(u6), c7 -= d9;
      }
      this.drawSpokes(t8), t8.add(r13), t8.add(o10);
    } }, { key: "renderInnerDataLabels", value: function(t8, e4, i17) {
      var a10 = this.w, s11 = new m3(this.ctx), r13 = e4.total.show;
      t8.node.innerHTML = "", t8.node.style.opacity = i17.opacity;
      var o10, n11, l8 = i17.centerX, h4 = i17.centerY;
      o10 = void 0 === e4.name.color ? a10.globals.colors[0] : e4.name.color;
      var c7 = e4.name.fontSize, d9 = e4.name.fontFamily, g7 = e4.name.fontWeight;
      n11 = void 0 === e4.value.color ? a10.config.chart.foreColor : e4.value.color;
      var u6 = e4.value.formatter, p7 = "", f5 = "";
      if (r13 ? (o10 = e4.total.color, c7 = e4.total.fontSize, d9 = e4.total.fontFamily, g7 = e4.total.fontWeight, f5 = e4.total.label, p7 = e4.total.formatter(a10)) : 1 === a10.globals.series.length && (p7 = u6(a10.globals.series[0], a10), f5 = a10.globals.seriesNames[0]), f5 && (f5 = e4.name.formatter(f5, e4.total.show, a10)), e4.name.show) {
        var x4 = s11.drawText({ x: l8, y: h4 + parseFloat(e4.name.offsetY), text: f5, textAnchor: "middle", foreColor: o10, fontSize: c7, fontWeight: g7, fontFamily: d9 });
        x4.node.classList.add("apexcharts-datalabel-label"), t8.add(x4);
      }
      if (e4.value.show) {
        var b3 = e4.name.show ? parseFloat(e4.value.offsetY) + 16 : e4.value.offsetY, v5 = s11.drawText({ x: l8, y: h4 + b3, text: p7, textAnchor: "middle", foreColor: n11, fontWeight: e4.value.fontWeight, fontSize: e4.value.fontSize, fontFamily: e4.value.fontFamily });
        v5.node.classList.add("apexcharts-datalabel-value"), t8.add(v5);
      }
      return t8;
    } }, { key: "printInnerLabels", value: function(t8, e4, i17, a10) {
      var s11, r13 = this.w;
      a10 ? s11 = void 0 === t8.name.color ? r13.globals.colors[parseInt(a10.parentNode.getAttribute("rel"), 10) - 1] : t8.name.color : r13.globals.series.length > 1 && t8.total.show && (s11 = t8.total.color);
      var o10 = r13.globals.dom.baseEl.querySelector(".apexcharts-datalabel-label"), n11 = r13.globals.dom.baseEl.querySelector(".apexcharts-datalabel-value");
      i17 = (0, t8.value.formatter)(i17, r13), a10 || "function" != typeof t8.total.formatter || (i17 = t8.total.formatter(r13));
      var l8 = e4 === t8.total.label;
      e4 = t8.name.formatter(e4, l8, r13), null !== o10 && (o10.textContent = e4), null !== n11 && (n11.textContent = i17), null !== o10 && (o10.style.fill = s11);
    } }, { key: "printDataLabelsInner", value: function(t8, e4) {
      var i17 = this.w, a10 = t8.getAttribute("data:value"), s11 = i17.globals.seriesNames[parseInt(t8.parentNode.getAttribute("rel"), 10) - 1];
      i17.globals.series.length > 1 && this.printInnerLabels(e4, s11, a10, t8);
      var r13 = i17.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group");
      null !== r13 && (r13.style.opacity = 1);
    } }, { key: "drawSpokes", value: function(t8) {
      var e4 = this, i17 = this.w, a10 = new m3(this.ctx), s11 = i17.config.plotOptions.polarArea.spokes;
      if (0 !== s11.strokeWidth) {
        for (var r13 = [], o10 = 360 / i17.globals.series.length, n11 = 0; n11 < i17.globals.series.length; n11++)
          r13.push(x3.polarToCartesian(this.centerX, this.centerY, i17.globals.radialSize, i17.config.plotOptions.pie.startAngle + o10 * n11));
        r13.forEach(function(i18, r14) {
          var o11 = a10.drawLine(i18.x, i18.y, e4.centerX, e4.centerY, Array.isArray(s11.connectorColors) ? s11.connectorColors[r14] : s11.connectorColors);
          t8.add(o11);
        });
      }
    } }, { key: "revertDataLabelsInner", value: function() {
      var t8 = this.w;
      if (this.donutDataLabels.show) {
        var e4 = t8.globals.dom.Paper.select(".apexcharts-datalabels-group").members[0], i17 = this.renderInnerDataLabels(e4, this.donutDataLabels, { hollowSize: this.donutSize, centerX: this.centerX, centerY: this.centerY, opacity: this.donutDataLabels.show });
        t8.globals.dom.Paper.select(".apexcharts-radialbar, .apexcharts-pie").members[0].add(i17);
      }
    } }]), t7;
  }(), Pt = function() {
    function t7(e4) {
      a9(this, t7), this.ctx = e4, this.w = e4.w, this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animDur = 0;
      var i17 = this.w;
      this.graphics = new m3(this.ctx), this.lineColorArr = void 0 !== i17.globals.stroke.colors ? i17.globals.stroke.colors : i17.globals.colors, this.defaultSize = i17.globals.svgHeight < i17.globals.svgWidth ? i17.globals.gridHeight + 1.5 * i17.globals.goldenPadding : i17.globals.gridWidth, this.isLog = i17.config.yaxis[0].logarithmic, this.logBase = i17.config.yaxis[0].logBase, this.coreUtils = new y4(this.ctx), this.maxValue = this.isLog ? this.coreUtils.getLogVal(this.logBase, i17.globals.maxY, 0) : i17.globals.maxY, this.minValue = this.isLog ? this.coreUtils.getLogVal(this.logBase, this.w.globals.minY, 0) : i17.globals.minY, this.polygons = i17.config.plotOptions.radar.polygons, this.strokeWidth = i17.config.stroke.show ? i17.config.stroke.width : 0, this.size = this.defaultSize / 2.1 - this.strokeWidth - i17.config.chart.dropShadow.blur, i17.config.xaxis.labels.show && (this.size = this.size - i17.globals.xAxisLabelsWidth / 1.75), void 0 !== i17.config.plotOptions.radar.size && (this.size = i17.config.plotOptions.radar.size), this.dataRadiusOfPercent = [], this.dataRadius = [], this.angleArr = [], this.yaxisLabelsTextsPos = [];
    }
    return r12(t7, [{ key: "draw", value: function(t8) {
      var i17 = this, a10 = this.w, s11 = new H3(this.ctx), r13 = [], o10 = new N3(this.ctx);
      t8.length && (this.dataPointsLen = t8[a10.globals.maxValsInArrayIndex].length), this.disAngle = 2 * Math.PI / this.dataPointsLen;
      var n11 = a10.globals.gridWidth / 2, l8 = a10.globals.gridHeight / 2, h4 = n11 + a10.config.plotOptions.radar.offsetX, c7 = l8 + a10.config.plotOptions.radar.offsetY, d9 = this.graphics.group({ class: "apexcharts-radar-series apexcharts-plot-series", transform: "translate(".concat(h4 || 0, ", ").concat(c7 || 0, ")") }), g7 = [], u6 = null, p7 = null;
      if (this.yaxisLabels = this.graphics.group({ class: "apexcharts-yaxis" }), t8.forEach(function(t9, n12) {
        var l9 = t9.length === a10.globals.dataPoints, h5 = i17.graphics.group().attr({ class: "apexcharts-series", "data:longestSeries": l9, seriesName: x3.escapeString(a10.globals.seriesNames[n12]), rel: n12 + 1, "data:realIndex": n12 });
        i17.dataRadiusOfPercent[n12] = [], i17.dataRadius[n12] = [], i17.angleArr[n12] = [], t9.forEach(function(t10, e4) {
          var a11 = Math.abs(i17.maxValue - i17.minValue);
          t10 -= i17.minValue, i17.isLog && (t10 = i17.coreUtils.getLogVal(i17.logBase, t10, 0)), i17.dataRadiusOfPercent[n12][e4] = t10 / a11, i17.dataRadius[n12][e4] = i17.dataRadiusOfPercent[n12][e4] * i17.size, i17.angleArr[n12][e4] = e4 * i17.disAngle;
        }), g7 = i17.getDataPointsPos(i17.dataRadius[n12], i17.angleArr[n12]);
        var c8 = i17.createPaths(g7, { x: 0, y: 0 });
        u6 = i17.graphics.group({ class: "apexcharts-series-markers-wrap apexcharts-element-hidden" }), p7 = i17.graphics.group({ class: "apexcharts-datalabels", "data:realIndex": n12 }), a10.globals.delayedElements.push({ el: u6.node, index: n12 });
        var d10 = { i: n12, realIndex: n12, animationDelay: n12, initialSpeed: a10.config.chart.animations.speed, dataChangeSpeed: a10.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-radar", shouldClipToGrid: false, bindEventsOnPaths: false, stroke: a10.globals.stroke.colors[n12], strokeLineCap: a10.config.stroke.lineCap }, f6 = null;
        a10.globals.previousPaths.length > 0 && (f6 = i17.getPreviousPath(n12));
        for (var b3 = 0; b3 < c8.linePathsTo.length; b3++) {
          var m4 = i17.graphics.renderPaths(e3(e3({}, d10), {}, { pathFrom: null === f6 ? c8.linePathsFrom[b3] : f6, pathTo: c8.linePathsTo[b3], strokeWidth: Array.isArray(i17.strokeWidth) ? i17.strokeWidth[n12] : i17.strokeWidth, fill: "none", drawShadow: false }));
          h5.add(m4);
          var y5 = s11.fillPath({ seriesNumber: n12 }), w4 = i17.graphics.renderPaths(e3(e3({}, d10), {}, { pathFrom: null === f6 ? c8.areaPathsFrom[b3] : f6, pathTo: c8.areaPathsTo[b3], strokeWidth: 0, fill: y5, drawShadow: false }));
          if (a10.config.chart.dropShadow.enabled) {
            var k4 = new v3(i17.ctx), A3 = a10.config.chart.dropShadow;
            k4.dropShadow(w4, Object.assign({}, A3, { noUserSpaceOnUse: true }), n12);
          }
          h5.add(w4);
        }
        t9.forEach(function(t10, s12) {
          var r14 = new D2(i17.ctx).getMarkerConfig({ cssClass: "apexcharts-marker", seriesIndex: n12, dataPointIndex: s12 }), l10 = i17.graphics.drawMarker(g7[s12].x, g7[s12].y, r14);
          l10.attr("rel", s12), l10.attr("j", s12), l10.attr("index", n12), l10.node.setAttribute("default-marker-size", r14.pSize);
          var c9 = i17.graphics.group({ class: "apexcharts-series-markers" });
          c9 && c9.add(l10), u6.add(c9), h5.add(u6);
          var d11 = a10.config.dataLabels;
          if (d11.enabled) {
            var f7 = d11.formatter(a10.globals.series[n12][s12], { seriesIndex: n12, dataPointIndex: s12, w: a10 });
            o10.plotDataLabelsText({ x: g7[s12].x, y: g7[s12].y, text: f7, textAnchor: "middle", i: n12, j: n12, parent: p7, offsetCorrection: false, dataLabelsConfig: e3({}, d11) });
          }
          h5.add(p7);
        }), r13.push(h5);
      }), this.drawPolygons({ parent: d9 }), a10.config.xaxis.labels.show) {
        var f5 = this.drawXAxisTexts();
        d9.add(f5);
      }
      return r13.forEach(function(t9) {
        d9.add(t9);
      }), d9.add(this.yaxisLabels), d9;
    } }, { key: "drawPolygons", value: function(t8) {
      for (var e4 = this, i17 = this.w, a10 = t8.parent, s11 = new Ct(this.ctx), r13 = i17.globals.yAxisScale[0].result.reverse(), o10 = r13.length, n11 = [], l8 = this.size / (o10 - 1), h4 = 0; h4 < o10; h4++)
        n11[h4] = l8 * h4;
      n11.reverse();
      var c7 = [], d9 = [];
      n11.forEach(function(t9, i18) {
        var a11 = x3.getPolygonPos(t9, e4.dataPointsLen), s12 = "";
        a11.forEach(function(t10, a12) {
          if (0 === i18) {
            var r14 = e4.graphics.drawLine(t10.x, t10.y, 0, 0, Array.isArray(e4.polygons.connectorColors) ? e4.polygons.connectorColors[a12] : e4.polygons.connectorColors);
            d9.push(r14);
          }
          0 === a12 && e4.yaxisLabelsTextsPos.push({ x: t10.x, y: t10.y }), s12 += t10.x + "," + t10.y + " ";
        }), c7.push(s12);
      }), c7.forEach(function(t9, s12) {
        var r14 = e4.polygons.strokeColors, o11 = e4.polygons.strokeWidth, n12 = e4.graphics.drawPolygon(t9, Array.isArray(r14) ? r14[s12] : r14, Array.isArray(o11) ? o11[s12] : o11, i17.globals.radarPolygons.fill.colors[s12]);
        a10.add(n12);
      }), d9.forEach(function(t9) {
        a10.add(t9);
      }), i17.config.yaxis[0].show && this.yaxisLabelsTextsPos.forEach(function(t9, i18) {
        var a11 = s11.drawYAxisTexts(t9.x, t9.y, i18, r13[i18]);
        e4.yaxisLabels.add(a11);
      });
    } }, { key: "drawXAxisTexts", value: function() {
      var t8 = this, i17 = this.w, a10 = i17.config.xaxis.labels, s11 = this.graphics.group({ class: "apexcharts-xaxis" }), r13 = x3.getPolygonPos(this.size, this.dataPointsLen);
      return i17.globals.labels.forEach(function(o10, n11) {
        var l8 = i17.config.xaxis.labels.formatter, h4 = new N3(t8.ctx);
        if (r13[n11]) {
          var c7 = t8.getTextPos(r13[n11], t8.size), d9 = l8(o10, { seriesIndex: -1, dataPointIndex: n11, w: i17 });
          h4.plotDataLabelsText({ x: c7.newX, y: c7.newY, text: d9, textAnchor: c7.textAnchor, i: n11, j: n11, parent: s11, className: "apexcharts-xaxis-label", color: Array.isArray(a10.style.colors) && a10.style.colors[n11] ? a10.style.colors[n11] : "#a8a8a8", dataLabelsConfig: e3({ textAnchor: c7.textAnchor, dropShadow: { enabled: false } }, a10), offsetCorrection: false }).on("click", function(e4) {
            if ("function" == typeof i17.config.chart.events.xAxisLabelClick) {
              var a11 = Object.assign({}, i17, { labelIndex: n11 });
              i17.config.chart.events.xAxisLabelClick(e4, t8.ctx, a11);
            }
          });
        }
      }), s11;
    } }, { key: "createPaths", value: function(t8, e4) {
      var i17 = this, a10 = [], s11 = [], r13 = [], o10 = [];
      if (t8.length) {
        s11 = [this.graphics.move(e4.x, e4.y)], o10 = [this.graphics.move(e4.x, e4.y)];
        var n11 = this.graphics.move(t8[0].x, t8[0].y), l8 = this.graphics.move(t8[0].x, t8[0].y);
        t8.forEach(function(e5, a11) {
          n11 += i17.graphics.line(e5.x, e5.y), l8 += i17.graphics.line(e5.x, e5.y), a11 === t8.length - 1 && (n11 += "Z", l8 += "Z");
        }), a10.push(n11), r13.push(l8);
      }
      return { linePathsFrom: s11, linePathsTo: a10, areaPathsFrom: o10, areaPathsTo: r13 };
    } }, { key: "getTextPos", value: function(t8, e4) {
      var i17 = "middle", a10 = t8.x, s11 = t8.y;
      return Math.abs(t8.x) >= 10 ? t8.x > 0 ? (i17 = "start", a10 += 10) : t8.x < 0 && (i17 = "end", a10 -= 10) : i17 = "middle", Math.abs(t8.y) >= e4 - 10 && (t8.y < 0 ? s11 -= 10 : t8.y > 0 && (s11 += 10)), { textAnchor: i17, newX: a10, newY: s11 };
    } }, { key: "getPreviousPath", value: function(t8) {
      for (var e4 = this.w, i17 = null, a10 = 0; a10 < e4.globals.previousPaths.length; a10++) {
        var s11 = e4.globals.previousPaths[a10];
        s11.paths.length > 0 && parseInt(s11.realIndex, 10) === parseInt(t8, 10) && void 0 !== e4.globals.previousPaths[a10].paths[0] && (i17 = e4.globals.previousPaths[a10].paths[0].d);
      }
      return i17;
    } }, { key: "getDataPointsPos", value: function(t8, e4) {
      var i17 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.dataPointsLen;
      t8 = t8 || [], e4 = e4 || [];
      for (var a10 = [], s11 = 0; s11 < i17; s11++) {
        var r13 = {};
        r13.x = t8[s11] * Math.sin(e4[s11]), r13.y = -t8[s11] * Math.cos(e4[s11]), a10.push(r13);
      }
      return a10;
    } }]), t7;
  }(), Mt = function(t7) {
    n10(i17, Lt);
    var e4 = d8(i17);
    function i17(t8) {
      var s11;
      a9(this, i17), (s11 = e4.call(this, t8)).ctx = t8, s11.w = t8.w, s11.animBeginArr = [0], s11.animDur = 0;
      var r13 = s11.w;
      return s11.startAngle = r13.config.plotOptions.radialBar.startAngle, s11.endAngle = r13.config.plotOptions.radialBar.endAngle, s11.totalAngle = Math.abs(r13.config.plotOptions.radialBar.endAngle - r13.config.plotOptions.radialBar.startAngle), s11.trackStartAngle = r13.config.plotOptions.radialBar.track.startAngle, s11.trackEndAngle = r13.config.plotOptions.radialBar.track.endAngle, s11.barLabels = s11.w.config.plotOptions.radialBar.barLabels, s11.donutDataLabels = s11.w.config.plotOptions.radialBar.dataLabels, s11.radialDataLabels = s11.donutDataLabels, s11.trackStartAngle || (s11.trackStartAngle = s11.startAngle), s11.trackEndAngle || (s11.trackEndAngle = s11.endAngle), 360 === s11.endAngle && (s11.endAngle = 359.99), s11.margin = parseInt(r13.config.plotOptions.radialBar.track.margin, 10), s11.onBarLabelClick = s11.onBarLabelClick.bind(c6(s11)), s11;
    }
    return r12(i17, [{ key: "draw", value: function(t8) {
      var e5 = this.w, i18 = new m3(this.ctx), a10 = i18.group({ class: "apexcharts-radialbar" });
      if (e5.globals.noData)
        return a10;
      var s11 = i18.group(), r13 = this.defaultSize / 2, o10 = e5.globals.gridWidth / 2, n11 = this.defaultSize / 2.05;
      e5.config.chart.sparkline.enabled || (n11 = n11 - e5.config.stroke.width - e5.config.chart.dropShadow.blur);
      var l8 = e5.globals.fill.colors;
      if (e5.config.plotOptions.radialBar.track.show) {
        var h4 = this.drawTracks({ size: n11, centerX: o10, centerY: r13, colorArr: l8, series: t8 });
        s11.add(h4);
      }
      var c7 = this.drawArcs({ size: n11, centerX: o10, centerY: r13, colorArr: l8, series: t8 }), d9 = 360;
      e5.config.plotOptions.radialBar.startAngle < 0 && (d9 = this.totalAngle);
      var g7 = (360 - d9) / 360;
      if (e5.globals.radialSize = n11 - n11 * g7, this.radialDataLabels.value.show) {
        var u6 = Math.max(this.radialDataLabels.value.offsetY, this.radialDataLabels.name.offsetY);
        e5.globals.radialSize += u6 * g7;
      }
      return s11.add(c7.g), "front" === e5.config.plotOptions.radialBar.hollow.position && (c7.g.add(c7.elHollow), c7.dataLabels && c7.g.add(c7.dataLabels)), a10.add(s11), a10;
    } }, { key: "drawTracks", value: function(t8) {
      var e5 = this.w, i18 = new m3(this.ctx), a10 = i18.group({ class: "apexcharts-tracks" }), s11 = new v3(this.ctx), r13 = new H3(this.ctx), o10 = this.getStrokeWidth(t8);
      t8.size = t8.size - o10 / 2;
      for (var n11 = 0; n11 < t8.series.length; n11++) {
        var l8 = i18.group({ class: "apexcharts-radialbar-track apexcharts-track" });
        a10.add(l8), l8.attr({ rel: n11 + 1 }), t8.size = t8.size - o10 - this.margin;
        var h4 = e5.config.plotOptions.radialBar.track, c7 = r13.fillPath({ seriesNumber: 0, size: t8.size, fillColors: Array.isArray(h4.background) ? h4.background[n11] : h4.background, solid: true }), d9 = this.trackStartAngle, g7 = this.trackEndAngle;
        Math.abs(g7) + Math.abs(d9) >= 360 && (g7 = 360 - Math.abs(this.startAngle) - 0.1);
        var u6 = i18.drawPath({ d: "", stroke: c7, strokeWidth: o10 * parseInt(h4.strokeWidth, 10) / 100, fill: "none", strokeOpacity: h4.opacity, classes: "apexcharts-radialbar-area" });
        if (h4.dropShadow.enabled) {
          var p7 = h4.dropShadow;
          s11.dropShadow(u6, p7);
        }
        l8.add(u6), u6.attr("id", "apexcharts-radialbarTrack-" + n11), this.animatePaths(u6, { centerX: t8.centerX, centerY: t8.centerY, endAngle: g7, startAngle: d9, size: t8.size, i: n11, totalItems: 2, animBeginArr: 0, dur: 0, isTrack: true, easing: e5.globals.easing });
      }
      return a10;
    } }, { key: "drawArcs", value: function(t8) {
      var e5 = this.w, i18 = new m3(this.ctx), a10 = new H3(this.ctx), s11 = new v3(this.ctx), r13 = i18.group(), o10 = this.getStrokeWidth(t8);
      t8.size = t8.size - o10 / 2;
      var n11 = e5.config.plotOptions.radialBar.hollow.background, l8 = t8.size - o10 * t8.series.length - this.margin * t8.series.length - o10 * parseInt(e5.config.plotOptions.radialBar.track.strokeWidth, 10) / 100 / 2, h4 = l8 - e5.config.plotOptions.radialBar.hollow.margin;
      void 0 !== e5.config.plotOptions.radialBar.hollow.image && (n11 = this.drawHollowImage(t8, r13, l8, n11));
      var c7 = this.drawHollow({ size: h4, centerX: t8.centerX, centerY: t8.centerY, fill: n11 || "transparent" });
      if (e5.config.plotOptions.radialBar.hollow.dropShadow.enabled) {
        var d9 = e5.config.plotOptions.radialBar.hollow.dropShadow;
        s11.dropShadow(c7, d9);
      }
      var g7 = 1;
      !this.radialDataLabels.total.show && e5.globals.series.length > 1 && (g7 = 0);
      var u6 = null;
      if (this.radialDataLabels.show) {
        var p7 = e5.globals.dom.Paper.select(".apexcharts-datalabels-group").members[0];
        u6 = this.renderInnerDataLabels(p7, this.radialDataLabels, { hollowSize: l8, centerX: t8.centerX, centerY: t8.centerY, opacity: g7 });
      }
      "back" === e5.config.plotOptions.radialBar.hollow.position && (r13.add(c7), u6 && r13.add(u6));
      var f5 = false;
      e5.config.plotOptions.radialBar.inverseOrder && (f5 = true);
      for (var b3 = f5 ? t8.series.length - 1 : 0; f5 ? b3 >= 0 : b3 < t8.series.length; f5 ? b3-- : b3++) {
        var y5 = i18.group({ class: "apexcharts-series apexcharts-radial-series", seriesName: x3.escapeString(e5.globals.seriesNames[b3]) });
        r13.add(y5), y5.attr({ rel: b3 + 1, "data:realIndex": b3 }), this.ctx.series.addCollapsedClassToSeries(y5, b3), t8.size = t8.size - o10 - this.margin;
        var w4 = a10.fillPath({ seriesNumber: b3, size: t8.size, value: t8.series[b3] }), k4 = this.startAngle, A3 = void 0, S3 = x3.negToZero(t8.series[b3] > 100 ? 100 : t8.series[b3]) / 100, C3 = Math.round(this.totalAngle * S3) + this.startAngle, L4 = void 0;
        e5.globals.dataChanged && (A3 = this.startAngle, L4 = Math.round(this.totalAngle * x3.negToZero(e5.globals.previousPaths[b3]) / 100) + A3), Math.abs(C3) + Math.abs(k4) >= 360 && (C3 -= 0.01), Math.abs(L4) + Math.abs(A3) >= 360 && (L4 -= 0.01);
        var P3 = C3 - k4, M4 = Array.isArray(e5.config.stroke.dashArray) ? e5.config.stroke.dashArray[b3] : e5.config.stroke.dashArray, I4 = i18.drawPath({ d: "", stroke: w4, strokeWidth: o10, fill: "none", fillOpacity: e5.config.fill.opacity, classes: "apexcharts-radialbar-area apexcharts-radialbar-slice-" + b3, strokeDashArray: M4 });
        if (m3.setAttrs(I4.node, { "data:angle": P3, "data:value": t8.series[b3] }), e5.config.chart.dropShadow.enabled) {
          var T4 = e5.config.chart.dropShadow;
          s11.dropShadow(I4, T4, b3);
        }
        if (s11.setSelectionFilter(I4, 0, b3), this.addListeners(I4, this.radialDataLabels), y5.add(I4), I4.attr({ index: 0, j: b3 }), this.barLabels.enabled) {
          var z4 = x3.polarToCartesian(t8.centerX, t8.centerY, t8.size, k4), X3 = this.barLabels.formatter(e5.globals.seriesNames[b3], { seriesIndex: b3, w: e5 }), E3 = ["apexcharts-radialbar-label"];
          this.barLabels.onClick || E3.push("apexcharts-no-click");
          var Y3 = this.barLabels.useSeriesColors ? e5.globals.colors[b3] : e5.config.chart.foreColor;
          Y3 || (Y3 = e5.config.chart.foreColor);
          var F3 = z4.x + this.barLabels.offsetX, R3 = z4.y + this.barLabels.offsetY, D3 = i18.drawText({ x: F3, y: R3, text: X3, textAnchor: "end", dominantBaseline: "middle", fontFamily: this.barLabels.fontFamily, fontWeight: this.barLabels.fontWeight, fontSize: this.barLabels.fontSize, foreColor: Y3, cssClass: E3.join(" ") });
          D3.on("click", this.onBarLabelClick), D3.attr({ rel: b3 + 1 }), 0 !== k4 && D3.attr({ "transform-origin": "".concat(F3, " ").concat(R3), transform: "rotate(".concat(k4, " 0 0)") }), y5.add(D3);
        }
        var O3 = 0;
        !this.initialAnim || e5.globals.resized || e5.globals.dataChanged || (O3 = e5.config.chart.animations.speed), e5.globals.dataChanged && (O3 = e5.config.chart.animations.dynamicAnimation.speed), this.animDur = O3 / (1.2 * t8.series.length) + this.animDur, this.animBeginArr.push(this.animDur), this.animatePaths(I4, { centerX: t8.centerX, centerY: t8.centerY, endAngle: C3, startAngle: k4, prevEndAngle: L4, prevStartAngle: A3, size: t8.size, i: b3, totalItems: 2, animBeginArr: this.animBeginArr, dur: O3, shouldSetPrevPaths: true, easing: e5.globals.easing });
      }
      return { g: r13, elHollow: c7, dataLabels: u6 };
    } }, { key: "drawHollow", value: function(t8) {
      var e5 = new m3(this.ctx).drawCircle(2 * t8.size);
      return e5.attr({ class: "apexcharts-radialbar-hollow", cx: t8.centerX, cy: t8.centerY, r: t8.size, fill: t8.fill }), e5;
    } }, { key: "drawHollowImage", value: function(t8, e5, i18, a10) {
      var s11 = this.w, r13 = new H3(this.ctx), o10 = x3.randomId(), n11 = s11.config.plotOptions.radialBar.hollow.image;
      if (s11.config.plotOptions.radialBar.hollow.imageClipped)
        r13.clippedImgArea({ width: i18, height: i18, image: n11, patternID: "pattern".concat(s11.globals.cuid).concat(o10) }), a10 = "url(#pattern".concat(s11.globals.cuid).concat(o10, ")");
      else {
        var l8 = s11.config.plotOptions.radialBar.hollow.imageWidth, h4 = s11.config.plotOptions.radialBar.hollow.imageHeight;
        if (void 0 === l8 && void 0 === h4) {
          var c7 = s11.globals.dom.Paper.image(n11).loaded(function(e6) {
            this.move(t8.centerX - e6.width / 2 + s11.config.plotOptions.radialBar.hollow.imageOffsetX, t8.centerY - e6.height / 2 + s11.config.plotOptions.radialBar.hollow.imageOffsetY);
          });
          e5.add(c7);
        } else {
          var d9 = s11.globals.dom.Paper.image(n11).loaded(function(e6) {
            this.move(t8.centerX - l8 / 2 + s11.config.plotOptions.radialBar.hollow.imageOffsetX, t8.centerY - h4 / 2 + s11.config.plotOptions.radialBar.hollow.imageOffsetY), this.size(l8, h4);
          });
          e5.add(d9);
        }
      }
      return a10;
    } }, { key: "getStrokeWidth", value: function(t8) {
      var e5 = this.w;
      return t8.size * (100 - parseInt(e5.config.plotOptions.radialBar.hollow.size, 10)) / 100 / (t8.series.length + 1) - this.margin;
    } }, { key: "onBarLabelClick", value: function(t8) {
      var e5 = parseInt(t8.target.getAttribute("rel"), 10) - 1, i18 = this.barLabels.onClick, a10 = this.w;
      i18 && i18(a10.globals.seriesNames[e5], { w: a10, seriesIndex: e5 });
    } }]), i17;
  }(), It = function(t7) {
    n10(s11, yt);
    var i17 = d8(s11);
    function s11() {
      return a9(this, s11), i17.apply(this, arguments);
    }
    return r12(s11, [{ key: "draw", value: function(t8, i18) {
      var a10 = this.w, s12 = new m3(this.ctx);
      this.rangeBarOptions = this.w.config.plotOptions.rangeBar, this.series = t8, this.seriesRangeStart = a10.globals.seriesRangeStart, this.seriesRangeEnd = a10.globals.seriesRangeEnd, this.barHelpers.initVariables(t8);
      for (var r13 = s12.group({ class: "apexcharts-rangebar-series apexcharts-plot-series" }), o10 = 0; o10 < t8.length; o10++) {
        var n11, l8, h4, c7, d9 = void 0, g7 = void 0, u6 = a10.globals.comboCharts ? i18[o10] : o10, p7 = this.barHelpers.getGroupIndex(u6).columnGroupIndex, f5 = s12.group({ class: "apexcharts-series", seriesName: x3.escapeString(a10.globals.seriesNames[u6]), rel: o10 + 1, "data:realIndex": u6 });
        this.ctx.series.addCollapsedClassToSeries(f5, u6), t8[o10].length > 0 && (this.visibleI = this.visibleI + 1);
        var b3 = 0, v5 = 0, y5 = 0;
        this.yRatio.length > 1 && (this.yaxisIndex = a10.globals.seriesYAxisReverseMap[u6][0], y5 = u6);
        var w4 = this.barHelpers.initialPositions();
        g7 = w4.y, c7 = w4.zeroW, d9 = w4.x, v5 = w4.barWidth, b3 = w4.barHeight, n11 = w4.xDivision, l8 = w4.yDivision, h4 = w4.zeroH;
        for (var k4 = s12.group({ class: "apexcharts-datalabels", "data:realIndex": u6 }), A3 = s12.group({ class: "apexcharts-rangebar-goals-markers" }), S3 = 0; S3 < a10.globals.dataPoints; S3++) {
          var C3 = this.barHelpers.getStrokeWidth(o10, S3, u6), L4 = this.seriesRangeStart[o10][S3], P3 = this.seriesRangeEnd[o10][S3], M4 = null, I4 = null, T4 = null, z4 = { x: d9, y: g7, strokeWidth: C3, elSeries: f5 }, X3 = this.seriesLen;
          if (a10.config.plotOptions.bar.rangeBarGroupRows && (X3 = 1), void 0 === a10.config.series[o10].data[S3])
            break;
          if (this.isHorizontal) {
            T4 = g7 + b3 * this.visibleI;
            var E3 = (l8 - b3 * X3) / 2;
            if (a10.config.series[o10].data[S3].x) {
              var Y3 = this.detectOverlappingBars({ i: o10, j: S3, barYPosition: T4, srty: E3, barHeight: b3, yDivision: l8, initPositions: w4 });
              b3 = Y3.barHeight, T4 = Y3.barYPosition;
            }
            v5 = (M4 = this.drawRangeBarPaths(e3({ indexes: { i: o10, j: S3, realIndex: u6 }, barHeight: b3, barYPosition: T4, zeroW: c7, yDivision: l8, y1: L4, y2: P3 }, z4))).barWidth;
          } else {
            a10.globals.isXNumeric && (d9 = (a10.globals.seriesX[o10][S3] - a10.globals.minX) / this.xRatio - v5 / 2), I4 = d9 + v5 * this.visibleI;
            var F3 = (n11 - v5 * X3) / 2;
            if (a10.config.series[o10].data[S3].x) {
              var R3 = this.detectOverlappingBars({ i: o10, j: S3, barXPosition: I4, srtx: F3, barWidth: v5, xDivision: n11, initPositions: w4 });
              v5 = R3.barWidth, I4 = R3.barXPosition;
            }
            b3 = (M4 = this.drawRangeColumnPaths(e3({ indexes: { i: o10, j: S3, realIndex: u6, translationsIndex: y5 }, barWidth: v5, barXPosition: I4, zeroH: h4, xDivision: n11 }, z4))).barHeight;
          }
          var H4 = this.barHelpers.drawGoalLine({ barXPosition: M4.barXPosition, barYPosition: T4, goalX: M4.goalX, goalY: M4.goalY, barHeight: b3, barWidth: v5 });
          H4 && A3.add(H4), g7 = M4.y, d9 = M4.x;
          var D3 = this.barHelpers.getPathFillColor(t8, o10, S3, u6), O3 = a10.globals.stroke.colors[u6];
          this.renderSeries({ realIndex: u6, pathFill: D3, lineFill: O3, j: S3, i: o10, x: d9, y: g7, y1: L4, y2: P3, pathFrom: M4.pathFrom, pathTo: M4.pathTo, strokeWidth: C3, elSeries: f5, series: t8, barHeight: b3, barWidth: v5, barXPosition: I4, barYPosition: T4, columnGroupIndex: p7, elDataLabelsWrap: k4, elGoalsMarkers: A3, visibleSeries: this.visibleI, type: "rangebar" });
        }
        r13.add(f5);
      }
      return r13;
    } }, { key: "detectOverlappingBars", value: function(t8) {
      var e4 = t8.i, i18 = t8.j, a10 = t8.barYPosition, s12 = t8.barXPosition, r13 = t8.srty, o10 = t8.srtx, n11 = t8.barHeight, l8 = t8.barWidth, h4 = t8.yDivision, c7 = t8.xDivision, d9 = t8.initPositions, g7 = this.w, u6 = [], p7 = g7.config.series[e4].data[i18].rangeName, f5 = g7.config.series[e4].data[i18].x, x4 = Array.isArray(f5) ? f5.join(" ") : f5, b3 = g7.globals.labels.map(function(t9) {
        return Array.isArray(t9) ? t9.join(" ") : t9;
      }).indexOf(x4), v5 = g7.globals.seriesRange[e4].findIndex(function(t9) {
        return t9.x === x4 && t9.overlaps.length > 0;
      });
      return this.isHorizontal ? (a10 = g7.config.plotOptions.bar.rangeBarGroupRows ? r13 + h4 * b3 : r13 + n11 * this.visibleI + h4 * b3, v5 > -1 && !g7.config.plotOptions.bar.rangeBarOverlap && (u6 = g7.globals.seriesRange[e4][v5].overlaps).indexOf(p7) > -1 && (a10 = (n11 = d9.barHeight / u6.length) * this.visibleI + h4 * (100 - parseInt(this.barOptions.barHeight, 10)) / 100 / 2 + n11 * (this.visibleI + u6.indexOf(p7)) + h4 * b3)) : (b3 > -1 && !g7.globals.timescaleLabels.length && (s12 = g7.config.plotOptions.bar.rangeBarGroupRows ? o10 + c7 * b3 : o10 + l8 * this.visibleI + c7 * b3), v5 > -1 && !g7.config.plotOptions.bar.rangeBarOverlap && (u6 = g7.globals.seriesRange[e4][v5].overlaps).indexOf(p7) > -1 && (s12 = (l8 = d9.barWidth / u6.length) * this.visibleI + c7 * (100 - parseInt(this.barOptions.barWidth, 10)) / 100 / 2 + l8 * (this.visibleI + u6.indexOf(p7)) + c7 * b3)), { barYPosition: a10, barXPosition: s12, barHeight: n11, barWidth: l8 };
    } }, { key: "drawRangeColumnPaths", value: function(t8) {
      var e4 = t8.indexes, i18 = t8.x, a10 = t8.xDivision, s12 = t8.barWidth, r13 = t8.barXPosition, o10 = t8.zeroH, n11 = this.w, l8 = e4.i, h4 = e4.j, c7 = e4.realIndex, d9 = e4.translationsIndex, g7 = this.yRatio[d9], u6 = this.getRangeValue(c7, h4), p7 = Math.min(u6.start, u6.end), f5 = Math.max(u6.start, u6.end);
      void 0 === this.series[l8][h4] || null === this.series[l8][h4] ? p7 = o10 : (p7 = o10 - p7 / g7, f5 = o10 - f5 / g7);
      var x4 = Math.abs(f5 - p7), b3 = this.barHelpers.getColumnPaths({ barXPosition: r13, barWidth: s12, y1: p7, y2: f5, strokeWidth: this.strokeWidth, series: this.seriesRangeEnd, realIndex: c7, i: c7, j: h4, w: n11 });
      if (n11.globals.isXNumeric) {
        var v5 = this.getBarXForNumericXAxis({ x: i18, j: h4, realIndex: c7, barWidth: s12 });
        i18 = v5.x, r13 = v5.barXPosition;
      } else
        i18 += a10;
      return { pathTo: b3.pathTo, pathFrom: b3.pathFrom, barHeight: x4, x: i18, y: u6.start < 0 && u6.end < 0 ? p7 : f5, goalY: this.barHelpers.getGoalValues("y", null, o10, l8, h4, d9), barXPosition: r13 };
    } }, { key: "preventBarOverflow", value: function(t8) {
      var e4 = this.w;
      return t8 < 0 && (t8 = 0), t8 > e4.globals.gridWidth && (t8 = e4.globals.gridWidth), t8;
    } }, { key: "drawRangeBarPaths", value: function(t8) {
      var e4 = t8.indexes, i18 = t8.y, a10 = t8.y1, s12 = t8.y2, r13 = t8.yDivision, o10 = t8.barHeight, n11 = t8.barYPosition, l8 = t8.zeroW, h4 = this.w, c7 = e4.realIndex, d9 = e4.j, g7 = this.preventBarOverflow(l8 + a10 / this.invertedYRatio), u6 = this.preventBarOverflow(l8 + s12 / this.invertedYRatio), p7 = this.getRangeValue(c7, d9), f5 = Math.abs(u6 - g7), x4 = this.barHelpers.getBarpaths({ barYPosition: n11, barHeight: o10, x1: g7, x2: u6, strokeWidth: this.strokeWidth, series: this.seriesRangeEnd, i: c7, realIndex: c7, j: d9, w: h4 });
      return h4.globals.isXNumeric || (i18 += r13), { pathTo: x4.pathTo, pathFrom: x4.pathFrom, barWidth: f5, x: p7.start < 0 && p7.end < 0 ? g7 : u6, goalX: this.barHelpers.getGoalValues("x", l8, null, c7, d9), y: i18 };
    } }, { key: "getRangeValue", value: function(t8, e4) {
      var i18 = this.w;
      return { start: i18.globals.seriesRangeStart[t8][e4], end: i18.globals.seriesRangeEnd[t8][e4] };
    } }]), s11;
  }(), Tt = function() {
    function t7(e4) {
      a9(this, t7), this.w = e4.w, this.lineCtx = e4;
    }
    return r12(t7, [{ key: "sameValueSeriesFix", value: function(t8, e4) {
      var i17 = this.w;
      if (("gradient" === i17.config.fill.type || "gradient" === i17.config.fill.type[t8]) && new y4(this.lineCtx.ctx, i17).seriesHaveSameValues(t8)) {
        var a10 = e4[t8].slice();
        a10[a10.length - 1] = a10[a10.length - 1] + 1e-6, e4[t8] = a10;
      }
      return e4;
    } }, { key: "calculatePoints", value: function(t8) {
      var e4 = t8.series, i17 = t8.realIndex, a10 = t8.x, s11 = t8.y, r13 = t8.i, o10 = t8.j, n11 = t8.prevY, l8 = this.w, h4 = [], c7 = [];
      if (0 === o10) {
        var d9 = this.lineCtx.categoryAxisCorrection + l8.config.markers.offsetX;
        l8.globals.isXNumeric && (d9 = (l8.globals.seriesX[i17][0] - l8.globals.minX) / this.lineCtx.xRatio + l8.config.markers.offsetX), h4.push(d9), c7.push(x3.isNumber(e4[r13][0]) ? n11 + l8.config.markers.offsetY : null), h4.push(a10 + l8.config.markers.offsetX), c7.push(x3.isNumber(e4[r13][o10 + 1]) ? s11 + l8.config.markers.offsetY : null);
      } else
        h4.push(a10 + l8.config.markers.offsetX), c7.push(x3.isNumber(e4[r13][o10 + 1]) ? s11 + l8.config.markers.offsetY : null);
      return { x: h4, y: c7 };
    } }, { key: "checkPreviousPaths", value: function(t8) {
      for (var e4 = t8.pathFromLine, i17 = t8.pathFromArea, a10 = t8.realIndex, s11 = this.w, r13 = 0; r13 < s11.globals.previousPaths.length; r13++) {
        var o10 = s11.globals.previousPaths[r13];
        ("line" === o10.type || "area" === o10.type) && o10.paths.length > 0 && parseInt(o10.realIndex, 10) === parseInt(a10, 10) && ("line" === o10.type ? (this.lineCtx.appendPathFrom = false, e4 = s11.globals.previousPaths[r13].paths[0].d) : "area" === o10.type && (this.lineCtx.appendPathFrom = false, i17 = s11.globals.previousPaths[r13].paths[0].d, s11.config.stroke.show && s11.globals.previousPaths[r13].paths[1] && (e4 = s11.globals.previousPaths[r13].paths[1].d)));
      }
      return { pathFromLine: e4, pathFromArea: i17 };
    } }, { key: "determineFirstPrevY", value: function(t8) {
      var e4, i17, a10, s11 = t8.i, r13 = t8.realIndex, o10 = t8.series, n11 = t8.prevY, l8 = t8.lineYPosition, h4 = t8.translationsIndex, c7 = this.w, d9 = c7.config.chart.stacked && !c7.globals.comboCharts || c7.config.chart.stacked && c7.globals.comboCharts && (!this.w.config.chart.stackOnlyBar || "bar" === (null === (e4 = this.w.config.series[r13]) || void 0 === e4 ? void 0 : e4.type) || "column" === (null === (i17 = this.w.config.series[r13]) || void 0 === i17 ? void 0 : i17.type));
      if (void 0 !== (null === (a10 = o10[s11]) || void 0 === a10 ? void 0 : a10[0]))
        n11 = (l8 = d9 && s11 > 0 ? this.lineCtx.prevSeriesY[s11 - 1][0] : this.lineCtx.zeroY) - o10[s11][0] / this.lineCtx.yRatio[h4] + 2 * (this.lineCtx.isReversed ? o10[s11][0] / this.lineCtx.yRatio[h4] : 0);
      else if (d9 && s11 > 0 && void 0 === o10[s11][0]) {
        for (var g7 = s11 - 1; g7 >= 0; g7--)
          if (null !== o10[g7][0] && void 0 !== o10[g7][0]) {
            n11 = l8 = this.lineCtx.prevSeriesY[g7][0];
            break;
          }
      }
      return { prevY: n11, lineYPosition: l8 };
    } }]), t7;
  }(), zt = function(t7) {
    for (var e4, i17, a10, s11, r13 = function(t8) {
      for (var e5 = [], i18 = t8[0], a11 = t8[1], s12 = e5[0] = Yt(i18, a11), r14 = 1, o11 = t8.length - 1; r14 < o11; r14++)
        i18 = a11, a11 = t8[r14 + 1], e5[r14] = 0.5 * (s12 + (s12 = Yt(i18, a11)));
      return e5[r14] = s12, e5;
    }(t7), o10 = t7.length - 1, n11 = [], l8 = 0; l8 < o10; l8++)
      a10 = Yt(t7[l8], t7[l8 + 1]), Math.abs(a10) < 1e-6 ? r13[l8] = r13[l8 + 1] = 0 : (s11 = (e4 = r13[l8] / a10) * e4 + (i17 = r13[l8 + 1] / a10) * i17) > 9 && (s11 = 3 * a10 / Math.sqrt(s11), r13[l8] = s11 * e4, r13[l8 + 1] = s11 * i17);
    for (var h4 = 0; h4 <= o10; h4++)
      s11 = (t7[Math.min(o10, h4 + 1)][0] - t7[Math.max(0, h4 - 1)][0]) / (6 * (1 + r13[h4] * r13[h4])), n11.push([s11 || 0, r13[h4] * s11 || 0]);
    return n11;
  }, Xt = function(t7) {
    var e4 = zt(t7), i17 = t7[1], a10 = t7[0], s11 = [], r13 = e4[1], o10 = e4[0];
    s11.push(a10, [a10[0] + o10[0], a10[1] + o10[1], i17[0] - r13[0], i17[1] - r13[1], i17[0], i17[1]]);
    for (var n11 = 2, l8 = e4.length; n11 < l8; n11++) {
      var h4 = t7[n11], c7 = e4[n11];
      s11.push([h4[0] - c7[0], h4[1] - c7[1], h4[0], h4[1]]);
    }
    return s11;
  }, Et = function(t7, e4, i17) {
    var a10 = t7.slice(e4, i17);
    if (e4) {
      if (i17 - e4 > 1 && a10[1].length < 6) {
        var s11 = a10[0].length;
        a10[1] = [2 * a10[0][s11 - 2] - a10[0][s11 - 4], 2 * a10[0][s11 - 1] - a10[0][s11 - 3]].concat(a10[1]);
      }
      a10[0] = a10[0].slice(-2);
    }
    return a10;
  };
  function Yt(t7, e4) {
    return (e4[1] - t7[1]) / (e4[0] - t7[0]);
  }
  var Ft = function() {
    function t7(e4, i17, s11) {
      a9(this, t7), this.ctx = e4, this.w = e4.w, this.xyRatios = i17, this.pointsChart = !("bubble" !== this.w.config.chart.type && "scatter" !== this.w.config.chart.type) || s11, this.scatter = new O2(this.ctx), this.noNegatives = this.w.globals.minX === Number.MAX_VALUE, this.lineHelpers = new Tt(this), this.markers = new D2(this.ctx), this.prevSeriesY = [], this.categoryAxisCorrection = 0, this.yaxisIndex = 0;
    }
    return r12(t7, [{ key: "draw", value: function(t8, i17, a10, s11) {
      var r13, o10 = this.w, n11 = new m3(this.ctx), l8 = o10.globals.comboCharts ? i17 : o10.config.chart.type, h4 = n11.group({ class: "apexcharts-".concat(l8, "-series apexcharts-plot-series") }), c7 = new y4(this.ctx, o10);
      this.yRatio = this.xyRatios.yRatio, this.zRatio = this.xyRatios.zRatio, this.xRatio = this.xyRatios.xRatio, this.baseLineY = this.xyRatios.baseLineY, t8 = c7.getLogSeries(t8), this.yRatio = c7.getLogYRatios(this.yRatio), this.prevSeriesY = [];
      for (var d9 = [], g7 = 0; g7 < t8.length; g7++) {
        t8 = this.lineHelpers.sameValueSeriesFix(g7, t8);
        var u6 = o10.globals.comboCharts ? a10[g7] : g7, p7 = this.yRatio.length > 1 ? u6 : 0;
        this._initSerieVariables(t8, g7, u6);
        var f5 = [], x4 = [], b3 = [], v5 = o10.globals.padHorizontal + this.categoryAxisCorrection;
        this.ctx.series.addCollapsedClassToSeries(this.elSeries, u6), o10.globals.isXNumeric && o10.globals.seriesX.length > 0 && (v5 = (o10.globals.seriesX[u6][0] - o10.globals.minX) / this.xRatio), b3.push(v5);
        var w4, k4 = v5, A3 = void 0, S3 = k4, C3 = this.zeroY, L4 = this.zeroY;
        C3 = this.lineHelpers.determineFirstPrevY({ i: g7, realIndex: u6, series: t8, prevY: C3, lineYPosition: 0, translationsIndex: p7 }).prevY, "monotoneCubic" === o10.config.stroke.curve && null === t8[g7][0] ? f5.push(null) : f5.push(C3), w4 = C3;
        "rangeArea" === l8 && (A3 = L4 = this.lineHelpers.determineFirstPrevY({ i: g7, realIndex: u6, series: s11, prevY: L4, lineYPosition: 0, translationsIndex: p7 }).prevY, x4.push(null !== f5[0] ? L4 : null));
        var P3 = this._calculatePathsFrom({ type: l8, series: t8, i: g7, realIndex: u6, translationsIndex: p7, prevX: S3, prevY: C3, prevY2: L4 }), M4 = [f5[0]], I4 = [x4[0]], T4 = { type: l8, series: t8, realIndex: u6, translationsIndex: p7, i: g7, x: v5, y: 1, pX: k4, pY: w4, pathsFrom: P3, linePaths: [], areaPaths: [], seriesIndex: a10, lineYPosition: 0, xArrj: b3, yArrj: f5, y2Arrj: x4, seriesRangeEnd: s11 }, z4 = this._iterateOverDataPoints(e3(e3({}, T4), {}, { iterations: "rangeArea" === l8 ? t8[g7].length - 1 : void 0, isRangeStart: true }));
        if ("rangeArea" === l8) {
          for (var X3 = this._calculatePathsFrom({ series: s11, i: g7, realIndex: u6, prevX: S3, prevY: L4 }), E3 = this._iterateOverDataPoints(e3(e3({}, T4), {}, { series: s11, xArrj: [v5], yArrj: M4, y2Arrj: I4, pY: A3, areaPaths: z4.areaPaths, pathsFrom: X3, iterations: s11[g7].length - 1, isRangeStart: false })), Y3 = z4.linePaths.length / 2, F3 = 0; F3 < Y3; F3++)
            z4.linePaths[F3] = E3.linePaths[F3 + Y3] + z4.linePaths[F3];
          z4.linePaths.splice(Y3), z4.pathFromLine = E3.pathFromLine + z4.pathFromLine;
        } else
          z4.pathFromArea += "z";
        this._handlePaths({ type: l8, realIndex: u6, i: g7, paths: z4 }), this.elSeries.add(this.elPointsMain), this.elSeries.add(this.elDataLabelsWrap), d9.push(this.elSeries);
      }
      if (void 0 !== (null === (r13 = o10.config.series[0]) || void 0 === r13 ? void 0 : r13.zIndex) && d9.sort(function(t9, e4) {
        return Number(t9.node.getAttribute("zIndex")) - Number(e4.node.getAttribute("zIndex"));
      }), o10.config.chart.stacked)
        for (var R3 = d9.length - 1; R3 >= 0; R3--)
          h4.add(d9[R3]);
      else
        for (var H4 = 0; H4 < d9.length; H4++)
          h4.add(d9[H4]);
      return h4;
    } }, { key: "_initSerieVariables", value: function(t8, e4, i17) {
      var a10 = this.w, s11 = new m3(this.ctx);
      this.xDivision = a10.globals.gridWidth / (a10.globals.dataPoints - ("on" === a10.config.xaxis.tickPlacement ? 1 : 0)), this.strokeWidth = Array.isArray(a10.config.stroke.width) ? a10.config.stroke.width[i17] : a10.config.stroke.width;
      var r13 = 0;
      this.yRatio.length > 1 && (this.yaxisIndex = a10.globals.seriesYAxisReverseMap[i17], r13 = i17), this.isReversed = a10.config.yaxis[this.yaxisIndex] && a10.config.yaxis[this.yaxisIndex].reversed, this.zeroY = a10.globals.gridHeight - this.baseLineY[r13] - (this.isReversed ? a10.globals.gridHeight : 0) + (this.isReversed ? 2 * this.baseLineY[r13] : 0), this.areaBottomY = this.zeroY, (this.zeroY > a10.globals.gridHeight || "end" === a10.config.plotOptions.area.fillTo) && (this.areaBottomY = a10.globals.gridHeight), this.categoryAxisCorrection = this.xDivision / 2, this.elSeries = s11.group({ class: "apexcharts-series", zIndex: void 0 !== a10.config.series[i17].zIndex ? a10.config.series[i17].zIndex : i17, seriesName: x3.escapeString(a10.globals.seriesNames[i17]) }), this.elPointsMain = s11.group({ class: "apexcharts-series-markers-wrap", "data:realIndex": i17 }), this.elDataLabelsWrap = s11.group({ class: "apexcharts-datalabels", "data:realIndex": i17 });
      var o10 = t8[e4].length === a10.globals.dataPoints;
      this.elSeries.attr({ "data:longestSeries": o10, rel: e4 + 1, "data:realIndex": i17 }), this.appendPathFrom = true;
    } }, { key: "_calculatePathsFrom", value: function(t8) {
      var e4, i17, a10, s11, r13 = t8.type, o10 = t8.series, n11 = t8.i, l8 = t8.realIndex, h4 = t8.translationsIndex, c7 = t8.prevX, d9 = t8.prevY, g7 = t8.prevY2, u6 = this.w, p7 = new m3(this.ctx);
      if (null === o10[n11][0]) {
        for (var f5 = 0; f5 < o10[n11].length; f5++)
          if (null !== o10[n11][f5]) {
            c7 = this.xDivision * f5, d9 = this.zeroY - o10[n11][f5] / this.yRatio[h4], e4 = p7.move(c7, d9), i17 = p7.move(c7, this.areaBottomY);
            break;
          }
      } else
        e4 = p7.move(c7, d9), "rangeArea" === r13 && (e4 = p7.move(c7, g7) + p7.line(c7, d9)), i17 = p7.move(c7, this.areaBottomY) + p7.line(c7, d9);
      if (a10 = p7.move(0, this.zeroY) + p7.line(0, this.zeroY), s11 = p7.move(0, this.zeroY) + p7.line(0, this.zeroY), u6.globals.previousPaths.length > 0) {
        var x4 = this.lineHelpers.checkPreviousPaths({ pathFromLine: a10, pathFromArea: s11, realIndex: l8 });
        a10 = x4.pathFromLine, s11 = x4.pathFromArea;
      }
      return { prevX: c7, prevY: d9, linePath: e4, areaPath: i17, pathFromLine: a10, pathFromArea: s11 };
    } }, { key: "_handlePaths", value: function(t8) {
      var i17 = t8.type, a10 = t8.realIndex, s11 = t8.i, r13 = t8.paths, o10 = this.w, n11 = new m3(this.ctx), l8 = new H3(this.ctx);
      this.prevSeriesY.push(r13.yArrj), o10.globals.seriesXvalues[a10] = r13.xArrj, o10.globals.seriesYvalues[a10] = r13.yArrj;
      var h4 = o10.config.forecastDataPoints;
      if (h4.count > 0 && "rangeArea" !== i17) {
        var c7 = o10.globals.seriesXvalues[a10][o10.globals.seriesXvalues[a10].length - h4.count - 1], d9 = n11.drawRect(c7, 0, o10.globals.gridWidth, o10.globals.gridHeight, 0);
        o10.globals.dom.elForecastMask.appendChild(d9.node);
        var g7 = n11.drawRect(0, 0, c7, o10.globals.gridHeight, 0);
        o10.globals.dom.elNonForecastMask.appendChild(g7.node);
      }
      this.pointsChart || o10.globals.delayedElements.push({ el: this.elPointsMain.node, index: a10 });
      var u6 = { i: s11, realIndex: a10, animationDelay: s11, initialSpeed: o10.config.chart.animations.speed, dataChangeSpeed: o10.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-".concat(i17) };
      if ("area" === i17)
        for (var p7 = l8.fillPath({ seriesNumber: a10 }), f5 = 0; f5 < r13.areaPaths.length; f5++) {
          var x4 = n11.renderPaths(e3(e3({}, u6), {}, { pathFrom: r13.pathFromArea, pathTo: r13.areaPaths[f5], stroke: "none", strokeWidth: 0, strokeLineCap: null, fill: p7 }));
          this.elSeries.add(x4);
        }
      if (o10.config.stroke.show && !this.pointsChart) {
        var b3 = null;
        if ("line" === i17)
          b3 = l8.fillPath({ seriesNumber: a10, i: s11 });
        else if ("solid" === o10.config.stroke.fill.type)
          b3 = o10.globals.stroke.colors[a10];
        else {
          var v5 = o10.config.fill;
          o10.config.fill = o10.config.stroke.fill, b3 = l8.fillPath({ seriesNumber: a10, i: s11 }), o10.config.fill = v5;
        }
        for (var y5 = 0; y5 < r13.linePaths.length; y5++) {
          var w4 = b3;
          "rangeArea" === i17 && (w4 = l8.fillPath({ seriesNumber: a10 }));
          var k4 = e3(e3({}, u6), {}, { pathFrom: r13.pathFromLine, pathTo: r13.linePaths[y5], stroke: b3, strokeWidth: this.strokeWidth, strokeLineCap: o10.config.stroke.lineCap, fill: "rangeArea" === i17 ? w4 : "none" }), A3 = n11.renderPaths(k4);
          if (this.elSeries.add(A3), A3.attr("fill-rule", "evenodd"), h4.count > 0 && "rangeArea" !== i17) {
            var S3 = n11.renderPaths(k4);
            S3.node.setAttribute("stroke-dasharray", h4.dashArray), h4.strokeWidth && S3.node.setAttribute("stroke-width", h4.strokeWidth), this.elSeries.add(S3), S3.attr("clip-path", "url(#forecastMask".concat(o10.globals.cuid, ")")), A3.attr("clip-path", "url(#nonForecastMask".concat(o10.globals.cuid, ")"));
          }
        }
      }
    } }, { key: "_iterateOverDataPoints", value: function(t8) {
      var e4, i17, a10 = this, s11 = t8.type, r13 = t8.series, o10 = t8.iterations, n11 = t8.realIndex, l8 = t8.translationsIndex, h4 = t8.i, c7 = t8.x, d9 = t8.y, g7 = t8.pX, u6 = t8.pY, p7 = t8.pathsFrom, f5 = t8.linePaths, b3 = t8.areaPaths, v5 = t8.seriesIndex, y5 = t8.lineYPosition, w4 = t8.xArrj, k4 = t8.yArrj, A3 = t8.y2Arrj, S3 = t8.isRangeStart, C3 = t8.seriesRangeEnd, L4 = this.w, P3 = new m3(this.ctx), M4 = this.yRatio, I4 = p7.prevY, T4 = p7.linePath, z4 = p7.areaPath, X3 = p7.pathFromLine, E3 = p7.pathFromArea, Y3 = x3.isNumber(L4.globals.minYArr[n11]) ? L4.globals.minYArr[n11] : L4.globals.minY;
      o10 || (o10 = L4.globals.dataPoints > 1 ? L4.globals.dataPoints - 1 : L4.globals.dataPoints);
      var F3 = function(t9, e5) {
        return e5 - t9 / M4[l8] + 2 * (a10.isReversed ? t9 / M4[l8] : 0);
      }, R3 = d9, H4 = L4.config.chart.stacked && !L4.globals.comboCharts || L4.config.chart.stacked && L4.globals.comboCharts && (!this.w.config.chart.stackOnlyBar || "bar" === (null === (e4 = this.w.config.series[n11]) || void 0 === e4 ? void 0 : e4.type) || "column" === (null === (i17 = this.w.config.series[n11]) || void 0 === i17 ? void 0 : i17.type)), D3 = L4.config.stroke.curve;
      Array.isArray(D3) && (D3 = Array.isArray(v5) ? D3[v5[h4]] : D3[h4]);
      for (var O3, N4 = 0, W4 = 0; W4 < o10; W4++) {
        var B3 = void 0 === r13[h4][W4 + 1] || null === r13[h4][W4 + 1];
        if (L4.globals.isXNumeric) {
          var G3 = L4.globals.seriesX[n11][W4 + 1];
          void 0 === L4.globals.seriesX[n11][W4 + 1] && (G3 = L4.globals.seriesX[n11][o10 - 1]), c7 = (G3 - L4.globals.minX) / this.xRatio;
        } else
          c7 += this.xDivision;
        if (H4)
          if (h4 > 0 && L4.globals.collapsedSeries.length < L4.config.series.length - 1) {
            y5 = this.prevSeriesY[function(t9) {
              for (var e5 = t9; e5 > 0; e5--) {
                if (!(L4.globals.collapsedSeriesIndices.indexOf((null == v5 ? void 0 : v5[e5]) || e5) > -1))
                  return e5;
                e5--;
              }
              return 0;
            }(h4 - 1)][W4 + 1];
          } else
            y5 = this.zeroY;
        else
          y5 = this.zeroY;
        B3 ? d9 = F3(Y3, y5) : (d9 = F3(r13[h4][W4 + 1], y5), "rangeArea" === s11 && (R3 = F3(C3[h4][W4 + 1], y5))), w4.push(c7), !B3 || "smooth" !== L4.config.stroke.curve && "monotoneCubic" !== L4.config.stroke.curve ? (k4.push(d9), A3.push(R3)) : (k4.push(null), A3.push(null));
        var V4 = this.lineHelpers.calculatePoints({ series: r13, x: c7, y: d9, realIndex: n11, i: h4, j: W4, prevY: I4 }), j3 = this._createPaths({ type: s11, series: r13, i: h4, realIndex: n11, j: W4, x: c7, y: d9, y2: R3, xArrj: w4, yArrj: k4, y2Arrj: A3, pX: g7, pY: u6, pathState: N4, segmentStartX: O3, linePath: T4, areaPath: z4, linePaths: f5, areaPaths: b3, curve: D3, isRangeStart: S3 });
        b3 = j3.areaPaths, f5 = j3.linePaths, g7 = j3.pX, u6 = j3.pY, N4 = j3.pathState, O3 = j3.segmentStartX, z4 = j3.areaPath, T4 = j3.linePath, !this.appendPathFrom || "monotoneCubic" === D3 && "rangeArea" === s11 || (X3 += P3.line(c7, this.zeroY), E3 += P3.line(c7, this.zeroY)), this.handleNullDataPoints(r13, V4, h4, W4, n11), this._handleMarkersAndLabels({ type: s11, pointsPos: V4, i: h4, j: W4, realIndex: n11, isRangeStart: S3 });
      }
      return { yArrj: k4, xArrj: w4, pathFromArea: E3, areaPaths: b3, pathFromLine: X3, linePaths: f5, linePath: T4, areaPath: z4 };
    } }, { key: "_handleMarkersAndLabels", value: function(t8) {
      var e4 = t8.type, i17 = t8.pointsPos, a10 = t8.isRangeStart, s11 = t8.i, r13 = t8.j, o10 = t8.realIndex, n11 = this.w, l8 = new N3(this.ctx);
      if (this.pointsChart)
        this.scatter.draw(this.elSeries, r13, { realIndex: o10, pointsPos: i17, zRatio: this.zRatio, elParent: this.elPointsMain });
      else {
        n11.globals.series[s11].length > 1 && this.elPointsMain.node.classList.add("apexcharts-element-hidden");
        var h4 = this.markers.plotChartMarkers(i17, o10, r13 + 1);
        null !== h4 && this.elPointsMain.add(h4);
      }
      var c7 = l8.drawDataLabel({ type: e4, isRangeStart: a10, pos: i17, i: o10, j: r13 + 1 });
      null !== c7 && this.elDataLabelsWrap.add(c7);
    } }, { key: "_createPaths", value: function(t8) {
      var e4 = t8.type, i17 = t8.series, a10 = t8.i;
      t8.realIndex;
      var s11 = t8.j, r13 = t8.x, o10 = t8.y, n11 = t8.xArrj, l8 = t8.yArrj, h4 = t8.y2, c7 = t8.y2Arrj, d9 = t8.pX, g7 = t8.pY, u6 = t8.pathState, p7 = t8.segmentStartX, f5 = t8.linePath, x4 = t8.areaPath, b3 = t8.linePaths, v5 = t8.areaPaths, y5 = t8.curve, w4 = t8.isRangeStart;
      this.w;
      var k4, A3 = new m3(this.ctx), S3 = this.areaBottomY, C3 = "rangeArea" === e4, L4 = "rangeArea" === e4 && w4;
      switch (y5) {
        case "monotoneCubic":
          var P3 = w4 ? l8 : c7;
          switch (u6) {
            case 0:
              if (null === P3[s11 + 1])
                break;
              u6 = 1;
            case 1:
              if (!(C3 ? n11.length === i17[a10].length : s11 === i17[a10].length - 2))
                break;
            case 2:
              var M4 = w4 ? n11 : n11.slice().reverse(), I4 = w4 ? P3 : P3.slice().reverse(), T4 = (k4 = I4, M4.map(function(t9, e5) {
                return [t9, k4[e5]];
              }).filter(function(t9) {
                return null !== t9[1];
              })), z4 = T4.length > 1 ? Xt(T4) : T4, X3 = [];
              C3 && (L4 ? v5 = T4 : X3 = v5.reverse());
              var E3 = 0, Y3 = 0;
              if (function(t9, e5) {
                for (var i18 = function(t10) {
                  var e6 = [], i19 = 0;
                  return t10.forEach(function(t11) {
                    null !== t11 ? i19++ : i19 > 0 && (e6.push(i19), i19 = 0);
                  }), i19 > 0 && e6.push(i19), e6;
                }(t9), a11 = [], s12 = 0, r14 = 0; s12 < i18.length; r14 += i18[s12++])
                  a11[s12] = Et(e5, r14, r14 + i18[s12]);
                return a11;
              }(I4, z4).forEach(function(t9) {
                E3++;
                var e5 = function(t10) {
                  for (var e6 = "", i19 = 0; i19 < t10.length; i19++) {
                    var a12 = t10[i19], s12 = a12.length;
                    s12 > 4 ? (e6 += "C".concat(a12[0], ", ").concat(a12[1]), e6 += ", ".concat(a12[2], ", ").concat(a12[3]), e6 += ", ".concat(a12[4], ", ").concat(a12[5])) : s12 > 2 && (e6 += "S".concat(a12[0], ", ").concat(a12[1]), e6 += ", ".concat(a12[2], ", ").concat(a12[3]));
                  }
                  return e6;
                }(t9), i18 = Y3, a11 = (Y3 += t9.length) - 1;
                L4 ? f5 = A3.move(T4[i18][0], T4[i18][1]) + e5 : C3 ? f5 = A3.move(X3[i18][0], X3[i18][1]) + A3.line(T4[i18][0], T4[i18][1]) + e5 + A3.line(X3[a11][0], X3[a11][1]) : (f5 = A3.move(T4[i18][0], T4[i18][1]) + e5, x4 = f5 + A3.line(T4[a11][0], S3) + A3.line(T4[i18][0], S3) + "z", v5.push(x4)), b3.push(f5);
              }), C3 && E3 > 1 && !L4) {
                var F3 = b3.slice(E3).reverse();
                b3.splice(E3), F3.forEach(function(t9) {
                  return b3.push(t9);
                });
              }
              u6 = 0;
          }
          break;
        case "smooth":
          var R3 = 0.35 * (r13 - d9);
          if (null === i17[a10][s11])
            u6 = 0;
          else
            switch (u6) {
              case 0:
                if (p7 = d9, f5 = L4 ? A3.move(d9, c7[s11]) + A3.line(d9, g7) : A3.move(d9, g7), x4 = A3.move(d9, g7), u6 = 1, s11 < i17[a10].length - 2) {
                  var H4 = A3.curve(d9 + R3, g7, r13 - R3, o10, r13, o10);
                  f5 += H4, x4 += H4;
                  break;
                }
              case 1:
                if (null === i17[a10][s11 + 1])
                  f5 += L4 ? A3.line(d9, h4) : A3.move(d9, g7), x4 += A3.line(d9, S3) + A3.line(p7, S3) + "z", b3.push(f5), v5.push(x4), u6 = -1;
                else {
                  var D3 = A3.curve(d9 + R3, g7, r13 - R3, o10, r13, o10);
                  f5 += D3, x4 += D3, s11 >= i17[a10].length - 2 && (L4 && (f5 += A3.curve(r13, o10, r13, o10, r13, h4) + A3.move(r13, h4)), x4 += A3.curve(r13, o10, r13, o10, r13, S3) + A3.line(p7, S3) + "z", b3.push(f5), v5.push(x4), u6 = -1);
                }
            }
          d9 = r13, g7 = o10;
          break;
        default:
          var O3 = function(t9, e5, i18) {
            var a11 = [];
            switch (t9) {
              case "stepline":
                a11 = A3.line(e5, null, "H") + A3.line(null, i18, "V");
                break;
              case "linestep":
                a11 = A3.line(null, i18, "V") + A3.line(e5, null, "H");
                break;
              case "straight":
                a11 = A3.line(e5, i18);
            }
            return a11;
          };
          if (null === i17[a10][s11])
            u6 = 0;
          else
            switch (u6) {
              case 0:
                if (p7 = d9, f5 = L4 ? A3.move(d9, c7[s11]) + A3.line(d9, g7) : A3.move(d9, g7), x4 = A3.move(d9, g7), u6 = 1, s11 < i17[a10].length - 2) {
                  var N4 = O3(y5, r13, o10);
                  f5 += N4, x4 += N4;
                  break;
                }
              case 1:
                if (null === i17[a10][s11 + 1])
                  f5 += L4 ? A3.line(d9, h4) : A3.move(d9, g7), x4 += A3.line(d9, S3) + A3.line(p7, S3) + "z", b3.push(f5), v5.push(x4), u6 = -1;
                else {
                  var W4 = O3(y5, r13, o10);
                  f5 += W4, x4 += W4, s11 >= i17[a10].length - 2 && (L4 && (f5 += A3.line(r13, h4)), x4 += A3.line(r13, S3) + A3.line(p7, S3) + "z", b3.push(f5), v5.push(x4), u6 = -1);
                }
            }
          d9 = r13, g7 = o10;
      }
      return { linePaths: b3, areaPaths: v5, pX: d9, pY: g7, pathState: u6, segmentStartX: p7, linePath: f5, areaPath: x4 };
    } }, { key: "handleNullDataPoints", value: function(t8, e4, i17, a10, s11) {
      var r13 = this.w;
      if (null === t8[i17][a10] && r13.config.markers.showNullDataPoints || 1 === t8[i17].length) {
        var o10 = this.strokeWidth - r13.config.markers.strokeWidth / 2;
        o10 > 0 || (o10 = 0);
        var n11 = this.markers.plotChartMarkers(e4, s11, a10 + 1, o10, true);
        null !== n11 && this.elPointsMain.add(n11);
      }
    } }]), t7;
  }();
  window.TreemapSquared = {}, window.TreemapSquared.generate = function() {
    function t7(e5, i18, a11, s12) {
      this.xoffset = e5, this.yoffset = i18, this.height = s12, this.width = a11, this.shortestEdge = function() {
        return Math.min(this.height, this.width);
      }, this.getCoordinates = function(t8) {
        var e6, i19 = [], a12 = this.xoffset, s13 = this.yoffset, o11 = r13(t8) / this.height, n11 = r13(t8) / this.width;
        if (this.width >= this.height)
          for (e6 = 0; e6 < t8.length; e6++)
            i19.push([a12, s13, a12 + o11, s13 + t8[e6] / o11]), s13 += t8[e6] / o11;
        else
          for (e6 = 0; e6 < t8.length; e6++)
            i19.push([a12, s13, a12 + t8[e6] / n11, s13 + n11]), a12 += t8[e6] / n11;
        return i19;
      }, this.cutArea = function(e6) {
        var i19;
        if (this.width >= this.height) {
          var a12 = e6 / this.height, s13 = this.width - a12;
          i19 = new t7(this.xoffset + a12, this.yoffset, s13, this.height);
        } else {
          var r14 = e6 / this.width, o11 = this.height - r14;
          i19 = new t7(this.xoffset, this.yoffset + r14, this.width, o11);
        }
        return i19;
      };
    }
    function e4(e5, a11, s12, o11, n11) {
      o11 = void 0 === o11 ? 0 : o11, n11 = void 0 === n11 ? 0 : n11;
      var l8 = i17(function(t8, e6) {
        var i18, a12 = [], s13 = e6 / r13(t8);
        for (i18 = 0; i18 < t8.length; i18++)
          a12[i18] = t8[i18] * s13;
        return a12;
      }(e5, a11 * s12), [], new t7(o11, n11, a11, s12), []);
      return function(t8) {
        var e6, i18, a12 = [];
        for (e6 = 0; e6 < t8.length; e6++)
          for (i18 = 0; i18 < t8[e6].length; i18++)
            a12.push(t8[e6][i18]);
        return a12;
      }(l8);
    }
    function i17(t8, e5, s12, o11) {
      var n11, l8, h4;
      if (0 !== t8.length)
        return n11 = s12.shortestEdge(), function(t9, e6, i18) {
          var s13;
          if (0 === t9.length)
            return true;
          (s13 = t9.slice()).push(e6);
          var r14 = a10(t9, i18), o12 = a10(s13, i18);
          return r14 >= o12;
        }(e5, l8 = t8[0], n11) ? (e5.push(l8), i17(t8.slice(1), e5, s12, o11)) : (h4 = s12.cutArea(r13(e5), o11), o11.push(s12.getCoordinates(e5)), i17(t8, [], h4, o11)), o11;
      o11.push(s12.getCoordinates(e5));
    }
    function a10(t8, e5) {
      var i18 = Math.min.apply(Math, t8), a11 = Math.max.apply(Math, t8), s12 = r13(t8);
      return Math.max(Math.pow(e5, 2) * a11 / Math.pow(s12, 2), Math.pow(s12, 2) / (Math.pow(e5, 2) * i18));
    }
    function s11(t8) {
      return t8 && t8.constructor === Array;
    }
    function r13(t8) {
      var e5, i18 = 0;
      for (e5 = 0; e5 < t8.length; e5++)
        i18 += t8[e5];
      return i18;
    }
    function o10(t8) {
      var e5, i18 = 0;
      if (s11(t8[0]))
        for (e5 = 0; e5 < t8.length; e5++)
          i18 += o10(t8[e5]);
      else
        i18 = r13(t8);
      return i18;
    }
    return function t8(i18, a11, r14, n11, l8) {
      n11 = void 0 === n11 ? 0 : n11, l8 = void 0 === l8 ? 0 : l8;
      var h4, c7, d9 = [], g7 = [];
      if (s11(i18[0])) {
        for (c7 = 0; c7 < i18.length; c7++)
          d9[c7] = o10(i18[c7]);
        for (h4 = e4(d9, a11, r14, n11, l8), c7 = 0; c7 < i18.length; c7++)
          g7.push(t8(i18[c7], h4[c7][2] - h4[c7][0], h4[c7][3] - h4[c7][1], h4[c7][0], h4[c7][1]));
      } else
        g7 = e4(i18, a11, r14, n11, l8);
      return g7;
    };
  }();
  var Rt, Ht, Dt = function() {
    function t7(e4, i17) {
      a9(this, t7), this.ctx = e4, this.w = e4.w, this.strokeWidth = this.w.config.stroke.width, this.helpers = new At(e4), this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.labels = [];
    }
    return r12(t7, [{ key: "draw", value: function(t8) {
      var e4 = this, i17 = this.w, a10 = new m3(this.ctx), s11 = new H3(this.ctx), r13 = a10.group({ class: "apexcharts-treemap" });
      if (i17.globals.noData)
        return r13;
      var o10 = [];
      return t8.forEach(function(t9) {
        var e5 = t9.map(function(t10) {
          return Math.abs(t10);
        });
        o10.push(e5);
      }), this.negRange = this.helpers.checkColorRange(), i17.config.series.forEach(function(t9, i18) {
        t9.data.forEach(function(t10) {
          Array.isArray(e4.labels[i18]) || (e4.labels[i18] = []), e4.labels[i18].push(t10.x);
        });
      }), window.TreemapSquared.generate(o10, i17.globals.gridWidth, i17.globals.gridHeight).forEach(function(o11, n11) {
        var l8 = a10.group({ class: "apexcharts-series apexcharts-treemap-series", seriesName: x3.escapeString(i17.globals.seriesNames[n11]), rel: n11 + 1, "data:realIndex": n11 });
        if (i17.config.chart.dropShadow.enabled) {
          var h4 = i17.config.chart.dropShadow;
          new v3(e4.ctx).dropShadow(r13, h4, n11);
        }
        var c7 = a10.group({ class: "apexcharts-data-labels" });
        o11.forEach(function(r14, o12) {
          var h5 = r14[0], c8 = r14[1], d9 = r14[2], g7 = r14[3], u6 = a10.drawRect(h5, c8, d9 - h5, g7 - c8, i17.config.plotOptions.treemap.borderRadius, "#fff", 1, e4.strokeWidth, i17.config.plotOptions.treemap.useFillColorAsStroke ? f5 : i17.globals.stroke.colors[n11]);
          u6.attr({ cx: h5, cy: c8, index: n11, i: n11, j: o12, width: d9 - h5, height: g7 - c8 });
          var p7 = e4.helpers.getShadeColor(i17.config.chart.type, n11, o12, e4.negRange), f5 = p7.color;
          void 0 !== i17.config.series[n11].data[o12] && i17.config.series[n11].data[o12].fillColor && (f5 = i17.config.series[n11].data[o12].fillColor);
          var x4 = s11.fillPath({ color: f5, seriesNumber: n11, dataPointIndex: o12 });
          u6.node.classList.add("apexcharts-treemap-rect"), u6.attr({ fill: x4 }), e4.helpers.addListeners(u6);
          var b3 = { x: h5 + (d9 - h5) / 2, y: c8 + (g7 - c8) / 2, width: 0, height: 0 }, v5 = { x: h5, y: c8, width: d9 - h5, height: g7 - c8 };
          if (i17.config.chart.animations.enabled && !i17.globals.dataChanged) {
            var m4 = 1;
            i17.globals.resized || (m4 = i17.config.chart.animations.speed), e4.animateTreemap(u6, b3, v5, m4);
          }
          if (i17.globals.dataChanged) {
            var y5 = 1;
            e4.dynamicAnim.enabled && i17.globals.shouldAnimate && (y5 = e4.dynamicAnim.speed, i17.globals.previousPaths[n11] && i17.globals.previousPaths[n11][o12] && i17.globals.previousPaths[n11][o12].rect && (b3 = i17.globals.previousPaths[n11][o12].rect), e4.animateTreemap(u6, b3, v5, y5));
          }
          var w4 = e4.getFontSize(r14), k4 = i17.config.dataLabels.formatter(e4.labels[n11][o12], { value: i17.globals.series[n11][o12], seriesIndex: n11, dataPointIndex: o12, w: i17 });
          "truncate" === i17.config.plotOptions.treemap.dataLabels.format && (w4 = parseInt(i17.config.dataLabels.style.fontSize, 10), k4 = e4.truncateLabels(k4, w4, h5, c8, d9, g7));
          var A3 = e4.helpers.calculateDataLabels({ text: k4, x: (h5 + d9) / 2, y: (c8 + g7) / 2 + e4.strokeWidth / 2 + w4 / 3, i: n11, j: o12, colorProps: p7, fontSize: w4, series: t8 });
          i17.config.dataLabels.enabled && A3 && e4.rotateToFitLabel(A3, w4, k4, h5, c8, d9, g7), l8.add(u6), null !== A3 && l8.add(A3);
        }), l8.add(c7), r13.add(l8);
      }), r13;
    } }, { key: "getFontSize", value: function(t8) {
      var e4 = this.w;
      var i17, a10, s11, r13, o10 = function t9(e5) {
        var i18, a11 = 0;
        if (Array.isArray(e5[0]))
          for (i18 = 0; i18 < e5.length; i18++)
            a11 += t9(e5[i18]);
        else
          for (i18 = 0; i18 < e5.length; i18++)
            a11 += e5[i18].length;
        return a11;
      }(this.labels) / function t9(e5) {
        var i18, a11 = 0;
        if (Array.isArray(e5[0]))
          for (i18 = 0; i18 < e5.length; i18++)
            a11 += t9(e5[i18]);
        else
          for (i18 = 0; i18 < e5.length; i18++)
            a11 += 1;
        return a11;
      }(this.labels);
      return i17 = t8[2] - t8[0], a10 = t8[3] - t8[1], s11 = i17 * a10, r13 = Math.pow(s11, 0.5), Math.min(r13 / o10, parseInt(e4.config.dataLabels.style.fontSize, 10));
    } }, { key: "rotateToFitLabel", value: function(t8, e4, i17, a10, s11, r13, o10) {
      var n11 = new m3(this.ctx), l8 = n11.getTextRects(i17, e4);
      if (l8.width + this.w.config.stroke.width + 5 > r13 - a10 && l8.width <= o10 - s11) {
        var h4 = n11.rotateAroundCenter(t8.node);
        t8.node.setAttribute("transform", "rotate(-90 ".concat(h4.x, " ").concat(h4.y, ") translate(").concat(l8.height / 3, ")"));
      }
    } }, { key: "truncateLabels", value: function(t8, e4, i17, a10, s11, r13) {
      var o10 = new m3(this.ctx), n11 = o10.getTextRects(t8, e4).width + this.w.config.stroke.width + 5 > s11 - i17 && r13 - a10 > s11 - i17 ? r13 - a10 : s11 - i17, l8 = o10.getTextBasedOnMaxWidth({ text: t8, maxWidth: n11, fontSize: e4 });
      return t8.length !== l8.length && n11 / e4 < 5 ? "" : l8;
    } }, { key: "animateTreemap", value: function(t8, e4, i17, a10) {
      var s11 = new b2(this.ctx);
      s11.animateRect(t8, { x: e4.x, y: e4.y, width: e4.width, height: e4.height }, { x: i17.x, y: i17.y, width: i17.width, height: i17.height }, a10, function() {
        s11.animationCompleted(t8);
      });
    } }]), t7;
  }(), Ot = 86400, Nt = 10 / Ot, Wt = function() {
    function t7(e4) {
      a9(this, t7), this.ctx = e4, this.w = e4.w, this.timeScaleArray = [], this.utc = this.w.config.xaxis.labels.datetimeUTC;
    }
    return r12(t7, [{ key: "calculateTimeScaleTicks", value: function(t8, i17) {
      var a10 = this, s11 = this.w;
      if (s11.globals.allSeriesCollapsed)
        return s11.globals.labels = [], s11.globals.timescaleLabels = [], [];
      var r13 = new A2(this.ctx), o10 = (i17 - t8) / 864e5;
      this.determineInterval(o10), s11.globals.disableZoomIn = false, s11.globals.disableZoomOut = false, o10 < Nt ? s11.globals.disableZoomIn = true : o10 > 5e4 && (s11.globals.disableZoomOut = true);
      var n11 = r13.getTimeUnitsfromTimestamp(t8, i17, this.utc), l8 = s11.globals.gridWidth / o10, h4 = l8 / 24, c7 = h4 / 60, d9 = c7 / 60, g7 = Math.floor(24 * o10), u6 = Math.floor(1440 * o10), p7 = Math.floor(o10 * Ot), f5 = Math.floor(o10), x4 = Math.floor(o10 / 30), b3 = Math.floor(o10 / 365), v5 = { minMillisecond: n11.minMillisecond, minSecond: n11.minSecond, minMinute: n11.minMinute, minHour: n11.minHour, minDate: n11.minDate, minMonth: n11.minMonth, minYear: n11.minYear }, m4 = { firstVal: v5, currentMillisecond: v5.minMillisecond, currentSecond: v5.minSecond, currentMinute: v5.minMinute, currentHour: v5.minHour, currentMonthDate: v5.minDate, currentDate: v5.minDate, currentMonth: v5.minMonth, currentYear: v5.minYear, daysWidthOnXAxis: l8, hoursWidthOnXAxis: h4, minutesWidthOnXAxis: c7, secondsWidthOnXAxis: d9, numberOfSeconds: p7, numberOfMinutes: u6, numberOfHours: g7, numberOfDays: f5, numberOfMonths: x4, numberOfYears: b3 };
      switch (this.tickInterval) {
        case "years":
          this.generateYearScale(m4);
          break;
        case "months":
        case "half_year":
          this.generateMonthScale(m4);
          break;
        case "months_days":
        case "months_fortnight":
        case "days":
        case "week_days":
          this.generateDayScale(m4);
          break;
        case "hours":
          this.generateHourScale(m4);
          break;
        case "minutes_fives":
        case "minutes":
          this.generateMinuteScale(m4);
          break;
        case "seconds_tens":
        case "seconds_fives":
        case "seconds":
          this.generateSecondScale(m4);
      }
      var y5 = this.timeScaleArray.map(function(t9) {
        var i18 = { position: t9.position, unit: t9.unit, year: t9.year, day: t9.day ? t9.day : 1, hour: t9.hour ? t9.hour : 0, month: t9.month + 1 };
        return "month" === t9.unit ? e3(e3({}, i18), {}, { day: 1, value: t9.value + 1 }) : "day" === t9.unit || "hour" === t9.unit ? e3(e3({}, i18), {}, { value: t9.value }) : "minute" === t9.unit ? e3(e3({}, i18), {}, { value: t9.value, minute: t9.value }) : "second" === t9.unit ? e3(e3({}, i18), {}, { value: t9.value, minute: t9.minute, second: t9.second }) : t9;
      });
      return y5.filter(function(t9) {
        var e4 = 1, i18 = Math.ceil(s11.globals.gridWidth / 120), r14 = t9.value;
        void 0 !== s11.config.xaxis.tickAmount && (i18 = s11.config.xaxis.tickAmount), y5.length > i18 && (e4 = Math.floor(y5.length / i18));
        var o11 = false, n12 = false;
        switch (a10.tickInterval) {
          case "years":
            "year" === t9.unit && (o11 = true);
            break;
          case "half_year":
            e4 = 7, "year" === t9.unit && (o11 = true);
            break;
          case "months":
            e4 = 1, "year" === t9.unit && (o11 = true);
            break;
          case "months_fortnight":
            e4 = 15, "year" !== t9.unit && "month" !== t9.unit || (o11 = true), 30 === r14 && (n12 = true);
            break;
          case "months_days":
            e4 = 10, "month" === t9.unit && (o11 = true), 30 === r14 && (n12 = true);
            break;
          case "week_days":
            e4 = 8, "month" === t9.unit && (o11 = true);
            break;
          case "days":
            e4 = 1, "month" === t9.unit && (o11 = true);
            break;
          case "hours":
            "day" === t9.unit && (o11 = true);
            break;
          case "minutes_fives":
          case "seconds_fives":
            r14 % 5 != 0 && (n12 = true);
            break;
          case "seconds_tens":
            r14 % 10 != 0 && (n12 = true);
        }
        if ("hours" === a10.tickInterval || "minutes_fives" === a10.tickInterval || "seconds_tens" === a10.tickInterval || "seconds_fives" === a10.tickInterval) {
          if (!n12)
            return true;
        } else if ((r14 % e4 == 0 || o11) && !n12)
          return true;
      });
    } }, { key: "recalcDimensionsBasedOnFormat", value: function(t8, e4) {
      var i17 = this.w, a10 = this.formatDates(t8), s11 = this.removeOverlappingTS(a10);
      i17.globals.timescaleLabels = s11.slice(), new ot(this.ctx).plotCoords();
    } }, { key: "determineInterval", value: function(t8) {
      var e4 = 24 * t8, i17 = 60 * e4;
      switch (true) {
        case t8 / 365 > 5:
          this.tickInterval = "years";
          break;
        case t8 > 800:
          this.tickInterval = "half_year";
          break;
        case t8 > 180:
          this.tickInterval = "months";
          break;
        case t8 > 90:
          this.tickInterval = "months_fortnight";
          break;
        case t8 > 60:
          this.tickInterval = "months_days";
          break;
        case t8 > 30:
          this.tickInterval = "week_days";
          break;
        case t8 > 2:
          this.tickInterval = "days";
          break;
        case e4 > 2.4:
          this.tickInterval = "hours";
          break;
        case i17 > 15:
          this.tickInterval = "minutes_fives";
          break;
        case i17 > 5:
          this.tickInterval = "minutes";
          break;
        case i17 > 1:
          this.tickInterval = "seconds_tens";
          break;
        case 60 * i17 > 20:
          this.tickInterval = "seconds_fives";
          break;
        default:
          this.tickInterval = "seconds";
      }
    } }, { key: "generateYearScale", value: function(t8) {
      var e4 = t8.firstVal, i17 = t8.currentMonth, a10 = t8.currentYear, s11 = t8.daysWidthOnXAxis, r13 = t8.numberOfYears, o10 = e4.minYear, n11 = 0, l8 = new A2(this.ctx), h4 = "year";
      if (e4.minDate > 1 || e4.minMonth > 0) {
        var c7 = l8.determineRemainingDaysOfYear(e4.minYear, e4.minMonth, e4.minDate);
        n11 = (l8.determineDaysOfYear(e4.minYear) - c7 + 1) * s11, o10 = e4.minYear + 1, this.timeScaleArray.push({ position: n11, value: o10, unit: h4, year: o10, month: x3.monthMod(i17 + 1) });
      } else
        1 === e4.minDate && 0 === e4.minMonth && this.timeScaleArray.push({ position: n11, value: o10, unit: h4, year: a10, month: x3.monthMod(i17 + 1) });
      for (var d9 = o10, g7 = n11, u6 = 0; u6 < r13; u6++)
        d9++, g7 = l8.determineDaysOfYear(d9 - 1) * s11 + g7, this.timeScaleArray.push({ position: g7, value: d9, unit: h4, year: d9, month: 1 });
    } }, { key: "generateMonthScale", value: function(t8) {
      var e4 = t8.firstVal, i17 = t8.currentMonthDate, a10 = t8.currentMonth, s11 = t8.currentYear, r13 = t8.daysWidthOnXAxis, o10 = t8.numberOfMonths, n11 = a10, l8 = 0, h4 = new A2(this.ctx), c7 = "month", d9 = 0;
      if (e4.minDate > 1) {
        l8 = (h4.determineDaysOfMonths(a10 + 1, e4.minYear) - i17 + 1) * r13, n11 = x3.monthMod(a10 + 1);
        var g7 = s11 + d9, u6 = x3.monthMod(n11), p7 = n11;
        0 === n11 && (c7 = "year", p7 = g7, u6 = 1, g7 += d9 += 1), this.timeScaleArray.push({ position: l8, value: p7, unit: c7, year: g7, month: u6 });
      } else
        this.timeScaleArray.push({ position: l8, value: n11, unit: c7, year: s11, month: x3.monthMod(a10) });
      for (var f5 = n11 + 1, b3 = l8, v5 = 0, m4 = 1; v5 < o10; v5++, m4++) {
        0 === (f5 = x3.monthMod(f5)) ? (c7 = "year", d9 += 1) : c7 = "month";
        var y5 = this._getYear(s11, f5, d9);
        b3 = h4.determineDaysOfMonths(f5, y5) * r13 + b3;
        var w4 = 0 === f5 ? y5 : f5;
        this.timeScaleArray.push({ position: b3, value: w4, unit: c7, year: y5, month: 0 === f5 ? 1 : f5 }), f5++;
      }
    } }, { key: "generateDayScale", value: function(t8) {
      var e4 = t8.firstVal, i17 = t8.currentMonth, a10 = t8.currentYear, s11 = t8.hoursWidthOnXAxis, r13 = t8.numberOfDays, o10 = new A2(this.ctx), n11 = "day", l8 = e4.minDate + 1, h4 = l8, c7 = function(t9, e5, i18) {
        return t9 > o10.determineDaysOfMonths(e5 + 1, i18) ? (h4 = 1, n11 = "month", g7 = e5 += 1, e5) : e5;
      }, d9 = (24 - e4.minHour) * s11, g7 = l8, u6 = c7(h4, i17, a10);
      0 === e4.minHour && 1 === e4.minDate ? (d9 = 0, g7 = x3.monthMod(e4.minMonth), n11 = "month", h4 = e4.minDate) : 1 !== e4.minDate && 0 === e4.minHour && 0 === e4.minMinute && (d9 = 0, l8 = e4.minDate, g7 = l8, u6 = c7(h4 = l8, i17, a10)), this.timeScaleArray.push({ position: d9, value: g7, unit: n11, year: this._getYear(a10, u6, 0), month: x3.monthMod(u6), day: h4 });
      for (var p7 = d9, f5 = 0; f5 < r13; f5++) {
        n11 = "day", u6 = c7(h4 += 1, u6, this._getYear(a10, u6, 0));
        var b3 = this._getYear(a10, u6, 0);
        p7 = 24 * s11 + p7;
        var v5 = 1 === h4 ? x3.monthMod(u6) : h4;
        this.timeScaleArray.push({ position: p7, value: v5, unit: n11, year: b3, month: x3.monthMod(u6), day: v5 });
      }
    } }, { key: "generateHourScale", value: function(t8) {
      var e4 = t8.firstVal, i17 = t8.currentDate, a10 = t8.currentMonth, s11 = t8.currentYear, r13 = t8.minutesWidthOnXAxis, o10 = t8.numberOfHours, n11 = new A2(this.ctx), l8 = "hour", h4 = function(t9, e5) {
        return t9 > n11.determineDaysOfMonths(e5 + 1, s11) && (f5 = 1, e5 += 1), { month: e5, date: f5 };
      }, c7 = function(t9, e5) {
        return t9 > n11.determineDaysOfMonths(e5 + 1, s11) ? e5 += 1 : e5;
      }, d9 = 60 - (e4.minMinute + e4.minSecond / 60), g7 = d9 * r13, u6 = e4.minHour + 1, p7 = u6;
      60 === d9 && (g7 = 0, p7 = u6 = e4.minHour);
      var f5 = i17;
      p7 >= 24 && (p7 = 0, f5 += 1, l8 = "day");
      var b3 = h4(f5, a10).month;
      b3 = c7(f5, b3), this.timeScaleArray.push({ position: g7, value: u6, unit: l8, day: f5, hour: p7, year: s11, month: x3.monthMod(b3) }), p7++;
      for (var v5 = g7, m4 = 0; m4 < o10; m4++) {
        if (l8 = "hour", p7 >= 24)
          p7 = 0, l8 = "day", b3 = h4(f5 += 1, b3).month, b3 = c7(f5, b3);
        var y5 = this._getYear(s11, b3, 0);
        v5 = 60 * r13 + v5;
        var w4 = 0 === p7 ? f5 : p7;
        this.timeScaleArray.push({ position: v5, value: w4, unit: l8, hour: p7, day: f5, year: y5, month: x3.monthMod(b3) }), p7++;
      }
    } }, { key: "generateMinuteScale", value: function(t8) {
      for (var e4 = t8.currentMillisecond, i17 = t8.currentSecond, a10 = t8.currentMinute, s11 = t8.currentHour, r13 = t8.currentDate, o10 = t8.currentMonth, n11 = t8.currentYear, l8 = t8.minutesWidthOnXAxis, h4 = t8.secondsWidthOnXAxis, c7 = t8.numberOfMinutes, d9 = a10 + 1, g7 = r13, u6 = o10, p7 = n11, f5 = s11, b3 = (60 - i17 - e4 / 1e3) * h4, v5 = 0; v5 < c7; v5++)
        d9 >= 60 && (d9 = 0, 24 === (f5 += 1) && (f5 = 0)), this.timeScaleArray.push({ position: b3, value: d9, unit: "minute", hour: f5, minute: d9, day: g7, year: this._getYear(p7, u6, 0), month: x3.monthMod(u6) }), b3 += l8, d9++;
    } }, { key: "generateSecondScale", value: function(t8) {
      for (var e4 = t8.currentMillisecond, i17 = t8.currentSecond, a10 = t8.currentMinute, s11 = t8.currentHour, r13 = t8.currentDate, o10 = t8.currentMonth, n11 = t8.currentYear, l8 = t8.secondsWidthOnXAxis, h4 = t8.numberOfSeconds, c7 = i17 + 1, d9 = a10, g7 = r13, u6 = o10, p7 = n11, f5 = s11, b3 = (1e3 - e4) / 1e3 * l8, v5 = 0; v5 < h4; v5++)
        c7 >= 60 && (c7 = 0, ++d9 >= 60 && (d9 = 0, 24 === ++f5 && (f5 = 0))), this.timeScaleArray.push({ position: b3, value: c7, unit: "second", hour: f5, minute: d9, second: c7, day: g7, year: this._getYear(p7, u6, 0), month: x3.monthMod(u6) }), b3 += l8, c7++;
    } }, { key: "createRawDateString", value: function(t8, e4) {
      var i17 = t8.year;
      return 0 === t8.month && (t8.month = 1), i17 += "-" + ("0" + t8.month.toString()).slice(-2), "day" === t8.unit ? i17 += "day" === t8.unit ? "-" + ("0" + e4).slice(-2) : "-01" : i17 += "-" + ("0" + (t8.day ? t8.day : "1")).slice(-2), "hour" === t8.unit ? i17 += "hour" === t8.unit ? "T" + ("0" + e4).slice(-2) : "T00" : i17 += "T" + ("0" + (t8.hour ? t8.hour : "0")).slice(-2), "minute" === t8.unit ? i17 += ":" + ("0" + e4).slice(-2) : i17 += ":" + (t8.minute ? ("0" + t8.minute).slice(-2) : "00"), "second" === t8.unit ? i17 += ":" + ("0" + e4).slice(-2) : i17 += ":00", this.utc && (i17 += ".000Z"), i17;
    } }, { key: "formatDates", value: function(t8) {
      var e4 = this, i17 = this.w;
      return t8.map(function(t9) {
        var a10 = t9.value.toString(), s11 = new A2(e4.ctx), r13 = e4.createRawDateString(t9, a10), o10 = s11.getDate(s11.parseDate(r13));
        if (e4.utc || (o10 = s11.getDate(s11.parseDateWithTimezone(r13))), void 0 === i17.config.xaxis.labels.format) {
          var n11 = "dd MMM", l8 = i17.config.xaxis.labels.datetimeFormatter;
          "year" === t9.unit && (n11 = l8.year), "month" === t9.unit && (n11 = l8.month), "day" === t9.unit && (n11 = l8.day), "hour" === t9.unit && (n11 = l8.hour), "minute" === t9.unit && (n11 = l8.minute), "second" === t9.unit && (n11 = l8.second), a10 = s11.formatDate(o10, n11);
        } else
          a10 = s11.formatDate(o10, i17.config.xaxis.labels.format);
        return { dateString: r13, position: t9.position, value: a10, unit: t9.unit, year: t9.year, month: t9.month };
      });
    } }, { key: "removeOverlappingTS", value: function(t8) {
      var e4, i17 = this, a10 = new m3(this.ctx), s11 = false;
      t8.length > 0 && t8[0].value && t8.every(function(e5) {
        return e5.value.length === t8[0].value.length;
      }) && (s11 = true, e4 = a10.getTextRects(t8[0].value).width);
      var r13 = 0, o10 = t8.map(function(o11, n11) {
        if (n11 > 0 && i17.w.config.xaxis.labels.hideOverlappingLabels) {
          var l8 = s11 ? e4 : a10.getTextRects(t8[r13].value).width, h4 = t8[r13].position;
          return o11.position > h4 + l8 + 10 ? (r13 = n11, o11) : null;
        }
        return o11;
      });
      return o10 = o10.filter(function(t9) {
        return null !== t9;
      });
    } }, { key: "_getYear", value: function(t8, e4, i17) {
      return t8 + Math.floor(e4 / 12) + i17;
    } }]), t7;
  }(), Bt = function() {
    function t7(e4, i17) {
      a9(this, t7), this.ctx = i17, this.w = i17.w, this.el = e4;
    }
    return r12(t7, [{ key: "setupElements", value: function() {
      var t8 = this.w.globals, e4 = this.w.config, i17 = e4.chart.type;
      t8.axisCharts = ["line", "area", "bar", "rangeBar", "rangeArea", "candlestick", "boxPlot", "scatter", "bubble", "radar", "heatmap", "treemap"].indexOf(i17) > -1, t8.xyCharts = ["line", "area", "bar", "rangeBar", "rangeArea", "candlestick", "boxPlot", "scatter", "bubble"].indexOf(i17) > -1, t8.isBarHorizontal = ("bar" === e4.chart.type || "rangeBar" === e4.chart.type || "boxPlot" === e4.chart.type) && e4.plotOptions.bar.horizontal, t8.chartClass = ".apexcharts" + t8.chartID, t8.dom.baseEl = this.el, t8.dom.elWrap = document.createElement("div"), m3.setAttrs(t8.dom.elWrap, { id: t8.chartClass.substring(1), class: "apexcharts-canvas " + t8.chartClass.substring(1) }), this.el.appendChild(t8.dom.elWrap), t8.dom.Paper = new window.SVG.Doc(t8.dom.elWrap), t8.dom.Paper.attr({ class: "apexcharts-svg", "xmlns:data": "ApexChartsNS", transform: "translate(".concat(e4.chart.offsetX, ", ").concat(e4.chart.offsetY, ")") }), t8.dom.Paper.node.style.background = "dark" !== e4.theme.mode || e4.chart.background ? "light" !== e4.theme.mode || e4.chart.background ? e4.chart.background : "#fff" : "#424242", this.setSVGDimensions(), t8.dom.elLegendForeign = document.createElementNS(t8.SVGNS, "foreignObject"), m3.setAttrs(t8.dom.elLegendForeign, { x: 0, y: 0, width: t8.svgWidth, height: t8.svgHeight }), t8.dom.elLegendWrap = document.createElement("div"), t8.dom.elLegendWrap.classList.add("apexcharts-legend"), t8.dom.elLegendWrap.setAttribute("xmlns", "http://www.w3.org/1999/xhtml"), t8.dom.elLegendForeign.appendChild(t8.dom.elLegendWrap), t8.dom.Paper.node.appendChild(t8.dom.elLegendForeign), t8.dom.elGraphical = t8.dom.Paper.group().attr({ class: "apexcharts-inner apexcharts-graphical" }), t8.dom.elDefs = t8.dom.Paper.defs(), t8.dom.Paper.add(t8.dom.elGraphical), t8.dom.elGraphical.add(t8.dom.elDefs);
    } }, { key: "plotChartType", value: function(t8, e4) {
      var i17 = this.w, a10 = i17.config, s11 = i17.globals, r13 = { series: [], i: [] }, o10 = { series: [], i: [] }, n11 = { series: [], i: [] }, l8 = { series: [], i: [] }, h4 = { series: [], i: [] }, c7 = { series: [], i: [] }, d9 = { series: [], i: [] }, g7 = { series: [], i: [] }, p7 = { series: [], seriesRangeEnd: [], i: [] }, f5 = void 0 !== a10.chart.type ? a10.chart.type : "line", x4 = null, b3 = 0;
      s11.series.forEach(function(e5, a11) {
        var u6 = t8[a11].type || f5;
        switch (u6) {
          case "column":
          case "bar":
            h4.series.push(e5), h4.i.push(a11), i17.globals.columnSeries = h4;
            break;
          case "area":
            o10.series.push(e5), o10.i.push(a11);
            break;
          case "line":
            r13.series.push(e5), r13.i.push(a11);
            break;
          case "scatter":
            n11.series.push(e5), n11.i.push(a11);
            break;
          case "bubble":
            l8.series.push(e5), l8.i.push(a11);
            break;
          case "candlestick":
            c7.series.push(e5), c7.i.push(a11);
            break;
          case "boxPlot":
            d9.series.push(e5), d9.i.push(a11);
            break;
          case "rangeBar":
            g7.series.push(e5), g7.i.push(a11);
            break;
          case "rangeArea":
            p7.series.push(s11.seriesRangeStart[a11]), p7.seriesRangeEnd.push(s11.seriesRangeEnd[a11]), p7.i.push(a11);
            break;
          case "heatmap":
          case "treemap":
          case "pie":
          case "donut":
          case "polarArea":
          case "radialBar":
          case "radar":
            x4 = u6;
            break;
          default:
            console.warn("You have specified an unrecognized series type (", u6, ").");
        }
        f5 !== u6 && "scatter" !== u6 && b3++;
      }), b3 > 0 && (null !== x4 && console.warn("Chart or series type ", x4, " can not appear with other chart or series types."), h4.series.length > 0 && a10.plotOptions.bar.horizontal && (b3 -= h4.length, h4 = { series: [], i: [] }, i17.globals.columnSeries = { series: [], i: [] }, console.warn("Horizontal bars are not supported in a mixed/combo chart. Please turn off `plotOptions.bar.horizontal`"))), s11.comboCharts || (s11.comboCharts = b3 > 0);
      var v5 = new Ft(this.ctx, e4), m4 = new kt(this.ctx, e4);
      this.ctx.pie = new Lt(this.ctx);
      var w4 = new Mt(this.ctx);
      this.ctx.rangeBar = new It(this.ctx, e4);
      var k4 = new Pt(this.ctx), A3 = [];
      if (s11.comboCharts) {
        var S3, C3, L4 = new y4(this.ctx);
        if (o10.series.length > 0)
          (S3 = A3).push.apply(S3, u5(L4.drawSeriesByGroup(o10, s11.areaGroups, "area", v5)));
        if (h4.series.length > 0)
          if (i17.config.chart.stacked) {
            var P3 = new wt(this.ctx, e4);
            A3.push(P3.draw(h4.series, h4.i));
          } else
            this.ctx.bar = new yt(this.ctx, e4), A3.push(this.ctx.bar.draw(h4.series, h4.i));
        if (p7.series.length > 0 && A3.push(v5.draw(p7.series, "rangeArea", p7.i, p7.seriesRangeEnd)), r13.series.length > 0)
          (C3 = A3).push.apply(C3, u5(L4.drawSeriesByGroup(r13, s11.lineGroups, "line", v5)));
        if (c7.series.length > 0 && A3.push(m4.draw(c7.series, "candlestick", c7.i)), d9.series.length > 0 && A3.push(m4.draw(d9.series, "boxPlot", d9.i)), g7.series.length > 0 && A3.push(this.ctx.rangeBar.draw(g7.series, g7.i)), n11.series.length > 0) {
          var M4 = new Ft(this.ctx, e4, true);
          A3.push(M4.draw(n11.series, "scatter", n11.i));
        }
        if (l8.series.length > 0) {
          var I4 = new Ft(this.ctx, e4, true);
          A3.push(I4.draw(l8.series, "bubble", l8.i));
        }
      } else
        switch (a10.chart.type) {
          case "line":
            A3 = v5.draw(s11.series, "line");
            break;
          case "area":
            A3 = v5.draw(s11.series, "area");
            break;
          case "bar":
            if (a10.chart.stacked)
              A3 = new wt(this.ctx, e4).draw(s11.series);
            else
              this.ctx.bar = new yt(this.ctx, e4), A3 = this.ctx.bar.draw(s11.series);
            break;
          case "candlestick":
            A3 = new kt(this.ctx, e4).draw(s11.series, "candlestick");
            break;
          case "boxPlot":
            A3 = new kt(this.ctx, e4).draw(s11.series, a10.chart.type);
            break;
          case "rangeBar":
            A3 = this.ctx.rangeBar.draw(s11.series);
            break;
          case "rangeArea":
            A3 = v5.draw(s11.seriesRangeStart, "rangeArea", void 0, s11.seriesRangeEnd);
            break;
          case "heatmap":
            A3 = new St(this.ctx, e4).draw(s11.series);
            break;
          case "treemap":
            A3 = new Dt(this.ctx, e4).draw(s11.series);
            break;
          case "pie":
          case "donut":
          case "polarArea":
            A3 = this.ctx.pie.draw(s11.series);
            break;
          case "radialBar":
            A3 = w4.draw(s11.series);
            break;
          case "radar":
            A3 = k4.draw(s11.series);
            break;
          default:
            A3 = v5.draw(s11.series);
        }
      return A3;
    } }, { key: "setSVGDimensions", value: function() {
      var t8 = this.w.globals, e4 = this.w.config;
      e4.chart.width || (e4.chart.width = "100%"), e4.chart.height || (e4.chart.height = "auto"), t8.svgWidth = e4.chart.width, t8.svgHeight = e4.chart.height;
      var i17 = x3.getDimensions(this.el), a10 = e4.chart.width.toString().split(/[0-9]+/g).pop();
      "%" === a10 ? x3.isNumber(i17[0]) && (0 === i17[0].width && (i17 = x3.getDimensions(this.el.parentNode)), t8.svgWidth = i17[0] * parseInt(e4.chart.width, 10) / 100) : "px" !== a10 && "" !== a10 || (t8.svgWidth = parseInt(e4.chart.width, 10));
      var s11 = String(e4.chart.height).toString().split(/[0-9]+/g).pop();
      if ("auto" !== t8.svgHeight && "" !== t8.svgHeight)
        if ("%" === s11) {
          var r13 = x3.getDimensions(this.el.parentNode);
          t8.svgHeight = r13[1] * parseInt(e4.chart.height, 10) / 100;
        } else
          t8.svgHeight = parseInt(e4.chart.height, 10);
      else
        t8.axisCharts ? t8.svgHeight = t8.svgWidth / 1.61 : t8.svgHeight = t8.svgWidth / 1.2;
      if (t8.svgWidth < 0 && (t8.svgWidth = 0), t8.svgHeight < 0 && (t8.svgHeight = 0), m3.setAttrs(t8.dom.Paper.node, { width: t8.svgWidth, height: t8.svgHeight }), "%" !== s11) {
        var o10 = e4.chart.sparkline.enabled ? 0 : t8.axisCharts ? e4.chart.parentHeightOffset : 0;
        t8.dom.Paper.node.parentNode.parentNode.style.minHeight = t8.svgHeight + o10 + "px";
      }
      t8.dom.elWrap.style.width = t8.svgWidth + "px", t8.dom.elWrap.style.height = t8.svgHeight + "px";
    } }, { key: "shiftGraphPosition", value: function() {
      var t8 = this.w.globals, e4 = t8.translateY, i17 = { transform: "translate(" + t8.translateX + ", " + e4 + ")" };
      m3.setAttrs(t8.dom.elGraphical.node, i17);
    } }, { key: "resizeNonAxisCharts", value: function() {
      var t8 = this.w, e4 = t8.globals, i17 = 0, a10 = t8.config.chart.sparkline.enabled ? 1 : 15;
      a10 += t8.config.grid.padding.bottom, "top" !== t8.config.legend.position && "bottom" !== t8.config.legend.position || !t8.config.legend.show || t8.config.legend.floating || (i17 = new lt(this.ctx).legendHelpers.getLegendDimensions().clwh + 10);
      var s11 = t8.globals.dom.baseEl.querySelector(".apexcharts-radialbar, .apexcharts-pie"), r13 = 2.05 * t8.globals.radialSize;
      if (s11 && !t8.config.chart.sparkline.enabled && 0 !== t8.config.plotOptions.radialBar.startAngle) {
        var o10 = x3.getBoundingClientRect(s11);
        r13 = o10.bottom;
        var n11 = o10.bottom - o10.top;
        r13 = Math.max(2.05 * t8.globals.radialSize, n11);
      }
      var l8 = r13 + e4.translateY + i17 + a10;
      e4.dom.elLegendForeign && e4.dom.elLegendForeign.setAttribute("height", l8), t8.config.chart.height && String(t8.config.chart.height).indexOf("%") > 0 || (e4.dom.elWrap.style.height = l8 + "px", m3.setAttrs(e4.dom.Paper.node, { height: l8 }), e4.dom.Paper.node.parentNode.parentNode.style.minHeight = l8 + "px");
    } }, { key: "coreCalculations", value: function() {
      new U3(this.ctx).init();
    } }, { key: "resetGlobals", value: function() {
      var t8 = this, e4 = function() {
        return t8.w.config.series.map(function(t9) {
          return [];
        });
      }, i17 = new F2(), a10 = this.w.globals;
      i17.initGlobalVars(a10), a10.seriesXvalues = e4(), a10.seriesYvalues = e4();
    } }, { key: "isMultipleY", value: function() {
      if (this.w.config.yaxis.constructor === Array && this.w.config.yaxis.length > 1)
        return this.w.globals.isMultipleYAxis = true, true;
    } }, { key: "xySettings", value: function() {
      var t8 = null, e4 = this.w;
      if (e4.globals.axisCharts) {
        if ("back" === e4.config.xaxis.crosshairs.position)
          new Q2(this.ctx).drawXCrosshairs();
        if ("back" === e4.config.yaxis[0].crosshairs.position)
          new Q2(this.ctx).drawYCrosshairs();
        if ("datetime" === e4.config.xaxis.type && void 0 === e4.config.xaxis.labels.formatter) {
          this.ctx.timeScale = new Wt(this.ctx);
          var i17 = [];
          isFinite(e4.globals.minX) && isFinite(e4.globals.maxX) && !e4.globals.isBarHorizontal ? i17 = this.ctx.timeScale.calculateTimeScaleTicks(e4.globals.minX, e4.globals.maxX) : e4.globals.isBarHorizontal && (i17 = this.ctx.timeScale.calculateTimeScaleTicks(e4.globals.minY, e4.globals.maxY)), this.ctx.timeScale.recalcDimensionsBasedOnFormat(i17);
        }
        t8 = new y4(this.ctx).getCalculatedRatios();
      }
      return t8;
    } }, { key: "updateSourceChart", value: function(t8) {
      this.ctx.w.globals.selection = void 0, this.ctx.updateHelpers._updateOptions({ chart: { selection: { xaxis: { min: t8.w.globals.minX, max: t8.w.globals.maxX } } } }, false, false);
    } }, { key: "setupBrushHandler", value: function() {
      var t8 = this, e4 = this.w;
      if (e4.config.chart.brush.enabled && "function" != typeof e4.config.chart.events.selection) {
        var i17 = Array.isArray(e4.config.chart.brush.targets) ? e4.config.chart.brush.targets : [e4.config.chart.brush.target];
        i17.forEach(function(e5) {
          var i18 = ApexCharts.getChartByID(e5);
          i18.w.globals.brushSource = t8.ctx, "function" != typeof i18.w.config.chart.events.zoomed && (i18.w.config.chart.events.zoomed = function() {
            t8.updateSourceChart(i18);
          }), "function" != typeof i18.w.config.chart.events.scrolled && (i18.w.config.chart.events.scrolled = function() {
            t8.updateSourceChart(i18);
          });
        }), e4.config.chart.events.selection = function(t9, e5) {
          i17.forEach(function(t10) {
            ApexCharts.getChartByID(t10).ctx.updateHelpers._updateOptions({ xaxis: { min: e5.xaxis.min, max: e5.xaxis.max } }, false, false, false, false);
          });
        };
      }
    } }]), t7;
  }(), Gt = function() {
    function t7(e4) {
      a9(this, t7), this.ctx = e4, this.w = e4.w;
    }
    return r12(t7, [{ key: "_updateOptions", value: function(t8) {
      var e4 = this, a10 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], s11 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], r13 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3], o10 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
      return new Promise(function(n11) {
        var l8 = [e4.ctx];
        r13 && (l8 = e4.ctx.getSyncedCharts()), e4.ctx.w.globals.isExecCalled && (l8 = [e4.ctx], e4.ctx.w.globals.isExecCalled = false), l8.forEach(function(r14, h4) {
          var c7 = r14.w;
          if (c7.globals.shouldAnimate = s11, a10 || (c7.globals.resized = true, c7.globals.dataChanged = true, s11 && r14.series.getPreviousPaths()), t8 && "object" === i16(t8) && (r14.config = new Y2(t8), t8 = y4.extendArrayProps(r14.config, t8, c7), r14.w.globals.chartID !== e4.ctx.w.globals.chartID && delete t8.series, c7.config = x3.extend(c7.config, t8), o10 && (c7.globals.lastXAxis = t8.xaxis ? x3.clone(t8.xaxis) : [], c7.globals.lastYAxis = t8.yaxis ? x3.clone(t8.yaxis) : [], c7.globals.initialConfig = x3.extend({}, c7.config), c7.globals.initialSeries = x3.clone(c7.config.series), t8.series))) {
            for (var d9 = 0; d9 < c7.globals.collapsedSeriesIndices.length; d9++) {
              var g7 = c7.config.series[c7.globals.collapsedSeriesIndices[d9]];
              c7.globals.collapsedSeries[d9].data = c7.globals.axisCharts ? g7.data.slice() : g7;
            }
            for (var u6 = 0; u6 < c7.globals.ancillaryCollapsedSeriesIndices.length; u6++) {
              var p7 = c7.config.series[c7.globals.ancillaryCollapsedSeriesIndices[u6]];
              c7.globals.ancillaryCollapsedSeries[u6].data = c7.globals.axisCharts ? p7.data.slice() : p7;
            }
            r14.series.emptyCollapsedSeries(c7.config.series);
          }
          return r14.update(t8).then(function() {
            h4 === l8.length - 1 && n11(r14);
          });
        });
      });
    } }, { key: "_updateSeries", value: function(t8, e4) {
      var i17 = this, a10 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
      return new Promise(function(s11) {
        var r13, o10 = i17.w;
        return o10.globals.shouldAnimate = e4, o10.globals.dataChanged = true, e4 && i17.ctx.series.getPreviousPaths(), o10.globals.axisCharts ? (0 === (r13 = t8.map(function(t9, e5) {
          return i17._extendSeries(t9, e5);
        })).length && (r13 = [{ data: [] }]), o10.config.series = r13) : o10.config.series = t8.slice(), a10 && (o10.globals.initialConfig.series = x3.clone(o10.config.series), o10.globals.initialSeries = x3.clone(o10.config.series)), i17.ctx.update().then(function() {
          s11(i17.ctx);
        });
      });
    } }, { key: "_extendSeries", value: function(t8, i17) {
      var a10 = this.w, s11 = a10.config.series[i17];
      return e3(e3({}, a10.config.series[i17]), {}, { name: t8.name ? t8.name : null == s11 ? void 0 : s11.name, color: t8.color ? t8.color : null == s11 ? void 0 : s11.color, type: t8.type ? t8.type : null == s11 ? void 0 : s11.type, group: t8.group ? t8.group : null == s11 ? void 0 : s11.group, data: t8.data ? t8.data : null == s11 ? void 0 : s11.data, zIndex: void 0 !== t8.zIndex ? t8.zIndex : i17 });
    } }, { key: "toggleDataPointSelection", value: function(t8, e4) {
      var i17 = this.w, a10 = null, s11 = ".apexcharts-series[data\\:realIndex='".concat(t8, "']");
      return i17.globals.axisCharts ? a10 = i17.globals.dom.Paper.select("".concat(s11, " path[j='").concat(e4, "'], ").concat(s11, " circle[j='").concat(e4, "'], ").concat(s11, " rect[j='").concat(e4, "']")).members[0] : void 0 === e4 && (a10 = i17.globals.dom.Paper.select("".concat(s11, " path[j='").concat(t8, "']")).members[0], "pie" !== i17.config.chart.type && "polarArea" !== i17.config.chart.type && "donut" !== i17.config.chart.type || this.ctx.pie.pieClicked(t8)), a10 ? (new m3(this.ctx).pathMouseDown(a10, null), a10.node ? a10.node : null) : (console.warn("toggleDataPointSelection: Element not found"), null);
    } }, { key: "forceXAxisUpdate", value: function(t8) {
      var e4 = this.w;
      if (["min", "max"].forEach(function(i18) {
        void 0 !== t8.xaxis[i18] && (e4.config.xaxis[i18] = t8.xaxis[i18], e4.globals.lastXAxis[i18] = t8.xaxis[i18]);
      }), t8.xaxis.categories && t8.xaxis.categories.length && (e4.config.xaxis.categories = t8.xaxis.categories), e4.config.xaxis.convertedCatToNumeric) {
        var i17 = new E2(t8);
        t8 = i17.convertCatToNumericXaxis(t8, this.ctx);
      }
      return t8;
    } }, { key: "forceYAxisUpdate", value: function(t8) {
      return t8.chart && t8.chart.stacked && "100%" === t8.chart.stackType && (Array.isArray(t8.yaxis) ? t8.yaxis.forEach(function(e4, i17) {
        t8.yaxis[i17].min = 0, t8.yaxis[i17].max = 100;
      }) : (t8.yaxis.min = 0, t8.yaxis.max = 100)), t8;
    } }, { key: "revertDefaultAxisMinMax", value: function(t8) {
      var e4 = this, i17 = this.w, a10 = i17.globals.lastXAxis, s11 = i17.globals.lastYAxis;
      t8 && t8.xaxis && (a10 = t8.xaxis), t8 && t8.yaxis && (s11 = t8.yaxis), i17.config.xaxis.min = a10.min, i17.config.xaxis.max = a10.max;
      var r13 = function(t9) {
        void 0 !== s11[t9] && (i17.config.yaxis[t9].min = s11[t9].min, i17.config.yaxis[t9].max = s11[t9].max);
      };
      i17.config.yaxis.map(function(t9, a11) {
        i17.globals.zoomed || void 0 !== s11[a11] ? r13(a11) : void 0 !== e4.ctx.opts.yaxis[a11] && (t9.min = e4.ctx.opts.yaxis[a11].min, t9.max = e4.ctx.opts.yaxis[a11].max);
      });
    } }]), t7;
  }();
  Rt = "undefined" != typeof window ? window : void 0, Ht = function(t7, e4) {
    var a10 = (void 0 !== this ? this : t7).SVG = function(t8) {
      if (a10.supported)
        return t8 = new a10.Doc(t8), a10.parser.draw || a10.prepare(), t8;
    };
    if (a10.ns = "http://www.w3.org/2000/svg", a10.xmlns = "http://www.w3.org/2000/xmlns/", a10.xlink = "http://www.w3.org/1999/xlink", a10.svgjs = "http://svgjs.dev", a10.supported = true, !a10.supported)
      return false;
    a10.did = 1e3, a10.eid = function(t8) {
      return "Svgjs" + d9(t8) + a10.did++;
    }, a10.create = function(t8) {
      var i17 = e4.createElementNS(this.ns, t8);
      return i17.setAttribute("id", this.eid(t8)), i17;
    }, a10.extend = function() {
      var t8, e5;
      e5 = (t8 = [].slice.call(arguments)).pop();
      for (var i17 = t8.length - 1; i17 >= 0; i17--)
        if (t8[i17])
          for (var s12 in e5)
            t8[i17].prototype[s12] = e5[s12];
      a10.Set && a10.Set.inherit && a10.Set.inherit();
    }, a10.invent = function(t8) {
      var e5 = "function" == typeof t8.create ? t8.create : function() {
        this.constructor.call(this, a10.create(t8.create));
      };
      return t8.inherit && (e5.prototype = new t8.inherit()), t8.extend && a10.extend(e5, t8.extend), t8.construct && a10.extend(t8.parent || a10.Container, t8.construct), e5;
    }, a10.adopt = function(e5) {
      return e5 ? e5.instance ? e5.instance : ((i17 = "svg" == e5.nodeName ? e5.parentNode instanceof t7.SVGElement ? new a10.Nested() : new a10.Doc() : "linearGradient" == e5.nodeName ? new a10.Gradient("linear") : "radialGradient" == e5.nodeName ? new a10.Gradient("radial") : a10[d9(e5.nodeName)] ? new a10[d9(e5.nodeName)]() : new a10.Element(e5)).type = e5.nodeName, i17.node = e5, e5.instance = i17, i17 instanceof a10.Doc && i17.namespace().defs(), i17.setData(JSON.parse(e5.getAttribute("svgjs:data")) || {}), i17) : null;
      var i17;
    }, a10.prepare = function() {
      var t8 = e4.getElementsByTagName("body")[0], i17 = (t8 ? new a10.Doc(t8) : a10.adopt(e4.documentElement).nested()).size(2, 0);
      a10.parser = { body: t8 || e4.documentElement, draw: i17.style("opacity:0;position:absolute;left:-100%;top:-100%;overflow:hidden").node, poly: i17.polyline().node, path: i17.path().node, native: a10.create("svg") };
    }, a10.parser = { native: a10.create("svg") }, e4.addEventListener("DOMContentLoaded", function() {
      a10.parser.draw || a10.prepare();
    }, false), a10.regex = { numberAndUnit: /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i, hex: /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i, rgb: /rgb\((\d+),(\d+),(\d+)\)/, reference: /#([a-z0-9\-_]+)/i, transforms: /\)\s*,?\s*/, whitespace: /\s/g, isHex: /^#[a-f0-9]{3,6}$/i, isRgb: /^rgb\(/, isCss: /[^:]+:[^;]+;?/, isBlank: /^(\s+)?$/, isNumber: /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, isPercent: /^-?[\d\.]+%$/, isImage: /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i, delimiter: /[\s,]+/, hyphen: /([^e])\-/gi, pathLetters: /[MLHVCSQTAZ]/gi, isPathLetter: /[MLHVCSQTAZ]/i, numbersWithDots: /((\d?\.\d+(?:e[+-]?\d+)?)((?:\.\d+(?:e[+-]?\d+)?)+))+/gi, dots: /\./g }, a10.utils = { map: function(t8, e5) {
      for (var i17 = t8.length, a11 = [], s12 = 0; s12 < i17; s12++)
        a11.push(e5(t8[s12]));
      return a11;
    }, filter: function(t8, e5) {
      for (var i17 = t8.length, a11 = [], s12 = 0; s12 < i17; s12++)
        e5(t8[s12]) && a11.push(t8[s12]);
      return a11;
    }, filterSVGElements: function(e5) {
      return this.filter(e5, function(e6) {
        return e6 instanceof t7.SVGElement;
      });
    } }, a10.defaults = { attrs: { "fill-opacity": 1, "stroke-opacity": 1, "stroke-width": 0, "stroke-linejoin": "miter", "stroke-linecap": "butt", fill: "#000000", stroke: "#000000", opacity: 1, x: 0, y: 0, cx: 0, cy: 0, width: 0, height: 0, r: 0, rx: 0, ry: 0, offset: 0, "stop-opacity": 1, "stop-color": "#000000", "font-size": 16, "font-family": "Helvetica, Arial, sans-serif", "text-anchor": "start" } }, a10.Color = function(t8) {
      var e5, s12;
      this.r = 0, this.g = 0, this.b = 0, t8 && ("string" == typeof t8 ? a10.regex.isRgb.test(t8) ? (e5 = a10.regex.rgb.exec(t8.replace(a10.regex.whitespace, "")), this.r = parseInt(e5[1]), this.g = parseInt(e5[2]), this.b = parseInt(e5[3])) : a10.regex.isHex.test(t8) && (e5 = a10.regex.hex.exec(4 == (s12 = t8).length ? ["#", s12.substring(1, 2), s12.substring(1, 2), s12.substring(2, 3), s12.substring(2, 3), s12.substring(3, 4), s12.substring(3, 4)].join("") : s12), this.r = parseInt(e5[1], 16), this.g = parseInt(e5[2], 16), this.b = parseInt(e5[3], 16)) : "object" === i16(t8) && (this.r = t8.r, this.g = t8.g, this.b = t8.b));
    }, a10.extend(a10.Color, { toString: function() {
      return this.toHex();
    }, toHex: function() {
      return "#" + g7(this.r) + g7(this.g) + g7(this.b);
    }, toRgb: function() {
      return "rgb(" + [this.r, this.g, this.b].join() + ")";
    }, brightness: function() {
      return this.r / 255 * 0.3 + this.g / 255 * 0.59 + this.b / 255 * 0.11;
    }, morph: function(t8) {
      return this.destination = new a10.Color(t8), this;
    }, at: function(t8) {
      return this.destination ? (t8 = t8 < 0 ? 0 : t8 > 1 ? 1 : t8, new a10.Color({ r: ~~(this.r + (this.destination.r - this.r) * t8), g: ~~(this.g + (this.destination.g - this.g) * t8), b: ~~(this.b + (this.destination.b - this.b) * t8) })) : this;
    } }), a10.Color.test = function(t8) {
      return t8 += "", a10.regex.isHex.test(t8) || a10.regex.isRgb.test(t8);
    }, a10.Color.isRgb = function(t8) {
      return t8 && "number" == typeof t8.r && "number" == typeof t8.g && "number" == typeof t8.b;
    }, a10.Color.isColor = function(t8) {
      return a10.Color.isRgb(t8) || a10.Color.test(t8);
    }, a10.Array = function(t8, e5) {
      0 == (t8 = (t8 || []).valueOf()).length && e5 && (t8 = e5.valueOf()), this.value = this.parse(t8);
    }, a10.extend(a10.Array, { toString: function() {
      return this.value.join(" ");
    }, valueOf: function() {
      return this.value;
    }, parse: function(t8) {
      return t8 = t8.valueOf(), Array.isArray(t8) ? t8 : this.split(t8);
    } }), a10.PointArray = function(t8, e5) {
      a10.Array.call(this, t8, e5 || [[0, 0]]);
    }, a10.PointArray.prototype = new a10.Array(), a10.PointArray.prototype.constructor = a10.PointArray;
    for (var s11 = { M: function(t8, e5, i17) {
      return e5.x = i17.x = t8[0], e5.y = i17.y = t8[1], ["M", e5.x, e5.y];
    }, L: function(t8, e5) {
      return e5.x = t8[0], e5.y = t8[1], ["L", t8[0], t8[1]];
    }, H: function(t8, e5) {
      return e5.x = t8[0], ["H", t8[0]];
    }, V: function(t8, e5) {
      return e5.y = t8[0], ["V", t8[0]];
    }, C: function(t8, e5) {
      return e5.x = t8[4], e5.y = t8[5], ["C", t8[0], t8[1], t8[2], t8[3], t8[4], t8[5]];
    }, Q: function(t8, e5) {
      return e5.x = t8[2], e5.y = t8[3], ["Q", t8[0], t8[1], t8[2], t8[3]];
    }, S: function(t8, e5) {
      return e5.x = t8[2], e5.y = t8[3], ["S", t8[0], t8[1], t8[2], t8[3]];
    }, Z: function(t8, e5, i17) {
      return e5.x = i17.x, e5.y = i17.y, ["Z"];
    } }, r13 = "mlhvqtcsaz".split(""), o10 = 0, n11 = r13.length; o10 < n11; ++o10)
      s11[r13[o10]] = function(t8) {
        return function(e5, i17, a11) {
          if ("H" == t8)
            e5[0] = e5[0] + i17.x;
          else if ("V" == t8)
            e5[0] = e5[0] + i17.y;
          else if ("A" == t8)
            e5[5] = e5[5] + i17.x, e5[6] = e5[6] + i17.y;
          else
            for (var r14 = 0, o11 = e5.length; r14 < o11; ++r14)
              e5[r14] = e5[r14] + (r14 % 2 ? i17.y : i17.x);
          if (s11 && "function" == typeof s11[t8])
            return s11[t8](e5, i17, a11);
        };
      }(r13[o10].toUpperCase());
    a10.PathArray = function(t8, e5) {
      a10.Array.call(this, t8, e5 || [["M", 0, 0]]);
    }, a10.PathArray.prototype = new a10.Array(), a10.PathArray.prototype.constructor = a10.PathArray, a10.extend(a10.PathArray, { toString: function() {
      return function(t8) {
        for (var e5 = 0, i17 = t8.length, a11 = ""; e5 < i17; e5++)
          a11 += t8[e5][0], null != t8[e5][1] && (a11 += t8[e5][1], null != t8[e5][2] && (a11 += " ", a11 += t8[e5][2], null != t8[e5][3] && (a11 += " ", a11 += t8[e5][3], a11 += " ", a11 += t8[e5][4], null != t8[e5][5] && (a11 += " ", a11 += t8[e5][5], a11 += " ", a11 += t8[e5][6], null != t8[e5][7] && (a11 += " ", a11 += t8[e5][7])))));
        return a11 + " ";
      }(this.value);
    }, move: function(t8, e5) {
      var i17 = this.bbox();
      return i17.x, i17.y, this;
    }, at: function(t8) {
      if (!this.destination)
        return this;
      for (var e5 = this.value, i17 = this.destination.value, s12 = [], r14 = new a10.PathArray(), o11 = 0, n12 = e5.length; o11 < n12; o11++) {
        s12[o11] = [e5[o11][0]];
        for (var l9 = 1, h5 = e5[o11].length; l9 < h5; l9++)
          s12[o11][l9] = e5[o11][l9] + (i17[o11][l9] - e5[o11][l9]) * t8;
        "A" === s12[o11][0] && (s12[o11][4] = +(0 != s12[o11][4]), s12[o11][5] = +(0 != s12[o11][5]));
      }
      return r14.value = s12, r14;
    }, parse: function(t8) {
      if (t8 instanceof a10.PathArray)
        return t8.valueOf();
      var e5, i17 = { M: 2, L: 2, H: 1, V: 1, C: 6, S: 4, Q: 4, T: 2, A: 7, Z: 0 };
      t8 = "string" == typeof t8 ? t8.replace(a10.regex.numbersWithDots, h4).replace(a10.regex.pathLetters, " $& ").replace(a10.regex.hyphen, "$1 -").trim().split(a10.regex.delimiter) : t8.reduce(function(t9, e6) {
        return [].concat.call(t9, e6);
      }, []);
      var r14 = [], o11 = new a10.Point(), n12 = new a10.Point(), l9 = 0, c8 = t8.length;
      do {
        a10.regex.isPathLetter.test(t8[l9]) ? (e5 = t8[l9], ++l9) : "M" == e5 ? e5 = "L" : "m" == e5 && (e5 = "l"), r14.push(s11[e5].call(null, t8.slice(l9, l9 += i17[e5.toUpperCase()]).map(parseFloat), o11, n12));
      } while (c8 > l9);
      return r14;
    }, bbox: function() {
      return a10.parser.draw || a10.prepare(), a10.parser.path.setAttribute("d", this.toString()), a10.parser.path.getBBox();
    } }), a10.Number = a10.invent({ create: function(t8, e5) {
      this.value = 0, this.unit = e5 || "", "number" == typeof t8 ? this.value = isNaN(t8) ? 0 : isFinite(t8) ? t8 : t8 < 0 ? -34e37 : 34e37 : "string" == typeof t8 ? (e5 = t8.match(a10.regex.numberAndUnit)) && (this.value = parseFloat(e5[1]), "%" == e5[5] ? this.value /= 100 : "s" == e5[5] && (this.value *= 1e3), this.unit = e5[5]) : t8 instanceof a10.Number && (this.value = t8.valueOf(), this.unit = t8.unit);
    }, extend: { toString: function() {
      return ("%" == this.unit ? ~~(1e8 * this.value) / 1e6 : "s" == this.unit ? this.value / 1e3 : this.value) + this.unit;
    }, toJSON: function() {
      return this.toString();
    }, valueOf: function() {
      return this.value;
    }, plus: function(t8) {
      return t8 = new a10.Number(t8), new a10.Number(this + t8, this.unit || t8.unit);
    }, minus: function(t8) {
      return t8 = new a10.Number(t8), new a10.Number(this - t8, this.unit || t8.unit);
    }, times: function(t8) {
      return t8 = new a10.Number(t8), new a10.Number(this * t8, this.unit || t8.unit);
    }, divide: function(t8) {
      return t8 = new a10.Number(t8), new a10.Number(this / t8, this.unit || t8.unit);
    }, to: function(t8) {
      var e5 = new a10.Number(this);
      return "string" == typeof t8 && (e5.unit = t8), e5;
    }, morph: function(t8) {
      return this.destination = new a10.Number(t8), t8.relative && (this.destination.value += this.value), this;
    }, at: function(t8) {
      return this.destination ? new a10.Number(this.destination).minus(this).times(t8).plus(this) : this;
    } } }), a10.Element = a10.invent({ create: function(t8) {
      this._stroke = a10.defaults.attrs.stroke, this._event = null, this.dom = {}, (this.node = t8) && (this.type = t8.nodeName, this.node.instance = this, this._stroke = t8.getAttribute("stroke") || this._stroke);
    }, extend: { x: function(t8) {
      return this.attr("x", t8);
    }, y: function(t8) {
      return this.attr("y", t8);
    }, cx: function(t8) {
      return null == t8 ? this.x() + this.width() / 2 : this.x(t8 - this.width() / 2);
    }, cy: function(t8) {
      return null == t8 ? this.y() + this.height() / 2 : this.y(t8 - this.height() / 2);
    }, move: function(t8, e5) {
      return this.x(t8).y(e5);
    }, center: function(t8, e5) {
      return this.cx(t8).cy(e5);
    }, width: function(t8) {
      return this.attr("width", t8);
    }, height: function(t8) {
      return this.attr("height", t8);
    }, size: function(t8, e5) {
      var i17 = u6(this, t8, e5);
      return this.width(new a10.Number(i17.width)).height(new a10.Number(i17.height));
    }, clone: function(t8) {
      this.writeDataToDom();
      var e5 = x4(this.node.cloneNode(true));
      return t8 ? t8.add(e5) : this.after(e5), e5;
    }, remove: function() {
      return this.parent() && this.parent().removeElement(this), this;
    }, replace: function(t8) {
      return this.after(t8).remove(), t8;
    }, addTo: function(t8) {
      return t8.put(this);
    }, putIn: function(t8) {
      return t8.add(this);
    }, id: function(t8) {
      return this.attr("id", t8);
    }, show: function() {
      return this.style("display", "");
    }, hide: function() {
      return this.style("display", "none");
    }, visible: function() {
      return "none" != this.style("display");
    }, toString: function() {
      return this.attr("id");
    }, classes: function() {
      var t8 = this.attr("class");
      return null == t8 ? [] : t8.trim().split(a10.regex.delimiter);
    }, hasClass: function(t8) {
      return -1 != this.classes().indexOf(t8);
    }, addClass: function(t8) {
      if (!this.hasClass(t8)) {
        var e5 = this.classes();
        e5.push(t8), this.attr("class", e5.join(" "));
      }
      return this;
    }, removeClass: function(t8) {
      return this.hasClass(t8) && this.attr("class", this.classes().filter(function(e5) {
        return e5 != t8;
      }).join(" ")), this;
    }, toggleClass: function(t8) {
      return this.hasClass(t8) ? this.removeClass(t8) : this.addClass(t8);
    }, reference: function(t8) {
      return a10.get(this.attr(t8));
    }, parent: function(e5) {
      var i17 = this;
      if (!i17.node.parentNode)
        return null;
      if (i17 = a10.adopt(i17.node.parentNode), !e5)
        return i17;
      for (; i17 && i17.node instanceof t7.SVGElement; ) {
        if ("string" == typeof e5 ? i17.matches(e5) : i17 instanceof e5)
          return i17;
        if (!i17.node.parentNode || "#document" == i17.node.parentNode.nodeName)
          return null;
        i17 = a10.adopt(i17.node.parentNode);
      }
    }, doc: function() {
      return this instanceof a10.Doc ? this : this.parent(a10.Doc);
    }, parents: function(t8) {
      var e5 = [], i17 = this;
      do {
        if (!(i17 = i17.parent(t8)) || !i17.node)
          break;
        e5.push(i17);
      } while (i17.parent);
      return e5;
    }, matches: function(t8) {
      return function(t9, e5) {
        return (t9.matches || t9.matchesSelector || t9.msMatchesSelector || t9.mozMatchesSelector || t9.webkitMatchesSelector || t9.oMatchesSelector).call(t9, e5);
      }(this.node, t8);
    }, native: function() {
      return this.node;
    }, svg: function(t8) {
      var i17 = e4.createElementNS("http://www.w3.org/2000/svg", "svg");
      if (!(t8 && this instanceof a10.Parent))
        return i17.appendChild(t8 = e4.createElementNS("http://www.w3.org/2000/svg", "svg")), this.writeDataToDom(), t8.appendChild(this.node.cloneNode(true)), i17.innerHTML.replace(/^<svg>/, "").replace(/<\/svg>$/, "");
      i17.innerHTML = "<svg>" + t8.replace(/\n/, "").replace(/<([\w:-]+)([^<]+?)\/>/g, "<$1$2></$1>") + "</svg>";
      for (var s12 = 0, r14 = i17.firstChild.childNodes.length; s12 < r14; s12++)
        this.node.appendChild(i17.firstChild.firstChild);
      return this;
    }, writeDataToDom: function() {
      return (this.each || this.lines) && (this.each ? this : this.lines()).each(function() {
        this.writeDataToDom();
      }), this.node.removeAttribute("svgjs:data"), Object.keys(this.dom).length && this.node.setAttribute("svgjs:data", JSON.stringify(this.dom)), this;
    }, setData: function(t8) {
      return this.dom = t8, this;
    }, is: function(t8) {
      return function(t9, e5) {
        return t9 instanceof e5;
      }(this, t8);
    } } }), a10.easing = { "-": function(t8) {
      return t8;
    }, "<>": function(t8) {
      return -Math.cos(t8 * Math.PI) / 2 + 0.5;
    }, ">": function(t8) {
      return Math.sin(t8 * Math.PI / 2);
    }, "<": function(t8) {
      return 1 - Math.cos(t8 * Math.PI / 2);
    } }, a10.morph = function(t8) {
      return function(e5, i17) {
        return new a10.MorphObj(e5, i17).at(t8);
      };
    }, a10.Situation = a10.invent({ create: function(t8) {
      this.init = false, this.reversed = false, this.reversing = false, this.duration = new a10.Number(t8.duration).valueOf(), this.delay = new a10.Number(t8.delay).valueOf(), this.start = +/* @__PURE__ */ new Date() + this.delay, this.finish = this.start + this.duration, this.ease = t8.ease, this.loop = 0, this.loops = false, this.animations = {}, this.attrs = {}, this.styles = {}, this.transforms = [], this.once = {};
    } }), a10.FX = a10.invent({ create: function(t8) {
      this._target = t8, this.situations = [], this.active = false, this.situation = null, this.paused = false, this.lastPos = 0, this.pos = 0, this.absPos = 0, this._speed = 1;
    }, extend: { animate: function(t8, e5, s12) {
      "object" === i16(t8) && (e5 = t8.ease, s12 = t8.delay, t8 = t8.duration);
      var r14 = new a10.Situation({ duration: t8 || 1e3, delay: s12 || 0, ease: a10.easing[e5 || "-"] || e5 });
      return this.queue(r14), this;
    }, target: function(t8) {
      return t8 && t8 instanceof a10.Element ? (this._target = t8, this) : this._target;
    }, timeToAbsPos: function(t8) {
      return (t8 - this.situation.start) / (this.situation.duration / this._speed);
    }, absPosToTime: function(t8) {
      return this.situation.duration / this._speed * t8 + this.situation.start;
    }, startAnimFrame: function() {
      this.stopAnimFrame(), this.animationFrame = t7.requestAnimationFrame((function() {
        this.step();
      }).bind(this));
    }, stopAnimFrame: function() {
      t7.cancelAnimationFrame(this.animationFrame);
    }, start: function() {
      return !this.active && this.situation && (this.active = true, this.startCurrent()), this;
    }, startCurrent: function() {
      return this.situation.start = +/* @__PURE__ */ new Date() + this.situation.delay / this._speed, this.situation.finish = this.situation.start + this.situation.duration / this._speed, this.initAnimations().step();
    }, queue: function(t8) {
      return ("function" == typeof t8 || t8 instanceof a10.Situation) && this.situations.push(t8), this.situation || (this.situation = this.situations.shift()), this;
    }, dequeue: function() {
      return this.stop(), this.situation = this.situations.shift(), this.situation && (this.situation instanceof a10.Situation ? this.start() : this.situation.call(this)), this;
    }, initAnimations: function() {
      var t8, e5 = this.situation;
      if (e5.init)
        return this;
      for (var i17 in e5.animations) {
        t8 = this.target()[i17](), Array.isArray(t8) || (t8 = [t8]), Array.isArray(e5.animations[i17]) || (e5.animations[i17] = [e5.animations[i17]]);
        for (var s12 = t8.length; s12--; )
          e5.animations[i17][s12] instanceof a10.Number && (t8[s12] = new a10.Number(t8[s12])), e5.animations[i17][s12] = t8[s12].morph(e5.animations[i17][s12]);
      }
      for (var i17 in e5.attrs)
        e5.attrs[i17] = new a10.MorphObj(this.target().attr(i17), e5.attrs[i17]);
      for (var i17 in e5.styles)
        e5.styles[i17] = new a10.MorphObj(this.target().style(i17), e5.styles[i17]);
      return e5.initialTransformation = this.target().matrixify(), e5.init = true, this;
    }, clearQueue: function() {
      return this.situations = [], this;
    }, clearCurrent: function() {
      return this.situation = null, this;
    }, stop: function(t8, e5) {
      var i17 = this.active;
      return this.active = false, e5 && this.clearQueue(), t8 && this.situation && (!i17 && this.startCurrent(), this.atEnd()), this.stopAnimFrame(), this.clearCurrent();
    }, after: function(t8) {
      var e5 = this.last();
      return this.target().on("finished.fx", function i17(a11) {
        a11.detail.situation == e5 && (t8.call(this, e5), this.off("finished.fx", i17));
      }), this._callStart();
    }, during: function(t8) {
      var e5 = this.last(), i17 = function(i18) {
        i18.detail.situation == e5 && t8.call(this, i18.detail.pos, a10.morph(i18.detail.pos), i18.detail.eased, e5);
      };
      return this.target().off("during.fx", i17).on("during.fx", i17), this.after(function() {
        this.off("during.fx", i17);
      }), this._callStart();
    }, afterAll: function(t8) {
      var e5 = function e6(i17) {
        t8.call(this), this.off("allfinished.fx", e6);
      };
      return this.target().off("allfinished.fx", e5).on("allfinished.fx", e5), this._callStart();
    }, last: function() {
      return this.situations.length ? this.situations[this.situations.length - 1] : this.situation;
    }, add: function(t8, e5, i17) {
      return this.last()[i17 || "animations"][t8] = e5, this._callStart();
    }, step: function(t8) {
      var e5, i17, a11;
      t8 || (this.absPos = this.timeToAbsPos(+/* @__PURE__ */ new Date())), false !== this.situation.loops ? (e5 = Math.max(this.absPos, 0), i17 = Math.floor(e5), true === this.situation.loops || i17 < this.situation.loops ? (this.pos = e5 - i17, a11 = this.situation.loop, this.situation.loop = i17) : (this.absPos = this.situation.loops, this.pos = 1, a11 = this.situation.loop - 1, this.situation.loop = this.situation.loops), this.situation.reversing && (this.situation.reversed = this.situation.reversed != Boolean((this.situation.loop - a11) % 2))) : (this.absPos = Math.min(this.absPos, 1), this.pos = this.absPos), this.pos < 0 && (this.pos = 0), this.situation.reversed && (this.pos = 1 - this.pos);
      var s12 = this.situation.ease(this.pos);
      for (var r14 in this.situation.once)
        r14 > this.lastPos && r14 <= s12 && (this.situation.once[r14].call(this.target(), this.pos, s12), delete this.situation.once[r14]);
      return this.active && this.target().fire("during", { pos: this.pos, eased: s12, fx: this, situation: this.situation }), this.situation ? (this.eachAt(), 1 == this.pos && !this.situation.reversed || this.situation.reversed && 0 == this.pos ? (this.stopAnimFrame(), this.target().fire("finished", { fx: this, situation: this.situation }), this.situations.length || (this.target().fire("allfinished"), this.situations.length || (this.target().off(".fx"), this.active = false)), this.active ? this.dequeue() : this.clearCurrent()) : !this.paused && this.active && this.startAnimFrame(), this.lastPos = s12, this) : this;
    }, eachAt: function() {
      var t8, e5 = this, i17 = this.target(), s12 = this.situation;
      for (var r14 in s12.animations)
        t8 = [].concat(s12.animations[r14]).map(function(t9) {
          return "string" != typeof t9 && t9.at ? t9.at(s12.ease(e5.pos), e5.pos) : t9;
        }), i17[r14].apply(i17, t8);
      for (var r14 in s12.attrs)
        t8 = [r14].concat(s12.attrs[r14]).map(function(t9) {
          return "string" != typeof t9 && t9.at ? t9.at(s12.ease(e5.pos), e5.pos) : t9;
        }), i17.attr.apply(i17, t8);
      for (var r14 in s12.styles)
        t8 = [r14].concat(s12.styles[r14]).map(function(t9) {
          return "string" != typeof t9 && t9.at ? t9.at(s12.ease(e5.pos), e5.pos) : t9;
        }), i17.style.apply(i17, t8);
      if (s12.transforms.length) {
        t8 = s12.initialTransformation, r14 = 0;
        for (var o11 = s12.transforms.length; r14 < o11; r14++) {
          var n12 = s12.transforms[r14];
          n12 instanceof a10.Matrix ? t8 = n12.relative ? t8.multiply(new a10.Matrix().morph(n12).at(s12.ease(this.pos))) : t8.morph(n12).at(s12.ease(this.pos)) : (n12.relative || n12.undo(t8.extract()), t8 = t8.multiply(n12.at(s12.ease(this.pos))));
        }
        i17.matrix(t8);
      }
      return this;
    }, once: function(t8, e5, i17) {
      var a11 = this.last();
      return i17 || (t8 = a11.ease(t8)), a11.once[t8] = e5, this;
    }, _callStart: function() {
      return setTimeout((function() {
        this.start();
      }).bind(this), 0), this;
    } }, parent: a10.Element, construct: { animate: function(t8, e5, i17) {
      return (this.fx || (this.fx = new a10.FX(this))).animate(t8, e5, i17);
    }, delay: function(t8) {
      return (this.fx || (this.fx = new a10.FX(this))).delay(t8);
    }, stop: function(t8, e5) {
      return this.fx && this.fx.stop(t8, e5), this;
    }, finish: function() {
      return this.fx && this.fx.finish(), this;
    } } }), a10.MorphObj = a10.invent({ create: function(t8, e5) {
      return a10.Color.isColor(e5) ? new a10.Color(t8).morph(e5) : a10.regex.delimiter.test(t8) ? a10.regex.pathLetters.test(t8) ? new a10.PathArray(t8).morph(e5) : new a10.Array(t8).morph(e5) : a10.regex.numberAndUnit.test(e5) ? new a10.Number(t8).morph(e5) : (this.value = t8, void (this.destination = e5));
    }, extend: { at: function(t8, e5) {
      return e5 < 1 ? this.value : this.destination;
    }, valueOf: function() {
      return this.value;
    } } }), a10.extend(a10.FX, { attr: function(t8, e5, a11) {
      if ("object" === i16(t8))
        for (var s12 in t8)
          this.attr(s12, t8[s12]);
      else
        this.add(t8, e5, "attrs");
      return this;
    }, plot: function(t8, e5, i17, a11) {
      return 4 == arguments.length ? this.plot([t8, e5, i17, a11]) : this.add("plot", new (this.target()).morphArray(t8));
    } }), a10.Box = a10.invent({ create: function(t8, e5, s12, r14) {
      if (!("object" !== i16(t8) || t8 instanceof a10.Element))
        return a10.Box.call(this, null != t8.left ? t8.left : t8.x, null != t8.top ? t8.top : t8.y, t8.width, t8.height);
      var o11;
      4 == arguments.length && (this.x = t8, this.y = e5, this.width = s12, this.height = r14), null == (o11 = this).x && (o11.x = 0, o11.y = 0, o11.width = 0, o11.height = 0), o11.w = o11.width, o11.h = o11.height, o11.x2 = o11.x + o11.width, o11.y2 = o11.y + o11.height, o11.cx = o11.x + o11.width / 2, o11.cy = o11.y + o11.height / 2;
    } }), a10.BBox = a10.invent({ create: function(t8) {
      if (a10.Box.apply(this, [].slice.call(arguments)), t8 instanceof a10.Element) {
        var i17;
        try {
          if (!e4.documentElement.contains) {
            for (var s12 = t8.node; s12.parentNode; )
              s12 = s12.parentNode;
            if (s12 != e4)
              throw new Error("Element not in the dom");
          }
          i17 = t8.node.getBBox();
        } catch (e5) {
          if (t8 instanceof a10.Shape) {
            a10.parser.draw || a10.prepare();
            var r14 = t8.clone(a10.parser.draw.instance).show();
            r14 && r14.node && "function" == typeof r14.node.getBBox && (i17 = r14.node.getBBox()), r14 && "function" == typeof r14.remove && r14.remove();
          } else
            i17 = { x: t8.node.clientLeft, y: t8.node.clientTop, width: t8.node.clientWidth, height: t8.node.clientHeight };
        }
        a10.Box.call(this, i17);
      }
    }, inherit: a10.Box, parent: a10.Element, construct: { bbox: function() {
      return new a10.BBox(this);
    } } }), a10.BBox.prototype.constructor = a10.BBox, a10.Matrix = a10.invent({ create: function(t8) {
      var e5 = f5([1, 0, 0, 1, 0, 0]);
      t8 = null === t8 ? e5 : t8 instanceof a10.Element ? t8.matrixify() : "string" == typeof t8 ? f5(t8.split(a10.regex.delimiter).map(parseFloat)) : 6 == arguments.length ? f5([].slice.call(arguments)) : Array.isArray(t8) ? f5(t8) : t8 && "object" === i16(t8) ? t8 : e5;
      for (var s12 = v5.length - 1; s12 >= 0; --s12)
        this[v5[s12]] = null != t8[v5[s12]] ? t8[v5[s12]] : e5[v5[s12]];
    }, extend: { extract: function() {
      var t8 = p7(this, 0, 1);
      p7(this, 1, 0);
      var e5 = 180 / Math.PI * Math.atan2(t8.y, t8.x) - 90;
      return { x: this.e, y: this.f, transformedX: (this.e * Math.cos(e5 * Math.PI / 180) + this.f * Math.sin(e5 * Math.PI / 180)) / Math.sqrt(this.a * this.a + this.b * this.b), transformedY: (this.f * Math.cos(e5 * Math.PI / 180) + this.e * Math.sin(-e5 * Math.PI / 180)) / Math.sqrt(this.c * this.c + this.d * this.d), rotation: e5, a: this.a, b: this.b, c: this.c, d: this.d, e: this.e, f: this.f, matrix: new a10.Matrix(this) };
    }, clone: function() {
      return new a10.Matrix(this);
    }, morph: function(t8) {
      return this.destination = new a10.Matrix(t8), this;
    }, multiply: function(t8) {
      return new a10.Matrix(this.native().multiply(function(t9) {
        return t9 instanceof a10.Matrix || (t9 = new a10.Matrix(t9)), t9;
      }(t8).native()));
    }, inverse: function() {
      return new a10.Matrix(this.native().inverse());
    }, translate: function(t8, e5) {
      return new a10.Matrix(this.native().translate(t8 || 0, e5 || 0));
    }, native: function() {
      for (var t8 = a10.parser.native.createSVGMatrix(), e5 = v5.length - 1; e5 >= 0; e5--)
        t8[v5[e5]] = this[v5[e5]];
      return t8;
    }, toString: function() {
      return "matrix(" + b3(this.a) + "," + b3(this.b) + "," + b3(this.c) + "," + b3(this.d) + "," + b3(this.e) + "," + b3(this.f) + ")";
    } }, parent: a10.Element, construct: { ctm: function() {
      return new a10.Matrix(this.node.getCTM());
    }, screenCTM: function() {
      if (this instanceof a10.Nested) {
        var t8 = this.rect(1, 1), e5 = t8.node.getScreenCTM();
        return t8.remove(), new a10.Matrix(e5);
      }
      return new a10.Matrix(this.node.getScreenCTM());
    } } }), a10.Point = a10.invent({ create: function(t8, e5) {
      var a11;
      a11 = Array.isArray(t8) ? { x: t8[0], y: t8[1] } : "object" === i16(t8) ? { x: t8.x, y: t8.y } : null != t8 ? { x: t8, y: null != e5 ? e5 : t8 } : { x: 0, y: 0 }, this.x = a11.x, this.y = a11.y;
    }, extend: { clone: function() {
      return new a10.Point(this);
    }, morph: function(t8, e5) {
      return this.destination = new a10.Point(t8, e5), this;
    } } }), a10.extend(a10.Element, { point: function(t8, e5) {
      return new a10.Point(t8, e5).transform(this.screenCTM().inverse());
    } }), a10.extend(a10.Element, { attr: function(t8, e5, s12) {
      if (null == t8) {
        for (t8 = {}, s12 = (e5 = this.node.attributes).length - 1; s12 >= 0; s12--)
          t8[e5[s12].nodeName] = a10.regex.isNumber.test(e5[s12].nodeValue) ? parseFloat(e5[s12].nodeValue) : e5[s12].nodeValue;
        return t8;
      }
      if ("object" === i16(t8))
        for (var r14 in t8)
          this.attr(r14, t8[r14]);
      else if (null === e5)
        this.node.removeAttribute(t8);
      else {
        if (null == e5)
          return null == (e5 = this.node.getAttribute(t8)) ? a10.defaults.attrs[t8] : a10.regex.isNumber.test(e5) ? parseFloat(e5) : e5;
        "stroke-width" == t8 ? this.attr("stroke", parseFloat(e5) > 0 ? this._stroke : null) : "stroke" == t8 && (this._stroke = e5), "fill" != t8 && "stroke" != t8 || (a10.regex.isImage.test(e5) && (e5 = this.doc().defs().image(e5, 0, 0)), e5 instanceof a10.Image && (e5 = this.doc().defs().pattern(0, 0, function() {
          this.add(e5);
        }))), "number" == typeof e5 ? e5 = new a10.Number(e5) : a10.Color.isColor(e5) ? e5 = new a10.Color(e5) : Array.isArray(e5) && (e5 = new a10.Array(e5)), "leading" == t8 ? this.leading && this.leading(e5) : "string" == typeof s12 ? this.node.setAttributeNS(s12, t8, e5.toString()) : this.node.setAttribute(t8, e5.toString()), !this.rebuild || "font-size" != t8 && "x" != t8 || this.rebuild(t8, e5);
      }
      return this;
    } }), a10.extend(a10.Element, { transform: function(t8, e5) {
      var s12;
      return "object" !== i16(t8) ? (s12 = new a10.Matrix(this).extract(), "string" == typeof t8 ? s12[t8] : s12) : (s12 = new a10.Matrix(this), e5 = !!e5 || !!t8.relative, null != t8.a && (s12 = e5 ? s12.multiply(new a10.Matrix(t8)) : new a10.Matrix(t8)), this.attr("transform", s12));
    } }), a10.extend(a10.Element, { untransform: function() {
      return this.attr("transform", null);
    }, matrixify: function() {
      return (this.attr("transform") || "").split(a10.regex.transforms).slice(0, -1).map(function(t8) {
        var e5 = t8.trim().split("(");
        return [e5[0], e5[1].split(a10.regex.delimiter).map(function(t9) {
          return parseFloat(t9);
        })];
      }).reduce(function(t8, e5) {
        return "matrix" == e5[0] ? t8.multiply(f5(e5[1])) : t8[e5[0]].apply(t8, e5[1]);
      }, new a10.Matrix());
    }, toParent: function(t8) {
      if (this == t8)
        return this;
      var e5 = this.screenCTM(), i17 = t8.screenCTM().inverse();
      return this.addTo(t8).untransform().transform(i17.multiply(e5)), this;
    }, toDoc: function() {
      return this.toParent(this.doc());
    } }), a10.Transformation = a10.invent({ create: function(t8, e5) {
      if (arguments.length > 1 && "boolean" != typeof e5)
        return this.constructor.call(this, [].slice.call(arguments));
      if (Array.isArray(t8))
        for (var a11 = 0, s12 = this.arguments.length; a11 < s12; ++a11)
          this[this.arguments[a11]] = t8[a11];
      else if (t8 && "object" === i16(t8))
        for (a11 = 0, s12 = this.arguments.length; a11 < s12; ++a11)
          this[this.arguments[a11]] = t8[this.arguments[a11]];
      this.inversed = false, true === e5 && (this.inversed = true);
    } }), a10.Translate = a10.invent({ parent: a10.Matrix, inherit: a10.Transformation, create: function(t8, e5) {
      this.constructor.apply(this, [].slice.call(arguments));
    }, extend: { arguments: ["transformedX", "transformedY"], method: "translate" } }), a10.extend(a10.Element, { style: function(t8, e5) {
      if (0 == arguments.length)
        return this.node.style.cssText || "";
      if (arguments.length < 2)
        if ("object" === i16(t8))
          for (var s12 in t8)
            this.style(s12, t8[s12]);
        else {
          if (!a10.regex.isCss.test(t8))
            return this.node.style[c7(t8)];
          for (t8 = t8.split(/\s*;\s*/).filter(function(t9) {
            return !!t9;
          }).map(function(t9) {
            return t9.split(/\s*:\s*/);
          }); e5 = t8.pop(); )
            this.style(e5[0], e5[1]);
        }
      else
        this.node.style[c7(t8)] = null === e5 || a10.regex.isBlank.test(e5) ? "" : e5;
      return this;
    } }), a10.Parent = a10.invent({ create: function(t8) {
      this.constructor.call(this, t8);
    }, inherit: a10.Element, extend: { children: function() {
      return a10.utils.map(a10.utils.filterSVGElements(this.node.childNodes), function(t8) {
        return a10.adopt(t8);
      });
    }, add: function(t8, e5) {
      return null == e5 ? this.node.appendChild(t8.node) : t8.node != this.node.childNodes[e5] && this.node.insertBefore(t8.node, this.node.childNodes[e5]), this;
    }, put: function(t8, e5) {
      return this.add(t8, e5), t8;
    }, has: function(t8) {
      return this.index(t8) >= 0;
    }, index: function(t8) {
      return [].slice.call(this.node.childNodes).indexOf(t8.node);
    }, get: function(t8) {
      return a10.adopt(this.node.childNodes[t8]);
    }, first: function() {
      return this.get(0);
    }, last: function() {
      return this.get(this.node.childNodes.length - 1);
    }, each: function(t8, e5) {
      for (var i17 = this.children(), s12 = 0, r14 = i17.length; s12 < r14; s12++)
        i17[s12] instanceof a10.Element && t8.apply(i17[s12], [s12, i17]), e5 && i17[s12] instanceof a10.Container && i17[s12].each(t8, e5);
      return this;
    }, removeElement: function(t8) {
      return this.node.removeChild(t8.node), this;
    }, clear: function() {
      for (; this.node.hasChildNodes(); )
        this.node.removeChild(this.node.lastChild);
      return delete this._defs, this;
    }, defs: function() {
      return this.doc().defs();
    } } }), a10.extend(a10.Parent, { ungroup: function(t8, e5) {
      return 0 === e5 || this instanceof a10.Defs || this.node == a10.parser.draw || (t8 = t8 || (this instanceof a10.Doc ? this : this.parent(a10.Parent)), e5 = e5 || 1 / 0, this.each(function() {
        return this instanceof a10.Defs ? this : this instanceof a10.Parent ? this.ungroup(t8, e5 - 1) : this.toParent(t8);
      }), this.node.firstChild || this.remove()), this;
    }, flatten: function(t8, e5) {
      return this.ungroup(t8, e5);
    } }), a10.Container = a10.invent({ create: function(t8) {
      this.constructor.call(this, t8);
    }, inherit: a10.Parent }), a10.ViewBox = a10.invent({ parent: a10.Container, construct: {} }), ["click", "dblclick", "mousedown", "mouseup", "mouseover", "mouseout", "mousemove", "touchstart", "touchmove", "touchleave", "touchend", "touchcancel"].forEach(function(t8) {
      a10.Element.prototype[t8] = function(e5) {
        return a10.on(this.node, t8, e5), this;
      };
    }), a10.listeners = [], a10.handlerMap = [], a10.listenerId = 0, a10.on = function(t8, e5, i17, s12, r14) {
      var o11 = i17.bind(s12 || t8.instance || t8), n12 = (a10.handlerMap.indexOf(t8) + 1 || a10.handlerMap.push(t8)) - 1, l9 = e5.split(".")[0], h5 = e5.split(".")[1] || "*";
      a10.listeners[n12] = a10.listeners[n12] || {}, a10.listeners[n12][l9] = a10.listeners[n12][l9] || {}, a10.listeners[n12][l9][h5] = a10.listeners[n12][l9][h5] || {}, i17._svgjsListenerId || (i17._svgjsListenerId = ++a10.listenerId), a10.listeners[n12][l9][h5][i17._svgjsListenerId] = o11, t8.addEventListener(l9, o11, r14 || { passive: false });
    }, a10.off = function(t8, e5, i17) {
      var s12 = a10.handlerMap.indexOf(t8), r14 = e5 && e5.split(".")[0], o11 = e5 && e5.split(".")[1], n12 = "";
      if (-1 != s12)
        if (i17) {
          if ("function" == typeof i17 && (i17 = i17._svgjsListenerId), !i17)
            return;
          a10.listeners[s12][r14] && a10.listeners[s12][r14][o11 || "*"] && (t8.removeEventListener(r14, a10.listeners[s12][r14][o11 || "*"][i17], false), delete a10.listeners[s12][r14][o11 || "*"][i17]);
        } else if (o11 && r14) {
          if (a10.listeners[s12][r14] && a10.listeners[s12][r14][o11]) {
            for (var l9 in a10.listeners[s12][r14][o11])
              a10.off(t8, [r14, o11].join("."), l9);
            delete a10.listeners[s12][r14][o11];
          }
        } else if (o11)
          for (var h5 in a10.listeners[s12])
            for (var n12 in a10.listeners[s12][h5])
              o11 === n12 && a10.off(t8, [h5, o11].join("."));
        else if (r14) {
          if (a10.listeners[s12][r14]) {
            for (var n12 in a10.listeners[s12][r14])
              a10.off(t8, [r14, n12].join("."));
            delete a10.listeners[s12][r14];
          }
        } else {
          for (var h5 in a10.listeners[s12])
            a10.off(t8, h5);
          delete a10.listeners[s12], delete a10.handlerMap[s12];
        }
    }, a10.extend(a10.Element, { on: function(t8, e5, i17, s12) {
      return a10.on(this.node, t8, e5, i17, s12), this;
    }, off: function(t8, e5) {
      return a10.off(this.node, t8, e5), this;
    }, fire: function(e5, i17) {
      return e5 instanceof t7.Event ? this.node.dispatchEvent(e5) : this.node.dispatchEvent(e5 = new a10.CustomEvent(e5, { detail: i17, cancelable: true })), this._event = e5, this;
    }, event: function() {
      return this._event;
    } }), a10.Defs = a10.invent({ create: "defs", inherit: a10.Container }), a10.G = a10.invent({ create: "g", inherit: a10.Container, extend: { x: function(t8) {
      return null == t8 ? this.transform("x") : this.transform({ x: t8 - this.x() }, true);
    } }, construct: { group: function() {
      return this.put(new a10.G());
    } } }), a10.Doc = a10.invent({ create: function(t8) {
      t8 && ("svg" == (t8 = "string" == typeof t8 ? e4.getElementById(t8) : t8).nodeName ? this.constructor.call(this, t8) : (this.constructor.call(this, a10.create("svg")), t8.appendChild(this.node), this.size("100%", "100%")), this.namespace().defs());
    }, inherit: a10.Container, extend: { namespace: function() {
      return this.attr({ xmlns: a10.ns, version: "1.1" }).attr("xmlns:xlink", a10.xlink, a10.xmlns).attr("xmlns:svgjs", a10.svgjs, a10.xmlns);
    }, defs: function() {
      var t8;
      return this._defs || ((t8 = this.node.getElementsByTagName("defs")[0]) ? this._defs = a10.adopt(t8) : this._defs = new a10.Defs(), this.node.appendChild(this._defs.node)), this._defs;
    }, parent: function() {
      return this.node.parentNode && "#document" != this.node.parentNode.nodeName ? this.node.parentNode : null;
    }, remove: function() {
      return this.parent() && this.parent().removeChild(this.node), this;
    }, clear: function() {
      for (; this.node.hasChildNodes(); )
        this.node.removeChild(this.node.lastChild);
      return delete this._defs, a10.parser.draw && !a10.parser.draw.parentNode && this.node.appendChild(a10.parser.draw), this;
    }, clone: function(t8) {
      this.writeDataToDom();
      var e5 = this.node, i17 = x4(e5.cloneNode(true));
      return t8 ? (t8.node || t8).appendChild(i17.node) : e5.parentNode.insertBefore(i17.node, e5.nextSibling), i17;
    } } }), a10.extend(a10.Element, {}), a10.Gradient = a10.invent({ create: function(t8) {
      this.constructor.call(this, a10.create(t8 + "Gradient")), this.type = t8;
    }, inherit: a10.Container, extend: { at: function(t8, e5, i17) {
      return this.put(new a10.Stop()).update(t8, e5, i17);
    }, update: function(t8) {
      return this.clear(), "function" == typeof t8 && t8.call(this, this), this;
    }, fill: function() {
      return "url(#" + this.id() + ")";
    }, toString: function() {
      return this.fill();
    }, attr: function(t8, e5, i17) {
      return "transform" == t8 && (t8 = "gradientTransform"), a10.Container.prototype.attr.call(this, t8, e5, i17);
    } }, construct: { gradient: function(t8, e5) {
      return this.defs().gradient(t8, e5);
    } } }), a10.extend(a10.Gradient, a10.FX, { from: function(t8, e5) {
      return "radial" == (this._target || this).type ? this.attr({ fx: new a10.Number(t8), fy: new a10.Number(e5) }) : this.attr({ x1: new a10.Number(t8), y1: new a10.Number(e5) });
    }, to: function(t8, e5) {
      return "radial" == (this._target || this).type ? this.attr({ cx: new a10.Number(t8), cy: new a10.Number(e5) }) : this.attr({ x2: new a10.Number(t8), y2: new a10.Number(e5) });
    } }), a10.extend(a10.Defs, { gradient: function(t8, e5) {
      return this.put(new a10.Gradient(t8)).update(e5);
    } }), a10.Stop = a10.invent({ create: "stop", inherit: a10.Element, extend: { update: function(t8) {
      return ("number" == typeof t8 || t8 instanceof a10.Number) && (t8 = { offset: arguments[0], color: arguments[1], opacity: arguments[2] }), null != t8.opacity && this.attr("stop-opacity", t8.opacity), null != t8.color && this.attr("stop-color", t8.color), null != t8.offset && this.attr("offset", new a10.Number(t8.offset)), this;
    } } }), a10.Pattern = a10.invent({ create: "pattern", inherit: a10.Container, extend: { fill: function() {
      return "url(#" + this.id() + ")";
    }, update: function(t8) {
      return this.clear(), "function" == typeof t8 && t8.call(this, this), this;
    }, toString: function() {
      return this.fill();
    }, attr: function(t8, e5, i17) {
      return "transform" == t8 && (t8 = "patternTransform"), a10.Container.prototype.attr.call(this, t8, e5, i17);
    } }, construct: { pattern: function(t8, e5, i17) {
      return this.defs().pattern(t8, e5, i17);
    } } }), a10.extend(a10.Defs, { pattern: function(t8, e5, i17) {
      return this.put(new a10.Pattern()).update(i17).attr({ x: 0, y: 0, width: t8, height: e5, patternUnits: "userSpaceOnUse" });
    } }), a10.Shape = a10.invent({ create: function(t8) {
      this.constructor.call(this, t8);
    }, inherit: a10.Element }), a10.Symbol = a10.invent({ create: "symbol", inherit: a10.Container, construct: { symbol: function() {
      return this.put(new a10.Symbol());
    } } }), a10.Use = a10.invent({ create: "use", inherit: a10.Shape, extend: { element: function(t8, e5) {
      return this.attr("href", (e5 || "") + "#" + t8, a10.xlink);
    } }, construct: { use: function(t8, e5) {
      return this.put(new a10.Use()).element(t8, e5);
    } } }), a10.Rect = a10.invent({ create: "rect", inherit: a10.Shape, construct: { rect: function(t8, e5) {
      return this.put(new a10.Rect()).size(t8, e5);
    } } }), a10.Circle = a10.invent({ create: "circle", inherit: a10.Shape, construct: { circle: function(t8) {
      return this.put(new a10.Circle()).rx(new a10.Number(t8).divide(2)).move(0, 0);
    } } }), a10.extend(a10.Circle, a10.FX, { rx: function(t8) {
      return this.attr("r", t8);
    }, ry: function(t8) {
      return this.rx(t8);
    } }), a10.Ellipse = a10.invent({ create: "ellipse", inherit: a10.Shape, construct: { ellipse: function(t8, e5) {
      return this.put(new a10.Ellipse()).size(t8, e5).move(0, 0);
    } } }), a10.extend(a10.Ellipse, a10.Rect, a10.FX, { rx: function(t8) {
      return this.attr("rx", t8);
    }, ry: function(t8) {
      return this.attr("ry", t8);
    } }), a10.extend(a10.Circle, a10.Ellipse, { x: function(t8) {
      return null == t8 ? this.cx() - this.rx() : this.cx(t8 + this.rx());
    }, y: function(t8) {
      return null == t8 ? this.cy() - this.ry() : this.cy(t8 + this.ry());
    }, cx: function(t8) {
      return null == t8 ? this.attr("cx") : this.attr("cx", t8);
    }, cy: function(t8) {
      return null == t8 ? this.attr("cy") : this.attr("cy", t8);
    }, width: function(t8) {
      return null == t8 ? 2 * this.rx() : this.rx(new a10.Number(t8).divide(2));
    }, height: function(t8) {
      return null == t8 ? 2 * this.ry() : this.ry(new a10.Number(t8).divide(2));
    }, size: function(t8, e5) {
      var i17 = u6(this, t8, e5);
      return this.rx(new a10.Number(i17.width).divide(2)).ry(new a10.Number(i17.height).divide(2));
    } }), a10.Line = a10.invent({ create: "line", inherit: a10.Shape, extend: { array: function() {
      return new a10.PointArray([[this.attr("x1"), this.attr("y1")], [this.attr("x2"), this.attr("y2")]]);
    }, plot: function(t8, e5, i17, s12) {
      return null == t8 ? this.array() : (t8 = void 0 !== e5 ? { x1: t8, y1: e5, x2: i17, y2: s12 } : new a10.PointArray(t8).toLine(), this.attr(t8));
    }, move: function(t8, e5) {
      return this.attr(this.array().move(t8, e5).toLine());
    }, size: function(t8, e5) {
      var i17 = u6(this, t8, e5);
      return this.attr(this.array().size(i17.width, i17.height).toLine());
    } }, construct: { line: function(t8, e5, i17, s12) {
      return a10.Line.prototype.plot.apply(this.put(new a10.Line()), null != t8 ? [t8, e5, i17, s12] : [0, 0, 0, 0]);
    } } }), a10.Polyline = a10.invent({ create: "polyline", inherit: a10.Shape, construct: { polyline: function(t8) {
      return this.put(new a10.Polyline()).plot(t8 || new a10.PointArray());
    } } }), a10.Polygon = a10.invent({ create: "polygon", inherit: a10.Shape, construct: { polygon: function(t8) {
      return this.put(new a10.Polygon()).plot(t8 || new a10.PointArray());
    } } }), a10.extend(a10.Polyline, a10.Polygon, { array: function() {
      return this._array || (this._array = new a10.PointArray(this.attr("points")));
    }, plot: function(t8) {
      return null == t8 ? this.array() : this.clear().attr("points", "string" == typeof t8 ? t8 : this._array = new a10.PointArray(t8));
    }, clear: function() {
      return delete this._array, this;
    }, move: function(t8, e5) {
      return this.attr("points", this.array().move(t8, e5));
    }, size: function(t8, e5) {
      var i17 = u6(this, t8, e5);
      return this.attr("points", this.array().size(i17.width, i17.height));
    } }), a10.extend(a10.Line, a10.Polyline, a10.Polygon, { morphArray: a10.PointArray, x: function(t8) {
      return null == t8 ? this.bbox().x : this.move(t8, this.bbox().y);
    }, y: function(t8) {
      return null == t8 ? this.bbox().y : this.move(this.bbox().x, t8);
    }, width: function(t8) {
      var e5 = this.bbox();
      return null == t8 ? e5.width : this.size(t8, e5.height);
    }, height: function(t8) {
      var e5 = this.bbox();
      return null == t8 ? e5.height : this.size(e5.width, t8);
    } }), a10.Path = a10.invent({ create: "path", inherit: a10.Shape, extend: { morphArray: a10.PathArray, array: function() {
      return this._array || (this._array = new a10.PathArray(this.attr("d")));
    }, plot: function(t8) {
      return null == t8 ? this.array() : this.clear().attr("d", "string" == typeof t8 ? t8 : this._array = new a10.PathArray(t8));
    }, clear: function() {
      return delete this._array, this;
    } }, construct: { path: function(t8) {
      return this.put(new a10.Path()).plot(t8 || new a10.PathArray());
    } } }), a10.Image = a10.invent({ create: "image", inherit: a10.Shape, extend: { load: function(e5) {
      if (!e5)
        return this;
      var i17 = this, s12 = new t7.Image();
      return a10.on(s12, "load", function() {
        a10.off(s12);
        var t8 = i17.parent(a10.Pattern);
        null !== t8 && (0 == i17.width() && 0 == i17.height() && i17.size(s12.width, s12.height), t8 && 0 == t8.width() && 0 == t8.height() && t8.size(i17.width(), i17.height()), "function" == typeof i17._loaded && i17._loaded.call(i17, { width: s12.width, height: s12.height, ratio: s12.width / s12.height, url: e5 }));
      }), a10.on(s12, "error", function(t8) {
        a10.off(s12), "function" == typeof i17._error && i17._error.call(i17, t8);
      }), this.attr("href", s12.src = this.src = e5, a10.xlink);
    }, loaded: function(t8) {
      return this._loaded = t8, this;
    }, error: function(t8) {
      return this._error = t8, this;
    } }, construct: { image: function(t8, e5, i17) {
      return this.put(new a10.Image()).load(t8).size(e5 || 0, i17 || e5 || 0);
    } } }), a10.Text = a10.invent({ create: function() {
      this.constructor.call(this, a10.create("text")), this.dom.leading = new a10.Number(1.3), this._rebuild = true, this._build = false, this.attr("font-family", a10.defaults.attrs["font-family"]);
    }, inherit: a10.Shape, extend: { x: function(t8) {
      return null == t8 ? this.attr("x") : this.attr("x", t8);
    }, text: function(t8) {
      if (void 0 === t8) {
        t8 = "";
        for (var e5 = this.node.childNodes, i17 = 0, s12 = e5.length; i17 < s12; ++i17)
          0 != i17 && 3 != e5[i17].nodeType && 1 == a10.adopt(e5[i17]).dom.newLined && (t8 += "\n"), t8 += e5[i17].textContent;
        return t8;
      }
      if (this.clear().build(true), "function" == typeof t8)
        t8.call(this, this);
      else {
        i17 = 0;
        for (var r14 = (t8 = t8.split("\n")).length; i17 < r14; i17++)
          this.tspan(t8[i17]).newLine();
      }
      return this.build(false).rebuild();
    }, size: function(t8) {
      return this.attr("font-size", t8).rebuild();
    }, leading: function(t8) {
      return null == t8 ? this.dom.leading : (this.dom.leading = new a10.Number(t8), this.rebuild());
    }, lines: function() {
      var t8 = (this.textPath && this.textPath() || this).node, e5 = a10.utils.map(a10.utils.filterSVGElements(t8.childNodes), function(t9) {
        return a10.adopt(t9);
      });
      return new a10.Set(e5);
    }, rebuild: function(t8) {
      if ("boolean" == typeof t8 && (this._rebuild = t8), this._rebuild) {
        var e5 = this, i17 = 0, s12 = this.dom.leading * new a10.Number(this.attr("font-size"));
        this.lines().each(function() {
          this.dom.newLined && (e5.textPath() || this.attr("x", e5.attr("x")), "\n" == this.text() ? i17 += s12 : (this.attr("dy", s12 + i17), i17 = 0));
        }), this.fire("rebuild");
      }
      return this;
    }, build: function(t8) {
      return this._build = !!t8, this;
    }, setData: function(t8) {
      return this.dom = t8, this.dom.leading = new a10.Number(t8.leading || 1.3), this;
    } }, construct: { text: function(t8) {
      return this.put(new a10.Text()).text(t8);
    }, plain: function(t8) {
      return this.put(new a10.Text()).plain(t8);
    } } }), a10.Tspan = a10.invent({ create: "tspan", inherit: a10.Shape, extend: { text: function(t8) {
      return null == t8 ? this.node.textContent + (this.dom.newLined ? "\n" : "") : ("function" == typeof t8 ? t8.call(this, this) : this.plain(t8), this);
    }, dx: function(t8) {
      return this.attr("dx", t8);
    }, dy: function(t8) {
      return this.attr("dy", t8);
    }, newLine: function() {
      var t8 = this.parent(a10.Text);
      return this.dom.newLined = true, this.dy(t8.dom.leading * t8.attr("font-size")).attr("x", t8.x());
    } } }), a10.extend(a10.Text, a10.Tspan, { plain: function(t8) {
      return false === this._build && this.clear(), this.node.appendChild(e4.createTextNode(t8)), this;
    }, tspan: function(t8) {
      var e5 = (this.textPath && this.textPath() || this).node, i17 = new a10.Tspan();
      return false === this._build && this.clear(), e5.appendChild(i17.node), i17.text(t8);
    }, clear: function() {
      for (var t8 = (this.textPath && this.textPath() || this).node; t8.hasChildNodes(); )
        t8.removeChild(t8.lastChild);
      return this;
    }, length: function() {
      return this.node.getComputedTextLength();
    } }), a10.TextPath = a10.invent({ create: "textPath", inherit: a10.Parent, parent: a10.Text, construct: { morphArray: a10.PathArray, array: function() {
      var t8 = this.track();
      return t8 ? t8.array() : null;
    }, plot: function(t8) {
      var e5 = this.track(), i17 = null;
      return e5 && (i17 = e5.plot(t8)), null == t8 ? i17 : this;
    }, track: function() {
      var t8 = this.textPath();
      if (t8)
        return t8.reference("href");
    }, textPath: function() {
      if (this.node.firstChild && "textPath" == this.node.firstChild.nodeName)
        return a10.adopt(this.node.firstChild);
    } } }), a10.Nested = a10.invent({ create: function() {
      this.constructor.call(this, a10.create("svg")), this.style("overflow", "visible");
    }, inherit: a10.Container, construct: { nested: function() {
      return this.put(new a10.Nested());
    } } });
    var l8 = { stroke: ["color", "width", "opacity", "linecap", "linejoin", "miterlimit", "dasharray", "dashoffset"], fill: ["color", "opacity", "rule"], prefix: function(t8, e5) {
      return "color" == e5 ? t8 : t8 + "-" + e5;
    } };
    function h4(t8, e5, i17, s12) {
      return i17 + s12.replace(a10.regex.dots, " .");
    }
    function c7(t8) {
      return t8.toLowerCase().replace(/-(.)/g, function(t9, e5) {
        return e5.toUpperCase();
      });
    }
    function d9(t8) {
      return t8.charAt(0).toUpperCase() + t8.slice(1);
    }
    function g7(t8) {
      var e5 = t8.toString(16);
      return 1 == e5.length ? "0" + e5 : e5;
    }
    function u6(t8, e5, i17) {
      if (null == e5 || null == i17) {
        var a11 = t8.bbox();
        null == e5 ? e5 = a11.width / a11.height * i17 : null == i17 && (i17 = a11.height / a11.width * e5);
      }
      return { width: e5, height: i17 };
    }
    function p7(t8, e5, i17) {
      return { x: e5 * t8.a + i17 * t8.c + 0, y: e5 * t8.b + i17 * t8.d + 0 };
    }
    function f5(t8) {
      return { a: t8[0], b: t8[1], c: t8[2], d: t8[3], e: t8[4], f: t8[5] };
    }
    function x4(e5) {
      for (var i17 = e5.childNodes.length - 1; i17 >= 0; i17--)
        e5.childNodes[i17] instanceof t7.SVGElement && x4(e5.childNodes[i17]);
      return a10.adopt(e5).id(a10.eid(e5.nodeName));
    }
    function b3(t8) {
      return Math.abs(t8) > 1e-37 ? t8 : 0;
    }
    ["fill", "stroke"].forEach(function(t8) {
      var e5 = {};
      e5[t8] = function(e6) {
        if (void 0 === e6)
          return this;
        if ("string" == typeof e6 || a10.Color.isRgb(e6) || e6 && "function" == typeof e6.fill)
          this.attr(t8, e6);
        else
          for (var i17 = l8[t8].length - 1; i17 >= 0; i17--)
            null != e6[l8[t8][i17]] && this.attr(l8.prefix(t8, l8[t8][i17]), e6[l8[t8][i17]]);
        return this;
      }, a10.extend(a10.Element, a10.FX, e5);
    }), a10.extend(a10.Element, a10.FX, { translate: function(t8, e5) {
      return this.transform({ x: t8, y: e5 });
    }, matrix: function(t8) {
      return this.attr("transform", new a10.Matrix(6 == arguments.length ? [].slice.call(arguments) : t8));
    }, opacity: function(t8) {
      return this.attr("opacity", t8);
    }, dx: function(t8) {
      return this.x(new a10.Number(t8).plus(this instanceof a10.FX ? 0 : this.x()), true);
    }, dy: function(t8) {
      return this.y(new a10.Number(t8).plus(this instanceof a10.FX ? 0 : this.y()), true);
    } }), a10.extend(a10.Path, { length: function() {
      return this.node.getTotalLength();
    }, pointAt: function(t8) {
      return this.node.getPointAtLength(t8);
    } }), a10.Set = a10.invent({ create: function(t8) {
      Array.isArray(t8) ? this.members = t8 : this.clear();
    }, extend: { add: function() {
      for (var t8 = [].slice.call(arguments), e5 = 0, i17 = t8.length; e5 < i17; e5++)
        this.members.push(t8[e5]);
      return this;
    }, remove: function(t8) {
      var e5 = this.index(t8);
      return e5 > -1 && this.members.splice(e5, 1), this;
    }, each: function(t8) {
      for (var e5 = 0, i17 = this.members.length; e5 < i17; e5++)
        t8.apply(this.members[e5], [e5, this.members]);
      return this;
    }, clear: function() {
      return this.members = [], this;
    }, length: function() {
      return this.members.length;
    }, has: function(t8) {
      return this.index(t8) >= 0;
    }, index: function(t8) {
      return this.members.indexOf(t8);
    }, get: function(t8) {
      return this.members[t8];
    }, first: function() {
      return this.get(0);
    }, last: function() {
      return this.get(this.members.length - 1);
    }, valueOf: function() {
      return this.members;
    } }, construct: { set: function(t8) {
      return new a10.Set(t8);
    } } }), a10.FX.Set = a10.invent({ create: function(t8) {
      this.set = t8;
    } }), a10.Set.inherit = function() {
      var t8 = [];
      for (var e5 in a10.Shape.prototype)
        "function" == typeof a10.Shape.prototype[e5] && "function" != typeof a10.Set.prototype[e5] && t8.push(e5);
      for (var e5 in t8.forEach(function(t9) {
        a10.Set.prototype[t9] = function() {
          for (var e6 = 0, i17 = this.members.length; e6 < i17; e6++)
            this.members[e6] && "function" == typeof this.members[e6][t9] && this.members[e6][t9].apply(this.members[e6], arguments);
          return "animate" == t9 ? this.fx || (this.fx = new a10.FX.Set(this)) : this;
        };
      }), t8 = [], a10.FX.prototype)
        "function" == typeof a10.FX.prototype[e5] && "function" != typeof a10.FX.Set.prototype[e5] && t8.push(e5);
      t8.forEach(function(t9) {
        a10.FX.Set.prototype[t9] = function() {
          for (var e6 = 0, i17 = this.set.members.length; e6 < i17; e6++)
            this.set.members[e6].fx[t9].apply(this.set.members[e6].fx, arguments);
          return this;
        };
      });
    }, a10.extend(a10.Element, {}), a10.extend(a10.Element, { remember: function(t8, e5) {
      if ("object" === i16(arguments[0]))
        for (var a11 in t8)
          this.remember(a11, t8[a11]);
      else {
        if (1 == arguments.length)
          return this.memory()[t8];
        this.memory()[t8] = e5;
      }
      return this;
    }, forget: function() {
      if (0 == arguments.length)
        this._memory = {};
      else
        for (var t8 = arguments.length - 1; t8 >= 0; t8--)
          delete this.memory()[arguments[t8]];
      return this;
    }, memory: function() {
      return this._memory || (this._memory = {});
    } }), a10.get = function(t8) {
      var i17 = e4.getElementById(function(t9) {
        var e5 = (t9 || "").toString().match(a10.regex.reference);
        if (e5)
          return e5[1];
      }(t8) || t8);
      return a10.adopt(i17);
    }, a10.select = function(t8, i17) {
      return new a10.Set(a10.utils.map((i17 || e4).querySelectorAll(t8), function(t9) {
        return a10.adopt(t9);
      }));
    }, a10.extend(a10.Parent, { select: function(t8) {
      return a10.select(t8, this.node);
    } });
    var v5 = "abcdef".split("");
    if ("function" != typeof t7.CustomEvent) {
      var m4 = function(t8, i17) {
        i17 = i17 || { bubbles: false, cancelable: false, detail: void 0 };
        var a11 = e4.createEvent("CustomEvent");
        return a11.initCustomEvent(t8, i17.bubbles, i17.cancelable, i17.detail), a11;
      };
      m4.prototype = t7.Event.prototype, a10.CustomEvent = m4;
    } else
      a10.CustomEvent = t7.CustomEvent;
    return a10;
  }, "object" === i16(exports) && true ? module.exports = Rt.document ? Ht(Rt, Rt.document) : function(t7) {
    return Ht(t7, t7.document);
  } : Rt.SVG = Ht(Rt, Rt.document), /*! svg.filter.js - v2.0.2 - 2016-02-24
  * https://github.com/wout/svg.filter.js
  * Copyright (c) 2016 Wout Fierens; Licensed MIT */
  (function() {
    SVG.Filter = SVG.invent({ create: "filter", inherit: SVG.Parent, extend: { source: "SourceGraphic", sourceAlpha: "SourceAlpha", background: "BackgroundImage", backgroundAlpha: "BackgroundAlpha", fill: "FillPaint", stroke: "StrokePaint", autoSetIn: true, put: function(t8, e5) {
      return this.add(t8, e5), !t8.attr("in") && this.autoSetIn && t8.attr("in", this.source), t8.attr("result") || t8.attr("result", t8), t8;
    }, blend: function(t8, e5, i18) {
      return this.put(new SVG.BlendEffect(t8, e5, i18));
    }, colorMatrix: function(t8, e5) {
      return this.put(new SVG.ColorMatrixEffect(t8, e5));
    }, convolveMatrix: function(t8) {
      return this.put(new SVG.ConvolveMatrixEffect(t8));
    }, componentTransfer: function(t8) {
      return this.put(new SVG.ComponentTransferEffect(t8));
    }, composite: function(t8, e5, i18) {
      return this.put(new SVG.CompositeEffect(t8, e5, i18));
    }, flood: function(t8, e5) {
      return this.put(new SVG.FloodEffect(t8, e5));
    }, offset: function(t8, e5) {
      return this.put(new SVG.OffsetEffect(t8, e5));
    }, image: function(t8) {
      return this.put(new SVG.ImageEffect(t8));
    }, merge: function() {
      var t8 = [void 0];
      for (var e5 in arguments)
        t8.push(arguments[e5]);
      return this.put(new (SVG.MergeEffect.bind.apply(SVG.MergeEffect, t8))());
    }, gaussianBlur: function(t8, e5) {
      return this.put(new SVG.GaussianBlurEffect(t8, e5));
    }, morphology: function(t8, e5) {
      return this.put(new SVG.MorphologyEffect(t8, e5));
    }, diffuseLighting: function(t8, e5, i18) {
      return this.put(new SVG.DiffuseLightingEffect(t8, e5, i18));
    }, displacementMap: function(t8, e5, i18, a11, s12) {
      return this.put(new SVG.DisplacementMapEffect(t8, e5, i18, a11, s12));
    }, specularLighting: function(t8, e5, i18, a11) {
      return this.put(new SVG.SpecularLightingEffect(t8, e5, i18, a11));
    }, tile: function() {
      return this.put(new SVG.TileEffect());
    }, turbulence: function(t8, e5, i18, a11, s12) {
      return this.put(new SVG.TurbulenceEffect(t8, e5, i18, a11, s12));
    }, toString: function() {
      return "url(#" + this.attr("id") + ")";
    } } }), SVG.extend(SVG.Defs, { filter: function(t8) {
      var e5 = this.put(new SVG.Filter());
      return "function" == typeof t8 && t8.call(e5, e5), e5;
    } }), SVG.extend(SVG.Container, { filter: function(t8) {
      return this.defs().filter(t8);
    } }), SVG.extend(SVG.Element, SVG.G, SVG.Nested, { filter: function(t8) {
      return this.filterer = t8 instanceof SVG.Element ? t8 : this.doc().filter(t8), this.doc() && this.filterer.doc() !== this.doc() && this.doc().defs().add(this.filterer), this.attr("filter", this.filterer), this.filterer;
    }, unfilter: function(t8) {
      return this.filterer && true === t8 && this.filterer.remove(), delete this.filterer, this.attr("filter", null);
    } }), SVG.Effect = SVG.invent({ create: function() {
      this.constructor.call(this);
    }, inherit: SVG.Element, extend: { in: function(t8) {
      return null == t8 ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", t8);
    }, result: function(t8) {
      return null == t8 ? this.attr("result") : this.attr("result", t8);
    }, toString: function() {
      return this.result();
    } } }), SVG.ParentEffect = SVG.invent({ create: function() {
      this.constructor.call(this);
    }, inherit: SVG.Parent, extend: { in: function(t8) {
      return null == t8 ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", t8);
    }, result: function(t8) {
      return null == t8 ? this.attr("result") : this.attr("result", t8);
    }, toString: function() {
      return this.result();
    } } });
    var t7 = { blend: function(t8, e5) {
      return this.parent() && this.parent().blend(this, t8, e5);
    }, colorMatrix: function(t8, e5) {
      return this.parent() && this.parent().colorMatrix(t8, e5).in(this);
    }, convolveMatrix: function(t8) {
      return this.parent() && this.parent().convolveMatrix(t8).in(this);
    }, componentTransfer: function(t8) {
      return this.parent() && this.parent().componentTransfer(t8).in(this);
    }, composite: function(t8, e5) {
      return this.parent() && this.parent().composite(this, t8, e5);
    }, flood: function(t8, e5) {
      return this.parent() && this.parent().flood(t8, e5);
    }, offset: function(t8, e5) {
      return this.parent() && this.parent().offset(t8, e5).in(this);
    }, image: function(t8) {
      return this.parent() && this.parent().image(t8);
    }, merge: function() {
      return this.parent() && this.parent().merge.apply(this.parent(), [this].concat(arguments));
    }, gaussianBlur: function(t8, e5) {
      return this.parent() && this.parent().gaussianBlur(t8, e5).in(this);
    }, morphology: function(t8, e5) {
      return this.parent() && this.parent().morphology(t8, e5).in(this);
    }, diffuseLighting: function(t8, e5, i18) {
      return this.parent() && this.parent().diffuseLighting(t8, e5, i18).in(this);
    }, displacementMap: function(t8, e5, i18, a11) {
      return this.parent() && this.parent().displacementMap(this, t8, e5, i18, a11);
    }, specularLighting: function(t8, e5, i18, a11) {
      return this.parent() && this.parent().specularLighting(t8, e5, i18, a11).in(this);
    }, tile: function() {
      return this.parent() && this.parent().tile().in(this);
    }, turbulence: function(t8, e5, i18, a11, s12) {
      return this.parent() && this.parent().turbulence(t8, e5, i18, a11, s12).in(this);
    } };
    SVG.extend(SVG.Effect, t7), SVG.extend(SVG.ParentEffect, t7), SVG.ChildEffect = SVG.invent({ create: function() {
      this.constructor.call(this);
    }, inherit: SVG.Element, extend: { in: function(t8) {
      this.attr("in", t8);
    } } });
    var e4 = { blend: function(t8, e5, i18) {
      this.attr({ in: t8, in2: e5, mode: i18 || "normal" });
    }, colorMatrix: function(t8, e5) {
      "matrix" == t8 && (e5 = s11(e5)), this.attr({ type: t8, values: void 0 === e5 ? null : e5 });
    }, convolveMatrix: function(t8) {
      t8 = s11(t8), this.attr({ order: Math.sqrt(t8.split(" ").length), kernelMatrix: t8 });
    }, composite: function(t8, e5, i18) {
      this.attr({ in: t8, in2: e5, operator: i18 });
    }, flood: function(t8, e5) {
      this.attr("flood-color", t8), null != e5 && this.attr("flood-opacity", e5);
    }, offset: function(t8, e5) {
      this.attr({ dx: t8, dy: e5 });
    }, image: function(t8) {
      this.attr("href", t8, SVG.xlink);
    }, displacementMap: function(t8, e5, i18, a11, s12) {
      this.attr({ in: t8, in2: e5, scale: i18, xChannelSelector: a11, yChannelSelector: s12 });
    }, gaussianBlur: function(t8, e5) {
      null != t8 || null != e5 ? this.attr("stdDeviation", function(t9) {
        if (!Array.isArray(t9))
          return t9;
        for (var e6 = 0, i18 = t9.length, a11 = []; e6 < i18; e6++)
          a11.push(t9[e6]);
        return a11.join(" ");
      }(Array.prototype.slice.call(arguments))) : this.attr("stdDeviation", "0 0");
    }, morphology: function(t8, e5) {
      this.attr({ operator: t8, radius: e5 });
    }, tile: function() {
    }, turbulence: function(t8, e5, i18, a11, s12) {
      this.attr({ numOctaves: e5, seed: i18, stitchTiles: a11, baseFrequency: t8, type: s12 });
    } }, i17 = { merge: function() {
      var t8;
      if (arguments[0] instanceof SVG.Set) {
        var e5 = this;
        arguments[0].each(function(t9) {
          this instanceof SVG.MergeNode ? e5.put(this) : (this instanceof SVG.Effect || this instanceof SVG.ParentEffect) && e5.put(new SVG.MergeNode(this));
        });
      } else {
        t8 = Array.isArray(arguments[0]) ? arguments[0] : arguments;
        for (var i18 = 0; i18 < t8.length; i18++)
          t8[i18] instanceof SVG.MergeNode ? this.put(t8[i18]) : this.put(new SVG.MergeNode(t8[i18]));
      }
    }, componentTransfer: function(t8) {
      if (this.rgb = new SVG.Set(), ["r", "g", "b", "a"].forEach((function(t9) {
        this[t9] = new SVG["Func" + t9.toUpperCase()]("identity"), this.rgb.add(this[t9]), this.node.appendChild(this[t9].node);
      }).bind(this)), t8)
        for (var e5 in t8.rgb && (["r", "g", "b"].forEach((function(e6) {
          this[e6].attr(t8.rgb);
        }).bind(this)), delete t8.rgb), t8)
          this[e5].attr(t8[e5]);
    }, diffuseLighting: function(t8, e5, i18) {
      this.attr({ surfaceScale: t8, diffuseConstant: e5, kernelUnitLength: i18 });
    }, specularLighting: function(t8, e5, i18, a11) {
      this.attr({ surfaceScale: t8, diffuseConstant: e5, specularExponent: i18, kernelUnitLength: a11 });
    } }, a10 = { distantLight: function(t8, e5) {
      this.attr({ azimuth: t8, elevation: e5 });
    }, pointLight: function(t8, e5, i18) {
      this.attr({ x: t8, y: e5, z: i18 });
    }, spotLight: function(t8, e5, i18, a11, s12, r14) {
      this.attr({ x: t8, y: e5, z: i18, pointsAtX: a11, pointsAtY: s12, pointsAtZ: r14 });
    }, mergeNode: function(t8) {
      this.attr("in", t8);
    } };
    function s11(t8) {
      return Array.isArray(t8) && (t8 = new SVG.Array(t8)), t8.toString().replace(/^\s+/, "").replace(/\s+$/, "").replace(/\s+/g, " ");
    }
    function r13() {
      var t8 = function() {
      };
      for (var e5 in "function" == typeof arguments[arguments.length - 1] && (t8 = arguments[arguments.length - 1], Array.prototype.splice.call(arguments, arguments.length - 1, 1)), arguments)
        for (var i18 in arguments[e5])
          t8(arguments[e5][i18], i18, arguments[e5]);
    }
    ["r", "g", "b", "a"].forEach(function(t8) {
      a10["Func" + t8.toUpperCase()] = function(t9) {
        switch (this.attr("type", t9), t9) {
          case "table":
            this.attr("tableValues", arguments[1]);
            break;
          case "linear":
            this.attr("slope", arguments[1]), this.attr("intercept", arguments[2]);
            break;
          case "gamma":
            this.attr("amplitude", arguments[1]), this.attr("exponent", arguments[2]), this.attr("offset", arguments[2]);
        }
      };
    }), r13(e4, function(t8, e5) {
      var i18 = e5.charAt(0).toUpperCase() + e5.slice(1);
      SVG[i18 + "Effect"] = SVG.invent({ create: function() {
        this.constructor.call(this, SVG.create("fe" + i18)), t8.apply(this, arguments), this.result(this.attr("id") + "Out");
      }, inherit: SVG.Effect, extend: {} });
    }), r13(i17, function(t8, e5) {
      var i18 = e5.charAt(0).toUpperCase() + e5.slice(1);
      SVG[i18 + "Effect"] = SVG.invent({ create: function() {
        this.constructor.call(this, SVG.create("fe" + i18)), t8.apply(this, arguments), this.result(this.attr("id") + "Out");
      }, inherit: SVG.ParentEffect, extend: {} });
    }), r13(a10, function(t8, e5) {
      var i18 = e5.charAt(0).toUpperCase() + e5.slice(1);
      SVG[i18] = SVG.invent({ create: function() {
        this.constructor.call(this, SVG.create("fe" + i18)), t8.apply(this, arguments);
      }, inherit: SVG.ChildEffect, extend: {} });
    }), SVG.extend(SVG.MergeEffect, { in: function(t8) {
      return t8 instanceof SVG.MergeNode ? this.add(t8, 0) : this.add(new SVG.MergeNode(t8), 0), this;
    } }), SVG.extend(SVG.CompositeEffect, SVG.BlendEffect, SVG.DisplacementMapEffect, { in2: function(t8) {
      return null == t8 ? this.parent() && this.parent().select('[result="' + this.attr("in2") + '"]').get(0) || this.attr("in2") : this.attr("in2", t8);
    } }), SVG.filter = { sepiatone: [0.343, 0.669, 0.119, 0, 0, 0.249, 0.626, 0.13, 0, 0, 0.172, 0.334, 0.111, 0, 0, 0, 0, 0, 1, 0] };
  }).call(void 0), function() {
    function t7(t8, s12, r13, o10, n11, l8, h4) {
      for (var c7 = t8.slice(s12, r13 || h4), d9 = o10.slice(n11, l8 || h4), g7 = 0, u6 = { pos: [0, 0], start: [0, 0] }, p7 = { pos: [0, 0], start: [0, 0] }; ; ) {
        if (c7[g7] = e4.call(u6, c7[g7]), d9[g7] = e4.call(p7, d9[g7]), c7[g7][0] != d9[g7][0] || "M" == c7[g7][0] || "A" == c7[g7][0] && (c7[g7][4] != d9[g7][4] || c7[g7][5] != d9[g7][5]) ? (Array.prototype.splice.apply(c7, [g7, 1].concat(a10.call(u6, c7[g7]))), Array.prototype.splice.apply(d9, [g7, 1].concat(a10.call(p7, d9[g7])))) : (c7[g7] = i17.call(u6, c7[g7]), d9[g7] = i17.call(p7, d9[g7])), ++g7 == c7.length && g7 == d9.length)
          break;
        g7 == c7.length && c7.push(["C", u6.pos[0], u6.pos[1], u6.pos[0], u6.pos[1], u6.pos[0], u6.pos[1]]), g7 == d9.length && d9.push(["C", p7.pos[0], p7.pos[1], p7.pos[0], p7.pos[1], p7.pos[0], p7.pos[1]]);
      }
      return { start: c7, dest: d9 };
    }
    function e4(t8) {
      switch (t8[0]) {
        case "z":
        case "Z":
          t8[0] = "L", t8[1] = this.start[0], t8[2] = this.start[1];
          break;
        case "H":
          t8[0] = "L", t8[2] = this.pos[1];
          break;
        case "V":
          t8[0] = "L", t8[2] = t8[1], t8[1] = this.pos[0];
          break;
        case "T":
          t8[0] = "Q", t8[3] = t8[1], t8[4] = t8[2], t8[1] = this.reflection[1], t8[2] = this.reflection[0];
          break;
        case "S":
          t8[0] = "C", t8[6] = t8[4], t8[5] = t8[3], t8[4] = t8[2], t8[3] = t8[1], t8[2] = this.reflection[1], t8[1] = this.reflection[0];
      }
      return t8;
    }
    function i17(t8) {
      var e5 = t8.length;
      return this.pos = [t8[e5 - 2], t8[e5 - 1]], -1 != "SCQT".indexOf(t8[0]) && (this.reflection = [2 * this.pos[0] - t8[e5 - 4], 2 * this.pos[1] - t8[e5 - 3]]), t8;
    }
    function a10(t8) {
      var e5 = [t8];
      switch (t8[0]) {
        case "M":
          return this.pos = this.start = [t8[1], t8[2]], e5;
        case "L":
          t8[5] = t8[3] = t8[1], t8[6] = t8[4] = t8[2], t8[1] = this.pos[0], t8[2] = this.pos[1];
          break;
        case "Q":
          t8[6] = t8[4], t8[5] = t8[3], t8[4] = 1 * t8[4] / 3 + 2 * t8[2] / 3, t8[3] = 1 * t8[3] / 3 + 2 * t8[1] / 3, t8[2] = 1 * this.pos[1] / 3 + 2 * t8[2] / 3, t8[1] = 1 * this.pos[0] / 3 + 2 * t8[1] / 3;
          break;
        case "A":
          e5 = function(t9, e6) {
            var i18, a11, s12, r13, o10, n11, l8, h4, c7, d9, g7, u6, p7, f5, x4, b3, v5, m4, y5, w4, k4, A3, S3, C3, L4, P3, M4 = Math.abs(e6[1]), I4 = Math.abs(e6[2]), T4 = e6[3] % 360, z4 = e6[4], X3 = e6[5], E3 = e6[6], Y3 = e6[7], F3 = new SVG.Point(t9), R3 = new SVG.Point(E3, Y3), H4 = [];
            if (0 === M4 || 0 === I4 || F3.x === R3.x && F3.y === R3.y)
              return [["C", F3.x, F3.y, R3.x, R3.y, R3.x, R3.y]];
            i18 = new SVG.Point((F3.x - R3.x) / 2, (F3.y - R3.y) / 2).transform(new SVG.Matrix().rotate(T4)), (a11 = i18.x * i18.x / (M4 * M4) + i18.y * i18.y / (I4 * I4)) > 1 && (M4 *= a11 = Math.sqrt(a11), I4 *= a11);
            s12 = new SVG.Matrix().rotate(T4).scale(1 / M4, 1 / I4).rotate(-T4), F3 = F3.transform(s12), R3 = R3.transform(s12), r13 = [R3.x - F3.x, R3.y - F3.y], n11 = r13[0] * r13[0] + r13[1] * r13[1], o10 = Math.sqrt(n11), r13[0] /= o10, r13[1] /= o10, l8 = n11 < 4 ? Math.sqrt(1 - n11 / 4) : 0, z4 === X3 && (l8 *= -1);
            h4 = new SVG.Point((R3.x + F3.x) / 2 + l8 * -r13[1], (R3.y + F3.y) / 2 + l8 * r13[0]), c7 = new SVG.Point(F3.x - h4.x, F3.y - h4.y), d9 = new SVG.Point(R3.x - h4.x, R3.y - h4.y), g7 = Math.acos(c7.x / Math.sqrt(c7.x * c7.x + c7.y * c7.y)), c7.y < 0 && (g7 *= -1);
            u6 = Math.acos(d9.x / Math.sqrt(d9.x * d9.x + d9.y * d9.y)), d9.y < 0 && (u6 *= -1);
            X3 && g7 > u6 && (u6 += 2 * Math.PI);
            !X3 && g7 < u6 && (u6 -= 2 * Math.PI);
            for (f5 = Math.ceil(2 * Math.abs(g7 - u6) / Math.PI), b3 = [], v5 = g7, p7 = (u6 - g7) / f5, x4 = 4 * Math.tan(p7 / 4) / 3, k4 = 0; k4 <= f5; k4++)
              y5 = Math.cos(v5), m4 = Math.sin(v5), w4 = new SVG.Point(h4.x + y5, h4.y + m4), b3[k4] = [new SVG.Point(w4.x + x4 * m4, w4.y - x4 * y5), w4, new SVG.Point(w4.x - x4 * m4, w4.y + x4 * y5)], v5 += p7;
            for (b3[0][0] = b3[0][1].clone(), b3[b3.length - 1][2] = b3[b3.length - 1][1].clone(), s12 = new SVG.Matrix().rotate(T4).scale(M4, I4).rotate(-T4), k4 = 0, A3 = b3.length; k4 < A3; k4++)
              b3[k4][0] = b3[k4][0].transform(s12), b3[k4][1] = b3[k4][1].transform(s12), b3[k4][2] = b3[k4][2].transform(s12);
            for (k4 = 1, A3 = b3.length; k4 < A3; k4++)
              S3 = (w4 = b3[k4 - 1][2]).x, C3 = w4.y, L4 = (w4 = b3[k4][0]).x, P3 = w4.y, E3 = (w4 = b3[k4][1]).x, Y3 = w4.y, H4.push(["C", S3, C3, L4, P3, E3, Y3]);
            return H4;
          }(this.pos, t8), t8 = e5[0];
      }
      return t8[0] = "C", this.pos = [t8[5], t8[6]], this.reflection = [2 * t8[5] - t8[3], 2 * t8[6] - t8[4]], e5;
    }
    function s11(t8, e5) {
      if (false === e5)
        return false;
      for (var i18 = e5, a11 = t8.length; i18 < a11; ++i18)
        if ("M" == t8[i18][0])
          return i18;
      return false;
    }
    SVG.extend(SVG.PathArray, { morph: function(e5) {
      for (var i18 = this.value, a11 = this.parse(e5), r13 = 0, o10 = 0, n11 = false, l8 = false; false !== r13 || false !== o10; ) {
        var h4;
        n11 = s11(i18, false !== r13 && r13 + 1), l8 = s11(a11, false !== o10 && o10 + 1), false === r13 && (r13 = 0 == (h4 = new SVG.PathArray(c7.start).bbox()).height || 0 == h4.width ? i18.push(i18[0]) - 1 : i18.push(["M", h4.x + h4.width / 2, h4.y + h4.height / 2]) - 1), false === o10 && (o10 = 0 == (h4 = new SVG.PathArray(c7.dest).bbox()).height || 0 == h4.width ? a11.push(a11[0]) - 1 : a11.push(["M", h4.x + h4.width / 2, h4.y + h4.height / 2]) - 1);
        var c7 = t7(i18, r13, n11, a11, o10, l8);
        i18 = i18.slice(0, r13).concat(c7.start, false === n11 ? [] : i18.slice(n11)), a11 = a11.slice(0, o10).concat(c7.dest, false === l8 ? [] : a11.slice(l8)), r13 = false !== n11 && r13 + c7.start.length, o10 = false !== l8 && o10 + c7.dest.length;
      }
      return this.value = i18, this.destination = new SVG.PathArray(), this.destination.value = a11, this;
    } });
  }(), /*! svg.draggable.js - v2.2.2 - 2019-01-08
  * https://github.com/svgdotjs/svg.draggable.js
  * Copyright (c) 2019 Wout Fierens; Licensed MIT */
  (function() {
    function t7(t8) {
      t8.remember("_draggable", this), this.el = t8;
    }
    t7.prototype.init = function(t8, e4) {
      var i17 = this;
      this.constraint = t8, this.value = e4, this.el.on("mousedown.drag", function(t9) {
        i17.start(t9);
      }), this.el.on("touchstart.drag", function(t9) {
        i17.start(t9);
      });
    }, t7.prototype.transformPoint = function(t8, e4) {
      var i17 = (t8 = t8 || window.event).changedTouches && t8.changedTouches[0] || t8;
      return this.p.x = i17.clientX - (e4 || 0), this.p.y = i17.clientY, this.p.matrixTransform(this.m);
    }, t7.prototype.getBBox = function() {
      var t8 = this.el.bbox();
      return this.el instanceof SVG.Nested && (t8 = this.el.rbox()), (this.el instanceof SVG.G || this.el instanceof SVG.Use || this.el instanceof SVG.Nested) && (t8.x = this.el.x(), t8.y = this.el.y()), t8;
    }, t7.prototype.start = function(t8) {
      if ("click" != t8.type && "mousedown" != t8.type && "mousemove" != t8.type || 1 == (t8.which || t8.buttons)) {
        var e4 = this;
        if (this.el.fire("beforedrag", { event: t8, handler: this }), !this.el.event().defaultPrevented) {
          t8.preventDefault(), t8.stopPropagation(), this.parent = this.parent || this.el.parent(SVG.Nested) || this.el.parent(SVG.Doc), this.p = this.parent.node.createSVGPoint(), this.m = this.el.node.getScreenCTM().inverse();
          var i17, a10 = this.getBBox();
          if (this.el instanceof SVG.Text)
            switch (i17 = this.el.node.getComputedTextLength(), this.el.attr("text-anchor")) {
              case "middle":
                i17 /= 2;
                break;
              case "start":
                i17 = 0;
            }
          this.startPoints = { point: this.transformPoint(t8, i17), box: a10, transform: this.el.transform() }, SVG.on(window, "mousemove.drag", function(t9) {
            e4.drag(t9);
          }), SVG.on(window, "touchmove.drag", function(t9) {
            e4.drag(t9);
          }), SVG.on(window, "mouseup.drag", function(t9) {
            e4.end(t9);
          }), SVG.on(window, "touchend.drag", function(t9) {
            e4.end(t9);
          }), this.el.fire("dragstart", { event: t8, p: this.startPoints.point, m: this.m, handler: this });
        }
      }
    }, t7.prototype.drag = function(t8) {
      var e4 = this.getBBox(), i17 = this.transformPoint(t8), a10 = this.startPoints.box.x + i17.x - this.startPoints.point.x, s11 = this.startPoints.box.y + i17.y - this.startPoints.point.y, r13 = this.constraint, o10 = i17.x - this.startPoints.point.x, n11 = i17.y - this.startPoints.point.y;
      if (this.el.fire("dragmove", { event: t8, p: i17, m: this.m, handler: this }), this.el.event().defaultPrevented)
        return i17;
      if ("function" == typeof r13) {
        var l8 = r13.call(this.el, a10, s11, this.m);
        "boolean" == typeof l8 && (l8 = { x: l8, y: l8 }), true === l8.x ? this.el.x(a10) : false !== l8.x && this.el.x(l8.x), true === l8.y ? this.el.y(s11) : false !== l8.y && this.el.y(l8.y);
      } else
        "object" == typeof r13 && (null != r13.minX && a10 < r13.minX ? o10 = (a10 = r13.minX) - this.startPoints.box.x : null != r13.maxX && a10 > r13.maxX - e4.width && (o10 = (a10 = r13.maxX - e4.width) - this.startPoints.box.x), null != r13.minY && s11 < r13.minY ? n11 = (s11 = r13.minY) - this.startPoints.box.y : null != r13.maxY && s11 > r13.maxY - e4.height && (n11 = (s11 = r13.maxY - e4.height) - this.startPoints.box.y), null != r13.snapToGrid && (a10 -= a10 % r13.snapToGrid, s11 -= s11 % r13.snapToGrid, o10 -= o10 % r13.snapToGrid, n11 -= n11 % r13.snapToGrid), this.el instanceof SVG.G ? this.el.matrix(this.startPoints.transform).transform({ x: o10, y: n11 }, true) : this.el.move(a10, s11));
      return i17;
    }, t7.prototype.end = function(t8) {
      var e4 = this.drag(t8);
      this.el.fire("dragend", { event: t8, p: e4, m: this.m, handler: this }), SVG.off(window, "mousemove.drag"), SVG.off(window, "touchmove.drag"), SVG.off(window, "mouseup.drag"), SVG.off(window, "touchend.drag");
    }, SVG.extend(SVG.Element, { draggable: function(e4, i17) {
      "function" != typeof e4 && "object" != typeof e4 || (i17 = e4, e4 = true);
      var a10 = this.remember("_draggable") || new t7(this);
      return (e4 = void 0 === e4 || e4) ? a10.init(i17 || {}, e4) : (this.off("mousedown.drag"), this.off("touchstart.drag")), this;
    } });
  }).call(void 0), function() {
    function t7(t8) {
      this.el = t8, t8.remember("_selectHandler", this), this.pointSelection = { isSelected: false }, this.rectSelection = { isSelected: false }, this.pointsList = { lt: [0, 0], rt: ["width", 0], rb: ["width", "height"], lb: [0, "height"], t: ["width", 0], r: ["width", "height"], b: ["width", "height"], l: [0, "height"] }, this.pointCoord = function(t9, e4, i17) {
        var a10 = "string" != typeof t9 ? t9 : e4[t9];
        return i17 ? a10 / 2 : a10;
      }, this.pointCoords = function(t9, e4) {
        var i17 = this.pointsList[t9];
        return { x: this.pointCoord(i17[0], e4, "t" === t9 || "b" === t9), y: this.pointCoord(i17[1], e4, "r" === t9 || "l" === t9) };
      };
    }
    t7.prototype.init = function(t8, e4) {
      var i17 = this.el.bbox();
      this.options = {};
      var a10 = this.el.selectize.defaults.points;
      for (var s11 in this.el.selectize.defaults)
        this.options[s11] = this.el.selectize.defaults[s11], void 0 !== e4[s11] && (this.options[s11] = e4[s11]);
      var r13 = ["points", "pointsExclude"];
      for (var s11 in r13) {
        var o10 = this.options[r13[s11]];
        "string" == typeof o10 ? o10 = o10.length > 0 ? o10.split(/\s*,\s*/i) : [] : "boolean" == typeof o10 && "points" === r13[s11] && (o10 = o10 ? a10 : []), this.options[r13[s11]] = o10;
      }
      this.options.points = [a10, this.options.points].reduce(function(t9, e5) {
        return t9.filter(function(t10) {
          return e5.indexOf(t10) > -1;
        });
      }), this.options.points = [this.options.points, this.options.pointsExclude].reduce(function(t9, e5) {
        return t9.filter(function(t10) {
          return e5.indexOf(t10) < 0;
        });
      }), this.parent = this.el.parent(), this.nested = this.nested || this.parent.group(), this.nested.matrix(new SVG.Matrix(this.el).translate(i17.x, i17.y)), this.options.deepSelect && -1 !== ["line", "polyline", "polygon"].indexOf(this.el.type) ? this.selectPoints(t8) : this.selectRect(t8), this.observe(), this.cleanup();
    }, t7.prototype.selectPoints = function(t8) {
      return this.pointSelection.isSelected = t8, this.pointSelection.set || (this.pointSelection.set = this.parent.set(), this.drawPoints()), this;
    }, t7.prototype.getPointArray = function() {
      var t8 = this.el.bbox();
      return this.el.array().valueOf().map(function(e4) {
        return [e4[0] - t8.x, e4[1] - t8.y];
      });
    }, t7.prototype.drawPoints = function() {
      for (var t8 = this, e4 = this.getPointArray(), i17 = 0, a10 = e4.length; i17 < a10; ++i17) {
        var s11 = function(e5) {
          return function(i18) {
            (i18 = i18 || window.event).preventDefault ? i18.preventDefault() : i18.returnValue = false, i18.stopPropagation();
            var a11 = i18.pageX || i18.touches[0].pageX, s12 = i18.pageY || i18.touches[0].pageY;
            t8.el.fire("point", { x: a11, y: s12, i: e5, event: i18 });
          };
        }(i17), r13 = this.drawPoint(e4[i17][0], e4[i17][1]).addClass(this.options.classPoints).addClass(this.options.classPoints + "_point").on("touchstart", s11).on("mousedown", s11);
        this.pointSelection.set.add(r13);
      }
    }, t7.prototype.drawPoint = function(t8, e4) {
      var i17 = this.options.pointType;
      switch (i17) {
        case "circle":
          return this.drawCircle(t8, e4);
        case "rect":
          return this.drawRect(t8, e4);
        default:
          if ("function" == typeof i17)
            return i17.call(this, t8, e4);
          throw new Error("Unknown " + i17 + " point type!");
      }
    }, t7.prototype.drawCircle = function(t8, e4) {
      return this.nested.circle(this.options.pointSize).center(t8, e4);
    }, t7.prototype.drawRect = function(t8, e4) {
      return this.nested.rect(this.options.pointSize, this.options.pointSize).center(t8, e4);
    }, t7.prototype.updatePointSelection = function() {
      var t8 = this.getPointArray();
      this.pointSelection.set.each(function(e4) {
        this.cx() === t8[e4][0] && this.cy() === t8[e4][1] || this.center(t8[e4][0], t8[e4][1]);
      });
    }, t7.prototype.updateRectSelection = function() {
      var t8 = this, e4 = this.el.bbox();
      if (this.rectSelection.set.get(0).attr({ width: e4.width, height: e4.height }), this.options.points.length && this.options.points.map(function(i18, a10) {
        var s11 = t8.pointCoords(i18, e4);
        t8.rectSelection.set.get(a10 + 1).center(s11.x, s11.y);
      }), this.options.rotationPoint) {
        var i17 = this.rectSelection.set.length();
        this.rectSelection.set.get(i17 - 1).center(e4.width / 2, 20);
      }
    }, t7.prototype.selectRect = function(t8) {
      var e4 = this, i17 = this.el.bbox();
      function a10(t9) {
        return function(i18) {
          (i18 = i18 || window.event).preventDefault ? i18.preventDefault() : i18.returnValue = false, i18.stopPropagation();
          var a11 = i18.pageX || i18.touches[0].pageX, s12 = i18.pageY || i18.touches[0].pageY;
          e4.el.fire(t9, { x: a11, y: s12, event: i18 });
        };
      }
      if (this.rectSelection.isSelected = t8, this.rectSelection.set = this.rectSelection.set || this.parent.set(), this.rectSelection.set.get(0) || this.rectSelection.set.add(this.nested.rect(i17.width, i17.height).addClass(this.options.classRect)), this.options.points.length && this.rectSelection.set.length() < 2) {
        this.options.points.map(function(t9, s12) {
          var r14 = e4.pointCoords(t9, i17), o10 = e4.drawPoint(r14.x, r14.y).attr("class", e4.options.classPoints + "_" + t9).on("mousedown", a10(t9)).on("touchstart", a10(t9));
          e4.rectSelection.set.add(o10);
        }), this.rectSelection.set.each(function() {
          this.addClass(e4.options.classPoints);
        });
      }
      if (this.options.rotationPoint && (this.options.points && !this.rectSelection.set.get(9) || !this.options.points && !this.rectSelection.set.get(1))) {
        var s11 = function(t9) {
          (t9 = t9 || window.event).preventDefault ? t9.preventDefault() : t9.returnValue = false, t9.stopPropagation();
          var i18 = t9.pageX || t9.touches[0].pageX, a11 = t9.pageY || t9.touches[0].pageY;
          e4.el.fire("rot", { x: i18, y: a11, event: t9 });
        }, r13 = this.drawPoint(i17.width / 2, 20).attr("class", this.options.classPoints + "_rot").on("touchstart", s11).on("mousedown", s11);
        this.rectSelection.set.add(r13);
      }
    }, t7.prototype.handler = function() {
      var t8 = this.el.bbox();
      this.nested.matrix(new SVG.Matrix(this.el).translate(t8.x, t8.y)), this.rectSelection.isSelected && this.updateRectSelection(), this.pointSelection.isSelected && this.updatePointSelection();
    }, t7.prototype.observe = function() {
      var t8 = this;
      if (MutationObserver)
        if (this.rectSelection.isSelected || this.pointSelection.isSelected)
          this.observerInst = this.observerInst || new MutationObserver(function() {
            t8.handler();
          }), this.observerInst.observe(this.el.node, { attributes: true });
        else
          try {
            this.observerInst.disconnect(), delete this.observerInst;
          } catch (t9) {
          }
      else
        this.el.off("DOMAttrModified.select"), (this.rectSelection.isSelected || this.pointSelection.isSelected) && this.el.on("DOMAttrModified.select", function() {
          t8.handler();
        });
    }, t7.prototype.cleanup = function() {
      !this.rectSelection.isSelected && this.rectSelection.set && (this.rectSelection.set.each(function() {
        this.remove();
      }), this.rectSelection.set.clear(), delete this.rectSelection.set), !this.pointSelection.isSelected && this.pointSelection.set && (this.pointSelection.set.each(function() {
        this.remove();
      }), this.pointSelection.set.clear(), delete this.pointSelection.set), this.pointSelection.isSelected || this.rectSelection.isSelected || (this.nested.remove(), delete this.nested);
    }, SVG.extend(SVG.Element, { selectize: function(e4, i17) {
      return "object" == typeof e4 && (i17 = e4, e4 = true), (this.remember("_selectHandler") || new t7(this)).init(void 0 === e4 || e4, i17 || {}), this;
    } }), SVG.Element.prototype.selectize.defaults = { points: ["lt", "rt", "rb", "lb", "t", "r", "b", "l"], pointsExclude: [], classRect: "svg_select_boundingRect", classPoints: "svg_select_points", pointSize: 7, rotationPoint: true, deepSelect: false, pointType: "circle" };
  }(), function() {
    (function() {
      function t7(t8) {
        t8.remember("_resizeHandler", this), this.el = t8, this.parameters = {}, this.lastUpdateCall = null, this.p = t8.doc().node.createSVGPoint();
      }
      t7.prototype.transformPoint = function(t8, e4, i17) {
        return this.p.x = t8 - (this.offset.x - window.pageXOffset), this.p.y = e4 - (this.offset.y - window.pageYOffset), this.p.matrixTransform(i17 || this.m);
      }, t7.prototype._extractPosition = function(t8) {
        return { x: null != t8.clientX ? t8.clientX : t8.touches[0].clientX, y: null != t8.clientY ? t8.clientY : t8.touches[0].clientY };
      }, t7.prototype.init = function(t8) {
        var e4 = this;
        if (this.stop(), "stop" !== t8) {
          for (var i17 in this.options = {}, this.el.resize.defaults)
            this.options[i17] = this.el.resize.defaults[i17], void 0 !== t8[i17] && (this.options[i17] = t8[i17]);
          this.el.on("lt.resize", function(t9) {
            e4.resize(t9 || window.event);
          }), this.el.on("rt.resize", function(t9) {
            e4.resize(t9 || window.event);
          }), this.el.on("rb.resize", function(t9) {
            e4.resize(t9 || window.event);
          }), this.el.on("lb.resize", function(t9) {
            e4.resize(t9 || window.event);
          }), this.el.on("t.resize", function(t9) {
            e4.resize(t9 || window.event);
          }), this.el.on("r.resize", function(t9) {
            e4.resize(t9 || window.event);
          }), this.el.on("b.resize", function(t9) {
            e4.resize(t9 || window.event);
          }), this.el.on("l.resize", function(t9) {
            e4.resize(t9 || window.event);
          }), this.el.on("rot.resize", function(t9) {
            e4.resize(t9 || window.event);
          }), this.el.on("point.resize", function(t9) {
            e4.resize(t9 || window.event);
          }), this.update();
        }
      }, t7.prototype.stop = function() {
        return this.el.off("lt.resize"), this.el.off("rt.resize"), this.el.off("rb.resize"), this.el.off("lb.resize"), this.el.off("t.resize"), this.el.off("r.resize"), this.el.off("b.resize"), this.el.off("l.resize"), this.el.off("rot.resize"), this.el.off("point.resize"), this;
      }, t7.prototype.resize = function(t8) {
        var e4 = this;
        this.m = this.el.node.getScreenCTM().inverse(), this.offset = { x: window.pageXOffset, y: window.pageYOffset };
        var i17 = this._extractPosition(t8.detail.event);
        if (this.parameters = { type: this.el.type, p: this.transformPoint(i17.x, i17.y), x: t8.detail.x, y: t8.detail.y, box: this.el.bbox(), rotation: this.el.transform().rotation }, "text" === this.el.type && (this.parameters.fontSize = this.el.attr()["font-size"]), void 0 !== t8.detail.i) {
          var a10 = this.el.array().valueOf();
          this.parameters.i = t8.detail.i, this.parameters.pointCoords = [a10[t8.detail.i][0], a10[t8.detail.i][1]];
        }
        switch (t8.type) {
          case "lt":
            this.calc = function(t9, e5) {
              var i18 = this.snapToGrid(t9, e5);
              if (this.parameters.box.width - i18[0] > 0 && this.parameters.box.height - i18[1] > 0) {
                if ("text" === this.parameters.type)
                  return this.el.move(this.parameters.box.x + i18[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize - i18[0]);
                i18 = this.checkAspectRatio(i18), this.el.move(this.parameters.box.x + i18[0], this.parameters.box.y + i18[1]).size(this.parameters.box.width - i18[0], this.parameters.box.height - i18[1]);
              }
            };
            break;
          case "rt":
            this.calc = function(t9, e5) {
              var i18 = this.snapToGrid(t9, e5, 2);
              if (this.parameters.box.width + i18[0] > 0 && this.parameters.box.height - i18[1] > 0) {
                if ("text" === this.parameters.type)
                  return this.el.move(this.parameters.box.x - i18[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize + i18[0]);
                i18 = this.checkAspectRatio(i18, true), this.el.move(this.parameters.box.x, this.parameters.box.y + i18[1]).size(this.parameters.box.width + i18[0], this.parameters.box.height - i18[1]);
              }
            };
            break;
          case "rb":
            this.calc = function(t9, e5) {
              var i18 = this.snapToGrid(t9, e5, 0);
              if (this.parameters.box.width + i18[0] > 0 && this.parameters.box.height + i18[1] > 0) {
                if ("text" === this.parameters.type)
                  return this.el.move(this.parameters.box.x - i18[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize + i18[0]);
                i18 = this.checkAspectRatio(i18), this.el.move(this.parameters.box.x, this.parameters.box.y).size(this.parameters.box.width + i18[0], this.parameters.box.height + i18[1]);
              }
            };
            break;
          case "lb":
            this.calc = function(t9, e5) {
              var i18 = this.snapToGrid(t9, e5, 1);
              if (this.parameters.box.width - i18[0] > 0 && this.parameters.box.height + i18[1] > 0) {
                if ("text" === this.parameters.type)
                  return this.el.move(this.parameters.box.x + i18[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize - i18[0]);
                i18 = this.checkAspectRatio(i18, true), this.el.move(this.parameters.box.x + i18[0], this.parameters.box.y).size(this.parameters.box.width - i18[0], this.parameters.box.height + i18[1]);
              }
            };
            break;
          case "t":
            this.calc = function(t9, e5) {
              var i18 = this.snapToGrid(t9, e5, 2);
              if (this.parameters.box.height - i18[1] > 0) {
                if ("text" === this.parameters.type)
                  return;
                this.el.move(this.parameters.box.x, this.parameters.box.y + i18[1]).height(this.parameters.box.height - i18[1]);
              }
            };
            break;
          case "r":
            this.calc = function(t9, e5) {
              var i18 = this.snapToGrid(t9, e5, 0);
              if (this.parameters.box.width + i18[0] > 0) {
                if ("text" === this.parameters.type)
                  return;
                this.el.move(this.parameters.box.x, this.parameters.box.y).width(this.parameters.box.width + i18[0]);
              }
            };
            break;
          case "b":
            this.calc = function(t9, e5) {
              var i18 = this.snapToGrid(t9, e5, 0);
              if (this.parameters.box.height + i18[1] > 0) {
                if ("text" === this.parameters.type)
                  return;
                this.el.move(this.parameters.box.x, this.parameters.box.y).height(this.parameters.box.height + i18[1]);
              }
            };
            break;
          case "l":
            this.calc = function(t9, e5) {
              var i18 = this.snapToGrid(t9, e5, 1);
              if (this.parameters.box.width - i18[0] > 0) {
                if ("text" === this.parameters.type)
                  return;
                this.el.move(this.parameters.box.x + i18[0], this.parameters.box.y).width(this.parameters.box.width - i18[0]);
              }
            };
            break;
          case "rot":
            this.calc = function(t9, e5) {
              var i18 = t9 + this.parameters.p.x, a11 = e5 + this.parameters.p.y, s11 = Math.atan2(this.parameters.p.y - this.parameters.box.y - this.parameters.box.height / 2, this.parameters.p.x - this.parameters.box.x - this.parameters.box.width / 2), r13 = Math.atan2(a11 - this.parameters.box.y - this.parameters.box.height / 2, i18 - this.parameters.box.x - this.parameters.box.width / 2), o10 = this.parameters.rotation + 180 * (r13 - s11) / Math.PI + this.options.snapToAngle / 2;
              this.el.center(this.parameters.box.cx, this.parameters.box.cy).rotate(o10 - o10 % this.options.snapToAngle, this.parameters.box.cx, this.parameters.box.cy);
            };
            break;
          case "point":
            this.calc = function(t9, e5) {
              var i18 = this.snapToGrid(t9, e5, this.parameters.pointCoords[0], this.parameters.pointCoords[1]), a11 = this.el.array().valueOf();
              a11[this.parameters.i][0] = this.parameters.pointCoords[0] + i18[0], a11[this.parameters.i][1] = this.parameters.pointCoords[1] + i18[1], this.el.plot(a11);
            };
        }
        this.el.fire("resizestart", { dx: this.parameters.x, dy: this.parameters.y, event: t8 }), SVG.on(window, "touchmove.resize", function(t9) {
          e4.update(t9 || window.event);
        }), SVG.on(window, "touchend.resize", function() {
          e4.done();
        }), SVG.on(window, "mousemove.resize", function(t9) {
          e4.update(t9 || window.event);
        }), SVG.on(window, "mouseup.resize", function() {
          e4.done();
        });
      }, t7.prototype.update = function(t8) {
        if (t8) {
          var e4 = this._extractPosition(t8), i17 = this.transformPoint(e4.x, e4.y), a10 = i17.x - this.parameters.p.x, s11 = i17.y - this.parameters.p.y;
          this.lastUpdateCall = [a10, s11], this.calc(a10, s11), this.el.fire("resizing", { dx: a10, dy: s11, event: t8 });
        } else
          this.lastUpdateCall && this.calc(this.lastUpdateCall[0], this.lastUpdateCall[1]);
      }, t7.prototype.done = function() {
        this.lastUpdateCall = null, SVG.off(window, "mousemove.resize"), SVG.off(window, "mouseup.resize"), SVG.off(window, "touchmove.resize"), SVG.off(window, "touchend.resize"), this.el.fire("resizedone");
      }, t7.prototype.snapToGrid = function(t8, e4, i17, a10) {
        var s11;
        return void 0 !== a10 ? s11 = [(i17 + t8) % this.options.snapToGrid, (a10 + e4) % this.options.snapToGrid] : (i17 = null == i17 ? 3 : i17, s11 = [(this.parameters.box.x + t8 + (1 & i17 ? 0 : this.parameters.box.width)) % this.options.snapToGrid, (this.parameters.box.y + e4 + (2 & i17 ? 0 : this.parameters.box.height)) % this.options.snapToGrid]), t8 < 0 && (s11[0] -= this.options.snapToGrid), e4 < 0 && (s11[1] -= this.options.snapToGrid), t8 -= Math.abs(s11[0]) < this.options.snapToGrid / 2 ? s11[0] : s11[0] - (t8 < 0 ? -this.options.snapToGrid : this.options.snapToGrid), e4 -= Math.abs(s11[1]) < this.options.snapToGrid / 2 ? s11[1] : s11[1] - (e4 < 0 ? -this.options.snapToGrid : this.options.snapToGrid), this.constraintToBox(t8, e4, i17, a10);
      }, t7.prototype.constraintToBox = function(t8, e4, i17, a10) {
        var s11, r13, o10 = this.options.constraint || {};
        return void 0 !== a10 ? (s11 = i17, r13 = a10) : (s11 = this.parameters.box.x + (1 & i17 ? 0 : this.parameters.box.width), r13 = this.parameters.box.y + (2 & i17 ? 0 : this.parameters.box.height)), void 0 !== o10.minX && s11 + t8 < o10.minX && (t8 = o10.minX - s11), void 0 !== o10.maxX && s11 + t8 > o10.maxX && (t8 = o10.maxX - s11), void 0 !== o10.minY && r13 + e4 < o10.minY && (e4 = o10.minY - r13), void 0 !== o10.maxY && r13 + e4 > o10.maxY && (e4 = o10.maxY - r13), [t8, e4];
      }, t7.prototype.checkAspectRatio = function(t8, e4) {
        if (!this.options.saveAspectRatio)
          return t8;
        var i17 = t8.slice(), a10 = this.parameters.box.width / this.parameters.box.height, s11 = this.parameters.box.width + t8[0], r13 = this.parameters.box.height - t8[1], o10 = s11 / r13;
        return o10 < a10 ? (i17[1] = s11 / a10 - this.parameters.box.height, e4 && (i17[1] = -i17[1])) : o10 > a10 && (i17[0] = this.parameters.box.width - r13 * a10, e4 && (i17[0] = -i17[0])), i17;
      }, SVG.extend(SVG.Element, { resize: function(e4) {
        return (this.remember("_resizeHandler") || new t7(this)).init(e4 || {}), this;
      } }), SVG.Element.prototype.resize.defaults = { snapToAngle: 0.1, snapToGrid: 1, constraint: {}, saveAspectRatio: false };
    }).call(this);
  }(), void 0 === window.Apex && (window.Apex = {});
  var Vt = function() {
    function t7(e4) {
      a9(this, t7), this.ctx = e4, this.w = e4.w;
    }
    return r12(t7, [{ key: "initModules", value: function() {
      this.ctx.publicMethods = ["updateOptions", "updateSeries", "appendData", "appendSeries", "isSeriesHidden", "toggleSeries", "showSeries", "hideSeries", "setLocale", "resetSeries", "zoomX", "toggleDataPointSelection", "dataURI", "exportToCSV", "addXaxisAnnotation", "addYaxisAnnotation", "addPointAnnotation", "clearAnnotations", "removeAnnotation", "paper", "destroy"], this.ctx.eventList = ["click", "mousedown", "mousemove", "mouseleave", "touchstart", "touchmove", "touchleave", "mouseup", "touchend"], this.ctx.animations = new b2(this.ctx), this.ctx.axes = new J2(this.ctx), this.ctx.core = new Bt(this.ctx.el, this.ctx), this.ctx.config = new Y2({}), this.ctx.data = new B2(this.ctx), this.ctx.grid = new j2(this.ctx), this.ctx.graphics = new m3(this.ctx), this.ctx.coreUtils = new y4(this.ctx), this.ctx.crosshairs = new Q2(this.ctx), this.ctx.events = new Z2(this.ctx), this.ctx.exports = new G2(this.ctx), this.ctx.localization = new $2(this.ctx), this.ctx.options = new I3(), this.ctx.responsive = new K3(this.ctx), this.ctx.series = new W3(this.ctx), this.ctx.theme = new tt(this.ctx), this.ctx.formatters = new S2(this.ctx), this.ctx.titleSubtitle = new et(this.ctx), this.ctx.legend = new lt(this.ctx), this.ctx.toolbar = new ht(this.ctx), this.ctx.tooltip = new bt(this.ctx), this.ctx.dimensions = new ot(this.ctx), this.ctx.updateHelpers = new Gt(this.ctx), this.ctx.zoomPanSelection = new ct2(this.ctx), this.ctx.w.globals.tooltip = new bt(this.ctx);
    } }]), t7;
  }(), jt = function() {
    function t7(e4) {
      a9(this, t7), this.ctx = e4, this.w = e4.w;
    }
    return r12(t7, [{ key: "clear", value: function(t8) {
      var e4 = t8.isUpdating;
      this.ctx.zoomPanSelection && this.ctx.zoomPanSelection.destroy(), this.ctx.toolbar && this.ctx.toolbar.destroy(), this.ctx.animations = null, this.ctx.axes = null, this.ctx.annotations = null, this.ctx.core = null, this.ctx.data = null, this.ctx.grid = null, this.ctx.series = null, this.ctx.responsive = null, this.ctx.theme = null, this.ctx.formatters = null, this.ctx.titleSubtitle = null, this.ctx.legend = null, this.ctx.dimensions = null, this.ctx.options = null, this.ctx.crosshairs = null, this.ctx.zoomPanSelection = null, this.ctx.updateHelpers = null, this.ctx.toolbar = null, this.ctx.localization = null, this.ctx.w.globals.tooltip = null, this.clearDomElements({ isUpdating: e4 });
    } }, { key: "killSVG", value: function(t8) {
      t8.each(function(t9, e4) {
        this.removeClass("*"), this.off(), this.stop();
      }, true), t8.ungroup(), t8.clear();
    } }, { key: "clearDomElements", value: function(t8) {
      var e4 = this, i17 = t8.isUpdating, a10 = this.w.globals.dom.Paper.node;
      a10.parentNode && a10.parentNode.parentNode && !i17 && (a10.parentNode.parentNode.style.minHeight = "unset");
      var s11 = this.w.globals.dom.baseEl;
      s11 && this.ctx.eventList.forEach(function(t9) {
        s11.removeEventListener(t9, e4.ctx.events.documentEvent);
      });
      var r13 = this.w.globals.dom;
      if (null !== this.ctx.el)
        for (; this.ctx.el.firstChild; )
          this.ctx.el.removeChild(this.ctx.el.firstChild);
      this.killSVG(r13.Paper), r13.Paper.remove(), r13.elWrap = null, r13.elGraphical = null, r13.elLegendWrap = null, r13.elLegendForeign = null, r13.baseEl = null, r13.elGridRect = null, r13.elGridRectMask = null, r13.elGridRectMarkerMask = null, r13.elForecastMask = null, r13.elNonForecastMask = null, r13.elDefs = null;
    } }]), t7;
  }(), _t = /* @__PURE__ */ new WeakMap();
  var Ut = function() {
    function t7(e4, i17) {
      a9(this, t7), this.opts = i17, this.ctx = this, this.w = new R2(i17).init(), this.el = e4, this.w.globals.cuid = x3.randomId(), this.w.globals.chartID = this.w.config.chart.id ? x3.escapeString(this.w.config.chart.id) : this.w.globals.cuid, new Vt(this).initModules(), this.create = x3.bind(this.create, this), this.windowResizeHandler = this._windowResizeHandler.bind(this), this.parentResizeHandler = this._parentResizeCallback.bind(this);
    }
    return r12(t7, [{ key: "render", value: function() {
      var t8 = this;
      return new Promise(function(e4, i17) {
        if (null !== t8.el) {
          void 0 === Apex._chartInstances && (Apex._chartInstances = []), t8.w.config.chart.id && Apex._chartInstances.push({ id: t8.w.globals.chartID, group: t8.w.config.chart.group, chart: t8 }), t8.setLocale(t8.w.config.chart.defaultLocale);
          var a10 = t8.w.config.chart.events.beforeMount;
          "function" == typeof a10 && a10(t8, t8.w), t8.events.fireEvent("beforeMount", [t8, t8.w]), window.addEventListener("resize", t8.windowResizeHandler), function(t9, e5) {
            var i18 = false;
            if (t9.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
              var a11 = t9.getBoundingClientRect();
              "none" !== t9.style.display && 0 !== a11.width || (i18 = true);
            }
            var s12 = new ResizeObserver(function(a12) {
              i18 && e5.call(t9, a12), i18 = true;
            });
            t9.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? Array.from(t9.children).forEach(function(t10) {
              return s12.observe(t10);
            }) : s12.observe(t9), _t.set(e5, s12);
          }(t8.el.parentNode, t8.parentResizeHandler);
          var s11 = t8.el.getRootNode && t8.el.getRootNode(), r13 = x3.is("ShadowRoot", s11), o10 = t8.el.ownerDocument, n11 = r13 ? s11.getElementById("apexcharts-css") : o10.getElementById("apexcharts-css");
          if (!n11) {
            var l8;
            (n11 = document.createElement("style")).id = "apexcharts-css", n11.textContent = '@keyframes opaque {\n  0% {\n    opacity: 0\n  }\n\n  to {\n    opacity: 1\n  }\n}\n\n@keyframes resizeanim {\n\n  0%,\n  to {\n    opacity: 0\n  }\n}\n\n.apexcharts-canvas {\n  position: relative;\n  user-select: none\n}\n\n.apexcharts-canvas ::-webkit-scrollbar {\n  -webkit-appearance: none;\n  width: 6px\n}\n\n.apexcharts-canvas ::-webkit-scrollbar-thumb {\n  border-radius: 4px;\n  background-color: rgba(0, 0, 0, .5);\n  box-shadow: 0 0 1px rgba(255, 255, 255, .5);\n  -webkit-box-shadow: 0 0 1px rgba(255, 255, 255, .5)\n}\n\n.apexcharts-inner {\n  position: relative\n}\n\n.apexcharts-text tspan {\n  font-family: inherit\n}\n\nrect.legend-mouseover-inactive,\n.legend-mouseover-inactive rect,\n.legend-mouseover-inactive path,\n.legend-mouseover-inactive circle,\n.legend-mouseover-inactive line,\n.legend-mouseover-inactive text.apexcharts-yaxis-title-text,\n.legend-mouseover-inactive text.apexcharts-yaxis-label {\n  transition: .15s ease all;\n  opacity: .2\n}\n\n.apexcharts-legend-text {\n  padding-left: 15px;\n  margin-left: -15px;\n}\n\n.apexcharts-series-collapsed {\n  opacity: 0\n}\n\n.apexcharts-tooltip {\n  border-radius: 5px;\n  box-shadow: 2px 2px 6px -4px #999;\n  cursor: default;\n  font-size: 14px;\n  left: 62px;\n  opacity: 0;\n  pointer-events: none;\n  position: absolute;\n  top: 20px;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n  white-space: nowrap;\n  z-index: 12;\n  transition: .15s ease all\n}\n\n.apexcharts-tooltip.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-tooltip.apexcharts-theme-light {\n  border: 1px solid #e3e3e3;\n  background: rgba(255, 255, 255, .96)\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark {\n  color: #fff;\n  background: rgba(30, 30, 30, .8)\n}\n\n.apexcharts-tooltip * {\n  font-family: inherit\n}\n\n.apexcharts-tooltip-title {\n  padding: 6px;\n  font-size: 15px;\n  margin-bottom: 4px\n}\n\n.apexcharts-tooltip.apexcharts-theme-light .apexcharts-tooltip-title {\n  background: #eceff1;\n  border-bottom: 1px solid #ddd\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark .apexcharts-tooltip-title {\n  background: rgba(0, 0, 0, .7);\n  border-bottom: 1px solid #333\n}\n\n.apexcharts-tooltip-text-goals-value,\n.apexcharts-tooltip-text-y-value,\n.apexcharts-tooltip-text-z-value {\n  display: inline-block;\n  margin-left: 5px;\n  font-weight: 600\n}\n\n.apexcharts-tooltip-text-goals-label:empty,\n.apexcharts-tooltip-text-goals-value:empty,\n.apexcharts-tooltip-text-y-label:empty,\n.apexcharts-tooltip-text-y-value:empty,\n.apexcharts-tooltip-text-z-value:empty,\n.apexcharts-tooltip-title:empty {\n  display: none\n}\n\n.apexcharts-tooltip-text-goals-label,\n.apexcharts-tooltip-text-goals-value {\n  padding: 6px 0 5px\n}\n\n.apexcharts-tooltip-goals-group,\n.apexcharts-tooltip-text-goals-label,\n.apexcharts-tooltip-text-goals-value {\n  display: flex\n}\n\n.apexcharts-tooltip-text-goals-label:not(:empty),\n.apexcharts-tooltip-text-goals-value:not(:empty) {\n  margin-top: -6px\n}\n\n.apexcharts-tooltip-marker {\n  width: 12px;\n  height: 12px;\n  position: relative;\n  top: 0;\n  margin-right: 10px;\n  border-radius: 50%\n}\n\n.apexcharts-tooltip-series-group {\n  padding: 0 10px;\n  display: none;\n  text-align: left;\n  justify-content: left;\n  align-items: center\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active .apexcharts-tooltip-marker {\n  opacity: 1\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active,\n.apexcharts-tooltip-series-group:last-child {\n  padding-bottom: 4px\n}\n\n.apexcharts-tooltip-y-group {\n  padding: 6px 0 5px\n}\n\n.apexcharts-custom-tooltip,\n.apexcharts-tooltip-box {\n  padding: 4px 8px\n}\n\n.apexcharts-tooltip-boxPlot {\n  display: flex;\n  flex-direction: column-reverse\n}\n\n.apexcharts-tooltip-box>div {\n  margin: 4px 0\n}\n\n.apexcharts-tooltip-box span.value {\n  font-weight: 700\n}\n\n.apexcharts-tooltip-rangebar {\n  padding: 5px 8px\n}\n\n.apexcharts-tooltip-rangebar .category {\n  font-weight: 600;\n  color: #777\n}\n\n.apexcharts-tooltip-rangebar .series-name {\n  font-weight: 700;\n  display: block;\n  margin-bottom: 5px\n}\n\n.apexcharts-xaxistooltip,\n.apexcharts-yaxistooltip {\n  opacity: 0;\n  pointer-events: none;\n  color: #373d3f;\n  font-size: 13px;\n  text-align: center;\n  border-radius: 2px;\n  position: absolute;\n  z-index: 10;\n  background: #eceff1;\n  border: 1px solid #90a4ae\n}\n\n.apexcharts-xaxistooltip {\n  padding: 9px 10px;\n  transition: .15s ease all\n}\n\n.apexcharts-xaxistooltip.apexcharts-theme-dark {\n  background: rgba(0, 0, 0, .7);\n  border: 1px solid rgba(0, 0, 0, .5);\n  color: #fff\n}\n\n.apexcharts-xaxistooltip:after,\n.apexcharts-xaxistooltip:before {\n  left: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none\n}\n\n.apexcharts-xaxistooltip:after {\n  border-color: transparent;\n  border-width: 6px;\n  margin-left: -6px\n}\n\n.apexcharts-xaxistooltip:before {\n  border-color: transparent;\n  border-width: 7px;\n  margin-left: -7px\n}\n\n.apexcharts-xaxistooltip-bottom:after,\n.apexcharts-xaxistooltip-bottom:before {\n  bottom: 100%\n}\n\n.apexcharts-xaxistooltip-top:after,\n.apexcharts-xaxistooltip-top:before {\n  top: 100%\n}\n\n.apexcharts-xaxistooltip-bottom:after {\n  border-bottom-color: #eceff1\n}\n\n.apexcharts-xaxistooltip-bottom:before {\n  border-bottom-color: #90a4ae\n}\n\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:after,\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:before {\n  border-bottom-color: rgba(0, 0, 0, .5)\n}\n\n.apexcharts-xaxistooltip-top:after {\n  border-top-color: #eceff1\n}\n\n.apexcharts-xaxistooltip-top:before {\n  border-top-color: #90a4ae\n}\n\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:after,\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:before {\n  border-top-color: rgba(0, 0, 0, .5)\n}\n\n.apexcharts-xaxistooltip.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-yaxistooltip {\n  padding: 4px 10px\n}\n\n.apexcharts-yaxistooltip.apexcharts-theme-dark {\n  background: rgba(0, 0, 0, .7);\n  border: 1px solid rgba(0, 0, 0, .5);\n  color: #fff\n}\n\n.apexcharts-yaxistooltip:after,\n.apexcharts-yaxistooltip:before {\n  top: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none\n}\n\n.apexcharts-yaxistooltip:after {\n  border-color: transparent;\n  border-width: 6px;\n  margin-top: -6px\n}\n\n.apexcharts-yaxistooltip:before {\n  border-color: transparent;\n  border-width: 7px;\n  margin-top: -7px\n}\n\n.apexcharts-yaxistooltip-left:after,\n.apexcharts-yaxistooltip-left:before {\n  left: 100%\n}\n\n.apexcharts-yaxistooltip-right:after,\n.apexcharts-yaxistooltip-right:before {\n  right: 100%\n}\n\n.apexcharts-yaxistooltip-left:after {\n  border-left-color: #eceff1\n}\n\n.apexcharts-yaxistooltip-left:before {\n  border-left-color: #90a4ae\n}\n\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:after,\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:before {\n  border-left-color: rgba(0, 0, 0, .5)\n}\n\n.apexcharts-yaxistooltip-right:after {\n  border-right-color: #eceff1\n}\n\n.apexcharts-yaxistooltip-right:before {\n  border-right-color: #90a4ae\n}\n\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:after,\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:before {\n  border-right-color: rgba(0, 0, 0, .5)\n}\n\n.apexcharts-yaxistooltip.apexcharts-active {\n  opacity: 1\n}\n\n.apexcharts-yaxistooltip-hidden {\n  display: none\n}\n\n.apexcharts-xcrosshairs,\n.apexcharts-ycrosshairs {\n  pointer-events: none;\n  opacity: 0;\n  transition: .15s ease all\n}\n\n.apexcharts-xcrosshairs.apexcharts-active,\n.apexcharts-ycrosshairs.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-ycrosshairs-hidden {\n  opacity: 0\n}\n\n.apexcharts-selection-rect {\n  cursor: move\n}\n\n.svg_select_boundingRect,\n.svg_select_points_rot {\n  pointer-events: none;\n  opacity: 0;\n  visibility: hidden\n}\n\n.apexcharts-selection-rect+g .svg_select_boundingRect,\n.apexcharts-selection-rect+g .svg_select_points_rot {\n  opacity: 0;\n  visibility: hidden\n}\n\n.apexcharts-selection-rect+g .svg_select_points_l,\n.apexcharts-selection-rect+g .svg_select_points_r {\n  cursor: ew-resize;\n  opacity: 1;\n  visibility: visible\n}\n\n.svg_select_points {\n  fill: #efefef;\n  stroke: #333;\n  rx: 2\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-zoom {\n  cursor: crosshair\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-pan {\n  cursor: move\n}\n\n.apexcharts-menu-icon,\n.apexcharts-pan-icon,\n.apexcharts-reset-icon,\n.apexcharts-selection-icon,\n.apexcharts-toolbar-custom-icon,\n.apexcharts-zoom-icon,\n.apexcharts-zoomin-icon,\n.apexcharts-zoomout-icon {\n  cursor: pointer;\n  width: 20px;\n  height: 20px;\n  line-height: 24px;\n  color: #6e8192;\n  text-align: center\n}\n\n.apexcharts-menu-icon svg,\n.apexcharts-reset-icon svg,\n.apexcharts-zoom-icon svg,\n.apexcharts-zoomin-icon svg,\n.apexcharts-zoomout-icon svg {\n  fill: #6e8192\n}\n\n.apexcharts-selection-icon svg {\n  fill: #444;\n  transform: scale(.76)\n}\n\n.apexcharts-theme-dark .apexcharts-menu-icon svg,\n.apexcharts-theme-dark .apexcharts-pan-icon svg,\n.apexcharts-theme-dark .apexcharts-reset-icon svg,\n.apexcharts-theme-dark .apexcharts-selection-icon svg,\n.apexcharts-theme-dark .apexcharts-toolbar-custom-icon svg,\n.apexcharts-theme-dark .apexcharts-zoom-icon svg,\n.apexcharts-theme-dark .apexcharts-zoomin-icon svg,\n.apexcharts-theme-dark .apexcharts-zoomout-icon svg {\n  fill: #f3f4f5\n}\n\n.apexcharts-canvas .apexcharts-reset-zoom-icon.apexcharts-selected svg,\n.apexcharts-canvas .apexcharts-selection-icon.apexcharts-selected svg,\n.apexcharts-canvas .apexcharts-zoom-icon.apexcharts-selected svg {\n  fill: #008ffb\n}\n\n.apexcharts-theme-light .apexcharts-menu-icon:hover svg,\n.apexcharts-theme-light .apexcharts-reset-icon:hover svg,\n.apexcharts-theme-light .apexcharts-selection-icon:not(.apexcharts-selected):hover svg,\n.apexcharts-theme-light .apexcharts-zoom-icon:not(.apexcharts-selected):hover svg,\n.apexcharts-theme-light .apexcharts-zoomin-icon:hover svg,\n.apexcharts-theme-light .apexcharts-zoomout-icon:hover svg {\n  fill: #333\n}\n\n.apexcharts-menu-icon,\n.apexcharts-selection-icon {\n  position: relative\n}\n\n.apexcharts-reset-icon {\n  margin-left: 5px\n}\n\n.apexcharts-menu-icon,\n.apexcharts-reset-icon,\n.apexcharts-zoom-icon {\n  transform: scale(.85)\n}\n\n.apexcharts-zoomin-icon,\n.apexcharts-zoomout-icon {\n  transform: scale(.7)\n}\n\n.apexcharts-zoomout-icon {\n  margin-right: 3px\n}\n\n.apexcharts-pan-icon {\n  transform: scale(.62);\n  position: relative;\n  left: 1px;\n  top: 0\n}\n\n.apexcharts-pan-icon svg {\n  fill: #fff;\n  stroke: #6e8192;\n  stroke-width: 2\n}\n\n.apexcharts-pan-icon.apexcharts-selected svg {\n  stroke: #008ffb\n}\n\n.apexcharts-pan-icon:not(.apexcharts-selected):hover svg {\n  stroke: #333\n}\n\n.apexcharts-toolbar {\n  position: absolute;\n  z-index: 11;\n  max-width: 176px;\n  text-align: right;\n  border-radius: 3px;\n  padding: 0 6px 2px;\n  display: flex;\n  justify-content: space-between;\n  align-items: center\n}\n\n.apexcharts-menu {\n  background: #fff;\n  position: absolute;\n  top: 100%;\n  border: 1px solid #ddd;\n  border-radius: 3px;\n  padding: 3px;\n  right: 10px;\n  opacity: 0;\n  min-width: 110px;\n  transition: .15s ease all;\n  pointer-events: none\n}\n\n.apexcharts-menu.apexcharts-menu-open {\n  opacity: 1;\n  pointer-events: all;\n  transition: .15s ease all\n}\n\n.apexcharts-menu-item {\n  padding: 6px 7px;\n  font-size: 12px;\n  cursor: pointer\n}\n\n.apexcharts-theme-light .apexcharts-menu-item:hover {\n  background: #eee\n}\n\n.apexcharts-theme-dark .apexcharts-menu {\n  background: rgba(0, 0, 0, .7);\n  color: #fff\n}\n\n@media screen and (min-width:768px) {\n  .apexcharts-canvas:hover .apexcharts-toolbar {\n    opacity: 1\n  }\n}\n\n.apexcharts-canvas .apexcharts-element-hidden,\n.apexcharts-datalabel.apexcharts-element-hidden,\n.apexcharts-hide .apexcharts-series-points {\n  opacity: 0;\n}\n\n.apexcharts-hidden-element-shown {\n  opacity: 1;\n  transition: 0.25s ease all;\n}\n\n.apexcharts-datalabel,\n.apexcharts-datalabel-label,\n.apexcharts-datalabel-value,\n.apexcharts-datalabels,\n.apexcharts-pie-label {\n  cursor: default;\n  pointer-events: none\n}\n\n.apexcharts-pie-label-delay {\n  opacity: 0;\n  animation-name: opaque;\n  animation-duration: .3s;\n  animation-fill-mode: forwards;\n  animation-timing-function: ease\n}\n\n.apexcharts-radialbar-label {\n  cursor: pointer;\n}\n\n.apexcharts-annotation-rect,\n.apexcharts-area-series .apexcharts-area,\n.apexcharts-area-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,\n.apexcharts-gridline,\n.apexcharts-line,\n.apexcharts-line-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,\n.apexcharts-point-annotation-label,\n.apexcharts-radar-series path:not(.apexcharts-marker),\n.apexcharts-radar-series polygon,\n.apexcharts-toolbar svg,\n.apexcharts-tooltip .apexcharts-marker,\n.apexcharts-xaxis-annotation-label,\n.apexcharts-yaxis-annotation-label,\n.apexcharts-zoom-rect {\n  pointer-events: none\n}\n\n.apexcharts-tooltip-active .apexcharts-marker {\n  transition: .15s ease all\n}\n\n.resize-triggers {\n  animation: 1ms resizeanim;\n  visibility: hidden;\n  opacity: 0;\n  height: 100%;\n  width: 100%;\n  overflow: hidden\n}\n\n.contract-trigger:before,\n.resize-triggers,\n.resize-triggers>div {\n  content: " ";\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0\n}\n\n.resize-triggers>div {\n  height: 100%;\n  width: 100%;\n  background: #eee;\n  overflow: auto\n}\n\n.contract-trigger:before {\n  overflow: hidden;\n  width: 200%;\n  height: 200%\n}\n\n.apexcharts-bar-goals-markers {\n  pointer-events: none\n}\n\n.apexcharts-bar-shadows {\n  pointer-events: none\n}\n\n.apexcharts-rangebar-goals-markers {\n  pointer-events: none\n}';
            var h4 = (null === (l8 = t8.opts.chart) || void 0 === l8 ? void 0 : l8.nonce) || t8.w.config.chart.nonce;
            h4 && n11.setAttribute("nonce", h4), r13 ? s11.prepend(n11) : o10.head.appendChild(n11);
          }
          var c7 = t8.create(t8.w.config.series, {});
          if (!c7)
            return e4(t8);
          t8.mount(c7).then(function() {
            "function" == typeof t8.w.config.chart.events.mounted && t8.w.config.chart.events.mounted(t8, t8.w), t8.events.fireEvent("mounted", [t8, t8.w]), e4(c7);
          }).catch(function(t9) {
            i17(t9);
          });
        } else
          i17(new Error("Element not found"));
      });
    } }, { key: "create", value: function(t8, e4) {
      var i17 = this.w;
      new Vt(this).initModules();
      var a10 = this.w.globals;
      (a10.noData = false, a10.animationEnded = false, this.responsive.checkResponsiveConfig(e4), i17.config.xaxis.convertedCatToNumeric) && new E2(i17.config).convertCatToNumericXaxis(i17.config, this.ctx);
      if (null === this.el)
        return a10.animationEnded = true, null;
      if (this.core.setupElements(), "treemap" === i17.config.chart.type && (i17.config.grid.show = false, i17.config.yaxis[0].show = false), 0 === a10.svgWidth)
        return a10.animationEnded = true, null;
      var s11 = y4.checkComboSeries(t8, i17.config.chart.type);
      a10.comboCharts = s11.comboCharts, a10.comboBarCount = s11.comboBarCount;
      var r13 = t8.every(function(t9) {
        return t9.data && 0 === t9.data.length;
      });
      (0 === t8.length || r13 && a10.collapsedSeries.length < 1) && this.series.handleNoData(), this.events.setupEventHandlers(), this.data.parseData(t8), this.theme.init(), new D2(this).setGlobalMarkerSize(), this.formatters.setLabelFormatters(), this.titleSubtitle.draw(), a10.noData && a10.collapsedSeries.length !== a10.series.length && !i17.config.legend.showForSingleSeries || this.legend.init(), this.series.hasAllSeriesEqualX(), a10.axisCharts && (this.core.coreCalculations(), "category" !== i17.config.xaxis.type && this.formatters.setLabelFormatters(), this.ctx.toolbar.minX = i17.globals.minX, this.ctx.toolbar.maxX = i17.globals.maxX), this.formatters.heatmapLabelFormatters(), new y4(this).getLargestMarkerSize(), this.dimensions.plotCoords();
      var o10 = this.core.xySettings();
      this.grid.createGridMask();
      var n11 = this.core.plotChartType(t8, o10), l8 = new N3(this);
      return l8.bringForward(), i17.config.dataLabels.background.enabled && l8.dataLabelsBackground(), this.core.shiftGraphPosition(), { elGraph: n11, xyRatios: o10, dimensions: { plot: { left: i17.globals.translateX, top: i17.globals.translateY, width: i17.globals.gridWidth, height: i17.globals.gridHeight } } };
    } }, { key: "mount", value: function() {
      var t8 = this, e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, i17 = this, a10 = i17.w;
      return new Promise(function(s11, r13) {
        if (null === i17.el)
          return r13(new Error("Not enough data to display or target element not found"));
        (null === e4 || a10.globals.allSeriesCollapsed) && i17.series.handleNoData(), i17.grid = new j2(i17);
        var o10, n11, l8 = i17.grid.drawGrid();
        (i17.annotations = new T3(i17), i17.annotations.drawImageAnnos(), i17.annotations.drawTextAnnos(), "back" === a10.config.grid.position) && (l8 && a10.globals.dom.elGraphical.add(l8.el), null != l8 && null !== (o10 = l8.elGridBorders) && void 0 !== o10 && o10.node && a10.globals.dom.elGraphical.add(l8.elGridBorders));
        if (Array.isArray(e4.elGraph))
          for (var h4 = 0; h4 < e4.elGraph.length; h4++)
            a10.globals.dom.elGraphical.add(e4.elGraph[h4]);
        else
          a10.globals.dom.elGraphical.add(e4.elGraph);
        "front" === a10.config.grid.position && (l8 && a10.globals.dom.elGraphical.add(l8.el), null != l8 && null !== (n11 = l8.elGridBorders) && void 0 !== n11 && n11.node && a10.globals.dom.elGraphical.add(l8.elGridBorders));
        "front" === a10.config.xaxis.crosshairs.position && i17.crosshairs.drawXCrosshairs(), "front" === a10.config.yaxis[0].crosshairs.position && i17.crosshairs.drawYCrosshairs(), "treemap" !== a10.config.chart.type && i17.axes.drawAxis(a10.config.chart.type, l8);
        var c7 = new V3(t8.ctx, l8), d9 = new q2(t8.ctx, l8);
        if (null !== l8 && (c7.xAxisLabelCorrections(l8.xAxisTickWidth), d9.setYAxisTextAlignments(), a10.config.yaxis.map(function(t9, e5) {
          -1 === a10.globals.ignoreYAxisIndexes.indexOf(e5) && d9.yAxisTitleRotate(e5, t9.opposite);
        })), i17.annotations.drawAxesAnnotations(), !a10.globals.noData) {
          if (a10.config.tooltip.enabled && !a10.globals.noData && i17.w.globals.tooltip.drawTooltip(e4.xyRatios), a10.globals.axisCharts && (a10.globals.isXNumeric || a10.config.xaxis.convertedCatToNumeric || a10.globals.isRangeBar))
            (a10.config.chart.zoom.enabled || a10.config.chart.selection && a10.config.chart.selection.enabled || a10.config.chart.pan && a10.config.chart.pan.enabled) && i17.zoomPanSelection.init({ xyRatios: e4.xyRatios });
          else {
            var g7 = a10.config.chart.toolbar.tools;
            ["zoom", "zoomin", "zoomout", "selection", "pan", "reset"].forEach(function(t9) {
              g7[t9] = false;
            });
          }
          a10.config.chart.toolbar.show && !a10.globals.allSeriesCollapsed && i17.toolbar.createToolbar();
        }
        a10.globals.memory.methodsToExec.length > 0 && a10.globals.memory.methodsToExec.forEach(function(t9) {
          t9.method(t9.params, false, t9.context);
        }), a10.globals.axisCharts || a10.globals.noData || i17.core.resizeNonAxisCharts(), s11(i17);
      });
    } }, { key: "destroy", value: function() {
      var t8, e4;
      window.removeEventListener("resize", this.windowResizeHandler), this.el.parentNode, t8 = this.parentResizeHandler, (e4 = _t.get(t8)) && (e4.disconnect(), _t.delete(t8));
      var i17 = this.w.config.chart.id;
      i17 && Apex._chartInstances.forEach(function(t9, e5) {
        t9.id === x3.escapeString(i17) && Apex._chartInstances.splice(e5, 1);
      }), new jt(this.ctx).clear({ isUpdating: false });
    } }, { key: "updateOptions", value: function(t8) {
      var e4 = this, i17 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], a10 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], s11 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3], r13 = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4], o10 = this.w;
      return o10.globals.selection = void 0, t8.series && (this.series.resetSeries(false, true, false), t8.series.length && t8.series[0].data && (t8.series = t8.series.map(function(t9, i18) {
        return e4.updateHelpers._extendSeries(t9, i18);
      })), this.updateHelpers.revertDefaultAxisMinMax()), t8.xaxis && (t8 = this.updateHelpers.forceXAxisUpdate(t8)), t8.yaxis && (t8 = this.updateHelpers.forceYAxisUpdate(t8)), o10.globals.collapsedSeriesIndices.length > 0 && this.series.clearPreviousPaths(), t8.theme && (t8 = this.theme.updateThemeOptions(t8)), this.updateHelpers._updateOptions(t8, i17, a10, s11, r13);
    } }, { key: "updateSeries", value: function() {
      var t8 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], e4 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i17 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
      return this.series.resetSeries(false), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(t8, e4, i17);
    } }, { key: "appendSeries", value: function(t8) {
      var e4 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i17 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], a10 = this.w.config.series.slice();
      return a10.push(t8), this.series.resetSeries(false), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(a10, e4, i17);
    } }, { key: "appendData", value: function(t8) {
      var e4 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i17 = this;
      i17.w.globals.dataChanged = true, i17.series.getPreviousPaths();
      for (var a10 = i17.w.config.series.slice(), s11 = 0; s11 < a10.length; s11++)
        if (null !== t8[s11] && void 0 !== t8[s11])
          for (var r13 = 0; r13 < t8[s11].data.length; r13++)
            a10[s11].data.push(t8[s11].data[r13]);
      return i17.w.config.series = a10, e4 && (i17.w.globals.initialSeries = x3.clone(i17.w.config.series)), this.update();
    } }, { key: "update", value: function(t8) {
      var e4 = this;
      return new Promise(function(i17, a10) {
        new jt(e4.ctx).clear({ isUpdating: true });
        var s11 = e4.create(e4.w.config.series, t8);
        if (!s11)
          return i17(e4);
        e4.mount(s11).then(function() {
          "function" == typeof e4.w.config.chart.events.updated && e4.w.config.chart.events.updated(e4, e4.w), e4.events.fireEvent("updated", [e4, e4.w]), e4.w.globals.isDirty = true, i17(e4);
        }).catch(function(t9) {
          a10(t9);
        });
      });
    } }, { key: "getSyncedCharts", value: function() {
      var t8 = this.getGroupedCharts(), e4 = [this];
      return t8.length && (e4 = [], t8.forEach(function(t9) {
        e4.push(t9);
      })), e4;
    } }, { key: "getGroupedCharts", value: function() {
      var t8 = this;
      return Apex._chartInstances.filter(function(t9) {
        if (t9.group)
          return true;
      }).map(function(e4) {
        return t8.w.config.chart.group === e4.group ? e4.chart : t8;
      });
    } }, { key: "toggleSeries", value: function(t8) {
      return this.series.toggleSeries(t8);
    } }, { key: "highlightSeriesOnLegendHover", value: function(t8, e4) {
      return this.series.toggleSeriesOnHover(t8, e4);
    } }, { key: "showSeries", value: function(t8) {
      this.series.showSeries(t8);
    } }, { key: "hideSeries", value: function(t8) {
      this.series.hideSeries(t8);
    } }, { key: "isSeriesHidden", value: function(t8) {
      this.series.isSeriesHidden(t8);
    } }, { key: "resetSeries", value: function() {
      var t8 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], e4 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
      this.series.resetSeries(t8, e4);
    } }, { key: "addEventListener", value: function(t8, e4) {
      this.events.addEventListener(t8, e4);
    } }, { key: "removeEventListener", value: function(t8, e4) {
      this.events.removeEventListener(t8, e4);
    } }, { key: "addXaxisAnnotation", value: function(t8) {
      var e4 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i17 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0, a10 = this;
      i17 && (a10 = i17), a10.annotations.addXaxisAnnotationExternal(t8, e4, a10);
    } }, { key: "addYaxisAnnotation", value: function(t8) {
      var e4 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i17 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0, a10 = this;
      i17 && (a10 = i17), a10.annotations.addYaxisAnnotationExternal(t8, e4, a10);
    } }, { key: "addPointAnnotation", value: function(t8) {
      var e4 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i17 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0, a10 = this;
      i17 && (a10 = i17), a10.annotations.addPointAnnotationExternal(t8, e4, a10);
    } }, { key: "clearAnnotations", value: function() {
      var t8 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0, e4 = this;
      t8 && (e4 = t8), e4.annotations.clearAnnotations(e4);
    } }, { key: "removeAnnotation", value: function(t8) {
      var e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0, i17 = this;
      e4 && (i17 = e4), i17.annotations.removeAnnotation(i17, t8);
    } }, { key: "getChartArea", value: function() {
      return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner");
    } }, { key: "getSeriesTotalXRange", value: function(t8, e4) {
      return this.coreUtils.getSeriesTotalsXRange(t8, e4);
    } }, { key: "getHighestValueInSeries", value: function() {
      var t8 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
      return new U3(this.ctx).getMinYMaxY(t8).highestY;
    } }, { key: "getLowestValueInSeries", value: function() {
      var t8 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
      return new U3(this.ctx).getMinYMaxY(t8).lowestY;
    } }, { key: "getSeriesTotal", value: function() {
      return this.w.globals.seriesTotals;
    } }, { key: "toggleDataPointSelection", value: function(t8, e4) {
      return this.updateHelpers.toggleDataPointSelection(t8, e4);
    } }, { key: "zoomX", value: function(t8, e4) {
      this.ctx.toolbar.zoomUpdateOptions(t8, e4);
    } }, { key: "setLocale", value: function(t8) {
      this.localization.setCurrentLocaleValues(t8);
    } }, { key: "dataURI", value: function(t8) {
      return new G2(this.ctx).dataURI(t8);
    } }, { key: "exportToCSV", value: function() {
      var t8 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      return new G2(this.ctx).exportToCSV(t8);
    } }, { key: "paper", value: function() {
      return this.w.globals.dom.Paper;
    } }, { key: "_parentResizeCallback", value: function() {
      this.w.globals.animationEnded && this.w.config.chart.redrawOnParentResize && this._windowResize();
    } }, { key: "_windowResize", value: function() {
      var t8 = this;
      clearTimeout(this.w.globals.resizeTimer), this.w.globals.resizeTimer = window.setTimeout(function() {
        t8.w.globals.resized = true, t8.w.globals.dataChanged = false, t8.ctx.update();
      }, 150);
    } }, { key: "_windowResizeHandler", value: function() {
      var t8 = this.w.config.chart.redrawOnWindowResize;
      "function" == typeof t8 && (t8 = t8()), t8 && this._windowResize();
    } }], [{ key: "getChartByID", value: function(t8) {
      var e4 = x3.escapeString(t8);
      if (Apex._chartInstances) {
        var i17 = Apex._chartInstances.filter(function(t9) {
          return t9.id === e4;
        })[0];
        return i17 && i17.chart;
      }
    } }, { key: "initOnLoad", value: function() {
      for (var e4 = document.querySelectorAll("[data-apexcharts]"), i17 = 0; i17 < e4.length; i17++) {
        new t7(e4[i17], JSON.parse(e4[i17].getAttribute("data-options"))).render();
      }
    } }, { key: "exec", value: function(t8, e4) {
      var i17 = this.getChartByID(t8);
      if (i17) {
        i17.w.globals.isExecCalled = true;
        var a10 = null;
        if (-1 !== i17.publicMethods.indexOf(e4)) {
          for (var s11 = arguments.length, r13 = new Array(s11 > 2 ? s11 - 2 : 0), o10 = 2; o10 < s11; o10++)
            r13[o10 - 2] = arguments[o10];
          a10 = i17[e4].apply(i17, r13);
        }
        return a10;
      }
    } }, { key: "merge", value: function(t8, e4) {
      return x3.extend(t8, e4);
    } }]), t7;
  }();
  module.exports = Ut;
})(apexcharts_common, apexcharts_common.exports);
var apexcharts_commonExports = apexcharts_common.exports;
var _default;
Object.defineProperty(reactApexcharts_min, "__esModule", { value: true });
var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
  return typeof e3;
} : function(e3) {
  return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
}, _extends = Object.assign || function(e3) {
  for (var t6 = 1; t6 < arguments.length; t6++) {
    var r12, n10 = arguments[t6];
    for (r12 in n10)
      Object.prototype.hasOwnProperty.call(n10, r12) && (e3[r12] = n10[r12]);
  }
  return e3;
}, _createClass = function() {
  function n10(e3, t6) {
    for (var r12 = 0; r12 < t6.length; r12++) {
      var n11 = t6[r12];
      n11.enumerable = n11.enumerable || false, n11.configurable = true, "value" in n11 && (n11.writable = true), Object.defineProperty(e3, n11.key, n11);
    }
  }
  return function(e3, t6, r12) {
    return t6 && n10(e3.prototype, t6), r12 && n10(e3, r12), e3;
  };
}(), _apexcharts = apexcharts_commonExports, _apexcharts2 = _interopRequireDefault(_apexcharts), _react = reactExports, _react2 = _interopRequireDefault(_react), _propTypes = propTypesExports, _propTypes2 = _interopRequireDefault(_propTypes);
function _interopRequireDefault(e3) {
  return e3 && e3.__esModule ? e3 : { default: e3 };
}
function _defineProperty(e3, t6, r12) {
  return t6 in e3 ? Object.defineProperty(e3, t6, { value: r12, enumerable: true, configurable: true, writable: true }) : e3[t6] = r12, e3;
}
function _objectWithoutProperties(e3, t6) {
  var r12, n10 = {};
  for (r12 in e3)
    0 <= t6.indexOf(r12) || Object.prototype.hasOwnProperty.call(e3, r12) && (n10[r12] = e3[r12]);
  return n10;
}
function _classCallCheck(e3, t6) {
  if (!(e3 instanceof t6))
    throw new TypeError("Cannot call a class as a function");
}
function _possibleConstructorReturn(e3, t6) {
  if (e3)
    return !t6 || "object" != typeof t6 && "function" != typeof t6 ? e3 : t6;
  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
}
function _inherits(e3, t6) {
  if ("function" != typeof t6 && null !== t6)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
  e3.prototype = Object.create(t6 && t6.prototype, { constructor: { value: e3, enumerable: false, writable: true, configurable: true } }), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e3, t6) : e3.__proto__ = t6);
}
window.ApexCharts = _apexcharts2.default;
var Charts = function() {
  function r12(e3) {
    _classCallCheck(this, r12);
    var t6 = _possibleConstructorReturn(this, (r12.__proto__ || Object.getPrototypeOf(r12)).call(this, e3));
    return _react2.default.createRef ? t6.chartRef = _react2.default.createRef() : t6.setRef = function(e4) {
      return t6.chartRef = e4;
    }, t6.chart = null, t6;
  }
  return _inherits(r12, _react.Component), _createClass(r12, [{ key: "render", value: function() {
    var e3 = _objectWithoutProperties(this.props, []);
    return _react2.default.createElement("div", _extends({ ref: _react2.default.createRef ? this.chartRef : this.setRef }, e3));
  } }, { key: "componentDidMount", value: function() {
    var e3 = _react2.default.createRef ? this.chartRef.current : this.chartRef;
    this.chart = new _apexcharts2.default(e3, this.getConfig()), this.chart.render();
  } }, { key: "getConfig", value: function() {
    var e3 = this.props, t6 = e3.type, r13 = e3.height, n10 = e3.width, o9 = e3.series, e3 = e3.options;
    return this.extend(e3, { chart: { type: t6, height: r13, width: n10 }, series: o9 });
  } }, { key: "isObject", value: function(e3) {
    return e3 && "object" === (void 0 === e3 ? "undefined" : _typeof(e3)) && !Array.isArray(e3) && null != e3;
  } }, { key: "extend", value: function(t6, r13) {
    var n10 = this, o9 = ("function" != typeof Object.assign && (Object.assign = function(e3) {
      if (null == e3)
        throw new TypeError("Cannot convert undefined or null to object");
      for (var t7 = Object(e3), r14 = 1; r14 < arguments.length; r14++) {
        var n11 = arguments[r14];
        if (null != n11)
          for (var o10 in n11)
            n11.hasOwnProperty(o10) && (t7[o10] = n11[o10]);
      }
      return t7;
    }), Object.assign({}, t6));
    return this.isObject(t6) && this.isObject(r13) && Object.keys(r13).forEach(function(e3) {
      n10.isObject(r13[e3]) && e3 in t6 ? o9[e3] = n10.extend(t6[e3], r13[e3]) : Object.assign(o9, _defineProperty({}, e3, r13[e3]));
    }), o9;
  } }, { key: "componentDidUpdate", value: function(e3) {
    if (!this.chart)
      return null;
    var t6 = this.props, r13 = t6.options, n10 = t6.series, o9 = t6.height, t6 = t6.width, i16 = JSON.stringify(e3.options), a9 = JSON.stringify(e3.series), r13 = JSON.stringify(r13), s10 = JSON.stringify(n10);
    i16 === r13 && a9 === s10 && o9 === e3.height && t6 === e3.width || (a9 !== s10 && i16 === r13 && o9 === e3.height && t6 === e3.width ? this.chart.updateSeries(n10) : this.chart.updateOptions(this.getConfig()));
  } }, { key: "componentWillUnmount", value: function() {
    this.chart && "function" == typeof this.chart.destroy && this.chart.destroy();
  } }]), r12;
}();
(_default = reactApexcharts_min.default = Charts).propTypes = { type: _propTypes2.default.string.isRequired, width: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]), height: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]), series: _propTypes2.default.array.isRequired, options: _propTypes2.default.object.isRequired }, Charts.defaultProps = { type: "line", width: "100%", height: "auto" };
const Chart = ({ data: data2 }) => {
  const { Options, Posn, Series, Size: Size2, ChartType, Event, CSS } = data2 == null ? void 0 : data2.Properties;
  const [chartSvg, setChartSvg] = reactExports.useState(null);
  const { socket, handleData } = useAppData();
  const customStyles = parseFlexStyles(CSS);
  const styles = setStyle$1(data2 == null ? void 0 : data2.Properties);
  const chartRef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (chartRef.current) {
      setTimeout(() => {
        const chartInstance = chartRef.current.chart.paper();
        const svg = chartInstance.svg();
        if (svg) {
          setChartSvg(svg);
          localStorage.setItem(data2.ID, JSON.stringify(svg));
          handleData(
            {
              ID: data2 == null ? void 0 : data2.ID,
              Properties: {
                SVG: svg
              }
            },
            "WS"
          );
        }
      }, 500);
    }
  }, [chartRef.current]);
  const sendEvent = (event, chartContext, config2, chartConfig) => {
    var _a, _b, _c;
    const obj = {
      dataPointIndex: chartConfig == null ? void 0 : chartConfig.dataPointIndex,
      seriesIndex: chartConfig == null ? void 0 : chartConfig.seriesIndex,
      series: (_a = chartConfig == null ? void 0 : chartConfig.config) == null ? void 0 : _a.series,
      xaxis: (_b = chartConfig == null ? void 0 : chartConfig.config) == null ? void 0 : _b.xaxis,
      yaxis: (_c = chartConfig == null ? void 0 : chartConfig.config) == null ? void 0 : _c.yaxis
    };
    const Event2 = JSON.stringify({
      Event: {
        ID: data2 == null ? void 0 : data2.ID,
        EventName: event,
        // Info: [stringifyCircularJSON(chartContext), stringifyCircularJSON(config)],
        Info: [JSON.stringify(obj)]
      }
    });
    console.log(Event2);
    socket.send(Event2);
  };
  console.log("chart", chartSvg);
  const options2 = {
    ...Options,
    chart: {
      events: {
        ...(Event == null ? void 0 : Event.some((item) => item[0] === "click")) && {
          click: (chartContext, config2, chartConfig) => sendEvent("click", chartContext, config2, chartConfig)
        },
        ...(Event == null ? void 0 : Event.some((item) => item[0] === "legendclick")) && {
          legendClick: (chartContext, config2, chartConfig) => sendEvent("legendclick", chartContext, config2, chartConfig)
        }
      }
    }
    // stroke: { curve: 'smooth'}
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      style: {
        position: "absolute",
        top: Posn && Posn[0],
        left: Posn && Posn[1],
        ...styles,
        ...customStyles
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        _default,
        {
          ref: chartRef,
          options: options2,
          width: Size2 && Size2[1],
          height: Size2 && Size2[0],
          type: ChartType,
          series: Series
        }
      )
    }
  );
};
const MessageBox = "";
function PiWarningFill(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 256 256", "fill": "currentColor" }, "child": [{ "tag": "path", "attr": { "d": "M236.8,188.09,149.35,36.22h0a24.76,24.76,0,0,0-42.7,0L19.2,188.09a23.51,23.51,0,0,0,0,23.72A24.35,24.35,0,0,0,40.55,224h174.9a24.35,24.35,0,0,0,21.33-12.19A23.51,23.51,0,0,0,236.8,188.09ZM120,104a8,8,0,0,1,16,0v40a8,8,0,0,1-16,0Zm8,88a12,12,0,1,1,12-12A12,12,0,0,1,128,192Z" } }] })(props);
}
function VscError(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 16 16", "fill": "currentColor" }, "child": [{ "tag": "path", "attr": { "fillRule": "evenodd", "clipRule": "evenodd", "d": "M8.6 1c1.6.1 3.1.9 4.2 2 1.3 1.4 2 3.1 2 5.1 0 1.6-.6 3.1-1.6 4.4-1 1.2-2.4 2.1-4 2.4-1.6.3-3.2.1-4.6-.7-1.4-.8-2.5-2-3.1-3.5C.9 9.2.8 7.5 1.3 6c.5-1.6 1.4-2.9 2.8-3.8C5.4 1.3 7 .9 8.6 1zm.5 12.9c1.3-.3 2.5-1 3.4-2.1.8-1.1 1.3-2.4 1.2-3.8 0-1.6-.6-3.2-1.7-4.3-1-1-2.2-1.6-3.6-1.7-1.3-.1-2.7.2-3.8 1-1.1.8-1.9 1.9-2.3 3.3-.4 1.3-.4 2.7.2 4 .6 1.3 1.5 2.3 2.7 3 1.2.7 2.6.9 3.9.6zM7.9 7.5L10.3 5l.7.7-2.4 2.5 2.4 2.5-.7.7-2.4-2.5-2.4 2.5-.7-.7 2.4-2.5-2.4-2.5.7-.7 2.4 2.5z" } }] })(props);
}
function HiQuestionMarkCircle(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 20 20", "fill": "currentColor", "aria-hidden": "true" }, "child": [{ "tag": "path", "attr": { "fillRule": "evenodd", "d": "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z", "clipRule": "evenodd" } }] })(props);
}
const MsgBox = ({ data: data2, onClose, isDesktop, options: options2 }) => {
  const { Caption, Text: Text2, Style, Btns } = data2 == null ? void 0 : data2.Properties;
  const Icon = () => {
    switch (Style) {
      case "Info":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(FcInfo, { className: "icon info-icon" });
      case "Query":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(HiQuestionMarkCircle, { className: "icon question-icon" });
      case "Warn":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(PiWarningFill, { className: "icon warning-icon" });
      case "Error":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(VscError, { className: "icon error-icon" });
      default:
        return "";
    }
  };
  let renderCheck = options2.Desktop === 1 ? false : true;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "msgbox-overlay", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `msgbox-container ${renderCheck ? "with-border" : ""}`, children: [
    renderCheck && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "msgbox-header with-border", children: Caption }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "msgbox-body", children: [
      Style && Style !== "Msg" && /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: Text2 })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `msgbox-footer ${renderCheck ? "with-border" : ""}`, children: Array.isArray(Btns) ? Btns.map((btn, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        className: "rounded-button ",
        onClick: () => onClose(`MsgBtn${index2 + 1}`, data2 == null ? void 0 : data2.ID),
        children: btn === "OK" ? "OK" : btn.charAt(0).toUpperCase() + btn.slice(1).toLowerCase()
      },
      index2
    )) : /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        className: "rounded-button",
        onClick: () => onClose("MsgBtn1", data2 == null ? void 0 : data2.ID),
        children: Btns
      }
    ) })
  ] }) });
};
const Link = ({ data: data2 }) => {
  var _a, _b, _c;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "a",
    {
      id: data2.Properties.ID,
      href: data2.Properties.Href,
      target: ((_a = data2.Properties) == null ? void 0 : _a.Target) || "_blank",
      download: ((_b = data2.Properties) == null ? void 0 : _b.Download) === 1,
      children: ((_c = data2.Properties) == null ? void 0 : _c.Label) !== void 0 ? data2.Properties.Label : data2.Properties.Href
    }
  ) });
};
const notSupported = (serverEvent, component) => {
  const desired = serverEvent.Properties || [];
  const notInDefaults = desired.filter((k3) => !component.Defaults.hasOwnProperty(k3));
  return notInDefaults.length == 0 ? null : { NotSupported: notInDefaults };
};
const filterProps = (serverEvent, properties) => {
  const ret = {};
  serverEvent.Properties.forEach((k3) => {
    if (properties.hasOwnProperty(k3)) {
      ret[k3] = properties[k3];
    }
  });
  return ret;
};
const wgResponse = (serverEvent, component, properties) => {
  return {
    WG: {
      ID: serverEvent.ID,
      WGID: serverEvent.WGID,
      Properties: filterProps(serverEvent, { ...component.Defaults, ...properties }),
      ...notSupported(serverEvent, component)
    }
  };
};
const Upload = ({ data: data2 }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("input", { id: data2.ID, type: "file" }) });
};
Upload.Defaults = {
  LastModified: -1,
  FileName: "",
  FileSize: -1,
  FileType: "",
  FileBytes: ""
};
Upload.WG = (send, serverEvent) => {
  var _a;
  const file = (_a = document.getElementById(serverEvent.ID)) == null ? void 0 : _a.files[0];
  if (!file)
    return send(wgResponse(serverEvent, Upload, {}));
  const fileProps = {
    LastModified: file.lastModified,
    FileName: file.name,
    FileSize: file.size,
    FileType: file.type
  };
  if (!serverEvent.Properties.includes("FileBytes"))
    file = file.slice(0, 1);
  const reader = new FileReader();
  reader.onload = (event) => {
    fileProps.FileBytes = btoa(event.target.result);
    send(wgResponse(serverEvent, Upload, fileProps));
  };
  reader.onerror = (_event) => {
    send(wgResponse(serverEvent, Upload, {}));
  };
  reader.readAsArrayBuffer(file);
};
const all = "";
const KendoChart = ({ data: data2 }) => {
  const { Options, Posn, Series, Size: Size2, ChartType, Event } = data2 == null ? void 0 : data2.Properties;
  useAppData();
  const chartDefaultV4Colors = [
    "#ff6358",
    "#ffd246",
    "#78d237",
    "#28b4c8",
    "#2d73f5",
    "#aa46be"
  ];
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { position: "absolute", top: Posn && Posn[0], left: Posn && Posn[1] }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    f$d,
    {
      style: { width: Size2 && Size2[1], height: Size2 && Size2[0] },
      seriesColors: chartDefaultV4Colors,
      pannable: true,
      zoomable: true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(r$7, { children: Series.map(
        (s10, i16) => /* @__PURE__ */ jsxRuntimeExports.jsx(c$b, { data: s10.data, type: "column", name: "series-" + i16 }, i16)
      ) })
    }
  ) });
};
var isPresent = function(value2) {
  return value2 !== null && value2 !== void 0;
};
var isBlank = function(value2) {
  return value2 === null || value2 === void 0;
};
var isArray = function(value2) {
  return Array.isArray(value2);
};
var isFunction = function(value2) {
  return typeof value2 === "function";
};
var isString = function(value2) {
  return typeof value2 === "string";
};
var isNullOrEmptyString = function(value2) {
  return isBlank(value2) || value2.trim().length === 0;
};
var isNotNullOrEmptyString = function(value2) {
  return !isNullOrEmptyString(value2);
};
var isNumeric = function(value2) {
  return !isNaN(value2 - parseFloat(value2));
};
var isDate = function(value2) {
  return value2 && value2.getTime;
};
var isCompositeFilterDescriptor = function(source) {
  return isPresent(source.filters);
};
var ifElse = function(predicate, right, left) {
  return function(value2) {
    return predicate(value2) ? right(value2) : left(value2);
  };
};
var compose = function() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return function(data2) {
    return args.reduceRight(function(acc, curr) {
      return curr(acc);
    }, data2);
  };
};
var toUTC = function(date) {
  return new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
};
var isDateValue = function(x3) {
  return isDate(x3.value);
};
var operatorMap = function(key) {
  return {
    "!=": "neq",
    "<": "lt",
    "<=": "lte",
    "==": "eq",
    ">": "gt",
    ">=": "gte",
    equal: "eq",
    equals: "eq",
    equalto: "eq",
    ge: "gte",
    greater: "gt",
    greaterthan: "gt",
    greaterthanequal: "gte",
    isempty: "isempty",
    isequalto: "eq",
    isgreaterthan: "gt",
    isgreaterthanorequalto: "gte",
    islessthan: "lt",
    islessthanorequalto: "lte",
    isnotempty: "isnotempty",
    isnotequalto: "neq",
    isnull: "isnull",
    le: "lte",
    less: "lt",
    lessthan: "lt",
    lessthanequal: "lte",
    ne: "neq",
    notequal: "neq",
    notequals: "neq",
    notequalto: "neq",
    notsubstringof: "doesnotcontain"
  }[key.toLowerCase()] || key;
};
var normalizeOperator = function(descriptor) {
  if (descriptor.filters) {
    descriptor.filters = descriptor.filters.map(function(filter) {
      var result = Object.assign({}, filter);
      if (!isCompositeFilterDescriptor(filter) && isString(filter.operator)) {
        result.operator = operatorMap(filter.operator);
      }
      if (isCompositeFilterDescriptor(filter)) {
        normalizeOperator(result);
      }
      return result;
    });
  }
};
var normalizeDescriptor = function(descriptor) {
  if (!isCompositeFilterDescriptor(descriptor)) {
    return {
      filters: isArray(descriptor) ? descriptor : [descriptor],
      logic: "and"
    };
  }
  return Object.assign({}, descriptor);
};
var normalizeFilters = function(descriptor) {
  if (isPresent(descriptor)) {
    descriptor = normalizeDescriptor(descriptor);
    normalizeOperator(descriptor);
  }
  return descriptor;
};
var getterCache = {};
var FIELD_REGEX = /\[(?:(\d+)|['"](.*?)['"])\]|((?:(?!\[.*?\]|\.).)+)/g;
getterCache["undefined"] = function(obj) {
  return obj;
};
var getter = function(field, safe) {
  var key = field + safe;
  if (getterCache[key]) {
    return getterCache[key];
  }
  var fields = [];
  field.replace(FIELD_REGEX, function(_2, index2, indexAccessor, field2) {
    fields.push(isPresent(index2) ? index2 : indexAccessor || field2);
    return void 0;
  });
  getterCache[key] = function(obj) {
    var result = obj;
    for (var idx = 0; idx < fields.length; idx++) {
      result = result[fields[idx]];
      if (!isPresent(result) && safe) {
        return result;
      }
    }
    return result;
  };
  return getterCache[key];
};
var pairwise = function(key) {
  return function(value2) {
    return [key, value2];
  };
};
var empty = function() {
  return null;
};
var isNotEmptyArray = function(value2) {
  return isPresent(value2) && isArray(value2) && value2.length > 0;
};
var isNotEmpty = function(accessor) {
  return function(value2) {
    return isNotEmptyArray(accessor(value2));
  };
};
var runOrEmpty = function(predicate, fn) {
  return ifElse(predicate, fn, empty);
};
var calcPage = function(_a) {
  var skip = _a.skip, take2 = _a.take;
  return Math.floor((skip || 0) / take2) + 1;
};
var formatDescriptors = function(accessor, formatter) {
  return function(state) {
    return accessor(state).map(formatter).join("~");
  };
};
var removeAfter = function(what) {
  return function(str) {
    return str.slice(0, str.indexOf(what));
  };
};
var replace = function(patterns) {
  return compose.apply(void 0, patterns.map(function(_a) {
    var left = _a[0], right = _a[1];
    return function(s10) {
      return s10.replace(new RegExp(left, "g"), right);
    };
  }));
};
var sanitizeDateLiterals = replace([['"', ""], [":", "-"]]);
var removeAfterDot = removeAfter(".");
var directionFormatter = function(_a) {
  var field = _a.field, _b = _a.dir, dir = _b === void 0 ? "asc" : _b;
  return field + "-" + dir;
};
var aggregateFormatter = function(_a) {
  var field = _a.field, aggregate = _a.aggregate;
  return field + "-" + aggregate;
};
var take = getter("take");
var aggregates = getter("aggregates");
getter("skip");
var group = getter("group");
var sort = getter("sort", true);
var formatSort = formatDescriptors(sort, directionFormatter);
var formatGroup = formatDescriptors(group, directionFormatter);
var formatAggregates = formatDescriptors(aggregates, aggregateFormatter);
var prefixDateValue = function(value2) {
  return "datetime'" + value2 + "'";
};
var formatDateValue = compose(prefixDateValue, removeAfterDot, sanitizeDateLiterals, JSON.stringify, toUTC);
var formatDate = function(_a) {
  var field = _a.field, value2 = _a.value, ignoreCase = _a.ignoreCase, operator = _a.operator;
  return {
    value: formatDateValue(value2),
    field,
    ignoreCase,
    operator
  };
};
var normalizeSort = function(state) {
  return Object.assign({}, state, {
    sort: (sort(state) || []).filter(function(_a) {
      var dir = _a.dir;
      return isNotNullOrEmptyString(dir);
    })
  });
};
compose(pairwise("page"), calcPage);
compose(pairwise("pageSize"), take);
compose(pairwise("group"), formatGroup);
var transformSort = compose(pairwise("sort"), formatSort);
compose(pairwise("aggregate"), formatAggregates);
compose(runOrEmpty(isNotEmpty(sort), transformSort), normalizeSort);
var filterFormatter = function(_a) {
  var field = _a.field, operator = _a.operator, value2 = _a.value;
  return field + "~" + operator + "~" + value2;
};
ifElse(isDateValue, compose(filterFormatter, formatDate), filterFormatter);
var set3 = function(field, target, value2) {
  target[field] = value2;
  return target;
};
var convert = function(mapper) {
  return function(values6) {
    return Object.keys(values6).reduce(mapper.bind(null, values6), {});
  };
};
var translateAggregate = convert(function(source, acc, field) {
  return set3(field.toLowerCase(), acc, source[field]);
});
var translateAggregates = convert(function(source, acc, field) {
  return set3(field, acc, translateAggregate(source[field]));
});
var valueOrDefault = function(value2, defaultValue) {
  return isPresent(value2) ? value2 : defaultValue;
};
var normalizeGroup = function(group2) {
  return {
    aggregates: group2.Aggregates || group2.aggregates,
    field: group2.Member || group2.member || group2.field,
    hasSubgroups: group2.HasSubgroups || group2.hasSubgroups || false,
    items: group2.Items || group2.items,
    value: valueOrDefault(group2.Key, valueOrDefault(group2.key, group2.value))
  };
};
var translateGroup = compose(function(_a) {
  var field = _a.field, hasSubgroups = _a.hasSubgroups, value2 = _a.value, aggregates2 = _a.aggregates, items = _a.items;
  return {
    aggregates: translateAggregates(aggregates2),
    field,
    items: hasSubgroups ? items.map(translateGroup) : items,
    value: value2
  };
}, normalizeGroup);
var compare = function(a9, b2) {
  if (isBlank(a9)) {
    return a9 === b2 ? 0 : -1;
  }
  if (isBlank(b2)) {
    return 1;
  }
  if (a9.localeCompare) {
    return a9.localeCompare(b2);
  }
  return a9 > b2 ? 1 : a9 < b2 ? -1 : 0;
};
var compareDesc = function(a9, b2) {
  return compare(b2, a9);
};
var descriptorAsFunc = function(descriptor) {
  if (typeof descriptor.compare === "function") {
    return descriptor.compare;
  }
  var prop = getter(descriptor.field, true);
  return function(a9, b2) {
    return (descriptor.dir === "asc" ? compare : compareDesc)(prop(a9), prop(b2));
  };
};
var initial = function(_a, _b) {
  return 0;
};
var composeSortDescriptors = function(descriptors) {
  return descriptors.filter(function(x3) {
    return isPresent(x3.dir) || isPresent(x3.compare);
  }).map(function(descriptor) {
    return descriptorAsFunc(descriptor);
  }).reduce(function(acc, curr) {
    return function(a9, b2) {
      return acc(a9, b2) || curr(a9, b2);
    };
  }, initial);
};
var logic = {
  "or": {
    concat: function(acc, fn) {
      return function(a9) {
        return acc(a9) || fn(a9);
      };
    },
    identity: function() {
      return false;
    }
  },
  "and": {
    concat: function(acc, fn) {
      return function(a9) {
        return acc(a9) && fn(a9);
      };
    },
    identity: function() {
      return true;
    }
  }
};
var operatorsMap = {
  contains: function(a9, b2) {
    return (a9 || "").indexOf(b2) >= 0;
  },
  doesnotcontain: function(a9, b2) {
    return (a9 || "").indexOf(b2) === -1;
  },
  doesnotendwith: function(a9, b2) {
    return (a9 || "").indexOf(b2, (a9 || "").length - (b2 || "").length) < 0;
  },
  doesnotstartwith: function(a9, b2) {
    return (a9 || "").lastIndexOf(b2, 0) === -1;
  },
  endswith: function(a9, b2) {
    return (a9 || "").indexOf(b2, (a9 || "").length - (b2 || "").length) >= 0;
  },
  eq: function(a9, b2) {
    return a9 === b2;
  },
  gt: function(a9, b2) {
    return a9 > b2;
  },
  gte: function(a9, b2) {
    return a9 >= b2;
  },
  isempty: function(a9) {
    return a9 === "";
  },
  isnotempty: function(a9) {
    return a9 !== "";
  },
  isnotnull: function(a9) {
    return isPresent(a9);
  },
  isnull: function(a9) {
    return isBlank(a9);
  },
  lt: function(a9, b2) {
    return a9 < b2;
  },
  lte: function(a9, b2) {
    return a9 <= b2;
  },
  neq: function(a9, b2) {
    return a9 != b2;
  },
  startswith: function(a9, b2) {
    return (a9 || "").lastIndexOf(b2, 0) === 0;
  }
};
var dateRegExp = /^\/Date\((.*?)\)\/$/;
var convertValue = function(value2, ignoreCase) {
  if (value2 != null && isString(value2)) {
    var date = dateRegExp.exec(value2);
    if (date) {
      return (/* @__PURE__ */ new Date(+date[1])).getTime();
    } else if (ignoreCase) {
      return value2.toLowerCase();
    }
  } else if (value2 != null && isDate(value2)) {
    return value2.getTime();
  }
  return value2;
};
var typedGetter = function(prop, value2, ignoreCase) {
  if (!isPresent(value2)) {
    return prop;
  }
  var acc = prop;
  if (isString(value2)) {
    var date = dateRegExp.exec(value2);
    if (date) {
      value2 = /* @__PURE__ */ new Date(+date[1]);
    } else {
      acc = function(a9) {
        var x3 = prop(a9);
        if (typeof x3 === "string" && ignoreCase) {
          return x3.toLowerCase();
        } else {
          return isNumeric(x3) ? x3 + "" : x3;
        }
      };
    }
  }
  if (isDate(value2)) {
    return function(a9) {
      var x3 = acc(a9);
      return isDate(x3) ? x3.getTime() : x3;
    };
  }
  return acc;
};
var transformFilter = function(_a) {
  var field = _a.field, ignoreCase = _a.ignoreCase, value2 = _a.value, operator = _a.operator;
  field = !isPresent(field) ? function(a9) {
    return a9;
  } : field;
  ignoreCase = isPresent(ignoreCase) ? ignoreCase : true;
  var itemProp = typedGetter(isFunction(field) ? field : getter(field, true), value2, ignoreCase);
  value2 = convertValue(value2, ignoreCase);
  var op = isFunction(operator) ? operator : operatorsMap[operator];
  return function(a9) {
    return op(itemProp(a9), value2, ignoreCase);
  };
};
var transformCompositeFilter = function(filter) {
  var combiner = logic[filter.logic];
  return filter.filters.filter(isPresent).map(function(x3) {
    return isCompositeFilterDescriptor(x3) ? transformCompositeFilter(x3) : transformFilter(x3);
  }).reduce(combiner.concat, combiner.identity);
};
var compileFilter = function(descriptor) {
  if (!descriptor || descriptor.filters.length === 0) {
    return function() {
      return true;
    };
  }
  return transformCompositeFilter(descriptor);
};
var filterBy = function(data2, descriptor) {
  if (!isPresent(descriptor) || isCompositeFilterDescriptor(descriptor) && descriptor.filters.length === 0) {
    return data2;
  }
  return data2.filter(compileFilter(normalizeFilters(descriptor)));
};
var orderBy = function(data2, descriptors) {
  if (descriptors.some(function(x3) {
    return isPresent(x3.dir) || isPresent(x3.compare);
  })) {
    data2 = data2.slice(0);
    var comparer = composeSortDescriptors(descriptors);
    data2.sort(comparer);
  }
  return data2;
};
var FilterOperator;
(function(FilterOperator2) {
  FilterOperator2["Contains"] = "contains";
  FilterOperator2["DoesNotContain"] = "doesnotcontain";
  FilterOperator2["DoesNotEndWith"] = "doesnotendwith";
  FilterOperator2["DoesNotStartWith"] = "doesnotstartwith";
  FilterOperator2["EndsWith"] = "endswith";
  FilterOperator2["EqualTo"] = "eq";
  FilterOperator2["GreaterThan"] = "gt";
  FilterOperator2["GreaterThanOrEqual"] = "gte";
  FilterOperator2["IsEmpty"] = "isempty";
  FilterOperator2["IsNotEmpty"] = "isnotempty";
  FilterOperator2["IsNotNull"] = "isnotnull";
  FilterOperator2["IsNull"] = "isnull";
  FilterOperator2["LessThan"] = "lt";
  FilterOperator2["LessThanOrEqual"] = "lte";
  FilterOperator2["NotEqualTo"] = "neq";
  FilterOperator2["StartsWith"] = "startswith";
})(FilterOperator || (FilterOperator = {}));
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const e$e = "pager.info", t$d = "pager.firstPage", r$6 = "pager.previousPage", o$a = "pager.nextPage", n$c = "pager.lastPage", l$a = "pager.itemsPerPage", a$e = "pager.pageSelection", i$9 = "pager.page", s$8 = "pager.of", u$e = "pager.totalPages", p$h = "pager.pageNumberLabel", c$a = "pager.pageLabel", f$8 = "pager.ariaKeyshortcuts", g$9 = "pager.ariaLabel", O$7 = "pager.pageSizeAriaLabel", m$a = "pager.mobileSelect", M$9 = "pager.moreButtonLabel", I$b = "filter.eqOperator", b$7 = "filter.notEqOperator", L$9 = "filter.isNullOperator", F$3 = "filter.isNotNullOperator", d$f = "filter.isEmptyOperator", A$a = "filter.isNotEmptyOperator", E$8 = "filter.startsWithOperator", q$4 = "filter.containsOperator", h$5 = "filter.notContainsOperator", N$8 = "filter.endsWithOperator", P$b = "filter.gteOperator", S$8 = "filter.gtOperator", x$a = "filter.lteOperator", w$a = "filter.ltOperator", y$7 = "filter.isTrue", G$8 = "filter.isFalse", C$c = "filter.afterOrEqualOperator", B$6 = "filter.afterOperator", D$4 = "filter.beforeOperator", T$6 = "filter.beforeOrEqualOperator", W$4 = "filter.andLogic", v$5 = "filter.orLogic", z$7 = "filter.addExpression", K$5 = "filter.addGroup", R$4 = "filter.close", j$2 = "filter.groupAriaLabel", k$a = "filter.expressionAriaLabel", H$3 = "filter.expressionDropdownAriaLabel", J$5 = "filter.expressionOperatorDropdownAriaLabel", Q$4 = "filter.enumFilterDropdownAriaLabel", U$3 = "filter.numericFilterAriaLabel", V$6 = "filter.textFilterAriaLabel", X$2 = "columnMenu.filterClearButton", Y$5 = "columnMenu.filterSubmitButton", Z$4 = "columnMenu.filterTitle", _$4 = "columnMenu.sortAscending", $$8 = "columnMenu.sortDescending", ee$3 = "columnMenu.filterEqOperator", te$2 = "columnMenu.filterNotEqOperator", re$1 = "columnMenu.filterIsNullOperator", oe$2 = "columnMenu.filterIsNotNullOperator", ne$1 = "columnMenu.filterIsEmptyOperator", le$4 = "columnMenu.filterIsNotEmptyOperator", ae$2 = "columnMenu.filterStartsWithOperator", ie$1 = "columnMenu.filterContainsOperator", se$1 = "columnMenu.filterNotContainsOperator", ue$1 = "columnMenu.filterEndsWithOperator", pe$2 = "columnMenu.filterGteOperator", ce$3 = "columnMenu.filterGtOperator", fe$1 = "columnMenu.filterLteOperator", ge$1 = "columnMenu.filterLtOperator", Oe$1 = "columnMenu.filterIsTrue", me$1 = "columnMenu.filterAfterOrEqualOperator", Me = "columnMenu.filterAfterOperator", Ie$1 = "columnMenu.filterBeforeOperator", be$1 = "columnMenu.filterBeforeOrEqualOperator", Le$1 = "columnMenu.filterAndLogic", Fe = "columnMenu.filterOrLogic", de$1 = "sort.ariaLabel", Ae = "filter.ariaLabel", Ee$3 = {
  [l$a]: "items per page",
  [a$e]: "Select page",
  [e$e]: "{0} - {1} of {2} items",
  [t$d]: "Go to the first page",
  [r$6]: "Go to the previous page",
  [o$a]: "Go to the next page",
  [n$c]: "Go to the last page",
  [i$9]: "Page",
  [s$8]: "of",
  [u$e]: "{0}",
  [c$a]: "Page",
  [f$8]: "Enter ArrowRight ArrowLeft",
  [g$9]: "Pager",
  [O$7]: "Page size",
  [m$a]: "Select",
  [M$9]: "More pages",
  [p$h]: "Type a page number",
  [de$1]: "Sortable",
  [Ae]: "Filter",
  [I$b]: "Is equal to",
  [b$7]: "Is not equal to",
  [L$9]: "Is null",
  [F$3]: "Is not null",
  [d$f]: "Is empty",
  [A$a]: "Is not empty",
  [E$8]: "Starts with",
  [q$4]: "Contains",
  [h$5]: "Does not contain",
  [N$8]: "Ends with",
  [P$b]: "Is greater than or equal to",
  [S$8]: "Is greater than",
  [x$a]: "Is less than or equal to",
  [w$a]: "Is less than",
  [y$7]: "Is true",
  [G$8]: "Is false",
  [C$c]: "Is after or equal to",
  [B$6]: "Is after",
  [D$4]: "Is before",
  [T$6]: "Is before or equal to",
  [W$4]: "And",
  [v$5]: "Or",
  [z$7]: "Add Expression",
  [K$5]: "Add Group",
  [R$4]: "Remove",
  [j$2]: "Filter toolbar",
  [k$a]: "Filter expression row",
  [H$3]: "Filter dropdown",
  [J$5]: "Filter operator dropdown",
  [Q$4]: "Select True/False",
  [U$3]: "Enter number",
  [V$6]: "Enter text",
  [X$2]: "Clear",
  [Y$5]: "Filter",
  [Z$4]: "Filter",
  [_$4]: "Sort Ascending",
  [$$8]: "Sort Descending",
  [ee$3]: "Is equal to",
  [te$2]: "Is not equal to",
  [re$1]: "Is null",
  [oe$2]: "Is not null",
  [ne$1]: "Is empty",
  [le$4]: "Is not empty",
  [ae$2]: "Starts with",
  [ie$1]: "Contains",
  [se$1]: "Does not contain",
  [ue$1]: "Ends with",
  [pe$2]: "Is greater than or equal to",
  [ce$3]: "Is greater than",
  [fe$1]: "Is less than or equal to",
  [ge$1]: "Is less than",
  [Oe$1]: "Is true",
  [me$1]: "Is after or equal to",
  [Me]: "Is after",
  [Ie$1]: "Is before",
  [be$1]: "Is before or equal to",
  [Le$1]: "And",
  [Fe]: "Or"
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const k$9 = "...";
let I$a = class I extends reactExports.Component {
  constructor() {
    super(...arguments), this.handlePageChange = (e3, s10) => {
      e3.preventDefault(), this.props.pageChange(s10, e3);
    }, this.handleSelectPageChange = (e3) => {
      e3.preventDefault(), this.props.pageChange(e3.target.value, e3);
    };
  }
  render() {
    const e3 = s$k(this), { messagesMap: s10, size: a9, totalPages: g6, currentPage: r12, type: c6, navigatable: v3 } = this.props, u5 = s10 ? s10(m$a) : { messageKey: m$a, defaultMessage: Ee$3[m$a] }, m3 = s10 ? s10(i$9) : { messageKey: i$9, defaultMessage: Ee$3[i$9] }, h3 = s10 ? s10(M$9) : { messageKey: M$9, defaultMessage: Ee$3[M$9] }, b2 = e3.toLanguageString(h3.messageKey, h3.defaultMessage), C2 = this.start > 1 && this.renderDots(this.start - 1, b2), y4 = this.end < g6 && this.renderDots(this.end + 1, b2), D2 = this.start > 1 && this.renderOptionDots(this.start - 1), P2 = this.end < g6 && this.renderOptionDots(this.end + 1), o9 = [];
    for (let t6 = this.start; t6 <= this.end; t6++)
      o9.push(t6);
    const S2 = o9.map((t6) => /* @__PURE__ */ reactExports.createElement(
      p$j,
      {
        className: r$r({ "k-selected": r12 === t6 }),
        key: t6,
        fillMode: "flat",
        themeColor: "primary",
        size: a9,
        rounded: null,
        role: "button",
        "aria-label": e3.toLanguageString(m3.messageKey, m3.defaultMessage) + " " + t6,
        "aria-current": r12 === t6 ? true : void 0,
        onClick: (x3) => this.handlePageChange(x3, t6),
        tabIndex: v3 ? -1 : void 0
      },
      t6
    )), L3 = o9.map((t6) => /* @__PURE__ */ reactExports.createElement("option", { key: t6 }, t6));
    return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(
      "select",
      {
        style: { width: "5em", margin: "0px 1em", display: "inline-flex" },
        className: r$r(
          "k-picker k-dropdown-list k-dropdown k-rounded-md k-picker-solid",
          {
            [`k-picker-${e$v.sizeMap[a9] || a9}`]: a9,
            "k-hidden": c6 !== "dropdown"
          }
        ),
        "aria-label": e3.toLanguageString(u5.messageKey, u5.defaultMessage),
        value: r12,
        onChange: (t6) => this.handleSelectPageChange(t6)
      },
      D2,
      L3,
      P2
    ), /* @__PURE__ */ reactExports.createElement(
      "div",
      {
        className: "k-pager-numbers",
        style: { display: c6 === "numbers" ? "" : "none" }
      },
      C2,
      S2,
      y4
    ));
  }
  get end() {
    return Math.min(this.start + this.props.buttonCount - 1, this.props.totalPages);
  }
  get start() {
    const e3 = this.props.currentPage, s10 = this.props.buttonCount;
    if (e3 > s10) {
      const a9 = e3 % s10;
      return a9 === 0 ? e3 - s10 + 1 : e3 - a9 + 1;
    }
    return 1;
  }
  renderDots(e3, s10) {
    return /* @__PURE__ */ reactExports.createElement(
      p$j,
      {
        fillMode: "flat",
        themeColor: "primary",
        size: this.props.size,
        rounded: null,
        role: "button",
        "aria-label": s10,
        onClick: (a9) => this.handlePageChange(a9, e3),
        tabIndex: this.props.navigatable ? -1 : void 0
      },
      k$9
    );
  }
  renderOptionDots(e3) {
    return /* @__PURE__ */ reactExports.createElement("option", { value: e3 }, k$9);
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const l$9 = "labels.optional", s$7 = {
  [l$9]: "(Optional)"
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const e$d = {
  name: "@progress/kendo-react-labels",
  productName: "KendoReact",
  productCodes: ["KENDOUIREACT", "KENDOUICOMPLETE"],
  publishDate: 1728906435,
  version: "",
  licensingDocsUrl: "https://www.telerik.com/kendo-react-ui/components/my-license/"
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const i$8 = class i12 extends reactExports.Component {
  constructor(s10) {
    super(s10), this.state = {
      focused: false
    }, this.handleFocus = (a9) => {
      this.setState({ focused: true });
    }, this.handleBlur = (a9) => {
      this.setState({ focused: false });
    }, l$p(e$d);
  }
  /**
   * @hidden
   */
  render() {
    const { label: s10, editorId: a9, className: N3, labelClassName: y4, editorValue: r12, editorPlaceholder: E2, editorValid: C2, editorDisabled: n10, style: v3, id: c6, optional: F2, unstyled: d8, ...S2 } = this.props, z3 = s$k(this), p6 = F2 ? z3.toLanguageString(l$9, s$7[l$9]) : "", m3 = p6 && /* @__PURE__ */ reactExports.createElement("span", { className: "k-label-optional" }, p6), u5 = d8 && d8.uFloatingLabel, o9 = !E2 && !r12 && r12 !== 0, L3 = r$r(g$g.wrapper(
      {
        c: u5,
        focused: this.state.focused,
        empty: o9,
        notEmpty: !o9,
        disabled: n10,
        isRtl: this.props.dir === "rtl"
      }
    ), N3), h3 = r$r(g$g.label(
      {
        c: u5,
        focused: this.state.focused,
        empty: o9,
        notEmpty: !o9,
        invalid: C2 === false,
        disabled: n10
      }
    ), y4);
    return /* @__PURE__ */ reactExports.createElement(
      "span",
      {
        ...S2,
        id: this.props.id,
        className: L3,
        onFocus: this.handleFocus,
        onBlur: this.handleBlur,
        style: v3,
        dir: this.props.dir
      },
      this.props.children,
      s10 ? a9 ? /* @__PURE__ */ reactExports.createElement("label", { id: c6, htmlFor: a9, className: h3 }, s10, m3) : /* @__PURE__ */ reactExports.createElement("span", { id: c6, className: h3 }, s10, m3) : null
    );
  }
};
i$8.propTypes = {
  label: o$r.string,
  editorId: o$r.string,
  editorValue: o$r.oneOfType([o$r.string, o$r.bool, o$r.number]),
  editorPlaceholder: o$r.string,
  editorValid: o$r.bool,
  editorDisabled: o$r.bool,
  id: o$r.string,
  style: o$r.object,
  className: o$r.string,
  labelClassName: o$r.string,
  optional: o$r.bool
};
let l$8 = i$8;
v$a(l$8);
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const e$c = {
  name: "@progress/kendo-react-inputs",
  productName: "KendoReact",
  productCodes: ["KENDOUIREACT", "KENDOUICOMPLETE"],
  publishDate: 1728906503,
  version: "",
  licensingDocsUrl: "https://www.telerik.com/kendo-react-ui/components/my-license/"
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const e$b = "numerictextbox.increment", o$9 = "numerictextbox.decrement", t$c = "slider.increment", r$5 = "slider.decrement", a$d = "slider.dragTitle", n$b = "colorGradient.r", l$7 = "colorGradient.g", i$7 = "colorGradient.b", c$9 = "colorGradient.a", s$6 = "colorGradient.hex", d$e = "colorGradient.contrastRatio", u$d = "colorGradient.colorGradientAALevel", G$7 = "colorGradient.colorGradientAAALevel", A$9 = "colorGradient.colorGradientPass", g$8 = "colorGradient.colorGradientFail", p$g = "colorGradient.hueSliderLabel", C$b = "colorGradient.alphaSliderLabel", P$a = "colorGradient.toggleInputsButton", x$9 = "flatColorPicker.cancelBtn", b$6 = "flatColorPicker.applyBtn", k$8 = "flatColorPicker.colorGradientBtn", m$9 = "flatColorPicker.colorPaletteBtn", B$5 = "flatColorPicker.clearBtn", h$4 = "checkbox.validation", f$7 = "checkbox.optionalText", v$4 = "radioButton.validation", L$8 = "switch.validation", w$9 = "colorPicker.dropdownButtonAriaLabel", D$3 = "rating.ariaLabel", V$5 = "signature.clear", y$6 = "signature.maximize", z$6 = "signature.minimize", I$9 = {
  [e$b]: "Increase value",
  [o$9]: "Decrease value",
  [t$c]: "Increase",
  [r$5]: "Decrease",
  [a$d]: "Drag",
  [n$b]: "r",
  [l$7]: "g",
  [i$7]: "b",
  [c$9]: "a",
  [s$6]: "hex",
  [d$e]: "Contrast ratio",
  [u$d]: "AA",
  [G$7]: "AAA",
  [A$9]: "Pass",
  [g$8]: "Fail",
  [p$g]: "Hue slider",
  [C$b]: "Alpha slider",
  [P$a]: "Toggle colorgradient inputs",
  [x$9]: "Cancel",
  [b$6]: "Apply",
  [k$8]: "Color Gradient view",
  [m$9]: "Color Palette view",
  [B$5]: "Clear color value",
  [h$4]: "Please check this box if you want to proceed!",
  [f$7]: "(Optional)",
  [v$4]: "Please select option if you want to proceed!",
  [L$8]: "Please turn on if you want to proceed!",
  [w$9]: "Select",
  [D$3]: "Rating",
  [V$5]: "Clear",
  [y$6]: "Maximize",
  [z$6]: "Minimize"
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const M$8 = 11111111111111e-7, ae$1 = 0.31111111111111117, de = 1, Y$4 = 1, w$8 = 0, m$8 = /\d/, ee$2 = 15, Ie = () => ({
  eventValue: null,
  prevLooseValue: "",
  currentLooseValue: "",
  focused: false,
  selectionStart: void 0,
  selectionEnd: void 0,
  decimalSelect: false,
  valueIsCorrected: false,
  valueIsOutOfRange: false
}), Ne = (t6, n10) => t6 !== void 0 ? t6 : n10, p$f = (t6, n10, r12) => t6 === null && t6 === void 0 ? "" : typeof t6 == "string" ? t6 : r12.formatNumber(t6, n10), J$4 = (t6) => (String(t6).split(".")[1] || "").length, ne = (t6, n10) => Math.max(J$4(t6), J$4(n10)), ge = (t6) => Math.min(t6, ee$2), te$1 = (t6, n10) => {
  const r12 = ge(n10);
  return parseFloat(t6.toFixed(r12));
}, Ce$1 = (t6, n10, r12, e3, u5, o9, a9) => {
  const s10 = ne(t6 || 0, r12 || 0), l7 = re(te$1((t6 || 0) + (r12 || 0), s10), e3, u5);
  n10.eventValue = l7, n10.currentLooseValue = p$f(l7, o9, a9), n10.selectionStart = n10.selectionEnd = O$6(n10.currentLooseValue, m$8);
}, Ee$2 = (t6, n10, r12, e3, u5, o9, a9) => {
  const s10 = ne(t6 || 0, r12 || 0), l7 = re(te$1((t6 || 0) - (r12 || 0), s10), e3, u5);
  n10.eventValue = l7, n10.currentLooseValue = p$f(l7, o9, a9), n10.selectionStart = n10.selectionEnd = O$6(n10.currentLooseValue, m$8);
}, re = (t6, n10, r12) => t6 == null ? t6 : !(t6 > 1 || t6 < 1 || t6 === 1) || r12 !== void 0 && n10 !== void 0 && r12 < n10 ? null : (r12 !== void 0 && t6 > r12 && (t6 = r12), n10 !== void 0 && t6 < n10 && (t6 = n10), t6), fe = (t6, n10) => {
  const r12 = n10.findIndex(([u5, o9]) => !!o9 && t6.indexOf(o9) === t6.length - o9.length);
  if (r12 === -1)
    return -1;
  const e3 = n10[r12][1];
  return t6.length - e3.length;
}, me = (t6, n10) => {
  const r12 = n10.findIndex(([u5, o9]) => !!u5 && t6.indexOf(u5) === 0);
  return r12 === -1 ? -1 : n10[r12][0].length;
}, Ve = (t6, n10, r12) => {
  const e3 = fe(t6, n10);
  if (e3 !== -1 && r12.selectionStart > e3) {
    r12.selectionStart = r12.selectionEnd = e3;
    return;
  }
  r12.selectionStart > t6.length && (r12.selectionStart = r12.selectionEnd = t6.length);
  const u5 = me(t6, n10);
  u5 !== -1 && r12.selectionStart < u5 && (r12.selectionStart = r12.selectionEnd = u5), r12.selectionStart === -1 && (r12.selectionStart = r12.selectionEnd = 0);
}, L$7 = (t6, n10, r12, e3) => {
  t6.selectionStart = t6.selectionEnd = n10, Ve(r12, e3, t6);
}, A$8 = (t6, n10, r12, e3) => {
  t6.eventValue = e3.parseNumber(t6.prevLooseValue, n10), t6.currentLooseValue = t6.prevLooseValue, t6.valueIsCorrected = true, L$7(t6, t6.selectionStart, t6.currentLooseValue, r12);
}, _$3 = (t6, n10, r12) => n10.split(t6).length !== r12.split(t6).length && n10.length === r12.length + t6.length, pe$1 = (t6, n10) => {
  const r12 = String(t6.currentLooseValue), e3 = String(t6.prevLooseValue);
  return _$3(n10.minusSign, r12, e3) || _$3("-", r12, e3) || _$3("", r12, e3);
}, xe = (t6, n10) => {
  const r12 = String(t6.currentLooseValue), e3 = String(t6.prevLooseValue);
  return r12.indexOf(n10.minusSign) === -1 && e3.indexOf(n10.minusSign) !== -1;
}, Le = (t6, n10) => String(t6.currentLooseValue).split(n10.decimal).length > 2, be = (t6, n10) => {
  const r12 = n10.formatNumber(M$8, t6), e3 = n10.formatNumber(-M$8, t6), u5 = n10.formatNumber(w$8, t6), o9 = n10.formatNumber(Y$4, t6), a9 = D$2(r12), s10 = D$2(e3), l7 = D$2(u5), i16 = D$2(o9), N3 = P$9(r12), C2 = P$9(e3), x3 = P$9(u5), b2 = P$9(o9);
  return {
    positiveInfo: [a9, N3],
    negativeInfo: [s10, C2],
    zeroInfo: [l7, x3],
    oneInfo: [i16, b2]
  };
}, he$1 = (t6, n10) => {
  const r12 = n10.formatNumber(M$8, t6), e3 = n10.formatNumber(-M$8, t6), u5 = n10.formatNumber(w$8, t6), o9 = n10.formatNumber(Y$4, t6), a9 = n10.numberSymbols(), s10 = new RegExp(`[\\d\\${a9.decimal}${a9.group}]`, "g");
  return [r12, e3, u5, o9].map((i16) => i16.replace(s10, "")).join("").split("").filter((i16, N3, C2) => C2.indexOf(i16) === N3).join("");
}, B$4 = (t6, n10) => {
  const r12 = t6.indexOf(n10.decimal);
  return r12 > -1 ? r12 : O$6(t6, m$8);
}, T$5 = (t6) => t6.split("").reverse().join(""), O$6 = (t6, n10) => t6.length - T$5(t6).search(n10), D$2 = (t6) => t6.split(t6[t6.search(m$8)])[0], P$9 = (t6) => {
  const n10 = T$5(t6);
  return T$5(n10.split(n10[n10.search(m$8)])[0]);
}, $$7 = (t6, n10) => t6.search(n10), K$4 = (t6, n10) => {
  const r12 = t6.indexOf(n10);
  return r12 > -1 ? t6.length - r12 - 1 : 0;
}, Q$3 = (t6, n10, r12, e3, u5) => {
  const o9 = t6.replace(u5, "")[0] === "0", a9 = n10.replace(u5, "")[0] === "0";
  if (o9 && !a9)
    return r12 - 1;
  if (a9 && e3)
    return r12 + 1;
  let s10 = 0;
  for (let i16 = 0; i16 < r12; i16++)
    m$8.test(t6.charAt(i16)) && s10++;
  let l7 = 0;
  for (; s10 > 0 && n10.length > l7; )
    m$8.test(n10.charAt(l7)) && s10--, l7++;
  return l7;
}, Oe = (t6, n10, r12) => {
  const e3 = { ...t6 }, { prevLooseValue: u5 } = e3, o9 = r12.numberSymbols(), a9 = he$1(n10, r12), s10 = String(e3.currentLooseValue), l7 = String(u5), i16 = new RegExp(`[^\\d\\${o9.decimal}]`, "g"), N3 = new RegExp(`[^\\d\\${o9.decimal}\\${o9.group}]`, "g"), C2 = new RegExp(`[\\d\\${o9.decimal}\\${o9.group}]`), x3 = s10.replace(i16, ""), b2 = $$7(s10, m$8), E2 = b2 === -1 ? -1 : O$6(s10, m$8), oe2 = s10.indexOf(o9.decimal), G2 = (s10.substring(0, b2) + s10.substring(b2, E2).replace(N3, "") + s10.substring(E2, s10.length)).split("").filter((V3) => a9.indexOf(V3) !== -1 || V3.search(C2) !== -1).join(""), S2 = r12.formatNumber(ae$1, n10).replace(i16, ""), U3 = S2.indexOf(o9.decimal), I3 = U3 > -1 ? S2.length - U3 - 1 : 0, j2 = r12.formatNumber(de, n10).replace(i16, ""), X2 = j2.indexOf(o9.decimal), R2 = X2 > -1 ? j2.length - X2 - 1 : 0, {
    positiveInfo: se2,
    negativeInfo: ue2,
    zeroInfo: ce2,
    oneInfo: le2
  } = be(n10, r12), g6 = [se2, ue2, ce2, le2], ie2 = g6.findIndex((V3) => V3.findIndex((h3) => !!h3) !== -1) !== 1, v3 = s10.length > 0 && s10.length < l7.length, Z2 = typeof n10 == "string" && n10[0] === "p" && s10 && s10.indexOf(o9.percentSign) === -1;
  if (!e3.isPaste) {
    if (s10 === "")
      return e3.eventValue = null, e3.currentLooseValue = "", e3;
    if (e3.currentLooseValue === o9.minusSign && r12.formatNumber(-0, n10) !== l7)
      return e3.eventValue = -0, e3.currentLooseValue = p$f(e3.eventValue, n10, r12), L$7(
        e3,
        B$4(e3.currentLooseValue, o9),
        e3.currentLooseValue,
        g6
      ), e3;
    if (e3.currentLooseValue === o9.decimal) {
      e3.eventValue = 0;
      const f4 = p$f(e3.eventValue, n10, r12);
      if (R2 === 0 && I3 > 0) {
        const c6 = O$6(f4, m$8);
        e3.currentLooseValue = f4.substring(0, c6) + o9.decimal + f4.substring(c6);
      } else
        e3.currentLooseValue = f4;
      return L$7(
        e3,
        B$4(e3.currentLooseValue, o9) + 1,
        e3.currentLooseValue,
        g6
      ), e3;
    }
    if (pe$1(e3, o9)) {
      const f4 = r12.parseNumber(u5, n10);
      e3.eventValue = -(f4 !== null ? f4 : 0), e3.currentLooseValue = p$f(e3.eventValue, n10, r12);
      const c6 = $$7(e3.currentLooseValue, m$8), d8 = $$7(l7, m$8);
      return L$7(
        e3,
        e3.selectionEnd - 1 + (c6 - d8),
        e3.currentLooseValue,
        g6
      ), e3;
    }
    if (xe(e3, o9))
      return e3.eventValue = r12.parseNumber(e3.currentLooseValue, n10), L$7(
        e3,
        e3.selectionStart,
        e3.currentLooseValue,
        g6
      ), e3;
    if (Le(e3, o9))
      return A$8(e3, n10, g6, r12), e3;
    if (Z2)
      return e3.eventValue = r12.parseNumber(s10, n10) / 100, e3.currentLooseValue = p$f(e3.eventValue, n10, r12), e3;
    if (String(e3.currentLooseValue).replace(/[^\d]/g, "").length > ee$2 || x3 !== s10 && s10 && ie2 && g6.findIndex(([c6, d8]) => {
      const F2 = s10.indexOf(c6), z3 = s10.indexOf(d8), W3 = F2 === 0, k3 = z3 === s10.length - d8.length, q2 = F2 + c6.length !== b2 && b2 !== -1 && s10[F2 + c6.length] !== o9.decimal, H3 = z3 !== E2 && E2 !== -1 && s10[z3 - 1] !== o9.decimal;
      return c6 && d8 ? q2 || H3 ? false : W3 && k3 : c6 ? q2 ? false : W3 : d8 ? H3 ? false : k3 : false;
    }) === -1)
      return A$8(e3, n10, g6, r12), e3;
    if (x3[x3.length - 1] === o9.decimal && I3 > 0)
      return e3.eventValue = r12.parseNumber(s10, n10), e3.currentLooseValue = G2, e3;
    if (e3.currentLooseValue && u5 && (a9 + o9.decimal + o9.group).split("").findIndex((c6) => s10.split("").filter((d8) => d8 === c6).length < l7.split("").filter((d8) => d8 === c6).length && s10.length + 1 === l7.length ? !(c6 === o9.decimal && K$4(l7.replace(i16, ""), o9.decimal) === 0) : false) > -1)
      return e3.eventValue = r12.parseNumber(t6.prevLooseValue, n10), e3.currentLooseValue = t6.prevLooseValue, e3;
    const h3 = K$4(x3, o9.decimal), y4 = x3[x3.length - 1] === "0";
    if (v3 && y4 && h3 < R2)
      return e3.eventValue = r12.parseNumber(e3.currentLooseValue, n10), e3.currentLooseValue = p$f(e3.eventValue, n10, r12), e3;
    if (h3 > 0) {
      const f4 = s10.substring(0, oe2);
      if (y4 && (!f4 || l7.indexOf(f4) !== 0)) {
        e3.eventValue = r12.parseNumber(e3.currentLooseValue, n10);
        const c6 = p$f(e3.eventValue, n10, r12);
        return L$7(
          e3,
          Q$3(s10, c6, e3.selectionEnd, v3, i16),
          c6,
          g6
        ), e3.currentLooseValue = c6, e3;
      }
      if (h3 > I3) {
        const c6 = s10.indexOf(o9.decimal), d8 = s10.substring(0, c6) + s10.substring(c6, c6 + 1 + I3) + s10.substring(E2, String(e3.currentLooseValue).length);
        return e3.eventValue = r12.parseNumber(d8, n10), e3.currentLooseValue = d8, L$7(e3, e3.selectionStart, d8, g6), e3;
      }
      if (R2 !== I3 && h3 <= I3 && y4)
        return e3.eventValue = r12.parseNumber(e3.currentLooseValue, n10), e3.currentLooseValue = G2, e3;
      if (h3 < R2)
        return e3.eventValue = r12.parseNumber(e3.currentLooseValue, n10), e3.currentLooseValue = p$f(e3.eventValue, n10, r12), e3;
    }
  }
  if (e3.eventValue = r12.parseNumber(e3.currentLooseValue, n10), Z2 && (e3.eventValue = e3.eventValue / 100), typeof e3.eventValue == "number") {
    const V3 = p$f(e3.eventValue, n10, r12);
    s10.length === 1 ? L$7(e3, B$4(V3, o9), V3, g6) : L$7(
      e3,
      Q$3(s10, V3, e3.selectionEnd, v3, i16),
      V3,
      g6
    ), e3.currentLooseValue = V3;
  } else
    e3.currentLooseValue = p$f(r12.parseNumber(x3), n10, r12);
  return e3;
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const ct = "Please enter a valid value!", dt = a$v(), Ee$1 = reactExports.forwardRef((C2, Se2) => {
  l$p(e$c);
  const j2 = n$u(dt, C2), {
    className: xe2,
    value: b2,
    defaultValue: he2,
    format: l7,
    width: Z2,
    tabIndex: Ie$12,
    accessKey: Oe$12,
    title: Le2,
    placeholder: ee2,
    min: c6,
    max: d8,
    dir: te2,
    name: A2,
    label: I3,
    id: Pe2,
    ariaDescribedBy: Ne$12,
    ariaLabelledBy: De2,
    ariaLabel: Re2,
    inputType: Fe2,
    readOnly: g6,
    validationMessage: _2,
    children: Be2,
    style: ne2,
    inputStyle: Me2,
    valid: H3,
    step: v3 = u$c.step,
    spinners: Te2 = u$c.spinners,
    disabled: o9 = u$c.disabled,
    required: O2 = u$c.required,
    validityStyles: re$12 = u$c.validityStyles,
    prefix: ze = u$c.prefix,
    suffix: qe2 = u$c.suffix,
    onChange: E2 = u$c.onChange,
    onFocus: ae2 = u$c.onFocus,
    onBlur: le2 = u$c.onBlur,
    rangeOnEnter: se2 = u$c.rangeOnEnter,
    size: K3 = u$c.size,
    rounded: w3 = u$c.rounded,
    fillMode: L3 = u$c.fillMode,
    autoFocus: Ge2 = u$c.autoFocus,
    ...oe2
  } = j2, je2 = m$m(), ue2 = Pe2 || je2, s10 = e$s(), P2 = a$r(), a9 = reactExports.useRef(null), N3 = reactExports.useRef(), [Ae2, S2] = reactExports.useState(false), i16 = reactExports.useRef(Ie()), D2 = reactExports.useRef(false), U3 = reactExports.useRef(), x3 = reactExports.useRef(he2), h3 = p$f(
    i16.current.focused && !o9 ? i16.current.currentLooseValue : Ne(b2, x3.current),
    l7,
    s10
  );
  U3.current = h3;
  const [_e2] = s$p(ze), [He2] = s$p(qe2);
  reactExports.useEffect(
    () => {
      a9.current && a9.current.setCustomValidity && a9.current.setCustomValidity(
        B2().valid ? "" : _2 || ct
      );
    }
  );
  const ie2 = reactExports.useCallback(
    () => {
      a9.current && a9.current.focus();
    },
    []
  ), R2 = reactExports.useCallback(
    () => N3.current !== void 0 ? N3.current : Ne(b2, x3.current),
    [b2]
  ), ce2 = reactExports.useCallback(
    () => A2,
    [A2]
  ), F2 = reactExports.useCallback(
    () => O2,
    [O2]
  ), B2 = reactExports.useCallback(
    () => {
      const r12 = _2 !== void 0, e3 = R2(), V3 = H3 !== void 0 ? H3 : !i16.current.valueIsOutOfRange && (!F2() || e3 != null);
      return {
        customError: r12,
        valid: V3,
        valueMissing: e3 == null
      };
    },
    [_2, H3, R2, F2]
  ), $2 = reactExports.useCallback(
    () => re$12,
    [re$12]
  ), de2 = reactExports.useCallback(
    () => j2,
    [j2]
  ), y4 = reactExports.useCallback(
    () => {
      const r12 = {
        element: a9.current,
        focus: ie2
      };
      return Object.defineProperty(r12, "name", { get: ce2 }), Object.defineProperty(r12, "value", { get: R2 }), Object.defineProperty(r12, "validity", { get: B2 }), Object.defineProperty(r12, "validityStyles", { get: $2 }), Object.defineProperty(r12, "required", { get: F2 }), Object.defineProperty(r12, "props", { get: de2 }), r12;
    },
    [ce2, R2, B2, $2, F2, ie2, de2]
  );
  reactExports.useImperativeHandle(Se2, y4);
  const f4 = reactExports.useCallback(
    () => ({
      eventValue: Ne(b2, x3.current),
      prevLooseValue: U3.current,
      currentLooseValue: a9.current.value,
      selectionStart: a9.current.selectionStart,
      selectionEnd: a9.current.selectionEnd,
      decimalSelect: false,
      valueIsCorrected: false,
      valueIsOutOfRange: false,
      isPaste: D2.current,
      focused: i16.current.focused
    }),
    [b2]
  ), p6 = reactExports.useCallback(
    (r12, e3) => {
      if (o9)
        return;
      N3.current = e3.eventValue, x3.current = e3.eventValue;
      const V3 = p$f(re(e3.eventValue, c6, d8), l7, s10), m3 = re(s10.parseNumber(V3, l7), c6, d8);
      m3 !== e3.eventValue && (e3.valueIsOutOfRange = true, e3.eventValue = m3, x3.current = m3), b2 !== e3.eventValue && c$o(
        E2,
        r12,
        y4(),
        { value: e3.eventValue }
      ), N3.current = void 0, i16.current = e3, S2((J2) => !J2);
    },
    [b2, E2, o9, S2, y4]
  ), Ke2 = reactExports.useCallback(
    (r12) => {
      const e3 = f4();
      D2.current = false, p6(r12, Oe(e3, l7, s10));
    },
    [l7, E2, s10, p6, f4]
  ), we2 = reactExports.useCallback(
    (r12) => {
      let e3 = f4();
      const V3 = s10.parseNumber(String(e3.currentLooseValue), l7);
      if (e3.selectionEnd > e3.selectionStart && e3.selectionEnd - e3.selectionStart === String(e3.currentLooseValue).length) {
        const m3 = s10.numberSymbols(), k3 = m3 && r12.key === m3.minusSign, J2 = m3 && r12.key === m3.decimal;
        D2.current = !k3 && !J2;
        return;
      }
      switch (r12.keyCode) {
        case 38:
          Ce$1(
            V3,
            e3,
            v3,
            c6,
            d8,
            l7,
            s10
          );
          break;
        case 40:
          Ee$2(
            V3,
            e3,
            v3,
            c6,
            d8,
            l7,
            s10
          );
          break;
        case 13: {
          if (se2 === false)
            return;
          const m3 = p$f(re(V3, c6, d8), l7, s10), k3 = re(s10.parseNumber(m3, l7), c6, d8);
          e3.eventValue = k3, e3.currentLooseValue = p$f(k3, l7, s10), e3.selectionStart = e3.selectionEnd = e3.currentLooseValue.length;
          break;
        }
        case 110: {
          const m3 = a9.current, k3 = s10.numberSymbols();
          m3 && (e3.currentLooseValue = e3.currentLooseValue.slice(0, e3.selectionStart) + k3.decimal + e3.currentLooseValue.slice(e3.selectionEnd), e3.selectionStart = e3.selectionEnd = e3.selectionStart + 1, e3 = Oe(e3, l7, s10));
          break;
        }
        default:
          return;
      }
      r12.preventDefault(), p6(r12, e3);
    },
    [l7, c6, d8, v3, E2, se2, p6, f4]
  ), Ue2 = reactExports.useCallback(
    () => {
      D2.current = true;
    },
    []
  ), W3 = reactExports.useCallback(
    (r12) => {
      if (g6 || o9)
        return;
      const e3 = f4();
      Ce$1(
        s10.parseNumber(String(e3.currentLooseValue), l7),
        e3,
        v3,
        c6,
        d8,
        l7,
        s10
      ), p6(r12, e3);
    },
    [l7, c6, d8, v3, E2, g6, o9, p6, f4]
  ), Y2 = reactExports.useCallback(
    (r12) => {
      if (g6 || o9)
        return;
      const e3 = f4();
      Ee$2(
        s10.parseNumber(String(e3.currentLooseValue), l7),
        e3,
        v3,
        c6,
        d8,
        l7,
        s10
      ), p6(r12, e3);
    },
    [l7, c6, d8, v3, E2, g6, o9, p6, f4]
  ), $e2 = reactExports.useCallback(
    (r12) => {
      const e3 = o$k(document);
      !document || e3 !== a9.current || !a9.current || g6 || o9 || (r12.nativeEvent.deltaY < 0 && W3(r12), r12.nativeEvent.deltaY > 0 && Y2(r12));
    },
    [W3, Y2, o9, g6]
  ), We2 = reactExports.useCallback(
    (r12) => {
      i16.current.currentLooseValue = U3.current, i16.current.focused = true, c$o(
        ae2,
        r12,
        y4(),
        {}
      ), S2((e3) => !e3);
    },
    [ae2, S2, y4]
  ), Ye2 = reactExports.useCallback(
    (r12) => {
      i16.current = Ie(), c$o(
        le2,
        r12,
        y4(),
        {}
      ), S2((e3) => !e3);
    },
    [le2, S2, y4]
  ), Je2 = reactExports.useCallback(
    (r12) => {
      if (document && a9.current) {
        const e3 = o$k(document);
        r12.preventDefault(), e3 !== a9.current && a9.current.focus();
      }
    },
    []
  );
  t$l(
    () => {
      a9.current && a9.current.type !== "number" && i16.current.selectionStart !== void 0 && i16.current.selectionEnd !== void 0 && (a9.current.selectionStart = i16.current.selectionStart, a9.current.selectionEnd = i16.current.selectionEnd, i16.current.selectionStart = void 0, i16.current.selectionEnd = void 0);
    },
    [Ae2]
  );
  const me2 = !$2() || B2().valid, fe2 = /* @__PURE__ */ reactExports.createElement(
    "span",
    {
      dir: te2,
      style: I3 ? ne2 : { width: Z2, ...ne2 },
      className: r$r(
        "k-input",
        "k-numerictextbox",
        {
          [`k-input-${e$v.sizeMap[K3] || K3}`]: K3,
          [`k-input-${L3}`]: L3,
          [`k-rounded-${e$v.roundedMap[w3] || w3}`]: w3,
          "k-invalid": !me2,
          "k-required": O2,
          "k-disabled": o9
        },
        xe2
      ),
      "aria-disabled": o9 ? "true" : void 0,
      ...I3 ? {} : oe2
    },
    /* @__PURE__ */ reactExports.createElement(_e2, null),
    /* @__PURE__ */ reactExports.createElement(
      "input",
      {
        role: "spinbutton",
        value: h3 === null ? "" : h3,
        tabIndex: o$o(Ie$12, o9),
        accessKey: Oe$12,
        disabled: o9,
        title: Le2,
        "aria-disabled": o9 ? "true" : void 0,
        "aria-valuemin": c6,
        "aria-valuemax": d8,
        "aria-label": Re2,
        "aria-labelledby": De2,
        "aria-describedby": Ne$12,
        "aria-required": O2,
        placeholder: ee2,
        spellCheck: false,
        autoComplete: "off",
        autoCorrect: "off",
        autoFocus: Ge2,
        type: Fe2 || "tel",
        className: "k-input-inner",
        id: ue2,
        name: A2,
        readOnly: g6,
        style: Me2,
        onChange: Ke2,
        onFocus: We2,
        onBlur: Ye2,
        onKeyDown: we2,
        onPaste: Ue2,
        onWheel: $e2,
        ref: a9
      }
    ),
    /* @__PURE__ */ reactExports.createElement(He2, null),
    Be2,
    Te2 && /* @__PURE__ */ reactExports.createElement(
      "span",
      {
        className: "k-input-spinner k-spin-button",
        onMouseDown: Je2
      },
      /* @__PURE__ */ reactExports.createElement(
        p$j,
        {
          tabIndex: -1,
          type: "button",
          icon: "caret-alt-up",
          svgIcon: caretAltUpIcon,
          rounded: null,
          fillMode: L3,
          className: "k-spinner-increase",
          "aria-label": P2.toLanguageString(e$b, I$9[e$b]),
          title: P2.toLanguageString(e$b, I$9[e$b]),
          onClick: W3
        }
      ),
      /* @__PURE__ */ reactExports.createElement(
        p$j,
        {
          tabIndex: -1,
          type: "button",
          icon: "caret-alt-down",
          svgIcon: caretAltDownIcon,
          rounded: null,
          fillMode: L3,
          className: "k-spinner-decrease",
          "aria-label": P2.toLanguageString(o$9, I$9[o$9]),
          title: P2.toLanguageString(o$9, I$9[o$9]),
          onClick: Y2
        }
      )
    )
  );
  return I3 ? /* @__PURE__ */ reactExports.createElement(
    l$8,
    {
      label: I3,
      editorId: ue2,
      editorValue: h3 === null ? "" : h3,
      editorValid: me2,
      editorDisabled: o9,
      editorPlaceholder: ee2,
      children: fe2,
      style: { width: Z2 },
      dir: te2,
      ...oe2
    }
  ) : fe2;
});
Ee$1.propTypes = {
  value: o$r.number,
  defaultValue: o$r.number,
  step: o$r.number,
  format: o$r.oneOfType([
    o$r.string,
    o$r.shape({
      style: o$r.oneOf(["decimal", "currency", "percent", "scientific", "accounting"]),
      currency: o$r.string,
      currencyDisplay: o$r.oneOf(["symbol", "code", "name"]),
      useGrouping: o$r.bool,
      minimumIntegerDigits: o$r.number,
      minimumFractionDigits: o$r.number,
      maximumFractionDigits: o$r.number
    })
  ]),
  width: o$r.oneOfType([
    o$r.string,
    o$r.number
  ]),
  tabIndex: o$r.number,
  accessKey: o$r.string,
  title: o$r.string,
  placeholder: o$r.string,
  min: o$r.number,
  max: o$r.number,
  spinners: o$r.bool,
  disabled: o$r.bool,
  readOnly: o$r.bool,
  dir: o$r.string,
  name: o$r.string,
  label: o$r.string,
  validationMessage: o$r.string,
  required: o$r.bool,
  id: o$r.string,
  rangeOnEnter: o$r.bool,
  ariaLabelledBy: o$r.string,
  ariaDescribedBy: o$r.string,
  ariaLabel: o$r.string,
  onChange: o$r.func,
  onFocus: o$r.func,
  onBlur: o$r.func,
  size: o$r.oneOf([null, "small", "medium", "large"]),
  rounded: o$r.oneOf([null, "small", "medium", "large", "full"]),
  fillMode: o$r.oneOf([null, "solid", "flat", "outline"])
};
const u$c = {
  prefix: (C2) => null,
  suffix: (C2) => null,
  step: 1,
  spinners: true,
  disabled: false,
  required: false,
  validityStyles: true,
  rangeOnEnter: true,
  autoFocus: false,
  onChange: (C2) => {
  },
  onFocus: (C2) => {
  },
  onBlur: (C2) => {
  },
  size: "medium",
  rounded: "medium",
  fillMode: "solid"
};
Ee$1.displayName = "KendoNumericTextBox";
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const B$3 = reactExports.forwardRef((e3, F2) => {
  l$p(e$c);
  const l7 = reactExports.useRef(null), o9 = reactExports.useRef(null), a9 = reactExports.useRef(), i16 = n$t(), s10 = i16 && i16.uTextBox, y4 = reactExports.useCallback(
    () => {
      var n10;
      return a9.current !== void 0 ? a9.current : (n10 = l7.current) == null ? void 0 : n10.value;
    },
    []
  );
  reactExports.useImperativeHandle(
    o9,
    () => ({
      get element() {
        return l7.current;
      },
      get name() {
        return l7.current && l7.current.name;
      },
      get value() {
        return y4();
      }
    })
  ), reactExports.useImperativeHandle(
    F2,
    () => o9.current
  );
  const {
    size: c6 = u$b.size,
    fillMode: d8 = u$b.fillMode,
    rounded: f4 = u$b.rounded,
    autoFocus: E2 = u$b.autoFocus,
    className: m3,
    dir: R2,
    style: _2,
    prefix: b2 = u$b.prefix,
    suffix: M3 = u$b.suffix,
    valid: D2,
    // Destruct to avoid warning when used inside a form field
    modified: G2,
    touched: K3,
    visited: U3,
    ...N3
  } = e3, [T3] = s$p(b2), [q2] = s$p(M3), [v3, x3] = reactExports.useState(false), k3 = (n10) => {
    x3(true);
  }, z3 = (n10) => {
    x3(false);
  }, P2 = reactExports.useCallback(
    (n10) => {
      a9.current = n10.target.value, e3.onChange && e3.onChange.call(void 0, {
        syntheticEvent: n10,
        nativeEvent: n10.nativeEvent,
        value: n10.target.value,
        target: o9.current
      }), a9.current = void 0;
    },
    [e3.onChange]
  ), { onFocus: S2, onBlur: I3 } = o$n({
    onFocus: k3,
    onBlur: z3,
    onSyncFocus: e3.onFocus,
    onSyncBlur: e3.onBlur
  }), O2 = reactExports.useMemo(
    () => r$r(E$b.wrapper({
      c: s10,
      rounded: f4,
      fillMode: d8,
      size: c6,
      focused: v3,
      required: e3.required,
      disabled: e3.disabled,
      invalid: e3.valid === false
    }), m3),
    [m3, d8, v3, e3.disabled, e3.required, e3.valid, f4, c6, s10]
  );
  return /* @__PURE__ */ reactExports.createElement(
    "span",
    {
      style: _2,
      dir: R2,
      className: O2,
      onFocus: S2,
      onBlur: I3
    },
    /* @__PURE__ */ reactExports.createElement(T3, null),
    /* @__PURE__ */ reactExports.createElement(
      "input",
      {
        ref: l7,
        className: r$r(E$b.inputInner({ c: s10 })),
        autoFocus: E2,
        ...N3,
        "aria-required": e3.required,
        onChange: P2
      }
    ),
    /* @__PURE__ */ reactExports.createElement(q2, null)
  );
}), u$b = {
  prefix: (e3) => null,
  suffix: (e3) => null,
  size: "medium",
  rounded: "medium",
  fillMode: "solid",
  autoFocus: false
};
B$3.propTypes = {
  size: o$r.oneOf([null, "small", "medium", "large"]),
  rounded: o$r.oneOf([null, "small", "medium", "large", "full"]),
  fillMode: o$r.oneOf([null, "solid", "flat", "outline"]),
  autoFocus: o$r.bool
};
B$3.displayName = "KendoReactTextBoxComponent";
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const f$6 = reactExports.forwardRef(({ orientation: t6 = "horizontal", ...s10 }, r12) => {
  const a9 = reactExports.useRef(null), c6 = reactExports.useRef(null), n10 = n$t(), l7 = n10 && n10.uTextBox;
  reactExports.useImperativeHandle(
    a9,
    () => ({ element: c6.current })
  ), reactExports.useImperativeHandle(
    r12,
    () => a9.current
  );
  const m3 = reactExports.useMemo(
    () => r$r(E$b.prefix({
      c: l7,
      orientation: t6
    }), s10.className),
    [s10.className, l7, t6]
  );
  return /* @__PURE__ */ reactExports.createElement("span", { ...s10, className: m3 });
});
f$6.displayName = "KendoReactInputPrefix";
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const u$a = reactExports.forwardRef(({ orientation: r12 = "vertical", ...t6 }, n10) => {
  const a9 = reactExports.useRef(null), s10 = reactExports.useRef(null);
  return reactExports.useImperativeHandle(
    a9,
    () => ({ element: s10.current })
  ), reactExports.useImperativeHandle(
    n10,
    () => a9.current
  ), /* @__PURE__ */ reactExports.createElement("span", { ...t6, className: r$r("k-input-separator", t6.className, `k-input-separator-${r12}`) });
});
u$a.displayName = "KendoReactInputSeparator";
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let d$d = class d3 extends reactExports.Component {
  constructor() {
    super(...arguments), this.state = { page: this.props.currentPage }, this.handleOnChange = (e3) => {
      this.setState({ page: e3.target.value }), e3.target.value && this.props.pageChange(e3.target.value, e3);
    };
  }
  render() {
    const e3 = a$s(this), a9 = s$k(this), n10 = this.props.messagesMap ? this.props.messagesMap(i$9) : { messageKey: i$9, defaultMessage: Ee$3[i$9] }, o9 = this.props.messagesMap ? this.props.messagesMap(s$8) : { messageKey: s$8, defaultMessage: Ee$3[s$8] }, i16 = this.props.messagesMap ? this.props.messagesMap(u$e) : { messageKey: u$e, defaultMessage: Ee$3[u$e] }, l7 = this.props.messagesMap ? this.props.messagesMap(u$e) : { messageKey: p$h, defaultMessage: Ee$3[p$h] };
    return /* @__PURE__ */ reactExports.createElement("span", { className: "k-pager-input" }, /* @__PURE__ */ reactExports.createElement("span", null, a9.toLanguageString(n10.messageKey, n10.defaultMessage)), /* @__PURE__ */ reactExports.createElement(
      Ee$1,
      {
        value: this.props.currentPage !== void 0 ? this.props.currentPage : this.state.page,
        onChange: this.handleOnChange,
        min: 1,
        spinners: false,
        ariaLabel: a9.toLanguageString(l7.messageKey, l7.defaultMessage),
        tabIndex: this.props.navigatable ? -1 : void 0
      }
    ), /* @__PURE__ */ reactExports.createElement("span", null, `${a9.toLanguageString(o9.messageKey, o9.defaultMessage)} ${e3.format(a9.toLanguageString(i16.messageKey, i16.defaultMessage), [
      this.props.totalPages
    ])}`));
  }
};
v$a(d$d);
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const a$c = (e3) => {
  const {
    children: n10,
    width: o9,
    dir: i16,
    itemsCount: t6,
    popupSettings: r12
  } = e3;
  return /* @__PURE__ */ reactExports.createElement(
    a$m,
    {
      style: { width: o9, direction: i16 },
      contentKey: t6 && t6.join(),
      ...r12
    },
    n10
  );
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const u$9 = reactExports.forwardRef((r12, c6) => {
  const o9 = reactExports.useRef(null), { renderListFilterWrapper: m3 = false, renderPrefixSeparator: d8 = false, ...f4 } = r12, s10 = n$t(), t6 = s10 && s10.uDropDownsBase;
  reactExports.useImperativeHandle(
    c6,
    () => o9.current
  );
  const p6 = () => /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(f$6, null, /* @__PURE__ */ reactExports.createElement(v$c, { name: "search", icon: searchIcon, className: r$r(j$4.inputIcon({ c: t6 })) })), d8 && /* @__PURE__ */ reactExports.createElement(u$a, null)), i16 = /* @__PURE__ */ reactExports.createElement(
    B$3,
    {
      ...f4,
      ref: o9,
      className: r$r(j$4.searchbox({ c: t6 })),
      value: r12.value || "",
      onChange: r12.onChange,
      onKeyDown: r12.onKeyDown,
      tabIndex: r12.tabIndex,
      onClick: (x3) => x3.stopPropagation(),
      size: r12.size,
      fillMode: r12.fillMode,
      rounded: r12.rounded,
      prefix: p6
    }
  );
  return m3 ? /* @__PURE__ */ reactExports.createElement("div", { className: r$r(j$4.listFilter({ c: t6 })) }, " ", i16, " ") : i16;
});
u$9.propTypes = {
  value: o$r.oneOfType([o$r.string, o$r.number, o$r.array]),
  tabIndex: o$r.number,
  onChange: o$r.func,
  onKeyDown: o$r.func,
  size: o$r.oneOf([null, "small", "medium", "large"]),
  rounded: o$r.oneOf([null, "small", "medium", "large", "full"]),
  fillMode: o$r.oneOf([null, "solid", "flat", "outline"]),
  renderListFilterWrapper: o$r.bool,
  renderPrefixSeparator: o$r.bool
};
u$9.displayName = "KendoReactListFilter";
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const m$7 = (e3) => {
  const {
    group: s10,
    groupMode: n10,
    render: t6
  } = e3, r12 = n$t(), a9 = r12 && r12.uDropDownsBase, o9 = /* @__PURE__ */ reactExports.createElement("div", { className: r$r(j$4.groupStickyHeader({ c: a9 })) }, n10 === "classic" ? s10 : /* @__PURE__ */ reactExports.createElement("div", { className: r$r(j$4.listHeaderText({ c: a9 })) }, s10));
  return t6 !== void 0 ? t6.call(void 0, o9, e3) : o9;
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const l$6 = (e3) => e3 != null, d$c = (e3, t6) => {
  for (let r12 = 0; r12 < e3.length; r12++)
    if (e3.charAt(r12) !== t6)
      return false;
  return true;
}, I$8 = (e3, t6, r12) => {
  let n10 = e3;
  return r12 && (n10 = [r12].concat(n10)), n10.slice(t6).concat(n10.slice(0, t6));
}, x$8 = (e3, t6, r12) => {
  if (!l$6(e3))
    return false;
  let n10 = String(e3);
  return r12 && (n10 = n10.toLowerCase()), n10.indexOf(t6) === 0;
}, C$a = (e3, t6, r12, n10, s10) => {
  const o9 = e3.offsetHeight, g6 = t6.children.item(r12), i16 = g6.offsetTop + (s10 ? n10 - e3.scrollTop : 0), c6 = g6.offsetHeight;
  if (s10) {
    let u5 = 0;
    i16 + c6 > o9 ? u5 = i16 + c6 - o9 : i16 < 0 && (u5 = i16), u5 !== 0 ? e3.scrollTop += u5 : e3.scrollTop === 0 && n10 !== 0 && (e3.scrollTop = n10);
  } else
    i16 + c6 > o9 + e3.scrollTop ? e3.scrollTop = i16 + c6 - o9 : i16 < e3.scrollTop && (e3.scrollTop -= e3.scrollTop - i16);
}, h$3 = (e3, t6, r12) => {
  let n10 = -1;
  if (t6) {
    t6 = t6.toLowerCase();
    for (let s10 = 0; s10 < e3.length; s10++) {
      const o9 = (f$5(e3[s10], r12) || "") + "";
      if (o9 && o9.toLowerCase().startsWith(t6)) {
        n10 = s10;
        break;
      }
    }
  }
  return n10;
}, f$5 = (e3, t6) => {
  if (t6 && l$6(e3)) {
    const r12 = t6.split(".");
    let n10 = e3;
    return r12.forEach((s10) => {
      n10 = n10 ? n10[s10] : void 0;
    }), n10;
  }
  return e3;
}, p$e = (e3, t6, r12) => e3 === t6 || l$6(e3) === l$6(t6) && f$5(e3, r12) === f$5(t6, r12), O$5 = (e3) => {
  const { data: t6 = [], groupField: r12 } = e3;
  return r12 ? t6.filter((n10) => r12 && n10[r12] !== void 0) : t6;
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const m$6 = (e3) => e3.preventDefault(), p$d = (e3) => {
  const {
    selected: s10,
    defaultItem: o9,
    textField: n10
  } = e3, t6 = n$t(), l7 = t6 && t6.uDropDownsBase;
  return /* @__PURE__ */ reactExports.createElement(
    "div",
    {
      onClick: e3.onClick,
      onMouseDown: m$6,
      style: { position: "unset" },
      className: r$r(j$4.optionLabel({ c: l7, selected: s10 }))
    },
    f$5(o9, n10) || ""
  );
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const b$5 = (e3) => {
  const {
    selected: o9,
    group: t6,
    dataItem: u5,
    virtual: v3,
    groupMode: c6,
    disabled: n10,
    id: f4,
    focused: g6,
    render: r12
  } = e3, d8 = n$t(), s10 = d8 && d8.uDropDownsBase, p6 = (x3) => e3.onClick(e3.index, x3), m3 = /* @__PURE__ */ reactExports.createElement(
    "li",
    {
      id: f4,
      role: "option",
      "aria-selected": o9,
      "aria-disabled": n10 ? true : void 0,
      className: r$r(j$4.li({
        c: s10,
        selected: o9,
        focused: g6,
        first: !!t6 && c6 === "classic",
        disabled: n10
      })),
      onClick: p6,
      style: { position: v3 ? "relative" : "unset" }
    },
    /* @__PURE__ */ reactExports.createElement("span", { className: r$r(j$4.itemText({ c: s10 })) }, f$5(u5, e3.textField).toString()),
    t6 !== void 0 && c6 === "classic" ? /* @__PURE__ */ reactExports.createElement("div", { className: r$r(j$4.itemGroupLabel({ c: s10 })) }, t6) : null
  );
  return r12 !== void 0 ? r12.call(void 0, m3, e3) : m3;
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const g$7 = (t6) => {
  const {
    group: u5,
    virtual: c6,
    render: e3,
    isMultiColumn: s10 = false,
    id: m3
  } = t6, o9 = n$t(), r12 = o9 && o9.uDropDownsBase, a9 = /* @__PURE__ */ reactExports.createElement(
    "li",
    {
      id: m3,
      role: "group",
      className: r$r(j$4.groupLi({ c: r12, isMultiColumn: s10 })),
      style: s10 ? { boxSizing: "inherit" } : { position: c6 ? "relative" : "unset" }
    },
    /* @__PURE__ */ reactExports.createElement("span", { className: e3 ? void 0 : r$r(j$4.groupItemText({ c: r12, isMultiColumn: s10 })) }, u5)
  );
  return e3 !== void 0 ? e3.call(void 0, a9, t6) : a9;
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const o$8 = "dropdowns.nodata", a$b = "dropdowns.clear", r$4 = "dropdowns.comboArrowBtnAriaLabelExpand", n$a = "dropdowns.comboArrowBtnAriaLabelCollapse", e$a = "dropdowns.dropDownListArrowBtnAriaLabel", d$b = "dropdowns.apply", s$5 = "dropdowns.cancel", t$b = {
  [a$b]: "clear",
  [o$8]: "NO DATA FOUND.",
  [r$4]: "expand combobox",
  [n$a]: "collapse combobox",
  [e$a]: "select",
  [d$b]: "Apply",
  [s$5]: "Cancel"
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const le$3 = (e3) => {
  const B2 = a$r(), y4 = n$t(), c6 = y4 && y4.uDropDownsBase, {
    id: L3,
    show: z3,
    wrapperCssClass: M3,
    wrapperStyle: $2,
    listStyle: x3,
    listRef: A2,
    wrapperRef: F2,
    listClassName: G2,
    ariaSetSize: V3
  } = e3, D2 = (() => {
    const {
      textField: n10,
      valueField: l7,
      groupField: u5,
      groupMode: s10,
      isMultiColumn: U3,
      optionsGuid: I3,
      skip: S2 = 0,
      virtual: h3,
      focusedIndex: C2,
      hasDuplicates: j2,
      highlightSelected: q2 = true,
      value: i16,
      data: E2,
      itemRender: J2,
      groupHeaderItemRender: K3
    } = e3, w3 = Array.isArray(i16);
    let N3 = 0;
    return E2.map((o9, r12) => {
      const m3 = S2 + r12, f4 = S2 + r12 + N3, O2 = j2 ? i16 ? C2 === r12 : false : o9.disabled ? false : q2 && (!w3 && p$e(o9, i16, l7) || w3 && i16.findIndex((P2) => p$e(P2, o9, l7)) !== -1);
      let a9, d8, v3;
      return r12 > 0 && u5 !== void 0 && (d8 = f$5(o9, u5), v3 = f$5(E2[r12 - 1], u5), d8 && v3 && d8 !== v3 && (a9 = d8)), a9 !== void 0 && s10 === "modern" && (N3 += 1), [
        a9 !== void 0 && s10 === "modern" && /* @__PURE__ */ reactExports.createElement(
          g$7,
          {
            id: `option-${I3}-${f4}`,
            virtual: h3,
            key: m3 + "-group-item",
            group: a9,
            isMultiColumn: U3,
            render: K3
          }
        ),
        /* @__PURE__ */ reactExports.createElement(
          b$5,
          {
            id: `option-${I3}-${a9 !== void 0 && s10 === "modern" ? f4 + 1 : f4}`,
            virtual: h3,
            dataItem: o9,
            groupMode: s10,
            selected: O2,
            focused: C2 === r12,
            index: m3,
            key: m3,
            onClick: e3.onClick,
            textField: n10,
            group: a9,
            render: J2,
            disabled: o9.disabled
          }
        )
      ];
    });
  })(), H3 = () => {
    const n10 = e3.noDataRender, l7 = /* @__PURE__ */ reactExports.createElement("div", { className: r$r(j$4.noData({ c: c6 })) }, /* @__PURE__ */ reactExports.createElement("div", null, B2.toLanguageString(o$8, t$b[o$8])));
    return n10 ? n10.call(void 0, l7) : l7;
  };
  return D2.length ? /* @__PURE__ */ reactExports.createElement(
    "div",
    {
      className: M3,
      style: $2,
      ref: F2,
      onMouseDown: e3.onMouseDown,
      onBlur: e3.onBlur,
      onScroll: e3.onScroll,
      unselectable: "on"
    },
    /* @__PURE__ */ reactExports.createElement(
      "ul",
      {
        id: L3,
        role: "listbox",
        "aria-hidden": z3 ? void 0 : true,
        "aria-setsize": V3,
        className: G2 || r$r(j$4.ul({ c: c6 })),
        ref: A2,
        style: x3
      },
      D2
    ),
    e3.scroller && /* @__PURE__ */ reactExports.createElement("div", { className: r$r(j$4.heightContainer({ c: c6 })) }, e3.scroller)
  ) : H3();
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const S$7 = 17895697, r$3 = typeof window != "undefined" && /Firefox/.test(window.navigator.userAgent);
let u$8 = class u {
  constructor() {
    this.table = null, this.total = 0, this.enabled = false, this.skip = 0, this.pageSize = 0, this.PageChange = null, this.scrollElement = null, this.listTransform = "", this.itemHeight = 0, this.containerHeight = 0, this.reactVersion = Number.parseFloat(reactExports.version), this.scrollSyncing = false, this.lastLoaded = 0, this.firstLoaded = 0, this.lastScrollTop = 0, this.listTranslate = 0, this.list = null, this.container = null, this.calcScrollElementHeight = () => {
      var h3;
      this.scrollSyncing = true;
      let t6 = false;
      this.itemHeight = this.list ? this.list.children[0].offsetHeight : this.itemHeight;
      const i16 = this.itemHeight * this.total - (((h3 = this.list) == null ? void 0 : h3.offsetHeight) || 0);
      this.containerHeight = r$3 ? Math.min(S$7, i16) : i16;
      const s10 = this.containerHeight;
      return this.scrollElement && (t6 = this.scrollElement.style.height !== s10 + "px", t6 && (this.scrollElement.style.height = s10 + "px")), this.scrollSyncing = false, t6;
    }, this.scrollerRef = (t6) => {
      this.container = t6, t6 && (t6.setAttribute("unselectable", "on"), window.setTimeout(this.calcScrollElementHeight.bind(this), 0));
    }, this.getRowHeightService = s$n((t6, i16) => new g$h(i16, t6, 0)), this.firstLoaded = this.pageSize, this.lastLoaded = this.skip + this.pageSize, this.scrollHandler = this.scrollHandler.bind(this);
  }
  get translate() {
    return this.listTranslate;
  }
  translateTo(t6, i16) {
    this.listTranslate = t6, this.enabled && this.list && (r$3 || this.reactVersion <= 17 || i16 ? this.list.style.transform = "translateY(" + t6 + "px)" : this.listTransform = "translateY(" + t6 + "px)");
  }
  changePage(t6, i16) {
    const s10 = Math.min(Math.max(0, t6), this.total - this.pageSize);
    s10 !== this.skip && this.PageChange && this.PageChange({ skip: s10, take: this.pageSize }, i16);
  }
  reset() {
    this.container && (this.calcScrollElementHeight(), this.container.scrollTop = 0, this.translateTo(0, true));
  }
  scrollToEnd() {
    if (this.container && this.list) {
      this.calcScrollElementHeight();
      const { scrollHeight: t6, offsetHeight: i16 } = this.container;
      this.container.scrollTop = t6, this.translateTo(t6 - i16, true);
    }
  }
  scrollHandler(t6) {
    if (!this.enabled || !this.container || !this.list)
      return;
    if (this.scrollSyncing) {
      this.scrollSyncing = false;
      return;
    }
    this.rowHeightService = this.getRowHeightService(this.itemHeight, this.total);
    const i16 = this.container.scrollTop, s10 = this.lastScrollTop >= i16, h3 = !s10, n10 = Math.abs(i16 - this.lastScrollTop);
    this.lastScrollTop = i16;
    let e3 = this.rowHeightService.index(i16), a9 = this.rowHeightService.offset(e3);
    const { offsetHeight: c6 } = this.container, g6 = this.rowHeightService.index(i16 + c6);
    if (h3 && g6 >= this.lastLoaded && this.lastLoaded < this.total) {
      const l7 = e3 + this.pageSize - this.total;
      l7 > 0 && (e3 = e3 - l7, a9 = this.rowHeightService.offset(e3)), this.firstLoaded = e3, this.translateTo(a9);
      const o9 = this.firstLoaded + this.pageSize;
      this.lastLoaded = Math.min(o9, this.total), this.changePage(this.firstLoaded, t6);
    } else if (s10 && e3 - 1 <= this.firstLoaded) {
      const l7 = n10 === this.itemHeight;
      if (this.skip === 0 && l7)
        this.lastScrollTop = 0, this.firstLoaded = 0, this.lastLoaded = this.pageSize, this.container.scrollTop = 0, this.translateTo(0, true);
      else {
        const o9 = Math.floor(this.pageSize * 0.3);
        this.firstLoaded = Math.max(e3 - o9, 0), this.translateTo(this.rowHeightService.offset(this.firstLoaded)), this.lastLoaded = Math.min(this.firstLoaded + this.pageSize, this.total), this.changePage(this.firstLoaded, t6);
      }
    }
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let o$7 = class o5 {
  navigate(e3) {
    const t6 = e3.keyCode;
    if (t6 === e$B.up || t6 === e$B.left)
      return this.next({ current: e3.current, min: e3.min, max: e3.max, step: e3.skipItems ? e3.skipItems : -1 });
    if (t6 === e$B.down || t6 === e$B.right)
      return this.next({ current: e3.current, min: e3.min, max: e3.max, step: e3.skipItems ? e3.skipItems : 1 });
    if (t6 === e$B.home)
      return 0;
    if (t6 === e$B.end)
      return e3.max;
  }
  next(e3) {
    return l$6(e3.current) ? Math.min(e3.max, Math.max(e3.current + e3.step, e3.min)) : e3.min;
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const a$a = class a5 {
  constructor(n10) {
    this.wrapper = null, this.list = null, this.vs = new u$8(), this.navigation = new o$7(), this.handleItemClick = (i16, t6) => {
      const e3 = this.initState();
      e3.syntheticEvent = t6, t6.stopPropagation(), this.component.handleItemSelect(i16, e3), this.togglePopup(e3), this.applyState(e3);
    }, this.handleFocus = (i16) => {
      if (!this.component.state.focused) {
        const t6 = this.initState();
        t6.data.focused = true, t6.events.push({ type: "onFocus" }), t6.syntheticEvent = i16, this.applyState(t6);
      }
    }, this.filterChanged = (i16, t6) => {
      const { textField: e3, filterable: o9 } = this.component.props;
      o9 && t6.events.push({
        type: "onFilterChange",
        filter: {
          field: e3,
          operator: "contains",
          ignoreCase: true,
          value: i16
        }
      });
    }, this.togglePopup = (i16) => {
      const t6 = this.component.props, e3 = t6.opened !== void 0 ? t6.opened : this.component.state.opened;
      t6.opened === void 0 && (i16.data.opened = !e3), e3 ? i16.events.push({ type: "onClose" }) : (i16.events.push({ type: "onOpen" }), this.calculatePopupWidth());
    }, this.pageChange = (i16, t6) => {
      const e3 = this.initState();
      e3.syntheticEvent = t6, this.triggerOnPageChange(e3, i16.skip, i16.take), this.applyState(e3);
    }, this.scrollToVirtualItem = (i16, t6) => {
      const e3 = this.vs;
      if (i16.skip === 0)
        e3.reset();
      else {
        let o9 = e3.translate;
        o9 === 0 && (e3.calcScrollElementHeight(), o9 = e3.itemHeight * i16.skip, e3.translateTo(o9, true)), t6 < 0 && o9 > 0 && (o9 += e3.itemHeight * (i16.pageSize / 4)), e3.container && (e3.container.scrollTop = o9), this.scrollToItem(t6, true);
      }
    }, this.scrollPopupByPageSize = (i16) => {
      var r12, l7, h3, c6, u5, d8;
      const t6 = this.vs, e3 = (l7 = (r12 = this.list) == null ? void 0 : r12.parentElement) == null ? void 0 : l7.scrollTop, o9 = t6.enabled && t6.itemHeight ? t6.itemHeight : this.list ? this.list.children[0].offsetHeight : 0, p6 = (c6 = (h3 = this.list) == null ? void 0 : h3.parentElement) == null ? void 0 : c6.offsetHeight;
      e3 !== void 0 && p6 !== void 0 && ((d8 = (u5 = this.list) == null ? void 0 : u5.parentElement) == null || d8.scroll({
        top: e3 + i16 * Math.floor(p6 / o9) * o9
      }));
    }, this.renderScrollElement = () => {
      const i16 = this.vs;
      return i16.enabled && /* @__PURE__ */ reactExports.createElement("div", { ref: (t6) => i16.scrollElement = t6, key: "scrollElementKey" });
    }, this.resetGroupStickyHeader = (i16, t6) => {
      i16 !== t6.state.group && t6.setState({ ...t6.state, group: i16 });
    }, this.listBoxId = n10.props.id + "list", this.guid = n10.props.id, this.component = n10, this.vs.PageChange = this.pageChange;
  }
  didUpdate() {
    this.vs.listTransform && this.vs.list && (this.vs.list.style.transform = this.vs.listTransform, this.vs.listTransform = "");
  }
  didMount() {
    const n10 = this.component.props, i16 = n10.popupSettings || {}, t6 = n10.style || {}, e3 = i16.width;
    let o9 = n10.opened === true;
    e3 === void 0 && this.calculatePopupWidth(), n10.dir === void 0 && t6.direction === void 0 && (this.calculateDir(), o9 = true), o9 && this.component.forceUpdate();
  }
  calculateDir() {
    const n10 = this.component.element;
    n10 && n10.ownerDocument && n10.ownerDocument.defaultView && (this.dirCalculated = n10.ownerDocument.defaultView.getComputedStyle(n10).direction || void 0);
  }
  calculatePopupWidth() {
    this.wrapper && (this.popupWidth = this.wrapper.offsetWidth + "px");
  }
  scrollToItem(n10, i16, t6) {
    const e3 = this.list || this.vs.list;
    if (!e3 && !t6 && setTimeout(() => {
      this.scrollToItem(n10, i16, true);
    }, 10), n10 === 0 && i16 && this.vs.skip === 0) {
      this.vs.reset();
      return;
    }
    if (e3 && n10 >= 0) {
      const o9 = this.vs, p6 = o9.container || e3.parentNode, r12 = i16 !== void 0 ? i16 : o9.enabled;
      C$a(p6, e3, n10, o9.translate, r12);
    }
  }
  initState() {
    return {
      data: {},
      events: [],
      syntheticEvent: void 0
    };
  }
  applyState(n10) {
    Object.keys(n10.data).length > 0 && this.component.setState(n10.data);
    const i16 = {
      syntheticEvent: n10.syntheticEvent,
      nativeEvent: n10.syntheticEvent ? n10.syntheticEvent.nativeEvent : void 0,
      target: this.component,
      value: this.component.value
    };
    n10.events.forEach((t6) => {
      const e3 = t6.type;
      delete t6.type;
      const o9 = e3 && this.component.props[e3];
      o9 && o9.call(void 0, {
        ...i16,
        ...t6
      });
    });
  }
  triggerOnPageChange(n10, i16, t6) {
    const e3 = this.component.props.virtual;
    if (e3) {
      const o9 = Math.min(Math.max(0, i16), Math.max(0, e3.total - t6));
      o9 !== e3.skip && n10.events.push({
        type: "onPageChange",
        page: { skip: o9, take: t6 }
      });
    }
  }
  triggerPageChangeCornerItems(n10, i16) {
    const t6 = this.component.props, { data: e3 = [], dataItemKey: o9, virtual: p6 } = t6, r12 = t6.opened !== void 0 ? t6.opened : this.component.state.opened;
    n10 && p6 && this.vs.enabled && (p6.skip > 0 && p$e(n10, e3[0], o9) ? this.triggerOnPageChange(i16, p6.skip - 1, p6.pageSize) : !r12 && p6.skip + p6.pageSize < p6.total && p$e(n10, e3[e3.length - 1], o9) && this.triggerOnPageChange(i16, p6.skip + 1, p6.pageSize));
  }
  getPopupSettings() {
    return Object.assign({}, a5.defaultProps.popupSettings, this.component.props.popupSettings);
  }
  getAdaptiveAnimation() {
    const n10 = this.getPopupSettings();
    return n10.animate !== void 0 ? n10.animate : true;
  }
  getGroupedDataModernMode(n10, i16) {
    const t6 = [];
    return n10.forEach((e3, o9) => {
      n10[o9 - 1] && e3[i16] !== n10[o9 - 1][i16] && t6.push({ [i16]: e3[i16] }), t6.push(n10[o9]);
    }), t6;
  }
};
a$a.basicPropTypes = {
  opened: o$r.bool,
  disabled: o$r.bool,
  dir: o$r.string,
  tabIndex: o$r.number,
  accessKey: o$r.string,
  data: o$r.array,
  textField: o$r.string,
  className: o$r.string,
  label: o$r.string,
  loading: o$r.bool,
  popupSettings: o$r.shape({
    animate: o$r.oneOfType([
      o$r.bool,
      o$r.shape({
        openDuration: o$r.number,
        closeDuration: o$r.number
      })
    ]),
    popupClass: o$r.string,
    className: o$r.string,
    appendTo: o$r.any,
    width: o$r.oneOfType([o$r.string, o$r.number]),
    height: o$r.oneOfType([o$r.string, o$r.number])
  }),
  onOpen: o$r.func,
  onClose: o$r.func,
  onFocus: o$r.func,
  onBlur: o$r.func,
  onChange: o$r.func,
  itemRender: o$r.func,
  listNoDataRender: o$r.func,
  focusedItemIndex: o$r.func,
  header: o$r.node,
  footer: o$r.node
}, a$a.propTypes = {
  ...a$a.basicPropTypes,
  value: o$r.any,
  defaultValue: o$r.any,
  filterable: o$r.bool,
  filter: o$r.string,
  virtual: o$r.shape({
    pageSize: o$r.number.isRequired,
    skip: o$r.number.isRequired,
    total: o$r.number.isRequired
  }),
  onFilterChange: o$r.func,
  onPageChange: o$r.func
}, a$a.defaultProps = {
  popupSettings: {
    height: "200px"
  },
  required: false,
  validityStyles: true
};
let f$4 = a$a;
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const e$9 = {
  name: "@progress/kendo-react-dropdowns",
  productName: "KendoReact",
  productCodes: ["KENDOUIREACT", "KENDOUICOMPLETE"],
  publishDate: 1728906544,
  version: "",
  licensingDocsUrl: "https://www.telerik.com/kendo-react-ui/components/my-license/?utm_medium=product&utm_source=kendoreact&utm_campaign=kendo-ui-react-purchase-license-keys-warning"
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const E$7 = 500, I$7 = 768;
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const Ce = "Please select a value from the list!", N$7 = class N extends reactExports.Component {
  constructor(s10) {
    super(s10), this.state = {}, this._element = null, this.base = new f$4(this), this.searchState = { word: "", last: "" }, this._select = null, this._skipFocusEvent = false, this._filterInput = null, this._navigated = false, this._lastKeypressIsFilter = false, this.itemHeight = 0, this.focus = () => {
      this.base.wrapper && this.base.wrapper.focus({ preventScroll: true });
    }, this.handleItemSelect = (e3, t6) => {
      const { virtual: a9, dataItemKey: h3, defaultItem: n10 } = this.props, l7 = O$5(this.props), b2 = a9 ? a9.skip : 0, d8 = e3 === -1 && n10 !== void 0 ? n10 : l7[e3 - b2], i16 = !p$e(d8, this.value, h3);
      this.triggerOnChange(d8, t6), i16 && this.base.triggerPageChangeCornerItems(d8, t6);
    }, this.componentRef = (e3) => {
      this._element = e3, this.base.wrapper = e3;
    }, this.dummySelect = (e3) => /* @__PURE__ */ reactExports.createElement(
      "select",
      {
        name: this.props.name,
        ref: (t6) => {
          this._select = t6;
        },
        tabIndex: -1,
        "aria-hidden": true,
        title: this.props.label,
        style: { opacity: 0, width: 1, border: 0, zIndex: -1, position: "absolute", left: "50%" }
      },
      /* @__PURE__ */ reactExports.createElement("option", { value: this.props.valueMap ? this.props.valueMap.call(void 0, e3) : e3 })
    ), this.renderListContainer = () => {
      const { header: e3, footer: t6, dir: a9, size: h3, groupField: n10, groupStickyHeaderItemRender: l7, list: b2, unstyled: d8 } = this.props, i16 = O$5(this.props), c6 = this.base, o9 = c6.getPopupSettings(), f4 = this.props.opened !== void 0 ? this.props.opened : this.state.opened, g6 = o9.width !== void 0 ? o9.width : c6.popupWidth, p6 = d8 && d8.uDropDownList, r12 = {
        dir: a9 !== void 0 ? a9 : c6.dirCalculated,
        width: g6,
        popupSettings: {
          ...o9,
          popupClass: r$r(
            o9.popupClass,
            J$6.listContainer({
              c: p6
            })
          ),
          anchor: o9.anchor || this.element,
          show: f4,
          onOpen: this.onPopupOpened,
          onClose: this.onPopupClosed,
          onMouseDownOutside: this.onPopupMouseDown
        },
        itemsCount: [i16.length]
      };
      let { group: w3 } = this.state;
      return w3 === void 0 && n10 !== void 0 && (w3 = f$5(i16[0], n10)), /* @__PURE__ */ reactExports.createElement(a$c, { ...r12 }, this.renderListFilter(), e3 && /* @__PURE__ */ reactExports.createElement("div", { className: r$r(J$6.listHeader({ c: p6 })) }, e3), /* @__PURE__ */ reactExports.createElement(
        "div",
        {
          className: r$r(
            J$6.list({
              c: p6,
              size: h3,
              virtual: this.base.vs.enabled
            })
          )
        },
        this.renderDefaultItem(),
        !b2 && w3 && i16.length !== 0 && /* @__PURE__ */ reactExports.createElement(m$7, { group: w3, groupMode: "modern", render: l7 }),
        this.renderList()
      ), t6 && /* @__PURE__ */ reactExports.createElement("div", { className: r$r(J$6.listFooter({ c: p6 })) }, t6));
    }, this.renderList = () => {
      const {
        textField: e3,
        dataItemKey: t6,
        virtual: a9 = { skip: 0, total: void 0 },
        groupHeaderItemRender: h3,
        listNoDataRender: n10,
        itemRender: l7,
        unstyled: b2
      } = this.props, d8 = O$5(this.props), i16 = b2 && b2.uDropDownList, c6 = this.base.vs, o9 = a9.skip, f4 = this.props.opened !== void 0 ? this.props.opened : this.state.opened, g6 = this.base.getPopupSettings(), p6 = `translateY(${c6.translate}px)`;
      return /* @__PURE__ */ reactExports.createElement(
        le$3,
        {
          id: this._listboxId,
          show: f4,
          data: d8.slice(),
          focusedIndex: this.getFocusedIndex(),
          value: this.value,
          textField: e3,
          valueField: t6,
          optionsGuid: this._guid,
          groupField: this.props.groupField,
          groupMode: "modern",
          listRef: (r12) => c6.list = this.base.list = r12,
          wrapperStyle: { maxHeight: g6.height },
          wrapperCssClass: r$r(J$6.listContent({ c: i16 })),
          listStyle: c6.enabled ? { transform: p6 } : void 0,
          key: "listkey",
          skip: o9,
          onClick: this.handleItemClick,
          itemRender: l7,
          groupHeaderItemRender: h3,
          noDataRender: n10,
          onScroll: this.onScroll,
          wrapperRef: c6.scrollerRef,
          scroller: this.base.renderScrollElement(),
          ariaSetSize: a9.total
        }
      );
    }, this.onScroll = (e3) => {
      const { vs: t6, list: a9 } = this.base;
      t6.scrollHandler(e3);
      const { groupField: h3 } = this.props;
      let n10 = O$5(this.props);
      if (!(!h3 || !n10.length) && h3) {
        const l7 = this.itemHeight = this.itemHeight || (t6.enabled ? t6.itemHeight : a9 ? a9.children[0].offsetHeight : 0), d8 = e3.target.scrollTop - t6.skip * l7;
        n10 = this.base.getGroupedDataModernMode(n10, h3);
        let i16 = n10[0][h3];
        for (let c6 = 1; c6 < n10.length && !(l7 * c6 > d8); c6++)
          n10[c6] && n10[c6][h3] && (i16 = n10[c6][h3]);
        i16 !== this.state.group && this.setState({
          group: i16
        });
      }
    }, this.renderListFilter = () => {
      const e3 = this.props.filter !== void 0 ? this.props.filter : this.state.text;
      return this.props.filterable && /* @__PURE__ */ reactExports.createElement(
        u$9,
        {
          value: e3,
          ref: (t6) => this._filterInput = t6 && t6.element,
          onChange: this.handleListFilterChange,
          onKeyDown: this.handleKeyDown,
          size: this.props.size,
          rounded: this.props.rounded,
          fillMode: this.props.fillMode,
          renderListFilterWrapper: true
        }
      );
    }, this.renderDefaultItem = () => {
      const { textField: e3, defaultItem: t6, dataItemKey: a9 } = this.props;
      return t6 !== void 0 && /* @__PURE__ */ reactExports.createElement(
        p$d,
        {
          defaultItem: t6,
          textField: e3,
          selected: p$e(this.value, t6, a9),
          key: "defaultitemkey",
          onClick: this.handleDefaultItemClick
        }
      );
    }, this.search = (e3) => {
      clearTimeout(this._typingTimeout), this.props.filterable || (this._typingTimeout = window.setTimeout(() => this.searchState.word = "", this.props.delay), this.selectNext(e3));
    }, this.selectNext = (e3) => {
      const { dataItemKey: t6 } = this.props, a9 = O$5(this.props);
      let h3 = a9.map((F2, M3) => ({ item: F2, itemIndex: M3 }));
      const n10 = this.searchState.word, l7 = this.searchState.last, b2 = d$c(n10, l7);
      let d8 = h3.length, i16 = Math.max(
        0,
        a9.findIndex((F2) => p$e(F2, this.value, t6))
      ), c6;
      this.props.defaultItem && (c6 = { item: this.props.defaultItem, itemIndex: -1 }, d8 += 1, i16 += 1), i16 += b2 ? 1 : 0, h3 = I$8(h3, i16, c6);
      let o9, f4, g6, p6 = 0;
      const { textField: r12, ignoreCase: w3 } = this.props;
      for (; p6 < d8; p6++)
        if (o9 = f$5(h3[p6].item, r12), f4 = b2 && x$8(o9, l7, w3), g6 = x$8(o9, n10, w3), f4 || g6) {
          p6 = h3[p6].itemIndex;
          break;
        }
      if (p6 !== d8) {
        const F2 = this.base.initState();
        F2.syntheticEvent = e3, this.handleItemSelect(p6, F2), this.applyState(F2), this._valueDuringOnChange = void 0;
      }
    }, this.handleKeyDown = (e3) => {
      e3 && e3.target instanceof Element && e3.target.nodeName === "INPUT" && e3.stopPropagation && e3.stopPropagation();
      const {
        filterable: t6,
        disabled: a9,
        defaultItem: h3,
        leftRightKeysNavigation: n10 = true,
        virtual: l7 = { skip: 0, total: 0, pageSize: 0 },
        dataItemKey: b2,
        groupField: d8 = "",
        textField: i16,
        skipDisabledItems: c6 = true
      } = this.props, o9 = O$5(this.props), f4 = this.value, g6 = o9.findIndex((y4) => p$e(y4, f4, b2)), p6 = this.props.opened !== void 0 ? this.props.opened : this.state.opened, r12 = e3.keyCode, w3 = r12 === e$B.home || r12 === e$B.end, F2 = r12 === e$B.up || r12 === e$B.down, M3 = !p6 && (e3.altKey && r12 === e$B.down || r12 === e$B.enter || r12 === e$B.space), _2 = p6 && (e3.altKey && r12 === e$B.up || r12 === e$B.esc), z3 = n10 && (r12 === e$B.left || r12 === e$B.right), P2 = F2 || z3 && !t6 || w3, S2 = this.base.initState();
      if (S2.syntheticEvent = e3, !a9) {
        if (w3 && this.base.vs.enabled)
          r12 === e$B.home ? l7.skip !== 0 ? (this.base.triggerOnPageChange(S2, 0, l7.pageSize), this._navigated = true) : this.triggerOnChange(o9[0], S2) : l7.skip < l7.total - l7.pageSize ? (this.base.triggerOnPageChange(S2, l7.total - l7.pageSize, l7.pageSize), this._navigated = true) : this.triggerOnChange(o9[o9.length - 1], S2);
        else if (p6 && r12 === e$B.pageUp)
          e3.preventDefault(), this.base.scrollPopupByPageSize(-1);
        else if (p6 && r12 === e$B.pageDown)
          e3.preventDefault(), this.base.scrollPopupByPageSize(1);
        else if (p6 && r12 === e$B.enter) {
          const y4 = this.getFocusedIndex();
          this.haveFocusedItemAndDataNotEmpty(o9, y4) ? (this.triggerOnChange(null, S2), this.applyState(S2)) : this.handleItemSelect(y4, S2), this.base.togglePopup(S2), e3.preventDefault();
        } else if (M3 || _2)
          _2 && this.resetValueIfDisabledItem(), this.base.togglePopup(S2), e3.preventDefault();
        else if (P2) {
          if (this._lastKeypressIsFilter = false, d8 !== "" && i16)
            if (!c6 && p6)
              this.onNavigate(S2, r12);
            else {
              let y4;
              if (r12 === e$B.down || r12 === e$B.right) {
                const v3 = o9.slice(g6 + 1).find((m3) => !m3.disabled && m3[i16]);
                y4 = v3 && o9.findIndex((m3) => m3[i16] === v3[i16]);
              } else if (r12 === e$B.up || r12 === e$B.left) {
                let v3;
                if (g6 === 0 && h3)
                  y4 = -1;
                else if (g6 === -1)
                  v3 = o9, y4 = o9.findIndex((m3) => !m3.disabled && m3[i16]);
                else {
                  v3 = o9.slice(0, g6);
                  let m3 = v3.pop();
                  for (; m3 && m3.disabled; )
                    m3 = v3.pop();
                  y4 = m3 && o9.findIndex((L3) => L3[i16] === m3[i16]);
                }
              }
              if (y4 !== void 0) {
                const v3 = y4 - g6;
                this.onNavigate(S2, r12, v3);
              } else
                y4 === void 0 && o9.findIndex((v3) => v3[i16] === f4[i16]) === o9.length - 1 && this.onNavigate(S2, r12);
            }
          else if (!c6 && p6 || w3)
            this.onNavigate(S2, r12);
          else if (i16) {
            let y4;
            if (r12 === e$B.down || r12 === e$B.right) {
              const v3 = o9.slice(g6 + 1).find((m3) => !m3.disabled && m3[i16]);
              y4 = v3 && o9.findIndex((m3) => m3[i16] === v3[i16]);
            } else if (r12 === e$B.up || r12 === e$B.left) {
              let v3;
              if (g6 === 0 && h3)
                y4 = -1;
              else if (g6 === -1)
                v3 = o9, y4 = o9.find((m3) => !m3.disabled && m3[i16]);
              else {
                v3 = o9.slice(0, g6);
                let m3 = v3.pop();
                for (; m3 && m3.disabled; )
                  m3 = v3.pop();
                y4 = m3 && o9.findIndex((L3) => L3[i16] === m3[i16]);
              }
            }
            if (y4 !== void 0) {
              const v3 = y4 - g6;
              this.onNavigate(S2, r12, v3);
            } else
              y4 === void 0 && o9.findIndex((v3) => v3[i16] === f4[i16]) === o9.length - 1 && this.onNavigate(S2, r12);
          } else
            this.onNavigate(S2, r12);
          e3.preventDefault();
        }
        this.applyState(S2);
      }
    }, this.handleItemClick = (e3, t6) => {
      this.base.handleItemClick(e3, t6), this._valueDuringOnChange = void 0;
    }, this.handleFocus = (e3) => {
      this._skipFocusEvent || this.base.handleFocus(e3);
    }, this.handleBlur = (e3) => {
      if (this._skipFocusEvent || !this.state.focused)
        return;
      const t6 = this.props.opened !== void 0 ? this.props.opened : this.state.opened, { adaptive: a9 } = this.props, { windowWidth: h3 = 0 } = this.state, n10 = h3 <= I$7 && a9, l7 = this.base.initState();
      l7.syntheticEvent = e3, l7.data.focused = false, l7.events.push({ type: "onBlur" }), t6 && this.resetValueIfDisabledItem(), t6 && !n10 && this.base.togglePopup(l7), this.applyState(l7);
    }, this.handleDefaultItemClick = (e3) => {
      const t6 = this.base.initState();
      t6.syntheticEvent = e3, this.base.togglePopup(t6), this.triggerOnChange(this.props.defaultItem, t6), this.applyState(t6);
    }, this.handleWrapperClick = (e3) => {
      if (e3.isPropagationStopped())
        return;
      const t6 = this.base.initState();
      t6.syntheticEvent = e3, this.state.focused || (t6.data.focused = true), this.resetValueIfDisabledItem(), this.base.togglePopup(t6), this.applyState(t6);
    }, this.handleKeyPress = (e3) => {
      if (this.props.filterable || e3.which === 0 || e3.keyCode === e$B.enter)
        return;
      let t6 = String.fromCharCode(e3.charCode || e3.keyCode);
      this.props.ignoreCase && (t6 = t6.toLowerCase()), t6 === " " && e3.preventDefault(), this.searchState = {
        word: this.searchState.word + t6,
        last: this.searchState.last + t6
      }, this.search(e3);
    }, this.handleListFilterChange = (e3) => {
      const t6 = this.base.initState();
      t6.syntheticEvent = e3.syntheticEvent, this.props.filter === void 0 && (t6.data.text = e3.target.value), this.base.filterChanged(e3.target.value, t6), this._lastKeypressIsFilter = true, this.applyState(t6), this.setState({ group: void 0 });
    }, this.onPopupOpened = () => {
      this._filterInput && this.focusElement(this._filterInput), this.props.adaptive && setTimeout(() => {
        this._filterInput && this.focusElement(this._filterInput);
      }, 300);
    }, this.onPopupClosed = () => {
      this.state.focused && window.setTimeout(() => {
        this.state.focused && this.base.wrapper && this.focusElement(this.base.wrapper);
      });
    }, this.onPopupMouseDown = (e3) => {
      var t6;
      (t6 = this.props.popupSettings) != null && t6.onMouseDownOutside && this.props.popupSettings.onMouseDownOutside.call(void 0, e3);
    }, this.togglePopup = () => {
      const e3 = this.base.initState();
      e3.data.opened = this.state.opened, this.base.togglePopup(e3), this.applyState(e3);
    }, this.setValidity = () => {
      this._select && this._select.setCustomValidity && this._select.setCustomValidity(
        this.validity.valid ? "" : this.props.validationMessage || Ce
      );
    }, l$p(e$9);
  }
  get _inputId() {
    return this.props.id + "-accessibility-id";
  }
  get _listboxId() {
    return this.props.id + "-listbox-id";
  }
  get _guid() {
    return this.props.id + "-guid";
  }
  get document() {
    if (e$C)
      return this.element && this.element.ownerDocument || document;
  }
  /**
   * @hidden
   */
  get element() {
    return this._element;
  }
  /**
   * The value of the DropDownList.
   */
  get value() {
    let s10;
    return this._valueDuringOnChange !== void 0 ? s10 = this._valueDuringOnChange : this.props.value !== void 0 ? s10 = this.props.value : this.state.value !== void 0 ? s10 = this.state.value : this.props.defaultValue !== void 0 && (s10 = this.props.defaultValue), !l$6(s10) && this.props.defaultItem !== void 0 && (s10 = this.props.defaultItem), s10;
  }
  /**
   * The index of the selected item.
   */
  get index() {
    const { dataItemKey: s10 } = this.props, e3 = O$5(this.props), t6 = this.value;
    return e3.findIndex((a9) => p$e(a9, t6, s10));
  }
  /**
   * Gets the `name` property of the DropDownList.
   */
  get name() {
    return this.props.name;
  }
  /**
   * Represents the validity state into which the DropDownList is set.
   */
  get validity() {
    const s10 = this.props.validationMessage !== void 0, e3 = !this.required || this.value !== null && this.value !== "" && this.value !== void 0, t6 = this.props.valid !== void 0 ? this.props.valid : e3;
    return {
      customError: s10,
      valid: t6,
      valueMissing: this.value === null
    };
  }
  get validityStyles() {
    return this.props.validityStyles !== void 0 ? this.props.validityStyles : N.defaultProps.validityStyles;
  }
  /**
   * @hidden
   */
  get required() {
    return this.props.required !== void 0 ? this.props.required : N.defaultProps.required;
  }
  /**
   * @hidden
   */
  componentDidUpdate(s10, e3) {
    var o9;
    const { dataItemKey: t6, virtual: a9, groupField: h3 = "", textField: n10 } = this.props, l7 = O$5(this.props), b2 = s10.virtual ? s10.virtual.total : 0, d8 = this.props.opened !== void 0 ? this.props.opened : this.state.opened, i16 = s10.opened !== void 0 ? s10.opened : e3.opened, c6 = !i16 && d8;
    if (this.base.didUpdate(), this.base.getPopupSettings().animate || c6 && this.onPopupOpened(), a9 && a9.total !== b2)
      this.base.vs.calcScrollElementHeight(), this.base.vs.reset();
    else {
      const f4 = this.value, g6 = s10.value !== void 0 ? s10.value : e3.value;
      let p6 = l7.findIndex((w3) => p$e(w3, f4, t6));
      h3 !== "" && f4 && n10 && (p6 = (o9 = this.base.getGroupedDataModernMode(l7, h3)) == null ? void 0 : o9.map((w3) => w3[n10]).indexOf(f4[n10]));
      const r12 = !p$e(g6, f4, t6);
      c6 && a9 ? this.base.scrollToVirtualItem(a9, p6) : c6 && !a9 ? (this.onPopupOpened(), l7 && l7.length !== 0 && this.base.resetGroupStickyHeader(l7[0][h3], this), this.base.scrollToItem(p6)) : d8 && i16 && f4 && r12 && !this._navigated ? this.base.scrollToItem(p6, this.base.vs.enabled) : d8 && i16 && this._navigated && (this._navigated && a9 && a9.skip === 0 ? this.base.vs.reset() : this._navigated && a9 && a9.skip === a9.total - a9.pageSize && this.base.vs.scrollToEnd());
    }
    this._navigated = false, this.setValidity();
  }
  /**
   * @hidden
   */
  componentDidMount() {
    var s10;
    this.observerResize = e$C && window.ResizeObserver && new window.ResizeObserver(this.calculateMedia.bind(this)), this.base.didMount(), this.setValidity(), (s10 = this.document) != null && s10.body && this.observerResize && this.observerResize.observe(this.document.body);
  }
  /** @hidden */
  componentWillUnmount() {
    var s10;
    (s10 = this.document) != null && s10.body && this.observerResize && this.observerResize.disconnect();
  }
  /**
   * @hidden
   */
  render() {
    const s10 = s$k(this).toLanguageString(
      e$a,
      t$b[e$a]
    ), { style: e3, className: t6, label: a9, dir: h3, virtual: n10, size: l7, rounded: b2, fillMode: d8, adaptive: i16, unstyled: c6 } = this.props, { windowWidth: o9 = 0 } = this.state, f4 = this.props.opened !== void 0 ? this.props.opened : this.state.opened, g6 = this.value, p6 = f$5(g6, this.props.textField), r12 = !this.validityStyles || this.validity.valid, w3 = this.base, F2 = w3.vs, M3 = o9 <= I$7 && i16, _2 = c6 && c6.uDropDownList;
    F2.enabled = n10 !== void 0, n10 !== void 0 && (w3.vs.skip = n10.skip, w3.vs.total = n10.total, w3.vs.pageSize = n10.pageSize);
    const { dataItemKey: z3, disabled: P2, tabIndex: S2, loading: y4, iconClassName: v3, svgIcon: m3, valueRender: L3 } = this.props, J2 = O$5(this.props), { focused: Q2 } = this.state, X2 = J2.findIndex((O2) => p$e(O2, g6, z3)), H3 = /* @__PURE__ */ reactExports.createElement("span", { id: this._inputId, className: r$r(J$6.inputInner({ c: _2 })) }, p6 && /* @__PURE__ */ reactExports.createElement("span", { className: r$r(J$6.inputText({ c: _2 })) }, p6)), Z2 = L3 !== void 0 ? L3.call(void 0, H3, g6) : H3, V3 = /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(
      "span",
      {
        ref: this.componentRef,
        className: r$r(
          J$6.wrapper({
            c: _2,
            size: l7,
            rounded: b2,
            fillMode: d8,
            focused: Q2,
            disabled: P2,
            invalid: !r12,
            loading: y4,
            required: this.required
          }),
          t6
        ),
        style: a9 ? { ...e3, width: void 0 } : e3,
        dir: h3,
        onMouseDown: f4 ? (O2) => {
          O2.target.nodeName !== "INPUT" && (this.focusElement(this.base.wrapper), O2.preventDefault());
        } : void 0,
        onFocus: this.handleFocus,
        onBlur: this.handleBlur,
        tabIndex: o$o(S2, P2),
        accessKey: this.props.accessKey,
        onKeyDown: this.handleKeyDown,
        onKeyPress: this.handleKeyPress,
        onClick: P2 ? void 0 : this.handleWrapperClick,
        role: "combobox",
        "aria-required": this.required,
        "aria-disabled": P2 || void 0,
        "aria-haspopup": "listbox",
        "aria-expanded": f4 || false,
        "aria-owns": this._listboxId,
        "aria-activedescendant": f4 ? "option-" + this._guid + "-" + (X2 + (n10 ? n10.skip : 0)) : void 0,
        "aria-label": this.props.ariaLabel || this.props.label,
        "aria-labelledby": this.props.ariaLabelledBy,
        "aria-describedby": this.props.ariaDescribedBy || this._inputId,
        "aria-controls": this._listboxId,
        id: this.props.id,
        title: this.props.title
      },
      Z2,
      y4 && /* @__PURE__ */ reactExports.createElement(v$c, { className: r$r(J$6.loadingIcon({ c: _2 })), name: "loading" }),
      /* @__PURE__ */ reactExports.createElement(
        p$j,
        {
          tabIndex: -1,
          type: "button",
          "aria-label": s10,
          size: l7,
          fillMode: d8,
          iconClass: v3,
          className: r$r(J$6.inputButton({ c: _2 })),
          rounded: null,
          themeColor: "base",
          icon: v3 ? void 0 : "caret-alt-down",
          svgIcon: m3 || caretAltDownIcon,
          onMouseDown: (O2) => this.state.focused && O2.preventDefault()
        }
      ),
      this.dummySelect(g6),
      !M3 && this.renderListContainer()
    ), M3 && this.renderAdaptiveListContainer());
    return a9 ? /* @__PURE__ */ reactExports.createElement(
      l$8,
      {
        label: a9,
        editorValue: p6,
        editorValid: r12,
        editorDisabled: this.props.disabled,
        style: { width: e3 ? e3.width : void 0 },
        children: V3
      }
    ) : V3;
  }
  /**
   * @hidden
   */
  onNavigate(s10, e3, t6) {
    const { defaultItem: a9, dataItemKey: h3, virtual: n10 = { skip: 0, total: 0, pageSize: 0 } } = this.props, l7 = O$5(this.props), b2 = this.base.vs, d8 = this.value, i16 = l7.findIndex((o9) => p$e(o9, d8, h3)), c6 = this.base.navigation.navigate({
      current: n10.skip + i16,
      max: (b2.enabled ? n10.total : l7.length) - 1,
      min: a9 !== void 0 ? -1 : 0,
      keyCode: e3,
      skipItems: t6 || void 0
    });
    c6 !== void 0 && this.handleItemSelect(c6, s10), this.applyState(s10);
  }
  renderAdaptiveListContainer() {
    const { windowWidth: s10 = 0 } = this.state, { header: e3, footer: t6, size: a9, adaptiveTitle: h3, groupField: n10, groupStickyHeaderItemRender: l7, list: b2, unstyled: d8 } = this.props, i16 = O$5(this.props), c6 = this.props.opened !== void 0 ? this.props.opened : this.state.opened, o9 = d8 && d8.uDropDownList, f4 = d8 && d8.uDropDownsActionSheet, g6 = {
      navigatable: false,
      navigatableElements: [],
      expand: c6,
      animation: true,
      onClose: (r12) => this.handleWrapperClick(r12),
      animationStyles: s10 <= E$7 ? { top: 0, width: "100%", height: "100%" } : void 0,
      className: r$r(
        E$c.wrapper({
          c: f4,
          isFullScreen: s10 <= E$7
        })
      )
    };
    let { group: p6 } = this.state;
    return p6 === void 0 && n10 !== void 0 && (p6 = f$5(i16[0], n10)), /* @__PURE__ */ reactExports.createElement(b$8, { ...g6 }, /* @__PURE__ */ reactExports.createElement(e$h, { className: r$r(E$c.header({ c: f4 })) }, /* @__PURE__ */ reactExports.createElement("div", { className: r$r(E$c.titleBar({ c: f4 })) }, /* @__PURE__ */ reactExports.createElement("div", { className: r$r(E$c.title({ c: f4 })) }, /* @__PURE__ */ reactExports.createElement("div", null, h3)), /* @__PURE__ */ reactExports.createElement("div", { className: r$r(E$c.actions({ c: f4 })) }, /* @__PURE__ */ reactExports.createElement(
      p$j,
      {
        tabIndex: 0,
        "aria-label": "Cancel",
        "aria-disabled": "false",
        type: "button",
        fillMode: "flat",
        onClick: this.handleWrapperClick,
        icon: "x",
        svgIcon: xIcon
      }
    ))), /* @__PURE__ */ reactExports.createElement("div", { className: r$r(E$c.titleBarGroup({ c: f4 })) }, this.renderListFilter())), /* @__PURE__ */ reactExports.createElement(t$e, { overflowHidden: true }, e3 && /* @__PURE__ */ reactExports.createElement("div", { className: r$r(J$6.listHeader({ c: o9 })) }, e3), /* @__PURE__ */ reactExports.createElement(
      "div",
      {
        className: r$r(
          J$6.list({
            c: o9,
            size: a9,
            virtual: this.base.vs.enabled
          })
        )
      },
      this.renderDefaultItem(),
      !b2 && p6 && i16.length !== 0 && /* @__PURE__ */ reactExports.createElement(
        m$7,
        {
          group: p6,
          groupMode: "modern",
          render: l7
        }
      ),
      this.renderList()
    ), t6 && /* @__PURE__ */ reactExports.createElement("div", { className: r$r(J$6.listFooter({ c: o9 })) }, t6)));
  }
  getFocusedIndex() {
    const s10 = this.value, {
      textField: e3,
      dataItemKey: t6,
      virtual: a9 = { skip: 0 },
      focusedItemIndex: h3 = h$3,
      filterable: n10,
      skipDisabledItems: l7 = true
    } = this.props, b2 = O$5(this.props), d8 = this.props.filter ? this.props.filter : this.state.text;
    return l7 && e3 && !d8 && !s10 ? b2.findIndex((i16) => !i16.disabled && i16[e3]) : l$6(s10) && d8 === void 0 || n10 && d8 === "" ? b2.findIndex((i16) => p$e(i16, s10, t6)) : d8 ? this._lastKeypressIsFilter ? h3(b2, d8, e3) : b2.findIndex((i16) => p$e(i16, s10, t6)) : a9.skip === 0 ? 0 : -1;
  }
  focusElement(s10) {
    this._skipFocusEvent = true, s10.focus(), window.setTimeout(() => this._skipFocusEvent = false, 30);
  }
  triggerOnChange(s10, e3) {
    p$e(this.value, s10, this.props.dataItemKey) || (this.props.value === void 0 && (e3.data.value = s10), this._valueDuringOnChange = s10, e3.events.push({ type: "onChange" }));
  }
  applyState(s10) {
    this.base.applyState(s10), this._valueDuringOnChange = void 0;
  }
  calculateMedia(s10) {
    for (const e3 of s10)
      this.setState({ windowWidth: e3.target.clientWidth });
  }
  resetValueIfDisabledItem() {
    const s10 = O$5(this.props), e3 = this.base.initState(), t6 = this.getFocusedIndex();
    this.haveFocusedItemAndDataNotEmpty(s10, t6) && (this.triggerOnChange(null, e3), this.applyState(e3));
  }
  haveFocusedItemAndDataNotEmpty(s10, e3) {
    return e3 !== void 0 && e3 !== -1 && s10 && s10.length > 0 && s10[e3].disabled;
  }
};
N$7.displayName = "DropDownList", N$7.propTypes = {
  delay: o$r.number,
  ignoreCase: o$r.bool,
  iconClassName: o$r.string,
  svgIcon: t$k,
  defaultItem: o$r.any,
  valueRender: o$r.func,
  valueMap: o$r.func,
  validationMessage: o$r.string,
  required: o$r.bool,
  id: o$r.string,
  ariaLabelledBy: o$r.string,
  ariaDescribedBy: o$r.string,
  ariaLabel: o$r.string,
  leftRightKeysNavigation: o$r.bool,
  title: o$r.string,
  groupField: o$r.string,
  list: o$r.any,
  skipDisabledItems: o$r.bool,
  renderListFilterWrapper: o$r.bool,
  ...f$4.propTypes
}, N$7.defaultProps = {
  delay: 500,
  tabIndex: 0,
  ignoreCase: true,
  ...f$4.defaultProps,
  required: false,
  size: "medium",
  rounded: "medium",
  fillMode: "solid",
  groupMode: "modern"
};
let A$7 = N$7;
const De = a$v(), Ee = m$l(
  x$l(
    De,
    l$o(A$7)
  )
);
Ee.displayName = "KendoReactDropDownList";
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let z$5 = class z extends reactExports.Component {
  constructor() {
    super(...arguments), this.pageSizeChange = (e3) => {
      this.props.pageChange && this.props.pageChange({ skip: 0, take: parseInt(e3.target.value, 10) }, e3);
    };
  }
  render() {
    const { value: e3, pageSizes: m3, pageSize: t6, messagesMap: a9, size: c6, navigatable: u5 } = this.props, i16 = m3.slice();
    e3 === void 0 && i16.filter((h3) => h3 === t6).length === 0 && i16.unshift(t6);
    const n10 = a9 ? a9(l$a) : { messageKey: l$a, defaultMessage: Ee$3[l$a] }, o9 = a9 ? a9(O$7) : { messageKey: O$7, defaultMessage: Ee$3[O$7] };
    return /* @__PURE__ */ reactExports.createElement("span", { className: "k-pager-sizes" }, /* @__PURE__ */ reactExports.createElement(
      Ee,
      {
        value: e3 !== void 0 ? e3 : t6,
        data: i16,
        onChange: this.pageSizeChange,
        ariaLabel: s$k(this).toLanguageString(o9.messageKey, o9.defaultMessage),
        size: c6,
        tabIndex: u5 ? -1 : void 0
      }
    ), /* @__PURE__ */ reactExports.createElement("span", null, s$k(this).toLanguageString(n10.messageKey, n10.defaultMessage)));
  }
};
v$a(z$5);
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const e$8 = {
  name: "@progress/kendo-react-data-tools",
  productName: "KendoReact",
  productCodes: ["KENDOUIREACT", "KENDOUICOMPLETE"],
  publishDate: 1728906609,
  version: "",
  licensingDocsUrl: "https://www.telerik.com/kendo-react-ui/components/my-license/"
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const J$3 = 600, ye = 768, M$7 = class M extends reactExports.Component {
  constructor(p6) {
    super(p6), this._element = null, this.onPageChange = (t6, e3) => {
      const i16 = {
        target: this,
        syntheticEvent: e3.syntheticEvent,
        nativeEvent: e3.nativeEvent,
        targetEvent: e3,
        ...t6
      };
      this.props.onPageChange && this.props.onPageChange.call(void 0, i16);
    }, this.changePage = (t6, e3) => {
      this.props.onPageChange && t6 > 0 && t6 <= this.totalPages && this.props.onPageChange({
        target: this,
        skip: (t6 - 1) * this.props.take,
        take: this.props.take,
        syntheticEvent: e3,
        nativeEvent: e3.nativeEvent,
        targetEvent: e3
      });
    }, this.onWindowResize = () => {
      const t6 = this.element;
      if (!t6 || !this.props.responsive)
        return;
      const e3 = t6.offsetWidth;
      e3 < J$3 ? this.setState({ showPagerSizes: false }) : e3 >= J$3 && e3 < ye ? this.setState({ showPagerInfo: false, showPagerSizes: true }) : this.setState({ showPagerInfo: true, showPagerSizes: true });
    }, this.onKeyDown = (t6) => {
      const e3 = this.element, i16 = t6.keyCode;
      !e3 || !this.props.navigatable || ((i16 === e$B.home || t6.metaKey && i16 === e$B.left) && this.changePage(1, t6), (i16 === e$B.end || t6.metaKey && i16 === e$B.right) && this.changePage(this.totalPages, t6), document.activeElement === e3 ? (i16 === e$B.enter && (e$A(e3), g$j(e3)), (i16 === e$B.left || i16 === e$B.up) && this.changePage(this.currentPage - 1, t6), (i16 === e$B.right || i16 === e$B.down) && this.changePage(this.currentPage + 1, t6)) : (i16 === e$B.esc && (e3.focus(), y$c(e3)), n$y(t6, e3, i$v)));
    }, l$p(e$8), this.state = { showPagerSizes: true, showPagerInfo: true, innerNavigateActive: false };
  }
  get isRtl() {
    return this.props.dir === "rtl";
  }
  get currentPage() {
    return Math.floor(this.props.skip / this.props.take) + 1;
  }
  /**
   * Returns the HTML element of the Pager component.
   */
  get element() {
    return this._element;
  }
  /**
   * @hidden
   */
  componentDidMount() {
    window.addEventListener("resize", this.onWindowResize), this.onWindowResize();
  }
  /**
   * @hidden
   */
  componentWillUnmount() {
    window.removeEventListener("resize", this.onWindowResize);
  }
  /**
   * @hidden
   */
  render() {
    const { showPagerSizes: p6, showPagerInfo: t6 } = this.state, {
      skip: e3,
      take: i16,
      total: u5,
      pageSizes: m3,
      size: g6,
      responsive: v3,
      messagesMap: s10,
      dir: Q2,
      style: X2,
      pageSizeValue: Y2,
      previousNext: Z2,
      className: ee2,
      navigatable: d8,
      disabled: c6
    } = this.props, o9 = s$k(this), y4 = a$s(this), r12 = this.currentPage, te2 = this.props.type === "numeric" ? /* @__PURE__ */ reactExports.createElement(
      I$a,
      {
        type: v3 && !p6 ? "dropdown" : "numbers",
        buttonCount: this.props.buttonCount || 0,
        totalPages: this.totalPages,
        currentPage: this.currentPage,
        pageChange: this.changePage,
        messagesMap: this.props.messagesMap,
        size: g6,
        navigatable: d8
      }
    ) : /* @__PURE__ */ reactExports.createElement(
      d$d,
      {
        buttonCount: this.props.buttonCount || 0,
        totalPages: this.totalPages,
        currentPage: r12,
        pageChange: this.changePage,
        messagesMap: s10,
        size: g6,
        navigatable: d8
      }
    ), L3 = s10 ? s10(t$d) : { messageKey: t$d, defaultMessage: Ee$3[t$d] }, I3 = s10 ? s10(r$6) : { messageKey: r$6, defaultMessage: Ee$3[r$6] }, N3 = s10 ? s10(o$a) : { messageKey: o$a, defaultMessage: Ee$3[o$a] }, A2 = s10 ? s10(n$c) : { messageKey: n$c, defaultMessage: Ee$3[n$c] }, B2 = s10 ? s10(e$e) : { messageKey: e$e, defaultMessage: Ee$3[e$e] }, T3 = s10 ? s10(f$8) : { messageKey: f$8, defaultMessage: Ee$3[f$8] }, x3 = s10 ? s10(i$9) : { messageKey: i$9, defaultMessage: Ee$3[i$9] }, O2 = s10 ? s10(s$8) : { messageKey: s$8, defaultMessage: Ee$3[s$8] }, f4 = s10 ? s10(u$e) : { messageKey: u$e, defaultMessage: Ee$3[u$e] }, se2 = `${o9.toLanguageString(
      x3.messageKey,
      x3.defaultMessage
    )} ${y4.format(
      o9.toLanguageString(f4.messageKey, f4.defaultMessage),
      [r12]
    )} ${o9.toLanguageString(O2.messageKey, O2.defaultMessage)} ${y4.format(
      o9.toLanguageString(f4.messageKey, f4.defaultMessage),
      [this.totalPages]
    )}`;
    let D2, F2, W3, _2;
    Z2 && (D2 = this.renderButton(
      1,
      "k-pager-nav k-pager-first" + (r12 === 1 && !c6 ? " k-disabled" : ""),
      o9.toLanguageString(L3.messageKey, L3.defaultMessage),
      this.isRtl ? "caret-alt-to-right" : "caret-alt-to-left",
      this.isRtl ? caretAltToRightIcon : caretAltToLeftIcon,
      r12 === 1 ? true : void 0
    ), F2 = this.renderButton(
      r12 - 1,
      "k-pager-nav" + (r12 === 1 && !c6 ? " k-disabled" : ""),
      o9.toLanguageString(
        I3.messageKey,
        I3.defaultMessage
      ),
      this.isRtl ? "caret-alt-right" : "caret-alt-left",
      this.isRtl ? caretAltRightIcon : caretAltLeftIcon,
      r12 === 1 ? true : void 0
    ), W3 = this.renderButton(
      r12 + 1,
      "k-pager-nav" + (r12 >= this.totalPages && !c6 ? " k-disabled" : ""),
      o9.toLanguageString(N3.messageKey, N3.defaultMessage),
      this.isRtl ? "caret-alt-left" : "caret-alt-right",
      this.isRtl ? caretAltLeftIcon : caretAltRightIcon,
      r12 >= this.totalPages ? true : void 0
    ), _2 = this.renderButton(
      this.totalPages,
      "k-pager-nav k-pager-last" + (r12 >= this.totalPages && !c6 ? " k-disabled" : ""),
      o9.toLanguageString(A2.messageKey, A2.defaultMessage),
      this.isRtl ? "caret-alt-to-left" : "caret-alt-to-right",
      this.isRtl ? caretAltToLeftIcon : caretAltToRightIcon,
      r12 >= this.totalPages ? true : void 0
    ));
    const $2 = m3 && /* @__PURE__ */ reactExports.createElement(
      z$5,
      {
        pageChange: this.onPageChange,
        pageSize: i16,
        pageSizes: m3,
        value: Y2,
        messagesMap: s10,
        size: g6,
        navigatable: d8
      }
    ), q2 = this.props.info && /* @__PURE__ */ reactExports.createElement("span", { className: "k-pager-info" }, y4.format(
      o9.toLanguageString(B2.messageKey, B2.defaultMessage),
      [Math.min(e3 + 1, u5), Math.min(e3 + i16, u5), u5]
    ));
    return /* @__PURE__ */ reactExports.createElement(
      "div",
      {
        className: r$r(
          "k-pager",
          {
            [`k-pager-${e$v.sizeMap[g6] || g6}`]: g6,
            "k-disabled": c6
          },
          ee2
        ),
        style: X2,
        role: "application",
        "aria-roledescription": "pager",
        dir: Q2,
        "aria-keyshortcuts": o9.toLanguageString(
          T3.messageKey,
          T3.defaultMessage
        ),
        "aria-label": se2,
        ref: (ae2) => this._element = ae2,
        tabIndex: d8 ? 0 : void 0,
        onKeyDown: this.onKeyDown
      },
      /* @__PURE__ */ reactExports.createElement("div", { className: r$r("k-pager-numbers-wrap") }, D2, F2, te2, W3, _2),
      v3 ? p6 && $2 : $2,
      v3 ? t6 && q2 : q2
    );
  }
  renderButton(p6, t6, e3, i16, u5, m3) {
    return /* @__PURE__ */ reactExports.createElement(
      p$j,
      {
        fillMode: "flat",
        themeColor: "base",
        size: this.props.size,
        rounded: null,
        className: t6,
        icon: i16,
        svgIcon: u5,
        title: e3,
        role: "button",
        "aria-disabled": m3,
        tabIndex: this.props.navigatable ? -1 : void 0,
        onClick: (g6) => {
          g6.preventDefault(), this.changePage(p6, g6);
        }
      }
    );
  }
  get totalPages() {
    return Math.ceil((this.props.total || 0) / this.props.take);
  }
};
M$7.propTypes = {
  className: o$r.string,
  style: o$r.object,
  total: o$r.number.isRequired,
  skip: o$r.number.isRequired,
  take: o$r.number.isRequired,
  buttonCount: o$r.number,
  info: o$r.bool,
  type: o$r.oneOf(["numeric", "input"]),
  pageSizes: o$r.arrayOf(o$r.oneOfType([o$r.string, o$r.number])),
  previousNext: o$r.bool,
  onPageChange: o$r.func,
  messagesMap: o$r.func,
  size: o$r.oneOf([null, "small", "medium", "large"]),
  dir: o$r.string,
  disabled: o$r.bool
}, M$7.defaultProps = {
  buttonCount: 10,
  info: true,
  type: "numeric",
  size: "medium",
  disabled: false
};
let P$8 = M$7;
p$t(P$8);
v$a(P$8);
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let n$9 = class n6 extends reactExports.Component {
  constructor() {
    super(...arguments), this.draggable = null, this.isDragged = false, this.onDrag = (e3) => {
      this.isDragged = true;
      const t6 = this.draggable && this.draggable.element;
      t6 && this.props.resize(e3.event, t6, false);
    }, this.onRelease = (e3) => {
      if (!this.isDragged)
        return;
      const t6 = this.draggable && this.draggable.element;
      t6 && this.props.resize(e3.event, t6, true), this.isDragged = false;
    }, this.onDoubleClick = (e3) => {
      if (this.isDragged)
        return;
      const t6 = this.draggable && this.draggable.element;
      t6 && this.props.autofit && this.props.autofit(e3, t6);
    };
  }
  render() {
    return /* @__PURE__ */ reactExports.createElement(
      m$i,
      {
        onPress: (e3) => {
          e3.event.originalEvent.stopPropagation();
        },
        onDrag: this.onDrag,
        onRelease: this.onRelease,
        autoScroll: { direction: { vertical: false, horizontal: true } },
        ref: (e3) => {
          this.draggable = e3;
        }
      },
      /* @__PURE__ */ reactExports.createElement(
        "span",
        {
          className: "k-column-resizer",
          style: { touchAction: "none" },
          draggable: false,
          onDoubleClick: this.onDoubleClick
        }
      )
    );
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const e$7 = "data-keyboardnavlevel", a$9 = "data-keyboardnavscope", t$a = "data-keyboardnavheader", A$6 = "data-keyboardnavbody", o$6 = "data-keyboardnavid", n$8 = "_filter", d$a = "k-grid-cancel-command", r$2 = "k-grid-edit-command", c$8 = {
  [a$9]: true
}, D$1 = {
  [t$a]: true
}, E$6 = {
  [A$6]: true
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const $$6 = (e3, t6, r12 = "cell") => `${t6}_${e3}_${r12}`, k$7 = (e3) => {
  if (e3)
    return parseInt(e3.getAttribute(e$7) || "", 10);
}, I$6 = (e3) => {
  if (!e3)
    return;
  const t6 = e3.getAttribute(o$6);
  return t6 || void 0;
}, E$5 = (e3) => e3 ? !!e3.getAttribute(o$6) : false, F$2 = (e3, t6 = { level: 0 }) => e3.querySelector(`[${e$7}='${t6.level}']`), m$5 = (e3) => e3 && e3.parentElement && e3.parentElement.closest(`[${e$7}]`), p$c = (e3, t6) => e3.querySelector(`[${o$6}='${t6}']`), R$3 = (e3) => e3 && e3.parentElement && e3.parentElement.closest(`[${a$9}]`), L$6 = (e3) => {
  const t6 = e3 && e3.parentElement && e3.parentElement.closest(".k-grid-edit-row");
  return t6 && t6.querySelector("." + d$a);
}, q$3 = (e3) => document.querySelector(`[aria-rowindex="${e3}"] .k-grid-remove-command`), u$7 = (e3) => document.querySelector(`[data-keyboardnavid="${e3}"]`), O$4 = (e3) => {
  var n10;
  const t6 = e3 && e3.parentElement && e3.parentElement.closest(".k-table-row");
  let r12;
  return (n10 = t6 == null ? void 0 : t6.parentElement) == null || n10.childNodes.forEach((o9) => {
    if (t6 === o9) {
      const l7 = o9.previousSibling;
      r12 = {
        current: t6.getAttribute("aria-rowindex"),
        prev: l7 && l7.getAttribute("aria-rowindex")
      };
    }
  }), r12;
};
async function _$2(e3, t6, r12 = 5e3) {
  const n10 = Date.now();
  if (t6)
    for (; Date.now() - n10 < r12; ) {
      const o9 = t6.querySelector(e3);
      if (o9)
        return o9;
      await new Promise((l7) => setTimeout(l7, 20));
    }
  return false;
}
const K$3 = async (e3) => {
  const t6 = e3 && e3.parentElement && e3.parentElement.closest(".k-grid-edit-row");
  return await _$2("." + r$2, t6);
}, V$4 = (e3) => (e3 == null ? void 0 : e3.closest(".k-table-td")) || null, Y$3 = (e3) => e3.querySelector(`[${t$a}]`), P$7 = (e3) => e3.querySelector(`[${A$6}]`), oe$1 = (e3) => e3.querySelector(".k-grid-norecords"), le$2 = (e3) => {
  const t6 = e3.querySelector(".k-grid-edit-cell"), r12 = t6 && t6.querySelector("input");
  r12 ? r12.focus() : t6 && t6.firstChild.focus();
}, U$2 = (e3, t6) => {
  const {
    scope: r12,
    navigationStateRef: n10,
    contextStateRef: o9
  } = e3;
  if (!n10.current || !r12)
    return;
  const l7 = Q$2(n10.current.navigationMatrix), s10 = p$c(r12, l7);
  x$7({ elementForFocus: s10, contextStateRef: o9, event: t6 });
}, j$1 = (e3, t6 = { focusable: false }) => {
  const r12 = t6.focusable ? s$u : i$v;
  return Array.from(e3.querySelectorAll(r12.join(",")));
}, W$3 = (e3, t6 = { level: 0 }) => {
  if (!e3)
    return [];
  const r12 = s$u.map((n10) => n10 + `[${e$7}='${t6.level}']`).join(",");
  return Array.from(e3.querySelectorAll(r12));
}, H$2 = (e3 = { level: 0 }) => {
  const t6 = s$u.map(
    (r12) => r12 + `[${e$7}='${e3.level}']`
  ).join(",");
  return (r12) => r12.matches(t6);
}, x$7 = (e3) => {
  const { elementForFocus: t6, event: r12, contextStateRef: n10, prevElement: o9 } = e3;
  if (n10.current && t6 && t6.focus) {
    r12 == null || r12.preventDefault();
    const l7 = t6.querySelector(".k-checkbox-wrap .k-checkbox");
    l7 && l7.focus ? l7.focus() : t6.focus(), E$5(t6) && (t6.setAttribute("tabIndex", "0"), n10.current.activeId = I$6(t6)), o9 && E$5(o9) && o9.setAttribute("tabIndex", "-1");
  }
}, M$6 = (e3) => e3.current ? e3.current.idPrefix : "", X$1 = (e3, t6, r12, n10, o9) => {
  if (!r12)
    return [];
  let l7 = e3 + (o9 ? -1 : 1);
  for (; l7 >= 0 && l7 < n10.length; ) {
    const s10 = n10[l7][t6];
    if (s10 !== r12)
      return [s10, [l7, t6]];
    l7 = l7 + (o9 ? -1 : 1);
  }
  return [];
}, d$9 = (e3, t6, r12, n10, o9) => {
  if (!r12)
    return [];
  let l7 = t6 + (o9 ? -1 : 1);
  for (; l7 >= 0 && n10[e3] && l7 < n10[e3].length; ) {
    const s10 = n10[e3][l7];
    if (s10 !== r12)
      return [s10, [e3, l7]];
    l7 = l7 + (o9 ? -1 : 1);
  }
  return [];
}, A$5 = (e3, t6) => {
  if (t6) {
    for (let r12 = 0; r12 < e3.length; r12++)
      for (let n10 = 0; n10 < e3[r12].length; n10++)
        if (e3[r12][n10] === t6)
          return [r12, n10];
  }
}, C$9 = (e3, t6, r12) => {
  let n10;
  do
    if (e3 = e3 + 1, n10 = t6[r12 - e3], n10 && n10.editable)
      break;
  while (r12 - e3 >= 0);
  return n10;
}, z$4 = (e3, t6, r12, n10) => {
  var v3;
  let o9;
  const [l7, s10] = e3;
  let i16;
  const c6 = 0, a9 = t6.length;
  return i16 = C$9(c6, t6, s10), i16 ? o9 = d$9(l7, i16.ariaColumnIndex, r12, n10, true) : (i16 = C$9(c6, t6, a9), o9 = d$9(l7 - 1, i16.ariaColumnIndex, r12, n10, true)), {
    prevCell: o9 && o9[0] && u$7(o9[0]),
    elementToFocus: o9 && o9[0] && ((v3 = u$7(o9[0])) == null ? void 0 : v3.getAttribute("role"))
  };
}, N$6 = (e3, t6, r12) => {
  let n10;
  do
    if (e3 = e3 + 1, n10 = t6[r12 + e3], n10 && n10.editable)
      break;
  while (r12 + e3 - 1 < t6.length);
  return n10;
}, G$6 = (e3, t6, r12, n10) => {
  var l7;
  let o9;
  if (e3) {
    const [s10, i16] = e3;
    let c6, a9 = 0;
    c6 = N$6(a9, t6, i16), c6 ? o9 = d$9(s10, c6.ariaColumnIndex, r12, n10, true) : (a9 = -1, c6 = N$6(a9, t6, 0), o9 = d$9(s10 + 1, c6.ariaColumnIndex, r12, n10, true));
  }
  return {
    nextCell: o9 && o9[0] && u$7(o9[0]),
    elementToFocus: o9 && o9[0] && ((l7 = u$7(o9[0])) == null ? void 0 : l7.getAttribute("role"))
  };
}, J$2 = (e3) => e3.current ? e3.current.navigationMatrix.length : 0, Q$2 = (e3) => e3.flat().find((t6) => t6.endsWith("cell")), se = (e3) => e3.flat().reverse().find((t6) => t6.endsWith("cell")), ce$2 = (e3, t6) => e3[t6][0], ie = (e3, t6) => Array.from(e3[t6]).reverse()[0], Z$3 = (e3) => e3 ? `${e3}${n$8}` : "", ae = (e3, t6, r12) => {
  let n10;
  if (e3.current && e3.current.prevNavigationIndexes) {
    const [o9, l7] = e3.current.prevNavigationIndexes, s10 = t6[o9];
    s10 && s10[l7] === r12 ? n10 = e3.current.prevNavigationIndexes : n10 = A$5(t6, r12);
  } else
    n10 = A$5(t6, r12);
  return n10;
}, ee$1 = (e3) => {
  var t6;
  return ((t6 = m$5(e3)) == null ? void 0 : t6.getAttribute("data-keyboardnavid")) || e3.getAttribute("data-keyboardnavid");
}, ue = {
  generateNavigatableId: $$6,
  getNavigatableId: I$6,
  getNavigatableLevel: k$7,
  getNavigatableElement: F$2,
  getClosestNavigatableElement: m$5,
  getActiveNavDataElement: p$c,
  getClosestScope: R$3,
  getHeaderElement: Y$3,
  getBodyElement: P$7,
  getFocusableElements: j$1,
  getNavigatableElements: W$3,
  filterNavigatableElements: H$2,
  focusElement: x$7,
  getIdPrefix: M$6,
  isNavigatable: E$5,
  findNextIdByRowIndex: X$1,
  findNextIdByCellIndex: d$9,
  findId: A$5,
  getNextNavigationIndex: J$2,
  getFilterColumnId: Z$3,
  focusFirstDataElement: U$2,
  getClosestCancelButton: L$6,
  getClosestEditButton: K$3,
  getRowAriaRowIndex: O$4,
  getRemoveButtonByAriaRowIndex: q$3,
  getTableCellByKeyboardNavId: u$7,
  getParentCell: V$4,
  waitForElementToBeVisible: _$2,
  getNextEditableCell: G$6,
  getPrevEditableCell: z$4,
  getClosestCellNavId: ee$1
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
function c$7(t6, d8) {
  const n10 = t6[d8].depth;
  let i16 = null;
  for (let h3 = d8 + 1; h3 < t6.length; h3++)
    if (t6[h3].depth === n10) {
      i16 = t6[h3];
      break;
    }
  return i16;
}
const p$b = (t6) => {
  let d8 = t6.width ? parseFloat(t6.width.toString()) : 0;
  return !d8 && t6.children && t6.children.length && (d8 = t6.children.reduce((n10, i16) => p$b(i16) + n10, 0)), d8;
};
function I$5(t6, d8) {
  const n10 = [[]];
  let i16 = 0;
  for (let e3 = t6.length - 1; e3 >= 0; e3--)
    i16 = Math.max(i16, t6[e3].depth), t6[e3].colSpan = t6[e3].colSpan || 1, t6[e3].children.length > 0 && (t6[e3].colSpan = t6[e3].children.reduce((l7, a9) => a9.hidden ? l7 : l7 + a9.colSpan, 0));
  const h3 = [];
  let r12 = 1;
  return t6.forEach((e3, l7) => {
    n10[e3.depth] = n10[e3.depth] || [];
    let a9 = false;
    n10[e3.depth].length === 0 && (r12 <= 1 ? r12 = 1 + (e3.children.length > 0 ? 0 : i16 - e3.depth) : (r12--, a9 = true)), e3.rowSpan = 1 + (e3.children.length > 0 ? 0 : i16 - e3.depth), e3.kFirst = a9, e3.index = n10[e3.depth].length, n10[e3.depth].push(l7), e3.ariaColumnIndex = h3[e3.depth] ? h3[e3.depth] + 1 : 1;
    for (let f4 = e3.depth; f4 < e3.depth + e3.rowSpan; f4++)
      h3[f4] = (h3[f4] || 0) + e3.colSpan;
  }), x$6(n10, t6, d8), s$4(n10, t6, d8), n10;
}
function x$6(t6, d8, n10) {
  let i16 = new Array(t6.length).fill(0), h3 = 0;
  d8.forEach((r12) => {
    if (r12.locked && (!r12.left || n10))
      if (r12.left = i16[r12.depth], h3 = p$b(r12), r12.children.length === 0)
        for (let e3 = r12.depth; e3 < i16.length; e3++)
          i16[e3] += h3;
      else
        i16[r12.depth] += h3;
  });
}
function s$4(t6, d8, n10) {
  let i16 = 0, h3 = new Array(t6.length).fill(0);
  for (let r12 = d8.length - 1; r12 >= 0; r12--) {
    const e3 = d8[r12];
    if (e3.locked && (!e3.right || n10)) {
      if (e3.right = h3[e3.depth], i16 = p$b(e3), e3.children.length === 0)
        for (let a9 = e3.depth; a9 < h3.length; a9++)
          h3[a9] += i16;
      else
        h3[e3.depth] += i16;
      const l7 = c$7(d8, r12);
      e3.rightBorder = !(l7 && l7.locked);
    }
  }
}
function E$4(t6) {
  return !!(t6 && getComputedStyle(t6).direction === "rtl");
}
function k$6(t6, d8) {
  if (!d8 || !t6 || !t6.originalEvent)
    return -1;
  const n10 = { x: t6.clientX, y: t6.originalEvent.clientY };
  let i16 = d8.ownerDocument ? d8.ownerDocument.elementFromPoint(n10.x, n10.y) : null;
  for (; i16 && i16.parentElement !== d8; )
    i16 = i16.parentElement;
  if (!i16 && d8.matches("tr")) {
    const r12 = (e3) => {
      const l7 = e3.getBoundingClientRect();
      return n10.x > l7.left && n10.x < l7.left + l7.width && n10.y > l7.top && n10.y < l7.top + l7.height;
    };
    i16 = Array.from(d8.children).find(r12) || null;
  }
  const h3 = d8.children;
  for (let r12 = 0; r12 < h3.length; r12++)
    if (h3[r12] === i16)
      return r12;
  return -1;
}
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let p$a = class p2 extends reactExports.PureComponent {
  constructor(t6) {
    super(t6), this.elementRef = reactExports.createRef(), this.state = {
      visible: false,
      top: 0,
      left: 0,
      innerText: "",
      status: "k-i-cancel"
    }, this.hiddenElementRef = reactExports.createRef();
  }
  get element() {
    return this.elementRef.current || this.hiddenElementRef.current;
  }
  render() {
    const t6 = this.hiddenElementRef.current, { status: n10 } = this.state, s10 = this.state.visible && e$C && reactDomExports.createPortal(
      /* @__PURE__ */ reactExports.createElement(
        "div",
        {
          ref: this.elementRef,
          className: "k-header k-drag-clue",
          style: {
            display: "block",
            position: "absolute",
            zIndex: 2e4,
            padding: "8px 12px",
            top: this.state.top + "px",
            left: this.state.left + "px"
          }
        },
        /* @__PURE__ */ reactExports.createElement(v$c, { className: "k-drag-status", name: n10, icon: n10 === "k-i-cancel" ? cancelIcon : plusIcon }),
        this.state.innerText
      ),
      t6 && t6.ownerDocument ? t6.ownerDocument.body : document.body
    );
    return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, s10, /* @__PURE__ */ reactExports.createElement("div", { ref: this.hiddenElementRef, style: { display: "none" } }));
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let a$8 = class a6 extends reactExports.PureComponent {
  constructor(t6) {
    super(t6), this.state = {
      height: 0,
      visible: false,
      left: 0,
      top: 0
    }, this.hiddenElementRef = reactExports.createRef();
  }
  render() {
    const t6 = this.hiddenElementRef.current, n10 = this.state.visible && e$C && reactDomExports.createPortal(
      /* @__PURE__ */ reactExports.createElement(
        "div",
        {
          className: "k-grouping-dropclue",
          style: {
            zIndex: 1e4,
            display: "block",
            top: this.state.top + "px",
            left: this.state.left + "px",
            height: this.state.height + "px"
          }
        }
      ),
      t6 && t6.ownerDocument ? t6.ownerDocument.body : document.body
    );
    return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, n10, /* @__PURE__ */ reactExports.createElement("div", { ref: this.hiddenElementRef, style: { display: "none" } }));
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const t$9 = reactExports.createContext(void 0);
t$9.displayName = "KendoReactTableKeyboardNavigationContext";
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const c$6 = (o9, a9) => {
  const t6 = reactExports.useContext(t$9);
  return !t6 || !o9 || a9 === false ? {} : {
    tabIndex: t6 && t6.activeId && t6.activeId === o9 ? 0 : -1,
    [e$7]: t6.level,
    [o$6]: o9
  };
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
var e$6 = /* @__PURE__ */ ((n10) => (n10.incell = "incell", n10.inline = "inline", n10))(e$6 || {});
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const M$5 = (e3) => {
  const { navigatable: l7, contextStateRef: o9, navigationStateRef: n10, idPrefix: i16 } = e3;
  l7 && (o9.current = {
    activeId: "",
    level: 0
  }, n10.current = {
    activeElementIsFocused: false,
    prevNavigationIndexes: void 0,
    idPrefix: i16 || i$u(),
    navigationMatrix: [],
    lastHeaderIndex: -1
  });
}, L$5 = (e3) => {
  const { scope: l7, contextStateRef: o9, navigationStateRef: n10 } = e3;
  if (o9.current && n10.current && l7) {
    h$2(e3);
    const i16 = Q$2(n10.current.navigationMatrix);
    if (i16) {
      const f4 = ue.getActiveNavDataElement(l7, i16);
      f4 && (o9.current.activeId = i16, f4.setAttribute("tabIndex", "0"));
    }
  }
}, Y$2 = (e3) => {
  const { contextStateRef: l7, navigationStateRef: o9, document: n10 } = e3;
  if (l7.current && o9.current && n10) {
    const i16 = o$k(n10), f4 = ue.getNavigatableId(i16);
    f4 && f4 === l7.current.activeId && (o9.current.activeElementIsFocused = true);
  }
}, Z$2 = (e3) => {
  const { scope: l7, contextStateRef: o9, navigationStateRef: n10, focusFirst: i16, newEditableRow: f4, singleEditRow: c6, lastActiveElement: v3, navigatable: a9 } = e3;
  if (i16 && (M$5(e3), L$5(e3), U$2(e3)), (!a9 || a9 && a9.mode === e$6.inline) && (f4 && !c6 || f4 && c6 && !v3) ? le$2(f4) : a9 && a9.mode === e$6.inline && f4 && c6 && v3 && v3.focus(), h$2(e3), o9.current && n10.current && l7) {
    if (!ue.getActiveNavDataElement(l7, o9.current.activeId)) {
      const E2 = l7.className.indexOf("k-treelist") === -1 ? Q$2(n10.current.navigationMatrix) : n10.current.navigationMatrix[0][0], I3 = ue.getActiveNavDataElement(l7, E2);
      E2 && I3 && (o9.current.activeId = E2, I3.setAttribute("tabIndex", "0"), n10.current.activeElementIsFocused && I3.focus());
    }
    n10.current.activeElementIsFocused = false;
  }
}, ee = (e3, l7) => {
  const { contextStateRef: o9 } = l7;
  if (e3.isDefaultPrevented() || !o9.current)
    return;
  const n10 = e3.target, i16 = ue.getNavigatableId(n10);
  if (i16 && i16 !== o9.current.activeId) {
    const f4 = ue.getClosestScope(n10);
    if (!f4)
      return;
    const c6 = ue.getActiveNavDataElement(f4, o9.current.activeId);
    c6 && !e3.target.classList.contains("k-table-td") && !e3.target.classList.contains("k-detail-cell") && c6.setAttribute("tabIndex", "-1"), n10.setAttribute("tabIndex", "0"), o9.current.activeId = i16;
  } else if (n10.closest(".k-filtercell") && l7.navigatable) {
    const f4 = n10.closest(".k-table-th");
    g$j(f4);
  }
}, te = async (e3, l7) => {
  var N3, p6, R2, A2;
  const {
    contextStateRef: o9,
    navigationStateRef: n10,
    onNavigationAction: i16,
    columns: f4
  } = l7;
  if (e3.isDefaultPrevented() || !o9.current || !n10.current)
    return;
  let c6;
  if (e3.keyCode === e$B.esc && !l7.navigatable.mode) {
    c6 = ue.getClosestNavigatableElement(e3.target), ue.focusElement({ elementForFocus: c6, event: e3, contextStateRef: o9 }), e3.target.closest(".k-filtercell") && c6 && l7.navigatable && y$c(c6);
    return;
  }
  const v3 = e3.target, a9 = v3.className.indexOf("k-checkbox") === -1 ? v3 : ue.getClosestNavigatableElement(v3), m3 = ue.getNavigatableId(a9) || ((N3 = ue.getParentCell(a9)) == null ? void 0 : N3.getAttribute("data-keyboardnavid")), E2 = m3 == null ? void 0 : m3.endsWith("column"), I3 = ue.getNavigatableLevel(a9), x3 = ue.getClosestScope(a9), y4 = n10.current.navigationMatrix, k3 = e3.metaKey || e3.ctrlKey, u5 = ae(n10, y4, m3), C2 = a9.closest(".k-table-th");
  if (l7.navigatable && l7.navigatable.mode === e$6.inline) {
    if (e3.keyCode === e$B.enter) {
      const d8 = a9.classList.contains("k-grid-remove-command"), r12 = a9.classList.contains("k-grid-cancel-command"), g6 = ue.getRowAriaRowIndex(a9);
      if (d8) {
        setTimeout(() => {
          const b2 = ue.getRemoveButtonByAriaRowIndex(g6.current) || ue.getRemoveButtonByAriaRowIndex(g6.prev);
          b2 && b2.focus();
        });
        return;
      } else if (r12 && a9.parentElement) {
        const b2 = (p6 = ue.getClosestNavigatableElement(a9)) == null ? void 0 : p6.getAttribute("data-keyboardnavid");
        setTimeout(() => {
          b2 && ue.getTableCellByKeyboardNavId(b2).focus();
        });
        return;
      }
    }
    if (e3.keyCode === e$B.esc) {
      const d8 = ue.getClosestCancelButton(a9);
      d8 && d8.click();
      const r12 = await ue.getClosestEditButton(a9);
      r12 && r12.focus();
      return;
    }
  } else if (l7.navigatable && l7.navigatable.mode === e$6.incell) {
    const d8 = (R2 = a9.closest(".k-table-td")) == null ? void 0 : R2.classList.contains("k-grid-edit-cell");
    if (e3.keyCode === e$B.esc) {
      a9.focus(), a9.blur();
      const r12 = v3 && v3.parentElement && v3.parentElement.closest(".k-grid-edit-row"), g6 = ue.getClosestCellNavId(a9), b2 = await ue.waitForElementToBeVisible(`[data-keyboardnavid='${g6}']:not(.k-grid-edit-cell)`, r12);
      b2 && b2.focus();
    } else if (e3.keyCode === e$B.enter) {
      let r12;
      if (u5) {
        const [g6, b2] = u5;
        r12 = X$1(g6, b2, m3, y4, false);
      }
      if (!d8)
        (A2 = ue.getParentCell(a9)) == null || A2.click();
      else if (d8 && r12) {
        const g6 = r12 && r12[0] && ue.getTableCellByKeyboardNavId(r12[0]);
        g6 && g6.click();
      }
    } else if (e3.keyCode === e$B.left) {
      if (d8)
        return;
    } else if (e3.keyCode === e$B.right) {
      if (d8)
        return;
    } else if (e3.keyCode === e$B.up) {
      if (d8)
        return;
    } else if (e3.keyCode === e$B.down) {
      if (d8)
        return;
    } else if (e3.keyCode === e$B.tab && d8) {
      if (e3.shiftKey) {
        const r12 = u5 && f4 && ue.getPrevEditableCell(u5, f4, m3, y4);
        if (r12 && r12.prevCell && r12.prevCell.click(), r12 && r12.elementToFocus !== "gridcell") {
          a9.blur();
          const g6 = ue.getClosestCellNavId(a9);
          setTimeout(() => {
            g6 && ue.getTableCellByKeyboardNavId(g6).focus();
          });
        }
        e3.preventDefault();
      } else {
        const r12 = u5 && f4 && ue.getNextEditableCell(u5, f4, m3, y4);
        if (r12 && r12.nextCell && r12.elementToFocus === "gridcell" && r12.nextCell.click(), r12 && r12.elementToFocus !== "gridcell") {
          a9.blur();
          const g6 = ue.getClosestCellNavId(a9);
          g6 && ue.getTableCellByKeyboardNavId(g6).focus();
          return;
        }
        e3.preventDefault();
      }
      e3.preventDefault();
    }
  }
  if (a9.closest(".k-filtercell") && C2 && l7.navigatable && n$y(e3, C2, i$v), I3 !== void 0 && x3) {
    if (e3.keyCode === e$B.enter) {
      const d8 = ue.getNavigatableElement(a9, { level: I3 + 1 });
      if (d8) {
        ue.focusElement({
          elementForFocus: d8,
          event: e3,
          contextStateRef: o9,
          prevElement: a9
        });
        return;
      } else {
        a9.querySelector(".k-filtercell") && l7.navigatable && g$j(a9), c6 = ue.getFocusableElements(a9)[0], ue.focusElement({ elementForFocus: c6, event: e3, contextStateRef: o9, prevElement: a9 });
        return;
      }
    }
    if (e3.keyCode === e$B.home && u5)
      if (k3)
        U$2(
          {
            scope: x3,
            navigationStateRef: n10,
            contextStateRef: o9
          },
          e3
        );
      else {
        const d8 = ce$2(n10.current.navigationMatrix, u5[0]);
        c6 = ue.getActiveNavDataElement(x3, d8), ue.focusElement({ elementForFocus: c6, event: e3, contextStateRef: o9 });
      }
    if (e3.keyCode === e$B.end && u5)
      if (k3) {
        const d8 = se(n10.current.navigationMatrix);
        c6 = ue.getActiveNavDataElement(x3, d8), ue.focusElement({ elementForFocus: c6, event: e3, contextStateRef: o9 });
      } else {
        const d8 = ie(n10.current.navigationMatrix, u5[0]);
        c6 = ue.getActiveNavDataElement(x3, d8), ue.focusElement({ elementForFocus: c6, event: e3, contextStateRef: o9 });
      }
    if (e3.keyCode === e$B.up || e3.keyCode === e$B.down || e3.keyCode === e$B.left || e3.keyCode === e$B.right) {
      const d8 = e3.keyCode === e$B.up || e3.keyCode === e$B.left, r12 = e3.keyCode === e$B.up || e3.keyCode === e$B.down;
      if (u5) {
        const [g6, b2] = u5, [B2, K3] = r12 ? X$1(g6, b2, m3, y4, d8) : d$9(g6, b2, m3, y4, d8);
        B2 && (c6 = ue.getActiveNavDataElement(x3, B2), ue.focusElement({ elementForFocus: c6, event: e3, contextStateRef: o9, prevElement: a9 }), n10.current.prevNavigationIndexes = K3);
      }
    }
    if (k3 && e3.keyCode === e$B.left && E2) {
      i16 && i16({ focusElement: a9, event: e3, action: "reorderToLeft" }), e3.preventDefault();
      return;
    }
    if (k3 && e3.keyCode === e$B.right && E2) {
      i16 && i16({ focusElement: a9, event: e3, action: "reorderToRight" }), e3.preventDefault();
      return;
    }
    if (e3.keyCode === e$B.pageUp) {
      i16 && i16({ focusElement: c6, event: e3, action: "moveToNextPage" }), e3.preventDefault();
      return;
    }
    if (e3.keyCode === e$B.pageDown) {
      i16 && i16({ focusElement: c6, event: e3, action: "moveToPrevPage" }), e3.preventDefault();
      return;
    }
    i16 && i16({ focusElement: c6, event: e3 });
  }
}, h$2 = (e3) => {
  const { navigationStateRef: l7, scope: o9 } = e3;
  if (!l7.current || !o9)
    return;
  const n10 = [], i16 = Y$3(o9), f4 = P$7(o9), c6 = oe$1(o9) || { children: [] };
  if (!i16 || !f4)
    return;
  const v3 = Array.from(i16.children), a9 = Array.from(f4.children);
  [...v3, ...a9, c6].forEach((m3, E2) => {
    Array.from(m3.children).forEach((I3) => {
      const x3 = I$6(I3);
      if (!x3)
        return;
      const y4 = I3.rowSpan || 1, k3 = I3.colSpan || 1;
      let u5;
      for (let C2 = E2, N3 = E2 + y4; C2 < N3; C2++) {
        if (n10[C2] || (n10[C2] = []), u5 === void 0) {
          const p6 = n10[C2].findIndex((R2) => !R2);
          u5 = p6 > -1 ? p6 : n10[C2].length;
        }
        n10[C2][u5] = x3 || "";
      }
      for (let C2 = u5 + 1, N3 = u5 + k3; C2 < N3; C2++)
        n10[E2][C2] = x3 || "";
    });
  }), l7.current.navigationMatrix = n10.filter((m3) => !!m3), l7.current.lastHeaderIndex = v3.length - 1;
}, le$1 = {
  onConstructor: M$5,
  onComponentDidMount: L$5,
  onGetSnapshotBeforeUpdate: Y$2,
  onComponentDidUpdate: Z$2,
  onFocus: ee,
  onKeyDown: te,
  generateMatrix: h$2,
  focusFirstDataElement: U$2
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const E$3 = "data-grid-row-index", T$4 = "data-grid-col-index", t$8 = "data-prevent-selection";
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const J$1 = (e3) => {
  let t6 = e3;
  for (; t6; ) {
    if (t6.hasAttribute(t$8))
      return true;
    t6 = t6.parentElement;
  }
  return false;
}, A$4 = (e3, t6) => {
  let o9 = e3;
  for (; o9; ) {
    if (o9.tagName === t6)
      return o9;
    if (o9.tagName === "TABLE")
      return null;
    o9 = o9.parentElement;
  }
  return null;
}, b$4 = (e3) => {
  if (!e3)
    return;
  const t6 = e3.getAttribute(E$3);
  return t6 ? parseInt(t6, 10) : void 0;
}, V$3 = (e3) => {
  if (!e3)
    return;
  const t6 = e3.getAttribute(T$4);
  return t6 ? parseInt(t6, 10) : void 0;
}, W$2 = s$q(), Z$1 = (e3) => {
  if (!e3 || !W$2)
    return null;
  let t6 = e3.parentElement;
  for (; t6; ) {
    if (window.getComputedStyle(t6).transform !== "none")
      return t6;
    t6 = t6.parentElement;
  }
}, $$5 = (e3) => {
  if (e3 && e3.ownerDocument && e3 !== e3.ownerDocument.body) {
    const t6 = e3.getBoundingClientRect();
    return {
      left: t6.left - e3.scrollLeft,
      top: t6.top - e3.scrollTop
    };
  }
  return { left: 0, top: 0 };
}, P$6 = (e3) => {
  const t6 = e3 ? typeof e3.enabled == "boolean" ? e3.enabled : true : false, o9 = e3 ? !!e3.drag : false, d8 = e3 && e3.mode ? e3.mode : "multiple", a9 = !!(e3 && e3.cell);
  return { enabled: t6, drag: o9, mode: d8, cell: a9 };
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const ce$1 = (u5) => {
  var w3;
  const { onRelease: D2, childRef: I3 } = u5, {
    enabled: q2,
    drag: M3,
    mode: o9,
    cell: X2
  } = P$6(u5.selectable), r12 = reactExports.useRef(null), Y2 = reactExports.useRef(null), d8 = reactExports.useRef({ clientX: 0, clientY: 0, scrollX: 0, scrollY: 0, pressedElement: null }), [T3, f4] = reactExports.useState(null), C2 = reactExports.useRef(), g6 = reactExports.useRef(false), y4 = reactExports.useRef(false), j2 = reactExports.useCallback(
    (s10) => {
      const { event: e3 } = s10;
      if (y4.current = J$1(e3.originalEvent.target), y4.current || !r12.current)
        return;
      C2.current = Z$1(r12.current.element);
      const n10 = r12.current.element && r12.current.element.ownerDocument;
      if (!n10)
        return;
      const l7 = n10.elementFromPoint(e3.clientX, e3.clientY);
      d8.current = {
        clientY: e3.clientY,
        clientX: e3.clientX,
        scrollX: e3.scrollX,
        scrollY: e3.scrollY,
        pressedElement: l7
      };
    },
    []
  ), z3 = reactExports.useCallback(
    (s10) => {
      const { event: e3 } = s10, { clientX: n10, clientY: l7 } = d8.current;
      if (!y4.current && !(!M3 || o9 === "single") && ((Math.abs(l7 - e3.clientY) > 5 || Math.abs(n10 - e3.clientX) > 5) && (g6.current = true), g6.current)) {
        const E2 = $$5(C2.current);
        f4({
          top: Math.min(l7, e3.clientY) - E2.top,
          left: Math.min(n10, e3.clientX) - E2.left,
          width: Math.abs(e3.clientX - n10),
          height: Math.abs(e3.clientY - l7)
        });
      }
    },
    [f4, M3, o9]
  ), A2 = reactExports.useCallback(
    (s10) => {
      const { event: e3 } = s10, { clientX: n10, clientY: l7, scrollX: E2, scrollY: G2, pressedElement: J2 } = d8.current;
      if (y4.current || !r12.current)
        return;
      const R2 = r12.current.element && r12.current.element.ownerDocument;
      if (R2) {
        if (g6.current) {
          const i16 = e3.scrollY - G2, v3 = e3.scrollX - E2, h3 = Math.min(l7, e3.clientY), a9 = Math.min(n10, e3.clientX), m3 = Math.max(l7, e3.clientY), L3 = Math.max(n10, e3.clientX), b2 = Y2.current;
          if (!b2)
            return;
          b2.style.visibility = "hidden";
          const Q2 = R2.elementFromPoint(a9, h3), P2 = i16 > 0 || v3 > 0 ? J2 : Q2, p6 = R2.elementFromPoint(L3, m3);
          if (b2.style.visibility = "", !P2 || !p6)
            return;
          const S2 = A$4(P2, "TD"), U3 = A$4(S2, "TR"), k3 = A$4(p6, "TD"), V3 = A$4(k3, "TR"), F2 = V$3(S2), O2 = b$4(U3), H3 = V$3(k3), N3 = b$4(V3);
          F2 !== void 0 && O2 !== void 0 && H3 !== void 0 && N3 !== void 0 && D2({
            nativeEvent: e3.originalEvent,
            startRowIndex: O2,
            startColIndex: F2,
            endRowIndex: N3,
            endColIndex: H3,
            altKey: e3.altKey,
            shiftKey: e3.shiftKey,
            ctrlKey: e3.ctrlKey,
            metaKey: e3.metaKey,
            mode: o9,
            cell: X2,
            isDrag: true
          });
        } else {
          const i16 = R2.elementFromPoint(n10, l7);
          if (!i16)
            return;
          const v3 = A$4(i16, "TD"), h3 = A$4(i16, "TR"), a9 = V$3(v3), m3 = b$4(h3);
          v3 && h3 && m3 !== void 0 && a9 !== void 0 && D2({
            nativeEvent: e3.originalEvent,
            startRowIndex: m3,
            startColIndex: a9,
            endRowIndex: m3,
            endColIndex: a9,
            altKey: e3.altKey,
            shiftKey: e3.shiftKey,
            ctrlKey: e3.ctrlKey,
            metaKey: e3.metaKey,
            mode: o9,
            cell: X2,
            isDrag: false
          });
        }
        f4(null), g6.current = false, d8.current = { clientX: 0, clientY: 0, scrollX: 0, scrollY: 0, pressedElement: null };
      }
    },
    [f4, o9, X2, D2]
  ), B2 = o$m(Y2);
  return q2 ? /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(
    m$i,
    {
      onPress: j2,
      onDrag: z3,
      onRelease: A2,
      ref: r12,
      childRef: I3
    },
    u5.children
  ), T3 && reactDomExports.createPortal(
    /* @__PURE__ */ reactExports.createElement(
      "div",
      {
        ref: Y2,
        style: { ...T3, position: "fixed" },
        className: "k-marquee k-marquee-color"
      }
    ),
    (w3 = B2()) == null ? void 0 : w3.body
  )) : reactExports.cloneElement(reactExports.Children.only(u5.children), { ref: I3 });
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
var L$4 = /* @__PURE__ */ ((t6) => (t6.copy = "copy", t6.cut = "cut", t6.paste = "paste", t6))(L$4 || {});
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let n$7 = class n7 {
  constructor(r12) {
    this.copyHandler = (e3) => {
      this.clipboardEvent(L$4.copy, e3);
    }, this.cutHandler = (e3) => {
      this.clipboardEvent(L$4.cut, e3);
    }, this.pasteHandler = (e3) => {
      this.clipboardEvent(L$4.paste, e3);
    }, this.addEventListeners = (e3) => {
      e3 && (e3.addEventListener(L$4.copy, this.copyHandler), e3.addEventListener(L$4.cut, this.cutHandler), e3.addEventListener(L$4.paste, this.pasteHandler));
    }, this.removeEventListeners = (e3) => {
      e3 && (e3.removeEventListener(L$4.copy, this.copyHandler), e3.removeEventListener(L$4.cut, this.cutHandler), e3.removeEventListener(L$4.paste, this.pasteHandler));
    }, this.clipboardEvent = r12;
  }
};
var cloneDate = function(date) {
  return date ? new Date(date.getTime()) : null;
};
var adjustDST = function(date, hour) {
  var newDate = cloneDate(date);
  if (hour === 0 && newDate.getHours() === 23) {
    newDate.setHours(newDate.getHours() + 2);
  }
  return newDate;
};
var addDays = function(date, offset2) {
  var newDate = cloneDate(date);
  newDate.setDate(newDate.getDate() + offset2);
  return adjustDST(newDate, date.getHours());
};
var createDate = function(year, month, day, hours, minutes, seconds, milliseconds) {
  if (hours === void 0) {
    hours = 0;
  }
  if (minutes === void 0) {
    minutes = 0;
  }
  if (seconds === void 0) {
    seconds = 0;
  }
  if (milliseconds === void 0) {
    milliseconds = 0;
  }
  var date = new Date(year, month, day, hours, minutes, seconds, milliseconds);
  if (year > -1 && year < 100) {
    date.setFullYear(date.getFullYear() - 1900);
  }
  return adjustDST(date, hours);
};
var lastDayOfMonth = function(date) {
  var newDate = createDate(date.getFullYear(), date.getMonth() + 1, 1, date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
  return addDays(newDate, -1);
};
var MONTHS_LENGTH = 12;
var normalize = function(date, expectedMonth) {
  return date.getMonth() !== expectedMonth ? lastDayOfMonth(addMonths(date, -1)) : date;
};
var addMonths = function(date, offset2) {
  var newDate = cloneDate(date);
  var diff = (newDate.getMonth() + offset2) % MONTHS_LENGTH;
  var expectedMonth = (MONTHS_LENGTH + diff) % MONTHS_LENGTH;
  newDate.setMonth(newDate.getMonth() + offset2);
  return normalize(adjustDST(newDate, date.getHours()), expectedMonth);
};
var setYear = function(value2, year) {
  var month = value2.getMonth();
  var candidate = createDate(year, month, value2.getDate(), value2.getHours(), value2.getMinutes(), value2.getSeconds(), value2.getMilliseconds());
  return candidate.getMonth() === month ? candidate : lastDayOfMonth(addMonths(candidate, -1));
};
var addYears = function(value2, offset2) {
  return adjustDST(setYear(value2, value2.getFullYear() + offset2), value2.getHours());
};
var addCenturies = function(value2, offset2) {
  return addYears(value2, 100 * offset2);
};
var addDecades = function(value2, offset2) {
  return addYears(value2, 10 * offset2);
};
var addWeeks = function(date, offset2) {
  return addDays(date, offset2 * 7);
};
var MS_PER_DAY = 864e5;
var Direction;
(function(Direction2) {
  Direction2[Direction2["Forward"] = 1] = "Forward";
  Direction2[Direction2["Backward"] = -1] = "Backward";
})(Direction || (Direction = {}));
var dayOfWeek = function(date, weekDay, direction) {
  if (direction === void 0) {
    direction = Direction.Forward;
  }
  var newDate = cloneDate(date);
  var newDay = (weekDay - newDate.getDay() + 7 * direction) % 7;
  newDate.setDate(newDate.getDate() + newDay);
  return adjustDST(newDate, date.getHours());
};
var Day;
(function(Day2) {
  Day2[Day2["Sunday"] = 0] = "Sunday";
  Day2[Day2["Monday"] = 1] = "Monday";
  Day2[Day2["Tuesday"] = 2] = "Tuesday";
  Day2[Day2["Wednesday"] = 3] = "Wednesday";
  Day2[Day2["Thursday"] = 4] = "Thursday";
  Day2[Day2["Friday"] = 5] = "Friday";
  Day2[Day2["Saturday"] = 6] = "Saturday";
})(Day || (Day = {}));
var normalizeYear = function(value2, year) {
  return setYear(value2, year(value2.getFullYear()));
};
var firstDecadeOfCentury = function(value2) {
  return normalizeYear(value2, function(y4) {
    return y4 - y4 % 100;
  });
};
var durationInCenturies = function(start, end) {
  return (firstDecadeOfCentury(end).getFullYear() - firstDecadeOfCentury(start).getFullYear()) / 100;
};
var firstYearOfDecade = function(value2) {
  return normalizeYear(value2, function(y4) {
    return y4 - y4 % 10;
  });
};
var durationInDecades = function(start, end) {
  return (firstYearOfDecade(end).getFullYear() - firstYearOfDecade(start).getFullYear()) / 10;
};
var durationInMonths = function(start, end) {
  return (end.getFullYear() - start.getFullYear()) * 12 + (end.getMonth() - start.getMonth());
};
var durationInYears = function(start, end) {
  return end.getFullYear() - start.getFullYear();
};
var firstDayOfMonth = function(date) {
  return createDate(date.getFullYear(), date.getMonth(), 1, date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
};
var setMonth = function(value2, month) {
  var day = value2.getDate();
  var candidate = createDate(value2.getFullYear(), month, day, value2.getHours(), value2.getMinutes(), value2.getSeconds(), value2.getMilliseconds());
  return candidate.getDate() === day ? candidate : lastDayOfMonth(addMonths(candidate, -1));
};
var firstMonthOfYear = function(value2) {
  return setMonth(value2, 0);
};
var getDate = function(date) {
  return createDate(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0);
};
var isEqual = function(candidate, expected) {
  if (!candidate && !expected) {
    return true;
  }
  return candidate && expected && candidate.getTime() === expected.getTime();
};
var isEqualDate = function(candidate, expected) {
  if (!candidate && !expected) {
    return true;
  }
  return candidate && expected && isEqual(getDate(candidate), getDate(expected));
};
var lastDecadeOfCentury = function(value2) {
  return normalizeYear(value2, function(y4) {
    return y4 - y4 % 100 + 90;
  });
};
var lastMonthOfYear = function(value2) {
  return setMonth(value2, 11);
};
var lastYearOfDecade = function(value2) {
  return normalizeYear(value2, function(y4) {
    return y4 - y4 % 10 + 9;
  });
};
var prevDayOfWeek = function(date, weekDay) {
  return dayOfWeek(date, weekDay, Direction.Backward);
};
var moveDateToWeekStart = function(date, weekStartDay) {
  if (weekStartDay !== Day.Monday) {
    return addDays(prevDayOfWeek(date, weekStartDay), 4);
  }
  return addDays(date, 4 - (date.getDay() || 7));
};
var calcWeekInYear = function(date, weekStartDay) {
  var firstWeekInYear = createDate(date.getFullYear(), 0, 1, -6);
  var newDate = moveDateToWeekStart(date, weekStartDay);
  var diffInMS = newDate.getTime() - firstWeekInYear.getTime();
  var days = Math.floor(diffInMS / MS_PER_DAY);
  return 1 + Math.floor(days / 7);
};
var weekInYear = function(date, weekStartDay) {
  if (weekStartDay === void 0) {
    weekStartDay = Day.Monday;
  }
  date = getDate(date);
  var prevWeekDate = addDays(date, -7);
  var nextWeekDate = addDays(date, 7);
  var weekNumber = calcWeekInYear(date, weekStartDay);
  if (weekNumber === 0) {
    return calcWeekInYear(prevWeekDate, weekStartDay) + 1;
  }
  if (weekNumber === 53 && calcWeekInYear(nextWeekDate, weekStartDay) > 1) {
    return 1;
  }
  return weekNumber;
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const e$5 = {
  name: "@progress/kendo-react-dateinputs",
  productName: "KendoReact",
  productCodes: ["KENDOUIREACT", "KENDOUICOMPLETE"],
  publishDate: 1728906575,
  version: "",
  licensingDocsUrl: "https://www.telerik.com/kendo-react-ui/components/my-license/?utm_medium=product&utm_source=kendoreact&utm_campaign=kendo-ui-react-purchase-license-keys-warning"
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const a$7 = (e3) => Math.max(e3, 0);
let f$3 = class f2 {
  constructor(t6) {
    this.offset = t6;
  }
};
let d$8 = class d4 {
  constructor(t6) {
    this.skip = t6;
  }
};
let w$7 = class w {
  constructor(t6, s10) {
    this.onScrollAction = t6, this.onPageAction = s10, this.direction = "vertical", this.firstLoaded = 0, this.lastLoaded = 0, this.lastScrollTop = 0, this.take = 0, this.total = 0, this.rowHeightService = null, this.bottomOffset = 0, this.topOffset = 0;
  }
  create(t6, s10, h3, l7, i16 = 0, n10 = 0, r12 = "vertical") {
    this.rowHeightService = t6, this.firstLoaded = s10, this.lastLoaded = s10 + h3, this.take = h3, this.total = l7, this.lastScrollTop = 0, this.topOffset = i16, this.bottomOffset = n10, this.direction = r12;
    const o9 = this.rowsForHeight(i16), c6 = a$7(s10 - o9);
    this.onScrollAction(new f$3(this.rowOffset(c6))), this.onPageAction(new d$8(c6));
  }
  onScroll({ scrollLeft: t6, scrollTop: s10, offsetHeight: h3, offsetWidth: l7 }) {
    const i16 = this.direction === "vertical" ? s10 : t6, n10 = this.direction === "vertical" ? h3 : l7;
    if (this.lastScrollTop === i16 || !this.rowHeightService)
      return;
    const r12 = this.lastScrollTop >= i16;
    this.lastScrollTop = i16;
    const o9 = this.rowHeightService.index(a$7(i16 - this.topOffset)), c6 = this.rowHeightService.index(a$7(i16 + n10 - this.bottomOffset));
    if (!r12 && c6 >= this.lastLoaded && this.lastLoaded < this.total && (this.firstLoaded = o9, this.onScrollAction(new f$3(this.rowOffset(o9))), this.lastLoaded = Math.min(this.firstLoaded + this.take, this.total), this.onPageAction(new d$8(this.firstLoaded))), r12 && o9 <= this.firstLoaded) {
      const S2 = Math.floor(this.take * 0.3);
      this.firstLoaded = a$7(o9 - S2), this.onScrollAction(new f$3(this.rowOffset(this.firstLoaded))), this.lastLoaded = Math.min(this.firstLoaded + this.take, this.total), this.onPageAction(new d$8(this.firstLoaded));
    }
  }
  rowOffset(t6) {
    return this.rowHeightService ? this.rowHeightService.offset(t6) + this.topOffset : 0;
  }
  rowsForHeight(t6) {
    return this.rowHeightService ? Math.ceil(t6 / this.rowHeightService.height(0)) : 0;
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const T$3 = (s10, i16, t6) => Math.min(Math.abs(i16 - s10), t6), A$3 = 17, C$8 = 10, x$5 = {
  1: (s10) => (i16) => i16 + s10,
  0: (s10) => (i16) => i16 - s10
}, I$4 = {
  1: (s10) => (i16) => Math.min(i16, s10),
  0: (s10) => (i16) => Math.max(i16, s10)
}, M$4 = {
  1: (s10) => (i16) => i16 < s10,
  0: (s10) => (i16) => i16 > s10
}, a$6 = class a7 extends reactExports.Component {
  constructor(i16) {
    super(i16), this.rowHeightService = null, this.scrollContainer = null, this.lastDirection = null, this.lastTotal = 0, this.lastTake = 0, this.animationInProgress = false, this.restrictScroll = false, this.scrollTo = (t6) => {
      const e3 = this.direction === "vertical" ? "scrollTop" : "scrollLeft";
      if (!this.scrollContainer)
        return;
      const r12 = this.scrollContainer[e3];
      this.restrictScroll && e3 === "scrollTop" && (!Number.isInteger(r12) || !Number.isInteger(t6)) && Math.abs(r12 - t6) < C$8 || (this.scrollContainer[e3] = t6);
    }, this.scrollToIndex = (t6) => {
      this.animationInProgress = false, this.rowHeightService && this.scrollTo(this.rowHeightService.offset(t6));
    }, this.animateToIndex = (t6) => {
      if (!this.rowHeightService || !window)
        return;
      window.cancelAnimationFrame(this.cancelAnimation);
      const e3 = this.rowHeightService.offset(t6), r12 = this.getContainerScrollDirection(e3);
      let { start: n10, end: l7 } = this.scrollRange(e3, r12);
      if (n10 === l7)
        return;
      const f4 = this.scrollStep(n10, l7), c6 = x$5[r12](f4), h3 = I$4[r12](l7), d8 = M$4[r12](c6(l7)), m3 = (g6) => {
        this.animationInProgress = true;
        const S2 = c6(g6);
        this.scrollTo(h3(S2)), d8(S2) ? this.cancelAnimation = window.requestAnimationFrame(() => {
          m3(S2);
        }) : this.animationInProgress = false;
      };
      this.cancelAnimation = window.requestAnimationFrame(() => {
        m3(n10);
      });
    }, this.scrollToBottom = () => {
      this.rowHeightService && this.scrollTo(this.rowHeightService.totalHeight() + this.props.bottomOffset);
    }, this.scrollStep = (t6, e3) => {
      const r12 = this.props.scrollDuration || a7.defaultProps.scrollDuration;
      return Math.abs(e3 - t6) / (r12 / A$3);
    }, this.scrollRange = (t6, e3) => {
      const r12 = this.containerScrollPosition;
      if (parseInt(`${t6}`, 10) === parseInt(`${r12}`, 10))
        return { start: t6, end: t6 };
      const n10 = this.containerMaxScroll(), l7 = e3 === 0 ? 1 : -1, f4 = T$3(r12, t6, this.props.maxScrollDifference || 0), c6 = Math.min(t6, n10);
      return { start: Math.min(Math.max(c6 + l7 * f4, 0), n10), end: c6 };
    }, this.containerMaxScroll = () => this.containerScrollSize - this.containerOffsetSize, this.getContainerScrollDirection = (t6) => t6 < this.containerScrollPosition ? 0 : 1, this.initServices = (t6 = this.props) => {
      const e3 = this.direction === "vertical" ? t6.itemHeight : t6.itemWidth;
      e3 !== void 0 && (this.rowHeightService = new g$h(t6.total, e3, 0), this.scrollerService.create(
        this.rowHeightService,
        t6.skip,
        t6.take,
        t6.total,
        t6.topOffset,
        this.scrollOffsetSize,
        this.direction
      ));
    }, this.getContainerProperty = (t6) => this.scrollContainer ? this.scrollContainer[t6] : 0, this.handleScroll = (t6) => {
      if (!this.scrollContainer || !this.rowHeightService)
        return;
      const e3 = t6.target;
      this.scrollerService.onScroll({
        scrollLeft: e3.scrollLeft,
        scrollTop: e3.scrollTop,
        offsetHeight: e3.offsetHeight,
        offsetWidth: e3.offsetWidth
      });
      const r12 = this.rowHeightService.index(this.containerScrollPosition - this.props.topOffset), { onScrollAction: n10 } = this.props, l7 = {
        index: r12,
        target: e3,
        scrollAction: this.scrollAction,
        pageAction: this.pageAction,
        animationInProgress: this.animationInProgress
      };
      this.props.onScroll && this.props.onScroll.call(void 0, t6), n10 && n10.call(void 0, l7), this.scrollAction = void 0, this.pageAction = void 0;
    }, this.handleScrollAction = (t6) => {
      this.scrollAction = t6;
    }, this.handlePageAction = (t6) => {
      this.pageAction = t6;
    }, this.scrollerService = new w$7(
      this.handleScrollAction,
      this.handlePageAction
    ), this.restrictScroll = Number.parseFloat(reactExports.version) > 17;
  }
  get element() {
    return this.scrollContainer;
  }
  get containerOffsetSize() {
    return this.getContainerProperty(this.direction === "vertical" ? "offsetHeight" : "offsetWidth");
  }
  get containerScrollSize() {
    return this.getContainerProperty(this.direction === "vertical" ? "scrollHeight" : "scrollWidth");
  }
  get containerScrollPosition() {
    return this.getContainerProperty(this.direction === "vertical" ? "scrollTop" : "scrollLeft");
  }
  get direction() {
    return this.props.direction !== void 0 ? this.props.direction : a7.defaultProps.direction;
  }
  get scrollOffsetSize() {
    return this.props.scrollOffsetSize !== void 0 ? this.props.scrollOffsetSize : a7.defaultProps.scrollOffsetSize;
  }
  activeIndex() {
    return this.itemIndex(Math.ceil(this.containerScrollPosition));
  }
  itemIndex(i16) {
    return this.rowHeightService ? this.rowHeightService.index(i16) : 0;
  }
  itemOffset(i16) {
    return this.rowHeightService ? this.rowHeightService.offset(i16) : 0;
  }
  isIndexVisible(i16) {
    if (!this.rowHeightService)
      return false;
    const t6 = this.containerScrollPosition, e3 = t6 + this.containerOffsetSize, r12 = this.rowHeightService.offset(i16), n10 = r12 + this.rowHeightService.height(i16);
    return r12 >= t6 && n10 <= e3;
  }
  isListScrolled(i16) {
    return this.rowHeightService ? this.containerScrollPosition !== this.rowHeightService.offset(i16) : false;
  }
  componentDidMount() {
    const { onMount: i16 } = this.props;
    i16 && i16.call(void 0, this);
  }
  render() {
    const { total: i16, take: t6, bottomOffset: e3, className: r12, tabIndex: n10, role: l7, children: f4, unstyled: c6 } = this.props, h3 = c6 && c6.uCalendar;
    (this.lastTotal !== i16 || this.lastDirection !== this.direction || this.lastTake !== t6) && (this.initServices(), this.lastTotal = i16, this.lastDirection = this.direction, this.lastTake = t6);
    const d8 = `${(this.rowHeightService ? this.rowHeightService.totalHeight() : 0) + e3}`, m3 = this.direction === "vertical" ? { height: `${d8}px` } : { width: `${d8}px` }, g6 = r$r(
      j$3.scrollableSelector({
        c: h3
      }),
      j$3.scrollable({
        c: h3,
        horizontal: this.direction === "horizontal"
      }),
      r12
    ), S2 = r$r(
      j$3.scrollablePlaceholder({
        c: h3,
        horizontal: this.direction === "horizontal"
      })
    );
    return /* @__PURE__ */ reactExports.createElement(
      "div",
      {
        ref: (H3) => {
          this.scrollContainer = H3;
        },
        onScroll: this.handleScroll,
        className: g6,
        tabIndex: n10,
        role: l7
      },
      f4,
      /* @__PURE__ */ reactExports.createElement(
        "div",
        {
          style: m3,
          className: S2
        }
      )
    );
  }
};
a$6.propTypes = {
  bottomOffset: o$r.number.isRequired,
  className: o$r.string,
  direction: o$r.oneOf(["horizontal", "vertical"]),
  forceScroll: o$r.bool,
  itemHeight: o$r.number,
  itemWidth: o$r.number,
  maxScrollDifference: o$r.number,
  onScroll: o$r.func,
  onScrollAction: o$r.func,
  scrollDuration: o$r.number,
  scrollOffsetSize: o$r.number,
  skip: o$r.number.isRequired,
  tabIndex: o$r.number,
  take: o$r.number.isRequired,
  topOffset: o$r.number.isRequired,
  total: o$r.number.isRequired,
  role: o$r.string
}, a$6.defaultProps = {
  direction: "vertical",
  forceScroll: false,
  scrollOffsetSize: 0,
  maxScrollDifference: 100,
  scrollDuration: 100
};
let w$6 = a$6;
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const y$5 = (l7, e3) => {
  const t6 = Object.getOwnPropertyNames(l7), a9 = Object.getOwnPropertyNames(e3);
  if (t6.length !== a9.length)
    return false;
  for (let n10 = 0; n10 < t6.length; n10++) {
    const o9 = t6[n10];
    if (l7[o9] !== e3[o9])
      return false;
  }
  return true;
};
let L$3 = class L extends reactExports.Component {
  constructor() {
    super(...arguments), this.handleClick = (e3) => {
      const { onClick: t6, value: a9 } = this.props;
      t6 && t6.call(void 0, a9, e3);
    }, this.handleMouseEnter = () => {
      const { onMouseEnter: e3, value: t6 } = this.props;
      e3 && e3.call(void 0, t6);
    }, this.handleMouseLeave = () => {
      const { onMouseLeave: e3, value: t6 } = this.props;
      e3 && e3.call(void 0, t6);
    };
  }
  // Manually checking if the component needs an update
  // due to date object being compared by instance
  // and new Date object is created
  // every time and fails the shallow compare of the React.PureComponent.
  /**
   * @hidden
   */
  shouldComponentUpdate(e3) {
    const { value: t6, ...a9 } = this.props, { value: n10, ...o9 } = e3;
    return !((!(t6 && n10) || t6.getTime() === n10.getTime()) && y$5(a9, o9));
  }
  /* eslint-disable max-len */
  render() {
    const {
      className: e3,
      formattedValue: t6,
      isWeekend: a9,
      isFocused: n10,
      isInRange: o9,
      isSelected: d8,
      isRangeStart: i16,
      isRangeMid: f4,
      isRangeEnd: c6,
      isRangeSplitStart: C2,
      isRangeSplitEnd: M3,
      isToday: R2,
      isDisabled: S2,
      view: O2,
      value: P2,
      isOtherMonth: s10,
      showOtherMonthDays: p6,
      allowReverse: u5,
      unstyled: h3,
      ...N3
    } = this.props, w3 = this.props.activeRangeEnd === "end" && c6, k3 = this.props.activeRangeEnd === "start" && i16, m3 = h3 && h3.uCalendar, g6 = r$r(
      j$3.td({
        c: m3,
        rangeStart: !s10 && !u5 && i16,
        rangeEnd: !s10 && !u5 && c6,
        rangeMid: !s10 && f4,
        rangeSplitEnd: !s10 && M3,
        rangeSplitStart: !s10 && C2,
        active: k3 || w3,
        focused: n10,
        selected: !s10 && (d8 || i16 || c6),
        today: !s10 && R2,
        weekend: a9,
        disabled: S2,
        isOtherMonth: s10,
        isEmpty: !p6 && s10
      }),
      e3
    );
    return !p6 && s10 ? /* @__PURE__ */ reactExports.createElement("td", { role: "gridcell", className: g6 }) : /* @__PURE__ */ reactExports.createElement(
      "td",
      {
        ...N3,
        className: g6,
        onClick: this.handleClick,
        onMouseEnter: this.handleMouseEnter,
        onMouseLeave: this.handleMouseLeave
      },
      /* @__PURE__ */ reactExports.createElement("span", { className: r$r(j$3.link({ c: m3 })) }, this.props.children)
    );
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const f$2 = (e3) => {
  const { className: l7, firstDate: c6, weekDays: n10, ...o9 } = e3, r12 = (t6) => {
    const { onClick: a9 } = e3;
    a9 && t6 && a9.call(void 0, c6, n10 || [], t6);
  }, s10 = n$t(), i16 = s10 && s10.uCalendar;
  return /* @__PURE__ */ reactExports.createElement("td", { className: r$r(j$3.td({ c: i16, isWeek: true }), l7), ...o9, onClick: r12 }, e3.children);
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
var c$5 = /* @__PURE__ */ ((t6) => (t6[t6.month = 0] = "month", t6[t6.year = 1] = "year", t6[t6.decade = 2] = "decade", t6[t6.century = 3] = "century", t6))(c$5 || {});
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const l$5 = { start: null, end: null };
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const d$7 = (e3, n10, t6) => n10 === void 0 || t6 === void 0 || n10 <= e3 && e3 <= t6 ? e3 : e3 < n10 ? n10 : t6, k$5 = new Date(1980, 0, 1), H$1 = new Date(1900, 0, 1), L$2 = new Date(2099, 11, 31), q$2 = new Date(1980, 0, 1), G$5 = new Date(1980, 0, 1, 23, 59, 59), O$3 = (e3, n10) => {
  const t6 = cloneDate(e3);
  return t6.setHours(n10.getHours(), n10.getMinutes(), n10.getSeconds(), n10.getMilliseconds()), t6;
}, X = () => getDate(/* @__PURE__ */ new Date()), j = (e3, n10, t6) => !e3 || !(n10 && n10 > e3 || t6 && t6 < e3), P$5 = (e3, n10, t6) => e3 === null || !(n10 && getDate(n10) > getDate(e3) || t6 && getDate(t6) < getDate(e3)), Y$1 = (e3, n10) => {
  const { start: t6, end: r12 } = n10 || l$5;
  return !t6 || !r12 ? false : t6 < e3 && e3 < r12;
}, z$3 = (e3, n10, t6 = 1) => {
  const r12 = [];
  for (let o9 = e3; o9 < n10; o9 = o9 + t6)
    r12.push(o9);
  return r12;
}, B$2 = (e3, n10, t6) => n10.getTime() <= e3.getTime() && e3.getTime() <= t6.getTime(), J = (e3, n10) => e3.slice(n10).concat(e3.slice(0, n10)), K$2 = (e3, n10, t6) => e3 && (n10 && e3 < n10 ? cloneDate(n10) : t6 && e3 > t6 ? cloneDate(t6) : e3), Q$1 = (e3) => (n10, t6 = "", r12 = {}) => {
  const o9 = document.createElement(e3);
  return o9.className = t6, Object.keys(r12).map((s10) => o9.style[s10] = r12[s10]), typeof n10 == "string" ? o9.innerHTML = n10 || "" : (n10 || []).forEach((s10) => s10 && o9.appendChild(s10)), o9;
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let r$1 = class r10 {
  constructor(e3) {
    this.intl = e3;
  }
  getWeekNames(e3 = false, t6) {
    const s10 = J(
      this.intl.dateFormatNames({ nameType: t6 != null ? t6 : "short", type: "days" }),
      this.intl.firstDay()
    );
    return e3 ? [""].concat(s10) : s10;
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const y$4 = (g6, t6) => {
  const e3 = t6;
  return /* @__PURE__ */ reactExports.createElement("td", { key: g6, role: "gridcell", className: r$r(j$3.td({ c: e3, isEmpty: true })) }, "");
}, u$6 = class u2 extends reactExports.Component {
  constructor() {
    super(...arguments), this.intl = null, this.weekService = null, this.buildWeekNumber = (t6, e3) => {
      if (!this.firstDate(t6))
        return y$4(`week-cell-${e3}`);
      const a9 = this.firstDate(t6), n10 = this.getWeekNumber(a9), o9 = `kendo-react-calendar-week-cell-${n10}`, m3 = {
        value: n10,
        firstDate: a9,
        weekDays: t6,
        unstyled: this.props.unstyled,
        onClick: this.handleWeekCellClick
      };
      return this.props.weekCell ? /* @__PURE__ */ reactExports.createElement(this.props.weekCell, { ...m3, key: o9 }, n10) : /* @__PURE__ */ reactExports.createElement(f$2, { ...m3, key: o9 }, n10);
    }, this.buildRow = (t6) => t6.map((e3, r12) => {
      if (!e3)
        return y$4(r12);
      const a9 = { "aria-selected": e3.isSelected }, n10 = `kendo-react-calendar-cell-${e3.value.getTime()}`, o9 = {
        ...a9,
        ...e3,
        isDisabled: !e3.isInRange,
        view: this.props.activeView,
        showOtherMonthDays: this.props.showOtherMonthDays,
        allowReverse: this.props.allowReverse,
        unstyled: this.props.unstyled,
        onClick: this.handleClick,
        onMouseEnter: this.handleMouseEnter,
        onMouseLeave: this.handleMouseLeave
      };
      return this.props.cell ? /* @__PURE__ */ reactExports.createElement(this.props.cell, { ...o9, key: n10 }, e3.formattedValue) : /* @__PURE__ */ reactExports.createElement(L$3, { ...o9, key: n10 }, e3.formattedValue);
    }), this.firstDate = (t6) => {
      const e3 = this.firstWeekDateContext(t6);
      return e3 ? e3.value : null;
    }, this.firstWeekDateContext = (t6) => {
      if (!this.weekNumber)
        return null;
      let e3 = 0, r12 = t6[e3];
      for (; !r12 && e3 < t6.length; )
        r12 = t6[++e3];
      return r12;
    }, this.handleClick = (t6, e3) => {
      const { onChange: r12 } = this.props;
      if (r12 && e3) {
        const a9 = {
          value: cloneDate(t6),
          target: this,
          nativeEvent: e3 && e3.nativeEvent,
          syntheticEvent: e3
        };
        r12.call(void 0, a9);
      }
    }, this.handleWeekCellClick = (t6, e3, r12) => {
      const { onWeekSelect: a9 } = this.props, n10 = e3.findIndex((o9) => o9 && o9.value === t6);
      a9 && r12 && a9.call(void 0, t6, n10, r12);
    }, this.handleMouseEnter = (t6) => {
      const { onCellEnter: e3 } = this.props;
      e3 && e3.call(void 0, cloneDate(t6));
    }, this.handleMouseLeave = (t6) => {
      const { onCellLeave: e3 } = this.props;
      e3 && e3.call(void 0, cloneDate(t6));
    };
  }
  get min() {
    return this.props.min;
  }
  get max() {
    return this.props.max;
  }
  get isHorizontal() {
    return this.props.direction === "horizontal";
  }
  get isMonthView() {
    return this.props.activeView === c$5.month;
  }
  get weekNumber() {
    return !!(this.props.showWeekNumbers && this.props.activeView === c$5.month);
  }
  get selectedDate() {
    return this.props.selectedDate !== void 0 ? this.props.selectedDate : u2.defaultProps.selectedDate;
  }
  render() {
    const { service: t6, weekDaysFormat: e3, cellUID: r12, focusedDate: a9, bus: n10, activeView: o9, selectionRange: m3, unstyled: w3 } = this.props, h3 = w3 && w3.uCalendar;
    this.intl = a$s(this), this.weekService = new r$1(this.intl);
    const C2 = this.weekService.getWeekNames(this.weekNumber, e3), N3 = t6.rowLength(this.weekNumber), b2 = t6.title(this.props.viewDate), E2 = X(), W3 = O$3(this.props.viewDate, E2), O2 = t6.data({
      cellUID: r12,
      min: this.min,
      max: this.max,
      focusedDate: a9,
      isActiveView: !n10.canMoveDown(o9),
      selectedDate: this.selectedDate,
      selectionRange: m3,
      viewDate: W3
    });
    return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, this.isMonthView && this.isHorizontal && /* @__PURE__ */ reactExports.createElement(
      "thead",
      {
        role: "rowgroup",
        className: r$r(j$3.thead({ c: h3 }))
      },
      /* @__PURE__ */ reactExports.createElement("tr", { role: "row", className: r$r(j$3.tr({ c: h3 })) }, C2.map((p6, d8) => /* @__PURE__ */ reactExports.createElement("th", { key: d8, className: r$r(j$3.th({ c: h3 })) }, p6)))
    ), /* @__PURE__ */ reactExports.createElement(
      "tbody",
      {
        role: "rowgroup",
        className: r$r(j$3.tbody({ c: h3 }))
      },
      !this.isHorizontal && /* @__PURE__ */ reactExports.createElement("tr", { role: "presentation", className: r$r(j$3.tr({ c: h3 })) }, /* @__PURE__ */ reactExports.createElement(
        "th",
        {
          scope: "col",
          colSpan: N3,
          className: r$r(j$3.caption({ c: h3 }))
        },
        b2
      )),
      O2.map((p6, d8) => /* @__PURE__ */ reactExports.createElement("tr", { role: "row", className: r$r(j$3.tr({ c: h3 })), key: d8 }, this.weekNumber && this.buildWeekNumber(p6, d8), this.buildRow(p6)))
    ));
  }
  getWeekNumber(t6) {
    return !this.weekNumber || !this.intl ? null : weekInYear(t6, this.intl.firstDay());
  }
};
u$6.propTypes = {
  activeRangeEnd: o$r.oneOf(["start", "end", null]),
  activeView: o$r.number.isRequired,
  cellUID: o$r.string.isRequired,
  direction: o$r.oneOf(["horizontal", "vertical"]),
  focusedDate: o$r.instanceOf(Date).isRequired,
  max: o$r.instanceOf(Date).isRequired,
  min: o$r.instanceOf(Date).isRequired,
  onChange: o$r.func,
  selectedDate: o$r.oneOfType(
    [o$r.instanceOf(Date), o$r.arrayOf(o$r.instanceOf(Date))]
  ),
  showWeekNumbers: o$r.bool,
  showOtherMonthDays: o$r.bool,
  viewDate: o$r.instanceOf(Date).isRequired
}, u$6.defaultProps = {
  direction: "vertical",
  selectedDate: X(),
  showWeekNumbers: false
};
let f$1 = u$6;
p$t(f$1);
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const a$5 = (e3) => {
  const { view: l7, ...t6 } = e3;
  return /* @__PURE__ */ reactExports.createElement(p$j, { type: "button", fillMode: "flat", themeColor: "primary", ...t6 }, e3.children);
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const t$7 = class t extends reactExports.Component {
  constructor() {
    super(...arguments), this.getTitle = () => {
      if (!this.props.currentDate)
        return "";
      const s10 = this.rangeLength - 1, a9 = this.props.service.title(this.props.currentDate), r12 = this.props.service.addToDate(this.props.currentDate, s10);
      return s10 < 1 || !this.props.service.isInRange(r12, this.min, this.max) ? a9 : `${a9} - ${this.props.service.title(r12)}`;
    }, this.handleTitleClick = (s10) => {
      this.canMoveUp && this.props.bus.moveUp(this.props.activeView, s10);
    };
  }
  get min() {
    return this.props.min !== void 0 ? this.props.min : t.defaultProps.min;
  }
  get max() {
    return this.props.max !== void 0 ? this.props.max : t.defaultProps.max;
  }
  get rangeLength() {
    return this.props.rangeLength !== void 0 ? this.props.rangeLength : t.defaultProps.rangeLength;
  }
  get canMoveUp() {
    return this.props.bus.canMoveUp(this.props.activeView);
  }
  render() {
    const { activeView: s10, commands: a9, unstyled: r12 } = this.props, n10 = r12 && r12.uCalendar, p6 = this.getTitle(), m3 = r$r(j$3.title({ c: n10 })), h3 = {
      children: p6,
      value: p6,
      view: s10,
      className: m3,
      onClick: this.handleTitleClick,
      disabled: !this.canMoveUp
    }, d8 = {
      headerTitleProps: h3,
      commands: a9
    }, u5 = this.props.headerTitle ? /* @__PURE__ */ reactExports.createElement(this.props.headerTitle, { ...h3 }, p6) : /* @__PURE__ */ reactExports.createElement(a$5, { ...h3 }, p6), g6 = this.props.header ? /* @__PURE__ */ reactExports.createElement(this.props.header, { ...d8 }) : /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, u5, /* @__PURE__ */ reactExports.createElement("span", { className: r$r(j$3.spacer({ c: n10 })) }), /* @__PURE__ */ reactExports.createElement("span", { className: r$r(j$3.nav({ c: n10 })) }, this.props.commands));
    return /* @__PURE__ */ reactExports.createElement("div", { className: r$r(j$3.header({ c: n10, vertical: this.props.verticalView })) }, g6);
  }
};
t$7.propTypes = {
  activeView: o$r.number.isRequired,
  currentDate: o$r.instanceOf(Date).isRequired,
  max: o$r.instanceOf(Date).isRequired,
  min: o$r.instanceOf(Date).isRequired,
  rangeLength: o$r.number
}, t$7.defaultProps = {
  rangeLength: 1,
  min: H$1,
  max: L$2
};
let l$4 = t$7;
v$a(l$4);
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const e$4 = "multiviewcalendar.prevView", t$6 = "multiviewcalendar.nextView", a$4 = "dateinput.increment", c$4 = "dateinput.decrement", n$6 = "dateinput.clear", i$6 = "calendar.today", r11 = "datepicker.toggleCalendar", o$5 = "daterangepicker.swapStartEnd", l$3 = "daterangepicker.start", s$3 = "daterangepicker.end", d$6 = "daterangepicker.separator", g$6 = "datetimepicker.toggleDateTimeSelector", p$9 = "timepicker.now", m$4 = "timepicker.selectNow", k$4 = "timepicker.cancel", w$5 = "timepicker.set", S$6 = "timepicker.toggleTimeSelector", T$2 = "timepicker.toggleClock", u$5 = "datetimepicker.date", v$3 = "datetimepicker.time", C$7 = "datetimepicker.cancel", N$5 = "datetimepicker.set", P$4 = "daterangepicker.cancel", V$2 = "daterangepicker.set", x$4 = {
  [i$6]: "Today",
  [p$9]: "NOW",
  [w$5]: "Set",
  [k$4]: "Cancel",
  [u$5]: "Date",
  [v$3]: "Time",
  [C$7]: "Cancel",
  [N$5]: "Set",
  [P$4]: "Cancel",
  [V$2]: "Set",
  [l$3]: "Start",
  [s$3]: "End",
  [d$6]: " ",
  [m$4]: "Select Now",
  [S$6]: "Toggle TimeSelector",
  [T$2]: "Toggle Clock",
  [a$4]: "Increase value",
  [c$4]: "Decrease value",
  [n$6]: "clear",
  [r11]: "Toggle calendar",
  [e$4]: "Navigate to previous view",
  [t$6]: "Navigate to next view",
  [o$5]: "Swap start and end values",
  [g$6]: "Toggle date-time selector"
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const t$5 = class t2 extends reactExports.Component {
  constructor() {
    super(...arguments), this.localization = null, this.handleClick = (i16) => {
      if (this.todayIsInRange && this.props.onClick) {
        const s10 = {
          syntheticEvent: i16,
          nativeEvent: i16.nativeEvent,
          value: K$2(X(), this.min, this.max),
          target: this,
          isTodayClick: true
        };
        this.props.onClick.call(void 0, s10);
      }
    };
  }
  get min() {
    return this.props.min !== void 0 ? this.props.min : t2.defaultProps.min;
  }
  get max() {
    return this.props.max !== void 0 ? this.props.max : t2.defaultProps.max;
  }
  get todayIsInRange() {
    return j(X(), getDate(this.min), getDate(this.max));
  }
  render() {
    const { disabled: i16, tabIndex: s10, unstyled: o9 } = this.props, p6 = o9 && o9.uCalendar;
    this.localization = s$k(this);
    const c6 = this.localization.toLanguageString(i$6, x$4[i$6]), d8 = r$r(j$3.today({ c: p6, disabled: i16 }));
    return /* @__PURE__ */ reactExports.createElement(
      p$j,
      {
        className: d8,
        onClick: this.handleClick,
        tabIndex: s10,
        fillMode: "flat",
        themeColor: "base",
        role: "link"
      },
      c6
    );
  }
};
t$5.propTypes = {
  max: o$r.instanceOf(Date).isRequired,
  min: o$r.instanceOf(Date).isRequired,
  onClick: o$r.func,
  disabled: o$r.bool
}, t$5.defaultProps = {
  min: H$1,
  max: L$2
};
let a$3 = t$5;
v$a(a$3);
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const M$3 = 5, d$5 = class d5 extends reactExports.Component {
  constructor(n10) {
    super(n10), this.virtualization = null, this.calendarView = null, this.table = null, this.intl = null, this.bottomOffset = 0, this.viewOffset = 0, this.viewHeight = 0, this._element = null, this.isActive = false, this.animateToIndex = true, this.shouldScroll = false, this.weekService = null, this.focusActiveDate = () => {
      if (!this._element)
        return;
      const e3 = this._element.querySelector("td.k-focus"), i16 = this._element.querySelector(".k-state-pending-focus");
      e3 && e3[0] && e3[0].classList.remove("k-focus"), i16 && i16.classList.add("k-focus"), this.isActive = true;
    }, this.blurActiveDate = () => {
      if (!this._element)
        return;
      const e3 = this._element.querySelector("td.k-focus");
      e3 && e3.classList.remove("k-focus"), this.isActive = false;
    }, this.handleVirtualizationMount = (e3) => {
      if (this.virtualization = e3, this.virtualization && this.table) {
        this.table.style.transform = `translateY(${this.viewOffset}px)`;
        const i16 = K$2(this.props.focusedDate, this.props.min, this.props.max), t6 = this.props.service.skip(i16, this.props.min);
        this.virtualization.scrollToIndex(t6);
      }
    }, this.buildMonthView = (e3, i16) => {
      const { unstyled: t6 } = this.props, s10 = t6 && t6.uCalendar;
      return /* @__PURE__ */ reactExports.createElement(
        "table",
        {
          key: "calendar-view-list-weekdays",
          className: r$r(j$3.table({ c: s10, weekdays: true })),
          role: "grid",
          tabIndex: this.props.tabIndex
        },
        /* @__PURE__ */ reactExports.createElement("colgroup", null, e3.map((l7, r12) => /* @__PURE__ */ reactExports.createElement("col", { key: r12 }))),
        /* @__PURE__ */ reactExports.createElement("thead", { className: r$r(j$3.thead({ c: s10 })) }, /* @__PURE__ */ reactExports.createElement("tr", { className: r$r(j$3.tr({ c: s10 })) }, i16.map((l7, r12) => /* @__PURE__ */ reactExports.createElement("th", { key: r12, className: r$r(j$3.th({ c: s10 })) }, l7))))
      );
    }, this.buildDates = (e3, i16) => {
      const t6 = this.props.cellUID, { unstyled: s10 } = this.props, l7 = s10 && s10.uCalendar;
      return /* @__PURE__ */ reactExports.createElement(
        "table",
        {
          className: r$r(j$3.table({ c: l7 })),
          ref: (r12) => this.table = r12,
          role: "grid",
          tabIndex: this.props.tabIndex,
          "aria-activedescendant": t6 + this.props.focusedDate.getTime()
        },
        /* @__PURE__ */ reactExports.createElement("colgroup", null, e3.map((r12, h3) => /* @__PURE__ */ reactExports.createElement("col", { key: h3 }))),
        i16.map((r12) => /* @__PURE__ */ reactExports.createElement(
          f$1,
          {
            ref: (h3) => {
              this.calendarView || (this.calendarView = h3);
            },
            key: r12.getTime(),
            activeView: this.props.activeView,
            viewDate: r12,
            min: this.props.min,
            max: this.props.max,
            cellUID: t6,
            focusedDate: this.props.focusedDate,
            cell: this.props.cell,
            selectedDate: this.props.value,
            showWeekNumbers: this.weekNumber,
            onChange: this.handleDateChange,
            bus: this.props.bus,
            service: this.props.service,
            weekCell: this.props.weekCell,
            showOtherMonthDays: this.props.showOtherMonthDays,
            unstyled: s10
          }
        ))
      );
    }, this.calculateHeights = () => {
      if (!this.props.dom)
        return;
      const e3 = this.props.activeView === c$5.month ? this.props.dom.scrollableContentHeight : this.props.dom.scrollableYearContentHeight;
      this.bottomOffset = e3 - this.props.dom.viewHeight(this.props.activeView), this.viewOffset = -1 * this.props.dom.headerHeight, this.viewHeight = this.props.dom.viewHeight(this.props.activeView) || 1;
    }, this.getTake = (e3, i16) => Math.min(i16 - e3, this.take), this.handleScrollAction = ({ index: e3, scrollAction: i16, pageAction: t6 }) => {
      const s10 = t6 ? t6.skip : this.state.skip;
      if ((this.state.index !== e3 || this.state.skip !== s10) && this.setState({ index: e3, skip: s10 }), this.table && i16) {
        const l7 = `translateY(${i16.offset}px)`;
        this.table.style.transform = l7;
      }
    }, this.handleTodayClick = (e3) => {
      this.shouldScroll = true, this.handleDateChange.call(void 0, e3, true);
    }, this.handleDateChange = (e3, i16 = false) => {
      const { onChange: t6 } = this.props;
      if (t6) {
        const s10 = {
          syntheticEvent: e3.syntheticEvent,
          nativeEvent: e3.nativeEvent,
          value: cloneDate(e3.value),
          target: this,
          isTodayClick: i16
        };
        t6.call(void 0, s10);
      }
    }, this.lastView = this.props.activeView, this.lastFocus = this.props.focusedDate, this.state = {
      skip: this.props.service.skip(this.props.focusedDate, this.props.min),
      index: this.props.service.skip(this.props.focusedDate, this.props.min)
    };
  }
  get element() {
    return this._element;
  }
  get weekNames() {
    return this.intl = a$s(this), this.weekService = new r$1(this.intl), this.weekService.getWeekNames(this.weekNumber, this.props.weekDaysFormat);
  }
  get weekNumber() {
    return !!(this.props.showWeekNumbers && this.props.activeView === c$5.month);
  }
  get take() {
    return this.props.take !== void 0 ? this.props.take : d5.defaultProps.take;
  }
  get animate() {
    return !!(this.props.smoothScroll && this.animateToIndex);
  }
  get todayIsInRange() {
    return j(X(), getDate(this.props.min), getDate(this.props.max));
  }
  componentDidUpdate(n10, e3) {
    this.shouldScroll = false, this.indexToScroll !== void 0 && this.virtualization && this.virtualization[this.animate ? "animateToIndex" : "scrollToIndex"](this.indexToScroll), this.isActive && this.focusActiveDate(), this.lastView = this.props.activeView, this.indexToScroll = void 0;
  }
  render() {
    const { activeView: n10, min: e3, max: i16, service: t6, unstyled: s10 } = this.props, l7 = s10 && s10.uCalendar;
    this.calculateHeights();
    const r12 = this.lastView !== n10, h3 = K$2(this.props.focusedDate, e3, i16), u5 = r12 ? t6.skip(h3, e3) : this.state.skip, w3 = t6.total(e3, i16), x3 = this.getTake(u5, w3), y4 = t6.addToDate(e3, u5), S2 = t6.addToDate(e3, this.state.index), k3 = new Array(t6.rowLength(this.weekNumber)).fill(""), b2 = n10 !== this.lastView;
    this.animateToIndex = !b2, (b2 || !isEqualDate(this.lastFocus, h3) || this.shouldScroll || !this.props.shouldScroll || this.props.shouldScroll()) && (this.indexToScroll = this.props.service.skip(h3, this.props.min)), this.lastFocus = h3;
    const C2 = r$r(
      j$3.view({
        c: l7,
        month: n10 === c$5.month,
        year: n10 === c$5.year,
        decade: n10 === c$5.decade,
        century: n10 === c$5.century
      })
    ), I3 = this.buildDates(k3, t6.datesList(y4, x3)), V3 = /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(
      l$4,
      {
        key: "calendar-view-list-header",
        currentDate: S2,
        min: this.props.min,
        max: this.props.max,
        activeView: this.props.activeView,
        bus: this.props.bus,
        service: this.props.service,
        headerTitle: this.props.headerTitle,
        header: this.props.header,
        unstyled: s10,
        commands: /* @__PURE__ */ reactExports.createElement(
          a$3,
          {
            min: this.props.min,
            max: this.props.max,
            onClick: this.handleTodayClick,
            disabled: !this.todayIsInRange,
            tabIndex: this.props.tabIndex,
            unstyled: s10
          }
        )
      }
    ), this.props.activeView === c$5.month && this.buildMonthView(k3, this.weekNames), /* @__PURE__ */ reactExports.createElement(
      w$6,
      {
        key: "calendar-view-list-content",
        skip: u5,
        take: this.take,
        total: w3,
        itemHeight: this.viewHeight,
        topOffset: this.viewOffset,
        bottomOffset: this.bottomOffset,
        scrollOffsetSize: this.viewOffset,
        maxScrollDifference: this.viewHeight,
        onScroll: this.props.onScroll,
        onScrollAction: this.handleScrollAction,
        onMount: (f4) => !this.virtualization && this.handleVirtualizationMount(f4),
        children: I3,
        tabIndex: this.props.tabIndex,
        unstyled: s10
      }
    ));
    return /* @__PURE__ */ reactExports.createElement(
      "div",
      {
        ref: (f4) => {
          this._element = f4;
        },
        className: C2
      },
      this.props.dom.didCalculate ? V3 : null
    );
  }
};
d$5.propTypes = {
  activeView: o$r.number.isRequired,
  bottomOffset: o$r.number,
  cellUID: o$r.string.isRequired,
  focusedDate: o$r.instanceOf(Date).isRequired,
  max: o$r.instanceOf(Date).isRequired,
  min: o$r.instanceOf(Date).isRequired,
  onChange: o$r.func,
  showWeekNumbers: o$r.bool,
  smoothScroll: o$r.bool,
  take: o$r.number,
  value: o$r.instanceOf(Date),
  viewHeight: o$r.number,
  viewOffset: o$r.number,
  weekDaysFormat: o$r.oneOf(["short", "abbreviated", "narrow"]),
  tabIndex: o$r.number
}, d$5.defaultProps = {
  take: M$3,
  showWeekNumbers: false,
  weekDaysFormat: "short",
  smoothScroll: true
};
let v$2 = d$5;
p$t(v$2);
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const N$4 = (e3) => {
  const { isRangeStart: i16, value: o9, text: C2, view: v3, ...r12 } = e3, a9 = n$t(), t6 = a9 && a9.uCalendar, m3 = (d8) => {
    const { onClick: n10 } = e3;
    n10 && n10.call(void 0, o9, d8);
  };
  return /* @__PURE__ */ reactExports.createElement(
    "li",
    {
      ...r12,
      onClick: m3,
      className: r$r(j$3.li({ c: t6 }))
    },
    /* @__PURE__ */ reactExports.createElement("span", { className: r$r(
      j$3.navigationMarker({
        c: t6,
        isRangeStart: i16
      })
    ) }, e3.children)
  );
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const I$3 = 30, p$8 = class p3 extends reactExports.Component {
  constructor(o9) {
    super(o9), this.virtualization = null, this.list = null, this.itemHeight = 0, this.topOffset = 0, this.maxViewHeight = 0, this.bottomOffset = 0, this.handleVirtualizationMount = (t6) => {
      if (this.virtualization = t6, this.virtualization && this.list) {
        this.list.style.transform = `translateY(${this.topOffset}px)`;
        const i16 = K$2(this.props.focusedDate, this.props.min, this.props.max), s10 = this.props.service.skip(i16, this.props.min);
        this.virtualization.scrollToIndex(s10);
      }
    }, this.buildNavigationItem = (t6) => {
      const i16 = this.props.service.navigationTitle(t6), s10 = this.props.service.isRangeStart(t6), a9 = `kendo-react-calendar-nav-item-${t6.getTime()}`, h3 = {
        text: i16,
        value: t6,
        isRangeStart: s10,
        view: this.props.activeView,
        onClick: this.handleDateChange
      };
      return this.props.navigationItem ? /* @__PURE__ */ reactExports.createElement(this.props.navigationItem, { ...h3, key: a9 }, i16) : /* @__PURE__ */ reactExports.createElement(N$4, { ...h3, key: a9 }, i16);
    }, this.calculateHeights = () => {
      const t6 = this.props.dom.calendarHeight;
      this.itemHeight = this.props.dom.navigationItemHeight || 1, this.maxViewHeight = this.props.dom.monthViewHeight, this.topOffset = (t6 - this.itemHeight) / 2, this.bottomOffset = t6 - this.itemHeight;
    }, this.handleDateChange = (t6, i16) => {
      const { onChange: s10 } = this.props;
      if (s10 && i16) {
        const a9 = {
          value: cloneDate(t6),
          target: this,
          nativeEvent: i16 && i16.nativeEvent,
          syntheticEvent: i16
        };
        s10.call(void 0, a9);
      }
    }, this.handleScrollAction = ({ scrollAction: t6, pageAction: i16 }) => {
      const s10 = i16 ? i16.skip : this.state.skip;
      if (this.state.skip !== s10 && this.setState({ skip: s10 }), this.list && t6) {
        const a9 = `translateY(${t6.offset}px)`;
        this.list.style.transform = a9;
      }
    }, this.lastView = this.props.activeView, this.lastFocus = this.props.focusedDate;
    const e3 = this.props.service.skip(this.props.focusedDate, this.props.min), c6 = this.props.service.total(this.props.min, this.props.max);
    this.state = {
      skip: e3 - this.getTake(e3, c6) > 0 ? e3 : 0
    };
  }
  get take() {
    return this.props.take !== void 0 ? this.props.take : p3.defaultProps.take;
  }
  /**
   * @hidden
   */
  componentDidUpdate(o9, e3) {
    this.indexToScroll !== void 0 && this.virtualization && this.virtualization.scrollToIndex(this.indexToScroll), this.lastView = this.props.activeView, this.lastFocus = this.props.focusedDate, this.indexToScroll = void 0;
  }
  render() {
    const { activeView: o9, min: e3, max: c6, service: t6, unstyled: i16 } = this.props;
    this.calculateHeights();
    const s10 = i16 && i16.uCalendar, a9 = this.lastView !== o9, h3 = K$2(this.props.focusedDate, e3, c6), m3 = a9 ? t6.skip(h3, e3) : this.state.skip, f4 = t6.total(e3, c6), k3 = this.getTake(m3, f4), x3 = t6.addToDate(e3, m3), D2 = t6.datesList(x3, k3);
    (o9 !== this.lastView || !isEqual(h3, this.lastFocus)) && (this.indexToScroll = t6.skip(h3, e3));
    const w3 = /* @__PURE__ */ reactExports.createElement(
      w$6,
      {
        skip: m3,
        take: this.take,
        total: f4,
        itemHeight: this.itemHeight,
        topOffset: this.topOffset,
        bottomOffset: this.bottomOffset,
        onScroll: this.props.onScroll,
        maxScrollDifference: this.maxViewHeight,
        onScrollAction: this.handleScrollAction,
        onMount: (l7) => !this.virtualization && this.handleVirtualizationMount(l7),
        tabIndex: this.props.tabIndex,
        unstyled: i16
      },
      /* @__PURE__ */ reactExports.createElement("ul", { ref: (l7) => {
        this.list = l7;
      }, className: r$r(j$3.ul({ c: s10 })) }, D2.map((l7) => this.buildNavigationItem(l7)))
    );
    return /* @__PURE__ */ reactExports.createElement(
      "div",
      {
        className: r$r(j$3.navigation({ c: s10 }))
      },
      /* @__PURE__ */ reactExports.createElement("span", { className: r$r(j$3.navigationHighlight({ c: s10 })) }),
      this.props.dom.didCalculate ? w3 : null
    );
  }
  getTake(o9, e3) {
    return Math.min(e3 - o9, this.take);
  }
};
p$8.propTypes = {
  activeView: o$r.number.isRequired,
  focusedDate: o$r.instanceOf(Date).isRequired,
  max: o$r.instanceOf(Date).isRequired,
  min: o$r.instanceOf(Date).isRequired,
  onChange: o$r.func,
  take: o$r.number,
  tabIndex: o$r.number
}, p$8.defaultProps = {
  take: I$3
};
let g$5 = p$8;
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
var w$4 = /* @__PURE__ */ ((e3) => (e3[e3.Left = 0] = "Left", e3[e3.Right = 1] = "Right", e3[e3.Up = 2] = "Up", e3[e3.Down = 3] = "Down", e3[e3.PrevView = 4] = "PrevView", e3[e3.NextView = 5] = "NextView", e3[e3.FirstInView = 6] = "FirstInView", e3[e3.LastInView = 7] = "LastInView", e3[e3.LowerView = 8] = "LowerView", e3[e3.UpperView = 9] = "UpperView", e3))(w$4 || {});
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const $$4 = [[]], T$1 = 4, b$3 = 3, G$4 = {
  [w$4.Left]: (i16) => addDecades(i16, -1),
  [w$4.Up]: (i16) => addDecades(i16, -5),
  [w$4.Right]: (i16) => addDecades(i16, 1),
  [w$4.Down]: (i16) => addDecades(i16, 5),
  [w$4.PrevView]: (i16) => addCenturies(i16, -1),
  [w$4.NextView]: (i16) => addCenturies(i16, 1),
  [w$4.FirstInView]: (i16) => firstDecadeOfCentury(i16),
  [w$4.LastInView]: (i16) => lastDecadeOfCentury(i16)
};
let W$1 = class W {
  addToDate(e3, t6) {
    return addCenturies(e3, t6);
  }
  datesList(e3, t6) {
    return z$3(0, t6).map((r12) => addCenturies(e3, r12));
  }
  data(e3) {
    const {
      cellUID: t6,
      focusedDate: r12,
      isActiveView: u5,
      max: s10,
      min: a9,
      selectedDate: f4,
      selectionRange: h3 = l$5,
      viewDate: F2
    } = e3;
    if (!F2)
      return $$4;
    const q2 = z$3(0, T$1), S2 = firstDecadeOfCentury(F2), R2 = lastDecadeOfCentury(F2), A2 = X();
    return z$3(0, b$3).map((V3) => {
      const L3 = addDecades(S2, V3 * T$1);
      return q2.map((C2) => {
        const n10 = this.normalize(addDecades(L3, C2), a9, s10), y4 = this.isEqual(n10, h3.start), D2 = this.isEqual(n10, h3.end), Y2 = !y4 && !D2 && Y$1(n10, h3), v3 = u5 && (Array.isArray(f4) ? this.isSelectedFromArray(n10, f4, a9, s10) : j(f4, a9, s10) && this.isEqual(n10, f4));
        return B$2(n10, S2, R2) ? {
          formattedValue: this.value(n10),
          id: `${t6}${n10.getTime()}`,
          isFocused: this.isEqual(n10, r12),
          isSelected: v3,
          isWeekend: false,
          isInRange: j(n10, a9, s10),
          isRangeStart: y4,
          isRangeMid: Y2,
          isRangeEnd: D2,
          isRangeSplitEnd: Y2 && this.isEqual(n10, R2),
          isRangeSplitStart: Y2 && this.isEqual(n10, S2),
          isToday: this.isEqual(n10, A2),
          title: this.cellTitle(n10),
          value: n10
        } : null;
      });
    });
  }
  isSelectedFromArray(e3, t6, r12, u5) {
    let s10 = false;
    return t6.forEach((a9) => {
      j(e3, r12, u5) && this.isEqual(e3, a9) && (s10 = true);
    }), s10;
  }
  isEqual(e3, t6) {
    return !e3 || !t6 ? false : firstYearOfDecade(e3).getFullYear() === firstYearOfDecade(t6).getFullYear();
  }
  isInArray(e3, t6) {
    if (!t6.length)
      return false;
    const r12 = e3.getFullYear();
    return t6[0].getFullYear() <= r12 && r12 <= t6[t6.length - 1].getFullYear() + 99;
  }
  isInRange(e3, t6, r12) {
    const u5 = firstYearOfDecade(e3).getFullYear(), s10 = !t6 || firstYearOfDecade(t6).getFullYear() <= u5, a9 = !r12 || u5 <= firstYearOfDecade(r12).getFullYear();
    return s10 && a9;
  }
  isInSameView(e3, t6) {
    return durationInCenturies(e3, t6) === 0;
  }
  isRangeStart(e3) {
    return e3.getFullYear() % 1e3 === 0;
  }
  move(e3, t6) {
    const r12 = G$4[t6];
    return r12 ? r12(e3) : e3;
  }
  cellTitle(e3) {
    return firstYearOfDecade(e3).getFullYear().toString();
  }
  navigationTitle(e3) {
    return e3 ? firstDecadeOfCentury(e3).getFullYear().toString() : "";
  }
  title(e3) {
    return e3 ? `${firstDecadeOfCentury(e3).getFullYear()} - ${lastDecadeOfCentury(e3).getFullYear()}` : "";
  }
  rowLength(e3) {
    return T$1;
  }
  skip(e3, t6) {
    return durationInCenturies(t6, e3);
  }
  total(e3, t6) {
    return durationInCenturies(e3, t6) + 1;
  }
  value(e3) {
    return e3 ? firstYearOfDecade(e3).getFullYear().toString() : "";
  }
  viewDate(e3, t6, r12 = 1) {
    return durationInCenturies(e3, t6) < r12 ? addCenturies(e3, -1) : e3;
  }
  normalize(e3, t6, r12) {
    return e3 < t6 && this.isEqual(e3, t6) ? cloneDate(t6) : e3 > r12 && this.isEqual(e3, r12) ? cloneDate(r12) : e3;
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const $$3 = [[]], w$3 = 4, b$2 = 3, C$6 = {
  [w$4.Left]: (i16) => addYears(i16, -1),
  [w$4.Up]: (i16) => addYears(i16, -5),
  [w$4.Right]: (i16) => addYears(i16, 1),
  [w$4.Down]: (i16) => addYears(i16, 5),
  [w$4.PrevView]: (i16) => addDecades(i16, -1),
  [w$4.NextView]: (i16) => addDecades(i16, 1),
  [w$4.FirstInView]: (i16) => firstYearOfDecade(i16),
  [w$4.LastInView]: (i16) => lastYearOfDecade(i16)
};
let U$1 = class U {
  addToDate(e3, t6) {
    return addDecades(e3, t6);
  }
  datesList(e3, t6) {
    return z$3(0, t6).map((r12) => addDecades(e3, r12));
  }
  data(e3) {
    const {
      cellUID: t6,
      focusedDate: r12,
      isActiveView: o9,
      max: n10,
      min: a9,
      selectedDate: g6,
      selectionRange: E2 = l$5,
      viewDate: h3
    } = e3;
    if (!h3)
      return $$3;
    const q2 = z$3(0, w$3), Y2 = firstYearOfDecade(h3), D2 = lastYearOfDecade(h3), A2 = X();
    return z$3(0, b$2).map((y4) => {
      const V3 = addYears(Y2, y4 * w$3);
      return q2.map((L3) => {
        const s10 = this.normalize(addYears(V3, L3), a9, n10), I3 = this.isEqual(s10, E2.start), R2 = this.isEqual(s10, E2.end), F2 = !I3 && !R2 && Y$1(s10, E2), v3 = o9 && (Array.isArray(g6) ? this.isSelectedFromArray(s10, g6, a9, n10) : j(g6, a9, n10) && this.isEqual(s10, g6));
        return B$2(s10, Y2, D2) ? {
          formattedValue: this.value(s10),
          id: `${t6}${s10.getTime()}`,
          isFocused: this.isEqual(s10, r12),
          isSelected: v3,
          isWeekend: false,
          isInRange: j(s10, a9, n10),
          isRangeStart: I3,
          isRangeMid: F2,
          isRangeEnd: R2,
          isRangeSplitEnd: F2 && this.isEqual(s10, D2),
          isRangeSplitStart: F2 && this.isEqual(s10, Y2),
          isToday: this.isEqual(s10, A2),
          title: this.cellTitle(s10),
          value: s10
        } : null;
      });
    });
  }
  isSelectedFromArray(e3, t6, r12, o9) {
    let n10 = false;
    return t6.forEach((a9) => {
      j(e3, r12, o9) && this.isEqual(e3, a9) && (n10 = true);
    }), n10;
  }
  isEqual(e3, t6) {
    return !e3 || !t6 ? false : e3.getFullYear() === t6.getFullYear();
  }
  isInArray(e3, t6) {
    if (!t6.length)
      return false;
    const r12 = e3.getFullYear();
    return t6[0].getFullYear() <= r12 && r12 <= t6[t6.length - 1].getFullYear() + 9;
  }
  isInRange(e3, t6, r12) {
    const o9 = e3.getFullYear(), n10 = !t6 || t6.getFullYear() <= o9, a9 = !r12 || o9 <= r12.getFullYear();
    return n10 && a9;
  }
  isRangeStart(e3) {
    return e3.getFullYear() % 100 === 0;
  }
  isInSameView(e3, t6) {
    return durationInDecades(e3, t6) === 0;
  }
  move(e3, t6) {
    const r12 = C$6[t6];
    return r12 ? r12(e3) : e3;
  }
  cellTitle(e3) {
    return e3.getFullYear().toString();
  }
  navigationTitle(e3) {
    return e3 ? firstYearOfDecade(e3).getFullYear().toString() : "";
  }
  title(e3) {
    return e3 ? `${firstYearOfDecade(e3).getFullYear()} - ${lastYearOfDecade(e3).getFullYear()}` : "";
  }
  rowLength(e3) {
    return w$3;
  }
  skip(e3, t6) {
    return durationInDecades(t6, e3);
  }
  total(e3, t6) {
    return durationInDecades(e3, t6) + 1;
  }
  value(e3) {
    return e3 ? e3.getFullYear().toString() : "";
  }
  viewDate(e3, t6, r12 = 1) {
    return durationInDecades(e3, t6) < r12 ? addDecades(e3, -1) : e3;
  }
  normalize(e3, t6, r12) {
    return e3 < t6 && this.isEqual(e3, t6) ? cloneDate(t6) : e3 > r12 && this.isEqual(e3, r12) ? cloneDate(r12) : e3;
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const _$1 = [[]], S$5 = 7, $$2 = 6, C$5 = 6, G$3 = 0, P$3 = {
  [w$4.Left]: (s10) => addDays(s10, -1),
  [w$4.Up]: (s10) => addWeeks(s10, -1),
  [w$4.Right]: (s10) => addDays(s10, 1),
  [w$4.Down]: (s10) => addWeeks(s10, 1),
  [w$4.PrevView]: (s10) => addMonths(s10, -1),
  [w$4.NextView]: (s10) => addMonths(s10, 1),
  [w$4.FirstInView]: (s10) => firstDayOfMonth(s10),
  [w$4.LastInView]: (s10) => lastDayOfMonth(s10)
};
class Q {
  constructor(t6) {
    this.intl = t6;
  }
  addToDate(t6, e3) {
    return addMonths(t6, e3);
  }
  datesList(t6, e3) {
    return z$3(0, e3).map((n10) => addMonths(t6, n10));
  }
  data(t6) {
    const {
      cellUID: e3,
      focusedDate: n10,
      isActiveView: l7,
      max: r12,
      min: a9,
      selectedDate: c6,
      selectionRange: m3 = l$5,
      viewDate: f4
    } = t6;
    if (!f4)
      return _$1;
    const M3 = firstDayOfMonth(f4), R2 = lastDayOfMonth(f4), N3 = dayOfWeek(M3, this.intl.firstDay(), -1), b2 = z$3(0, S$5), q2 = X();
    return z$3(0, $$2).map((V3) => {
      const v3 = addDays(N3, V3 * S$5);
      return b2.map((L3) => {
        const i16 = this.normalize(addDays(v3, L3), a9, r12), k3 = i16 < M3 || i16 > R2, p6 = this.isEqual(i16, m3.start), A2 = this.isEqual(i16, m3.end), E2 = !p6 && !A2 && Y$1(i16, m3), F2 = l7 && (Array.isArray(c6) ? this.isSelectedFromArray(i16, c6, a9, r12) : j(c6, a9, r12) && this.isEqual(i16, c6));
        return {
          formattedValue: this.value(i16),
          id: `${e3}${i16.getTime()}`,
          isFocused: this.isEqual(i16, n10),
          isSelected: F2,
          isInRange: j(i16, a9, r12),
          isWeekend: this.isWeekend(i16),
          isRangeStart: p6,
          isRangeMid: E2,
          isRangeEnd: A2,
          isRangeSplitStart: E2 && this.isEqual(i16, M3),
          isRangeSplitEnd: E2 && this.isEqual(i16, R2),
          isToday: this.isEqual(i16, q2),
          title: this.cellTitle(i16),
          value: i16,
          isOtherMonth: k3
        };
      });
    });
  }
  isEqual(t6, e3) {
    return !t6 || !e3 ? false : getDate(t6).getTime() === getDate(e3).getTime();
  }
  isSelectedFromArray(t6, e3, n10, l7) {
    let r12 = false;
    return e3.forEach((a9) => {
      j(t6, n10, l7) && this.isEqual(t6, a9) && (r12 = true);
    }), r12;
  }
  isInArray(t6, e3) {
    return !!e3.length && firstDayOfMonth(e3[0]) <= t6 && t6 <= lastDayOfMonth(e3[e3.length - 1]);
  }
  isInRange(t6, e3, n10) {
    const l7 = getDate(t6), r12 = !e3 || getDate(e3) <= l7, a9 = !n10 || l7 <= getDate(n10);
    return r12 && a9;
  }
  isInSameView(t6, e3) {
    return durationInMonths(t6, e3) === 0;
  }
  isRangeStart(t6) {
    return !t6.getMonth();
  }
  move(t6, e3) {
    const n10 = P$3[e3];
    return n10 ? n10(t6) : t6;
  }
  cellTitle(t6) {
    return this.intl.formatDate(t6, "D");
  }
  navigationTitle(t6) {
    return t6 ? this.isRangeStart(t6) ? t6.getFullYear().toString() : this.abbrMonthNames()[t6.getMonth()] : "";
  }
  title(t6) {
    return `${this.wideMonthNames()[t6.getMonth()]} ${t6.getFullYear()}`;
  }
  rowLength(t6) {
    return S$5 + (t6 ? 1 : 0);
  }
  skip(t6, e3) {
    return durationInMonths(e3, t6);
  }
  total(t6, e3) {
    return durationInMonths(t6, e3) + 1;
  }
  value(t6) {
    return t6 ? t6.getDate().toString() : "";
  }
  viewDate(t6, e3, n10 = 1) {
    return durationInMonths(t6, e3) < n10 ? addMonths(t6, -1) : t6;
  }
  isWeekend(t6) {
    const e3 = t6.getDay();
    return e3 === C$5 || e3 === G$3;
  }
  abbrMonthNames() {
    return this.intl.dateFormatNames({ nameType: "abbreviated", type: "months" });
  }
  normalize(t6, e3, n10) {
    return t6 < e3 && this.isEqual(t6, e3) ? getDate(e3) : t6 > n10 && this.isEqual(t6, n10) ? getDate(n10) : t6;
  }
  wideMonthNames() {
    return this.intl.dateFormatNames({ nameType: "wide", type: "months", standAlone: true });
  }
}
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const C$4 = [[]], S$4 = 4, G$2 = 3, P$2 = (r12) => r12 > 4 ? -5 : r12 < 2 ? -2 : -7, k$3 = (r12) => r12 < 7 ? 5 : r12 < 10 ? 7 : 2, z$2 = {
  [w$4.Left]: (r12) => addMonths(r12, -1),
  [w$4.Up]: (r12) => addMonths(r12, P$2(r12.getMonth())),
  [w$4.Right]: (r12) => addMonths(r12, 1),
  [w$4.Down]: (r12) => addMonths(r12, k$3(r12.getMonth())),
  [w$4.PrevView]: (r12) => addYears(r12, -1),
  [w$4.NextView]: (r12) => addYears(r12, 1),
  [w$4.FirstInView]: (r12) => firstMonthOfYear(r12),
  [w$4.LastInView]: (r12) => lastMonthOfYear(r12)
};
let K$1 = class K {
  constructor(t6) {
    this._intl = t6;
  }
  addToDate(t6, e3) {
    return addYears(t6, e3);
  }
  datesList(t6, e3) {
    return z$3(0, e3).map((n10) => addYears(t6, n10));
  }
  data(t6) {
    const {
      cellUID: e3,
      focusedDate: n10,
      isActiveView: l7,
      max: i16,
      min: a9,
      selectedDate: c6,
      selectionRange: f4 = l$5,
      viewDate: Y2
    } = t6;
    if (!Y2)
      return C$4;
    const b2 = this.abbrMonthNames(), d8 = firstMonthOfYear(Y2), q2 = lastMonthOfYear(Y2), y4 = d8.getFullYear(), A2 = z$3(0, S$4), V3 = X();
    return z$3(0, G$2).map((v3) => {
      const D2 = addMonths(d8, v3 * S$4);
      return A2.map((N3) => {
        const s10 = this.normalize(addMonths(D2, N3), a9, i16);
        if (y4 < s10.getFullYear())
          return null;
        const w3 = this.isEqual(s10, f4.start), T3 = this.isEqual(s10, f4.end), E2 = !w3 && !T3 && Y$1(s10, f4), L3 = l7 && (Array.isArray(c6) ? this.isSelectedFromArray(s10, c6, a9, i16) : j(c6, a9, i16) && this.isEqual(s10, c6));
        return {
          formattedValue: b2[s10.getMonth()],
          id: `${e3}${s10.getTime()}`,
          isFocused: this.isEqual(s10, n10),
          isSelected: L3,
          isInRange: j(s10, a9, i16),
          isWeekend: false,
          isRangeStart: w3,
          isRangeMid: E2,
          isRangeEnd: T3,
          isRangeSplitEnd: E2 && this.isEqual(s10, q2),
          isRangeSplitStart: E2 && this.isEqual(s10, d8),
          isToday: this.isEqual(s10, V3),
          title: this.cellTitle(s10),
          value: s10
        };
      });
    });
  }
  isSelectedFromArray(t6, e3, n10, l7) {
    let i16 = false;
    return e3.forEach((a9) => {
      j(t6, n10, l7) && this.isEqual(t6, a9) && (i16 = true);
    }), i16;
  }
  isEqual(t6, e3) {
    return !t6 || !e3 ? false : t6.getFullYear() === e3.getFullYear() && t6.getMonth() === e3.getMonth();
  }
  isInArray(t6, e3) {
    if (!e3.length)
      return false;
    const n10 = t6.getFullYear();
    return e3[0].getFullYear() <= n10 && n10 <= e3[e3.length - 1].getFullYear();
  }
  isInRange(t6, e3, n10) {
    const l7 = createDate(t6.getFullYear(), t6.getMonth(), 1), i16 = !e3 || createDate(e3.getFullYear(), e3.getMonth(), 1) <= l7, a9 = !n10 || l7 <= createDate(n10.getFullYear(), n10.getMonth(), 1);
    return i16 && a9;
  }
  isInSameView(t6, e3) {
    return durationInYears(t6, e3) === 0;
  }
  isRangeStart(t6) {
    return t6.getFullYear() % 10 === 0;
  }
  move(t6, e3) {
    const n10 = z$2[e3];
    return n10 ? n10(t6) : t6;
  }
  cellTitle(t6) {
    return `${t6.getFullYear()} ${this.value(t6)}`;
  }
  navigationTitle(t6) {
    return this.title(t6);
  }
  title(t6) {
    return t6 ? t6.getFullYear().toString() : "";
  }
  rowLength(t6) {
    return S$4;
  }
  skip(t6, e3) {
    return durationInYears(e3, t6);
  }
  total(t6, e3) {
    return durationInYears(t6, e3) + 1;
  }
  value(t6) {
    return t6 ? this.abbrMonthNames()[t6.getMonth()] : "";
  }
  viewDate(t6, e3, n10 = 1) {
    return durationInYears(t6, e3) < n10 ? addYears(t6, -1) : t6;
  }
  abbrMonthNames() {
    return this._intl.dateFormatNames({ nameType: "abbreviated", type: "months" });
  }
  normalize(t6, e3, n10) {
    return t6 < e3 && this.isEqual(t6, e3) ? cloneDate(e3) : t6 > n10 && this.isEqual(t6, n10) ? cloneDate(n10) : t6;
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const a$2 = {
  [c$5.month]: Q,
  [c$5.year]: K$1,
  [c$5.decade]: U$1,
  [c$5.century]: W$1
}, u$4 = (i16, t6) => {
  const e3 = c$5[c$5[i16 + t6]];
  return e3 !== void 0 ? e3 : i16;
};
let V$1 = class V {
  constructor(t6) {
    this.bottom = c$5.month, this.top = c$5.century, this.onViewChanged = t6;
  }
  configure(t6, e3) {
    this.bottom = t6, this.top = e3;
  }
  service(t6, e3) {
    return new a$2[`${t6}`](e3);
  }
  moveDown(t6, e3) {
    this.move(t6, -1, e3);
  }
  moveUp(t6, e3) {
    this.move(t6, 1, e3);
  }
  moveToBottom(t6) {
    t6 !== this.bottom && this.onViewChanged({ view: this.bottom });
  }
  canMoveDown(t6) {
    return this.bottom < t6;
  }
  canMoveUp(t6) {
    return t6 < this.top;
  }
  clamp(t6) {
    return t6 < this.bottom ? this.bottom : t6 > this.top ? this.top : t6;
  }
  move(t6, e3, n10) {
    const r12 = this.clamp(u$4(t6, e3));
    r12 !== t6 && this.onViewChanged({ view: r12 }, n10);
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
class K2 {
  constructor() {
    this.calendarHeight = 0, this.headerHeight = 0, this.monthViewHeight = 0, this.yearViewHeight = 0, this.decadeViewHeight = 0, this.centuryViewHeight = 0, this.navigationItemHeight = 0, this.scrollableContentHeight = 0, this.scrollableYearContentHeight = 0, this.calendarWidth = 0, this.monthViewWidth = 0, this.yearViewWidth = 0, this.decadeViewWidth = 0, this.centuryViewWidth = 0, this.scrollableContentWidth = 0, this.didCalculate = false, this.hostContainer = null;
  }
  ensureHeights() {
    this.calendarHeight === void 0 && this.calculateHeights();
  }
  calculateHeights(o9, c6) {
    if (!e$C)
      return;
    const h3 = Q$1("div"), w3 = Q$1("ul"), k3 = Q$1("li"), C2 = Q$1("td"), x3 = Q$1("th"), b2 = Q$1("tr"), B2 = Q$1("tbody"), O2 = Q$1("thead"), f4 = Q$1("table"), e3 = c6 && c6.uCalendar, W3 = c6 && c6.uButton, Y2 = o$q(
      G$9.wrapper({
        c: W3,
        fillMode: "flat",
        size: "medium",
        rounded: "medium",
        themeColor: "primary"
      }),
      j$3.title({ c: e3 })
    ), $2 = () => h3(
      `
                <span class="${Y2}">
                    <span class="${o$q(G$9.text({ c: W3 }))}">March 2017</span>
                </span>
                <span class="${o$q(j$3.spacer({ c: e3 }))}"></span>
                <span class="${o$q(j$3.nav({ c: e3 }))}"><button class="${o$q(
        j$3.today({ c: e3 })
      )}">TODAY</button></span>
            `,
      o$q(j$3.header({ c: e3, vertical: true }))
    ), q2 = () => f4(
      [
        O2(
          [
            b2(
              [x3("MO", o$q(j$3.th({ c: e3 })))],
              o$q(j$3.tr({ c: e3 }))
            )
          ],
          o$q(j$3.thead({ c: e3 }))
        )
      ],
      o$q(j$3.table({ c: e3, weekdays: true }))
    ), S2 = (t6, a9) => new Array(t6).fill("1").map(a9), N3 = (t6, a9 = 1) => f4(
      [
        B2(
          [b2([C2("1", o$q(j$3.td({ c: e3, isWeek: true })))])].concat(
            S2(
              t6,
              () => b2(
                S2(
                  a9,
                  (d8) => C2(
                    `<span class="${o$q(
                      j$3.link({ c: e3 })
                    )}">${d8}</span>`,
                    o$q(j$3.td({ c: e3 }))
                  )
                ),
                o$q(j$3.tr({ c: e3 }))
              )
            )
          ),
          o$q(j$3.tbody({ c: e3 }))
        )
      ],
      o$q(j$3.table({ c: e3 }))
    ), m3 = (t6) => h3(
      t6,
      o$q(
        j$3.scrollableSelector({
          c: e3
        }),
        j$3.scrollable({
          c: e3,
          horizontal: true
        })
      )
    ), A2 = (t6, a9, d8) => h3(
      d8 ? [$2(), q2(), m3([t6, t6])] : [$2(), m3([t6, t6])],
      a9,
      { left: "-10000px", position: "absolute" }
    ), I3 = /* @__PURE__ */ (() => {
      let t6;
      return () => e$C ? (t6 || (t6 = h3(
        [m3([w3([k3("<span>FEB</span>")])])],
        o$q(j$3.navigation({ c: e3 })),
        { left: "0px", position: "absolute" }
      )), t6) : null;
    })(), y4 = ({ cells: t6, rows: a9 }, d8, T3) => {
      let V3;
      return () => e$C ? (V3 || (V3 = A2(N3(a9, t6), d8, T3)), V3) : null;
    }, p6 = (t6) => t6.querySelector(
      `.${o$q(j$3.scrollableSelector({ c: e3 }))}`
    ), H3 = (t6) => {
      const a9 = p6(t6);
      return a9.className = `${a9.className} scrollable-horizontal`, t6;
    }, z3 = y4(
      { cells: 7, rows: 6 },
      o$q(j$3.view({ c: e3, month: true })),
      true
    ), D2 = y4(
      { cells: 5, rows: 3 },
      o$q(j$3.view({ c: e3, year: true })),
      false
    ), F2 = y4(
      { cells: 5, rows: 2 },
      o$q(j$3.view({ c: e3, decade: true })),
      false
    ), L3 = () => H3(z3()), P2 = () => H3(D2()), R2 = () => H3(F2()), n10 = (t6) => parseFloat(window.getComputedStyle(t6).height) || t6.offsetHeight, u5 = (t6) => {
      const a9 = window.getComputedStyle(t6);
      return parseFloat(a9.width) + parseFloat(a9.paddingLeft) + parseFloat(a9.paddingRight) || t6.offsetWidth;
    }, l7 = (t6) => t6.querySelector("tbody");
    this.didCalculate = true, o9 && (this.hostContainer = o9), this.batch(z3(), (t6) => {
      const a9 = l7(t6);
      this.calendarHeight = n10(t6), this.monthViewHeight = n10(a9), this.headerHeight = n10(a9.children[0]), this.scrollableContentHeight = n10(p6(t6));
    }), this.batch(L3(), (t6) => {
      const a9 = l7(t6);
      this.calendarWidth = u5(t6), this.monthViewWidth = u5(a9), this.scrollableContentWidth = u5(p6(t6));
    }), this.batch(D2(), (t6) => {
      this.yearViewHeight = n10(l7(t6)), this.scrollableYearContentHeight = n10(p6(t6));
    }), this.batch(P2(), (t6) => {
      this.yearViewWidth = u5(l7(t6));
    }), this.batch(F2(), (t6) => {
      this.decadeViewHeight = n10(l7(t6)), this.centuryViewHeight = this.decadeViewHeight;
    }), this.batch(R2(), (t6) => {
      this.decadeViewWidth = u5(l7(t6)), this.centuryViewWidth = this.decadeViewWidth;
    }), this.batch(I3(), (t6) => {
      this.navigationItemHeight = n10(t6.querySelector("li"));
    });
  }
  viewHeight(o9) {
    return this.viewDimension(o9, "height");
  }
  viewWidth(o9) {
    return this.viewDimension(o9, "width");
  }
  viewDimension(o9, c6) {
    const h3 = c6 === "height" ? "ViewHeight" : "ViewWidth";
    switch (o9) {
      case c$5.month:
        return this[`month${h3}`];
      case c$5.year:
        return this[`year${h3}`];
      case c$5.decade:
        return this[`decade${h3}`];
      case c$5.century:
        return this[`century${h3}`];
      default:
        return 1;
    }
  }
  batch(o9, c6) {
    const h3 = this.hostContainer || document.body, w3 = h3.appendChild(o9);
    c6(w3), h3.removeChild(w3);
  }
}
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const n$5 = {
  33: w$4.PrevView,
  34: w$4.NextView,
  35: w$4.LastInView,
  36: w$4.FirstInView,
  37: w$4.Left,
  38: w$4.Up,
  39: w$4.Right,
  40: w$4.Down,
  "meta+38": w$4.UpperView,
  "meta+40": w$4.LowerView
};
let p$7 = class p4 {
  constructor(e3) {
    this.bus = e3;
  }
  action(e3) {
    const r12 = `${e3.ctrlKey || e3.metaKey ? "meta+" : ""}${e3.keyCode}`;
    return n$5[r12];
  }
  move(e3, r12, o9, i16, s10) {
    return i16 ? r12 === w$4.UpperView && this.bus.canMoveUp(o9) ? (this.bus.moveUp(o9, s10), e3) : r12 === w$4.LowerView && this.bus.canMoveDown(o9) ? (this.bus.moveDown(o9, s10), e3) : i16.move(e3, r12) : e3;
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const n$4 = (l7) => (t6) => Math.floor(t6 / l7), o$4 = (l7) => (t6) => t6 * l7;
let s$2 = class s8 {
  constructor(t6) {
    this.dom = t6, this.divideByMagnitude = null, this.powerByMagnitude = null, this.navigator = null, this.view = null, this.monthScrolled = false, this.navScrolled = false;
  }
  configure(t6) {
    const i16 = Math.max(this.dom.viewHeight(t6) / this.dom.navigationItemHeight, 1);
    this.divideByMagnitude = n$4(i16), this.powerByMagnitude = o$4(i16);
  }
  sync(t6, i16, e3) {
    if (!(!t6 || !i16)) {
      if (this.navigator = t6, this.view = i16, e3.target === this.navigator.element) {
        if (this.monthScrolled) {
          this.monthScrolled = false;
          return;
        }
        this.navScrolled = true, this.scrollSiblingOf(this.navigator.element);
      }
      if (e3.target === this.view.element) {
        if (this.navScrolled) {
          this.navScrolled = false;
          return;
        }
        this.monthScrolled = true, this.scrollSiblingOf(this.view.element);
      }
    }
  }
  scrollSiblingOf(t6) {
    const i16 = this.siblingComponent(t6), e3 = this.calculateScroll(i16, t6.scrollTop);
    i16.scrollTo(e3);
  }
  siblingComponent(t6) {
    return this.navigator.element === t6 ? this.view : this.navigator;
  }
  calculateScroll(t6, i16) {
    const e3 = t6 === this.navigator ? this.divideByMagnitude : this.powerByMagnitude;
    return e3 ? e3(i16) : 0;
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const S$3 = (u5) => u5 ? u5.virtualization : null, k$2 = (u5 = d$4.defaultProps.min, a9 = d$4.defaultProps.max, e3, t6) => t6 !== void 0 ? t6 !== null && j(getDate(t6), u5, a9) ? t6 : null : e3 !== null && j(getDate(e3), u5, a9) ? e3 : null, n$3 = class n8 extends reactExports.Component {
  constructor(a9) {
    super(a9), this.scrollSyncService = null, this.focusedDate = null, this.Navigation = null, this.calendarViewList = null, this._element = null, this.intl = null, this.service = null, this.isActive = false, this.didNavigationChange = false, this.focus = () => {
      this._element && this._element.focus();
    }, this.shouldScroll = () => this.didNavigationChange, this.handleScroll = (t6) => {
      this.scrollSyncService && this.scrollSyncService.sync(
        S$3(this.Navigation),
        S$3(this.calendarViewList),
        t6
      );
    }, this.handleNavigationChange = (t6) => {
      if (this.props.disabled)
        return;
      this.didNavigationChange = true;
      const i16 = cloneDate(t6.value);
      this.setState({ focusedDate: i16 });
    }, this.handleViewChange = ({ view: t6 }) => {
      this.scrollSyncService && this.scrollSyncService.configure(t6), this.setState({ activeView: t6 });
    }, this.handleDateChange = (t6) => {
      const i16 = cloneDate(t6.value), o9 = cloneDate(t6.value), p6 = this.bus.canMoveDown(this.state.activeView);
      if (this.props.disabled)
        return;
      if (p6)
        if (t6.isTodayClick)
          this.bus.moveToBottom(this.state.activeView);
        else {
          this.bus.moveDown(this.state.activeView, t6.syntheticEvent), this.setState({ focusedDate: o9 });
          return;
        }
      this.setState({ value: i16, focusedDate: o9 }), this.valueDuringOnChange = i16;
      const { onChange: h3 } = this.props;
      if (h3) {
        const l7 = {
          syntheticEvent: t6.syntheticEvent,
          nativeEvent: t6.nativeEvent,
          value: i16,
          target: this
        };
        h3.call(void 0, l7);
      }
      this.valueDuringOnChange = void 0;
    }, this.handleFocus = (t6) => {
      if (this.isActive = true, !this.calendarViewList)
        return;
      this.calendarViewList.focusActiveDate();
      const { onFocus: i16 } = this.props;
      i16 && i16.call(void 0, t6);
    }, this.handleBlur = (t6) => {
      if (this.isActive = false, !this.calendarViewList)
        return;
      this.calendarViewList.blurActiveDate();
      const { onBlur: i16 } = this.props;
      i16 && i16.call(void 0, t6);
    }, this.handleKeyDown = (t6) => {
      const { keyCode: o9, ctrlKey: p6, metaKey: h3 } = t6;
      if (!(!this.focusedDate || !this.service)) {
        if (o9 === 84 && this.setState({ focusedDate: X() }), (p6 || h3) && (o9 === e$B.left || o9 === e$B.right)) {
          if (this.props.disabled)
            return;
          this.didNavigationChange = true, this.focusedDate.getDate() === 31 && this.focusedDate.setDate(30);
          const l7 = o9 === e$B.left ? this.focusedDate.getMonth() - 1 : this.focusedDate.getMonth() + 1, v3 = new Date(this.focusedDate.setMonth(l7)), b2 = cloneDate(v3);
          this.setState({ focusedDate: b2 });
        }
        if (o9 === e$B.enter) {
          if (this.value !== null && isEqualDate(this.focusedDate, this.value)) {
            const v3 = K$2(this.focusedDate, this.min, this.max);
            S$3(this.calendarViewList).scrollToIndex(this.service.skip(v3, this.min));
          }
          const l7 = {
            syntheticEvent: t6,
            nativeEvent: t6.nativeEvent,
            value: this.focusedDate,
            target: this
          };
          this.handleDateChange(l7);
        } else {
          const l7 = K$2(
            this.navigation.move(
              this.focusedDate,
              this.navigation.action(t6),
              this.state.activeView,
              this.service,
              t6
            ),
            this.min,
            this.max
          );
          if (isEqualDate(this.focusedDate, l7))
            return;
          this.setState({ focusedDate: l7 });
        }
        t6.preventDefault();
      }
    }, this.handleMouseDown = (t6) => {
      t6.preventDefault();
    }, this.handleClick = (t6) => {
      this._element && this._element.focus({ preventScroll: true });
    }, l$p(e$5);
    const e3 = k$2(
      this.min,
      this.max,
      this.props.defaultValue || n8.defaultProps.defaultValue,
      this.props.value
    );
    this.state = {
      value: e3,
      activeView: d$7(
        c$5[a9.defaultActiveView],
        this.bottomView,
        this.topView
      ),
      focusedDate: K$2(
        a9.focusedDate || e3 || X(),
        this.min,
        this.max
      )
    }, this.dom = new K2(), this.bus = new V$1(this.handleViewChange), this.navigation = new p$7(this.bus), this.oldValue = e3;
  }
  get cellUID() {
    return this.props.id + "-cell-uid";
  }
  get id() {
    return this.props.id + "-id";
  }
  /**
   * Gets the wrapping element of the Calendar.
   */
  get element() {
    return this._element;
  }
  /**
   * Gets the value of the Calendar.
   */
  get value() {
    return this.valueDuringOnChange !== void 0 ? this.valueDuringOnChange : this.props.value !== void 0 ? this.props.value : this.state.value;
  }
  get min() {
    return getDate(this.props.min !== void 0 ? this.props.min : n8.defaultProps.min);
  }
  get max() {
    return getDate(this.props.max !== void 0 ? this.props.max : n8.defaultProps.max);
  }
  get bottomView() {
    return c$5[this.props.bottomView !== void 0 ? this.props.bottomView : n8.defaultProps.bottomView];
  }
  get topView() {
    return c$5[this.props.topView !== void 0 ? this.props.topView : n8.defaultProps.topView];
  }
  /**
   * @hidden
   */
  componentDidMount() {
    const { unstyled: a9 } = this.props;
    Promise.resolve().then(() => {
      d$s(), this._element && (this.dom.calculateHeights(this._element, a9), this.scrollSyncService = new s$2(this.dom), this.scrollSyncService.configure(this.state.activeView), this.forceUpdate());
    });
  }
  /**
   * @hidden
   */
  componentDidUpdate(a9, e3) {
    d$s(), e3.activeView !== this.state.activeView && this.scrollSyncService && this.scrollSyncService.configure(this.state.activeView), this.calendarViewList && (this.isActive ? this.calendarViewList.focusActiveDate : this.calendarViewList.blurActiveDate)(), this.didNavigationChange = false, this.isActive && (this.oldValue = this.value);
  }
  /**
   * @hidden
   */
  render() {
    const { _ref: a9, unstyled: e3, bottomView: t6, topView: i16, disabled: o9, weekNumber: p6, mobileMode: h3, className: l7 } = this.props;
    a9 && a9(this);
    const v3 = e3 && e3.uCalendar, b2 = this.value !== null && this.oldValue !== null ? !isEqualDate(this.value, this.oldValue) : this.value !== this.oldValue, E2 = d$7(
      this.state.activeView,
      c$5[t6 !== void 0 ? t6 : n8.defaultProps.bottomView],
      c$5[i16 !== void 0 ? i16 : n8.defaultProps.topView]
    ), w3 = k$2(this.min, this.max, this.value, this.value), O2 = w3 ? getDate(w3) : null;
    this.focusedDate = getDate(K$2(
      b2 && w3 !== null ? w3 : this.state.focusedDate,
      this.min,
      this.max
    )), this.intl = a$s(this), this.bus.configure(this.bottomView, this.topView), this.service = this.bus.service(E2, this.intl);
    const { smoothScroll: P2 = Number.parseFloat(reactExports.version) < 18 } = this.props, A2 = r$r(
      j$3.wrapper({
        c: v3,
        disabled: o9,
        weekNumber: p6,
        mobileMode: h3
      }),
      l7
    ), M3 = [this.props.navigation && /* @__PURE__ */ reactExports.createElement(
      g$5,
      {
        key: 0,
        ref: (m3) => {
          this.Navigation = m3;
        },
        activeView: this.state.activeView,
        focusedDate: this.focusedDate,
        min: this.min,
        max: this.max,
        onScroll: this.handleScroll,
        onChange: this.handleNavigationChange,
        service: this.service,
        dom: this.dom,
        navigationItem: this.props.navigationItem,
        tabIndex: this.props.tabIndex,
        unstyled: e3
      }
    ), /* @__PURE__ */ reactExports.createElement(
      v$2,
      {
        key: 1,
        ref: (m3) => {
          this.calendarViewList = m3;
        },
        activeView: this.state.activeView,
        focusedDate: this.focusedDate,
        min: this.min,
        max: this.max,
        bus: this.bus,
        shouldScroll: this.shouldScroll,
        onScroll: this.handleScroll,
        service: this.service,
        cell: this.props.cell,
        weekCell: this.props.weekCell,
        dom: this.dom,
        smoothScroll: P2,
        showWeekNumbers: this.props.weekNumber,
        onChange: this.handleDateChange,
        value: O2,
        cellUID: this.cellUID,
        headerTitle: this.props.headerTitle,
        header: this.props.header,
        tabIndex: this.props.tabIndex,
        weekDaysFormat: this.props.weekDaysFormat,
        showOtherMonthDays: this.props.showOtherMonthDays,
        unstyled: e3
      }
    )];
    return /* @__PURE__ */ reactExports.createElement(
      "div",
      {
        ref: (m3) => {
          this._element = m3;
        },
        className: A2,
        id: this.props.id || this.id,
        "aria-labelledby": this.props.ariaLabelledBy,
        "aria-describedby": this.props.ariaDescribedBy,
        "aria-disabled": this.props.disabled,
        tabIndex: this.props.disabled ? void 0 : this.props.tabIndex || 0,
        onFocus: this.handleFocus,
        onBlur: this.handleBlur,
        onKeyDown: this.handleKeyDown,
        onMouseDown: this.handleMouseDown,
        onClick: this.handleClick
      },
      M3
    );
  }
};
n$3.displayName = "Calendar", n$3.propTypes = {
  className: o$r.string,
  defaultActiveView: o$r.oneOf(["month", "year", "decade", "century"]),
  defaultValue: o$r.instanceOf(Date),
  disabled: o$r.bool,
  focusedDate: o$r.instanceOf(Date),
  id: o$r.string,
  ariaLabelledBy: o$r.string,
  ariaDescribedBy: o$r.string,
  weekDaysFormat: o$r.oneOf(["short", "abbreviated", "narrow"]),
  max: o$r.instanceOf(Date),
  min: o$r.instanceOf(Date),
  navigation: o$r.bool,
  smoothScroll: o$r.bool,
  onBlur: o$r.func,
  onChange: o$r.func,
  onFocus: o$r.func,
  tabIndex: o$r.number,
  value: o$r.instanceOf(Date),
  weekNumber: o$r.bool,
  topView: (a9, e3, t6) => {
    const i16 = a9[e3], o9 = a9.bottomView;
    return i16 && o9 && c$5[i16] < c$5[o9] ? new Error(
      `Invalid prop + ${e3} suplied to ${t6}.
                    ${e3} can not be smaller than bottomView.
                    `
    ) : null;
  },
  bottomView: (a9, e3, t6) => {
    const i16 = a9[e3], o9 = a9.topView;
    return i16 && o9 && c$5[i16] > c$5[o9] ? new Error(
      `Invalid prop + ${e3} suplied to ${t6}.
                    ${e3} can not be bigger than topView.
                    `
    ) : null;
  }
}, n$3.defaultProps = {
  disabled: false,
  min: H$1,
  max: L$2,
  weekDaysFormat: "short",
  navigation: true,
  defaultActiveView: "month",
  defaultValue: null,
  topView: "century",
  bottomView: "month",
  showOtherMonthDays: false
};
let d$4 = n$3;
const Z = a$v(), W2 = m$l(
  x$l(
    Z,
    l$o(d$4)
  )
);
W2.displayName = "KendoReactCalendar";
p$t(d$4);
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let t$4 = class t3 {
  constructor() {
    this.symbols = "", this.partMap = [];
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const y$3 = "d", _ = "wide", t$3 = (e3, n10, g6, f4) => {
  const l7 = e3[f4 + e3.length - g6.length], p6 = e3.substring(0, f4 + e3.length - g6.length), h3 = g6.substring(0, f4), b2 = [];
  if (p6 === h3 && f4 > 0)
    return b2.push([n10[f4 - 1], h3[f4 - 1]]), b2;
  if (p6.indexOf(h3) === 0 && (h3.length === 0 || n10[h3.length - 1] !== n10[h3.length])) {
    let s10 = "";
    h3.length === 1 && b2.push([n10[0], h3[0]]);
    for (let u5 = h3.length; u5 < p6.length; u5++)
      n10[u5] !== s10 && n10[u5] !== "_" && (s10 = n10[u5], b2.push([s10, ""]));
    return b2;
  }
  if (h3.indexOf(p6) === 0 || n10[f4 - 1] === "_") {
    let s10 = n10[0];
    for (let u5 = Math.max(0, p6.length - 1); u5 < n10.length; u5++)
      if (n10[u5] !== "_") {
        s10 = n10[u5];
        break;
      }
    return [[s10, h3[f4 - 1]]];
  }
  return h3[h3.length - 1] === " " || h3[h3.length - 1] === l7 ? [[n10[f4 - 1], "_"]] : [[n10[f4 - 1], h3[f4 - 1]]];
}, M$2 = (e3, n10) => (e3[n10.pattern[0]] = n10.type, e3), x$3 = (e3, n10, g6) => e3 === null || !(n10 && n10 > e3 || g6 && g6 < e3);
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let k$1 = class k {
  constructor(t6, e3, s10) {
    this.year = true, this.month = true, this.date = true, this.hours = true, this.minutes = true, this.seconds = true, this.milliseconds = true, this.leadingZero = null, this.typedMonthPart = "", this.knownParts = "adHhmMsEy", this.symbols = {
      E: "E",
      H: "H",
      M: "M",
      a: "a",
      d: "d",
      h: "h",
      m: "m",
      s: "s",
      y: "y"
    }, this._value = getDate(/* @__PURE__ */ new Date()), this.intlProvider = t6, this.formatPlaceholder = e3, this.format = s10, this.monthNames = this.allFormatedMonths();
  }
  get intl() {
    return this.intlProvider();
  }
  get value() {
    return this._value;
  }
  setValue(t6) {
    t6 ? isEqual(t6, this._value) || (this._value = cloneDate(t6), this.modifyExisting(true)) : (this._value = getDate(/* @__PURE__ */ new Date()), this.modifyExisting(false));
  }
  hasValue() {
    const t6 = (e3, s10) => e3 || s10.type !== "literal" && s10.type !== "dayperiod" && this.getExisting(s10.pattern[0]);
    return this.intl.splitDateFormat(this.format).reduce(t6, false);
  }
  getDateObject() {
    for (let t6 = 0; t6 < this.knownParts.length; t6++)
      if (!this.getExisting(this.knownParts[t6]))
        return null;
    return cloneDate(this.value);
  }
  getTextAndFormat() {
    return this.merge(
      this.intl.formatDate(this.value, this.format),
      this.dateFormatString(this.value, this.format)
    );
  }
  modifyExisting(t6) {
    const e3 = this.dateFormatString(this.value, this.format).symbols;
    for (let s10 = 0; s10 < e3.length; s10++)
      this.setExisting(e3[s10], t6);
  }
  getExisting(t6) {
    switch (t6) {
      case "y":
        return this.year;
      case "M":
      case "L":
        return this.month;
      case "d":
        return this.date;
      case "E":
        return this.date && this.month && this.year;
      case "h":
      case "H":
        return this.hours;
      case "m":
        return this.minutes;
      case "s":
        return this.seconds;
      default:
        return true;
    }
  }
  setExisting(t6, e3) {
    switch (t6) {
      case "y":
        this.year = e3, e3 === false && this._value.setFullYear(2e3);
        break;
      case "M":
        this.month = e3, e3 === false && this._value.setMonth(0);
        break;
      case "d":
        this.date = e3;
        break;
      case "h":
      case "H":
        this.hours = e3;
        break;
      case "m":
        this.minutes = e3;
        break;
      case "s":
        this.seconds = e3;
        break;
      default:
        return;
    }
  }
  modifyPart(t6, e3) {
    let s10 = cloneDate(this.value);
    switch (t6) {
      case "y":
        s10.setFullYear(s10.getFullYear() + e3);
        break;
      case "M":
        s10 = addMonths(this.value, e3);
        break;
      case "d":
      case "E":
        s10.setDate(s10.getDate() + e3);
        break;
      case "h":
      case "H":
        s10.setHours(s10.getHours() + e3);
        break;
      case "m":
        s10.setMinutes(s10.getMinutes() + e3);
        break;
      case "s":
        s10.setSeconds(s10.getSeconds() + e3);
        break;
      case "a":
        s10.setHours(s10.getHours() + 12 * e3);
        break;
    }
    this.setExisting(t6, true), this._value = s10;
  }
  parsePart(t6, e3) {
    if (this.resetLeadingZero(), !e3)
      return this.setExisting(t6, false), { value: null };
    const s10 = this.intl.formatDate(this.value, this.format), r12 = this.dateFormatString(this.value, this.format), n10 = r12.symbols;
    let i16 = false, h3 = "", l7 = "", d8 = "";
    for (let o9 = 0; o9 < s10.length; o9++)
      n10[o9] === t6 ? (l7 += this.getExisting(t6) ? s10[o9] : "0", i16 = true) : i16 ? d8 += s10[o9] : h3 += s10[o9];
    let a9 = null;
    const g6 = this.matchMonth(e3);
    for (; l7.length > 0 && l7.charAt(0) === "0"; )
      l7 = l7.slice(1);
    l7.length >= 4 && (l7 = "");
    for (let o9 = 0; o9 < 2; o9++) {
      let c6 = l7 + e3, p6 = parseInt(c6, 10);
      if (a9 = this.intl.parseDate(h3 + c6 + d8, this.format), !a9 && !isNaN(p6) && !isNaN(parseInt(e3, 10))) {
        if (t6 === "M" && !g6) {
          const u5 = p6 - 1;
          u5 > -1 && u5 < 12 && (a9 = cloneDate(this.value), a9.setMonth(u5), a9.getMonth() !== u5 && (a9 = lastDayOfMonth(addMonths(a9, -1))));
        }
        t6 === "y" && (a9 = createDate(
          parseInt(c6, 10),
          this.month ? this.value.getMonth() : 0,
          this.date ? this.value.getDate() : 1,
          this.hours ? this.value.getHours() : 0,
          this.minutes ? this.value.getMinutes() : 0,
          this.seconds ? this.value.getSeconds() : 0,
          this.milliseconds ? this.value.getMilliseconds() : 0
        ), this.date && a9.getDate() !== this.value.getDate() && (a9 = lastDayOfMonth(addMonths(a9, -1))));
      }
      if (a9)
        return this._value = a9, this.setExisting(t6, true), { value: this.value };
      l7 = "";
    }
    return g6 && (a9 = this.intl.parseDate(h3 + g6 + d8, this.format), a9) ? (this._value = a9, this.setExisting(t6, true), { value: this.value }) : (e3 === "0" && (this.leadingZero = this.isAbbrMonth(r12.partMap, t6) ? null : { [t6]: true }, this.setExisting(t6, false)), { value: null });
  }
  symbolMap(t6) {
    return this.intl.splitDateFormat(this.format).reduce(M$2, {})[t6];
  }
  resetLeadingZero() {
    const t6 = this.leadingZero !== null;
    return this.leadingZero = null, t6;
  }
  isAbbrMonth(t6, e3) {
    const s10 = this.partPattern(t6, e3);
    return s10.type === "month" && s10.names;
  }
  partPattern(t6, e3) {
    return t6.filter((s10) => s10.pattern.indexOf(e3) !== -1)[0];
  }
  matchMonth(t6) {
    if (this.typedMonthPart += t6.toLowerCase(), this.monthNames.length === 0)
      return "";
    for (; this.typedMonthPart.length > 0; ) {
      for (let s10 = 0; s10 < this.monthNames.length; s10++)
        if (this.monthNames[s10].toLowerCase().indexOf(this.typedMonthPart) === 0)
          return this.monthNames[s10];
      const e3 = parseInt(this.typedMonthPart, 10);
      if (e3 >= 1 && e3 <= 12 && e3.toString() === this.typedMonthPart)
        return this.monthNames[e3 - 1];
      this.typedMonthPart = this.typedMonthPart.substring(1, this.typedMonthPart.length);
    }
    return "";
  }
  allFormatedMonths() {
    const t6 = this.intl.splitDateFormat(this.format);
    for (let e3 = 0; e3 < t6.length; e3++)
      if (t6[e3].type === "month" && t6[e3].names)
        return this.intl.dateFormatNames(t6[e3].names);
    return [];
  }
  dateFormatString(t6, e3) {
    const s10 = this.intl.splitDateFormat(e3), r12 = [], n10 = [];
    for (let h3 = 0; h3 < s10.length; h3++) {
      let l7 = this.intl.formatDate(t6, { pattern: s10[h3].pattern }).length;
      for (; l7 > 0; )
        r12.push(this.symbols[s10[h3].pattern[0]] || "_"), n10.push(s10[h3]), l7--;
    }
    const i16 = new t$4();
    return i16.symbols = r12.join(""), i16.partMap = n10, i16;
  }
  merge(t6, e3) {
    let s10 = "", r12 = "", n10 = e3.symbols;
    for (let i16 = n10.length - 1; i16 >= 0; i16--)
      if (this.knownParts.indexOf(n10[i16]) === -1 || this.getExisting(n10[i16]))
        s10 = t6[i16] + s10, r12 = n10[i16] + r12;
      else {
        const h3 = n10[i16];
        for (; i16 >= 0 && h3 === n10[i16]; )
          i16--;
        for (i16++, this.leadingZero && this.leadingZero[h3] ? s10 = "0" + s10 : s10 = this.dateFieldName(e3.partMap[i16]) + s10; r12.length < s10.length; )
          r12 = n10[i16] + r12;
      }
    return { text: s10, format: r12 };
  }
  dateFieldName(t6) {
    const e3 = this.formatPlaceholder || "wide";
    return e3[t6.type] ? e3[t6.type] : e3 === "formatPattern" ? t6.pattern : this.intl.dateFieldName(Object.assign(t6, { nameType: e3 }));
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const i$5 = (e3, t6, r12) => ({
  candidateValue: O$3(k$5, e3),
  maxValue: addDays(O$3(k$5, r12), t6.getHours() < r12.getHours() ? 0 : 1),
  minValue: O$3(k$5, t6)
}), N$3 = (e3, t6, r12) => {
  if (!e3 || !t6 || !r12)
    return true;
  const {
    candidateValue: n10,
    minValue: s10,
    maxValue: o9
  } = i$5(e3, t6, r12);
  return s10 <= n10 && n10 <= o9;
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const y$2 = (t6) => {
  const s10 = a$r(), e3 = n$t(), l7 = e3 && e3.uDateInput, r12 = s10.toLanguageString(n$6, x$4[n$6]), i16 = (o9) => {
    o9.stopPropagation();
    const { onClick: n10 } = t6;
    n10 && n10.call(void 0, o9);
  };
  return /* @__PURE__ */ reactExports.createElement(
    "span",
    {
      className: r$r(A$c.clearButton({ c: l7 })),
      role: "button",
      onClick: i16,
      tabIndex: t6.tabindex || -1,
      title: r12,
      key: "clearbutton"
    },
    /* @__PURE__ */ reactExports.createElement(v$c, { name: "x", icon: xIcon })
  );
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const oe = "Please enter a valid value!", o$3 = class o6 extends reactExports.Component {
  constructor(i16) {
    super(i16), this.kendoDate = null, this.currentFormat = "", this.paste = false, this._element = null, this._wrapper = null, this._lastSelectedSymbol = "", this.focus = () => {
      this._element && this._element.focus();
    }, this.setValidity = () => {
      this.element && this.element.setCustomValidity && this.element.setCustomValidity(
        this.validity.valid ? "" : this.props.validationMessage || o6.defaultProps.validationMessage
      );
    }, this.updateOnPaste = (t6) => {
      if (!this.element || !this.kendoDate)
        return;
      const s10 = a$s(this).parseDate(this.element.value, this.props.format) || this.value, r12 = this.value;
      this.kendoDate.setValue(s10), this.triggerChange(t6, r12);
    }, this.spinnersMouseDown = (t6) => {
      t6.preventDefault();
      const s10 = o$k(document);
      this.element && s10 !== this.element && this.element.focus({ preventScroll: true });
    }, this.handlePaste = () => {
      this.paste = true;
    }, this.handleClick = (t6) => {
      this.props.onChange && this.props.onChange(t6);
    }, this.elementChange = (t6) => {
      if (!this.element || !this.kendoDate)
        return;
      if (this.paste) {
        this.updateOnPaste(t6), this.paste = false;
        return;
      }
      const { text: s10, format: r12 } = this.kendoDate.getTextAndFormat();
      this.currentFormat = r12;
      const n10 = this.value, a9 = t$3(
        s10,
        this.currentFormat,
        this.element.value,
        this.selection.start
      ), l7 = a9.length === 1 && a9[0][1] === "_";
      if (!l7)
        for (let d8 = 0; d8 < a9.length; d8++)
          this.kendoDate.parsePart(a9[d8][0], a9[d8][1]);
      a9.length && a9[0][0] !== "_" && this.setSelection(this.selectionBySymbol(a9[0][0])), l7 && this.switchDateSegment(1), this.triggerChange(t6, n10);
    }, this.elementClick = (t6) => {
      this.setSelection(this.selectionByIndex(this.selection.start));
    }, this.nativeWheel = (t6) => {
      o$k(document) === this.element && t6.preventDefault();
    }, this.wheel = (t6) => {
      o$k(document) === this.element && (t6.nativeEvent.deltaY < 0 && this.increasePart(t6), t6.nativeEvent.deltaY > 0 && this.decreasePart(t6));
    }, this.increasePart = (t6) => {
      this.modifyDateSegmentValue(1, t6);
    }, this.decreasePart = (t6) => {
      this.modifyDateSegmentValue(-1, t6);
    }, this.elementKeyDown = (t6) => {
      if (!t6.altKey) {
        switch (t6.keyCode) {
          case 37:
            this.switchDateSegment(-1);
            break;
          case 38:
            this.modifyDateSegmentValue(1, t6);
            break;
          case 39:
            this.switchDateSegment(1);
            break;
          case 40:
            this.modifyDateSegmentValue(-1, t6);
            break;
          default:
            return;
        }
        t6.preventDefault();
      }
    }, this.elementOnFocus = (t6) => {
      this.wrapper && this.wrapper.classList.add("k-focus"), this.setState({ focused: true });
    }, this.elementOnBlur = (t6) => {
      this.wrapper && this.wrapper.classList.remove("k-focus"), this.setState({ focused: false });
    }, l$p(e$5), this.state = {
      focused: false
    };
  }
  get _inputId() {
    return this.props.id + "-accessibility-id";
  }
  /**
   * @hidden
   */
  componentDidMount() {
    this.setValidity(), this.wrapper && this.wrapper.addEventListener("wheel", this.nativeWheel, { passive: false });
  }
  /**
   * @hidden
   */
  componentDidUpdate(i16, t6) {
    this._lastSelectedSymbol && t6.focused === this.state.focused ? this.setSelection(this.selectionBySymbol(this._lastSelectedSymbol)) : this.props.placeholder !== void 0 && this.selection.start === this.selection.end && this.setSelection({ start: 0, end: this.currentFormat.length }), this.setValidity();
  }
  /**
   * @hidden
   */
  componentWillUnmount() {
    this.wrapper && this.wrapper.removeEventListener("wheel", this.nativeWheel);
  }
  /**
   * @hidden
   */
  render() {
    const {
      size: i16 = o6.defaultProps.size,
      fillMode: t6 = o6.defaultProps.fillMode,
      rounded: s10 = o6.defaultProps.rounded,
      autoFocus: r12 = o6.defaultProps.autoFocus,
      unstyled: n10
    } = this.props, a9 = n10 && n10.uDateInput;
    this.props._ref && (this.props._ref.current = this);
    const l7 = s$k(this), d8 = { ...o6.defaultProps, ...this.props }, { name: E2, label: D2, id: x3, disabled: I3 } = d8, u5 = this.text, T3 = u5 === this.props.placeholder ? "" : u5, V3 = u5 === this.props.placeholder ? u5 : void 0, k3 = x3 || this._inputId, S2 = !this.validityStyles || this.validity.valid, F2 = /* @__PURE__ */ reactExports.createElement(a$w, { onFocus: this.elementOnFocus, onBlur: this.elementOnBlur }, ({ onFocus: M3, onBlur: B2 }) => /* @__PURE__ */ reactExports.createElement(
      "span",
      {
        ref: (w3) => {
          this._wrapper = w3;
        },
        style: D2 ? void 0 : { width: this.props.width },
        dir: this.props.dir,
        className: r$r(
          A$c.wrapper({
            c: a9,
            size: i16,
            fillMode: t6,
            rounded: s10,
            disabled: I3,
            required: this.required,
            invalid: !S2
          }),
          this.props.className
        ),
        onFocus: M3,
        onBlur: B2
      },
      /* @__PURE__ */ reactExports.createElement(
        "input",
        {
          role: this.props.ariaRole || "textbox",
          readOnly: this.props.readonly,
          tabIndex: this.props.tabIndex,
          disabled: this.props.disabled,
          title: this.props.title !== void 0 ? this.props.title : u5,
          type: "text",
          spellCheck: false,
          autoComplete: "off",
          autoCorrect: "off",
          autoFocus: r12,
          className: r$r(A$c.inputInner({ c: a9 })),
          id: k3,
          "aria-label": this.props.ariaLabel,
          "aria-labelledby": this.props.ariaLabelledBy,
          "aria-describedby": this.props.ariaDescribedBy,
          "aria-haspopup": this.props.ariaHasPopup,
          "aria-disabled": this.props.disabled,
          "aria-expanded": this.props.ariaExpanded,
          "aria-controls": this.props.ariaControls,
          "aria-required": this.props.required,
          "aria-invalid": !S2,
          onWheel: this.wheel,
          onClick: this.elementClick,
          onInput: this.elementChange,
          onPaste: this.handlePaste,
          onKeyDown: this.elementKeyDown,
          onChange: n$x,
          value: T3,
          placeholder: V3,
          name: E2,
          ref: (w3) => this._element = w3
        }
      ),
      this.props.children,
      this.props.clearButton && this.props.value && /* @__PURE__ */ reactExports.createElement(y$2, { onClick: this.handleClick, key: "clearbutton" }),
      this.props.spinners && /* @__PURE__ */ reactExports.createElement(
        "span",
        {
          className: r$r(A$c.inputSpinner({ c: a9 })),
          onMouseDown: this.spinnersMouseDown
        },
        /* @__PURE__ */ reactExports.createElement(
          p$j,
          {
            tabIndex: -1,
            type: "button",
            rounded: null,
            className: r$r(A$c.spinnerIncrease({ c: a9 })),
            icon: "caret-alt-up",
            svgIcon: caretAltUpIcon,
            "aria-label": l7.toLanguageString(
              a$4,
              x$4[a$4]
            ),
            title: l7.toLanguageString(a$4, x$4[a$4]),
            onClick: this.increasePart
          }
        ),
        /* @__PURE__ */ reactExports.createElement(
          p$j,
          {
            tabIndex: -1,
            type: "button",
            rounded: null,
            className: r$r(A$c.spinnerDecrease({ c: a9 })),
            icon: "caret-alt-down",
            svgIcon: caretAltDownIcon,
            "aria-label": l7.toLanguageString(
              c$4,
              x$4[c$4]
            ),
            title: l7.toLanguageString(c$4, x$4[c$4]),
            onClick: this.decreasePart
          }
        )
      )
    ));
    return D2 ? /* @__PURE__ */ reactExports.createElement(
      l$8,
      {
        label: D2,
        editorId: k3,
        editorValue: u5,
        editorValid: S2,
        editorDisabled: this.props.disabled,
        children: F2,
        style: { width: this.props.width }
      }
    ) : F2;
  }
  /* Public Getters */
  /**
   * Gets the value of the DateInput.
   */
  get value() {
    return this.valueDuringOnChange !== void 0 ? this.valueDuringOnChange : this.kendoDate && this.kendoDate.getDateObject();
  }
  /**
   * Gets the `name` property of the DateInput.
   */
  get name() {
    return this.props.name;
  }
  get min() {
    return this.props.min !== void 0 ? this.props.min : o6.defaultProps.min;
  }
  get max() {
    return this.props.max !== void 0 ? this.props.max : o6.defaultProps.max;
  }
  /**
   * @hidden
   */
  get text() {
    const i16 = { ...C$3.defaultProps, ...this.props }, {
      formatPlaceholder: t6 = o6.defaultProps.formatPlaceholder,
      format: s10 = o6.defaultProps.format,
      value: r12,
      defaultValue: n10
    } = i16;
    this.kendoDate === null ? (this.kendoDate = new k$1(this.intl.bind(this), t6, s10), this.kendoDate.setValue(r12 || n10 || null)) : (this.kendoDate.format = s10, this.kendoDate.formatPlaceholder = t6), r12 !== void 0 && this.value !== r12 && this.kendoDate.setValue(r12);
    const { text: a9, format: l7 } = this.kendoDate.getTextAndFormat();
    return this.currentFormat = l7, i16.placeholder !== null && i16.placeholder !== void 0 && !this.state.focused && !this.kendoDate.hasValue() ? i16.placeholder : a9;
  }
  /**
   * Represents the validity state into which the DateInput is set.
   */
  get validity() {
    const i16 = x$3(this.value, this.min, this.max) && N$3(this.value, this.props.minTime, this.props.maxTime), t6 = this.props.validationMessage !== void 0, s10 = (!this.required || this.value !== null) && i16, r12 = this.props.valid !== void 0 ? this.props.valid : s10;
    return {
      customError: t6,
      rangeOverflow: this.value && this.max.getTime() < this.value.getTime() || false,
      rangeUnderflow: this.value && this.value.getTime() < this.min.getTime() || false,
      valid: r12,
      valueMissing: this.value === null
    };
  }
  /**
   * Gets the element of the DateInput.
   *
   * @return - An `HTMLInputElement`.
   *
   * @example
   * ```jsx
   * class App extends React.Component {
   *     constructor(props) {
   *         super(props);
   *     }
   *     element = null;
   *     render() {
   *         return (
   *             <div>
   *                 <DateInput
   *                     ref={(dateInput) =>
   *                         this.element = dateInput ? dateInput.element : null}
   *                 />
   *                 <button onClick={() => console.log(this.element)}>console.log the element</button>
   *             </div>
   *         );
   *     }
   * }
   *
   * ReactDOM.render(
   *     <App />,
   *     document.getElementsByTagName('my-app')[0]
   * );
   * ```
   */
  get element() {
    return this._element;
  }
  /**
   * @hidden
   */
  get validityStyles() {
    return this.props.validityStyles !== void 0 ? this.props.validityStyles : o6.defaultProps.validityStyles;
  }
  /**
   * @hidden
   */
  get required() {
    return this.props.required !== void 0 ? this.props.required : false;
  }
  /**
   * @hidden
   */
  get wrapper() {
    return this._wrapper;
  }
  /**
   * @hidden
   */
  intl() {
    return a$s(this);
  }
  /*  end handlers */
  get selection() {
    let i16 = { start: 0, end: 0 };
    return this.element !== null && this.element.selectionStart !== void 0 && (i16 = { start: this.element.selectionStart, end: this.element.selectionEnd }), i16;
  }
  setSelection(i16) {
    this._lastSelectedSymbol = this.currentFormat[i16.start], window.requestAnimationFrame(() => {
      const t6 = o$k(document);
      this.element && t6 === this.element && !this.props.disableSelection && this.element.setSelectionRange(i16.start, i16.end);
    });
  }
  triggerChange(i16, t6) {
    this.valueDuringOnChange = this.value, this.forceUpdate(), this.props.onChange && !isEqual(t6, this.value) && this.props.onChange.call(void 0, {
      syntheticEvent: i16,
      nativeEvent: i16.nativeEvent,
      value: this.value,
      target: this
      // inRange: this.props.min && this.props.max ? isInRange(value, this.props.min, this.props.max) : true
    }), this.valueDuringOnChange = void 0;
  }
  selectionBySymbol(i16) {
    let t6 = -1, s10 = 0;
    for (let r12 = 0; r12 < this.currentFormat.length; r12++)
      this.currentFormat[r12] === i16 && (s10 = r12 + 1, t6 === -1 && (t6 = r12));
    return t6 < 0 && (t6 = 0), { start: t6, end: s10 };
  }
  selectionByIndex(i16) {
    let t6 = { start: i16, end: i16 };
    for (let s10 = i16, r12 = i16 - 1; s10 < this.currentFormat.length || r12 >= 0; s10++, r12--) {
      if (s10 < this.currentFormat.length && this.currentFormat[s10] !== "_") {
        t6 = this.selectionBySymbol(this.currentFormat[s10]);
        break;
      }
      if (r12 >= 0 && this.currentFormat[r12] !== "_") {
        t6 = this.selectionBySymbol(this.currentFormat[r12]);
        break;
      }
    }
    return t6;
  }
  switchDateSegment(i16) {
    const { start: t6, end: s10 } = this.selection;
    if (t6 < s10 && this.currentFormat[t6] !== this.currentFormat[s10 - 1]) {
      this.setSelection(this.selectionByIndex(i16 > 0 ? t6 : s10 - 1));
      return;
    }
    const r12 = this.currentFormat[t6];
    let n10 = t6 + i16;
    for (; n10 > 0 && n10 < this.currentFormat.length && !(this.currentFormat[n10] !== r12 && this.currentFormat[n10] !== "_"); )
      n10 += i16;
    if (this.currentFormat[n10] === "_")
      return;
    let a9 = n10;
    for (; a9 >= 0 && a9 < this.currentFormat.length && this.currentFormat[a9] === this.currentFormat[n10]; )
      a9 += i16;
    n10 > a9 && (a9 + 1 !== t6 || n10 + 1 !== s10) ? this.setSelection({ start: a9 + 1, end: n10 + 1 }) : n10 < a9 && (n10 !== t6 || a9 !== s10) && this.setSelection({ start: n10, end: a9 });
  }
  modifyDateSegmentValue(i16, t6) {
    if (!this.kendoDate)
      return;
    const s10 = this.value, r12 = this.currentFormat[this.selection.start], n10 = this.kendoDate.symbolMap(r12), a9 = ((this.props.steps || {})[n10] || 1) * i16;
    this.kendoDate.modifyPart(r12, a9), this.triggerChange(t6, s10);
  }
};
o$3.displayName = "DateInput", o$3.propTypes = {
  value: o$r.instanceOf(Date),
  format: o$r.oneOfType([
    o$r.string,
    o$r.shape({
      skeleton: o$r.string,
      pattern: o$r.string,
      date: o$r.oneOf(["short", "medium", "long", "full"]),
      time: o$r.oneOf(["short", "medium", "long", "full"]),
      datetime: o$r.oneOf(["short", "medium", "long", "full"]),
      era: o$r.oneOf(["narrow", "short", "long"]),
      year: o$r.oneOf(["numeric", "2-digit"]),
      month: o$r.oneOf(["numeric", "2-digit", "narrow", "short", "long"]),
      day: o$r.oneOf(["numeric", "2-digit"]),
      weekday: o$r.oneOf(["narrow", "short", "long"]),
      hour: o$r.oneOf(["numeric", "2-digit"]),
      hour12: o$r.bool,
      minute: o$r.oneOf(["numeric", "2-digit"]),
      second: o$r.oneOf(["numeric", "2-digit"]),
      timeZoneName: o$r.oneOf(["short", "long"])
    })
  ]),
  formatPlaceholder: o$r.oneOfType([
    o$r.oneOf([
      "wide",
      "narrow",
      "short",
      "formatPattern"
    ]),
    o$r.shape({
      year: o$r.string,
      month: o$r.string,
      day: o$r.string,
      hour: o$r.string,
      minute: o$r.string,
      second: o$r.string
    })
  ]),
  width: o$r.oneOfType([o$r.string, o$r.number]),
  tabIndex: o$r.number,
  title: o$r.string,
  steps: o$r.shape({
    year: o$r.number,
    month: o$r.number,
    day: o$r.number,
    hour: o$r.number,
    minute: o$r.number,
    second: o$r.number
  }),
  min: o$r.instanceOf(Date),
  max: o$r.instanceOf(Date),
  disabled: o$r.bool,
  spinners: o$r.bool,
  name: o$r.string,
  dir: o$r.string,
  label: o$r.string,
  id: o$r.string,
  ariaLabelledBy: o$r.string,
  ariaDescribedBy: o$r.string,
  ariaLabel: o$r.string,
  ariaRole: o$r.string,
  ariaHasPopup: o$r.oneOfType([o$r.bool, o$r.string]),
  ariaExpanded: o$r.oneOfType([o$r.bool]),
  onChange: o$r.func,
  validationMessage: o$r.string,
  required: o$r.bool,
  validate: o$r.bool,
  valid: o$r.bool,
  size: o$r.oneOf([null, "small", "medium", "large"]),
  rounded: o$r.oneOf([null, "small", "medium", "large", "full"]),
  fillMode: o$r.oneOf([null, "solid", "flat", "outline"]),
  autoFocus: o$r.bool
}, o$3.defaultProps = {
  format: y$3,
  size: "medium",
  rounded: "medium",
  fillMode: "solid",
  formatPlaceholder: _,
  // defaultValue: null as Date | null,
  spinners: false,
  disabled: false,
  max: cloneDate(L$2),
  min: cloneDate(H$1),
  minTime: cloneDate(q$2),
  maxTime: cloneDate(G$5),
  validityStyles: true,
  validationMessage: oe,
  placeholder: null,
  // the rest of the properties are undefined by default
  ariaHasPopup: "grid",
  autoFocus: false
};
let m$3 = o$3;
const le = a$v(), C$3 = m$l(
  x$l(
    le,
    l$o(m$3)
  )
);
C$3.displayName = "KendoReactDateInput";
p$t(m$3);
v$a(m$3);
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const e$3 = p$j;
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const m$2 = reactExports.forwardRef((e3, n10) => {
  const { _ref: r12 } = e3, t6 = reactExports.useRef(null);
  reactExports.useImperativeHandle(n10, () => t6.current), reactExports.useImperativeHandle(r12, () => t6.current);
  const c6 = reactExports.useMemo(
    () => r$r(e3.className, "k-picker-wrap"),
    [e3.className]
  );
  return /* @__PURE__ */ reactExports.createElement(
    "span",
    {
      ref: t6,
      id: e3.id,
      style: e3.style,
      className: c6,
      tabIndex: e3.tabIndex
    },
    e3.children
  );
});
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const a$1 = (e3) => {
  const [t6, o9] = reactExports.useState(false), r12 = () => {
    e3.current && o9(!!e3.current.text);
  };
  return reactExports.useEffect(r12), {
    editorValue: t6
  };
}, l$2 = (e3) => {
  const { dateInput: t6, ...o9 } = e3, r12 = a$1(t6);
  return /* @__PURE__ */ reactExports.createElement(
    l$8,
    {
      ...o9,
      ...r12
    }
  );
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const o$2 = 500, y$1 = (c6) => {
  const {
    footer: t6,
    children: s10,
    windowWidth: l7 = 0,
    navigatable: r12,
    navigatableElements: m3,
    expand: d8,
    animation: p6,
    onClose: n10,
    adaptiveTitle: b2,
    mobileFilter: i16
  } = c6, h3 = {
    navigatable: r12 || false,
    navigatableElements: m3 || [],
    expand: d8,
    animation: p6 !== false,
    onClose: n10,
    animationStyles: l7 <= o$2 ? { top: 0, width: "100%", height: "100%" } : void 0,
    className: l7 <= o$2 ? "k-adaptive-actionsheet k-actionsheet-fullscreen" : "k-adaptive-actionsheet k-actionsheet-bottom"
  };
  return /* @__PURE__ */ reactExports.createElement(b$8, { ...h3 }, /* @__PURE__ */ reactExports.createElement(e$h, { className: "k-text-center" }, /* @__PURE__ */ reactExports.createElement("div", { className: "k-actionsheet-titlebar-group k-hbox" }, /* @__PURE__ */ reactExports.createElement("div", { className: "k-actionsheet-title" }, /* @__PURE__ */ reactExports.createElement("div", null, b2)), /* @__PURE__ */ reactExports.createElement("div", { className: "k-actionsheet-actions" }, /* @__PURE__ */ reactExports.createElement(
    p$j,
    {
      tabIndex: 0,
      "aria-label": "Cancel",
      "aria-disabled": "false",
      type: "button",
      fillMode: "flat",
      icon: "x",
      svgIcon: xIcon,
      onClick: n10
    }
  ))), i16 && /* @__PURE__ */ reactExports.createElement("div", { className: "k-actionsheet-titlebar-group k-actionsheet-filter" }, i16)), s10, t6 && /* @__PURE__ */ reactExports.createElement(e$g, { className: "k-actions k-actions-stretched" }, /* @__PURE__ */ reactExports.createElement(
    p$j,
    {
      size: "large",
      tabIndex: 0,
      "aria-label": t6.cancelText,
      "aria-disabled": "false",
      type: "button",
      onClick: t6.onCancel
    },
    t6.cancelText
  ), /* @__PURE__ */ reactExports.createElement(
    p$j,
    {
      tabIndex: 0,
      themeColor: "primary",
      size: "large",
      "aria-label": t6.applyText,
      "aria-disabled": "false",
      type: "button",
      onClick: t6.onApply
    },
    t6.applyText
  )));
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const E$2 = 768;
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const o$1 = class o7 extends reactExports.Component {
  constructor(i16) {
    super(i16), this._element = null, this._dateInput = reactExports.createRef(), this._calendar = null, this.shouldFocusDateInput = false, this.prevShow = false, this.focus = () => {
      this.dateInput && this.dateInput.focus();
    }, this.setCalendarRef = (t6) => {
      this._calendar = t6;
    }, this.nextValue = (t6, s10) => t6.value !== void 0 ? t6.value : s10.value, this.nextShow = (t6, s10) => t6.show !== void 0 ? t6.show : s10.show, this.renderPopup = () => {
      const { disabled: t6, min: s10, max: a9, weekNumber: c6, focusedDate: m3, popupSettings: l7 } = this.props, { popupClass: f4, ...g6 } = l7, v3 = this.show, d8 = this.value, w3 = d8 && getDate(d8), u5 = r$r(
        f4
      ), b2 = {
        popupClass: "k-datepicker-popup",
        show: v3,
        anchor: this._element,
        className: u5,
        id: this._popupId,
        anchorAlign: {
          horizontal: "left",
          vertical: "bottom"
        },
        popupAlign: {
          horizontal: "left",
          vertical: "top"
        },
        ...g6,
        onMouseDownOutside: this.handleMouseDownOutside
      }, h3 = {
        disabled: t6,
        value: w3,
        min: s10,
        max: a9,
        weekNumber: c6,
        focusedDate: m3,
        className: this.mobileMode ? "k-calendar-lg" : "",
        navigation: !this.mobileMode,
        onChange: this.handleCalendarValueChange
      };
      return this.mobileMode ? /* @__PURE__ */ reactExports.createElement(this.calendarComp, { _ref: this.setCalendarRef, ...h3 }) : /* @__PURE__ */ reactExports.createElement(this.popupComp, { ...b2 }, /* @__PURE__ */ reactExports.createElement(this.calendarComp, { _ref: this.setCalendarRef, ...h3 }));
    }, this.renderAdaptivePopup = () => {
      const { windowWidth: t6 = 0 } = this.state, s10 = {
        expand: this.show,
        onClose: this.handleBlur,
        adaptiveTitle: this.props.adaptiveTitle,
        windowWidth: t6
      };
      return /* @__PURE__ */ reactExports.createElement(y$1, { ...s10 }, /* @__PURE__ */ reactExports.createElement(t$e, { overflowHidden: true }, this.renderPopup()));
    }, this.handleInputValueChange = (t6) => {
      this.handleValueChange(t6.value, t6);
    }, this.handleCalendarValueChange = (t6) => {
      const s10 = this.mergeTime(t6.value);
      this.handleValueChange(s10, t6);
    }, this.handleValueChange = (t6, s10) => {
      this.setState({
        value: cloneDate(t6 || void 0)
      }), this.valueDuringOnChange = t6, this.showDuringOnChange = false, this.mobileMode || (this.shouldFocusDateInput = true);
      const { onChange: a9 } = this.props;
      a9 && a9.call(void 0, {
        syntheticEvent: s10.syntheticEvent,
        nativeEvent: s10.nativeEvent,
        value: this.value,
        show: this.show,
        target: this
      }), this.valueDuringOnChange = void 0, this.showDuringOnChange = void 0, this.setShow(false);
    }, this.handleFocus = () => {
      this.setState({ focused: true });
    }, this.handleBlur = () => {
      this.setState({ focused: false }), this.setShow(false);
    }, this.togglePopup = () => {
      this.setShow(!this.show);
    }, this.handleMouseDownOutside = (t6) => {
      var s10;
      (s10 = this.props.popupSettings) != null && s10.onMouseDownOutside && this.props.popupSettings.onMouseDownOutside.call(void 0, t6);
    }, this.handleIconClick = () => {
      this.props.disabled || (this.shouldFocusDateInput = true, this.setShow(!this.show));
    }, this.handleIconMouseDown = (t6) => {
      t6.preventDefault();
    }, this.handleKeyDown = (t6) => {
      const { altKey: s10, keyCode: a9 } = t6;
      if (a9 === e$B.esc && this.show) {
        this.shouldFocusDateInput = true, this.setShow(false);
        return;
      }
      s10 && (a9 === e$B.up || a9 === e$B.down) && (t6.preventDefault(), t6.stopPropagation(), this.shouldFocusDateInput = a9 === e$B.up, this.setShow(a9 === e$B.down));
    }, l$p(e$5), this.state = {
      value: this.props.defaultValue || o7.defaultProps.defaultValue,
      show: this.props.defaultShow || o7.defaultProps.defaultShow,
      focused: false
    };
  }
  get _popupId() {
    return this.props.id + "-popup-id";
  }
  get document() {
    if (e$C)
      return this.element && this.element.ownerDocument || document;
  }
  /**
   * Gets the wrapping element of the DatePickerWithoutContext.
   */
  get element() {
    return this._element;
  }
  /**
   * The mobile mode of the DatePicker.
   */
  get mobileMode() {
    return !!(this.state.windowWidth && this.state.windowWidth <= E$2 && this.props.adaptive);
  }
  /**
   * Gets the DateInput component inside the DatePicker component.
   */
  get dateInput() {
    return this._dateInput.current;
  }
  /**
   * Gets the Calendar component inside the DatePicker component.
   */
  get calendar() {
    return this._calendar;
  }
  /**
   * Gets the value of the DatePickerWithoutContext.
   */
  get value() {
    const i16 = this.valueDuringOnChange !== void 0 ? this.valueDuringOnChange : this.props.value !== void 0 ? this.props.value : this.state.value;
    return i16 !== null ? cloneDate(i16) : null;
  }
  /**
   * Gets the popup state of the DatePickerWithoutContext.
   */
  get show() {
    return this.showDuringOnChange !== void 0 ? this.showDuringOnChange : this.props.show !== void 0 ? this.props.show : this.state.show;
  }
  /**
   * Gets the `name` property of the DatePickerWithoutContext.
   */
  get name() {
    return this.props.name;
  }
  get min() {
    return this.props.min !== void 0 ? this.props.min : o7.defaultProps.min;
  }
  get max() {
    return this.props.max !== void 0 ? this.props.max : o7.defaultProps.max;
  }
  get dateInputComp() {
    return this.props.dateInput || o7.defaultProps.dateInput;
  }
  get toggleButtonComp() {
    return this.props.toggleButton || o7.defaultProps.toggleButton;
  }
  get calendarComp() {
    return this.props.calendar || o7.defaultProps.calendar;
  }
  get popupComp() {
    return this.props.popup || o7.defaultProps.popup;
  }
  get pickerWrapComp() {
    return this.props.pickerWrap || o7.defaultProps.pickerWrap;
  }
  /**
   * Represents the validity state into which the DatePicker is set.
   */
  get validity() {
    const i16 = P$5(this.value, this.min, this.max), t6 = this.props.validationMessage !== void 0, s10 = (!this.required || this.value !== null) && i16, a9 = this.props.valid !== void 0 ? this.props.valid : s10;
    return {
      customError: t6,
      rangeOverflow: this.value && this.max.getTime() < this.value.getTime() || false,
      rangeUnderflow: this.value && this.value.getTime() < this.min.getTime() || false,
      valid: a9,
      valueMissing: this.value === null
    };
  }
  /**
   * @hidden
   */
  get validityStyles() {
    return this.props.validityStyles !== void 0 ? this.props.validityStyles : o7.defaultProps.validityStyles;
  }
  /**
   * @hidden
   */
  get required() {
    return this.props.required !== void 0 ? this.props.required : false;
  }
  /**
   * @hidden
   */
  componentDidMount() {
    var i16;
    this.observerResize = e$C && window.ResizeObserver && new window.ResizeObserver(this.calculateMedia.bind(this)), this.show && this.forceUpdate(), (i16 = this.document) != null && i16.body && this.observerResize && this.observerResize.observe(this.document.body);
  }
  /**
   * @hidden
   */
  componentDidUpdate() {
    this._calendar && this._calendar.element && this.show && !this.prevShow && this._calendar.element.focus({ preventScroll: true }), this.dateInput && this.dateInput.element && !this.show && this.shouldFocusDateInput && this.dateInput.element.focus({ preventScroll: true }), this.prevShow = this.show, this.shouldFocusDateInput = false;
  }
  /**
   * @hidden
   */
  componentWillUnmount() {
    var i16;
    clearTimeout(this.nextTickId), (i16 = this.document) != null && i16.body && this.observerResize && this.observerResize.disconnect();
  }
  /**
   * @hidden
   */
  render() {
    const {
      size: i16 = o7.defaultProps.size,
      rounded: t6 = o7.defaultProps.rounded,
      fillMode: s10 = o7.defaultProps.fillMode,
      disabled: a9,
      tabIndex: c6,
      title: m3,
      id: l7,
      format: f4,
      formatPlaceholder: g6,
      min: v3,
      max: d8,
      className: w3,
      width: u5,
      name: b2,
      validationMessage: h3,
      required: x3,
      validityStyles: B2,
      ariaLabelledBy: F2,
      ariaDescribedBy: V3,
      ariaLabel: z3,
      placeholder: N3,
      label: y4,
      popupSettings: ce2,
      defaultValue: me2,
      defaultShow: fe2,
      value: ge2,
      popup: ve2,
      weekNumber: we2,
      dateInput: be2,
      calendar: ye2,
      toggleButton: Ie2,
      onChange: Ce2,
      onBlur: De2,
      onFocus: Oe2,
      show: Se2,
      onOpen: Me2,
      pickerWrap: ke2,
      adaptive: Pe2,
      adaptiveTitle: Te2,
      valid: Ee2,
      autoFocus: R2,
      // Removed to support direct use in Form Field component
      visited: xe2,
      touched: Be2,
      modified: Fe2,
      ...I3
    } = this.props, A2 = this.value, C2 = !this.validityStyles || this.validity.valid, L3 = {
      disabled: a9,
      format: f4,
      formatPlaceholder: g6,
      id: l7,
      ariaLabelledBy: F2,
      ariaDescribedBy: V3,
      ariaLabel: z3,
      max: d8,
      min: v3,
      name: b2,
      onChange: this.handleInputValueChange,
      required: x3,
      tabIndex: this.show ? -1 : c6,
      title: m3,
      valid: this.validity.valid,
      validationMessage: h3,
      validityStyles: B2,
      value: A2,
      label: void 0,
      placeholder: this.state.focused ? null : N3,
      ariaExpanded: this.show,
      size: null,
      fillMode: null,
      rounded: null
    }, D2 = s$k(this).toLanguageString(r11, x$4[r11]), O2 = /* @__PURE__ */ reactExports.createElement(
      a$w,
      {
        onFocus: this.handleFocus,
        onBlur: this.mobileMode ? void 0 : this.handleBlur,
        onSyncBlur: this.props.onBlur,
        onSyncFocus: this.props.onFocus
      },
      (S2) => /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(
        "span",
        {
          ...y4 ? {} : I3,
          ref: (q2) => {
            this._element = q2;
          },
          className: r$r(
            "k-input",
            "k-datepicker",
            {
              [`k-input-${e$v.sizeMap[i16] || i16}`]: i16,
              [`k-rounded-${e$v.roundedMap[t6] || t6}`]: t6,
              [`k-input-${s10}`]: s10,
              "k-invalid": !C2,
              "k-required": this.required,
              "k-disabled": a9
            },
            w3
          ),
          onKeyDown: this.handleKeyDown,
          style: { width: u5 },
          onFocus: S2.onFocus,
          onBlur: S2.onBlur,
          onClick: this.mobileMode ? this.handleIconClick : void 0
        },
        /* @__PURE__ */ reactExports.createElement(
          this.dateInputComp,
          {
            _ref: this._dateInput,
            ariaRole: "combobox",
            readonly: this.mobileMode,
            ariaExpanded: this.show,
            ariaControls: this._popupId,
            autoFocus: R2,
            ...L3
          }
        ),
        /* @__PURE__ */ reactExports.createElement(
          this.toggleButtonComp,
          {
            type: "button",
            icon: "calendar",
            svgIcon: calendarIcon,
            title: D2,
            className: "k-input-button",
            rounded: null,
            onClick: this.mobileMode ? void 0 : this.handleIconClick,
            "aria-label": D2,
            fillMode: s10,
            onMouseDown: this.handleIconMouseDown
          }
        ),
        !this.mobileMode && this.renderPopup()
      ), this.mobileMode && this.renderAdaptivePopup())
    );
    return y4 ? /* @__PURE__ */ reactExports.createElement(
      l$2,
      {
        dateInput: this._dateInput,
        label: y4,
        editorId: l7,
        editorValid: C2,
        editorDisabled: a9,
        children: O2,
        style: { width: u5 },
        ...I3
      }
    ) : O2;
  }
  setShow(i16) {
    const { onOpen: t6, onClose: s10 } = this.props;
    this.show !== i16 && (this.setState({ show: i16 }), i16 && t6 && t6.call(void 0, {
      target: this
    }), !i16 && s10 && s10.call(void 0, {
      target: this
    }));
  }
  mergeTime(i16) {
    return this.value && i16 ? O$3(i16, this.value) : i16;
  }
  nextTick(i16) {
    clearTimeout(this.nextTickId), this.nextTickId = window.setTimeout(() => i16());
  }
  calculateMedia(i16) {
    for (const t6 of i16)
      this.setState({ windowWidth: t6.target.clientWidth });
  }
};
o$1.displayName = "DatePicker", o$1.propTypes = {
  className: o$r.string,
  defaultShow: o$r.bool,
  defaultValue: o$r.instanceOf(Date),
  disabled: o$r.bool,
  focusedDate: o$r.instanceOf(Date),
  format: o$r.oneOfType([
    o$r.string,
    o$r.shape({
      skeleton: o$r.string,
      pattern: o$r.string,
      date: o$r.oneOf(["short", "medium", "long", "full"]),
      time: o$r.oneOf(["short", "medium", "long", "full"]),
      datetime: o$r.oneOf(["short", "medium", "long", "full"]),
      era: o$r.oneOf(["narrow", "short", "long"]),
      year: o$r.oneOf(["numeric", "2-digit"]),
      month: o$r.oneOf(["numeric", "2-digit", "narrow", "short", "long"]),
      day: o$r.oneOf(["numeric", "2-digit"]),
      weekday: o$r.oneOf(["narrow", "short", "long"]),
      hour: o$r.oneOf(["numeric", "2-digit"]),
      hour12: o$r.bool,
      minute: o$r.oneOf(["numeric", "2-digit"]),
      second: o$r.oneOf(["numeric", "2-digit"]),
      timeZoneName: o$r.oneOf(["short", "long"])
    })
  ]),
  formatPlaceholder: o$r.oneOfType([
    o$r.oneOf(["wide", "narrow", "short", "formatPattern"]),
    o$r.shape({
      year: o$r.string,
      month: o$r.string,
      day: o$r.string,
      hour: o$r.string,
      minute: o$r.string,
      second: o$r.string
    })
  ]),
  id: o$r.string,
  ariaLabelledBy: o$r.string,
  ariaDescribedBy: o$r.string,
  ariaLabel: o$r.string,
  min: o$r.instanceOf(Date),
  max: o$r.instanceOf(Date),
  name: o$r.string,
  popupSettings: o$r.shape({
    animate: o$r.bool,
    appendTo: o$r.any,
    popupClass: o$r.string
  }),
  show: o$r.bool,
  tabIndex: o$r.number,
  title: o$r.string,
  value: o$r.instanceOf(Date),
  weekNumber: o$r.bool,
  width: o$r.oneOfType([o$r.number, o$r.string]),
  validationMessage: o$r.string,
  required: o$r.bool,
  validate: o$r.bool,
  valid: o$r.bool,
  size: o$r.oneOf([null, "small", "medium", "large"]),
  rounded: o$r.oneOf([null, "small", "medium", "large", "full"]),
  fillMode: o$r.oneOf([null, "solid", "flat", "outline"]),
  adaptive: o$r.bool,
  adaptiveTitle: o$r.string,
  autoFocus: o$r.bool
}, o$1.defaultProps = {
  defaultShow: false,
  defaultValue: null,
  dateInput: C$3,
  calendar: W2,
  toggleButton: e$3,
  popup: a$m,
  pickerWrap: m$2,
  disabled: false,
  format: "d",
  max: L$2,
  min: H$1,
  popupSettings: {},
  tabIndex: 0,
  weekNumber: false,
  validityStyles: true,
  size: "medium",
  rounded: "medium",
  fillMode: "solid",
  autoFocus: false
};
let p$6 = o$1;
const he = a$v(), pe = m$l(x$l(he, p$6));
pe.displayName = "KendoReactDatePicker";
v$a(p$6);
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const p$5 = (r12) => {
  const {
    ariaSort: i16,
    colSpan: n10,
    rowSpan: o9,
    columnId: l7,
    navigatable: e3,
    ariaColumnIndex: c6,
    ariaLabel: s10,
    ariaSelected: m3,
    ariaDescription: h3,
    ...d8
  } = r12, u5 = c$6(l7, e3), a9 = reactExports.useRef(null);
  return reactExports.useEffect(() => {
    a9.current && e3 && y$c(a9.current);
  }, [e3]), /* @__PURE__ */ reactExports.createElement(
    "th",
    {
      ref: a9,
      "aria-sort": i16,
      "aria-label": s10,
      "aria-colindex": c6,
      "aria-selected": m3,
      colSpan: n10,
      rowSpan: o9,
      ...u5,
      ...d8
    },
    r12.children
  );
};
p$5.displayName = "KendoReactHeaderThElement";
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
function x$2(p6) {
  const { enabled: m3, columns: l7 = [], tableViewPortWidth: b2, scrollLeft: u5 } = p6, c6 = l7.map(() => 1), i16 = l7.map(() => false);
  if (!m3)
    return { colSpans: c6, hiddenColumns: i16 };
  const n10 = l7.map((e3) => parseFloat((e3.width || "").toString()) || 10);
  let o9 = 0;
  for (let e3 = 0; e3 < l7.length; e3++) {
    if (l7[e3].locked)
      continue;
    const f4 = e3 < n10.length - 1 ? n10[e3 + 1] : 0;
    if (o9 + n10[e3] + f4 < u5)
      i16[e3] = true, o9 += n10[e3];
    else
      break;
  }
  const w3 = n10.reduce((e3, f4) => e3 + f4, 0);
  o9 = 0;
  for (let e3 = l7.length - 1; e3 >= 0; e3--)
    if (!l7[e3].locked)
      if (o9 + 2 * n10[e3] < w3 - b2 - u5)
        i16[e3] = true, o9 += n10[e3];
      else
        break;
  const t6 = [...i16], h3 = (e3) => e3;
  let s10 = t6.lastIndexOf(false), g6 = t6.some(h3), r12 = t6.every(h3), d8, a9;
  for (; g6 && t6.length && (s10 !== -1 || r12); ) {
    for (s10 < t6.length - 1 && (d8 = r12 ? t6.length : t6.length - s10 - 1, a9 = t6.length - d8, a9 === 0 && (a9 = d8 - 1), i16[a9] = false, c6[a9] = d8, t6.splice(s10 + 1, d8)); t6.length && !t6[t6.length - 1]; )
      t6.pop();
    s10 = t6.lastIndexOf(false), g6 = t6.some(h3), r12 = t6.every(h3);
  }
  return { colSpans: c6, hiddenColumns: i16 };
}
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const l$1 = (o9) => null;
l$1.displayName = "KendoReactGridColumn";
const t$2 = {
  filterable: true,
  editable: true,
  sortable: true,
  resizable: true,
  reorderable: true,
  groupable: true
};
l$1.propTypes = {
  field: o$r.string,
  title: o$r.string,
  editable: o$r.bool,
  sortable: o$r.oneOfType([
    o$r.bool,
    o$r.shape({
      allowUnsort: o$r.bool.isRequired
    })
  ]),
  cell: o$r.any,
  filterCell: o$r.any,
  filterTitle: o$r.string,
  filterable: o$r.bool,
  filter: o$r.oneOf(["text", "numeric", "boolean", "date"]),
  editor: o$r.oneOf(["text", "numeric", "boolean", "date"]),
  width: o$r.oneOfType([o$r.string, o$r.number]),
  minResizableWidth: o$r.number,
  headerCell: o$r.any,
  footerCell: o$r.any,
  headerSelectionValue: o$r.bool,
  format: o$r.string,
  headerClassName: o$r.string,
  className: o$r.string,
  reorderable: o$r.bool,
  resizable: o$r.bool,
  orderIndex: o$r.number,
  groupable: o$r.bool,
  columnMenu: o$r.any,
  menuIcon: o$r.any,
  locked: o$r.bool,
  hidden: o$r.bool,
  media: o$r.string
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
function c$3(e3, r12) {
  const i16 = (e3 || "").split(".");
  let o9 = r12;
  return i16.forEach((d8) => {
    o9 = o9 ? o9[d8] : void 0;
  }), o9;
}
function p$4(e3, r12, i16, o9, d8, s10, h3 = 0) {
  let t6 = h3;
  for (let n10 = 0; n10 < r12.length; n10++) {
    if (!d8 || r12[n10].value === void 0 || r12[n10].items === void 0) {
      e3[e3.length] = {
        dataIndex: o9.index,
        dataItem: r12[n10],
        rowType: "data",
        level: h3,
        expanded: s10 === void 0 || c$3(s10, r12[n10])
      }, o9.index++;
      continue;
    }
    t6 = Math.max(t6, h3 + 1);
    const a9 = s10 === void 0 || c$3(s10, r12[n10]) === void 0 || c$3(s10, r12[n10]);
    e3[e3.length] = {
      dataIndex: -1,
      dataItem: r12[n10],
      level: h3,
      rowType: "groupHeader",
      expanded: a9
    }, a9 && (t6 = Math.max(
      p$4(e3, r12[n10].items, i16, o9, d8, s10, h3 + 1),
      t6
    )), (i16 === "always" || a9 && i16 === "visible") && (e3[e3.length] = {
      dataIndex: -1,
      dataItem: r12[n10],
      rowType: "groupFooter",
      level: h3,
      expanded: a9
    });
  }
  return t6;
}
function I$2(e3, r12, i16, o9 = 0) {
  let d8 = [];
  if (!e3)
    return [];
  e3 && e3.length === void 0 && (e3 = [e3]), e3.filter((t6) => t6 && t6.props ? !t6.props.hidden : !t6.hidden).forEach((t6, n10) => {
    t6 = t6.props ? t6.props : t6;
    const a9 = r12[n10] || null, f4 = I$2(t6.children, a9 && a9.children || [], i16, o9 + 1);
    d8.push(
      Object.assign(
        { depth: o9 },
        t$2,
        f4.length ? { cell: () => null, filterCell: () => null } : {},
        a9 ? { width: a9.width, orderIndex: a9.orderIndex } : {},
        t6,
        {
          id: t6.id ? t6.id : ue.generateNavigatableId(`${i16.prevId++}`, i16.idPrefix, "column"),
          declarationIndex: d8.length,
          children: f4,
          rowSpan: 0,
          colSpan: 0,
          isAccessible: true,
          left: a9 && Math.floor(a9.left),
          right: a9 && Math.floor(a9.right)
        }
      )
    );
  });
  const h3 = (t6, n10) => t6.orderIndex === n10.orderIndex ? t6.declarationIndex - n10.declarationIndex : (t6.orderIndex || 0) - (n10.orderIndex || 0);
  if (d8.sort(h3), o9 === 0) {
    let t6 = [];
    const n10 = (a9, f4) => a9.forEach((l7) => {
      l7.parentIndex = f4, n10(l7.children, t6.push(l7) - 1);
    });
    return n10(d8, -1), t6;
  }
  return d8;
}
function b$1(e3, r12, i16, o9) {
  let d8 = [];
  Array.isArray(e3) ? d8 = e3 : e3 && (d8 = e3.data);
  const s10 = [];
  if (d8.length > 0) {
    let h3 = d8[0];
    if (r12)
      for (let n10 = 0; n10 < r12.length; n10++)
        h3 = h3.items && h3.items[0];
    Object.getOwnPropertyNames(h3).forEach((n10) => {
      n10 !== i16 && s10.push(Object.assign(
        {
          id: ue.generateNavigatableId(`${o9.prevId++}`, o9.idPrefix, "column"),
          declarationIndex: -1,
          parentIndex: -1,
          depth: 0,
          colSpan: 0,
          rowSpan: 0,
          index: 0,
          left: 0,
          right: 0,
          rightBorder: false,
          children: [],
          ariaColumnIndex: 0,
          isAccessible: true
        },
        t$2,
        { field: n10 }
      ));
    });
  }
  return s10;
}
const v$1 = (e3, r12) => {
  let i16 = e3[r12.parentIndex];
  for (; i16; ) {
    if (i16.footerCell)
      return true;
    i16 = e3[i16.parentIndex];
  }
  return false;
}, S$2 = (e3) => e3.filter((r12) => v$1(e3, r12) ? false : !!r12.footerCell || !(r12.children && r12.children.length > 0)), m$1 = (e3) => e3.width !== void 0 ? Math.floor(parseFloat(e3.width.toString())) + "px" : void 0, F$1 = (e3, r12) => r12 && r12.filter((i16) => i16.field === e3).length > 0, w$2 = (e3) => (e3.sort((r12, i16) => r12.declarationIndex - i16.declarationIndex), e3.map((r12) => {
  const {
    declarationIndex: i16,
    parentIndex: o9,
    depth: d8,
    colSpan: s10,
    rowSpan: h3,
    index: t6,
    kFirst: n10,
    children: a9,
    ...f4
  } = r12;
  return a9.length ? {
    children: w$2(a9),
    ...f4
  } : f4;
})), M$1 = typeof window != "undefined" && /Firefox/.test(window.navigator.userAgent), A$2 = 17895697, N$2 = (e3, r12) => {
  if (!(!e3 && !r12))
    return r12 ? e3 ? {
      ...e3,
      ...r12,
      select: {
        ...e3.select || {},
        ...r12.select || {}
      },
      hierarchy: {
        ...e3.hierarchy || {},
        ...r12.hierarchy || {}
      },
      group: {
        ...e3.group || {},
        ...r12.group || {}
      },
      edit: {
        ...e3.edit || {},
        ...r12.edit || {}
      }
    } : r12 : e3;
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const o8 = "grid.noRecords", a8 = "grid.pagerInfo", i$4 = "grid.pagerFirstPage", l6 = "grid.pagerPreviousPage", g$4 = "grid.pagerNextPage", s$1 = "grid.pagerLastPage", n$2 = "grid.pagerItemsPerPage", p$3 = "grid.pagerPage", d$3 = "grid.pagerPageSizeAriaLabel", c$2 = "grid.pagerOf", u$3 = "grid.pagerTotalPages", f3 = "grid.groupPanelEmpty", m2 = "grid.groupColumn", A$1 = "grid.ungroupColumn", I$1 = "grid.columnMenu", P$1 = "grid.filterApplyButton", h$1 = "grid.filterClearButton", O$2 = "grid.filterResetButton", C$2 = "grid.filterSubmitButton", b = "grid.filterTitle", E$1 = "grid.sortAscending", L$1 = "grid.sortDescending", S$1 = "grid.searchPlaceholder", y3 = "grid.filterCheckAll", B$1 = "grid.filterChooseOperator", q$1 = "grid.filterSelectAll", x$1 = "grid.filterSelectedItems", G$1 = "grid.sortAriaLabel", N$1 = "grid.filterAriaLabel", R$2 = "grid.groupPanelAriaLabel", w$1 = "grid.groupExpand", F = "grid.groupCollapse", T2 = "grid.detailExpand", D = "grid.detailCollapse", M2 = "grid.selectRow", v2 = "grid.gridAriaLabel", z$1 = {
  [T2]: "Expand detail row",
  [D]: "Collapse detail row",
  [w$1]: "Expand group",
  [F]: "Collapse Group",
  [o8]: "No records available",
  [f3]: "Drag a column header and drop it here to group by that column",
  [P$1]: "Apply",
  [h$1]: "Clear",
  [O$2]: "Reset",
  [C$2]: "Filter",
  [b]: "Filter",
  [E$1]: "Sort Ascending",
  [L$1]: "Sort Descending",
  [G$1]: "Sortable",
  [m2]: "Group Column",
  [A$1]: "Ungroup Column",
  [I$1]: "Column menu",
  [n$2]: "items per page",
  [a8]: "{0} - {1} of {2} items",
  [i$4]: "Go to the first page",
  [l6]: "Go to the previous page",
  [g$4]: "Go to the next page",
  [s$1]: "Go to the last page",
  [p$3]: "Page",
  [d$3]: "Page size",
  [c$2]: "of",
  [u$3]: "{0}",
  [S$1]: "Search",
  [y3]: "Check All",
  [B$1]: "Choose Operator",
  [x$1]: "selected items",
  [q$1]: "Select All",
  [N$1]: "Filter",
  [R$2]: "Group panel",
  [v2]: "Table",
  [M2]: "Select Row",
  "grid.filterEqOperator": "Is equal to",
  "grid.filterNotEqOperator": "Is not equal to",
  "grid.filterIsNullOperator": "Is null",
  "grid.filterIsNotNullOperator": "Is not null",
  "grid.filterIsEmptyOperator": "Is empty",
  "grid.filterIsNotEmptyOperator": "Is not empty",
  "grid.filterStartsWithOperator": "Starts with",
  "grid.filterContainsOperator": "Contains",
  "grid.filterNotContainsOperator": "Does not contain",
  "grid.filterEndsWithOperator": "Ends with",
  "grid.filterGteOperator": "Is greater than or equal to",
  "grid.filterGtOperator": "Is greater than",
  "grid.filterLteOperator": "Is less than or equal to",
  "grid.filterLtOperator": "Is less than",
  "grid.filterIsTrue": "Is true",
  "grid.filterIsFalse": "Is false",
  "grid.filterBooleanAll": "(All)",
  "grid.filterAfterOrEqualOperator": "Is after or equal to",
  "grid.filterAfterOperator": "Is after",
  "grid.filterBeforeOperator": "Is before",
  "grid.filterBeforeOrEqualOperator": "Is before or equal to",
  "grid.filterAndLogic": "And",
  "grid.filterOrLogic": "Or"
};
function U2(r12) {
  const e3 = r12.replace(/^pager\.([a-z])/, (k3, t6) => "grid.pager" + t6.toUpperCase());
  return { messageKey: e3, defaultMessage: z$1[e3] };
}
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const P = (a9) => {
  const {
    selectionChange: o9,
    field: p6,
    dataItem: k3,
    id: b2,
    className: f4,
    colSpan: h3,
    style: C2,
    ariaColumnIndex: x3,
    rowType: l7,
    cells: N3,
    render: n10
  } = a9, y4 = a$r(), I3 = reactExports.useCallback(
    (c6) => {
      o9 && o9({ syntheticEvent: c6 });
    },
    [o9]
  ), S2 = m$m(), s10 = c$3(p6, k3), w3 = c$6(b2), E2 = r$r(
    "k-table-td",
    f4
  ), r12 = {
    colSpan: h3,
    style: C2,
    className: E2,
    "aria-colindex": x3,
    role: "gridcell",
    ...w3
  }, i16 = typeof s10 == "boolean" && s10, d8 = /* @__PURE__ */ reactExports.createElement("span", { key: 1, className: "k-checkbox-wrap" }, /* @__PURE__ */ reactExports.createElement(
    "input",
    {
      id: S2,
      tabIndex: -1,
      type: "checkbox",
      className: "k-checkbox k-checkbox-md k-rounded-md",
      "aria-label": y4.toLanguageString(M2, z$1[M2]),
      "aria-checked": i16,
      checked: i16,
      onChange: I3
    }
  )), m3 = l7 !== "groupHeader" ? /* @__PURE__ */ reactExports.createElement(
    "td",
    {
      ...r12
    },
    d8
  ) : null, u5 = l7 || "data", t6 = N3;
  if (t6 && t6.select && t6.select[u5]) {
    const c6 = t6.select[u5];
    return /* @__PURE__ */ reactExports.createElement(c6, { ...a9, tdProps: r12 }, d8);
  }
  return n10 ? n10.call(void 0, m3, a9) : m3;
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const z2 = (e3) => {
  let i16 = null, l7 = null, r12 = null;
  const t6 = c$3(e3.field, e3.dataItem), c6 = c$6(e3.id), u5 = a$r(), f4 = reactExports.useCallback(
    (a9) => {
      a9.isDefaultPrevented() || a9.keyCode === e$B.enter && e3.onChange && (a9.preventDefault(), e3.onChange({
        dataItem: e3.dataItem,
        dataIndex: e3.dataIndex,
        syntheticEvent: a9,
        field: e3.field,
        value: !t6
      }));
    },
    [e3.dataItem, e3.dataIndex, e3.field, e3.onChange, t6]
  );
  if (e3.rowType === "groupFooter")
    l7 = {
      className: "k-table-td k-hierarchy-cell",
      role: "gridcell",
      ...c6
    }, i16 = /* @__PURE__ */ reactExports.createElement(
      "td",
      {
        ...l7
      }
    );
  else if (e3.rowType !== "groupHeader") {
    const a9 = t6 ? D : T2, g6 = u5.toLanguageString(a9, z$1[a9]);
    l7 = {
      className: "k-table-td k-hierarchy-cell",
      onKeyDown: f4,
      "aria-expanded": !!t6,
      role: "gridcell",
      "aria-colindex": e3.ariaColumnIndex,
      ...c6
    }, r12 = /* @__PURE__ */ reactExports.createElement(
      "a",
      {
        onClick: (m3) => {
          m3.preventDefault(), e3.onChange && e3.onChange({
            dataItem: e3.dataItem,
            dataIndex: e3.dataIndex,
            syntheticEvent: m3,
            field: e3.field,
            value: !t6
          });
        },
        "aria-label": g6,
        href: "#",
        tabIndex: -1
      },
      /* @__PURE__ */ reactExports.createElement(v$c, { name: t6 ? "minus" : "plus", icon: t6 ? minusIcon : plusIcon })
    ), i16 = /* @__PURE__ */ reactExports.createElement(
      "td",
      {
        ...l7
      },
      r12
    );
  }
  const o9 = e3.rowType || "data", d8 = e3.cells;
  if (d8 && d8.hierarchy && d8.hierarchy[o9]) {
    const a9 = d8.hierarchy[o9];
    return /* @__PURE__ */ reactExports.createElement(a9, { ...e3, tdProps: l7 }, r12);
  }
  return e3.render ? e3.render.call(void 0, i16, e3) : i16;
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const R$1 = E$3, N2 = T$4, L2 = /^(?!.*\bChrome).*\bSafari/i;
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const B = (e3) => {
  const i16 = c$3(e3.field, e3.dataItem), C2 = n$t(), h3 = C2 && C2.uGrid ? C2.uGrid : g$f;
  let d8 = null;
  const m3 = r$r(h3.editTd({ selected: e3.isSelected }), e3.className), s10 = m$m(), u5 = c$6(e3.id);
  let l7 = null, n10 = null;
  const f4 = reactExports.useCallback(
    (t6) => {
      if (e3.onChange) {
        const k3 = t6.target.type === "checkbox" ? t6.target.checked : t6.target.value;
        e3.onChange({
          dataItem: e3.dataItem,
          dataIndex: e3.dataIndex,
          field: e3.field,
          syntheticEvent: t6,
          value: k3
        });
      }
    },
    [e3.onChange, e3.dataItem, e3.dataIndex, e3.field]
  ), o9 = reactExports.useCallback((t6) => {
    e3.onContextMenu && e3.onContextMenu.call(void 0, t6, e3.dataItem, e3.field);
  }, [e3.onContextMenu, e3.dataItem, e3.field]), g6 = reactExports.useCallback(
    (t6) => {
      e3.onChange && e3.onChange({
        dataItem: e3.dataItem,
        dataIndex: e3.dataIndex,
        field: e3.field,
        syntheticEvent: t6.syntheticEvent,
        value: t6.value
      });
    },
    [e3.onChange, e3.dataItem, e3.dataIndex, e3.field]
  );
  switch (e3.editor) {
    case "numeric": {
      l7 = {
        onContextMenu: o9,
        colSpan: e3.colSpan,
        style: e3.style,
        className: m3,
        "aria-colindex": e3.ariaColumnIndex,
        "aria-selected": e3.isSelected,
        [N2]: e3.columnIndex,
        role: "gridcell",
        ...u5
      }, n10 = /* @__PURE__ */ reactExports.createElement(
        Ee$1,
        {
          value: i16 === void 0 ? null : i16,
          onChange: g6,
          [t$8]: true
        }
      ), d8 = /* @__PURE__ */ reactExports.createElement(
        "td",
        {
          ...l7
        },
        n10
      );
      break;
    }
    case "date":
      l7 = {
        onContextMenu: o9,
        colSpan: e3.colSpan,
        style: e3.style,
        className: m3,
        "aria-colindex": e3.ariaColumnIndex,
        "aria-selected": e3.isSelected,
        [N2]: e3.columnIndex,
        role: "gridcell",
        ...u5
      }, n10 = /* @__PURE__ */ reactExports.createElement(
        pe,
        {
          value: i16,
          onChange: g6,
          [t$8]: true
        }
      ), d8 = /* @__PURE__ */ reactExports.createElement(
        "td",
        {
          ...l7
        },
        n10
      );
      break;
    case "boolean":
      l7 = {
        onContextMenu: o9,
        colSpan: e3.colSpan,
        style: e3.style,
        className: m3,
        "aria-colindex": e3.ariaColumnIndex,
        "aria-selected": e3.isSelected,
        [N2]: e3.columnIndex,
        role: "gridcell",
        ...u5
      }, n10 = [
        /* @__PURE__ */ reactExports.createElement("span", { key: 1, className: "k-checkbox-wrap" }, /* @__PURE__ */ reactExports.createElement(
          "input",
          {
            checked: i16 || false,
            id: s10,
            type: "checkbox",
            className: "k-checkbox k-checkbox-md k-rounded-md",
            onChange: f4
          }
        )),
        /* @__PURE__ */ reactExports.createElement("label", { className: "k-checkbox-label", htmlFor: s10, key: 2 })
      ], d8 = /* @__PURE__ */ reactExports.createElement(
        "td",
        {
          ...l7
        },
        n10
      );
      break;
    default:
      l7 = {
        onContextMenu: o9,
        colSpan: e3.colSpan,
        style: e3.style,
        className: m3,
        "aria-colindex": e3.ariaColumnIndex,
        "aria-selected": e3.isSelected,
        [N2]: e3.columnIndex,
        role: "gridcell",
        ...u5
      }, n10 = /* @__PURE__ */ reactExports.createElement(
        "input",
        {
          style: { width: "100%" },
          className: "k-input",
          value: i16 || "",
          onChange: f4,
          [t$8]: true
        }
      ), d8 = /* @__PURE__ */ reactExports.createElement(
        "td",
        {
          ...l7
        },
        n10
      );
  }
  const r12 = e3.editor || "text", c6 = e3.cells;
  if (c6) {
    let t6;
    return c6.edit && c6.edit[r12] ? t6 = c6.edit[r12] : c6.data && (t6 = c6.data), /* @__PURE__ */ reactExports.createElement(t6, { ...e3, tdProps: l7 }, n10);
  }
  return e3.render ? e3.render.call(void 0, d8, e3) : d8;
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let d$2 = class d6 extends reactExports.Component {
  constructor() {
    super(...arguments), this.headerWrap = null, this.table = null, this.syncScroll = false, this.scrollbarWidth = s$r(), this.onScroll = (e3) => {
      if (this.syncScroll) {
        this.syncScroll = false;
        return;
      }
      if (!this.headerWrap)
        return;
      const l7 = this.headerWrap.scrollLeft, t6 = this.props.scrollableDataElement();
      t6 && t6.scrollLeft !== l7 && (t6.scrollLeft = l7);
    };
  }
  get element() {
    return this.props.elemRef.current;
  }
  componentDidMount() {
    const e3 = E$4(this.element);
    this.props.columnResize && this.props.columnResize.setIsRtl(e3), this.forceUpdate();
  }
  /**
   *
   * @param scrollLeft - Scrolls to the left (in pixels).
   */
  setScrollLeft(e3) {
    this.headerWrap && this.headerWrap.scrollLeft !== e3 && (this.syncScroll = true, this.headerWrap.scrollLeft = e3);
  }
  /**
   *
   * @param width - Scrolls the width (in pixels).
   */
  setWidth(e3) {
    this.table && (this.table.style.width = e3 + "px");
  }
  render() {
    const e3 = this.context && this.context.uGrid ? this.context.uGrid : g$f, { size: l7 = "md" } = this.props;
    return this.props.staticHeaders ? /* @__PURE__ */ reactExports.createElement(
      "div",
      {
        ref: this.props.elemRef,
        className: r$r(e3.header({ draggable: this.props.draggable }), this.props.className),
        role: "presentation"
      },
      /* @__PURE__ */ reactExports.createElement(
        "div",
        {
          ref: (t6) => {
            this.headerWrap = t6;
          },
          className: r$r(e3.headerWrap({})),
          style: this.props.hasScrollbarWidth ? {} : { borderWidth: 0 },
          onScroll: this.onScroll,
          role: "presentation"
        },
        /* @__PURE__ */ reactExports.createElement(
          "table",
          {
            ref: (t6) => {
              this.table = t6;
            },
            className: r$r(e3.headerTable({ size: l7 }), this.props.className),
            role: "presentation"
          },
          /* @__PURE__ */ reactExports.createElement("colgroup", { ref: (t6) => {
            this.props.columnResize.colGroupHeader = t6;
          } }, this.props.cols),
          /* @__PURE__ */ reactExports.createElement("thead", { className: r$r(e3.tableThead({})), role: "rowgroup", ...D$1 }, this.props.headerRow, this.props.filterRow)
        )
      )
    ) : /* @__PURE__ */ reactExports.createElement(
      "thead",
      {
        role: "presentation",
        className: r$r(e3.thead({ draggable: this.props.draggable }), this.props.className),
        ...D$1
      },
      this.props.headerRow,
      this.props.filterRow
    );
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const n$1 = (...e3) => Object.assign({ allowUnsort: true, mode: "single" }, ...e3);
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let i$3 = class i13 extends reactExports.PureComponent {
  constructor() {
    super(...arguments), this.draggable = null, this.onPress = (t6) => {
      const e3 = this.draggable && this.draggable.element;
      e3 && this.props.pressHandler && this.props.pressHandler(t6.event, e3);
    }, this.onDrag = (t6) => {
      const e3 = this.draggable && this.draggable.element;
      e3 && this.props.dragHandler && this.props.dragHandler(t6.event, e3);
    }, this.onRelease = (t6) => {
      this.draggable && this.draggable.element && this.props.releaseHandler && this.props.releaseHandler(t6.event);
    };
  }
  render() {
    const t6 = this.context && this.context.uGrid ? this.context.uGrid : g$f;
    return /* @__PURE__ */ reactExports.createElement(
      m$i,
      {
        onPress: this.onPress,
        onDrag: this.onDrag,
        onRelease: this.onRelease,
        hint: this.props.dragClue,
        autoScroll: { boundaryElementRef: this.props.headerRef, direction: { horizontal: true, vertical: false } },
        scrollContainer: this.props.containerRef || void 0,
        ref: (e3) => {
          this.draggable = e3;
        }
      },
      /* @__PURE__ */ reactExports.createElement("tr", { className: r$r(t6.simpleTr({})), style: { touchAction: "none" }, role: "row", "aria-rowindex": this.props.ariaRowIndex }, this.props.children)
    );
  }
};
i$3.contextType = e$y;
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const O$1 = [
  ".k-columnmenu-item-content",
  ".k-filter-menu-container"
].map((t6) => i$v.map(
  (u5) => `${t6} ${u5}`
)), G = [
  [".k-tabstrip-items"],
  [".k-columnmenu-item"],
  ...O$1
], Y = (t6) => {
  const [u5, a9] = reactExports.useState(false), l7 = reactExports.useRef(null), s10 = reactExports.useRef(null), r12 = reactExports.useRef(null), i16 = reactExports.useRef(0), { columnMenu: E2, ...p6 } = t6, { column: g6, columnMenuIcon: m3, navigatable: w3 } = t6, b2 = a$r(), M3 = g6.title || g6.field, C2 = M3 ? `${M3} ` : "", D2 = "#", y4 = (e3) => {
    const n10 = o$k(document);
    clearTimeout(i16.current), i16.current = window.setTimeout(() => {
      n10 && e3.relatedTarget !== l7.current && s10.current && !s10.current.contains(n10) && f4();
    });
  }, T3 = () => {
    clearTimeout(i16.current);
  }, S2 = (e3) => {
    e3.preventDefault(), u5 && t6.onCloseMenu && t6.onCloseMenu(), a9(!u5);
  }, f4 = () => {
    t6.onCloseMenu && t6.onCloseMenu(), a9(false), !t6.navigatable && l7.current && l7.current.focus();
  }, K3 = (e3) => {
    var n10;
    if (e3.keyCode === e$B.tab) {
      const c6 = e3.target, h3 = c6 && ((n10 = c6.closest(".k-grid")) == null ? void 0 : n10.getElementsByClassName("k-grid-content")[0]);
      h3 && h3.scrollWidth > h3.clientWidth && c6.scrollIntoView({ inline: "center" });
    }
  }, d8 = reactExports.useMemo(() => t6.show !== void 0 ? t6.show : u5, [t6.show, u5]), B2 = (e3) => {
    var n10;
    (n10 = r12.current) == null || n10.triggerKeyboardEvent(e3);
  }, I3 = (e3) => {
    var n10;
    (n10 = r12.current) == null || n10.triggerMouseEvent(e3);
  }, A2 = (e3, n10, c6) => {
    c6.preventDefault(), c6.shiftKey ? n10.focusPrevious(e3) : n10.focusNext(e3);
  }, N3 = (e3, n10, c6) => {
    e3 && e3.click();
  }, R2 = (e3, n10, c6) => {
    c6.preventDefault(), f4();
  }, $2 = (e3, n10, c6) => {
    c6.preventDefault(), n10.focusElement(e3);
  }, x3 = (e3) => {
    !e3.isAnchorClicked && a9(false);
  };
  return reactExports.useEffect(() => (d8 && s10.current && (r12.current = new l$m({
    tabIndex: 0,
    root: s10,
    selectors: G,
    keyboardEvents: {
      keydown: {
        Tab: A2,
        Enter: N3,
        Escape: R2
      }
    },
    mouseEvents: {
      mousedown: $2
    }
  }), r12.current.focusElement(r12.current.first, null)), () => {
    r12.current && (r12.current = null);
  }), [d8]), /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(
    "a",
    {
      className: "k-grid-header-menu k-grid-column-menu",
      ref: l7,
      onClick: S2,
      onKeyDown: K3,
      href: D2,
      tabIndex: w3 ? -1 : void 0,
      "aria-label": `${w3 ? "" : C2}${b2.toLanguageString(I$1, z$1[I$1])}`
    },
    m3 ? /* @__PURE__ */ reactExports.createElement(v$c, { name: m3.name, icon: m3 }) : /* @__PURE__ */ reactExports.createElement(v$c, { name: "more-vertical", icon: moreVerticalIcon })
  ), /* @__PURE__ */ reactExports.createElement(
    a$m,
    {
      anchor: l7.current,
      show: d8,
      popupClass: "k-column-menu k-column-menu-popup k-grid-columnmenu-popup",
      onMouseDownOutside: x3
    },
    /* @__PURE__ */ reactExports.createElement(
      "div",
      {
        ref: s10,
        onBlur: y4,
        onFocus: T3,
        onMouseDown: I3,
        onKeyDown: B2,
        style: { outline: "none" }
      },
      E2 && /* @__PURE__ */ reactExports.createElement(
        E2,
        {
          ...p6,
          onCloseMenu: f4
        }
      )
    )
  ));
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const C$1 = (e3) => {
  const l7 = n$t(), r12 = l7 && l7.uGrid ? l7.uGrid : g$f, { columnMenuWrapperProps: a9 } = e3, i16 = e3.onClick ? {
    onClick: e3.onClick
  } : {}, c6 = /* @__PURE__ */ reactExports.createElement("span", { className: r$r(r12.headerCellInner({})) }, /* @__PURE__ */ reactExports.createElement(
    "span",
    {
      className: r$r(
        r12.headerCellLink({
          sortable: e3.columnMenuWrapperProps.sortable
        })
      ),
      ...i16
    },
    /* @__PURE__ */ reactExports.createElement("span", { className: r$r(r12.columnTitle({})) }, e3.title || e3.field || ""),
    e3.children
  ), a9.columnMenu && /* @__PURE__ */ reactExports.createElement(Y, { ...a9 }));
  return e3.render ? e3.render.call(void 0, c6, e3) : c6;
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const $$1 = {
  true: { asc: "desc", desc: "", "": "asc" },
  false: { asc: "desc", desc: "asc", "": "asc" }
}, p$2 = {
  none: "none",
  asc: "ascending",
  desc: "descending"
}, ce = (e3) => {
  const [D2, R2] = reactExports.useState(), E2 = a$r(), C2 = n$t(), f4 = C2 && C2.uGrid ? C2.uGrid : g$f, m3 = reactExports.useRef(null);
  let x3 = 0, v3 = -1;
  const S2 = (t6, n10) => {
    if (t6.preventDefault(), !e3.sortChange)
      return;
    const { allowUnsort: l7, mode: s10 } = n$1(e3.sortable || false, n10.sortable || false), o9 = (e3.sort || []).filter((i16) => i16.field === n10.field)[0], d8 = $$1[l7][o9 && o9.dir || ""], c6 = s10 === "single" ? [] : (e3.sort || []).filter((i16) => i16.field !== n10.field);
    d8 !== "" && n10.field && c6.push({ field: n10.field, dir: d8 }), e3.sortChange(c6, t6);
  }, N3 = (t6, n10) => {
    if (t6.isDefaultPrevented())
      return;
    const { keyCode: l7, metaKey: s10, ctrlKey: o9, altKey: d8 } = t6, c6 = e3.sortable && n10.sortable, i16 = t6.target;
    if (c6 && t6.keyCode === e$B.enter && i16.className.indexOf("k-table-th") !== -1 && S2(t6, n10), e3.navigatable) {
      if (e3.groupable && (s10 && l7 === e$B.enter || o9 && l7 === e$B.space)) {
        t6.preventDefault();
        const h3 = e3.columns.findIndex((b2) => b2.field === n10.field);
        e3.columnGroupChange && e3.columnGroupChange(h3, t6);
      }
      d8 && l7 === e$B.down && (t6.preventDefault(), R2(n10.field), m3.current = i16);
    }
  }, G2 = () => {
    R2(void 0), m3.current && m3.current.getAttribute("tabindex") !== "-1" && m3.current.focus();
  }, K3 = (t6) => {
    if (!e3.sort)
      return null;
    const n10 = r$r(f4.sortIcon({}));
    return t6 >= 0 && [
      /* @__PURE__ */ reactExports.createElement("span", { key: 1, className: n10 }, /* @__PURE__ */ reactExports.createElement(
        v$c,
        {
          name: "sort-" + e3.sort[t6].dir + "-small",
          icon: e3.sort[t6].dir === "asc" ? sortAscSmallIcon : sortDescSmallIcon
        }
      )),
      e3.sort.length > 1 && /* @__PURE__ */ reactExports.createElement("span", { key: 2, className: n10 }, /* @__PURE__ */ reactExports.createElement("span", { className: r$r(f4.sortOrder({})) }, t6 + 1))
    ];
  }, I3 = (t6) => t6.map((n10) => {
    const l7 = e3.columns[n10], s10 = e3.sortable && l7.sortable, o9 = e3.sort ? e3.sort.findIndex((a9) => a9.field === l7.field) : -1, d8 = o9 >= 0 && e3.sort[o9].dir || "none", c6 = l7.columnMenu === null ? null : l7.columnMenu || e3.columnMenu, i16 = l7.menuIcon || e3.columnMenuIcon, h3 = r$r(
      r$r(f4.headerTh({
        first: l7.kFirst,
        filterable: !!c6,
        locked: l7.locked,
        sorted: e3.sort && e3.sort.some((a9) => a9.field === l7.field)
      })),
      l7.headerClassName
    );
    l7.locked === false && (l7.left = 0);
    const b2 = l7.left !== void 0 ? e3.isRtl ? { left: l7.right, right: l7.left } : { left: l7.left, right: l7.right } : {}, A2 = E2.toLanguageString(G$1, z$1[G$1]), F2 = l7.isAccessible ? {
      ariaSort: p$2[d8],
      role: "columnheader",
      ariaColumnIndex: l7.ariaColumnIndex,
      ariaSelected: false,
      ariaDescription: s10 ? A2 : ""
    } : {
      role: "presentation"
    }, k3 = l7.declarationIndex >= 0 ? ++v3 : --x3, L3 = l7.headerCell ? l7.headerCell : C$1, M3 = /* @__PURE__ */ reactExports.createElement(
      L3,
      {
        key: 1,
        field: l7.field,
        onClick: s10 && ((a9) => S2(a9, l7)) || void 0,
        selectionChange: e3.selectionChange,
        title: l7.title,
        selectionValue: l7.headerSelectionValue,
        render: e3.cellRender,
        children: K3(o9),
        columnMenuWrapperProps: {
          column: {
            field: l7.field,
            title: l7.title,
            locked: l7.locked,
            filter: l7.filter,
            id: l7.id
          },
          sortable: s10 && e3.sortable,
          sort: e3.sort,
          onSortChange: e3.sortChange,
          filter: e3.filter,
          filterable: e3.filterable && l7.filterable,
          filterOperators: e3.filterOperators,
          onFilterChange: e3.filterChange,
          show: D2 === l7.field ? true : void 0,
          onCloseMenu: G2,
          navigatable: e3.navigatable,
          group: e3.group,
          groupable: e3.groupable,
          onGroupChange: e3.groupChange,
          columnMenu: c6,
          columnMenuIcon: i16
        }
      }
    ), w3 = {
      ...F2,
      key: k3,
      colSpan: l7.colSpan,
      rowSpan: l7.rowSpan,
      className: h3,
      style: b2,
      columnId: l7.id,
      navigatable: l7.navigatable,
      onKeyDown: (a9) => N3(a9, l7),
      role: "columnheader"
    }, z3 = [
      M3,
      e3.columnResize && e3.columnResize.resizable && l7.resizable && /* @__PURE__ */ reactExports.createElement(
        n$9,
        {
          key: 2,
          resize: (a9, O2, P2) => e3.columnResize && e3.columnResize.dragHandler(a9, l7, O2, P2),
          autofit: (a9) => e3.columnResize && e3.columnResize.dblClickHandler(a9, [l7.id])
        }
      )
    ], y4 = N$2(e3.cells, l7.cells);
    if (y4 && y4.headerCell) {
      const a9 = y4.headerCell;
      return /* @__PURE__ */ reactExports.createElement(a9, { ...M3.props, key: k3, thProps: w3, index: n10 }, z3);
    }
    return /* @__PURE__ */ reactExports.createElement(
      p$5,
      {
        ...w3,
        key: k3
      },
      z3
    );
  });
  return e3.columnsMap.map((t6, n10) => e3.pressHandler && /* @__PURE__ */ reactExports.createElement(
    i$3,
    {
      key: n10,
      pressHandler: e3.pressHandler,
      dragHandler: e3.dragHandler,
      releaseHandler: e3.releaseHandler,
      ariaRowIndex: n10 + 1,
      dragClue: e3.dragClue,
      headerRef: e3.headerRef,
      containerRef: e3.containerRef
    },
    I3(t6)
  ) || /* @__PURE__ */ reactExports.createElement("tr", { key: n10, className: r$r(f4.simpletr({})), role: "row", "aria-rowindex": n10 + 1 }, I3(t6)));
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const g$3 = {
  text: [
    { text: "grid.filterContainsOperator", operator: "contains" },
    { text: "grid.filterNotContainsOperator", operator: "doesnotcontain" },
    { text: "grid.filterEqOperator", operator: "eq" },
    { text: "grid.filterNotEqOperator", operator: "neq" },
    { text: "grid.filterStartsWithOperator", operator: "startswith" },
    { text: "grid.filterEndsWithOperator", operator: "endswith" },
    { text: "grid.filterIsNullOperator", operator: "isnull" },
    { text: "grid.filterIsNotNullOperator", operator: "isnotnull" },
    { text: "grid.filterIsEmptyOperator", operator: "isempty" },
    { text: "grid.filterIsNotEmptyOperator", operator: "isnotempty" }
  ],
  numeric: [
    { text: "grid.filterEqOperator", operator: "eq" },
    { text: "grid.filterNotEqOperator", operator: "neq" },
    { text: "grid.filterGteOperator", operator: "gte" },
    { text: "grid.filterGtOperator", operator: "gt" },
    { text: "grid.filterLteOperator", operator: "lte" },
    { text: "grid.filterLtOperator", operator: "lt" },
    { text: "grid.filterIsNullOperator", operator: "isnull" },
    { text: "grid.filterIsNotNullOperator", operator: "isnotnull" }
  ],
  date: [
    { text: "grid.filterEqOperator", operator: "eq" },
    { text: "grid.filterNotEqOperator", operator: "neq" },
    { text: "grid.filterAfterOrEqualOperator", operator: "gte" },
    { text: "grid.filterAfterOperator", operator: "gt" },
    { text: "grid.filterBeforeOperator", operator: "lt" },
    { text: "grid.filterBeforeOrEqualOperator", operator: "lte" },
    { text: "grid.filterIsNullOperator", operator: "isnull" },
    { text: "grid.filterIsNotNullOperator", operator: "isnotnull" }
  ],
  boolean: [
    { text: "grid.filterEqOperator", operator: "eq" }
  ]
}, i$2 = (t6) => t6 === "isnull" || t6 === "isnotnull" || t6 === "isempty" || t6 === "isnotempty", d$1 = (t6, o9) => t6.map((e3) => ({
  text: o9.toLanguageString(e3.text, z$1[e3.text]),
  operator: e3.operator
})), n9 = "eq", u$2 = [
  { text: "grid.filterBooleanAll", operator: "" },
  { text: "grid.filterIsTrue", operator: true },
  { text: "grid.filterIsFalse", operator: false }
], c$1 = (t6, o9, e3) => {
  const a9 = p$1(e3.operators);
  let r12 = e3.operator;
  switch (e3.filterType) {
    case "numeric":
      (!r12 || i$2(r12)) && (r12 = a9), t6 === null && r12 === a9 && (r12 = "");
      break;
    case "date":
      (!r12 || i$2(r12)) && (r12 = a9), t6 === null && r12 === a9 && (r12 = "");
      break;
    case "text":
      (!r12 || i$2(r12)) && (r12 = a9), !t6 && r12 === a9 && (r12 = "");
      break;
    default:
      return;
  }
  e3.onChange({ value: t6, operator: r12, syntheticEvent: o9 });
}, p$1 = (t6, o9) => o9 ? t6[o9][0].operator : t6[0].operator, O = (t6) => t6 || "text", q = (t6, o9) => {
  const e3 = t6.target.value;
  o9({
    value: e3.operator,
    operator: e3.operator === "" ? "" : n9,
    syntheticEvent: t6.syntheticEvent
  });
}, E = (t6, o9, e3) => {
  let a9 = o9;
  const r12 = t6.target.value;
  t6.target.state.opened && (i$2(r12.operator) && (a9 = null), o9 === null && !i$2(r12.operator) && (a9 = void 0), e3({ value: a9, operator: r12.operator, syntheticEvent: t6.syntheticEvent }));
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
class R extends reactExports.Component {
  constructor(r12) {
    super(r12), this._inputRef = reactExports.createRef(), this.renderOperatorEditor = (i16) => {
      if (this.props.filterType === "boolean")
        return;
      let s10;
      const e3 = this.props.operators.find((t6) => t6.operator === this.props.operator) || null;
      return /* @__PURE__ */ reactExports.createElement(
        Ee,
        {
          ref: (t6) => s10 = t6,
          size: this.props.size,
          value: e3,
          onChange: this.operatorChange,
          className: "k-dropdown-operator",
          iconClassName: "k-i-filter k-icon",
          svgIcon: filterIcon,
          data: this.props.operators,
          textField: "text",
          title: i16.toLanguageString(B$1, z$1[B$1]),
          popupSettings: {
            width: "",
            onMouseDownOutside: function(t6) {
              !t6.isAnchorClicked && t6.state && t6.state.props.show && s10 && s10.togglePopup();
            }
          }
        }
      );
    }, this.inputChange = this.inputChange.bind(this), this.clear = this.clear.bind(this), this.operatorChange = this.operatorChange.bind(this), this.boolDropdownChange = this.boolDropdownChange.bind(this);
  }
  /**
   * @hidden
   */
  render() {
    const r12 = s$k(this), i16 = /* @__PURE__ */ reactExports.createElement("div", { className: "k-filtercell" }, /* @__PURE__ */ reactExports.createElement("div", { className: "k-filtercell-wrapper" }, this.filterComponent(this.props.filterType, this.props.value, this.props.booleanValues), /* @__PURE__ */ reactExports.createElement("div", { className: "k-filtercell-operator" }, this.renderOperatorEditor(r12), "", /* @__PURE__ */ reactExports.createElement(
      p$j,
      {
        size: this.props.size,
        icon: "filter-clear",
        svgIcon: filterClearIcon,
        className: r$r({
          "k-clear-button-visible": !!(!(this.props.value === null || this.props.value === "") || this.props.operator)
        }),
        title: r12.toLanguageString(h$1, z$1[h$1]),
        type: "button",
        onClick: this.clear,
        disabled: !(!(this.props.value === null || this.props.value === "") || this.props.operator)
      }
    ))));
    return this.props.render ? this.props.render.call(void 0, i16, this.props) : i16;
  }
  inputChange(r12, i16) {
    c$1(r12, i16, this.props);
  }
  operatorChange(r12) {
    E(r12, this.props.value, this.props.onChange);
  }
  boolDropdownChange(r12) {
    q(r12, this.props.onChange);
  }
  clear(r12) {
    r12.preventDefault(), this.props.onChange({ value: "", operator: "", syntheticEvent: r12 }), this._inputRef.current && (this._inputRef.current.element.value = "", setTimeout(() => {
      this._inputRef.current.element.focus();
    }, 0));
  }
  filterComponent(r12, i16, s10) {
    switch (r12) {
      case "numeric":
        return /* @__PURE__ */ reactExports.createElement(
          Ee$1,
          {
            ref: this._inputRef,
            size: this.props.size,
            value: i16,
            onChange: (e3) => {
              this.inputChange(e3.value, e3.syntheticEvent);
            },
            title: this.props.title,
            ariaLabel: this.props.ariaLabel
          }
        );
      case "date":
        return /* @__PURE__ */ reactExports.createElement(
          pe,
          {
            ref: this._inputRef,
            size: this.props.size,
            value: i16,
            onChange: (e3) => {
              this.inputChange(e3.value, e3.syntheticEvent);
            },
            title: this.props.title,
            ariaLabel: this.props.ariaLabel,
            popupSettings: {
              onMouseDownOutside: (e3) => {
                !e3.isAnchorClicked && e3.state && e3.state.props.show && this._inputRef && this._inputRef.current.togglePopup();
              }
            }
          }
        );
      case "boolean": {
        const e3 = (t6) => t6 == null;
        return /* @__PURE__ */ reactExports.createElement(
          Ee,
          {
            ref: this._inputRef,
            size: this.props.size,
            onChange: this.boolDropdownChange,
            value: s10.find((t6) => t6.operator === (e3(i16) ? "" : i16)),
            data: s10,
            textField: "text",
            title: this.props.title,
            ariaLabel: this.props.ariaLabel,
            popupSettings: {
              onMouseDownOutside: (t6) => {
                !t6.isAnchorClicked && t6.state && t6.state.props.show && this._inputRef && this._inputRef.current.togglePopup();
              }
            }
          }
        );
      }
      default:
        return /* @__PURE__ */ reactExports.createElement(
          B$3,
          {
            ref: this._inputRef,
            size: this.props.size,
            value: i16 || "",
            onChange: (e3) => {
              this.inputChange(e3.target.value, e3.syntheticEvent);
            },
            title: this.props.title,
            "aria-label": this.props.ariaLabel
          }
        );
    }
  }
}
v$a(R);
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const A = "k-table-row k-filter-row";
class S extends reactExports.Component {
  headerCellClassName(r12, o9) {
    let l7 = `${o9 ? "k-grid-header-sticky" : ""}`;
    return this.props.sort && this.props.sort.filter((n10) => n10.field === r12).length > 0 && (l7 += " k-sorted"), l7;
  }
  setFilter(r12, o9, l7, n10) {
    if (!this.props.filterChange)
      return;
    const s10 = [];
    (r12 !== "" && r12 !== null || o9 !== "") && s10.push({
      field: l7,
      operator: o9,
      value: r12
    }), this.props.filter && this.props.filter.filters && (this.props.filter.filters || []).forEach((i16) => {
      const t6 = i16;
      t6 && t6.field !== l7 && s10.push(t6);
    });
    const h3 = this.props.filter && this.props.filter.logic ? this.props.filter.logic : "and";
    this.props.filterChange(s10.length > 0 ? { logic: h3, filters: s10 } : null, n10);
  }
  render() {
    const r12 = s$k(this), o9 = this.props.filter && this.props.filter.filters || [], l7 = (e3) => {
      if (e3 === void 0)
        return;
      const i16 = o9.filter((t6) => t6.field === e3);
      return i16.length ? i16[0] : void 0;
    };
    let n10 = 0, s10 = -1;
    const h3 = this.props.columns.filter((e3) => e3.children.length === 0).map(
      (e3) => {
        const i16 = O(e3.filter), t6 = l7(e3.field), g6 = e3.filterable ? r12.toLanguageString(N$1, z$1[N$1]) : void 0;
        let d8 = t6 && t6.value;
        d8 === void 0 && (d8 = i16 === "text" ? "" : null);
        const f4 = e3.filterable && {
          render: this.props.cellRender,
          field: e3.field,
          title: e3.filterTitle,
          value: d8,
          operator: t6 && t6.operator,
          operators: d$1(this.props.filterOperators[i16] || [], r12),
          booleanValues: d$1(u$2, r12),
          filterType: i16,
          ariaLabel: g6,
          onChange: (p6) => {
            this.setFilter(p6.value, p6.operator, e3.field, p6.syntheticEvent);
          }
        }, C2 = e3.declarationIndex >= 0 ? ++s10 : --n10, x3 = {
          ariaLabel: g6,
          ariaColumnIndex: e3.ariaColumnIndex
        }, E2 = e3.left !== void 0 ? this.props.isRtl ? { left: e3.right, right: e3.left } : { left: e3.left, right: e3.right } : {}, m3 = {
          columnId: ue.getFilterColumnId(e3.id),
          navigatable: e3.navigatable || this.props.navigatable,
          style: E2,
          className: r$r("k-table-th", this.headerCellClassName(e3.field, e3.locked) || void 0),
          role: "columnheader",
          ...x3
        }, v3 = f4 && (e3.filterCell ? /* @__PURE__ */ reactExports.createElement(e3.filterCell, { ...f4 }) : /* @__PURE__ */ reactExports.createElement(R, { size: this.props.size, ...f4 })), c6 = N$2(this.props.cells, e3.cells);
        if (c6 && c6.filterCell) {
          const p6 = c6.filterCell;
          return /* @__PURE__ */ reactExports.createElement(p6, { key: C2, ...f4, thProps: m3, index: s10 }, v3);
        }
        return /* @__PURE__ */ reactExports.createElement(
          p$5,
          {
            key: C2,
            ...m3
          },
          v3
        );
      }
    );
    return /* @__PURE__ */ reactExports.createElement("tr", { className: A, "aria-rowindex": this.props.ariaRowIndex, role: "row" }, h3);
  }
}
v$a(S);
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
class c5 extends reactExports.Component {
  constructor() {
    super(...arguments), this.draggable = null, this.onPress = (e3) => {
      const t6 = this.draggable && this.draggable.element;
      t6 && this.props.onPress && this.props.onPress(e3.event, t6);
    }, this.onDrag = (e3) => {
      const t6 = this.draggable && this.draggable.element;
      t6 && this.props.onDrag && this.props.onDrag(e3.event, t6);
    }, this.onRelease = (e3) => {
      this.draggable && this.draggable.element && this.props.onRelease && this.props.onRelease(e3.event);
    }, this.sortChange = (e3) => {
      if (e3.preventDefault(), this.props.onSortChange) {
        const t6 = this.props.dir === "asc" ? "desc" : "asc";
        this.props.onSortChange(e3, t6);
      }
    }, this.handleKeyDown = (e3) => {
      (e3.keyCode === e$B.delete || e3.keyCode === e$B.backspace) && (e3.preventDefault(), e3.stopPropagation(), this.props.onRemove && this.props.onRemove(e3));
    }, this.groupRemove = (e3) => {
      e3.preventDefault(), e3.stopPropagation(), this.props.onRemove && this.props.onRemove(e3);
    }, this.onContextMenu = (e3) => {
      const t6 = {
        title: this.props.title,
        dir: this.props.dir,
        index: this.props.index
      };
      this.props.onContextMenu && this.props.onContextMenu.call(void 0, e3, { dataItem: { ...t6 } });
    };
  }
  render() {
    const { dir: e3 } = this.props;
    return /* @__PURE__ */ reactExports.createElement(
      m$i,
      {
        onPress: this.onPress,
        onDrag: this.onDrag,
        onRelease: this.onRelease,
        ref: (t6) => {
          this.draggable = t6;
        }
      },
      /* @__PURE__ */ reactExports.createElement(
        "div",
        {
          className: "k-chip k-chip-md k-chip-solid k-chip-solid-base k-rounded-md",
          onClick: this.sortChange,
          onContextMenu: this.onContextMenu,
          onKeyDown: this.handleKeyDown,
          tabIndex: 0,
          role: "button",
          style: { touchAction: "none" }
        },
        /* @__PURE__ */ reactExports.createElement("span", null, /* @__PURE__ */ reactExports.createElement(
          v$c,
          {
            name: "sort-" + e3 + "-small",
            icon: e3 === "asc" ? sortAscSmallIcon : sortDescSmallIcon,
            size: "small"
          }
        )),
        /* @__PURE__ */ reactExports.createElement("span", { className: "k-chip-content" }, this.props.title),
        /* @__PURE__ */ reactExports.createElement("span", { className: "k-chip-actions" }, /* @__PURE__ */ reactExports.createElement(
          "span",
          {
            className: "k-chip-action k-chip-remove-action",
            onClick: this.groupRemove
          },
          /* @__PURE__ */ reactExports.createElement(
            v$c,
            {
              name: "x-circle",
              icon: xCircleIcon,
              size: "small"
            }
          )
        ))
      )
    );
  }
}
v$a(c5);
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
class h2 extends reactExports.Component {
  constructor() {
    super(...arguments), this.onGroupRemove = (p6, r12) => {
      const o9 = this.props.group.slice();
      o9.splice(r12, 1), this.props.groupChange(o9, p6);
    }, this.onGroupSortChange = (p6, r12, o9, e3) => {
      const s10 = Object.assign({}, o9, { dir: e3 }), n10 = this.props.group.slice();
      n10.splice(r12, 1, s10), this.props.groupChange(n10, p6);
    };
  }
  render() {
    const r12 = (this.props.group || []).map((o9, e3) => /* @__PURE__ */ reactExports.createElement(
      c5,
      {
        key: e3,
        index: e3,
        dir: o9.dir || "asc",
        title: this.props.resolveTitle(o9.field),
        onRemove: (s10) => {
          this.onGroupRemove(s10, e3);
        },
        onSortChange: (s10, n10) => {
          this.onGroupSortChange(s10, e3, o9, n10);
        },
        onPress: this.props.pressHandler,
        onDrag: this.props.dragHandler,
        onRelease: this.props.releaseHandler,
        onContextMenu: this.props.onContextMenu
      }
    ));
    return /* @__PURE__ */ reactExports.createElement(
      "div",
      {
        ref: this.props.refCallback,
        className: "k-grouping-header",
        role: "toolbar",
        "aria-label": s$k(this).toLanguageString(R$2, z$1[R$2]),
        "aria-controls": this.props.ariaControls || ""
      },
      /* @__PURE__ */ reactExports.createElement("div", { className: "k-chip-list k-chip-list-md", role: "none" }, r12),
      /* @__PURE__ */ reactExports.createElement("div", { className: "k-grouping-drop-container" }, !r12.length && s$k(this).toLanguageString(f3, z$1[f3]), "")
    );
  }
}
v$a(h2);
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let i$1 = class i14 extends reactExports.Component {
  constructor() {
    super(...arguments), this.footerWrap = null, this.table = null;
  }
  componentDidMount() {
    this.setState({});
  }
  /**
   *
   * @param scrollLeft - Scrolls to the left (in pixels).
   */
  setScrollLeft(e3) {
    this.footerWrap && (this.footerWrap.scrollLeft = e3);
  }
  /**
   *
   * @param width - Scrolls the width (in pixels).
   */
  setWidth(e3) {
    this.table && (this.table.style.width = e3 + "px");
  }
  render() {
    return this.props.staticHeaders ? /* @__PURE__ */ reactExports.createElement(
      "div",
      {
        className: "k-grid-footer",
        role: "presentation"
      },
      /* @__PURE__ */ reactExports.createElement(
        "div",
        {
          ref: (e3) => {
            this.footerWrap = e3;
          },
          className: "k-grid-footer-wrap",
          style: this.props.hasScrollbarWidth ? {} : { borderWidth: 0 },
          role: "presentation"
        },
        /* @__PURE__ */ reactExports.createElement(
          "table",
          {
            ref: (e3) => {
              this.table = e3;
            },
            className: r$r(
              "k-table k-grid-footer-table",
              {
                "k-table-md": !this.props.size,
                [`k-table-${e$v.sizeMap[this.props.size] || this.props.size}`]: this.props.size
              },
              this.props.className
            ),
            role: "presentation"
          },
          /* @__PURE__ */ reactExports.createElement("colgroup", { ref: (e3) => {
            this.props.columnResize.colGroupFooter = e3;
          }, role: "presentation" }, this.props.cols),
          /* @__PURE__ */ reactExports.createElement("tfoot", { className: "k-table-tfoot", role: "presentation" }, this.props.row)
        )
      )
    ) : /* @__PURE__ */ reactExports.createElement("tfoot", { className: "k-table-tfoot" }, this.props.row);
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let g$2 = class g3 {
  constructor(s10) {
    this.table = null, this.containerHeight = 0, this.topCacheCount = 0, this.attendedSkip = 0, this.propsSkip = 0, this.total = 0, this.scrollableVirtual = false, this.realSkip = 0, this.pageSize = 0, this.PageChange = null, this.tableBodyRef = reactExports.createRef(), this.fixedScroll = false, this.askedSkip = void 0, this.containerRef = reactExports.createRef(), this.tableTransform = "", this.prevScrollPos = 0, this.tableTranslate = 0, this.scrollSyncing = false, this.reactVersion = Number.parseFloat(reactExports.version), this.topItems = (t6, l7) => {
      if (!this.container || l7)
        return { topItemsCount: 0, topItemsHeight: 0 };
      const i16 = this.container.clientHeight, e3 = Math.ceil(i16 / t6[0].line), n10 = Math.ceil((t6.length - e3) / 2);
      let o9 = 0;
      for (let a9 = 0; a9 < n10; a9++)
        o9 += t6[a9].line + t6[a9].acc;
      return {
        topItemsCount: n10,
        topItemsHeight: o9,
        itemsNeededOnScreen: e3 + e3 / 2
      };
    }, this.horizontalScrollbarHeight = () => this.container ? this.container.offsetHeight - this.container.clientHeight : 0, s10 && (this.topCacheCount = 4, this.attendedSkip = -this.topCacheCount), this.scrollHandler = this.scrollHandler.bind(this);
  }
  get container() {
    return this.containerRef.current;
  }
  /**
   * @return - The row heights in an array.
   */
  get rowHeights() {
    const s10 = [], t6 = this.tableBodyRef.current && this.tableBodyRef.current.children || [];
    let l7 = 0;
    for (let i16 = 0; i16 < t6.length; i16++) {
      if (t6[i16].className.indexOf("k-grouping-row") > -1) {
        l7 += t6[i16].scrollHeight;
        continue;
      }
      t6[i16].className.indexOf("k-detail-row") > -1 ? s10[s10.length - 1].line += t6[i16].scrollHeight : (s10.push({
        line: t6[i16].scrollHeight,
        acc: l7
      }), l7 = 0);
    }
    return s10;
  }
  changePage(s10, t6) {
    this.attendedSkip = s10 - this.topCacheCount, this.PageChange && this.PageChange(
      {
        skip: Math.max(0, s10 - this.topCacheCount),
        take: this.pageSize
      },
      t6
    );
  }
  translate(s10, t6) {
    this.tableTranslate = s10, this.scrollableVirtual && this.table && (this.reactVersion <= 17 || t6 ? this.table.style.transform = "translateY(" + s10 + "px)" : this.tableTransform = "translateY(" + s10 + "px)");
  }
  reset() {
    this.scrollSyncing = true, !this.fixedScroll && (this.container && (this.container.scrollTop = 0), this.translate(0, true));
  }
  localScrollUp(s10) {
    if (!this.container)
      return;
    const t6 = this.rowHeights, l7 = this.container.scrollTop;
    let i16 = this.tableTranslate, e3 = 0;
    const {
      topItemsCount: n10,
      topItemsHeight: o9,
      itemsNeededOnScreen: a9
    } = this.topItems(t6, !!this.topCacheCount), h3 = l7 - i16;
    if (!(h3 > o9 || t6.length <= a9)) {
      for (; e3 < this.topCacheCount + this.attendedSkip - this.realSkip + n10 && this.propsSkip - e3 > 0 && !(i16 + (t6[t6.length - 1 - e3].line + t6[t6.length - 1 - e3].acc) + h3 <= l7); )
        i16 -= t6[t6.length - 1 - e3].line + t6[t6.length - 1 - e3].acc, e3++;
      if (e3 === 0 && this.topCacheCount === 0 && this.attendedSkip > 0 && (i16 = Math.max(i16 - t6[0].line, 0), e3 = 1), this.propsSkip - e3 <= 0 && i16 > l7) {
        this.translate(0), this.changePage(0, s10), this.container.scrollTop = 0;
        return;
      }
      if (i16 > l7 && (i16 = l7), i16 !== this.tableTranslate) {
        this.translate(Math.max(0, i16 - o9));
        const c6 = Math.max(0, this.propsSkip - e3 - n10);
        this.changePage(c6, s10);
      }
    }
  }
  localScrollDown(s10) {
    if (!this.container)
      return;
    const t6 = this.rowHeights, l7 = this.container.scrollTop;
    let i16 = this.tableTranslate, e3 = 0;
    const {
      topItemsCount: n10,
      topItemsHeight: o9,
      itemsNeededOnScreen: a9
    } = this.topItems(t6, !!this.topCacheCount);
    for (; e3 < t6.length - this.topCacheCount && !(i16 + t6[e3].line + t6[e3].acc > l7); )
      i16 += t6[e3].line + t6[e3].acc, e3++;
    n10 > this.propsSkip + e3 || t6.length <= a9 || (e3 >= t6.length - this.topCacheCount && this.propsSkip + e3 >= this.total ? (this.translate(i16 - o9), this.changePage(this.total - 1 - n10, s10)) : i16 !== this.tableTranslate && this.propsSkip + e3 - n10 !== this.propsSkip && (this.translate(i16 - o9), this.changePage(this.propsSkip + e3 - n10, s10)));
  }
  scrollNonStrict(s10) {
    const t6 = this.total * this.prevScrollPos / this.containerHeight;
    let l7 = Math.floor(t6);
    l7 >= this.total && (l7 = this.total - 1);
    const i16 = Math.min(t6 - l7, 1);
    let e3 = 0;
    const n10 = l7 - this.propsSkip, o9 = this.rowHeights;
    n10 >= 0 && n10 <= 1 ? e3 = -((o9[0].line + o9[0].acc) * i16) : n10 === -1 && (e3 = -((o9[o9.length - 1].line + o9[o9.length - 1].acc) * i16));
    const { topItemsCount: a9, topItemsHeight: h3 } = this.topItems(o9, !!this.topCacheCount);
    this.translate(Math.max(0, e3 - h3 - this.horizontalScrollbarHeight() + this.containerHeight * t6 / this.total)), this.changePage(l7 - a9, s10);
  }
  scrollHandler(s10) {
    if (!this.scrollableVirtual)
      return;
    if (this.scrollSyncing || !this.container || !this.table) {
      this.scrollSyncing = false;
      return;
    }
    const t6 = this.container.scrollTop, l7 = this.prevScrollPos;
    if (this.prevScrollPos = t6, this.askedSkip !== void 0) {
      this.translate(this.containerHeight * this.askedSkip / this.total), this.changePage(this.askedSkip, s10), this.prevScrollPos = t6, this.askedSkip = void 0;
      return;
    }
    t6 - l7 < 0 && t6 > this.tableTranslate - this.table.scrollHeight / 10 ? this.localScrollUp(s10) : t6 - l7 > 0 && t6 < this.tableTranslate + this.table.scrollHeight * 2 / 3 ? this.localScrollDown(s10) : this.scrollNonStrict(s10), this.prevScrollPos = t6;
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
class p5 {
  constructor(t6) {
    this.table = null, this.containerHeight = 0, this.topCacheCount = 0, this.attendedSkip = 0, this.propsSkip = 0, this.total = 0, this.scrollableVirtual = false, this.realSkip = 0, this.pageSize = 0, this.PageChange = null, this.tableBodyRef = reactExports.createRef(), this.fixedScroll = false, this.askedSkip = void 0, this.containerRef = reactExports.createRef(), this.tableTransform = "", this.scrollSyncing = false, this.lastLoaded = 0, this.firstLoaded = 0, this.lastScrollTop = 0, this.reactVersion = Number.parseFloat(reactExports.version), this.firstLoaded = this.pageSize, this.lastLoaded = this.realSkip + this.pageSize, this.scrollHandler = this.scrollHandler.bind(this);
  }
  get container() {
    return this.containerRef.current;
  }
  translate(t6, i16) {
    this.scrollableVirtual && this.table && (M$1 || this.reactVersion <= 17 || i16 ? this.table.style.transform = "translateY(" + t6 + "px)" : this.tableTransform = "translateY(" + t6 + "px)");
  }
  changePage(t6, i16) {
    this.PageChange && this.PageChange({ skip: Math.max(0, t6), take: this.pageSize }, i16);
  }
  reset() {
    this.scrollSyncing = true, !this.fixedScroll && (this.container && (this.container.scrollTop = 0), this.translate(0, true));
  }
  scrollHandler(t6) {
    if (!this.scrollableVirtual || !this.container || !this.table || !this.rowHeightService || !this.containerRef.current)
      return;
    if (this.scrollSyncing) {
      this.scrollSyncing = false;
      return;
    }
    const i16 = this.container.scrollTop, r12 = this.lastScrollTop >= i16, o9 = !r12;
    this.lastScrollTop = i16;
    let e3 = this.rowHeightService.index(i16), h3 = this.rowHeightService.offset(e3);
    const { offsetHeight: l7 } = this.containerRef.current, n10 = this.rowHeightService.index(i16 + l7);
    if (o9 && n10 >= this.lastLoaded && this.lastLoaded < this.total) {
      const s10 = e3 + this.pageSize - this.total;
      s10 > 0 && (e3 = e3 - s10, h3 = this.rowHeightService.offset(e3)), this.firstLoaded = e3, this.translate(h3);
      const c6 = this.firstLoaded + this.pageSize;
      this.lastLoaded = Math.min(c6, this.total), this.changePage(this.firstLoaded, t6);
    } else if (r12 && e3 < this.firstLoaded) {
      const s10 = Math.floor(this.pageSize * 0.3);
      this.firstLoaded = Math.max(e3 - s10, 0), this.translate(this.rowHeightService.offset(this.firstLoaded)), this.lastLoaded = Math.min(this.firstLoaded + this.pageSize, this.total), this.changePage(this.firstLoaded, t6);
    }
  }
}
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let u$1 = class u3 {
  constructor(f4) {
    this.columns = [], this.resizable = false, this.isRtl = false, this.setIsRtl = (c6) => {
      this.isRtl = c6;
    }, this.dragHandler = (c6, l7, e3, h3) => {
      const t6 = c6.originalEvent;
      h3 || (t6.preventDefault(), t6.stopPropagation(), t6.stopImmediatePropagation());
      const o9 = e3.closest("th");
      if (!o9 || !o9)
        return;
      const s10 = o9.clientWidth;
      let n10 = s10;
      if (this.isRtl ? n10 += e3.getBoundingClientRect().right - e3.offsetWidth / 2 - c6.clientX : n10 += c6.clientX - e3.getBoundingClientRect().left - e3.offsetWidth / 2, !h3 && Math.abs(n10 - s10) < 1)
        return;
      this.fixateInitialWidths(o9.parentElement.clientWidth), this.setWidths(l7, Math.floor(n10) / s10);
      const d8 = this.columns.filter((i16) => !i16.children.length).findIndex((i16) => i16.id === l7.id);
      this.onResize(d8, s10, n10, t6, h3, l7.id);
    }, this.dblClickHandler = (c6, l7) => {
      const e3 = this.columns.filter((r12) => l7.indexOf(r12.id) > -1);
      if (!this.colGroupMain || !e3.length)
        return;
      const h3 = {}, t6 = e3;
      for (; t6.length > 0; ) {
        const r12 = t6.pop();
        if (!r12)
          break;
        r12.children.length ? t6.push(...r12.children) : h3[r12.id] = r12;
      }
      const o9 = this.columns.filter((r12) => !r12.children.length), s10 = [];
      o9.forEach((r12, a9) => {
        h3[r12.id] && s10.push(a9);
      });
      const n10 = [this.colGroupMain.parentElement], d8 = [this.colGroupMain];
      this.colGroupHeader && (n10.push(this.colGroupHeader.parentElement), d8.push(this.colGroupHeader)), this.colGroupFooter && (n10.push(this.colGroupFooter.parentElement), d8.push(this.colGroupFooter)), n10.forEach((r12) => r12.classList.add("k-autofitting"));
      let i16 = [];
      d8.forEach((r12) => {
        s10.forEach((a9) => {
          r12.children[a9] && (r12.children[a9].width = "", i16[a9] = Math.max(i16[a9] || 0, r12.children[a9].offsetWidth + 1));
        });
      }), d8.forEach((r12) => {
        s10.forEach((a9) => {
          r12.children[a9] && (r12.children[a9].width = i16[a9] + "px", o9[a9].width = i16[a9]);
        });
      }), n10.forEach((r12) => r12.classList.remove("k-autofitting")), this.onResize(s10[0], 0, 0, c6, true, l7[0]);
    }, this.updateColElements = (c6) => {
      const l7 = this.columns.filter((h3) => !h3.children.length);
      let e3 = 1e-10;
      for (let h3 = 0; h3 < c6.length; h3++) {
        const t6 = c6[h3], o9 = l7.findIndex((i16) => i16.id === t6.id), s10 = parseFloat((t6.width || 0).toString()), n10 = Math.floor(s10);
        e3 += s10 - n10;
        const d8 = n10 + Math.floor(e3);
        if (e3 -= Math.floor(e3), this.colGroupMain && this.colGroupMain.children[o9]) {
          const i16 = parseInt(this.colGroupMain.children[o9].width, 10);
          this.colGroupMain.children[o9].width = d8 + "px", this.updateNextLockedCol(
            this.colGroupMain.parentElement,
            t6,
            i16 - d8
          );
        }
        if (this.colGroupHeader && this.colGroupHeader.children[o9]) {
          const i16 = parseInt(this.colGroupHeader.children[o9].width, 10);
          this.colGroupHeader.children[o9].width = d8 + "px", this.updateNextLockedCol(
            this.colGroupHeader.parentElement,
            t6,
            i16 - d8
          );
        }
        if (this.colGroupFooter && this.colGroupFooter.children[o9]) {
          const i16 = parseInt(this.colGroupFooter.children[o9].width, 10);
          this.colGroupFooter.children[o9].width = d8 + "px", this.updateNextLockedCol(
            this.colGroupFooter.parentElement,
            t6,
            i16 - d8
          );
        }
      }
    }, this.onResize = f4;
  }
  fixateInitialWidths(f4) {
    const c6 = this.columns.filter((t6) => !t6.children.length);
    let l7 = 0, e3 = this.colGroupMain ? this.colGroupMain.children : [];
    for (let t6 = 0; t6 < e3.length; t6++)
      e3[t6].width ? f4 -= parseFloat(e3[t6].width) : l7++;
    if (l7 === 0)
      return;
    const h3 = Math.floor(f4 / l7);
    for (let t6 = 0; t6 < e3.length; t6++) {
      const o9 = e3[t6];
      o9.width || (o9.width = h3, c6[t6].width = h3.toString(), this.colGroupHeader && (this.colGroupHeader.children[t6].width = h3), this.colGroupFooter && (this.colGroupFooter.children[t6].width = h3));
    }
  }
  setWidths(f4, c6) {
    const l7 = this.columns.findIndex((t6) => t6.id === f4.id), e3 = [];
    let h3 = f4.children.length;
    for (let t6 = l7 + 1; h3 > 0 && t6 < this.columns.length; t6++, h3--) {
      const o9 = this.columns[t6];
      o9.children.length ? h3 += o9.children.length : e3.push(o9);
    }
    return e3.length === 0 && e3.push(f4), e3.forEach((t6) => {
      let o9 = t6.width ? parseFloat(t6.width.toString()) * c6 : 0;
      const s10 = t6.minResizableWidth === void 0 ? 10 : t6.minResizableWidth;
      o9 < s10 && (o9 = s10), t6.width = o9;
    }), this.updateColElements(e3), e3;
  }
  updateNextLockedCol(f4, c6, l7) {
    const e3 = c6.index, h3 = this.colGroupMain.parentElement.closest(".k-grid"), t6 = h3 == null ? void 0 : h3.clientWidth, o9 = this.columns.filter((s10) => s10.locked).map((s10) => parseInt(s10.width + "", 10)).reduce((s10, n10) => s10 + n10, 0);
    !c6.locked || t6 <= o9 + 20 || this.columns.forEach((s10) => {
      if (s10 != null && s10.locked && l7) {
        const n10 = f4 == null ? void 0 : f4.querySelectorAll('[aria-colindex="' + s10.ariaColumnIndex + '"]');
        n10 == null || n10.forEach((d8) => {
          const i16 = d8.style;
          this.isRtl ? (s10.index > e3 && i16 && i16.right && (i16.right = parseInt(i16.right, 10) - l7 + "px"), s10.index < e3 && i16 && i16.left && (i16.left = parseInt(i16.left, 10) - l7 + "px")) : (s10.index > e3 && i16 && i16.left && (i16.left = parseInt(i16.left, 10) - l7 + "px"), s10.index < e3 && i16 && i16.right && (i16.right = parseInt(i16.right, 10) - l7 + "px"));
        });
      }
    });
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
let g$1 = class g4 {
  constructor(e3, i16, n10) {
    this.refDragElementClue = reactExports.createRef(), this.refDropElementClue = reactExports.createRef(), this.columns = [], this.reorderable = false, this.groupable = false, this.startColumn = -1, this.startGroup = -1, this.currentColumn = -1, this.currentGroup = -1, this.groupPanelDivElement = null, this.refGroupPanelDiv = (t6) => {
      this.groupPanelDivElement = t6 && t6.children ? t6.children[0] : t6;
    }, this.pressHandler = (t6, r12) => {
      const s10 = this.getColumnIndex(t6, r12);
      if (this.startGroup = this.getGroupIndex(t6), s10 >= 0) {
        const u5 = this.columns[s10];
        (u5.reorderable && this.reorderable || u5.groupable && this.groupable) && (this.startColumn = s10);
      }
    }, this.dragHandler = (t6, r12) => {
      if (t6.isTouch || t6.originalEvent.preventDefault(), t6.originalEvent.stopPropagation(), this.startColumn === -1 && this.startGroup === -1)
        return;
      this.currentColumn = this.getColumnIndex(t6, r12), this.currentGroup = this.isTargetGroupingContainer(t6) ? this.getCurrentGroupsLength : this.getGroupIndex(t6);
      const s10 = !this.isValid();
      s10 && (this.currentColumn = -1, this.currentGroup = -1);
      const u5 = this.currentColumn >= 0 ? r12.children[this.columns[this.currentColumn].index] : this.isTargetGroupingContainer(t6) ? t6.originalEvent.target : this.groupPanelDivElement && this.groupPanelDivElement.children[this.currentGroup];
      this.updateDragElementClue(t6, r12, u5, s10), this.updateDropElementClue(t6, r12, u5, s10);
    }, this.releaseHandler = (t6) => {
      const r12 = this.startColumn, s10 = this.currentColumn, u5 = this.startGroup, l7 = this.currentGroup;
      t6.originalEvent.preventDefault(), this.dropElementClue && this.dropElementClue.setState({ visible: false }), this.dragElementClue && this.dragElementClue.setState({ visible: false });
      const o9 = this.isValid();
      this.startColumn = this.startGroup = this.currentColumn = this.currentGroup = -1, o9 && (r12 >= 0 && s10 >= 0 ? this.columnReorder(r12, s10, t6.originalEvent) : u5 >= 0 && l7 >= 0 ? this.groupReorder(u5, l7, t6.originalEvent) : r12 >= 0 && l7 >= 0 && this.columnToGroup(r12, l7, t6.originalEvent));
    }, this.columnReorder = e3, this.groupReorder = i16, this.columnToGroup = n10;
  }
  get dragClueRef() {
    return this.refDragElementClue;
  }
  get dropClueRef() {
    return this.refDropElementClue;
  }
  get getCurrentGroupsLength() {
    const e3 = this.groupPanelDivElement && this.groupPanelDivElement.children;
    return e3 && e3.length || 0;
  }
  get dragElementClue() {
    return this.refDragElementClue.current;
  }
  get dropElementClue() {
    return this.refDropElementClue.current;
  }
  getColumnIndex(e3, i16) {
    if (!i16 || i16.parentElement === this.groupPanelDivElement)
      return -1;
    const n10 = k$6(e3, i16);
    if (n10 === -1)
      return -1;
    for (let t6 = 0; t6 < i16.parentNode.children.length; t6++)
      if (i16.parentNode.children[t6] === i16)
        return this.columns.findIndex((r12) => r12.index === n10 && r12.depth === t6);
    return -1;
  }
  isTargetGroupingContainer(e3) {
    const i16 = e3.originalEvent.target;
    return i16.className.indexOf ? i16.className.indexOf("k-grouping-drop-container") !== -1 : false;
  }
  getGroupIndex(e3) {
    return k$6(e3, this.groupPanelDivElement);
  }
  isValid() {
    return this.startGroup >= 0 ? this.currentGroup >= 0 && this.currentGroup !== this.startGroup : this.startColumn === -1 ? false : this.currentGroup >= 0 ? this.columns[this.startColumn].groupable === true && this.groupable === true : this.reorderable === true && this.currentColumn >= 0 && this.currentColumn !== this.startColumn && this.columns[this.startColumn].reorderable === true && this.columns[this.currentColumn].parentIndex === this.columns[this.startColumn].parentIndex;
  }
  updateDragElementClue(e3, i16, n10, t6) {
    if (!this.dragElementClue)
      return;
    const r12 = this.startColumn >= 0 ? i16.children[this.columns[this.startColumn].index].innerText : i16.innerText;
    this.dragElementClue.setState({
      visible: true,
      top: e3.pageY + 10,
      left: e3.pageX,
      innerText: r12,
      status: t6 || !n10 ? "k-i-cancel" : "k-i-plus"
    });
  }
  updateDropElementClue(e3, i16, n10, t6) {
    if (!this.dropElementClue)
      return;
    if (t6 || !n10) {
      this.dropElementClue.setState({ visible: false });
      return;
    }
    const r12 = n10.getBoundingClientRect(), u5 = (n10.closest(".k-grouping-header") || n10).getBoundingClientRect();
    let l7 = r12.left + e3.pageX - e3.clientX - 6;
    !this.isTargetGroupingContainer(e3) && (this.currentColumn > this.startColumn || this.currentGroup > this.startGroup && this.startGroup !== -1) && (l7 += r12.width);
    const o9 = u5.top + e3.pageY - e3.clientY;
    this.dropElementClue.setState({
      visible: true,
      top: o9,
      left: l7,
      height: this.currentColumn >= 0 ? i16.clientHeight : u5.height
    });
  }
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const w2 = (e3) => {
  let n10 = null;
  const f4 = e$s(), d8 = n$t(), s10 = d8 && d8.uGrid ? d8.uGrid : g$f, m3 = c$6(e3.id), u5 = reactExports.useCallback((l7) => {
    e3.onContextMenu && e3.onContextMenu.call(void 0, l7, e3.dataItem, e3.field);
  }, [e3.onContextMenu, e3.dataItem, e3.field]);
  let t6 = null, c6 = null;
  if (e3.rowType === "groupFooter")
    t6 = {
      onContextMenu: u5,
      className: e3.className,
      ...m3
    }, n10 = /* @__PURE__ */ reactExports.createElement("td", { ...t6 });
  else if (e3.rowType !== "groupHeader") {
    if (e3.field !== void 0) {
      const a9 = c$3(e3.field, e3.dataItem);
      a9 != null && (c6 = e3.format ? f4.format(e3.format, a9) : a9.toString());
    }
    const l7 = r$r(
      s10.td({ selected: e3.isSelected, sorted: e3.isSorted, alt: e3.isAlt }),
      e3.className
    );
    t6 = {
      onContextMenu: u5,
      colSpan: e3.colSpan,
      style: e3.style,
      className: l7,
      role: "gridcell",
      "aria-colindex": e3.ariaColumnIndex,
      "aria-selected": e3.isSelected,
      [N2]: e3.columnIndex,
      ...m3
    }, n10 = /* @__PURE__ */ reactExports.createElement("td", { ...t6 }, c6);
  }
  const r12 = e3.rowType || "data", o9 = e3.cells;
  if (o9 && o9[r12]) {
    const l7 = o9[r12];
    return /* @__PURE__ */ reactExports.createElement(l7, { ...e3, tdProps: t6 }, c6);
  }
  return e3.render ? e3.render.call(void 0, n10, e3) : n10;
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const V2 = (e3) => {
  let c6 = null;
  const { columnIndex: a9, level: s10, columnsCount: m3, rowType: w3, dataItem: n10, field: D2, onChange: r12, expanded: o9, render: C2, dataIndex: f4, ariaColumnIndex: N3, isRtl: v3 } = e3, d8 = D2 || "", x3 = c$6(e3.id), S2 = a$r();
  let i16 = null, g6 = null, y4 = null;
  const M3 = reactExports.useCallback(
    (l7) => {
      l7.isDefaultPrevented() || l7.keyCode === e$B.enter && r12 && (l7.preventDefault(), r12({
        dataItem: n10,
        dataIndex: f4,
        syntheticEvent: l7,
        field: void 0,
        value: !o9
      }));
    },
    [o9, r12, n10, f4]
  ), k3 = reactExports.useCallback((l7) => {
    e3.onContextMenu && e3.onContextMenu.call(void 0, l7, e3.dataItem, e3.field);
  }, [e3.onContextMenu, e3.dataItem, e3.field]), b2 = (l7, R2) => {
    const E2 = o9 ? F : w$1, A2 = S2.toLanguageString(E2, z$1[E2]);
    return i16 = {
      className: "k-table-td",
      style: { ...e3.style, ...R2 },
      colSpan: l7,
      key: "g-colspan",
      role: "gridcell",
      "aria-selected": false,
      "aria-expanded": o9,
      "aria-colindex": N3,
      onKeyDown: M3,
      onContextMenu: k3,
      ...x3
    }, y4 = /* @__PURE__ */ reactExports.createElement("p", { className: "k-reset" }, /* @__PURE__ */ reactExports.createElement(
      "a",
      {
        onClick: (h3) => {
          h3.preventDefault(), r12 && r12({
            dataItem: n10,
            dataIndex: f4,
            syntheticEvent: h3,
            field: void 0,
            value: !o9
          });
        },
        href: "#",
        tabIndex: -1,
        "aria-label": A2
      },
      /* @__PURE__ */ reactExports.createElement(
        v$c,
        {
          name: o9 ? "caret-alt-down" : v3 ? "caret-alt-left" : "caret-alt-right",
          icon: o9 ? caretAltDownIcon : v3 ? caretAltLeftIcon : caretAltRightIcon
        }
      )
    ), n10[d8] instanceof Date && n10[d8].toString ? n10[d8].toString() : n10[d8]), /* @__PURE__ */ reactExports.createElement(
      "td",
      {
        ...i16,
        key: i16.key
      },
      y4
    );
  };
  a9 === void 0 || s10 === void 0 || a9 < s10 || m3 === void 0 || w3 !== "groupHeader" || n10[d8] === void 0 ? (i16 = {
    style: e3.style,
    key: "g" + a9,
    className: r$r(
      "k-table-td",
      "k-group-cell",
      { "k-grid-content-sticky": e3.locked }
    ),
    role: "gridcell",
    onContextMenu: k3,
    ...x3
  }, c6 = /* @__PURE__ */ reactExports.createElement(
    "td",
    {
      ...i16,
      key: i16.key
    }
  )) : a9 <= s10 && !e3.locked ? c6 = b2(m3 - a9, {}) : a9 <= s10 && e3.locked && (g6 = {
    className: "k-table-td",
    role: "gridcell",
    colSpan: m3 - a9,
    style: { borderLeftWidth: 0, borderRightWidth: 0 },
    onContextMenu: k3
  }, c6 = /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, b2(0, { position: "sticky", zIndex: 2 }), /* @__PURE__ */ reactExports.createElement(
    "td",
    {
      ...g6
    }
  )));
  const I3 = e3.rowType || "data", u5 = e3.cells;
  if (u5 && u5.group && u5.group[I3]) {
    const l7 = u5.group[I3];
    return /* @__PURE__ */ reactExports.createElement(l7, { ...e3, tdProps: i16, td2Props: g6 }, y4);
  }
  return C2 ? C2.call(void 0, c6, e3) : c6;
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const x2 = (e3) => {
  const { rowType: i16, isAltRow: o9, isInEdit: n10, isSelected: r12 } = e3, t6 = n$t(), l7 = t6 && t6.uGrid ? t6.uGrid : g$f, a9 = r$r(l7.tr({
    selected: r12,
    isHeader: i16 === "groupHeader",
    isFooter: i16 === "groupFooter",
    isMaster: i16 !== "groupHeader" && i16 !== "groupFooter",
    isAltRow: o9,
    isInEdit: n10
  })), d8 = /* @__PURE__ */ reactExports.createElement(
    "tr",
    {
      id: e3.id,
      onClick: e3.onClick,
      onDoubleClick: e3.onDoubleClick,
      className: a9,
      style: {
        height: e3.rowHeight ? e3.rowHeight + "px" : "",
        visibility: e3.isHidden ? "hidden" : ""
      },
      role: "row",
      "aria-rowindex": e3.ariaRowIndex,
      "absolute-row-index": e3.absoluteRowIndex,
      key: e3.absoluteRowIndex,
      [R$1]: e3.rowType === "data" ? e3.dataIndex : void 0
    },
    e3.children
  );
  return e3.render ? e3.render.call(void 0, d8, e3) : d8;
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
class i15 extends reactExports.Component {
  get _inputId() {
    return this.props.id;
  }
  render() {
    const n10 = s$k(this), { columnMenuWrapperProps: t6 } = this.props, r12 = [
      /* @__PURE__ */ reactExports.createElement("span", { key: 0, className: "k-checkbox-wrap" }, /* @__PURE__ */ reactExports.createElement(
        "input",
        {
          id: this._inputId,
          type: "checkbox",
          tabIndex: -1,
          className: "k-checkbox k-checkbox-md k-rounded-md",
          "aria-label": n10.toLanguageString(M2, z$1[M2]),
          "aria-checked": this.props.selectionValue,
          checked: this.props.selectionValue,
          onChange: (s10) => this.props.selectionChange({
            field: this.props.field,
            syntheticEvent: s10
          })
        }
      )),
      t6.columnMenu && /* @__PURE__ */ reactExports.createElement(Y, { ...t6 })
    ];
    return this.props.render ? this.props.render.call(void 0, r12, this.props) : r12;
  }
}
v$a(i15);
const C = m$l(l$o(i15));
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const t$1 = class t4 extends reactExports.Component {
  /**
   * @hidden
   */
  render() {
    return this.props.children || s$k(this).toLanguageString(o8, z$1[o8]);
  }
};
t$1.displayName = "KendoReactGridNoRecords";
let e$2 = t$1;
v$a(e$2);
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const k2 = (t6) => {
  const { column: e3, index: l7, isRtl: r12, id: c6, cells: s10 } = t6, d8 = c$6(c6), a9 = {
    colSpan: e3.colSpan !== 1 ? e3.colSpan : void 0,
    style: e3.left !== void 0 ? r12 ? { left: e3.right, right: e3.left } : { left: e3.left, right: e3.right } : {},
    className: r$r(
      "k-table-td",
      e3.locked && e3.left !== void 0 ? "k-grid-footer-sticky" : ""
    ),
    key: l7,
    role: "gridcell",
    "aria-colindex": e3.ariaColumnIndex,
    ...d8
  }, n10 = {
    field: e3.field,
    ariaColumnIndex: e3.ariaColumnIndex,
    ...a9
  }, i16 = N$2(s10, e3.cells);
  if (i16 && i16.footerCell) {
    const m3 = i16.footerCell;
    return /* @__PURE__ */ reactExports.createElement(m3, { ...n10, tdProps: a9, index: l7 });
  }
  return e3.footerCell && /* @__PURE__ */ reactExports.createElement(e3.footerCell, { ...n10, key: l7 }) || /* @__PURE__ */ reactExports.createElement("td", { ...a9 });
}, I2 = (t6) => /* @__PURE__ */ reactExports.createElement("tr", { className: "k-table-row", role: "row", "aria-rowindex": t6.ariaRowIndex }, S$2(t6.columns).map((e3, l7) => {
  const r12 = ue.generateNavigatableId(`${l7}-footercell`, t6.idPrefix, "nodata");
  return /* @__PURE__ */ reactExports.createElement(
    k2,
    {
      key: r12,
      column: e3,
      id: r12,
      index: l7,
      cells: t6.cells,
      isRtl: t6.isRtl
    }
  );
}));
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const s9 = ({
  buttonCount: e3 = 10,
  info: o9 = true,
  type: r12 = "numeric",
  pageSizes: i16 = void 0,
  previousNext: t6 = true,
  responsive: a9 = void 0,
  navigatable: l7 = void 0,
  pageSizeValue: n10 = void 0
}) => ({
  buttonCount: e3,
  info: o9,
  pageSizes: i16 === true ? [5, 10, 20] : i16 || void 0,
  previousNext: t6,
  responsive: a9 !== false,
  navigatable: l7 !== false,
  type: r12,
  pageSizeValue: n10
}), u4 = (e3) => s9(e3 === true ? {} : e3);
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const e$1 = {
  name: "@progress/kendo-react-grid",
  productName: "KendoReact",
  productCodes: ["KENDOUIREACT", "KENDOUICOMPLETE"],
  publishDate: 1728906711,
  version: "",
  licensingDocsUrl: "https://www.telerik.com/kendo-react-ui/components/my-license/"
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const g5 = (e3) => {
  const { colSpan: n10, ariaColIndex: i16, dataItem: l7, dataIndex: o9, id: d8 } = e3, c6 = c$6(d8), t6 = n$t(), r12 = t6 && t6.uGrid ? t6.uGrid : g$f, s10 = reactExports.useCallback((u5) => {
    e3.onContextMenu && e3.onContextMenu.call(void 0, u5, e3.dataItem);
  }, [e3.onContextMenu, e3.dataItem]);
  return /* @__PURE__ */ reactExports.createElement(
    "td",
    {
      onContextMenu: s10,
      className: r$r(r12.detailTd({})),
      colSpan: n10,
      "aria-colindex": i16,
      role: "gridcell",
      ...c6
    },
    /* @__PURE__ */ reactExports.createElement(e3.detail, { dataItem: l7, dataIndex: o9 })
  );
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const d7 = (a9) => {
  const e3 = n$t(), r12 = e3 && e3.uGrid ? e3.uGrid : g$f;
  return /* @__PURE__ */ reactExports.createElement("td", { className: r$r(r12.hierarchyTd({})), role: "gridcell" });
};
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const H = class H2 extends reactExports.Component {
  constructor(a9) {
    super(a9), this._columns = [], this._columnsMap = [[]], this._columnsMutations = 0, this._resized = false, this._focusFirst = false, this._singleEditRow = false, this._shouldUpdateLeftRight = true, this._scrollbarWidth = void 0, this.contextStateRef = { current: void 0 }, this.navigationStateRef = { current: void 0 }, this._data = [], this._slicedData = void 0, this.wrapperScrollTop = 0, this.showLicenseWatermark = false, this.headerRef = reactExports.createRef(), this.headerElementRef = reactExports.createRef(), this._element = null, this.tableElement = null, this.containerRef = reactExports.createRef(), this.tableBodyRef = reactExports.createRef(), this._footer = null, this.forceUpdateTimeout = void 0, this.isRtl = false, this.headTable = null, this.rowsInEdit = [], this.observer = null, this.handleIntersection = (e3) => {
      const t6 = { rowIndex: this.rowIndex };
      e3.forEach((s10) => {
        s10.isIntersecting || this.setCurrentOnTop(t6);
      });
    }, this.setCurrentOnTop = (e3) => {
      if (!this.vs.container || this.props.scrollable === "none")
        return;
      this.observer && this.observer.disconnect();
      const { rowIndex: t6 } = e3;
      if (this.props.scrollable === "virtual")
        this.vs.askedSkip = t6, this.vs.container.scroll(
          0,
          Math.round(this.vs.askedSkip / this.vs.total * this.vs.container.scrollHeight)
        );
      else if (this.element) {
        const s10 = t6 < 1 ? this.element.querySelector("tbody > tr:nth-child(1)") : this.element.querySelector(`tbody > tr:nth-child(${t6 + 1})`);
        s10 && this.containerRef.current && (this.containerRef.current.scrollTop = s10.offsetTop);
      }
    }, this.scrollIntoView = (e3) => {
      if (!this.vs.container || this.props.scrollable === "none")
        return;
      this.rowIndex = e3.rowIndex;
      const { rowIndex: t6 } = e3, s10 = this.element;
      if (this.observer && s10) {
        this.observer.disconnect();
        const l7 = s10.querySelector(`[absolute-row-index="${t6}"]`);
        l7 ? this.observer.observe(l7) : this.setCurrentOnTop(e3);
      }
    }, this.fitColumns = (e3) => {
      this.columnResize.dblClickHandler(null, e3);
    }, this.getColumnsEssentialProps = (e3) => JSON.stringify(e3.map((t6) => ({ id: t6.id, field: t6.field, title: t6.title, children: t6.children }))), this.checkMatchMediaColumnsDifferece = () => {
      const e3 = this.childrenToArray(this.props.children);
      return this.getColumnsEssentialProps(e3) === this.getColumnsEssentialProps(this._columns);
    }, this.onContextMenu = (e3, t6, s10) => {
      if (this.props.onContextMenu) {
        const l7 = {
          target: this,
          syntheticEvent: e3,
          nativeEvent: e3.nativeEvent,
          dataItem: t6,
          field: s10
        };
        this.props.onContextMenu.call(void 0, l7);
      }
    }, this.getVirtualScroll = (e3) => {
      const { rowHeight: t6, detailRowHeight: s10, detail: l7, expandField: d8, groupable: p$12 } = e3, h3 = this.isAllData(), g6 = t6 !== void 0 && t6 > 0, v3 = s10 !== void 0 && s10 > 0, z3 = p$12 === true || typeof p$12 == "object" && p$12.enabled !== false;
      return !g6 || z3 && !h3 || !!(l7 && d8) && (!v3 || !h3) ? g$2 : p5;
    }, this.isAllData = () => {
      const { data: e3, total: t6 } = this.props;
      return Array.isArray(e3) ? e3.length === t6 : e3 ? t6 === e3.total : false;
    }, this.initializeVirtualization = (e3, t6) => {
      if (this.reInitVirtualization(
        this.props.scrollable === "virtual",
        this.props.total,
        this.props.filter,
        this.props.group,
        this.props.sort,
        t6 || this.props.rowHeight === void 0 || this.props.rowHeight === 0
      ), this.vs.fixedScroll = this.props.fixedScroll || false, this.vs.PageChange = this.pageChange, this.vs.realSkip = this.props.skip || 0, this.vs.pageSize = (this.props.take !== void 0 ? this.props.take : this.props.pageSize) || 0, this.vs.scrollableVirtual = this.props.scrollable === "virtual", this.vs.total = e3, this.vs.propsSkip = (this.props.skip || 0) + (this.props.scrollable === "virtual" ? this.vs.topCacheCount + (this.vs.attendedSkip - (this.props.skip || 0)) : 0), this.props.rowHeight !== void 0 && this.props.rowHeight > 0 && !t6) {
        const s10 = this.props.rowHeight * e3;
        this.vs.containerHeight = M$1 ? Math.min(A$2, s10) : s10;
      } else
        this.vs.containerHeight = 1533915;
      if (this.vs.containerRef = this.containerRef, this.vs.tableBodyRef = this.tableBodyRef, this.vs.table = this.tableElement, this._slicedData = void 0, this.vs instanceof p5) {
        const { rowHeight: s10 = 0, detail: l7, expandField: d8 } = this.props;
        let { detailRowHeight: p6 = 0 } = this.props;
        p6 = l7 && d8 ? p6 : s10, this.isAllData() ? (this.vs.total = this._data.length, this._slicedData = this._data.slice(this.vs.realSkip, this.vs.realSkip + this.vs.pageSize), this.vs.rowHeightService = this.rowHeightService(
          this.vs,
          this._data.length,
          s10,
          p6,
          this._data
        )) : this.vs.rowHeightService = new g$h(e3, s10, p6);
        const h3 = this.vs.rowHeightService.totalHeight();
        this.vs.containerHeight = M$1 ? Math.min(A$2, h3) : h3;
      }
    }, this.getCachedScrollbarWidth = () => (this._scrollbarWidth || (this._scrollbarWidth = s$r() || void 0), this._scrollbarWidth), this.scrollHandler = (e3) => {
      if (e3.target !== e3.currentTarget)
        return;
      clearTimeout(this.forceUpdateTimeout), this.vs.table = this.tableElement;
      const t6 = e3.currentTarget.scrollLeft, s10 = e3.currentTarget.scrollTop;
      this.props.columnVirtualization && (!this.vs.scrollableVirtual || s10 === this.wrapperScrollTop) && (this.forceUpdateTimeout = window.setTimeout(() => {
        this.forceUpdate();
      }, 0)), this._header && this._header.setScrollLeft(t6), this._footer && this._footer.setScrollLeft(t6), this.vs && s10 !== this.wrapperScrollTop && this.vs.scrollHandler(e3), c$o(this.props.onScroll, e3, this, void 0), this.wrapperScrollTop = s10;
    }, this.onKeyDown = (e3) => {
      if (le$1.onKeyDown(e3, {
        navigatable: this.props.navigatable || false,
        contextStateRef: this.contextStateRef,
        navigationStateRef: this.navigationStateRef,
        onNavigationAction: this.onNavigationAction,
        columns: this.columns
      }), this.props.onKeyDown) {
        const { mode: t6, cell: s10 } = P$6(this.props.selectable), l7 = {
          dataItems: this.getLeafDataItems(),
          mode: t6,
          cell: s10,
          componentId: this._gridId,
          selectedField: this.props.selectedField,
          ...this.getArguments(e3)
        };
        this.props.onKeyDown.call(void 0, l7);
      }
    }, this.onFocus = (e3) => {
      le$1.onFocus(e3, {
        navigatable: !!this.props.navigatable,
        contextStateRef: this.contextStateRef
      });
    }, this.onNavigationAction = (e3) => {
      if (e3.action === "moveToNextPage" && this.moveToNextPage(e3.event), e3.action === "moveToPrevPage" && this.moveToPrevPage(e3.event), e3.focusElement && e3.action === "reorderToRight") {
        const t6 = parseInt(e3.focusElement.ariaColIndex, 10) - 1;
        t6 < this._columns.length - 1 && this.columnReorder(t6, t6 + 1, e3.event);
      }
      if (e3.focusElement && e3.action === "reorderToLeft") {
        const t6 = parseInt(e3.focusElement.ariaColIndex, 10) - 1;
        t6 > 0 && this.columnReorder(t6, t6 - 1, e3.event);
      }
      if (this.props.onNavigationAction) {
        const t6 = {
          focusElement: e3.focusElement,
          ...this.getArguments(e3.event)
        };
        this.props.onNavigationAction.call(void 0, t6);
      }
    }, this.rowClick = (e3, t6) => {
      this.props.onRowClick && e3.target.nodeName === "TD" && this.props.onRowClick.call(void 0, {
        dataItem: t6.dataItem,
        ...this.getArguments(e3)
      });
    }, this.rowDblClick = (e3, t6) => {
      this.props.onRowDoubleClick && e3.target.nodeName === "TD" && this.props.onRowDoubleClick.call(void 0, {
        dataItem: t6.dataItem,
        ...this.getArguments(e3)
      });
    }, this.itemChange = (e3) => {
      const t6 = this.props.onItemChange;
      if (e3.field === this.props.expandField || this.props.group && e3.field === void 0) {
        const s10 = this.props.onExpandChange;
        s10 && s10.call(void 0, {
          ...this.getArguments(e3.syntheticEvent),
          dataItem: e3.dataItem,
          dataIndex: e3.dataIndex,
          value: e3.value
        });
        return;
      }
      t6 && t6.call(void 0, {
        ...this.getArguments(e3.syntheticEvent),
        dataItem: e3.dataItem,
        dataIndex: e3.dataIndex,
        field: e3.field,
        value: e3.value
      });
    }, this.onHeaderSelectionChange = (e3) => {
      this.props.onHeaderSelectionChange && this.props.onHeaderSelectionChange.call(void 0, {
        field: e3.field,
        nativeEvent: e3.syntheticEvent && e3.syntheticEvent.nativeEvent,
        syntheticEvent: e3.syntheticEvent,
        target: this,
        dataItems: this.getLeafDataItems(),
        selectedField: this.props.selectedField
      });
    }, this.selectionRelease = (e3) => {
      if (this.props.onSelectionChange) {
        const t6 = this.getSlicedLeafDataItems()[e3.startRowIndex], s10 = this.getSlicedLeafDataItems()[e3.endRowIndex], l7 = {
          syntheticEvent: void 0,
          target: this,
          selectedField: this.props.selectedField || "",
          componentId: this._gridId,
          dataItems: this.getLeafDataItems(),
          dataItem: null,
          startDataItem: t6,
          endDataItem: s10,
          ...e3
        };
        this.props.onSelectionChange.call(void 0, l7);
      }
    }, this.pageChange = (e3, t6, s10) => {
      this.raiseDataEvent(
        this.props.onPageChange,
        { page: e3 },
        { skip: e3.skip, take: e3.take },
        t6,
        s10
      );
    }, this.getTotal = () => {
      let e3 = this.props.total || 0;
      return Array.isArray(this.props.data) ? e3 = e3 || this.props.data.length : this.props.data && (e3 = e3 || this.props.data.total), e3;
    }, this.moveToNextPage = (e3) => {
      const t6 = this.props.take || 0, s10 = (this.props.skip || 0) + t6, l7 = this.getTotal();
      s10 < l7 && this.pageChange({ skip: s10, take: t6 }, e3);
    }, this.moveToPrevPage = (e3) => {
      const t6 = this.props.take || 0, s10 = (this.props.skip || 0) - t6;
      s10 >= 0 && this.pageChange({ skip: s10, take: t6 }, e3);
    }, this.pagerPageChange = (e3) => {
      this.pageChange({ skip: e3.skip, take: e3.take }, e3.syntheticEvent, e3.targetEvent);
    }, this.sortChange = (e3, t6) => {
      this.raiseDataEvent(
        this.props.onSortChange,
        { sort: e3 },
        { sort: e3, ...this.props.scrollable === "virtual" ? { skip: 0 } : {} },
        t6
      );
    }, this.filterChange = (e3, t6) => {
      this.raiseDataEvent(
        this.props.onFilterChange,
        { filter: e3 },
        { filter: e3 || void 0, skip: 0 },
        t6
      );
    }, this.groupChange = (e3, t6) => {
      const s10 = t6.nativeEvent ? t6 : { nativeEvent: t6.nativeEvent || t6.originalEvent };
      e3.length === 0 && this.props.navigatable && (this._focusFirst = true), this._columnsMutations++, this.raiseDataEvent(
        this.props.onGroupChange,
        { group: e3 },
        { group: e3, skip: 0 },
        s10
      );
    }, this.onClipboard = (e3, t6) => {
      if (this.props.onClipboard) {
        if (!this.inActiveElement() || !e3)
          return;
        this.props.onClipboard.call(void 0, {
          type: e3,
          nativeEvent: t6,
          columns: this._columns,
          dataItemKey: this.props.dataItemKey || "",
          ...typeof this.props.clipboard != "boolean" ? this.props.clipboard : {}
        });
      }
    }, this.inActiveElement = () => {
      var d8, p6, h3;
      if (!e$C)
        return false;
      const e3 = o$k(this.document), t6 = e3 ? e3.matches(".k-table-td") ? e3 : (d8 = this.document) == null ? void 0 : d8.body : (p6 = this.document) == null ? void 0 : p6.body, s10 = t6.closest(".k-grid-container"), l7 = t6 && ((h3 = this._element) == null ? void 0 : h3.contains(t6));
      return !!(t6 && l7 && s10);
    }, this.onResize = (e3, t6, s10, l7, d8, p6) => {
      this.resetTableWidth(), this._shouldUpdateLeftRight = true, this._resized = true, this._columnsMutations++, this.props.onColumnResize && this.props.onColumnResize.call(void 0, {
        columns: this.columns,
        nativeEvent: l7,
        targetColumnId: p6,
        index: e3,
        newWidth: t6,
        oldWidth: s10,
        end: d8,
        target: this
      });
    }, this.reInitVirtualization = s$n(
      (e3, t6, s10, l7, d8, p6) => {
        this.vs.reset();
        const h3 = this.getVirtualScroll(this.props);
        this.vs = new h3(p6);
      }
    ), this.flatData = s$n((e3, t6, s10, l7, d8, p6, h3) => {
      const g6 = [], v3 = p$4(
        g6,
        e3,
        t6,
        { index: s10 },
        l7 !== void 0,
        d8
      );
      return { flattedData: g6, resolvedGroupsCount: v3 };
    }), this.rowHeightService = s$n(
      (e3, t6, s10, l7, d8) => new g$h(t6, s10, l7, d8)
    ), this.childrenToArray = s$n((e3) => reactExports.Children.toArray(e3)), this.readColumns = s$n((e3, t6, s10) => {
      const l7 = e3.filter(
        (d8) => d8 && d8.type && d8.type.displayName === "KendoReactGridColumn"
      );
      return I$2(l7, this.columns, { prevId: 0, idPrefix: t6 });
    }), this.mapColumns = s$n((e3, t6) => I$5(e3, true)), this.filterColumnsByMediaProp = (e3) => e3.filter((t6) => e$C && t6 && t6.media ? window.matchMedia(t6.media).matches : t6), this.configureColumns = s$n((e3, t6, s10) => {
      this.props.selectedField && e3.filter((g6) => g6.field === this.props.selectedField).forEach((g6) => {
        g6.width = g6.width || "50px", g6.cell = g6.cell || P, g6.headerCell = g6.headerCell || C;
      });
      const { unstyled: l7 } = this.props, d8 = l7 && l7.uGrid ? l7.uGrid : g$f, p6 = {
        id: "",
        resizable: true,
        width: "32px",
        title: " ",
        declarationIndex: -1,
        orderIndex: -1,
        children: [],
        parentIndex: -1,
        depth: 0,
        colSpan: 0,
        rowSpan: 0,
        left: 0,
        right: 0,
        index: 0,
        rightBorder: false,
        ariaColumnIndex: 0,
        isAccessible: true
      };
      let h3 = 0;
      this.props.expandField && this.props.onExpandChange && this.props.detail && (e3.unshift({
        ...p6,
        cell: z2,
        field: this.props.expandField,
        headerClassName: r$r(d8.hierarchyCell({}))
      }), h3++);
      for (let g6 = 0; g6 < t6; g6++)
        e3.unshift({
          ...p6,
          isAccessible: false,
          cell: V2,
          field: "value",
          locked: this.props.lockGroups
        }), h3++;
      e3.slice(h3).forEach((g6) => g6.parentIndex >= 0 && (g6.parentIndex += h3));
    }), this.getHeaderRow = s$n(
      (e3, t6, s10, l7, d8, p6, h3, g6, v3, z3, E2, G2, O2) => /* @__PURE__ */ reactExports.createElement(
        ce,
        {
          cells: this.props.cells,
          sort: e3,
          sortable: t6,
          sortChange: this.sortChange,
          group: s10 || [],
          groupable: l7,
          groupChange: this.groupChange,
          filter: d8,
          filterable: p6,
          filterOperators: h3,
          filterChange: this.filterChange,
          columnMenu: v3,
          columnMenuIcon: z3,
          selectionChange: this.onHeaderSelectionChange,
          columns: E2,
          columnResize: this.columnResize,
          pressHandler: this.dragLogic.pressHandler,
          dragHandler: this.dragLogic.dragHandler,
          releaseHandler: this.dragLogic.releaseHandler,
          columnsMap: G2,
          cellRender: g6,
          isRtl: O2,
          dragClue: this.dragLogic.dragClueRef,
          headerRef: this.headerElementRef,
          containerRef: this.containerRef,
          navigatable: !!this.props.navigatable,
          columnGroupChange: this.columnGroupChange
        }
      )
    ), this.resolveTitle = (e3) => {
      const t6 = this._columns.find((l7) => l7.field === e3), s10 = t6 && (t6.title || t6.field);
      return s10 === void 0 ? e3 : s10;
    }, this.getLeafDataItems = () => this._data.filter((e3) => e3.rowType === "data").map((e3) => e3.dataItem), this.getSlicedLeafDataItems = () => (this._slicedData || this._data).filter((e3) => e3.rowType === "data").map((e3) => e3.dataItem), this.handleFocusInEditableRows = () => {
      var e3, t6, s10;
      if (this.tableBodyRef.current && ((e3 = this.tableBodyRef.current) == null ? void 0 : e3.getElementsByClassName("k-grid-edit-row").length) > 0) {
        this._singleEditRow = false, (t6 = document.activeElement) != null && t6.closest(".k-grid-edit-row") ? this._lastActiveElement = document.activeElement : this._lastActiveElement = void 0;
        const l7 = Array.from((s10 = this.tableBodyRef.current) == null ? void 0 : s10.getElementsByClassName("k-grid-edit-row"));
        l7.length > this.rowsInEdit.length ? this._newEditableRow = l7.filter((d8) => !this.rowsInEdit.includes(d8))[0] : l7.length === 1 && (this._newEditableRow = l7[0], this._singleEditRow = true), this.rowsInEdit = l7;
      }
    }, l$p(e$1), this.showLicenseWatermark = n$w(e$1);
    const n10 = this.props.groupable === true || typeof this.props.groupable == "object" && this.props.groupable.enabled !== false, c6 = this.getVirtualScroll(a9);
    this.vs = new c6(n10 || a9.rowHeight === void 0 || a9.rowHeight === 0), this.dragLogic = new g$1(
      this.columnReorder.bind(this),
      this.groupReorder.bind(this),
      this.columnToGroup.bind(this)
    ), this.columnGroupChange = this.columnGroupChange.bind(this), this.columnResize = new u$1(this.onResize), this.props.clipboard && (this.clipboardService = new n$7(this.onClipboard)), le$1.onConstructor({
      navigatable: !!a9.navigatable,
      contextStateRef: this.contextStateRef,
      navigationStateRef: this.navigationStateRef,
      idPrefix: this._gridId
    });
  }
  /* eslint-disable max-len */
  /**
   * A getter of the current columns. Gets the current column width or current columns, or any other [`GridColumnProps`]({% slug api_grid_gridcolumnprops %}) for each defined column. Can be used on each Grid instance. To obtain the instance of the rendered Grid, use the `ref` callback. The following example demonstrates how to reorder the columns by dragging their handlers and check the properties afterwards. You can check the result in the browser console.
   *
   * @example
   * ```jsx
   * class App extends React.Component {
   *     constructor(props) {
   *         super(props);
   *         this.state = {
   *             data: [
   *                 { 'foo': 'A1', 'bar': 'B1' },
   *                 { 'foo': 'A2', 'bar': 'B2' },
   *                 { 'foo': 'A3', 'bar': 'B2' }
   *             ]
   *         };
   *         this.grid = null;
   *     }
   *     render() {
   *         return (
   *             <div>
   *                 <Grid
   *                     data={this.state.data}
   *                     reorderable={true}
   *                     ref={(g) => { this.grid = g; }}
   *                 >
   *                     <GridColumn field="foo" />
   *                     <GridColumn field="bar" />
   *                 </Grid>
   *                 <button onClick={() => console.log(JSON.stringify(this.grid.columns))}>
   *                     log current properties into browser console.
   *                 </button>
   *             </div>
   *         );
   *     }
   * }
   * ReactDOM.render(<App />, document.querySelector('my-app'));
   * ```
   */
  // tslint:enable:max-line-length
  get columns() {
    const a9 = this._columns.filter((n10) => n10.declarationIndex >= 0 && n10.parentIndex === -1);
    return w$2(a9);
  }
  /**
   * Returns the HTML element of the Grid component.
   */
  get element() {
    return this._element;
  }
  get document() {
    if (e$C)
      return this.element && this.element.ownerDocument || document;
  }
  get _header() {
    return this.headerRef.current;
  }
  get _gridId() {
    return this.props.id + "-role-element-id";
  }
  /**
   * @hidden
   */
  componentDidMount() {
    var c6;
    this.props.columnVirtualization && !navigator.userAgent.match(L2) && (this.headTable && (this.headTable.style.display = "block"), this.tableElement && (this.tableElement.style.display = "block")), this.resetTableWidth(), d$s(this.getCachedScrollbarWidth());
    const a9 = E$4(this.element);
    this.isRtl = a9, le$1.onComponentDidMount({
      scope: this.element || void 0,
      contextStateRef: this.contextStateRef,
      navigationStateRef: this.navigationStateRef
    }), this.isRtl && this.forceUpdate();
    const n10 = {
      rootMargin: "0px",
      threshold: 0.9
    };
    this.clipboardService && this.clipboardService.addEventListeners(this.document), this.observer = e$C && window.IntersectionObserver && new window.IntersectionObserver(this.handleIntersection, n10) || null, this.resizeObserver = e$C && window.ResizeObserver && new window.ResizeObserver(this.calculateMedia.bind(this)), (c6 = this.document) != null && c6.body && this.resizeObserver && this.resizeObserver.observe(this.document.body);
  }
  /**
   * @hidden
   */
  getSnapshotBeforeUpdate() {
    return le$1.onGetSnapshotBeforeUpdate({
      document: this.document,
      contextStateRef: this.contextStateRef,
      navigationStateRef: this.navigationStateRef
    }), null;
  }
  /**
   * @hidden
   */
  componentDidUpdate() {
    this.resetTableWidth(), d$s(this.getCachedScrollbarWidth()), this.vs.tableTransform && this.vs.table && (this.vs.table.style.transform = this.vs.tableTransform, this.vs.tableTransform = ""), this.handleFocusInEditableRows(), le$1.onComponentDidUpdate({
      scope: this.element || void 0,
      contextStateRef: this.contextStateRef,
      navigationStateRef: this.navigationStateRef,
      focusFirst: this._focusFirst,
      newEditableRow: this._newEditableRow,
      singleEditRow: this._singleEditRow,
      lastActiveElement: this._lastActiveElement,
      navigatable: this.props.navigatable
    }), this._focusFirst = false, this._newEditableRow = void 0;
  }
  /**
   * @hidden
   */
  componentWillUnmount() {
    var a9;
    clearTimeout(this.forceUpdateTimeout), this.clipboardService && this.clipboardService.removeEventListeners(this.document), (a9 = this.document) != null && a9.body && this.resizeObserver && this.resizeObserver.disconnect();
  }
  /**
   * @hidden
   */
  render() {
    var ae2;
    let a9 = this.props.total || 0;
    const n10 = ue.getIdPrefix(this.navigationStateRef), c6 = s$k(this), { unstyled: e3, size: t6 = "medium" } = this.props, s10 = e3 && e3.uGrid ? e3.uGrid : g$f;
    let l7 = [];
    Array.isArray(this.props.data) ? (l7 = this.props.data, a9 = a9 || this.props.data.length) : this.props.data && (l7 = this.props.data.data, a9 = a9 || this.props.data.total);
    const d$12 = typeof this.props.groupable == "object" && this.props.groupable.footer || "none", p6 = this.props.scrollable === "virtual", { resolvedGroupsCount: h$12, flattedData: g$12 } = this.flatData(
      l7,
      d$12,
      this.props.skip || 0,
      this.props.group,
      this.props.expandField,
      this.props.filter,
      this.props.sort
    );
    this._data = g$12;
    const v$12 = this.props.groupable === true || typeof this.props.groupable == "object" && this.props.groupable.enabled !== false;
    this.columnResize.resizable = this.props.resizable || false, this.dragLogic.reorderable = this.props.reorderable || false, this.dragLogic.groupable = v$12;
    const z3 = this.props.selectable && this.props.selectable.drag ? "none" : void 0;
    this.initializeVirtualization(a9, v$12);
    const E2 = this.childrenToArray(this.props.children);
    this.initColumns(E2, h$12);
    const G2 = E2.map((i16) => i16 && i16.type && i16.type.displayName === "KendoReactGridToolbar" ? reactExports.cloneElement(i16, { ...i16.props, ariaControls: this._gridId }) : null), O2 = E2.filter(
      (i16) => i16 && i16.type && i16.type.displayName === "KendoReactGridNoRecords"
    ), j2 = E2.filter(
      (i16) => i16 && i16.type && i16.type.displayName === "KendoReactGridStatusBar"
    ), R2 = this._columns.filter((i16) => i16.children.length === 0), q2 = v$12 && /* @__PURE__ */ reactExports.createElement(
      h2,
      {
        group: this.props.group || [],
        groupChange: this.groupChange,
        pressHandler: this.dragLogic.pressHandler,
        dragHandler: this.dragLogic.dragHandler,
        releaseHandler: this.dragLogic.releaseHandler,
        refCallback: this.dragLogic.refGroupPanelDiv,
        resolveTitle: this.resolveTitle,
        ariaControls: this._gridId,
        onContextMenu: this.onContextMenu
      }
    ), {
      sort: _e2,
      sortable: xe2,
      group: ke2,
      filter: Te2,
      filterable: De2,
      filterOperators: He2 = g$3,
      headerCellRender: ze,
      columnMenu: Ae2,
      columnMenuIcon: Fe2
    } = this.props, J2 = /* @__PURE__ */ reactExports.createElement(
      d$2,
      {
        size: t6,
        columnResize: this.columnResize,
        staticHeaders: this.props.scrollable !== "none",
        scrollableDataElement: () => this.vs.container,
        hasScrollbarWidth: !!this.getCachedScrollbarWidth(),
        draggable: this.props.reorderable || v$12,
        ref: this.headerRef,
        elemRef: this.headerElementRef,
        headerRow: this.getHeaderRow(
          _e2,
          xe2,
          ke2,
          v$12,
          Te2,
          De2,
          He2,
          ze,
          Ae2,
          Fe2,
          this._columns,
          this._columnsMap,
          this.isRtl
        ),
        filterRow: this.props.filterable && /* @__PURE__ */ reactExports.createElement(
          S,
          {
            cells: this.props.cells,
            size: t6,
            columns: this._columns,
            filter: this.props.filter,
            filterOperators: this.props.filterOperators || g$3,
            filterChange: this.filterChange,
            sort: this.props.sort,
            cellRender: this.props.filterCellRender,
            isRtl: this.isRtl,
            navigatable: !!this.props.navigatable,
            ariaRowIndex: this._columnsMap.length + 1
          }
        ) || void 0,
        cols: R2.map((i16, f4) => /* @__PURE__ */ reactExports.createElement("col", { key: f4.toString(), width: m$1(i16) }))
      }
    ), Ne2 = this.vs && this.vs.container && this.vs.container.scrollLeft || 0, Le2 = parseFloat(((this.props.style || {}).width || "").toString()), { colSpans: Me2, hiddenColumns: Ge2 } = x$2({
      enabled: this.props.columnVirtualization,
      columns: R2,
      tableViewPortWidth: Le2,
      scrollLeft: Ne2
    }), Oe2 = (i16, f4, b2, F2) => {
      let k3 = false;
      const S2 = this.props.selectedField ? c$3(this.props.selectedField, i16.dataItem) : void 0;
      return {
        row: R2.map((u5, C2) => {
          if (Ge2[C2])
            return null;
          const N3 = u5.id ? u5.id : C2, w$12 = r$r(
            s10.contentSticky({ locked: u5.locked }),
            u5.className
          ), I3 = u5.left !== void 0 ? this.isRtl ? { left: u5.right, right: u5.left } : { left: u5.left, right: u5.right } : {};
          let K3 = false;
          if (u5.editable && this.props.editField) {
            const x3 = c$3(this.props.editField, i16.dataItem);
            x3 && (x3 === true || x3 === u5.field) && (k3 = true, K3 = true);
          }
          const L3 = u5.cell || K3 && B || w2, _2 = this.props.expandField && this.props.detail && u5.field === this.props.expandField;
          return /* @__PURE__ */ reactExports.createElement(
            L3,
            {
              onContextMenu: this.onContextMenu,
              key: N3,
              locked: this.props.lockGroups,
              id: ue.generateNavigatableId(
                `${f4}-${String(C2)}`,
                n10,
                _2 || i16.rowType === "groupHeader" || i16.rowType === "groupFooter" || u5.field === "value" ? "nodata" : "cell"
              ),
              colSpan: Me2[C2],
              dataItem: i16.dataItem,
              field: u5.field,
              editor: u5.editor,
              format: u5.format,
              className: w$12,
              render: this.props.cellRender,
              cells: N$2(this.props.cells, u5.cells),
              onChange: this.itemChange,
              selectionChange: this.props.onSelectionChange ? (x3) => {
                this.selectionChange({
                  event: x3,
                  dataItem: i16.dataItem,
                  dataIndex: b2,
                  columnIndex: C2
                });
              } : void 0,
              columnIndex: C2,
              columnsCount: R2.length,
              rowType: i16.rowType,
              level: i16.level,
              expanded: i16.expanded,
              dataIndex: i16.dataIndex,
              style: I3,
              ariaColumnIndex: u5.ariaColumnIndex,
              isSelected: Array.isArray(S2) && S2.indexOf(C2) > -1,
              isSorted: !!F$1(u5.field, this.props.sort),
              isAlt: F2
            }
          );
        }),
        isInEdit: k3,
        isSelected: typeof S2 == "boolean" && S2
      };
    };
    let X2 = 0;
    if (p6)
      for (let i16 = 0; i16 < this.vs.topCacheCount + this.vs.attendedSkip - (this.props.skip || 0); i16++) {
        const f4 = this._data.shift();
        if (f4)
          this._data.push(f4), X2++, f4.rowType === "groupHeader" && i16--;
        else
          break;
      }
    const Y2 = (i16) => i16 >= this._data.length - X2;
    let Q2 = this.vs.realSkip || 0;
    const P2 = [];
    let B$12 = false;
    const Z2 = this._columnsMap.length + (this.props.filterable ? 1 : 0) + 1;
    let A2 = 0;
    if (this._data.length) {
      let i16 = -1, f4 = 0;
      (this._slicedData || this._data).forEach((b2, F2) => {
        b2.rowType === "data" && (Q2++, i16++);
        const k3 = Q2 % 2 === 0, S2 = this.props.dataItemKey && s$s(this.props.dataItemKey)(b2.dataItem), u5 = F2 + (this.vs.realSkip || 0), C2 = S2 || "ai" + u5, N3 = C2 + "_1", w3 = Oe2(b2, C2, i16, k3);
        if (A2 = u5 + Z2 + f4, P2.push(
          /* @__PURE__ */ reactExports.createElement(
            x2,
            {
              key: C2,
              dataItem: b2.dataItem,
              isAltRow: k3,
              isInEdit: w3.isInEdit,
              rowType: b2.rowType,
              isHidden: Y2(F2),
              onClick: (I3) => this.rowClick(I3, b2),
              onDoubleClick: (I3) => this.rowDblClick(I3, b2),
              selectedField: this.props.selectedField,
              rowHeight: this.props.rowHeight,
              render: this.props.rowRender,
              ariaRowIndex: A2,
              absoluteRowIndex: u5,
              dataIndex: this.vs.scrollableVirtual && !this.props.groupable ? u5 : i16,
              isSelected: w3.isSelected
            },
            w3.row
          )
        ), this.props.detail && b2.rowType === "data" && b2.expanded) {
          const I3 = R2.length - (this.props.expandField ? 1 : 0) - (this.props.group ? this.props.group.length : 0) || 1;
          f4++, A2 = u5 + Z2 + f4, P2.push(
            /* @__PURE__ */ reactExports.createElement(
              "tr",
              {
                key: N3,
                className: r$r(s10.detailTr({ isAlt: k3 })),
                style: {
                  visibility: Y2(F2) ? "hidden" : "",
                  height: this.props.detailRowHeight
                },
                role: "row",
                "aria-rowindex": A2
              },
              this.props.group && this.props.group.map((K3, L3) => {
                var le2;
                const _2 = (le2 = w3 == null ? void 0 : w3.row[L3]) == null ? void 0 : le2.props.style, x3 = _2 ? this.isRtl ? { left: _2.right, right: _2.left } : { left: _2.left, right: _2.right } : {};
                return /* @__PURE__ */ reactExports.createElement(
                  V2,
                  {
                    id: "",
                    dataIndex: b2.dataIndex,
                    field: K3.field,
                    dataItem: b2.dataItem,
                    key: L3,
                    style: x3,
                    ariaColumnIndex: 1 + L3,
                    isSelected: false,
                    locked: this.props.lockGroups,
                    isRtl: this.isRtl,
                    cells: this.props.cells
                  }
                );
              }),
              this.props.expandField && /* @__PURE__ */ reactExports.createElement(
                d7,
                {
                  id: ue.generateNavigatableId(`${N3}-dhcell`, n10)
                }
              ),
              /* @__PURE__ */ reactExports.createElement(
                g5,
                {
                  onContextMenu: this.onContextMenu,
                  dataItem: b2.dataItem,
                  dataIndex: b2.dataIndex,
                  colSpan: I3,
                  ariaColIndex: 2 + (this.props.group ? this.props.group.length : 0),
                  detail: this.props.detail,
                  id: ue.generateNavigatableId(`${N3}-dcell`, n10)
                }
              )
            )
          );
        }
      });
    } else
      B$12 = true;
    const Pe2 = () => {
      const i16 = this._header;
      return i16 && i16.table && i16.table.clientWidth;
    }, ee2 = () => /* @__PURE__ */ reactExports.createElement("div", { key: "no-records", className: r$r(s10.noRecords({})), style: { width: Pe2() } }, /* @__PURE__ */ reactExports.createElement(
      "div",
      {
        className: r$r(s10.noRecordsTemplate({})),
        [o$6]: ue.generateNavigatableId("no-records", n10)
      },
      O2.length ? O2 : /* @__PURE__ */ reactExports.createElement(e$2, null)
    )), te2 = {
      size: t6,
      onPageChange: this.pagerPageChange,
      total: a9,
      dir: this.isRtl ? "rtl" : void 0,
      skip: this.vs.propsSkip || 0,
      take: (this.props.take !== void 0 ? this.props.take : this.props.pageSize) || 10,
      messagesMap: U2,
      ...u4(this.props.pageable || {})
    }, se2 = this.props.pager ? /* @__PURE__ */ reactExports.createElement(this.props.pager, { ...te2 }) : /* @__PURE__ */ reactExports.createElement(P$8, { className: r$r(s10.pager({})), ...te2 }), We2 = (i16, f4) => /* @__PURE__ */ reactExports.createElement("col", { key: f4.toString(), width: m$1(i16) }), ie2 = (ae2 = this.props.cells) != null && ae2.footerCell || this._columns.some((i16) => {
      var f4;
      return !!(i16.footerCell || (f4 = i16.cells) != null && f4.footerCell);
    }) ? /* @__PURE__ */ reactExports.createElement(
      i$1,
      {
        size: t6,
        columnResize: this.columnResize,
        staticHeaders: this.props.scrollable !== "none",
        hasScrollbarWidth: !!this.getCachedScrollbarWidth(),
        ref: (i16) => this._footer = i16,
        row: /* @__PURE__ */ reactExports.createElement(
          I2,
          {
            cells: this.props.cells,
            idPrefix: n10,
            columns: this._columns,
            isRtl: this.isRtl,
            ariaRowIndex: A2 + 1
          }
        ),
        cols: R2.map(We2)
      }
    ) : null, oe2 = /* @__PURE__ */ reactExports.createElement(
      "colgroup",
      {
        ref: (i16) => {
          this.columnResize.colGroupMain = i16;
        }
      },
      R2.map((i16, f4) => /* @__PURE__ */ reactExports.createElement(
        "col",
        {
          key: f4.toString(),
          className: F$1(i16.field, this.props.sort) ? r$r(s10.sorted({})) : void 0,
          width: m$1(i16)
        }
      ))
    ), re2 = this.dragLogic.reorderable || this.dragLogic.groupable;
    if (this.props.scrollable === "none")
      return /* @__PURE__ */ reactExports.createElement(t$9.Provider, { value: this.contextStateRef.current }, /* @__PURE__ */ reactExports.createElement(
        "div",
        {
          id: this.props.id,
          style: this.props.style,
          className: r$r(s10.wrapper({ size: t6 }), this.props.className),
          ref: (i16) => {
            this._element = i16;
          },
          "aria-label": this.props.ariaLabel,
          onKeyDown: this.onKeyDown,
          onFocus: this.onFocus,
          ...c$8
        },
        G2,
        q2,
        /* @__PURE__ */ reactExports.createElement(
          ce$1,
          {
            selectable: this.props.selectable,
            onRelease: this.selectionRelease,
            childRef: (i16) => {
              this.tableElement = i16, this.headTable = i16;
            }
          },
          /* @__PURE__ */ reactExports.createElement(
            "table",
            {
              ref: (i16) => this.headTable = i16,
              className: r$r(s10.table({ size: t6 }))
            },
            oe2,
            J2,
            /* @__PURE__ */ reactExports.createElement(
              "tbody",
              {
                role: "rowgroup",
                className: r$r(s10.tbody({})),
                ...E$6
              },
              P2
            ),
            ie2
          )
        ),
        B$12 && ee2(),
        re2 && /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(a$8, { ref: this.dragLogic.refDropElementClue }), /* @__PURE__ */ reactExports.createElement(p$a, { ref: this.dragLogic.refDragElementClue }))
      ), j2, this.props.pageable && se2);
    let W3 = this.props.style || {};
    return p6 && (W3.height || (W3 = Object.assign({}, W3, { height: "450px" }))), /* @__PURE__ */ reactExports.createElement(t$9.Provider, { value: this.contextStateRef.current }, /* @__PURE__ */ reactExports.createElement(
      "div",
      {
        id: this.props.id,
        style: W3,
        className: r$r(
          s10.wrapper({
            size: t6,
            virtual: p6
          }),
          this.props.className
        ),
        ref: (i16) => {
          this._element = i16;
        },
        "aria-label": this.props.ariaLabel,
        onKeyDown: this.onKeyDown,
        onFocus: this.onFocus,
        ...c$8
      },
      G2,
      q2,
      /* @__PURE__ */ reactExports.createElement(
        "div",
        {
          className: r$r(s10.ariaRoot({})),
          role: "grid",
          "aria-colcount": R2.length,
          "aria-rowcount": a9,
          id: this._gridId,
          "aria-label": c6.toLanguageString(v2, z$1[v2])
        },
        J2,
        /* @__PURE__ */ reactExports.createElement("div", { className: r$r(s10.container({})), role: "presentation" }, /* @__PURE__ */ reactExports.createElement(
          "div",
          {
            ref: this.containerRef,
            className: r$r(s10.content({})),
            onScroll: this.scrollHandler,
            role: "presentation"
          },
          /* @__PURE__ */ reactExports.createElement("div", { className: r$r(s10.tableWrap({})), role: "presentation" }, /* @__PURE__ */ reactExports.createElement(
            ce$1,
            {
              selectable: this.props.selectable,
              onRelease: this.selectionRelease,
              childRef: (i16) => {
                this.tableElement = i16;
              }
            },
            /* @__PURE__ */ reactExports.createElement(
              "table",
              {
                ref: (i16) => this.tableElement = i16,
                className: r$r(
                  s10.table({
                    size: t6
                  })
                ),
                role: "presentation",
                style: { userSelect: z3 }
              },
              oe2,
              /* @__PURE__ */ reactExports.createElement(
                "tbody",
                {
                  className: r$r(s10.tbody({})),
                  ref: this.tableBodyRef,
                  role: "rowgroup",
                  ...E$6
                },
                P2
              )
            )
          ), B$12 && ee2()),
          p6 && /* @__PURE__ */ reactExports.createElement("div", { className: r$r(s10.heightContainer({})), role: "presentation" }, /* @__PURE__ */ reactExports.createElement(
            "div",
            {
              style: p6 ? { height: this.vs.containerHeight + "px" } : {}
            }
          ))
        )),
        ie2,
        re2 && /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(a$8, { ref: this.dragLogic.refDropElementClue }), /* @__PURE__ */ reactExports.createElement(p$a, { ref: this.dragLogic.refDragElementClue })),
        this.showLicenseWatermark && /* @__PURE__ */ reactExports.createElement(v$e, null)
      ),
      j2,
      this.props.pageable && se2
    ));
  }
  calculateMedia() {
    this.checkMatchMediaColumnsDifferece() || this.forceUpdate();
  }
  selectionChange(a9) {
    if (this.props.onSelectionChange) {
      const { event: n10, dataItem: c6, dataIndex: e3, columnIndex: t6 } = a9, { mode: s10, cell: l7 } = P$6(this.props.selectable), d8 = {
        ...this.getArguments(n10.syntheticEvent),
        dataItem: c6,
        startColIndex: t6,
        endColIndex: t6,
        startRowIndex: e3,
        endRowIndex: e3,
        dataItems: this.getLeafDataItems(),
        altKey: false,
        ctrlKey: false,
        shiftKey: false,
        metaKey: false,
        mode: s10,
        cell: l7,
        isDrag: false,
        componentId: this._gridId,
        selectedField: this.props.selectedField || ""
      };
      this.props.onSelectionChange.call(void 0, d8);
    }
  }
  raiseDataEvent(a9, n10, c6, e3, t6) {
    const s10 = this.props.onDataStateChange;
    if (a9) {
      const l7 = { ...this.getArguments(e3), ...n10, targetEvent: t6 };
      a9.call(void 0, l7);
    } else
      s10 && s10.call(void 0, {
        ...this.getArguments(e3),
        targetEvent: t6 || {},
        dataState: {
          ...this.getDataState(),
          ...c6
        }
      });
  }
  columnReorder(a9, n10, c6) {
    const e3 = this._columns[a9], t6 = e3.depth, s10 = (h3) => {
      do
        h3++;
      while (h3 < this._columns.length && this._columns[h3].depth > t6);
      return h3;
    }, l7 = this._columns.splice(a9, s10(a9) - a9);
    this._columns.splice(a9 < n10 ? s10(n10 - l7.length) : n10, 0, ...l7), this._columns.filter((h3) => h3.declarationIndex >= 0).forEach((h3, g6) => h3.orderIndex = g6), this._columnsMutations++;
    const d8 = this._columns[a9].locked && this._columns[n10].locked;
    x$6(this._columnsMap, this._columns, d8 || this._shouldUpdateLeftRight), s$4(this._columnsMap, this._columns, d8 || this._shouldUpdateLeftRight), this._resized && (this._shouldUpdateLeftRight = false, this._resized = false);
    const p6 = this.columns;
    if (this.forceUpdate(), this.props.onColumnReorder) {
      const h3 = {
        target: this,
        columns: p6,
        columnId: e3.id,
        nativeEvent: c6
      };
      this.props.onColumnReorder.call(void 0, h3);
    }
  }
  groupReorder(a9, n10, c6) {
    if (this.props.group === void 0)
      return;
    const e3 = this.props.group.slice();
    e3.splice(n10, 0, ...e3.splice(a9, 1)), this.groupChange(e3, c6);
  }
  columnToGroup(a9, n10, c6) {
    const e3 = this._columns[a9].field;
    if (!e3)
      return;
    const t6 = (this.props.group || []).slice();
    t6.splice(n10, 0, { field: e3 }), this.groupChange(t6, c6);
  }
  columnGroupChange(a9, n10) {
    const c6 = this.dragLogic.getCurrentGroupsLength;
    this.columnToGroup(a9, c6, n10);
  }
  resetTableWidth() {
    let a9 = 0;
    if (!this.columnResize.colGroupMain)
      return;
    const n10 = this.columnResize.colGroupMain.children;
    for (let c6 = 0; c6 < n10.length; c6++) {
      const e3 = n10[c6].width;
      if (!e3)
        return;
      a9 += parseFloat(e3.toString());
    }
    a9 = Math.round(a9), this._header && this._header.setWidth(a9), this._footer && this._footer.setWidth(a9), this.tableElement && (this.tableElement.style.width = a9 + "px");
  }
  initColumns(a9, n10) {
    const c6 = ue.getIdPrefix(this.navigationStateRef), e3 = this.readColumns(a9, c6, this._columnsMutations), t6 = this.filterColumnsByMediaProp(e3);
    this._columns = t6, this._columns.length === 0 && (this._columns = b$1(this.props.data, this.props.group, this.props.expandField, {
      prevId: 0,
      idPrefix: c6
    })), this.configureColumns(this._columns, n10, c6), this._columnsMap = this.mapColumns(this._columns, this._columnsMutations), this.columnResize.columns = this._columns, this.dragLogic.columns = this._columns;
  }
  getDataState() {
    return {
      filter: this.props.filter,
      sort: this.props.sort,
      skip: this.props.skip,
      take: this.props.take !== void 0 ? this.props.take : this.props.pageSize,
      group: this.props.group
    };
  }
  getArguments(a9) {
    return {
      nativeEvent: a9 && a9.nativeEvent,
      syntheticEvent: a9,
      target: this
    };
  }
};
H.displayName = "KendoReactGrid", H.defaultProps = {
  // never use this
}, H.propTypes = {
  data: o$r.oneOfType([
    o$r.array,
    o$r.shape({
      data: o$r.array,
      total: o$r.number
    })
  ]),
  sortable: o$r.oneOfType([
    o$r.bool,
    o$r.shape({
      mode: o$r.oneOf(["single", "multiple"]),
      allowUnsort: o$r.bool
    })
  ]),
  onSortChange: o$r.func,
  sort: o$r.array,
  filterable: o$r.bool,
  filter: o$r.any,
  onFilterChange: o$r.func,
  pageable: o$r.oneOfType([
    o$r.bool,
    o$r.shape({
      buttonCount: o$r.number,
      responsive: o$r.bool,
      info: o$r.bool,
      type: o$r.oneOf(["numeric", "input"]),
      pageSizes: o$r.oneOfType([
        o$r.bool,
        o$r.arrayOf(o$r.oneOfType([o$r.string, o$r.number]))
      ]),
      previousNext: o$r.bool
    })
  ]),
  pageSize: o$r.number,
  onPageChange: o$r.func,
  total: o$r.number,
  skip: o$r.number,
  take: o$r.number,
  fixedScroll: o$r.bool,
  onExpandChange: o$r.func,
  expandField: o$r.string,
  selectedField: o$r.string,
  onSelectionChange: o$r.func,
  onHeaderSelectionChange: o$r.func,
  resizable: o$r.bool,
  reorderable: o$r.bool,
  group: o$r.any,
  groupable: o$r.oneOfType([
    o$r.bool,
    o$r.shape({
      enabled: o$r.bool,
      footer: o$r.oneOf(["always", "visible", "none"])
    })
  ]),
  onGroupChange: o$r.func,
  onRowClick: o$r.func,
  onRowDoubleClick: o$r.func,
  onItemChange: o$r.func,
  editField: o$r.string,
  scrollable: o$r.oneOf(["none", "scrollable", "virtual"]),
  rowHeight: o$r.number,
  detailRowHeight: o$r.number,
  detail: o$r.any,
  style: o$r.object,
  onDataStateChange: o$r.func,
  onColumnResize: o$r.func,
  onColumnReorder: o$r.func,
  dataItemKey: o$r.string,
  navigatable: o$r.oneOfType([
    o$r.bool,
    o$r.shape({
      mode: o$r.oneOf(["incell", "inline", "popup"])
    })
  ]),
  size: o$r.oneOf(["small", "medium"])
}, H.contextType = t$9;
let $ = H;
v$a($);
/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright  2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const t5 = m$l(l$o($));
t5.displayName = "KendoReactGrid";
const pairsToObject = (pairs) => {
  const obj = {};
  pairs.forEach((p6) => {
    obj[p6[0]] = p6[1];
  });
  return obj;
};
const KendoGrid = ({ data: data2 }) => {
  const { ColTitles, Values, Posn, Options } = data2 == null ? void 0 : data2.Properties;
  const gridData = Values.map((row) => {
    let gd2 = {};
    ColTitles.forEach((ct2, i16) => gd2[ct2] = row[i16]);
    return gd2;
  });
  const initialFilter = {
    logic: "and",
    filters: []
  };
  const [filter, setFilter] = reactExports.useState(initialFilter);
  const initialSort = [];
  const [sort2, setSort] = reactExports.useState(initialSort);
  const columnTypes = pairsToObject(Options.columnTypes);
  const filterableCols = pairsToObject(Options.filterableCols);
  const sortableCols = Options.sortableCols;
  const ImageCell = (props) => {
    if (!props.dataItem[props.field]) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("td", {});
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: getCurrentUrl() + props.dataItem[props.field] }) });
  };
  const ButtonCell = (props) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(p$j, { onClick: () => alert(props.dataItem[props.field]), children: props.dataItem[props.field] }) });
  };
  const VideoCell = (props) => {
    const videoSrc = props.dataItem[props.field];
    if (!videoSrc) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("td", {});
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("video", { controls: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx("source", { src: getCurrentUrl() + videoSrc, type: "video/mp4" }) }) });
  };
  const cellComponents = {
    Image: ImageCell,
    Button: ButtonCell,
    Video: VideoCell
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      style: {
        position: "absolute",
        top: Posn && Posn[0],
        left: Posn && Posn[1]
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        t5,
        {
          data: orderBy(filterBy(gridData, filter), sort2),
          navigatable: true,
          filterable: Options["filterable"] == 1,
          filter,
          onFilterChange: (e3) => setFilter(e3.filter),
          sortable: Options["sortable"] == 1 ? {
            allowUnsort: true,
            mode: "multiple"
          } : void 0,
          sort: sort2,
          onSortChange: (e3) => setSort(e3.sort),
          children: ColTitles.map((ct2, _2) => {
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              l$1,
              {
                field: ct2,
                title: ct2,
                cells: { data: cellComponents[columnTypes[ct2]] },
                filterable: filterableCols.hasOwnProperty(ct2),
                filter: filterableCols[ct2] === "" ? void 0 : filterableCols[ct2],
                sortable: sortableCols.includes(ct2)
              }
            );
          })
        }
      )
    }
  );
};
const SelectComponent = ({
  data: data2,
  inputValue = "",
  event = "",
  row = "",
  column = "",
  location,
  inSplitter = null,
  values: values6 = [],
  formatString: formatString2 = "",
  activeTab = null,
  bgColor = null,
  fontColor = null,
  activebgColor = null,
  handleTabClick = () => {
  }
}) => {
  var _a, _b, _c, _d, _e2, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, _L, _M, _N, _O, _P;
  const { dataRef } = useAppData();
  if (((_a = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _a.Type) == "Form")
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Form, { data: data2 });
  if (((_b = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _b.Type) == "MenuBar")
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        style: {
          translate: "0% -100%",
          position: "relative",
          zIndex: "2",
          width: "100%"
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuBar, { data: data2 })
      }
    );
  if (((_c = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _c.Type) == "Menu")
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Menu, { data: data2 });
  if (((_d = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _d.Type) == "Grid")
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { data: data2 });
  if (((_e2 = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _e2.Type) == "Edit" && ((_f = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _f.Style) !== "Multi")
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        style: location == "inGrid" ? {
          display: "flex",
          justifyContent: ((_g = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _g.FieldType) == "Numeric" || ((_h = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _h.FieldType) == "LongNumeric" ? "end" : "start"
        } : null,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Edit,
          {
            values: values6,
            location,
            data: data2,
            value: inputValue,
            event,
            row,
            column,
            formatString: formatString2
          }
        )
      }
    );
  if (((_i = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _i.Type) == "Button")
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        data: data2,
        location,
        inputValue,
        event,
        row,
        column,
        values: values6
      }
    );
  if (((_j = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _j.Type) == "Combo")
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Combo,
      {
        data: data2,
        location,
        value: inputValue,
        event,
        row,
        column,
        values: values6
      }
    );
  if (((_k = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _k.Type) == "Label")
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { location, gridValue: inputValue, data: data2 });
  if (((_l = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _l.Type) == "TreeView")
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Treeview, { data: data2 });
  if (((_m = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _m.Type) == "List")
    return /* @__PURE__ */ jsxRuntimeExports.jsx(List, { data: data2 });
  if (((_n = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _n.Type) == "Splitter")
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Splitter, { data: data2 });
  if (((_o = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _o.Type) == "Group")
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Group$a, { data: data2 });
  if (((_p = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _p.Type) == "Scroll")
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollBar$1, { data: data2 });
  if (((_q = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _q.Type) == "TabControl")
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TabControl, { data: data2 });
  if (((_r = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _r.Type) == "TabButton")
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      TabButton,
      {
        activeTab,
        handleTabClick,
        data: data2,
        bgColor,
        fontColor,
        activebgColor
      }
    );
  if (((_s = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _s.Type) == "Edit" && ((_t = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _t.Style) == "Multi") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TextArea, { data: data2 });
  }
  if (((_u = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _u.Type) == "Ribbon")
    return /* @__PURE__ */ jsxRuntimeExports.jsx(CustomRibbon, { data: data2 });
  if (((_v = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _v.Type) == "RibbonGroup")
    return /* @__PURE__ */ jsxRuntimeExports.jsx(CustomRibbonGroup, { data: data2 });
  if (((_w = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _w.Type) == "RibbonGroupItem")
    return /* @__PURE__ */ jsxRuntimeExports.jsx(CustomRibbonItem, { data: data2 });
  if (((_x = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _x.Type) == "RibbonButton")
    return /* @__PURE__ */ jsxRuntimeExports.jsx(CustomRibbonButton, { data: data2 });
  if (((_y = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _y.Type) == "RibbonButtonGroup")
    return /* @__PURE__ */ jsxRuntimeExports.jsx(CustomRibbonButtonGroup, { data: data2 });
  if (((_z = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _z.Type) == "Poly")
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Poly, { data: data2 });
  if (((_A = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _A.Type) == "Rect")
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Rectangle, { data: data2 });
  if (((_B = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _B.Type) == "SubForm") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SubForm, { data: data2 });
  }
  if (((_C = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _C.Type) == "Text") {
    const font2 = JSON.parse(getObjectById(dataRef == null ? void 0 : dataRef.current, (_D = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _D.FontObj));
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { data: data2, fontProperties: font2 == null ? void 0 : font2.Properties });
  }
  if (((_E = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _E.Type) == "Timer")
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Timer, { data: data2 });
  if (((_F = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _F.Type) == "ListView")
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ListView, { data: data2 });
  if (((_G = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _G.Type) == "Image")
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Image$1, { data: data2 });
  if (((_H = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _H.Type) == "Ellipse")
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Ecllipse, { data: data2 });
  if (((_I = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _I.Type) == "Circle")
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Circle, { data: data2 });
  if (((_J = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _J.Type) == "ApexChart")
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Chart, { data: data2 });
  if (((_K = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _K.Type) == "MsgBox")
    return /* @__PURE__ */ jsxRuntimeExports.jsx(MsgBox, { data: data2 });
  if (((_L = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _L.Type) == "KendoChart")
    return /* @__PURE__ */ jsxRuntimeExports.jsx(KendoChart, { data: data2 });
  if (((_M = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _M.Type) == "KendoGrid")
    return /* @__PURE__ */ jsxRuntimeExports.jsx(KendoGrid, { data: data2 });
  if (((_N = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _N.Type) == "Link")
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { data: data2 });
  if (((_O = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _O.Type) == "Upload")
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Upload, { data: data2 });
  console.log("UNKNOWN: " + ((_P = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _P.Type));
};
const Form = ({ data: data2 }) => {
  useWindowDimensions();
  const { findDesiredData, socket } = useAppData();
  const [formStyles, setFormStyles] = reactExports.useState({});
  const dimensions = useResizeObserver(document.getElementById(data2 == null ? void 0 : data2.ID));
  const {
    BCol,
    Picture,
    Size: Size2,
    Visible,
    Posn,
    Flex = 0,
    Event,
    CSS
  } = data2 == null ? void 0 : data2.Properties;
  const styles = parseFlexStyles(CSS);
  console.log("form after parsing", { styles, CSS, Flex });
  const updatedData = excludeKeys(data2);
  const ImageData = findDesiredData(Picture && Picture[0]);
  let imageStyles = getImageStyles(Picture && Picture[1], ImageData);
  const sendConfigureEvent = () => {
    const event = JSON.stringify({
      Event: {
        EventName: "Configure",
        ID: data2 == null ? void 0 : data2.ID,
        Info: [
          Posn && Posn[0],
          Posn && Posn[1],
          Size2 && Size2[0],
          Size2 && Size2[1]
        ]
      }
    });
    const exists = Event && Event.some((item) => item[0] === "Configure");
    console.log(event);
    if (!exists)
      return;
    socket.send(event);
  };
  const sendDeviceCapabilities = () => {
    let zoom = Math.round(window.devicePixelRatio * 100);
    let event = JSON.stringify({
      DeviceCapabilities: {
        ViewPort: [window.innerHeight, window.innerWidth],
        ScreenSize: [window.screen.height, window.screen.width],
        DPR: zoom / 100,
        PPI: 200
      }
    });
    console.log(event);
    socket.send(event);
  };
  reactExports.useEffect(() => {
    localStorage.setItem("current-focus", data2.ID);
  }, []);
  reactExports.useEffect(() => {
    var _a;
    const hasSize = (_a = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _a.hasOwnProperty("Size");
    const halfViewportWidth = Math.round(window.innerWidth / 2);
    const halfViewportHeight = Math.round(window.innerHeight / 2);
    localStorage.setItem(
      "formDimension",
      JSON.stringify(hasSize ? Size2 : [halfViewportHeight, halfViewportWidth])
    );
    localStorage.setItem(
      "formPositions",
      JSON.stringify([Posn && Posn[0], Posn && Posn[1]])
    );
    localStorage.setItem(
      data2 == null ? void 0 : data2.ID,
      JSON.stringify({
        Size: hasSize ? Size2 : [halfViewportHeight, halfViewportWidth],
        Posn
      })
    );
    setFormStyles(
      setStyle$1(
        {
          ...data2 == null ? void 0 : data2.Properties,
          ...hasSize ? { Size: Size2 } : { Size: [halfViewportHeight, halfViewportWidth] }
        },
        "relative",
        Flex
      )
    );
  }, [data2]);
  reactExports.useEffect(() => {
    sendConfigureEvent();
    sendDeviceCapabilities();
  }, [dimensions]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      onMouseDown: (e3) => {
        handleMouseDown(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseUp: (e3) => {
        handleMouseUp(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseEnter: (e3) => {
        handleMouseEnter(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseMove: (e3) => {
        handleMouseMove(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onMouseLeave: (e3) => {
        handleMouseLeave(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onWheel: (e3) => {
        handleMouseWheel(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      onDoubleClick: (e3) => {
        handleMouseDoubleClick(e3, socket, Event, data2 == null ? void 0 : data2.ID);
      },
      id: data2 == null ? void 0 : data2.ID,
      style: {
        ...formStyles,
        ...styles,
        background: BCol ? rgbColor(BCol) : "#F0F0F0",
        position: "relative",
        border: "1px solid #F0F0F0",
        display: Visible == 0 ? "none" : (data2 == null ? void 0 : data2.Properties.hasOwnProperty("Flex")) ? "flex" : "block",
        ...imageStyles
        // overflow: 'hidden',
      },
      onKeyDown: (e3) => {
      },
      children: Object.keys(updatedData).map((key, i16) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectComponent, { data: updatedData[key] }, i16);
      })
    }
  );
};
const App$1 = "";
const version = "0.2.3";
const name$1 = "EWC Client";
const version$1 = {
  version,
  name: name$1
};
function useForceRerender() {
  const [_state, setState] = reactExports.useState(true);
  const reRender = () => {
    setState((prev) => !prev);
  };
  return { reRender };
}
const App = () => {
  var _a, _b, _c;
  const [socketData, setSocketData] = reactExports.useState([]);
  const [socket, setSocket] = reactExports.useState(null);
  const [proceed, setProceed] = reactExports.useState(false);
  const [proceedEventArray, setProceedEventArray] = reactExports.useState([]);
  const [layout, setLayout] = reactExports.useState("Initialise");
  const webSocketRef = reactExports.useRef(null);
  const [focusedElement, setFocusedElement] = reactExports.useState(null);
  const { reRender } = useForceRerender();
  const [messageBoxData, setMessageBoxData] = reactExports.useState(null);
  const [options2, setOptions] = reactExports.useState(null);
  const [fontScale, setFontScale] = reactExports.useState(null);
  let colors = {};
  const dataRef = reactExports.useRef({});
  const appRef = reactExports.useRef(null);
  const wsSend = (d8) => webSocketRef.current.send(JSON.stringify(d8));
  reactExports.useEffect(() => {
    dataRef.current = {};
    setSocketData([]);
    localStorage.clear();
    fetchData();
    const handleBeforeUnload = () => {
      if (webSocketRef.current) {
        webSocketRef.current.send(JSON.stringify({ Signal: { Name: "Close" } }));
      }
    };
    window.addEventListener("beforeunload", handleBeforeUnload);
    return () => {
      window.removeEventListener("beforeunload", handleBeforeUnload);
      if (webSocketRef.current && webSocketRef.current.readyState === WebSocket.OPEN) {
        webSocketRef.current.close();
      }
    };
  }, [layout]);
  reactExports.useEffect(() => {
    const container = appRef.current;
    if (container) {
      container.addEventListener("click", handleFocus);
    }
    return () => {
      if (container) {
        container.removeEventListener("click", handleFocus);
      }
    };
  }, []);
  if (fontScale) {
    localStorage.setItem("fontscale", fontScale);
  }
  function getColor(index2, defaultColor) {
    return (colors == null ? void 0 : colors[index2]) || defaultColor;
  }
  function getRequiredRGBChannel(val) {
    if (typeof val === "number") {
      val = [val];
    }
    const newValue = val == null ? void 0 : val.map((value2) => {
      if (Array.isArray(value2) && (value2 == null ? void 0 : value2.every((item) => typeof item === "number" && item >= 0))) {
        return value2;
      }
      if (typeof value2 === "number" && value2 < 0) {
        return getColor(value2);
      }
      if (typeof value2 === "number" && value2 >= 0) {
        return value2;
      }
      const modifiedValue = value2 == null ? void 0 : value2.map((nestVal) => {
        if (Array.isArray(nestVal)) {
          return nestVal.map((item) => typeof item === "number" && item < 0 ? getColor(item) : item);
        } else if (typeof nestVal === "number" && nestVal < 0) {
          return getColor(nestVal);
        } else {
          return nestVal;
        }
      });
      return modifiedValue;
    });
    return newValue;
  }
  const handleData = (data2, mode) => {
    var _a2, _b2, _c2;
    console.log("handleData", data2, mode);
    const splitID = data2.ID.split(".");
    const currentLevel = locateParentByPath(dataRef.current, data2.ID);
    const finalKey = splitID[splitID.length - 1];
    if (currentLevel.hasOwnProperty(finalKey)) {
      if (mode === "WC") {
        if (data2.Properties && data2.Properties.Type === "Form") {
          localStorage.clear();
        }
        currentLevel[finalKey] = {
          ID: data2.ID,
          ...data2
        };
      } else if (mode === "WS") {
        const isRadio = (node) => {
          var _a3, _b3;
          return ((_a3 = node.Properties) == null ? void 0 : _a3.Type) == "Button" && ((_b3 = node.Properties) == null ? void 0 : _b3.Style) == "Radio";
        };
        if (isRadio(currentLevel[finalKey])) {
          const parent = locateParentByPath(dataRef.current, data2.ID);
          const givenKey = extractStringFromLastPeriod(data2.ID);
          Object.keys(excludeKeys(parent)).forEach((k3) => {
            if (isRadio(parent[k3])) {
              parent[k3].Properties.State = 0;
            }
          });
          parent[givenKey].Properties.State = data2.Properties.State;
        }
        currentLevel[finalKey] = {
          ID: data2.ID,
          ...currentLevel[finalKey],
          Properties: {
            ...currentLevel[finalKey].Properties || {},
            ...data2.Properties || {}
          }
        };
      }
    } else {
      let newData = JSON.parse(JSON.stringify(data2));
      try {
        if (data2.Properties.hasOwnProperty("FillCol") || data2.Properties.hasOwnProperty("FCol") || data2.Properties.hasOwnProperty("BCol")) {
          newData = {
            ...data2,
            Properties: {
              ...data2 == null ? void 0 : data2.Properties,
              ...((_a2 = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _a2.FillCol) && { FillCol: getRequiredRGBChannel(data2.Properties.FillCol) },
              ...((_b2 = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _b2.FCol) && { FCol: getRequiredRGBChannel(data2.Properties.FCol) },
              ...((_c2 = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _c2.BCol) && { BCol: getRequiredRGBChannel(data2.Properties.BCol) }
            }
          };
        }
      } catch (error2) {
        console.log({ error: error2 });
      }
      currentLevel[finalKey] = {
        ID: data2.ID,
        ...newData
      };
    }
    reRender();
  };
  function deleteObjectsById(obj, ids) {
    ids.forEach((id2) => {
      const deleteKey = (data2, key) => {
        if (data2.hasOwnProperty(key)) {
          delete data2[key];
        } else {
          const nestedKeys = key.split(".");
          let nestedObj = data2;
          for (let i16 = 0; i16 < nestedKeys.length; i16++) {
            const nestedKey = nestedKeys[i16];
            if (nestedObj.hasOwnProperty(nestedKey)) {
              if (i16 === nestedKeys.length - 1) {
                delete nestedObj[nestedKey];
              } else {
                nestedObj = nestedObj[nestedKey];
              }
            } else {
              break;
            }
          }
        }
      };
      deleteKey(obj, id2);
    });
    console.log({ obj });
    dataRef.current = obj;
    reRender();
  }
  const fetchData = () => {
    let zoom = Math.round(window.devicePixelRatio * 100);
    const envUrl = getCurrentUrl();
    const url = URL.parse(envUrl);
    const protocol = url.protocol === "https:" ? "wss" : "ws";
    const urlPort = url.port && url.protocol !== "https:" ? `:${url.port}` : "";
    const path = url.pathname || "/";
    webSocketRef.current = new WebSocket(`${protocol}://${url.hostname}${urlPort}${path}`);
    const webSocket = webSocketRef.current;
    setSocket(webSocket);
    webSocket.onopen = () => {
      let event = JSON.stringify({
        DeviceCapabilities: {
          ViewPort: [window.innerHeight, window.innerWidth],
          ScreenSize: [window.screen.height, window.screen.width],
          DPR: zoom / 100,
          PPI: 200
        }
      });
      webSocket.send(event);
      const eventInit = JSON.stringify({
        [layout]: {
          Version: version$1.version,
          Name: version$1.name,
          URL: window.location.href
        }
      });
      webSocket.send(eventInit);
    };
    webSocket.onmessage = (event) => {
      var _a2, _b2, _c2, _d, _e2, _f, _g, _h, _i, _j, _k;
      const keys2 = Object.keys(JSON.parse(event.data));
      if (keys2[0] == "WC") {
        let windowCreationEvent = JSON.parse(event.data).WC;
        if (((_a2 = windowCreationEvent == null ? void 0 : windowCreationEvent.Properties) == null ? void 0 : _a2.Type) == "Form") {
          localStorage.clear();
          const updatedData = deleteFormAndSiblings(dataRef.current);
          dataRef.current = {};
          dataRef.current = updatedData;
          handleData(JSON.parse(event.data).WC, "WC");
          return;
        }
        if (((_b2 = windowCreationEvent == null ? void 0 : windowCreationEvent.Properties) == null ? void 0 : _b2.Type) == "MsgBox") {
          setMessageBoxData(windowCreationEvent);
          return;
        }
        setSocketData((prevData) => [...prevData, JSON.parse(event.data).WC]);
        handleData(JSON.parse(event.data).WC, "WC");
      } else if (keys2[0] == "WS") {
        const serverEvent = JSON.parse(event.data).WS;
        let value2 = null;
        const data2 = JSON.parse(getObjectById(dataRef.current, serverEvent.ID));
        console.log("WSSocket", { serverEvent, data: data2 });
        if (((_c2 = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _c2.Type) == "Edit") {
          if (serverEvent == null ? void 0 : serverEvent.Properties.hasOwnProperty("Text")) {
            value2 = serverEvent == null ? void 0 : serverEvent.Properties.Text;
          } else if (serverEvent == null ? void 0 : serverEvent.Properties.hasOwnProperty("Value")) {
            value2 = serverEvent == null ? void 0 : serverEvent.Properties.Value;
          } else if (serverEvent == null ? void 0 : serverEvent.Properties.hasOwnProperty("SelText")) {
            value2 = serverEvent == null ? void 0 : serverEvent.Properties.SelText;
          }
          const updatedProperties = {
            ...data2 == null ? void 0 : data2.Properties,
            ...serverEvent == null ? void 0 : serverEvent.Properties
          };
          return handleData(
            {
              ID: serverEvent.ID,
              Properties: updatedProperties
            },
            "WS"
          );
        }
        if (((_d = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _d.Type) == "Combo") {
          if (serverEvent == null ? void 0 : serverEvent.Properties.hasOwnProperty("SelItems")) {
            setSocketData((prevData) => [...prevData, JSON.parse(event.data).WS]);
            value2 = serverEvent == null ? void 0 : serverEvent.Properties.SelItems;
            const indextoFind = value2.indexOf(1);
            let Text2 = (_e2 = data2 == null ? void 0 : data2.Properties) == null ? void 0 : _e2.Items[indextoFind];
            return handleData(
              {
                ID: serverEvent.ID,
                Properties: {
                  ...data2 == null ? void 0 : data2.Properties,
                  SelItems: value2,
                  Text: Text2
                }
              },
              "WS"
            );
          }
        }
        setSocketData((prevData) => [...prevData, JSON.parse(event.data).WS]);
        handleData(JSON.parse(event.data).WS, "WS");
      } else if (keys2[0] == "WG") {
        const serverEvent = JSON.parse(event.data).WG;
        try {
          const refData = JSON.parse(getObjectById(dataRef.current, serverEvent == null ? void 0 : serverEvent.ID));
          const Type = (_f = refData == null ? void 0 : refData.Properties) == null ? void 0 : _f.Type;
          const errorEvent = JSON.stringify({
            WG: {
              ID: serverEvent == null ? void 0 : serverEvent.ID,
              Error: { Code: 1, Message: "ID not found", WGID: serverEvent == null ? void 0 : serverEvent.WGID }
            }
          });
          if (!Type)
            return webSocket.send(errorEvent);
          const { Properties } = refData;
          if (Type == "Grid") {
            const { Values, CurCell } = Properties;
            console.log("250 values", { Values, CurCell });
            const supportedProperties = ["Values", "CurCell"];
            const result = checkSupportedProperties(supportedProperties, serverEvent == null ? void 0 : serverEvent.Properties);
            if (!localStorage.getItem(serverEvent.ID)) {
              const serverPropertiesObj2 = {};
              serverEvent.Properties.map((key) => {
                return serverPropertiesObj2[key] = Properties[key];
              });
              const event2 = JSON.stringify({
                WG: {
                  ID: serverEvent.ID,
                  Properties: serverPropertiesObj2,
                  WGID: serverEvent.WGID,
                  ...result && result.NotSupported && result.NotSupported.length > 0 ? { NotSupported: result.NotSupported } : null
                }
              });
              return webSocket.send(event2);
            }
            const { Event } = JSON.parse(localStorage.getItem(serverEvent.ID));
            const serverPropertiesObj = {};
            serverEvent.Properties.map((key) => {
              var _a3;
              if (key === "CurCell") {
                serverPropertiesObj[key] = CurCell;
              } else {
                serverPropertiesObj[key] = Event[key] || ((_a3 = refData == null ? void 0 : refData.Properties) == null ? void 0 : _a3[key]);
              }
            });
            console.log(
              "250",
              JSON.stringify({
                WG: {
                  ID: serverEvent.ID,
                  Properties: serverPropertiesObj,
                  WGID: serverEvent.WGID,
                  ...result && result.NotSupported && result.NotSupported.length > 0 ? { NotSupported: result.NotSupported } : null
                }
              })
            );
            setSocketData((prevData) => [
              ...prevData,
              {
                ID: serverEvent.ID,
                Properties: {
                  ...Properties,
                  Values
                }
              }
            ]);
            handleData({
              ID: serverEvent.ID,
              Properties: {
                ...Properties,
                Values
              }
            });
            webSocket.send(
              JSON.stringify({
                WG: {
                  ID: serverEvent.ID,
                  Properties: serverPropertiesObj,
                  WGID: serverEvent.WGID,
                  ...result && result.NotSupported && result.NotSupported.length > 0 ? { NotSupported: result.NotSupported } : null
                }
              })
            );
          }
          if (Type == "Form") {
            const supportedProperties = ["Posn", "Size"];
            const result = checkSupportedProperties(supportedProperties, serverEvent == null ? void 0 : serverEvent.Properties);
            const serverPropertiesObj = {};
            const Form2 = JSON.parse(localStorage.getItem(serverEvent.ID));
            if (!localStorage.getItem(serverEvent.ID)) {
              const serverPropertiesObj2 = {};
              serverEvent.Properties.map((key) => {
                return serverPropertiesObj2[key] = Properties[key];
              });
              const event3 = JSON.stringify({
                WG: {
                  ID: serverEvent.ID,
                  Properties: serverPropertiesObj2,
                  WGID: serverEvent.WGID,
                  ...result && result.NotSupported && result.NotSupported.length > 0 ? { NotSupported: result.NotSupported } : null
                }
              });
              console.log(event3);
              webSocket.send(event3);
              return;
            }
            serverEvent.Properties.map((key) => {
              return serverPropertiesObj[key] = Form2[key];
            });
            const event2 = JSON.stringify({
              WG: {
                ID: serverEvent.ID,
                Properties: serverPropertiesObj,
                WGID: serverEvent.WGID,
                ...result && result.NotSupported && result.NotSupported.length > 0 ? { NotSupported: result.NotSupported } : null
              }
            });
            console.log(event2);
            webSocket.send(event2);
            return;
          }
          if (Type == "Edit") {
            const { Text: Text2 = "", Value, SelText } = Properties;
            const supportedProperties = ["Text", "Value", "SelText"];
            console.log("edit", { serverEvent, Properties, Text: Text2, local: localStorage.getItem(serverEvent.ID) });
            const result = checkSupportedProperties(supportedProperties, serverEvent == null ? void 0 : serverEvent.Properties);
            if (!localStorage.getItem(serverEvent.ID)) {
              const editValue = Text2 ? Text2 : Value;
              const isNumber2 = (_g = refData == null ? void 0 : refData.Properties) == null ? void 0 : _g.hasOwnProperty("FieldType");
              const serverPropertiesObj2 = {};
              serverEvent.Properties.forEach((key) => {
                if (key === "Text") {
                  serverPropertiesObj2[key] = editValue ? editValue.toString() : "";
                } else if (key === "Value") {
                  serverPropertiesObj2[key] = isNumber2 ? parseInt(editValue) : editValue;
                } else if (key === "SelText") {
                  serverPropertiesObj2[key] = Properties[key] ? Properties[key] : [1, 1];
                } else {
                  serverPropertiesObj2[key] = editValue;
                }
              });
              console.log(
                JSON.stringify({
                  WG: {
                    ID: serverEvent.ID,
                    Properties: serverPropertiesObj2,
                    WGID: serverEvent.WGID,
                    ...result && result.NotSupported && result.NotSupported.length > 0 ? { NotSupported: result.NotSupported } : null
                  }
                })
              );
              return webSocket.send(
                JSON.stringify({
                  WG: {
                    ID: serverEvent.ID,
                    Properties: serverPropertiesObj2,
                    WGID: serverEvent.WGID,
                    ...result && result.NotSupported && result.NotSupported.length > 0 ? { NotSupported: result.NotSupported } : null
                  }
                })
              );
            }
            const { Event } = JSON.parse(localStorage.getItem(serverEvent == null ? void 0 : serverEvent.ID));
            const { Info } = Event;
            const serverPropertiesObj = {};
            console.log("edit 2", { serverPropertiesObj });
            serverEvent.Properties.forEach((key) => {
              var _a3;
              if (key === "Value") {
                serverPropertiesObj[key] = Info;
              } else if (key === "SelText") {
                serverPropertiesObj[key] = SelText;
              } else if (key === "Text") {
                console.log("edit 3 hrere");
                const storedText = (_a3 = JSON.parse(localStorage.getItem(serverEvent == null ? void 0 : serverEvent.ID))) == null ? void 0 : _a3.Text;
                serverPropertiesObj[key] = Array.isArray(Text2 || storedText) ? Text2 || storedText : Text2 || "2";
              } else {
                serverPropertiesObj[key] = Info.toString();
              }
            });
            console.log(
              JSON.stringify({
                WG: {
                  ID: serverEvent.ID,
                  Properties: serverPropertiesObj,
                  WGID: serverEvent.WGID,
                  ...result && result.NotSupported && result.NotSupported.length > 0 ? { NotSupported: result.NotSupported } : null
                }
              })
            );
            webSocket.send(
              JSON.stringify({
                WG: {
                  ID: serverEvent.ID,
                  Properties: serverPropertiesObj,
                  WGID: serverEvent.WGID,
                  ...result && result.NotSupported && result.NotSupported.length > 0 ? { NotSupported: result.NotSupported } : null
                }
              })
            );
          }
          if (Type == "Combo") {
            const { SelItems, Items, Text: Text2 } = Properties;
            const supportedProperties = ["Text", "SelItems", "Posn", "Size"];
            const result = checkSupportedProperties(
              supportedProperties,
              serverEvent == null ? void 0 : serverEvent.Properties
            );
            if (!localStorage.getItem(serverEvent.ID)) {
              let newSelItems2 = SelItems || new Array(Items.length).fill(0);
              if (Text2) {
                const indexToChange = Items.indexOf(Text2);
                if (indexToChange >= 0) {
                  newSelItems2.fill(0);
                  newSelItems2[indexToChange] = 1;
                }
              }
              const serverPropertiesObj2 = {};
              serverEvent.Properties.map((key) => {
                serverPropertiesObj2[key] = key === "SelItems" ? newSelItems2 : key === "Text" ? Text2 : Properties[key];
              });
              const message2 = {
                WG: {
                  ID: serverEvent.ID,
                  Properties: serverPropertiesObj2,
                  WGID: serverEvent.WGID,
                  ...((_h = result == null ? void 0 : result.NotSupported) == null ? void 0 : _h.length) > 0 ? { NotSupported: result.NotSupported } : null
                }
              };
              console.log(JSON.stringify(message2));
              return webSocket.send(JSON.stringify(message2));
            }
            const { Event } = JSON.parse(localStorage.getItem(serverEvent == null ? void 0 : serverEvent.ID));
            const { Info, Size: Size2, Posn } = Event;
            let newSelItems = SelItems || new Array(Items.length).fill(0);
            if (Text2) {
              const indexToChange = Items.indexOf(Text2);
              if (indexToChange >= 0) {
                newSelItems.fill(0);
                newSelItems[indexToChange] = 1;
              }
            }
            const serverPropertiesObj = {};
            serverEvent.Properties.map((key) => {
              serverPropertiesObj[key] = key === "SelItems" ? newSelItems : key === "Text" ? Text2 : key === "Items" ? Items[Info] : Event[key];
            });
            const message = {
              WG: {
                ID: serverEvent.ID,
                Properties: serverPropertiesObj,
                WGID: serverEvent.WGID,
                ...((_i = result == null ? void 0 : result.NotSupported) == null ? void 0 : _i.length) > 0 ? { NotSupported: result.NotSupported } : null
              }
            };
            console.log(JSON.stringify(message));
            return webSocket.send(JSON.stringify(message));
          }
          if (Type == "List") {
            const { SelItems } = Properties;
            const supportedProperties = ["SelItems"];
            const result = checkSupportedProperties(supportedProperties, serverEvent == null ? void 0 : serverEvent.Properties);
            if (!localStorage.getItem(serverEvent.ID)) {
              console.log(
                JSON.stringify({
                  WG: {
                    ID: serverEvent.ID,
                    Properties: {
                      SelItems
                    },
                    ...result && result.NotSupported && result.NotSupported.length > 0 ? { NotSupported: result.NotSupported } : null,
                    WGID: serverEvent.WGID
                  }
                })
              );
              return webSocket.send(
                JSON.stringify({
                  WG: {
                    ID: serverEvent.ID,
                    Properties: {
                      SelItems
                    },
                    ...result && result.NotSupported && result.NotSupported.length > 0 ? { NotSupported: result.NotSupported } : null,
                    WGID: serverEvent.WGID
                  }
                })
              );
            }
            const { Event } = JSON.parse(localStorage.getItem(serverEvent == null ? void 0 : serverEvent.ID));
            console.log(
              JSON.stringify({
                WG: {
                  ID: serverEvent.ID,
                  Properties: {
                    SelItems: Event["SelItems"]
                  },
                  ...result && result.NotSupported && result.NotSupported.length > 0 ? { NotSupported: result.NotSupported } : null,
                  WGID: serverEvent.WGID
                }
              })
            );
            return webSocket.send(
              JSON.stringify({
                WG: {
                  ID: serverEvent.ID,
                  Properties: {
                    SelItems: Event["SelItems"]
                  },
                  ...result && result.NotSupported && result.NotSupported.length > 0 ? { NotSupported: result.NotSupported } : null,
                  WGID: serverEvent.WGID
                }
              })
            );
          }
          if (Type == "Scroll") {
            const { Thumb } = Properties;
            const supportedProperties = ["Thumb"];
            const result = checkSupportedProperties(supportedProperties, serverEvent == null ? void 0 : serverEvent.Properties);
            if (!localStorage.getItem(serverEvent.ID)) {
              console.log(
                JSON.stringify({
                  WG: {
                    ID: serverEvent.ID,
                    Properties: {
                      Thumb
                    },
                    WGID: serverEvent.WGID,
                    ...result && result.NotSupported && result.NotSupported.length > 0 ? { NotSupported: result.NotSupported } : null
                  }
                })
              );
              return webSocket.send(
                JSON.stringify({
                  WG: {
                    ID: serverEvent.ID,
                    Properties: {
                      Thumb
                    },
                    WGID: serverEvent.WGID,
                    ...result && result.NotSupported && result.NotSupported.length > 0 ? { NotSupported: result.NotSupported } : null
                  }
                })
              );
            }
            const { Event } = JSON.parse(localStorage.getItem(serverEvent == null ? void 0 : serverEvent.ID));
            const { Info } = Event;
            console.log(
              JSON.stringify({
                WG: {
                  ID: serverEvent.ID,
                  Properties: {
                    Thumb: Info[1]
                  },
                  WGID: serverEvent.WGID,
                  ...result && result.NotSupported && result.NotSupported.length > 0 ? { NotSupported: result.NotSupported } : null
                }
              })
            );
            return webSocket.send(
              JSON.stringify({
                WG: {
                  ID: serverEvent.ID,
                  Properties: {
                    Thumb
                  },
                  WGID: serverEvent.WGID,
                  ...result && result.NotSupported && result.NotSupported.length > 0 ? { NotSupported: result.NotSupported } : null
                }
              })
            );
          }
          if (Type == "Splitter") {
            const { Posn } = Properties;
            const supportedProperties = ["Posn", "Size"];
            const result = checkSupportedProperties(supportedProperties, serverEvent == null ? void 0 : serverEvent.Properties);
            if (!localStorage.getItem(serverEvent.ID)) {
              const serverPropertiesObj2 = {};
              serverEvent.Properties.map((key) => {
                return serverPropertiesObj2[key] = Properties[key];
              });
              console.log(
                JSON.stringify({
                  WG: {
                    ID: serverEvent.ID,
                    Properties: serverPropertiesObj2,
                    WGID: serverEvent.WGID,
                    ...result && result.NotSupported && result.NotSupported.length > 0 ? { NotSupported: result.NotSupported } : null
                  }
                })
              );
              return webSocket.send(
                JSON.stringify({
                  WG: {
                    ID: serverEvent.ID,
                    Properties: serverPropertiesObj2,
                    WGID: serverEvent.WGID,
                    ...result && result.NotSupported && result.NotSupported.length > 0 ? { NotSupported: result.NotSupported } : null
                  }
                })
              );
            }
            const { Event } = JSON.parse(localStorage.getItem(serverEvent.ID));
            const { Info, Size: Size2 } = Event;
            const serverPropertiesObj = {};
            serverEvent.Properties.map((key) => {
              return serverPropertiesObj[key] = key == "Posn" ? Info : Size2;
            });
            console.log(
              JSON.stringify({
                WG: {
                  ID: serverEvent.ID,
                  Properties: serverPropertiesObj,
                  WGID: serverEvent.WGID,
                  ...result && result.NotSupported && result.NotSupported.length > 0 ? { NotSupported: result.NotSupported } : null
                }
              })
            );
            return webSocket.send(
              JSON.stringify({
                WG: {
                  ID: serverEvent.ID,
                  Properties: serverPropertiesObj,
                  WGID: serverEvent.WGID,
                  ...result && result.NotSupported && result.NotSupported.length > 0 ? { NotSupported: result.NotSupported } : null
                }
              })
            );
          }
          if (Type == "SubForm") {
            const supportedProperties = ["Posn", "Size"];
            const result = checkSupportedProperties(supportedProperties, serverEvent == null ? void 0 : serverEvent.Properties);
            if (!localStorage.getItem(serverEvent.ID)) {
              const serverPropertiesObj2 = {};
              serverEvent.Properties.map((key) => {
                return serverPropertiesObj2[key] = Properties[key];
              });
              console.log(
                JSON.stringify({
                  WG: {
                    ID: serverEvent.ID,
                    Properties: serverPropertiesObj2,
                    WGID: serverEvent.WGID,
                    ...result && result.NotSupported && result.NotSupported.length > 0 ? { NotSupported: result.NotSupported } : null
                  }
                })
              );
              return webSocket.send(
                JSON.stringify({
                  WG: {
                    ID: serverEvent.ID,
                    Properties: serverPropertiesObj2,
                    WGID: serverEvent.WGID,
                    ...result && result.NotSupported && result.NotSupported.length > 0 ? { NotSupported: result.NotSupported } : null
                  }
                })
              );
            }
            const serverPropertiesObj = {};
            const SubForm2 = JSON.parse(localStorage.getItem(serverEvent.ID));
            serverEvent.Properties.map((key) => {
              return serverPropertiesObj[key] = SubForm2[key];
            });
            console.log(
              JSON.stringify({
                WG: {
                  ID: serverEvent.ID,
                  Properties: serverPropertiesObj,
                  WGID: serverEvent.WGID,
                  ...result && result.NotSupported && result.NotSupported.length > 0 ? { NotSupported: result.NotSupported } : null
                }
              })
            );
            return webSocket.send(
              JSON.stringify({
                WG: {
                  ID: serverEvent.ID,
                  Properties: serverPropertiesObj,
                  WGID: serverEvent.WGID,
                  ...result && result.NotSupported && result.NotSupported.length > 0 ? { NotSupported: result.NotSupported } : null
                }
              })
            );
          }
          if (Type == "Button") {
            const { State } = Properties;
            const supportedProperties = ["State", "Posn", "Size"];
            const result = checkSupportedProperties(supportedProperties, serverEvent == null ? void 0 : serverEvent.Properties);
            if (!localStorage.getItem(serverEvent.ID)) {
              const serverPropertiesObj2 = {};
              serverEvent.Properties.map((key) => {
                return serverPropertiesObj2[key] = key == "State" ? State ? State : 0 : Properties[key];
              });
              const event3 = JSON.stringify({
                WG: {
                  ID: serverEvent.ID,
                  Properties: serverPropertiesObj2,
                  WGID: serverEvent.WGID,
                  ...result && result.NotSupported && result.NotSupported.length > 0 ? { NotSupported: result.NotSupported } : null
                }
              });
              console.log(event3);
              return webSocket.send(event3);
            }
            const { Event } = JSON.parse(localStorage.getItem(serverEvent.ID));
            const { Value } = Event;
            const serverPropertiesObj = {};
            serverEvent.Properties.map((key) => {
              return serverPropertiesObj[key] = key == "State" ? Value : Event[key];
            });
            const event2 = JSON.stringify({
              WG: {
                ID: serverEvent.ID,
                Properties: serverPropertiesObj,
                WGID: serverEvent.WGID,
                ...result && result.NotSupported && result.NotSupported.length > 0 ? { NotSupported: result.NotSupported } : null
              }
            });
            console.log(event2);
            return webSocket.send(event2);
          }
          if (Type == "TreeView") {
            const supportedProperties = ["SelItems"];
            const result = checkSupportedProperties(supportedProperties, serverEvent == null ? void 0 : serverEvent.Properties);
            const { Event } = JSON.parse(localStorage.getItem(serverEvent.ID));
            const { SelItems } = Event;
            const event2 = JSON.stringify({
              WG: {
                ID: serverEvent.ID,
                Properties: {
                  SelItems
                },
                WGID: serverEvent.WGID,
                ...result && result.NotSupported && result.NotSupported.length > 0 ? { NotSupported: result.NotSupported } : null
              }
            });
            console.log(event2);
            return webSocket.send(event2);
          }
          if (Type == "Timer") {
            const supportedProperties = ["FireOnce"];
            const result = checkSupportedProperties(supportedProperties, serverEvent == null ? void 0 : serverEvent.Properties);
            const { Event } = JSON.parse(localStorage.getItem(serverEvent.ID));
            const { FireOnce } = Event;
            const event2 = JSON.stringify({
              WG: {
                ID: serverEvent.ID,
                Properties: {
                  FireOnce
                },
                WGID: serverEvent.WGID,
                ...result && result.NotSupported && result.NotSupported.length > 0 ? { NotSupported: result.NotSupported } : null
              }
            });
            console.log(event2);
            return webSocket.send(event2);
          }
          if (Type == "ListView") {
            const supportedProperties = ["SelItems"];
            const result = checkSupportedProperties(supportedProperties, serverEvent == null ? void 0 : serverEvent.Properties);
            const { Event } = JSON.parse(localStorage.getItem(serverEvent.ID));
            const { SelItems } = Event;
            const event2 = JSON.stringify({
              WG: {
                ID: serverEvent.ID,
                Properties: {
                  SelItems
                },
                WGID: serverEvent.WGID,
                ...result && result.NotSupported && result.NotSupported.length > 0 ? { NotSupported: result.NotSupported } : null
              }
            });
            console.log(event2);
            return webSocket.send(event2);
          }
          if (Type === "ApexChart") {
            const supportedProperties = ["SVG"];
            const { SVG: SVG2 } = Properties;
            const data2 = JSON.parse(
              getObjectById(dataRef.current, serverEvent.ID)
            );
            const event2 = JSON.stringify({
              WG: {
                ID: serverEvent.ID,
                WGID: serverEvent.WGID,
                Properties: {
                  SVG: SVG2
                }
              }
            });
            webSocket.send(event2);
            return;
          }
          if (Type === "Upload")
            return Upload.WG(wsSend, serverEvent);
          return;
        } catch (e3) {
          console.error("WG Error: ", e3);
        }
      } else if (keys2[0] == "NQ") {
        const nqEvent = JSON.parse(event.data).NQ;
        const { Event, ID: ID2, Info, NoCallback = 0 } = nqEvent;
        const appElement = getObjectById(dataRef.current, ID2);
        if (Event && Event == "Configure") {
          handleData(
            {
              ID: ID2,
              Properties: {
                ...appElement == null ? void 0 : appElement.Properties,
                Posn: [Info[0], Info[1]],
                Size: [Info[2], Info[3]]
              }
            },
            "WS"
          );
          return;
        } else if (Event && Event == "ItemDown" || Event && Event == "GotFocus") {
          if (Event && Event == "GotFocus")
            localStorage.setItem("current-focus", ID2);
          const existingData = JSON.parse(getObjectById(dataRef.current, ID2));
          const exists = ((_j = existingData == null ? void 0 : existingData.Properties) == null ? void 0 : _j.Event) && ((_k = existingData == null ? void 0 : existingData.Properties) == null ? void 0 : _k.Event.some((item) => item[0] === Event));
          if (!exists)
            return;
          const event2 = JSON.stringify({
            Event: {
              EventName: Event,
              ID: ID2,
              Info
            }
          });
          console.log(event2);
          if (NoCallback == 0)
            webSocket.send(event2);
          return;
        } else if (Event == "CellMove") {
          handleData(
            {
              ID: ID2,
              Properties: {
                CurCell: [Info[0], Info[1]]
              }
            },
            "WS"
          );
          localStorage.setItem(
            ID2,
            JSON.stringify({
              Event: {
                CurCell: [Info[0], Info[1]]
              }
            })
          );
          return;
        } else if (Event == "Select") {
          const element2 = document.getElementById(nqEvent.ID);
          if (element2)
            element2.click();
        } else if (Event == "Scroll") {
          webSocket.send(
            JSON.stringify({
              Event: {
                EventName: "Scroll",
                ID: ID2,
                Info: [Info[0], Info[1]]
              }
            })
          );
        }
        const thumbValue = Info[1];
        handleData({ ID: ID2, Properties: { Thumb: thumbValue } }, "WS");
        const element = document.getElementById(nqEvent.ID);
        element && element.focus();
      } else if (keys2[0] == "EC") {
        const serverEvent = JSON.parse(event.data).EC;
        const { EventID, Proceed } = serverEvent;
        setProceedEventArray((prev) => ({ ...prev, [EventID]: Proceed }));
        setProceed(Proceed);
        localStorage.setItem(EventID, Proceed);
      } else if (keys2[0] == "EX") {
        const serverEvent = JSON.parse(event.data).EX;
        deleteObjectsById(dataRef.current, serverEvent == null ? void 0 : serverEvent.ID);
      } else if (keys2[0] == "WX") {
        const serverEvent = JSON.parse(event.data).WX;
        const { Method, Info, WGID, ID: ID2 } = serverEvent;
        const calculateTextDimensions = (wordsArray, fontSize = 12) => {
          const scale = localStorage.getItem("fontscale");
          console.log("fontScale dimension: ", scale);
          const container = document.createElement("div");
          container.style.visibility = "hidden";
          container.style.position = "fixed";
          container.style.top = "0";
          container.style.left = "0";
          container.style.fontSize = fontSize * scale + "px";
          wordsArray.forEach((word) => {
            const span = document.createElement("div");
            span.textContent = word;
            span.style.display = "block";
            container.appendChild(span);
          });
          document.body.appendChild(container);
          const width = container.offsetWidth;
          const height = container.offsetHeight - 11;
          document.body.removeChild(container);
          return [height, width];
        };
        if (Method == "GetTextSize") {
          const joinedString = Info && Info[0];
          const font2 = JSON.parse(getObjectById(dataRef.current, Info && Info[1]));
          const fontProperties = font2 && (font2 == null ? void 0 : font2.Properties);
          const textDimensions = calculateTextDimensions(joinedString, fontProperties == null ? void 0 : fontProperties.Size);
          const event2 = JSON.stringify({ WX: { Info: textDimensions, WGID } });
          console.log(event2);
          return webSocket.send(event2);
        } else if (Method == "OnlyDQ") {
          let event2;
          if (!!(Info == null ? void 0 : Info[0])) {
            event2 = JSON.stringify({ WX: { Info: [[ID2, 150, 300]], WGID } });
          } else {
            event2 = JSON.stringify({ WX: { Info: [], "WGID": WGID } });
          }
          webSocket.send(event2);
        } else if (Method == "GetFocus") {
          const focusedID = localStorage.getItem("current-focus");
          const event2 = JSON.stringify({ WX: { Info: !focusedID ? [] : [focusedID], WGID } });
          console.log(event2);
          webSocket.send(event2);
        } else if (Method == "SetCookie") {
          Info.forEach((c6) => {
            document.cookie = c6;
          });
          webSocket.send(JSON.stringify({ WX: { Info: [], WGID } }));
        } else if (Method == "GetCookie") {
          const found = document.cookie.split("; ").map((c6) => c6.split("=")).filter((c6) => Info.includes(c6[0]));
          webSocket.send(JSON.stringify({ WX: { Info: found, WGID } }));
        } else if (Method == "SetTitle") {
          document.title = Info[0];
          webSocket.send(JSON.stringify({ WX: { Info: [], WGID } }));
        } else if (Method == "GetTitle") {
          webSocket.send(JSON.stringify({ WX: { Info: [document.title], WGID } }));
        } else if (Method == "EvalJS") {
          const results = Info.map((code) => {
            try {
              return [0, eval == null ? void 0 : (0, eval)(code)];
            } catch (e3) {
              return [-1, e3.toString()];
            }
          });
          webSocket.send(JSON.stringify({ WX: { Info: results, WGID } }));
        }
      } else if (keys2[0] == "Options") {
        handleData(JSON.parse(event.data).Options, "WC");
        console.log("label", JSON.parse(event.data).Options);
        JSON.parse(event.data).Options.ID == "Fonts" && setFontScale(JSON.parse(event.data).Options.Properties.Scale);
        JSON.parse(event.data).Options.ID == "Fonts" && console.log("label", JSON.parse(event.data).Options.Properties.Scale);
        JSON.parse(event.data).Options.ID == "Mode" && setOptions(JSON.parse(event.data).Options.Properties);
        if (JSON.parse(event.data).Options.ID == "Colors")
          setColorFunc(JSON.parse(event.data).Options.Properties.Standard);
      } else if (keys2[0] == "FormatCell") {
        const formatCellEvent = JSON.parse(event.data);
        const { FormatCell } = formatCellEvent;
        const refData = JSON.parse(getObjectById(dataRef.current, FormatCell == null ? void 0 : FormatCell.ID));
        const { Properties } = refData;
        const updatedFormattedValues = Properties == null ? void 0 : Properties.FormattedValues;
        updatedFormattedValues[FormatCell.Cell[0] - 1][FormatCell.Cell[1] - 1] = FormatCell == null ? void 0 : FormatCell.FormattedValue;
        handleData(
          {
            ID: FormatCell == null ? void 0 : FormatCell.ID,
            Properties: {
              ...refData == null ? void 0 : refData.Properties,
              FormattedValues: updatedFormattedValues
            }
          },
          "WS"
        );
      }
    };
  };
  const handleFocus = (element) => {
    const formParentID2 = findFormParentID(dataRef.current);
    if (localStorage.getItem("change-event")) {
      const { Event } = JSON.parse(localStorage.getItem("change-event"));
      const updatedEvent = {
        ...Event,
        Info: [!element.target.id ? formParentID2 : element.target.id]
      };
      let webSocket = webSocketRef.current;
      webSocket.send(JSON.stringify({ Event: { ...updatedEvent } }));
      localStorage.removeItem("change-event");
    }
  };
  console.log("App", dataRef.current);
  const setColorFunc = (colorStandardArray) => {
    const reqColors = colorStandardArray == null ? void 0 : colorStandardArray.reduce((prev, current2) => {
      return { ...prev, [current2 == null ? void 0 : current2[0]]: current2[2] };
    }, {});
    colors = { ...reqColors };
  };
  const formParentID = findFormParentID(dataRef.current);
  const handleMsgBoxClose = (button, ID2) => {
    setMessageBoxData(null);
    socket.send(JSON.stringify({ Event: { EventName: button, ID: ID2 } }));
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      AppDataContext.Provider,
      {
        value: {
          socketData,
          dataRef,
          socket,
          handleData,
          focusedElement,
          reRender,
          proceed,
          setProceed,
          proceedEventArray,
          setProceedEventArray,
          colors,
          fontScale
        },
        children: dataRef && formParentID && /* @__PURE__ */ jsxRuntimeExports.jsx(SelectComponent, { data: dataRef.current[formParentID] })
      }
    ),
    messageBoxData && /* @__PURE__ */ jsxRuntimeExports.jsx(MsgBox, { data: messageBoxData, options: options2, onClose: handleMsgBoxClose, isDesktop: (_c = (_b = (_a = dataRef == null ? void 0 : dataRef.current) == null ? void 0 : _a.Mode) == null ? void 0 : _b.Properties) == null ? void 0 : _c.Desktop })
  ] });
};
client.createRoot(document.getElementById("root")).render(/* @__PURE__ */ jsxRuntimeExports.jsx(App, {}));
